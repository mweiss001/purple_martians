Graphics, Tiles and Displays.



The game is tile based.  Each tile is 20x20.  A design decision made in 1997.

Each level is 100x100 tiles.

The visible or playable section of the level does not need to be that big.


-----------------------------------------------------
---  Tiles: -----------------------------------------
-----------------------------------------------------

Each tile is stored in an array of bitmaps called tile[1024]

From the very beginning in DOS to 2018, they were 256 color, 8 bit bitmaps.

I made my own custom palette with 15 colors, with each color being faded 16 times.

I made my own bitmap editor and palette creator and drew all my bitamps with that.

I used to save them to disk one get_pixel at a time and load them one put_pixel at a time.

I'm kind of embarassed to say I continued to do that up until 2018!

The main push to convert them came from all the work arounds I had to do in windows 7 beacuse 8 bit did not render properly in full screen modes with allegro 4.

Now they are saved as a 24bit bmp files.

I used to store different colored versions of players and doors with the main tiles.

I has since converted that to separate bitmap files for players and doors, that contain all the colored version.

Now I have:
tiles.bmp (1024 main tile storage)
player_tiles.bmp (16 colors x 19 tiles)
door_tiles.bmp (16 colors x 8 tiles x 2 types)

I read them in when the game starts and store them in actual memory bitmaps so that the contents will not be lost in the screen changes.

the main tilemap bitmaps are:
tilemap = al_create_bitmap(640, 640);
ptilemap = al_create_bitmap(380,320);
dtilemap = al_create_bitmap(160,640);

I create sub bitmaps from these so I can draw with indexes:
ALLEGRO_BITMAP *tile[NUM_SPRITES];
ALLEGRO_BITMAP *player_tile[16][32];
ALLEGRO_BITMAP *door_tile[2][16][8];

   for (int y=0; y<32; y++)
      for (int x=0; x<32; x++)
      {
         al_destroy_bitmap(tile[y*32 + x]);
         tile[y*32 + x] = al_create_sub_bitmap(tilemap, x*20, y*20, 20, 20);
      }

I have copies of the tilemaps in memory, used to restore on screen change:
M_tilemap = al_create_bitmap(640,640);
M_ptilemap = al_create_bitmap(380,320);
M_dtilemap = al_create_bitmap(160,640);



-------------------------------------------------------------------------
--- create_bmp() --------------------------------------------------------
-------------------------------------------------------------------------
- called from 'init_screen()'
- only ever called once

void create_bmp(void)
{
   // create tilemap bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);
   tilemap = al_create_bitmap(640, 640);
   ptilemap = al_create_bitmap(380,320);
   dtilemap = al_create_bitmap(160,640);

   // create memory bitmaps as temp storage for restoring tilemaps after screen change
   al_set_new_bitmap_flags(ALLEGRO_MEMORY_BITMAP);
   M_tilemap = al_create_bitmap(640,640);
   M_ptilemap = al_create_bitmap(380,320);
   M_dtilemap = al_create_bitmap(160,640);
....


-------------------------------------------------------------------------
--- load_tiles() --------------------------------------------------------
-------------------------------------------------------------------------

- tilemaps are loaded from file
- M_tilemaps are created from tilemaps
- rebuild_bitmaps()' is called

int load_tiles(void)
{

   // get main tiles
   tilemap = al_load_bitmap("bitmaps/tiles.bmp");
   if (!tilemap)
   {
      sprintf(msg, "Can't load tiles from bitmaps/tiles.bmp");
      m_err(msg);
   }
   else
   {
      al_convert_mask_to_alpha(tilemap, al_map_rgb(0, 0, 0)) ;
      al_set_target_bitmap(M_tilemap);
      al_draw_bitmap(tilemap, 0, 0, 0);
   }

   // get player tiles
   ptilemap = al_load_bitmap("bitmaps/player_tiles.bmp");
   if (!ptilemap)
   {
      sprintf(msg, "Can't load tiles from bitmaps/player_tiles.bmp");
      m_err(msg);
   }
   else
   {
      al_convert_mask_to_alpha(ptilemap, al_map_rgb(0, 0, 0)) ;
      al_set_target_bitmap(M_ptilemap);
      al_draw_bitmap(ptilemap, 0, 0, 0);
   }


   // get door tiles
   dtilemap = al_load_bitmap("bitmaps/door_tiles.bmp");
   if (!dtilemap)
   {
      sprintf(msg, "Can't load tiles from bitmaps/door_tiles.bmp");
      m_err(msg);
   }
   else
   {
      al_convert_mask_to_alpha(dtilemap, al_map_rgb(0, 0, 0)) ;
      al_set_target_bitmap(M_dtilemap);
      al_draw_bitmap(dtilemap, 0, 0, 0);
   }

   rebuild_bitmaps();
.....


-------------------------------------------------------------------------
--- rebuild_bitmaps()  --------------------------------------------------
-------------------------------------------------------------------------
- called on start and when ever screen changes
- M_tilemaps are drawn to tilemaps
- sub_bitmaps are created / recreated from tilemaps


void rebuild_bitmaps(void)
{
   // rebuild main tiles
   al_set_target_bitmap(tilemap);
   al_draw_bitmap(M_tilemap, 0, 0, 0);
   for (int y=0; y<32; y++)
      for (int x=0; x<32; x++)
      {
         al_destroy_bitmap(tile[y*32 + x]);
         tile[y*32 + x] = al_create_sub_bitmap(tilemap, x*20, y*20, 20, 20);
      }

   // rebuild player tiles
   al_set_target_bitmap(ptilemap);
   al_draw_bitmap(M_ptilemap, 0, 0, 0);
   for (int a=0; a<16; a++)
      for (int b=0; b<19; b++)
      {
         al_destroy_bitmap(player_tile[a][b]);
         player_tile[a][b] = al_create_sub_bitmap(ptilemap, b*20, a*20, 20, 20);
      }

   // rebuild door tiles
   al_set_target_bitmap(dtilemap);
   al_draw_bitmap(M_dtilemap, 0, 0, 0);
   for (int a=0; a<16; a++)
      for (int b=0; b<8; b++)
      {
         al_destroy_bitmap(door_tile[0][a][b]);
         al_destroy_bitmap(door_tile[1][a][b]);
         door_tile[0][a][b] = al_create_sub_bitmap(dtilemap, b*20,     a*20, 20, 20);
         door_tile[1][a][b] = al_create_sub_bitmap(dtilemap, b*20, 320+a*20, 20, 20);
      }
...













The level array
---------------
The level_array is a 100x100 array of integers.  
Each integer is an index to memory_bitmap[1024] (the block that is draw at that position on the level)
I have certain special ranges:
0  - 31  - empty
32 - 63  - semi-solid (players and enemies can jump through from below)
64 - 95  - bombable   (will be destroyed by bombs)
96 - 127 - breakable  (will be destroyed by bullets)
128+     - solid  


Rendering the level in the game loop.
-------------------------------------

I use 2 BITMAPS, each 2000 x 2000 pixels, called level_background and level_buffer

When a level is first loaded the background blocks are drawn on level_background. (all 10,000 tiles!)



Then every frame:

- level_buffer gets completely overwritten with a fresh copy of level_background

- everything else (players, enemies, items, lifts, bullets) is then drawn on level_buffer

- the region of level_buffer that will be shown on the screen is scaled to the back buffer

- the screen overlays are drawn to the back buffer

- flip display




This is lot of data being copied each frame, especially if the screen is zoomed out so a large portion of the entire level is shown.

To make things faster, all the bitmaps are created with ALLEGRO_NO_PRESERVE_TEXTURE.

This has no effect on the bitmaps that are redrawn every frame.

But the ones that are not, (like level background) will be redrawn if the screen changes.


void init_level_background(void) // fill level_background with blocks and lift lines
{
   al_set_target_bitmap(level_background);
   al_clear_to_color(al_map_rgb(0,0,0));
   for (int x=0; x<100; x++)
      for (int y=0; y<100; y++)
      {
         int c = l[x][y];
         if (c < NUM_SPRITES)
            al_draw_bitmap(tile[c], x*20, y*20, 0);
      }
   draw_lift_lines();
}


void get_new_background(int full)
{
   al_set_target_bitmap(level_buffer);
   if (full) al_draw_bitmap(level_background, 0, 0, 0);
   else
   {
      // this only grabs the visible region, in the interests of speed
      int x = level_display_region_x - 20; if (x < 0) x = 0;
      int y = level_display_region_y - 20; if (y < 0) y = 0;
      int w = level_display_region_w + 40; if (x+w > 2000) w = 2000-x;
      int h = level_display_region_h + 40; if (y+h > 2000) h = 2000-y;
      al_draw_bitmap_region(level_background, x, y, w, h, x, y, 0);
   }
}




On top of all this I also use a transform...



------------------------------------------------------
--- Display ------------------------------------------
------------------------------------------------------

I create my display with these settings:

al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_SUGGEST);
(most of the time I get a 32 bit, but if I get 16, it can be faster)

int flags = ALLEGRO_WINDOWED | ALLEGRO_RESIZABLE;
if (fullscreen) flags = ALLEGRO_FULLSCREEN_WINDOW | ALLEGRO_RESIZABLE;


I use these global variables:

int fullscreen = 1;

// current size and position (if windowed mode, values are same as windowed vaules)
int disp_x_curr; 
int disp_y_curr;
int disp_w_curr;
int disp_h_curr;

// size and position of windowed mode
int disp_x_wind;
int disp_y_wind;
int disp_w_wind;
int disp_h_wind;


int display_transform_double = 3;
int SCREEN_W;
int SCREEN_H;

int WX;
int WY;







-------------------------------------------
---- init_screen() ------------------------
-------------------------------------------

int init_screen(void)
{
   al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_SUGGEST);
   int flags = ALLEGRO_WINDOWED | ALLEGRO_RESIZABLE;
   if (fullscreen) flags = ALLEGRO_FULLSCREEN_WINDOW | ALLEGRO_RESIZABLE;
   al_set_new_display_flags(flags);
   display = al_create_display(disp_w_wind, disp_h_wind);

   if (!fullscreen)
   {
      disp_x_curr = disp_x_wind;
      disp_y_curr = disp_y_wind;
      al_set_window_position(display, disp_x_curr, disp_y_curr);
   }

   disp_w_curr = al_get_display_width(display);
   disp_h_curr = al_get_display_height(display);
   al_get_window_position(display, &disp_x_curr, &disp_y_curr);

   auto_set_display_transform_double();
   set_display_transform();
   set_ortho();
   create_bmp();
   set_map_var();
   return 1;
}


-------------------------------------------
---- proc_screen_change() -----------------
-------------------------------------------
called:
- when F12 is used to toggle fullscreen
- when proc_controllers() detects the window has been moved
- when I get an event: ALLEGRO_EVENT_DISPLAY_RESIZE

void proc_screen_change(int new_sw, int new_sh, int new_sx, int new_sy, int new_fs)
{
   if ((!fullscreen) && (new_fs)) //  changing to fullscreen
   {
      fullscreen = 1;
      al_set_display_flag(display, ALLEGRO_FULLSCREEN_WINDOW, 1);
      al_get_window_position(display, &disp_x_curr, &disp_y_curr);
      disp_w_curr = al_get_display_width(display);
      disp_h_curr = al_get_display_height(display);
      auto_set_display_transform_double();
      rebuild_bitmaps();
      save_config();
      Redraw = 1;
   }
   else if ((fullscreen) && (!new_fs)) //  changing away from fullscreen
   {
      fullscreen = 0;
      al_resize_display(display, disp_w_wind, disp_h_wind);
      al_set_display_flag(display, ALLEGRO_FULLSCREEN_WINDOW, 0);
      al_set_window_position(display, disp_x_wind, disp_y_wind);

      al_get_window_position(display, &disp_x_curr, &disp_y_curr);
      disp_w_curr = al_get_display_width(display);
      disp_h_curr = al_get_display_height(display);
      auto_set_display_transform_double();
      rebuild_bitmaps();
      save_config();
      Redraw = 1;
   }
   else if (!fullscreen)
   {
      if ((new_sw != disp_w_curr) || (new_sh != disp_h_curr)) // window has been resized
      {
         al_acknowledge_resize(display);
         disp_w_curr = disp_w_wind = al_get_display_width(display);
         disp_h_curr = disp_h_wind = al_get_display_height(display);
         auto_set_display_transform_double();
         rebuild_bitmaps();
         save_config();
         Redraw = 1;
     }
     if ((new_sx != disp_x_curr) || (new_sy != disp_y_curr)) // window has been moved
     {
        disp_x_curr = disp_x_wind = new_sx;;
        disp_y_curr = disp_y_wind = new_sy;;
        save_config();
     }
  }
}


void auto_set_display_transform_double(void)
{
   display_transform_double = 1;

   if (disp_w_curr > 1023) display_transform_double = 2;
   if (disp_h_curr > 1023) display_transform_double = 2;

   if (disp_w_curr < 1024) display_transform_double = 1;
   if (disp_h_curr < 700) display_transform_double = 1;

   if (level_editor_running) display_transform_double = 1;

   if (help_screens_running)
   {
      if (disp_w_curr > 1279) display_transform_double = 2;
      if (disp_w_curr < 1280) display_transform_double = 1;
   }
}

void set_display_transform(void)
{
   al_set_target_backbuffer(display);
   SCREEN_W = disp_w_curr/display_transform_double;
   SCREEN_H = disp_h_curr/display_transform_double;
   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, SCREEN_W, SCREEN_H, 1.0);
   al_use_projection_transform(&trans);
}


void get_new_screen_buffer(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(al_map_rgb(0,0,0));

   int alp = active_local_player;
   int c = players[alp].color;

   // draw frame in local player's color
   for (int x = 0; x < BORDER_WIDTH; x++)
      al_draw_rectangle(x+0.5f, x+0.5f, (SCREEN_W-1-x)+0.5f, (SCREEN_H-1-x)+0.5f,  palette_color[c + (x * 16)], 1);

   // default place and size to draw on screen_buffer
   int bw = BORDER_WIDTH;
   int sbx = bw;
   int sby = bw;
   int sbw = SCREEN_W-bw*2;
   int sbh = SCREEN_H-bw*2;

   // how big is the entire level after scale factor is applied?
   int sls = (int) ((float)2000 * scale_factor_current); // sls = scaled level size

   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      sbw = sls;         // new screen_buffer blit width = sls
      sbx += a/2;        // new screen_buffer blit xpos
   }

   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      sbh = sls;         // new screen_buffer blit height = sls
      sby += a/2;        // new screen_buffer blit ypos
   }

   // find the size of the source screen from actual screen size and scaler
   int SW = (int)( (float)(SCREEN_W - bw *2) / scale_factor_current);
   int SH = (int)( (float)(SCREEN_H - bw *2) / scale_factor_current);
   if (SW > 2000) SW = 2000;
   if (SH > 2000) SH = 2000;

   // find where to grab the source screen from based on the players position
   int PX = al_fixtoi(players[alp].PX) + 10;
   int PY = al_fixtoi(players[alp].PY) + 10;

   // this method always has the player in the middle of the screen
   //int WX = PX - SW/2 -10; // set window from PX, PY
   //int WY = PY - SH/2 -10;

   // this method has a hysteresis rectangle in the middle of the screen where there is no scroll
   int x_size = SW / 8; // larger number is smaller window
   int y_size = SH / 12;

   if (WX < PX - SW/2 - x_size) WX = PX - SW/2 - x_size; // hit right edge
   if (WX > PX - SW/2 + x_size) WX = PX - SW/2 + x_size; // hit left edge
   if (WY < PY - SH/2 - y_size) WY = PY - SH/2 - y_size; // hit bottom edge
   if (WY > PY - SH/2 + y_size) WY = PY - SH/2 + y_size; // hit top edge

   // correct for edges
   if (WX < 0) WX = 0;
   if (WY < 0) WY = 0;
   if (WX > (2000 - SW)) WX = 2000 - SW;
   if (WY > (2000 - SH)) WY = 2000 - SH;

   // used by get_new_background to only get what is needed
   level_display_region_x = WX;
   level_display_region_y = WY;
   level_display_region_w = SW;
   level_display_region_h = SH;

   // this is the what all the previous calculation have been building up to
   al_draw_scaled_bitmap(level_buffer, WX, WY, SW, SH, sbx, sby, sbw, sbh, 0);

}

can I make WX and WY static to this function only??, no, also used by stimp and stamp







































