timers


I use three timers:

ALLEGRO_TIMER * fps_timer;
ALLEGRO_TIMER * sec_timer;
ALLEGRO_TIMER * mnu_timer;



fps_timer is used to control the speed of the game

sec_timer is used to count the actual frames per second

mnu_timer is used to control the speed of the menu




int initial_setup(void)
{

   // create timers
   fps_timer = al_create_timer(1 / (float) frame_speed );
   sec_timer = al_create_timer(1);
   mnu_timer = al_create_timer(.01);

   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mnu_timer));

   // start timers
   al_start_timer(fps_timer);
   al_start_timer(sec_timer);
   al_start_timer(mnu_timer);
...



------------------------------------
--- mnu_timer ---------------------- 
------------------------------------

The speed of the menu loop is controlled by mnu_timer.

The menu runs in a loop that processes the menu and also processes the logo animation.

In this loop proc_controller() is called.

If the global variable 'game_exit' == 1, then proc_controller() knows the menu is running.

In that case proc_controller() will block until it gets a timer event.

int proc_controllers()
{
   int ret = 0;
   int done = 0;
   int menu_timer_wait = 1;

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
         if (al_get_next_event(event_queue, &ev)) ret = proc_events(ev, ret);
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
          if (menu_timer_wait) done = 0;
      }
   }
   return ret;
}


------------------------------------
--- sec_timer ---------------------- 
------------------------------------

sec_timer is used to count the actual frames per second and the number of skipped frames in the last second

the algorithm uses the following global varaibles:

int passcount;
int last_fps_passcount = 0;
int actual_fps;

players1[active_local_player].frames_skipped
int last_frames_skipped = 0;
int frames_skipped_last_second;


void proc_frame_delay(void)
{
   if (al_get_timer_count(sec_timer) > 0)
   {
      al_set_timer_count(sec_timer, 0); // reset_second_timer
      actual_fps = passcount - last_fps_passcount;
      last_fps_passcount = passcount;
      frames_skipped_last_second = (players1[active_local_player].frames_skipped - last_frames_skipped);
      last_frames_skipped = players1[active_local_player].frames_skipped;
   }
...

  
   
------------------------------------
--- fps_timer ---------------------- 
------------------------------------
   
fps_timer is used to control the speed of the game
   
The global variable 'frame_speed' sets the frame rate of the game
int frame_speed= 40;
   
fps_timer is set as a reciprocal of frame_speed like this:

al_set_timer_speed(fps_timer, 1/(float)frame_speed);



The game speed is controlled by the function: 'proc_frame_delay()'

void proc_frame_delay(void)
{
   if (speed_testing) // draw every frame no matter how fast or slow it is
   {
      draw_frame = 1;
      al_set_timer_count(fps_timer, passcount);
   }
   else
   {
      if (passcount <=  al_get_timer_count(fps_timer)) // skip drawing frame
      {
         draw_frame = 0;
         players1[active_local_player].frames_skipped++;
      }
      else draw_frame = 1;
      while (passcount > al_get_timer_count(fps_timer)); // delay if too far ahead so timer catches up
   }
}

When the game is running normally, proc_frame_delay() will block until fps_timer catches up to the next passcount.

When the game is lagging, proc_frame_delay() will skip drawing for the current frame.

In speed test mode:
- every frame is drawn, no matter what
- there is no waiting for the timer, it runs as fast as it can





------------------------------------
--- Speed adjust during netgame. ---
------------------------------------

During a netgame the server runs at 40 fps and is the master timing source.

The clients all make small adjustments to their speeds to try to maintain the
proper timing relation to the server.

The value 'server_lead_frames' is a global int and can be set in the config file,
but should be left at its default value of 1.
This means that the clients try to stay 1 frame behind the server.

The packet 'sdat' (server_data) is sent from the server to a client when the server has data
for that client, or if there is no data, an empty 'sdat' is sent periodically for sync purposes.

The 'sdat' packet is time stamped with the passcount of the server.
The client compares this to its own passcount and makes speed adjustments as follows.

void client_timer_adjust(void)
{
   int p = active_local_player;
   if (passcount == players1[p].last_sdat_lpc)  // only if just received sdat; use for sync
   {
      players1[p].server_sync = players1[p].last_sdat_fpc - passcount;
      int fps_chase = frame_speed + players1[p].server_sync - server_lead_frames;
      al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));
   }
}






































