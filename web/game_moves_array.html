<!doctype html>
<title>Game Moves Array</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">
        
<mdw_lhs_nav>
<div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#created_by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#created_with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#license" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#external links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#old_versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#history" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div>
</mdw_lhs_nav>
            
        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh1>Technical Code Descriptions</mh1><hr>
            </header>

<mh8>Game Moves Array</mh8>
<mh7>Overview</mh7>

<mh3>

The game moves array is the heart of the entire game control method.

</mh3>
            
<br><mh7>The Game Moves Array</mh7>
<mh3>
There is actually another layer before the actual players controls are set.

The game_moves array contains an entry for every frame that a player's controls change.

int game_moves[1000000][4];

The game_moves array can hold 1 million game moves.

1 million might seem excessive but at 40fps:
8 players x 40 possible control changes per second (if the players could actually press the controls that fast!)
= 320 game_moves per second
or 19200 game_moves per minute
or 1,152,000 game_moves per hour

Each game_move entry has 4 elements:
0 - frame  (the frame the change occured on)
1 - player (the player whose controls changed)
2 - type   (5 is for normal game move)
3 - data   (bitfield of the controls)

The game_moves array does not have an entry for every frame, only when a player's controls have changed.

here is some raw data: </mh3>
<pre><code class="language-cpp">
16
5
0
2
frame:16
player:0
type:5 (move)
data: 2 

25
5
0
34
frame:25
player:0
type:5 (move)
data: 34 (32 + 2) 

26
5
0
50
frame:26
player:0
type:5 (move)
data: 50 (32 + 16 + 2) 

27
5
0
18
frame:27
player:0
type:5 (move)
data: 18 (16 + 2)</code></pre>

<mh3>Here is a nicely formatted version:</mh3>
<pre><code class="language-cpp">[  16][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  25][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[  26][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[  27][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]</code></pre>

<mh3>The data field is a bitfield of the controls and is set like this:</mh3>

<pre><code class="language-cpp">void set_comp_move_from_player_key_check(int p)
{
   int cm = 0;
   if (key[players1[p].left_key])  cm += 1;
   if (key[players1[p].right_key]) cm += 2;
   if (key[players1[p].up_key])    cm += 4;
   if (key[players1[p].down_key])  cm += 8;
   if (key[players1[p].jump_key])  cm += 16;
   if (key[players1[p].fire_key])  cm += 32;

   // if menu key ignore everything else and set to 127
   if (key[players1[p].menu_key]) cm = 127;
   if (key[ALLEGRO_KEY_ESCAPE]) cm = 127;
   players1[p].comp_move = cm;
}</code></pre>

<mh3>
This is how game_move entries are added in single player mode:
</mh3>

<pre><code class="language-cpp">set_comp_move_from_player_key_check(p);
if (players1[p].comp_move != players1[p].old_comp_move)
{
   players1[p].old_comp_move = players1[p].comp_move;
   add_game_move(frame_num, 5, p, players1[p].comp_move);
}

void add_game_move(int pc, int type, int data1, int data2)
{
   game_moves[game_move_entry_pos][0] = pc;
   game_moves[game_move_entry_pos][1] = type;
   game_moves[game_move_entry_pos][2] = data1;
   game_moves[game_move_entry_pos][3] = data2;
   game_move_entry_pos++;
}</code></pre>

<mh3>
Finally here is how the actual controls in the player struct are set from game_move array:
</mh3>

<pre><code class="language-cpp">void set_controls_from_game_move(int p)
{
   // this will search back from entry position until it finds the first 'move' type
   // entry that matches the player and is not in the future

   int found = 0;
   for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
      if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
         if (game_moves[g][0] <= frame_num) // check to make sure its not in the future
         {
            set_controls_from_comp_move(g);
            game_move_current_pos = g; // for savegame running only
            g = 0; // break out of loop
            found = 1;
         }
   if (!found) clear_keys(p); // if no match found (no move entry for player in entire game move array)
}

void set_controls_from_comp_move(int g)
{
   int p = game_moves[g][2];
   int t = game_moves[g][3];
   clear_keys(p);
   if (t == 127)
   {
      players[p].menu = 1;
      t -= 127;
   }
   if (t > 31)
   {
      t -= 32;
      players[p].fire = 1;
   }
   if (t > 15)
   {
      t -= 16;
      players[p].jump = 1;
   }
   if (t > 7)
   {
      t -= 8;
      players[p].down = 1;
   }
   if (t > 3)
   {
      t -= 4;
      players[p].up = 1;
   }
   if (t > 1)
   {
      t -= 2;
      players[p].right = 1;
   }
   if (t > 0)
   {
      t -= 1;
      players[p].left = 1;
   }
}</code></pre>

<br><mh7>Netgame</mh7>
<mh3>
In netgame things are done differently.

For clients, when a control changes happens, it's NOT put in the client's local game_moves array, instead it's sent to the server:
</mh3>

<pre><code class="language-cpp">set_comp_move_from_player_key_check(p);
if (players1[p].comp_move != players1[p].old_comp_move)
{
   players1[p].old_comp_move = players1[p].comp_move;
   int fpc = frame_num + control_lead_frames;  // add  to frame_num
   int cm = players1[p].comp_move;

   Packet((char *)"cdat");
   PacketAddByte(p);
   PacketAdd4Bytes(fpc);
   PacketAddByte(cm);
   ClientSend(packetbuffer, packetsize);
}</code></pre>

<mh3>
When the server receives the packet, the client's game move is puts in the server's master game_moves array.
Unless its late, in which case it's dropped.
</mh3>

<pre><code class="language-cpp">if(PacketRead((char *)"cdat"))
{
   int p = PacketGetByte();
   int pc = Packet4ByteRead();
   int cm = PacketGetByte();

   // how far ahead is the frame_num for this move, compare to server frame_num
   int c_sync = players1[p].c_sync = pc - frame_num;

   if (c_sync >= 0) add_game_move(pc, 5, p, cm); // add to game_move array
   else                                          // unless late, then drop and inc error
   {
      players1[p].c_sync_err++;
   }
}</code></pre>


<mh3>
The server then syncs its master game_moves array back to all the clients, by sending sdat packets
</mh3>

<pre><code class="language-cpp">void server_send_sdat(void)
{
   for (int p=1; p < NUM_PLAYERS; p++)
      if (players[p].control_method == 2)
      {
         if (players1[p].game_move_entry_pos < game_move_entry_pos) // client needs more data
         {
            int start_entry = players1[p].game_move_entry_pos;
            int end_entry = game_move_entry_pos;
            int num_entries = end_entry - start_entry;
            if (num_entries > 100) num_entries = 100;

            if ((players1[p].server_last_sdat_sent_start != start_entry) || // dif start pos
               (players1[p].server_last_sdat_sent_num != num_entries))      // dif num entries
            {

               players1[p].server_last_sdat_sent_start = start_entry;
               players1[p].server_last_sdat_sent_num = num_entries;

               Packet((char *)"sdat");
               PacketAddByte(p);
               PacketAdd4Bytes(frame_num);
               PacketAdd4Bytes(start_entry);
               PacketAddByte(num_entries);

               for (int x=start_entry; x < start_entry + num_entries; x++)
               {
                  PacketAdd4Bytes(game_moves[x][0]); // frame_num
                  PacketAddByte(game_moves[x][1]); // type
                  PacketAddByte(game_moves[x][2]); // data 1
                  PacketAddByte(game_moves[x][3]); // data 2
               }
               ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
            }
         }
      }
}</code></pre>


<mh3>
When a client gets an sdat packet, it adds the game_moves to its local game_moves array:
</mh3>

<pre><code class="language-cpp">if(PacketRead((char *)"sdat"))
{
   int sp = PacketGetByte();
   players1[p].last_sdat_fpc = Packet4ByteRead();
   int start_entry = Packet4ByteRead();
   int num_entries = PacketGetByte();

   players1[p].last_sdat_lpc = frame_num; // client's local frame_num of last sync packet
   int nep = start_entry + num_entries; // new entry position
   if (nep > game_move_entry_pos) // only enter if they are newer
   {
      for (int x=start_entry; x < nep; x++)
         read_game_step_from_packet(x, 1);
      game_move_entry_pos = nep;
   }
}
void read_game_step_from_packet(int x, int clf_check)
{
   // read from the packet
   int g0 = Packet4ByteRead();
   int g1 = PacketGetByte();
   int g2 = PacketGetByte();
   int g3 = PacketGetByte();

   // put in the game array
   game_moves[x][0] = g0;
   game_moves[x][1] = g1;
   game_moves[x][2] = g2;
   game_moves[x][3] = g3;

  int cs;
  if (clf_check)
  {
     int p = active_local_player;
     cs = g0 - frame_num;                     // calculate c_csync
     if (cs < 0 ) players1[p].c_sync_err++;   // check for error
     if (cs < players1[p].c_sync_min)         // check and set min
        players1[p].c_sync_min = cs;
  }
} </code></pre>

<mh3>
If a game move is entered that is marked with a frame_num that has alreay passed, that is really bad!

The client will never be able to apply that move because it was received too late.
However, the server has applied it, and synced it to other clients.

The client's game will almost certainly be out of sync.  There are, however, methods to recover from this.

See the detailed code description for netgame.

</mh3>


<br><mh7>Special Game Moves</mh7>
<mh3>    

game_moves[x][0]; // frame_num
game_moves[x][1]; // game_move type
game_moves[x][2]; // data 1
game_moves[x][3]; // data 2

// type 5 (player control change)
game_moves[x][2]; // player number
game_moves[x][3]; // comp move

// type 6 (level done)
game_moves[x][2]; // not used
game_moves[x][3]; // not used

// type 1 (player state and color)
game_moves[x][2]; // player number
game_moves[x][3]; // val (state, color, quit reason)


if val > 63 - make player inactive and log quit reason

if (val > 63) // player becomes inactive
{
   players1[p].active = 0;
   players1[p].quit_reason = val;
}

if val 1-15 - make player active and set color

if ((players[p].active == 0) && (val > 0) && (val < 16))
{
   players[p].active = 1;
   players[p].color = val;
}
     
				  
</mh3>






            
               <footer>
                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2018, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
            </footer>

        </div>
    </body>

</html>
