Events, keyboard, mouse joystick


I really missed the way that Allegro 4 handled input, so I recreated parts of it.


------------------------------------------------------------
--- keyboard -----------------------------------------------
------------------------------------------------------------

In A4 there is an array of keys (key[]) that is updated asynchronously.
You could do stuff like:  if (key[KEY_S]) ...

So in A5 I made my own array and set it with events that I get from the keyboard like this:

bool key[ALLEGRO_KEY_MAX]; // global variable

if (ev.type == ALLEGRO_EVENT_KEY_DOWN) key[ev.keyboard.keycode] = true;
if (ev.type == ALLEGRO_EVENT_KEY_UP)   key[ev.keyboard.keycode] = false;

Now in A5 I can do somthing similar:  if (key[ALLEGRO_KEY_S]) ...


------------------------------------------------------------
--- mouse --------------------------------------------------
------------------------------------------------------------

I do something similar for the mouse:

// global variables
int mouse_x = 0;
int mouse_y = 0;
int mouse_z = 0;
int mouse_dx = 0;
int mouse_dy = 0;
int mouse_dz = 0;
int mouse_b1 = 0;
int mouse_b2 = 0;
int mouse_b3 = 0;
int mouse_b4 = 0;

if (ev.type == ALLEGRO_EVENT_MOUSE_WARPED)
{
   mouse_x = ev.mouse.x;
   mouse_y = ev.mouse.y;
}
if (ev.type == ALLEGRO_EVENT_MOUSE_AXES)
{
   mouse_x = ev.mouse.x;
   mouse_y = ev.mouse.y;
   mouse_z = ev.mouse.z;
   mouse_dx = ev.mouse.dx;
   mouse_dy = ev.mouse.dy;
   mouse_dz = ev.mouse.dz;
}
if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_DOWN)
{
   if (ev.mouse.button == 1) mouse_b1 = 1;
   if (ev.mouse.button == 2) mouse_b2 = 1;
   if (ev.mouse.button == 3) mouse_b3 = 1;
   if (ev.mouse.button == 4) mouse_b4 = 1;
}
if (ev.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP)
{
   if (ev.mouse.button == 1) mouse_b1 = 0;
   if (ev.mouse.button == 2) mouse_b2 = 0;
   if (ev.mouse.button == 3) mouse_b3 = 0;
   if (ev.mouse.button == 4) mouse_b4 = 0;
}



------------------------------------------------------------
--- joystick -----------------------------------------------
------------------------------------------------------------

I do something really weird for the joystick.  I've done it for many years.

Basically I take a section of usused key codes (I use from 128 to 167)
and I use them for the joystick input.

char *key_names[] =
{
  (char*) "(none)",     (char*) "A",         (char*) "B",         (char*) "C",
  (char*) "D",          (char*) "E",         (char*) "F",         (char*) "G",
  (char*) "H",          (char*) "I",         (char*) "J",         (char*) "K",
  (char*) "L",          (char*) "M",         (char*) "N",         (char*) "O",
  (char*) "P",          (char*) "Q",         (char*) "R",         (char*) "S",
  (char*) "T",          (char*) "U",         (char*) "V",         (char*) "W",
  (char*) "X",          (char*) "Y",         (char*) "Z",         (char*) "0",
  (char*) "1",          (char*) "2",         (char*) "3",         (char*) "4",
  (char*) "5",          (char*) "6",         (char*) "7",         (char*) "8",
  (char*) "9",          (char*) "PAD 0",     (char*) "PAD 1",     (char*) "PAD 2",
  (char*) "PAD 3",      (char*) "PAD 4",     (char*) "PAD 5",     (char*) "PAD 6",
  (char*) "PAD 7",      (char*) "PAD 8",     (char*) "PAD 9",     (char*) "F1",
  (char*) "F2",         (char*) "F3",        (char*) "F4",        (char*) "F5",
  (char*) "F6",         (char*) "F7",        (char*) "F8",        (char*) "F9",
  (char*) "F10",        (char*) "F11",       (char*) "F12",       (char*) "ESCAPE",
  (char*) "KEY60",      (char*) "KEY61",     (char*) "KEY62",     (char*) "BACKSPACE",
  (char*) "TAB",        (char*) "KEY65",     (char*) "KEY66",     (char*) "ENTER",
  (char*) "KEY68",      (char*) "KEY69",     (char*) "BACKSLASH", (char*) "KEY71",
  (char*) "KEY72",      (char*) "KEY73",     (char*) "KEY74",     (char*) "SPACE",
  (char*) "INSERT",     (char*) "DELETE",    (char*) "HOME",      (char*) "END",
  (char*) "PGUP",       (char*) "PGDN",      (char*) "LEFT",      (char*) "RIGHT",
  (char*) "UP",         (char*) "DOWN",      (char*) "PAD /",     (char*) "PAD *",
  (char*) "PAD -",      (char*) "PAD +",     (char*) "PAD DELETE",(char*) "PAD ENTER",
  (char*) "PRINTSCREEN",(char*) "PAUSE",     (char*) "KEY94",     (char*) "KEY95",
  (char*) "KEY96",      (char*) "KEY97",     (char*) "KEY98",     (char*) "KEY99",
  (char*) "KEY100",     (char*) "KEY101",    (char*) "KEY102",    (char*) "PAD =",
  (char*) "KEY104",     (char*) "KEY105",    (char*) "KEY106",    (char*) "KEY107",
  (char*) "KEY108",     (char*) "KEY109",    (char*) "KEY110",    (char*) "KEY111",
  (char*) "KEY112",     (char*) "KEY113",    (char*) "KEY114",    (char*) "KEY115",
  (char*) "KEY116",     (char*) "KEY117",    (char*) "KEY118",    (char*) "KEY119",
  (char*) "KEY120",     (char*) "KEY121",    (char*) "KEY122",    (char*) "KEY123",
  (char*) "KEY124",     (char*) "KEY125",    (char*) "KEY126",    (char*) "KEY127",

   // joystick equivalents
   // 128-
          (char*) "joy1-up", (char*) "joy1-down",(char*) "joy1-left",(char*) "joy1-right",
          (char*) "joy1-b0", (char*) "joy1-b1",  (char*) "joy1-b2",  (char*) "joy1-b3",
          (char*) "joy1-b4", (char*) "joy1-b5",  (char*) "joy1-b6",  (char*) "joy1-b7",
          (char*) "joy1-b8", (char*) "joy1-b9",  (char*) "joy1-b10", (char*) "joy1-b11",
          (char*) "joy1-b12",(char*) "joy1-b13", (char*) "joy1-b14", (char*) "joy1-b15",
   // 148-
          (char*) "joy2-up", (char*) "joy2-down",(char*) "joy2-left",(char*) "joy2-right",
          (char*) "joy2-b0", (char*) "joy2-b1",  (char*) "joy2-b2",  (char*) "joy2-b3",
          (char*) "joy2-b4", (char*) "joy2-b5",  (char*) "joy2-b6",  (char*) "joy2-b7",
          (char*) "joy2-b8", (char*) "joy2-b9",  (char*) "joy2-b10", (char*) "joy2-b11",
          (char*) "joy2-b12",(char*) "joy2-b13", (char*) "joy2-b14", (char*) "joy2-b15",

//  (char*) "KEY128",    (char*) "KEY129",    (char*) "KEY130",    (char*) "KEY131",
//  (char*) "KEY132",    (char*) "KEY133",    (char*) "KEY134",    (char*) "KEY135",
//  (char*) "KEY136",    (char*) "KEY137",    (char*) "KEY138",    (char*) "KEY139",
//  (char*) "KEY140",    (char*) "KEY141",    (char*) "KEY142",    (char*) "KEY143",
//  (char*) "KEY144",    (char*) "KEY145",    (char*) "KEY146",    (char*) "KEY147",
//
//  (char*) "KEY148",    (char*) "KEY149",    (char*) "KEY150",    (char*) "KEY151",
//  (char*) "KEY152",    (char*) "KEY153",    (char*) "KEY154",    (char*) "KEY155",
//  (char*) "KEY156",    (char*) "KEY157",    (char*) "KEY158",    (char*) "KEY159",
//  (char*) "KEY160",    (char*) "KEY161",    (char*) "KEY162",    (char*) "KEY163",
//  (char*) "KEY164",    (char*) "KEY165",    (char*) "KEY166",    (char*) "KEY167",

  (char*) "KEY168",    (char*) "KEY169",    (char*) "KEY170",    (char*) "KEY171",
  (char*) "KEY172",    (char*) "KEY173",    (char*) "KEY174",    (char*) "KEY175",
  (char*) "KEY176",    (char*) "KEY177",    (char*) "KEY178",    (char*) "KEY179",
  (char*) "KEY180",    (char*) "KEY181",    (char*) "KEY182",    (char*) "KEY183",
  (char*) "KEY184",    (char*) "KEY185",    (char*) "KEY186",    (char*) "KEY187",
  (char*) "KEY188",    (char*) "KEY189",    (char*) "KEY190",    (char*) "KEY191",
  (char*) "KEY192",    (char*) "KEY193",    (char*) "KEY194",    (char*) "KEY195",
  (char*) "KEY196",    (char*) "KEY197",    (char*) "KEY198",    (char*) "KEY199",
  (char*) "KEY200",    (char*) "KEY201",    (char*) "KEY202",    (char*) "KEY203",
  (char*) "KEY204",    (char*) "KEY205",    (char*) "KEY206",    (char*) "KEY207",
  (char*) "KEY208",    (char*) "KEY209",    (char*) "KEY210",    (char*) "KEY211",
  (char*) "KEY212",    (char*) "KEY213",    (char*) "KEY214",    (char*) "LSHIFT",
  (char*) "RSHIFT",    (char*) "LCTRL",     (char*) "RCTRL",     (char*) "ALT",
  (char*) "ALTGR",     (char*) "LWIN",      (char*) "RWIN",      (char*) "MENU",
  (char*) "SCROLLLOCK",(char*) "NUMLOCK",   (char*) "CAPSLOCK"
};

In my array key[], when a key is pressed, that value in array is set TRUE
and when the key is released its set FALSE.

I do the exact same thing with joystick inputs. When the joystick control is
pressed I set its values in the key array TRUE, and when released, FALSE.

This method makes it easier to set up the controller bindings for the game.

For example, the game control <FIRE> could be mapped to a keyboard key like "C"
or a joystick control like "joy-b5", and the code to detect that would be the same.
I just check if that array element is set.

When I display or change the key bindings I just use the char array above,
and both keys and joystick bindings show a description.


Here is how I use events to set joystick controls in the key[] array

if (ev.type == ALLEGRO_EVENT_JOYSTICK_AXIS)
{
   int jy = getJoystickNum(ev.joystick.id);
   int jo = 0; // offset
   if (jy == 0) jo = 0;
   if (jy == 1) jo = 20;
   int ax = ev.joystick.axis;
   float pos = ev.joystick.pos;
   if (ax == 0) // x axis
   {
      key[130+jo] = false;
      key[131+jo] = false;
      if (pos > 0) key[131+jo] = true;
      if (pos < 0) key[130+jo] = true;
   }
   if (ax == 1) // y axis
   {
      key[128+jo] = false;
      key[129+jo] = false;
      if (pos > 0) key[129+jo] = true;
      if (pos < 0) key[128+jo] = true;
   }
}
if (ev.type == ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN)
{
   int jy = getJoystickNum(ev.joystick.id);
   int sc = get_scan_code_from_joystick(jy, 1, ev.joystick.button);
   key[sc] = true;
}
if (ev.type == ALLEGRO_EVENT_JOYSTICK_BUTTON_UP)
{
   int jy = getJoystickNum(ev.joystick.id);
   int sc = get_scan_code_from_joystick(jy, 1, ev.joystick.button);
   key[sc] = false;
}

int getJoystickNum(ALLEGRO_JOYSTICK* joy) // Thanks Edgar Reynaldo!
{
   for (int i=0; i<al_get_num_joysticks(); ++i)
   {
      if (joy == al_get_joystick(i)) {return i;}
   }
   return -1;
}

int get_scan_code_from_joystick(int joy, int button, int num)
{
   int ret = 0;
   int base = 128;
   if (joy == 0) base = 128;
   if (joy == 1) base = 148;
   if (button) ret = num + 4;
   return base + ret;
}


-----------------------------------------------------

game player input...

I make a clear distinction between the key_bindings and the controls

In the player struct, for each player we have the key bindings:
int up_key, down_key, left_key, right_key, jump_key, fire_key, menu_key;

And then we have variables to indicate if a particular control is active for that frame:
int up, down, left, right, jump, fire, menu;

For single player games, these control are set from the key array.
- the event loop is processed and any input events are used to set the key[] array
- the key[] array is compared to the key bindings and used to set players controls
- the game logic uses the controls to move the player

This may seem more complicated than it needs to be, but it is needed for when we are
doing things more complicated than single player.

For example, to run a demo game from a file, the keys are read from a file and then used
to set the controls, bypassing the key binding stuff completely.

There is actually another layer....

The game moves array.

int game_moves[1000000][4];

0 - frame
1 - player
2 - type
3 - data

Every frame if the players input has changed, an entry is put in the game moves array
indexed by the frame:

here is some raw data:

16
5
0
2
frame:16
player:0
type:5 (move)
data: 2 

25
5
0
34
frame:25
player:0
type:5 (move)
data: 34 (32 + 2) 

26
5
0
50
frame:26
player:0
type:5 (move)
data: 50 (32 + 16 + 2) 

27
5
0
18
frame:27
player:0
type:5 (move)
data: 18 (16 + 2) 

here is a nicely formatted version
[  16][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  25][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[  26][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[  27][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]


The data field is a bitfield of the controls and is set like this:

void set_comp_move_from_player_key_check(int p)
{
   int cm = 0;
   if (key[players1[p].left_key])  cm += 1;
   if (key[players1[p].right_key]) cm += 2;
   if (key[players1[p].up_key])    cm += 4;
   if (key[players1[p].down_key])  cm += 8;
   if (key[players1[p].jump_key])  cm += 16;
   if (key[players1[p].fire_key])  cm += 32;

   // if menu key ignore everything else and set to 127
   if (key[players1[p].menu_key]) cm = 127;
   if (key[ALLEGRO_KEY_ESCAPE]) cm = 127;
   players1[p].comp_move = cm;
}


Here is how game_move entries are added:

set_comp_move_from_player_key_check(p); // but don't set controls !!!
if (players1[p].comp_move != players1[p].old_comp_move)
{
   players1[p].old_comp_move = players1[p].comp_move;
   add_game_move(passcount, 5, p, players1[p].comp_move);
}

void add_game_move(int pc, int type, int data1, int data2)
{
   game_moves[game_move_entry_pos][0] = pc;
   game_moves[game_move_entry_pos][1] = type;
   game_moves[game_move_entry_pos][2] = data1;
   game_moves[game_move_entry_pos][3] = data2;
   game_move_entry_pos++;
}


This is how every mode sets controls from game_move array:

void set_controls_from_game_move(int p)
{
   // this will search back from entry position until it finds the first 'move' type
   // entry that matches the player and is not in the future

   int found = 0;
   for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
      if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
         if (game_moves[g][0] <= passcount) // check to make sure its not in the future
         {
            set_controls_from_comp_move(g);
            game_move_current_pos = g; // for savegame running only
            g = 0; // break out of loop
            found = 1;
         }
   if (!found) clear_keys(p); // if no match found (no move entry for player in entire game move array)
}





All this is necessary for netgame.
In that mode, control changes do not directly go into the game_moves array,
they are sent to the server and synced back to clients with all the other players moves.







































