

------------------------------------------------
20180314 pi day

OK here I am converting to Allegro 5

imported the project from .dev into code::blocks

removed all e_ files and n_ files

in pm.h undefined sound DUMB netplay

now lets see if I can get it to compile...

first thing in that the new allegro headers cant be found:
fixed that..

fixed has been replaced with al_fixed???

when I'm doing things like this should I not do it for my entire project?

yes...

fixed -> al_fixed
BITMAP -> ALLEGRO_BITMAP
destroy_bitmap -> al_destroy_bitmap

DIALOG gone from 5
disable for now, maybe get EGG_DIALOG later

PALLETE ????? ditch it

END_OF_FUNCTION(inc_timer_passcount);

void inc_timer_passcount()
{
   timer_passcount++;
}
END_OF_FUNCTION(inc_timer_passcount);

void second_timer()
{
   fps = passcount - last_fps_passcount;
   last_fps_passcount = passcount;

   frames_skipped_last_second = (players1[active_local_player].frames_skipped - last_frames_skipped);
   last_frames_skipped = players1[active_local_player].frames_skipped;
}
END_OF_FUNCTION(second_timer);


   LOCK_VARIABLE(timer_passcount);
   LOCK_FUNCTION(inc_timer_passcount);

   LOCK_VARIABLE(fps);
   LOCK_VARIABLE(last_fps_passcount);

   // this is for the fps
   LOCK_FUNCTION(second_timer);
   install_int_ex(second_timer, BPS_TO_TIMER(1));



it looks like the old timers, called a function...
where the new ones generate an event


I only have 2 timers:
1 to count actual frames per second
1 to control the frame rate
both are only used in the game loop
I'm having trouble thinking why I want to do this with events...

one solution is to spawn another thread that does nothing but update passcount

or in my loop, at the frame delay I can wait until i get an event...

al_create_timer
ALLEGRO_TIMER *al_create_timer(double speed_secs)

Allocates and initializes a timer.
If successful, a pointer to a new timer object is returned, otherwise NULL is returned.
speed_secs is in seconds per "tick", and must be positive. The new timer is initially stopped.
Usage note: typical granularity is on the order of microseconds, but with some drivers might only be milliseconds.

See also: al_start_timer, al_destroy_timer

al_start_timer


al_get_timer_count
int64_t al_get_timer_count(const ALLEGRO_TIMER *timer)
Source Code

Return the timer's counter value. The timer can be started or stopped.

See also: al_set_timer_count

I think with this i don't need events at all



'fps_timer' will be the name of my new timer

ALLEGRO_TIMER * fps_timer = al_create_timer(0.025);


"timer_passcount" used to be the variable that got incremented in the
old timer loop.

now it will be al_get_timer_count(fps_timer);


void al_set_timer_speed(ALLEGRO_TIMER *timer, double new_speed_secs)
Set the timer's speed, i.e. the rate at which its counter will be incremented when it is started.
This can be done when the timer is started or stopped.
If the timer is currently running, it is made to look as though the speed change occurred precisely at the last tick.

void al_set_timer_count(ALLEGRO_TIMER *timer, int64_t new_count)
Set the timer's counter value. The timer can be started or stopped.
The count value may be positive or negative, but will always be incremented by +1 at each tick.


disable the fps per second one for now...
commented out in main



change the timer:

add global and extern in pm.h
ALLEGRO_TIMER * fps_timer ;

create timer in initial setup:
fps_timer = al_create_timer(1/fps_passcount_timer);


look for all mentions of timer_passcount and replace with al_get_timer_count(fps_timer);
or set...  done




sprintf() needed <stdio.h>?? why didn't it need it before??'


config is all fucked.. more more int float string, now its all string
will need to make convertors...atoi and itoa...etc


also I need to load the config file first...

where do I do these things in my program?

right after allegro_init

set_config_file("pm.cfg");


why don't I load it in initial setup
and destroy right after.

whenever I want to save a change i will need to load the file
make the change and save it.


i should have one function that saves everything to config
and also one that loads everything

what do i do about defaults??

make my own load data from config fucntion




----------
fixtoi --done
fixtof -- done
itofix - done
ftofix - done

rest all chnged to al_rest

al_create_bitmap done all



scrn.cpp
killed most of screen setup

just make a 800x600 window

global and externed
ALLEGRO_DISPLAY *display = NULL;


   display = al_create_display(640, 640);
   if(!display) {
      fprintf(stderr, "failed to create display!\n");
      return -1;
   }


blit( src, dst, 0, 0, dx, dy, src->w, src->h)	al_draw_bitmap( src, dx, dy, 0)
blit( src, dst, sx, sy, dx, dy, sw, sh)	al_draw_bitmap_region( src, sx, sy, sw, sh, dx, dy, 0)
blit


first set al_set_target_bitmap

screen_buffer will need to be replaced with the back buffer

what do i do with SCREEN_H and W??
global and extern SCREEN_H



al_get_display_width
int al_get_display_width(ALLEGRO_DISPLAY *display)
Source Code

Gets the width of the display. This is like SCREEN_W in Allegro 4.x.

See also: al_get_display_height

al_get_display_height
int al_get_display_height(ALLEGRO_DISPLAY *display)


made scrn.cpp compile by gutting it...


sound compiles...

player compiles


now i'm in menu how am i going to do key input??

void al_get_keyboard_state(ALLEGRO_KEYBOARD_STATE *ret_state)


// Returns whether or not a specified key is being pressed
bool key_pressed(int key)
{
   ALLEGRO_KEYBOARD_STATE s;
   al_get_keyboard_state(&s);
   return al_key_down(&s, key);
}
This was a function I wrote for Deluxe Pacman 2 to wait for a keypress or xxxx amount of milliseconds before continuing (this is the trimmed down version)...

#SelectExpand
  1// Waits a specified time (in ms, 1000=1s) for a key to be pressed.
  2// Will also respond if a mouse or joystick button is clicked.
  3// If the time passes before a key/mouse/joystick is pressed, the function returns
  4// If the time specified is zero, the function will wait indefinitely.
  5bool wait_for_keypress(double wait_time)
  6{
  7   double ts = al_get_time(); // time stamp
  8   double elapsed_time;
  9
 10   al_flush_event_queue(event_queue);
 11
 12   bool done = false;
 13
 14   // Wait until the specified time passes or a key is pressed.
 15   do {
 16      al_wait_for_event(event_queue, &event);
 17
 18      if(event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
 19         shut_down(); // free resources
 20         exit(0);
 21      }
 22
 23      else if(wait_time && event.type == ALLEGRO_EVENT_TIMER) {
 24         elapsed_time = al_get_time() - ts;
 25         if(elapsed_time >= wait_time) return false;
 26      }
 27
 28      // Wait for key to be pressed and released to continue
 29      else if(event.type == ALLEGRO_EVENT_KEY_UP) {
 30         if(event.keyboard.keycode == ALLEGRO_KEY_ESCAPE) return true;
 31         else done = true;
 32      }
 33
 34      // And if a key wasn't pressed, maybe a mouse button was...
 35      else if(event.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
 36         done = true;
 37      }
 38   }
 39   while(!done);
 40
 41   return false;
 42}
---


maybe I can register an event loop once in my program and then use it for menus
and whatever as well as the main game loop...


where am i??

either in menu or in loop


i got menu to compile

loop compiles..


now in lifts...
what am i going to do about color?

I'll make my own palette, with hookers and blackjack...

I can even still call it palette color...

all I need is the seed for each color...

make an array of colors:

ALLEGRO_COLOR mC.pc[256];
mC.pc[0]  = al_map_rgb(  0,   0,    0); // black
mC.pc[1]  = al_map_rgb(191, 108,  232); // alt purple 1
mC.pc[2]  = al_map_rgb(136,  32,  172); // alt purple 2
mC.pc[3]  = al_map_rgb(60,  127,  255); // alt blue
mC.pc[4]  = al_map_rgb(224,  28,   72); // alt red
mC.pc[5]  = al_map_rgb(255,   0,  232); // pink
mC.pc[6]  = al_map_rgb(255,  191, 127); // taan
mC.pc[7]  = al_map_rgb(255,  127,   0); // orange
mC.pc[8]  = al_map_rgb(127,    0, 255); // original purple
mC.pc[9]  = al_map_rgb(  0,  255, 127); // alt green
mC.pc[10] = al_map_rgb(255,    0,   0); // red
mC.pc[11] = al_map_rgb(  0,  255,   0); // green
mC.pc[12] = al_map_rgb(  0,    0, 255); // blue
mC.pc[13] = al_map_rgb(  0,  255, 255); // lt blue
mC.pc[14] = al_map_rgb(255,  255,   0); // yellow
mC.pc[15] = al_map_rgb(255,  255, 255); // white

for (int x=1; x<16; x++)
{
   int c = (x+1)*16 - 1;
   mC.pc[x*16]  = al_map_rgb(c, c, c);
}

this is my old fade proc

         int x;
         int cn = b1_color;
         float ns = 15;
         for (x=0; x<ns; x++)
         {
            pallete[cn+(x*16)].r = (unsigned char) ( pallete[cn].r * (1 - (x/ns)) );
            pallete[cn+(x*16)].g = (unsigned char) ( pallete[cn].g * (1 - (x/ns)) );
            pallete[cn+(x*16)].b = (unsigned char) ( pallete[cn].b * (1 - (x/ns)) );
         }



it seems to work good..

i just had a thought...
all this stuff I have always been doing with the way i set up my palette...
its just basically an alpha channel...
by adding 16 to the color i decrease the alpha because that s how i set up my palette


im just testing things in mtest for now...

so far I have

load sprit
drawing primitives
made my own palettte
textout

I really need to figure out keyboard input


make an event loop...done...

it looks like the example i followed show an easy way to re-implement the old mI.key[KEY_*] fucntionality

first of all i need to create mI.key[256] with names for all the actual keys

i want to reuse as much as possible....

al5 aleady has somthing like this...ALLEGRO_KEY_*

looks like I can already if I use
bool pressed_keys[ALLEGRO_KEY_MAX];
pressed_keys[key_code] = true;


---------------
create my own array like:

bool mI.key[ALLEGRO_KEY_MAX];

now in my event loop get key downs and up events, run function to set my array

the only thing i won't be able to do is while(mI.key[KEY_ESC]);

unless i process in that loop..

am i getting lost here??

what do I need to do to make my menu work

make an event loop in initial setup..
register screen and keyboard events
poll it in the menu

ok im ready to go back to the game....

lift color is what I was working on

add primitives to game

patch my colors into the game...done


lifts now compiles


can i do a global replace for textout??

al_draw_text(font, color, x, y, ALLEGRO_ALIGN_CENTRE, msg);

i might need to specify a display or bitmap..

items compiles

fnx compiles

file compiles by commenting everything out...

emove compiles


on to control

I have to do something about keyboard input...

- set up event loop and hook keyboard up to it

process the event queue in proc_controls...

i want a non blocking way to look for events...

control done...

bullets done

yfilecom..done

now.. remove all other files from project and try to compile...


got as far as trying to start a game...


i can run the game..with lots of problems..

rotation of bitmaps..

players bitmap not filled
filled but need top change colors

control does not works.fixed

items do not show...fixed

make scaler work...


make function keys work...
re-enable function keys
scaler works
speed no

up screen res to 1024 768 for now


make lift prox rect work
mostly done..just need to patch in vertical name when rtext is fixed

do the transparency of player properly

where should I do transparency?

when I created the bitmaps on load??

does it make any sense to keep color 0 in there??



convert mask to alpha at bitmap load and also when making player bitmaps

now do door bitmaps...done...


now fix item draw.

door done..

now key in ans..


what is left to do for item draw:
key in final seq...
stretch draw for bombs


now make enemy draw better...

I fixed the rotating conversion from fixed to float

I am having trouble converting my rotations
what point do i pivot on??

it was as simple as setting the center pivot point to 10,10
and then offsetting the pos x and y by 10

works for player too...!!

i want to get speed working again.. and top display..
ok done...

time for a backup and work...


20180316 7:45

seems like I'm skipping a lot of frames...

rocket draw...fixed

removing blocks with key or breakable leaves lines..fixed

bullets alpha looks good...

block walker block to show...done



frame and title to show frame...done

that is using the backbuffer, instead of screen buffer
i think I should do this in all cases anyway
its an extra layer of complexitry to do both..

frame during game...done
this uses the screen buffer

run the menu using proc controls..done

still needs some work...




game seems to run slow...
can i run it wide open

like in speed test...

still only get like 20 fps

make the fps skipped per sec and actual

how??


create a second timer
check it in proc frame delay



looks like draw item and set draw item shape are high up on the profiler list...

also _mcount private??


i get 22-23 fps
with item_draw_disabled I can get 29-30 fps


everything seems slow...


20 fps base

- get new background 28
- draw items 28
- both 38

also
- draw enemy 56
- draw lift 56
- draw player

no dif

draw pbullets is really bad... why???
no its not that...
that was just the last thing i disabled

with all these disabled i get 170fps

         // these all draw on level_buffer
//         get_new_background();


//         draw_lifts();
//         draw_items();
//         draw_enemy();
//         draw_ebullets();
//         draw_pbullets();
//         draw_screen_msg();
//         draw_players();


as soon as any one of them is enabled it drops to 50


all those functions have in common is:
al_set_target_bitmap(level_buffer);


set this:
al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);

made things a lot faster...

now...


base 32
no item draw 52
no enemy draw 90
all others but get background no change
get background (all disabled) 256


I guess i was mistaken about memory_bitmaps
with allegro 5 they are slow, and video bitmaps are the way to go...


next, why is draw items so slow...

-------------

my bitmap are created with 4 byte per pixel and 32 bits per format

lets try to half that...


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA); ..fails
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works





base 40 fps with get_new_background only


al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
90

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
94

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
102



base 22 fps all

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
32

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
28

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34



draw items does a weird thing were it gets the bitmap to draw in dtemp
if i disable that it gets faster...






tried creating display with windowed, resizeable window no fps diff

fullscreen window went from 32fps to 28
screen size went from 1024x768 to 2048x1152

actual full screen was about the same..


fixed item draw to not use dtemp

new base 1024x768 windows all on
52 fps

enemy draws with dtemp too...fixed
new base 1024x768 windows all on
80 fps


draw enemy is completely done

draw items need to have stretch implemented...
for bombs and moving keys


i think draw items is done, but i would like to simplify it...
rot is used by key and rocket only...
stretch is used by key only, and maybe explosion??
key uses 11 for scale 10 for rot (/10)
rocket uses 10 for rot
lit bomb uses 10 for scale ()/ 100)
if I change:
lit bomb to use 11 to scale..
and make all these / 100
other items uses 11 and 10...
leave this for now




item draw and enemy draw are done, game runs at good speed

let make the menu better...

keys left and right need holdoff...
how about if menu is started with those keys pressed, wait for release...


menu and start screen are all fixed..

lets do the health display and progress bar...done

now free men...done

now frame..done

now small text on door bitmaps...


im going to make or use two bitmaps to do this...

1014 in.
1015 out.

do this when creating door bitmaps
small text for doors is done


now how about controller setup

maybe i should do the save config first...


201801318 5:00 I did a lot yesterday...


today I want to:
finish cfg file
controller setup
remove use of screen buffer in game and switch to backbuffer
sound
help

add to all error msg, native dialog pop up

test keys is done
most of controls is done, still left
key names...done

joystick..


use the same key struct as keys

in controll set the appropriate key...


its looking good,


only works for first joystick right now...

i'm not sure how to do more..

the joystick struct does not correspond to id..
leave it for now
edgar reynaldo posted a solution...

code is good now...








lets do some sound...


scalers were from 0-9

a typical example for bullet is:

(180 * se_scaler)/9

(180/255)  = .71 * (float) se_scaler / 9


sounds are coming along nicely..

i need a way to stop them, especially fuse hiss...

// this plays pm.xm just fine...time to kill DUMB!!!!

   temp_song_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
   al_attach_audio_stream_to_mixer(temp_song_stream, al_get_default_mixer());

nowhere in the sources is dumb found!!!

make a seperate mixer for se and st and make it work with scalers

do i need sound on/off???

just patch it in the mixer somehow


im having hard time with config files


make load do nothing but get values and test limits

then call save to set menu's and whatever else

save also called when program changes values


done....



remove use of screen buffer in game and switch to backbuffer


mostly done, do the rest as it get uncommented


i want to fix mtextout done
bottom message and level done is good...

now I want to fix tsw()...done



rtextout done...
screen message done...
join_quit_done...



20180318..got a lot done today....


20180319



native error messages..done

screen change by dragging...done, it was easy...
hot key for full screen F12..done..

changing volume when sound off causes crash..fixed
fps to show up on menu to start...fixed

next to do...

file selectors
help
graphical level select
mdw_logo and splash screen
new menu for all of my option that need setting

20180319 0650


stimp and stamp done


change proc_controls to return int
0 normal return
not 0 = scan code of keypress

mdw logo is done... looks a little thin...

i could spend a lot of time making the logo look awesome...

i would like to make the thickness automatic based on the size...
i would like to do some fading with real colors instead of palette..

done

now patch in the splash screen toggle...

do i have to reload everthing from config?  why not??

mdw_logo and splash screen done...

menu redraws map every frame
this takes time.

when on options menu is not drawn and mdw_ans run much faster...

could i also re-purpose proc_controllers() to do delay?
i could think of my proc_controllers() as my event loop processor...

maybe later...


20180320 6:50

next to do:
help
graphical level select
new menu for all of my option that need setting



20180321 6:55

native file select working...
paths were a bitch.. lots of conversions and checks
full path is used, might break run game from command line...
demo mode has been fixed also

bug in changing scale, leaves artifacts if smaller than entire screen.
fixed, in get new background, clear to color after setting backbuffer..

bug: demo mode can be cancelled with any key except ESC, just starts new demo
run game can be cancelled with any key, make it just esc..fixed
demo timeout not reset..done

figure out how to use code blocks to make a nice backup solution..

20180321 1200

next to do:
help
graphical level select
new menu for all of my option that need setting
timer to make menus run at same speed

help is coming along nicely...
help is completley done...20180321 16:45


next to do:
graphical level select
new menu for all of my options that need setting
timer to make menus run at same speed
some way of saving the screen size...
netplay
overlay screens


20180322 6:50
graphical level select is done..., but...
doesn't work with mouse...never did anyway only keys
cant handle screen size change..fixed
used global Redraw...


20180322 10:00

next to do:
timer to make menus run at same speed
new menu for all of my options that need setting
some way of saving the screen size...
netplay
overlay screens


timer to make menus run at same speed
should I block in proc_controllers() ???
yes but only for menu..

menu timer things is working good now...

next
overlay screens
netplay
new method for all of my options that need setting
some way of saving the screen size...



network


libnet.h
where should i put it? in my local stuff?? why not..seem to work

zlib was found without me doing anything...
comes with mingw..
version 1.2.11, January 15th, 2017

everything compiles because I have NETPLAY undefined....
now I have tons...
replace allegro error with m_err

now everything compiles, i just need the library...

C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a

link with:
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libwsock32.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libz.a

compiles and links...

need to fix the timer adjust in client...done...

now I need to fix many, many text lines in overlay...done...

now lunch and some real work...
12:40

hooked up the mouse to the event loop...
used it to make adjust spline work...






tested netplay with i990 server and old version 6 on m7667...worked perfectly..



tried to compile on i990 and dir struct if different
mingw is in C:\al5


i like my i990 version better
codeblocks, mingw and allegro are all in c:\AL5

C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a


actually i can do better than that:

C:\al5\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw32\i686-w64-mingw32\lib\libnet.a


compiles on both machines goodly now...



net game works between 2 a5 games

save and load server_ip to cfg file...done


now add screen stuff to logging...


what is screen stuff going to look like now?

same:
sx, sy
scale_factor
show_splash_screen


add:
window x pos, y pos
full_screen


lose
gfx_card
color_depth??
auto_full_screen


-----
done...now save and load them in config..done


now make them work...

what comes first?
init screen or get config?? fixed..

reads on init just fine

save on change

Question about ALLEGRO_FULLSCREEN_WINDOW

I am trying to save the window size and position, so that it will
persist when the game is started again.

Mostly everything is working good, except for a few minor things:

Here is what works:

- I create a display with a certain width and height
- then I let the user resize and move the window
- I save the display size and position in my config file
- It comes back perfectly the next time the game is run


Here is what doesn't:

When I switch to ALLEGRO_FULLSCREEN_WINDOW and back,
the window uses the values that were used to create the display
not the window size that it previously was

I can store my changed position, and then when I change back
- restore the position (easy)
- resize the display (takes a whole other resize)

What I would really like to do, is be able to modify the values
in the display structure, so that switching back, goes to the values
that were there before I switched into ALLEGRO_FULLSCREEN_WINDOW,
and not the ones used when creating the display.


From the manual:

"The passed width and height are only used if the window is switched
out of fullscreen mode later but will be ignored initially."


I suppose I could just destroy and re-create the display, but that
seems like a bit of overkill.


Does anyone have any advice on how I can achieve what I'm trying to do here?


---------------

I have a thought...

instead of changing to fullscreen using the screen thingy
i could just resize it my self to max size...


// moved all the screen change code to one place


variables

display position (relative to desktop)

disp_x_curr (either wind in windowed mode or 0 in fullscreen mode)
disp_y_curr

disp_x_wind (use when restoring from fullscreen)
disp_y_wind

disp_w_curr (either wind or full)
disp_w_wind
disp_w_full



it seems to work, but still takes a while to resize...

now i need a reliable way to get the desktop width and height

how about I create a fullscreen window, grab the w and h then switch out and resize


also my window keeps creeping up....fixed


how can i make reloading bitmaps faster...

store them in memory??

ok


first load puts them in both

next loads from mem to vid...


---------------------------
20180324 0500

cleaned up the screen code a lot
made separate functions to show flags, option, etc..

created temp memory bitmap for reloading..

fill them at creation

sprit player door
doesnt seem any faster

what if i make them all sub_bitmaps and just restore the parent??

first make a video and memory bitmap to store the tiles 640 x 640
then create memory bitmaps with clone_bitmap

seems much faster...

now players and doors...


first....

create them and save them to disk as bitmaps.. just like tiles

what size...


players 19 x 16 = 380 x 320

doors 16 x 8 x 2 = 320 x 320

doors 8 x 32 or (160 x 640)



looking good...

permanently save IN OUT to tilemap..

can I save tilemap??

haven't since a4
done..
my saves now are 24bit bmp and are 3x the old size of 8 bit...


shit is super fast now...



bugs:

resizing display in help, need to reset last line...done

coming out of help, need to redraw menu map
if in game exit, screen change has to recreate the level buffer too.
it should be doing that already...
draw_level..but blocks are gone????
only if screen changed during help...
what does load level do that i don't do...
cant tell...
i know that the bitmaps are getting reloaded...
initl2000 is getting called
l2000 is blank, but why????
at the end of help the target bitmap is cleared....!!!!!
fixed

help screen bitmaps are gone when resized
used global Redraw to fix this...

rtext for lifts..done in game..maybe some in level editor i'll get later

save scaler when changed, i think it is...done

create cfg file if none exists...done



-----------------------------
20180324 0936

coming along real good now...

new to do:
do something with screen size menu thing...not needed

save game...

method to change options...
try menu??

splash_screen_on...dont save the current value
make another called splash_screen_done for current stuff

extern int show_splash_screen;
extern int splash_screen_done;
done..........

bug, when on options menu, change screen then go back to main menu
stuff is getting drawn on level buffer, no l2000
i could make l2000 set cabk buffer back...
but shouldn't other make sure its drawing on right thing??
done.. at start of menu, set target...





ALLEGRO_MENU *menu = al_create_menu();
ALLEGRO_MENU *file_menu = al_create_menu();
al_append_menu_item(file_menu, "Exit", FILE_EXIT_ID, 0, NULL, NULL);
al_append_menu_item(menu, "File", 0, 0, NULL, file_menu);
al_set_display_menu(display, menu);

al_register_event_source(queue, al_get_default_menu_event_source());
al_wait_for_event(queue, &event);

if (event.type == ALLEGRO_EVENT_MENU_CLICK) {
   if (event.user.data1 == FILE_EXIT_ID) {
      exit_program();
   }
}

I have set everything in the menu that I can...
basically only bools...

I would really like to set:
server IP, fuck it, do it from commandline...

works great, except i get random hard crashes...

bug; clear keys at level done

music loop only plays once



lets try it on more machines...

XP???
the procedure entry point _time32 could not be located in the
dynamic link library msvcrt.dll

10...works good...
still get crashes from options menu toggle....


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...

key shifts....



make it so that you can't put the window off the screen

fix the fake keypress mode...

make overlay have an opaque background...done


make it so that you can't put the window off the screen
only on first start...
only in windowed...
done


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...


make run game work from command line..done

finish active player list on run game overlay..done


key shifts done
done for level inc dec
done for speed inc dec
what else is there?? ...log file viewer

blind_save_game_moves(1);
done
now text version...done
now we just need the file selector version :()
done


random hard crashes after using menu toggles
fixed by not creating second display


save_log_file();
log_file_viewer
done
20180324 1039

i have got a lot done today...!!


bug; clear keys at level done
added clear key array to start mode

map..done


screenshot.. done but PRINTSCREEN does not work. had to use PAUSE
fixed

I have been thinking overnight....

I have a couple of big issues...
- speed up the game so it doesn't skip frames
- fix the bug I'm still having about wrong player input...






lets look at the bitmaps i'm using...



first of all the display

display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
---------------------------------

the important stuff is:

ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_COLOR_SIZE:32
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888

now let look at some bitmaps i create like l2000 and level_buffer


pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


lets try creating a display with ALLEGRO_OPENGL
crashed...
ALLEGRO_OPENGL_3_0 starts but both that and ALLEGRO_DIRECT3D_INTERNAL
are listed...

abandon this for now


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE)

desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:5
ALLEGRO_GREEN_SIZE:6
ALLEGRO_BLUE_SIZE:5
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:11
ALLEGRO_GREEN_SHIFT:5
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:16
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


the bitmaps don't seem to have changed..
the game seems to run faster


can i do a 24??


desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
ALLEGRO_FRAMELESS
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP

exactly the same as 32 bit


OK go back to 16 and lets look at bitmaps


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_ARGB_8888


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
fails to create


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_RGB_565
works but has no alpha...duh!

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA)
fails to create

what if i made l2000 and level buffer 16 with no alpha

that seems to work...

lets test and see the dif..

display 16 or 32
l2000 and level_buffer 16 no alpha


fullscreen 2048x1152
d32 l32  (55-60fps)
d16 l32  (55-60fps)
d16 l16  (58-62fps) slightly better


what is the bottleneck?

is is the huge l2000 to level_buffer each frame??


what if I made that only do a region??
let try and see if it gets faster...

//   al_draw_bitmap(l2000, 0, 0, 0);
   al_draw_bitmap_region(l2000, 0, 0, 1000, 1000, 0, 0, 0);

that got way faster...like 100-110

lets only do it for the section that maps to the screen...



what are SH, SW, WX, WY?

WY, WY are global but are used in
seem to be used only in stimp, stamp, and get_new_screen_buffer

SW, SH
used locally in set_scale_factor, get_new_screen_buffer, stimp and stamp


make global to tell what region on l2000 is currently being shown

call them:

int level_display_region_x;
int level_display_region_y;
int level_display_region_w;
int level_display_region_h;

that seems to be a lot faster

map on menu is messed

set in stimp and stamp

no, unless in a game do it all..

use game_exit?? yes

this all seems great and seem a lot faster

lets test...



speed test
ill need to redo it...
i should just run it wide open and manually adjust the screen to start...

nv59 starts out fullscreen 1600x1200 at >100fps then drops to less than 40 in 15s
sometimes jumps to 80


nv59 sp  w 200 drops to 100
nv59 sp  f 80 drops to 35

nv59 demo w 60 drops to 35
nv59 demo f 20

i990 sp   600w 100f
i990 demo 180w 72f

m7667 can do 386 fps in a window!!! and 200 fullscreen

eid can do 800 in windows and 400 fullscreen

demo mode why slower???

disabled all screen overlays, should not be that..
disabled rungame_key_check()
changed proc_game_move() look back thing
all no diff

going back...

I have a new idea about speed test.

run game, or demo and record fps every second

then adjust screen resolution on the fly...

make a pretty graph...


name and screen resolution in screen title...done

make get new background get a little larger..done
what order is stuff drawn in??


log file viewer file select
make a new file... zlog.cpp
do it....done....


redraw map when leaving controller menu
test keys...fixed...


bomb's explosion animation seq is too low, center it better
looks good to me...








level_editor

bring in the files...e_editor

coming along goodly....


status window creates new bitmap every time its drawn
make it draw itself every time...
now dont need code to draw its bmp or even its bitmap...


status and select window are now perfect...
1 day later even more perfect...
removed all bitmaps they draw on.
only one function for each, draw and process
disable resizing of blocks and special sub windows


moving on...


pop up menu is transparent..make background opaque...done


next...zoom full screen...

looking good...
i can copy and paste

file stuff disabled for now

screen size change messes with text button positions

clear disabled until erase lifts brought back..done

blocks on off not updating fsel?? looks good now...


new backup

20180328 0700




should I make my own file select dialog?
I hate the way the native windows one looks...

i would have to implement a list box...

what if I just make a wrapper for the gui so i can call it in one line_draw_modelike I used to:

      FILE *filepntr;
      extern char sel_filename[500];
      sprintf(sel_filename, "sel\\");
      if (file_select_ex("Save Selection", sel_filename, "sel", 500, 0, 0))
      {
         filepntr = fopen(sel_filename,"w");




re_implement file_select_ex as
mw_file_select(const char * title, char * filename, const char * ext, ALLEGRO_COLOR col);

works great, add option save  and force extension..done..

i could re-do my file access to use the allegro methods...maybe when I've got too much time on my hands...


re do it for rungame save...no that has a special case where i only need the filename and I add my own extensions .gm and .txt

OK whats left in zoom full screen???

random...done

brf...done...

look like zoom fullscreen is totally done..

so is everything in e_editor...

next ...

viewers...will be huge...

but first:

status and select window positions when screen changes

where does db and lefsm get changed when screen size changes??
all done in set map var...

after screen resize items and enemies are gone?
try draw big..


backup...
20180329-0700



object viewer is looking very good
map move too...



--------------------
20180330 0700

item viewer
creators
pop message editor
save and load
all done

next big thing...lifts


lifts is all done except for text...

replace all alert with native msg...


//      gui_fg_color = mC.pc[14];  gui_bg_color = mC.pc[14+224];
//      alert("Error creating lift step:", (char)NULL, "40 steps is the maximum", "OK", (char)NULL, (char)NULL, (char)NULL);
//      gui_fg_color = mC.pc[9]; gui_bg_color = mC.pc[0];

         al_show_native_message_box(display,
               "Error", "No creator exists for the current item type",
               "Copy from an existing item of that type, or get one from the selection window",
                NULL, ALLEGRO_MESSAGEBOX_ERROR);




now alert3

if (alert("Move the key's", "block range also?","","Move", "Leave", 'M', 'L')==1)

if (al_show_native_message_box(display,
               "Move?", "Move the key's", "block range also?",
                NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION );


if (al_show_native_message_box(display,
            "Move?", "Move the key's block range also?", NULL, NULL,
             ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)




level viewer is mostly done...

it used a trick where the grid was not redrawn

in order to make it work now, i'll need a temp bitmap
what size...?? 1000 x 1000

e_lev is all done:

next to do:

text input for lift...


glt is totally done too...


the only files that are not back in the project are:
e_bitmap
e_guifnx
and they will probably not come back....
pde is mostly disabled too...



kill all scrn_buffer...
153 refs...
all done except for some unused re-size code in special
also fix all clips..



draw pop message on item viewer leaves artifacts
but only when switching from one message to another
why does it not redraw then?
as far as i can tell, it should redraw every frame..

it was because draw pop message set target to something else


sproingy adjust...done
crosshairs line 16 inside rect
928 for highlighted rect
text entry box done!!!


help quits to far..trap esc or mouseb...done

make screen adjust work with level editor and les
looks good in zfs, obj and lift viewers...

make les adjustable in le done

used F2, same as speed testing in game

I need a variable to tell me if i'm in the level editor

level_editor_running done

mouse off map in main editor...done





lots done over long weekeknd

new backup...
20180401 1025

mouse shown during game and menu screens...done
make save level have filename automatically filled in...done



I am new to the whole blender thing and have spent many hours trying
to figure out what I though would be a simple task.

I am trying to draw a bitmap onto the backbuffer and blend it with the
backbuffer.

This code from the examples works great:

al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

But my source bitmap has an alpha channel, and I can't figure out how
to get that respected...no matter how many different combination I try
I always get the zero pixels blended also.

I have tried al_set_separate_blender with many different combinations
and gotten nowhere.

I have read the docuemntation many times, and looked at other explanations
of blending of the web.  But I can't seem to make it work.


<code>
// this draws a background of colored squares
   ALLEGRO_COLOR c[5];
   c[0] = al_map_rgb(255, 0, 0);
   c[1] = al_map_rgb(0, 255, 0);
   c[2] = al_map_rgb(0, 0, 255);
   c[3] = al_map_rgb(255, 255, 255);
   c[4] = al_map_rgb(0, 0, 0);

   al_set_target_backbuffer(display);
   al_flip_display();
   al_clear_to_color(al_map_rgb(0,0,0));

   int ci = 0;
   for (int y=0; y<10; y++)
      for (int x=0; x<10; x++)
      {
         al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, c[ci]);
         if (++ci>2) ci = 0;
      }



// this is the bitmap I am drawing
   sprintf(msg, "Test") ;
   int sw = strlen(msg) * 8;
   ALLEGRO_BITMAP *temp = al_create_bitmap(sw, 8);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));
   al_draw_text(font, ci[3], sw/2, 0, ALLEGRO_ALIGN_CENTRE, msg);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0));


// here is where I have tried just about every blender combination I can think of

   al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
   al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);



// this is where i actually draw  it
   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temp, sw/2, 4, 88, 48, 4, 4, 0, 0);
   al_flip_display();
   al_destroy_bitmap(temp);

</code>


When I don't specify any blender I get a nice masked text over background.

When I try this:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

I get a nice blended source and dest, just like what I wanted,
except the alpha is not respected and I get a rectangle around the text.


I tried:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0));
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 1));
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
but they all made no difference.

I tried:
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);

al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_ZERO);

plus many more combinations, but I can never get the alpha mask to work...

Can anyone with more experience with blenders help me?

Do I somehow have to do this with 2 steps?

My overall goal is simply to have a partially transparent bitmap superimposed over
another bitmap (the backbuffer), (kind like a water mark), but I want it masked so the
zero pixels are not blended with the background.




pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565




looking at different fonts..

great vibes is a free calligraphic font I might use for logo
by typesetit
licensed under OFL

I should make my own larger text display function

it purpose to display very large text based on screen and font size
one and two line versions



for a few days now I have been working with ttf

I have a nice new script font I'm using for ichael avid eiss

It's called 'Great Vibes'
by: typesetit
license: OFL

I also like:
SaucerBB.ttf
but it only free for non-commercial use..
It looks good as my main logo..


I have replaced mtextout() with a similar function
mtextout() was slow, so the new one uses pre-draw bitmaps
for ichael avid eiss
seems a lot faster...

I moved all code for logo and splash screen to its own file: zlogo.cpp

I think I am finally happy with the beginning splash screen

now I want to redo demo mode...

its too slow to draw the large text every frame
I could make another temp bitmap like the others...done...

what am i doing?

I am spending a lot of time making fonts and stuff look pretty...

when will it end???

to do:
-width of splines smooth change
-splash screen to not flash when quitting
-new title with new font

all this is done

predefined enemies editor..done


map not redrawn completely,
probably due to not drawing all of level buffer...
yes...lets disable map
just at the function key level...





orthographic stretch during game, and or menu screens
move to F11
choose another key for controller test exit other than F11
auto choose ortho based on screen size
maybe I could make othro strecth CTRL SHIFT F12
done...


now make les auto chosen based on screen size...

where??
init screen
also screen change

make a seperate function

set_display_transform_double()


how?


rebuild bitmaps does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;
   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


init screen does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;


   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


why dont i put that in set_les


need a function to set ortho
called by init and change

make set_les do auto


rebuild does
set ortho

init does:
auto_set_les();
set_ortho();

change does:
auto_set_les();
rebuild
( set_ortho(); is done in rebuild bitmaps)

F12 does
rebuild

this works...

now to auto set
never auto choose 3

SCREEN_W > 1024 les = 2

looks good in game, but level editor??

does scale change with les??

it should...done
but when its saved with a different les???
its good


demo mode
resize
fullscreen...
goes really slow and no title..
2 resizes...
only in demo mode
fixed..font not destroyed before recreate



do I need to load fonts at 400??
what does 200 look like?
"saucer"
used for:
main tile Purple Martains
main title created by
menu title
level done
demo mode
240 is good enough

"a charming font"
used for ichael avid eiss
240 is good


locked exit to show number left


bottom display to not conflict with frame display (mostly in demo mode)
moved up BORDER_WIDTH



m7667 resize ok but going in or out of fullscreen causes exit when client
do I still have F12 exit key in client??
yes in 4 places...change to F11 for now
done....



client quits game, but freezes locally..
walk me through the sequence of client quitting
client presses ESC
client local control gets comp move of 127 and sends cdat to server
server add to game move array
in add game move special move exit is entered instead of escape
player state change to incative
in proc game move for local client become inactive...
this is the problem:
while (mI.key[ALLEGRO_KEY_ESCAPE]); // wait for release, but send cdat first
do i even need this???


no mouse for options menu..fixed
restore full screen mode when leaving options toggles..done


log file viewer les...done




level viewer won't load good
keeps saying cant find file...400 times
fixed...



simplify num_enemy
int num_enemy in main in pm.h
counted in game in enemy collision
counted in level editor in sort_enemy
only only enemy_data now, no duplicate in lev

same for items..done



start level editor from command line
les is bad fixed


make my own option setting screens with my own sliders and buttons

netgame server text
deathmatch_pbullets_damage slider

I could do it with the menus that I have now..
make netgame menu...done
call it from old menu toggles..
done...
now implement the toggles
in config load set the menu values...done
edit and change with menu
this is all done....yay!!!
now if I do logging I can kill the stupid toggle menu...
done....!!!!
kill it!!!!

number pad keys to work in help...done

fix logo in help..done

when ortho changes
help divider lines off screen...fixed

close holes in menu
-bitmap editor is all that is left
do I still have release in pm.h??

Random mode in zfs
menu in editor
fake keypress mode
copy files to clients
packet test
log file viewer
temp test -g
record video
debug overlay for client and server






---------------------------------------------------------
should I make my background totally black?
---------------------------------------------------------
modify shapes 0-32 to remove really light pixels?
how could i do this??
save_sprit() is still there just commented out
load, modify, save...done


---------------------------------------------------------
what if my whole drawing routine is too complicated
---------------------------------------------------------
right now:
I have l2000 with all the blocks and lift lines drawn
every frame I start with this and copy it to level buffer
then all objectrs draw on the level buffer
then i take a screen sized region of the level buffer and copy it to the backbuffer
then I draw overlay on that
then finally I flip display

how many target bitmap changes: 2
switch to level buffer
and get new background
draw on level buffer
switch to screen buffer

how could i make it easier??

draw background directly on backbuffer from memory bitmaps
draw objects directly on backbuffer
draw overlay
flip

or...

draw background directly on backbuffer from l2000 (just like get new screen buffer)
draw objects directly on backbuffer (just need to change offsets)
draw overlay (same)
flip

test this and see if its faster...
made 1 change in get_new_screen_buffer()

i just realized, i have scaling going on too
i cant just switch from drawing on level buffer which is unscaled
to screen buffer, which is...fuck it, i'm not doing this




speed testing...

while speed testing use number keys to disable stuff to see the
performance hit

get_new background
screen meassges
bottom messages

show fps independent of overlay

wow, i got somewhere!
I found that bottom msg slows stuff down...
on nv59 it down a lot....


make the keys active at any time, not just speed test
show when something is disabled only

test big netgame...


it gets a lot faster when screen and bottom msg are disabled..

I should see if there is some way to optimize them..

like not using temp bitmaps...
like not drawing as many of them..
player health screen messages could be only for local player not all

basically i dont want to switch my target bitmap during game loop
and all of my fancy text routine do that...

what about screen overlay? should be just straight text...yes
what about percent bar?? no switch...its good

move show_player_join_quit to loop for disabling...
if (show_player_join_quit_timer) show_player_join_quit();
done

disable by default: 3 4 5 ...done

test some more...

what if i evened out frame skip
like every other farem, or every 3 or 4 frame...etc
why?  if one frame is slow wont they all be??


what if i made the fancy text drawing stuff off when frames skipped?

profile the text drawing stuff...
in game loop make a function that draw 100 rtext things to screen every drame

change health display to show +H or -H
use regular text

found a very small font called: pixel gosub
"Pixel Sagas" and "Neale Davidson" may be used interchangeably in this agreement. These all refer to the intellectual and legal property of Neale Davidson.
Usage
Pixel Saga's Shareware Fonts are free to use for personal, non-commercial purposes. No payment is necessary to use Pixel Saga's Freeware Fonts for personal use, and there is no limit to the amount of prints, pages, or other medium to be produced using them. However, you cannot offer the font for commercial sale, or offer for direct download. The inclusion of the font name and/or site URL in the credits or documentation when it is used is appreciated, but this is not mandatory.

is is otf but loads fine
i load with size 7
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", 7, ALLEGRO_TTF_MONOCHROME);
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", -8, ALLEGRO_TTF_MONOCHROME);
these both look good
its looks like 3x5 on the screen

ok now I never need screen message...


how about bottom display
i like how it looks...
but so what?, if its slow it needs to go...
fixed...

in draw player health display all is good...

in bottom message all is good

screen message, disabled

all that's left is join_quit..lets leave it

lifts use rtextout_centre()...
but only in vertical mode
its rare enough i'm going to leave it for now

speed seems good now across all clients except nv59
but nv59 has always had issues...

what if i did nv59 in a desktop screen size
less than the huge 1600x1200 i have been using??





---------------------------------------------------------
hysteresis window does not work
---------------------------------------------------------
always stuck to lower right corner
WX and WY needed to persist
made it a global again
bug happened after I made it local..



---------------------------------------------------------
------------------------ linux --------------------------
---------------------------------------------------------

got it to compile and run..

complains it can't create built in font

also can't load a4.tga

gcc version 5.4.0
allegro version 5.2.5??

i'm editting in 2 places at once
thats a recipe for disaster...

edit only on linux for now

the second crash was that I couldn't create a 16 bit display
fixed that...

splash screen has no large Purple Martians but has created by??
same font??
logo works
crashes a soon as splash screen done..

i'm running into max bitmap size

it says it 2048

when I create the title its close...

2090 one time
2034 another timeval
why the fuck is it different???

I don't know...

I would like the title as high a resoultion as i can...

'Purple Martians!' is 14 char

take max bitmap size and divide by 16

2048/16 = 128

8192/16 = 512


changed the load font function to create saucer font by
max bitmap / 16

also changed load built in font to try a4_font.bmp if it fails

left achafont at 240...
what's its max length?  'ichael' 6 char

2048/6 = 341
8192/6 = 1365
just leave at 240 for now...looks good...


as far as the display bit depth, i'll try 16 "SUGGEST"
works on linux just fine, gets 32 bit...


on linux the built in font seems to work now that I have a display...


its really slow

linux:
32 bit
opengl
render method: 2
max bitmap size: 2048
support seperate alpha: no

win:
16 or 32 bit
D3D
render method: 0
max bitmap size: 8192
support seperate alpha: yes


no matter what I disable, linux runs at 60fps

2 things..

downgrade allegro to 5.2.4..done
get gcc-7..done
rebuild allegro with gcc-7...

that made exactly no difference...


I tried opengl on windows and I got exactly 60fps also...

its the exact same as the desktop refresh rate..
I changed the desktop to 40 and my game followed...

try open gl 3

sudo apt-get install mesa-utils

glxinfo | grep "render string"


open_gl
seems to wait for vertical retrace before doing al_flip_display()

u swap method:0 same as w

w render method:0
w vsync:0

u render method = 2
u vsync:0

none of this works...
vblank_mode=0  (from command line)

GLX_EXT_swap_control
GLX_MESA_swap_control

moving on......

l seems to not change screen zize nicely..
in control...make sure all resize event are received before actually resizing

when switching away from fullscreen mode
sizes all look good, but still fullscreen??

in linux i try to set to fullscreen but get slightly less???


on the plus side, it looks like everything else is working good in linux

all that i need to figure out is the open gl stuff
with fullscreen, resizing, ortho, les, etc...


init screen
fullscreen:0 les:1
x:  10 y:  10 w: 800 h: 600 - curr
x:  10 y:  10 w: 800 h: 600 - wind
x:  10 y:  10 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
----------------------------------
Display change
x:  43 y:  47 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  43 y:  47 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:   0 y:   0 w: 800 h: 600 fs:1
changed to fullscreen
fullscreen:1 les:2
x:   0 y:   0 w:1280 h:1024 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 640 h: 512 - scrn
Display change
x:   0 y:   0 w: 640 h: 512 fs:0
changed away from fullscreen
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  35 y:  18 w: 800 h: 600 - curr
x:  35 y:  18 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w:1245 h:1006 fs:0
window resized
fullscreen:0 les:2
x:  35 y:  18 w:1245 h:1006 - curr
x:  35 y:  18 w:1245 h:1006 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 622 h: 503 - scrn


what if I tried ALLEGRO_FULLSCREEN_WINDOW....



this could be happening:

fullscreen mode is set
linux change to slightly less than fullscreen
my proc_screen_change() has no case to deal with this...

I should update the full screen sizes




ripped out all the custom fullscreen window shit
now it works good in win and lin except for
lin background wrong size??

fullscreen and back OK, only when resize...


l2000 get drawn wrong after resize and I don't know why
code is just about identical...

when I am setting ortho, I need to make sure i'm setting it for the backbuffer...problem solved


the good thing is that almost everything else works great..


lin window moves down 21 pixels, every time fs on/off







---------------------------------------------------------
------------------------ Static Linking------------------
---------------------------------------------------------
why?
so i dont have to distribute dlls with my project?

my method now (dynamic)

link with allegro_monolith-5.2

I need to distribute with executable:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

my exectutable is (3,209K)

total: 20,089K

what do I need to do static linking?

build allegro with static linking



From Neil:
https://www.allegro.cc/forums/thread/617338
In Code::Blocks, I use "allegro_monolith-static".

For my linked libs, I have (copy and pasted from my codeblocks project file). Maybe this will help...

<Linker>
   <Add option="-m32" />
   <Add option="-static" />
   <Add option="-static-libgcc" />
   <Add library="mingw32" />
   <Add library="dumb" />
   <Add library="FLAC" />
   <Add library="vorbisfile" />
   <Add library="vorbis" />
   <Add library="freetype" />
   <Add library="ogg" />
   <Add library="physfs" />
   <Add library="png16" />
   <Add library="zlibstatic" />
   <Add library="gdiplus" />
   <Add library="uuid" />
   <Add library="kernel32" />
   <Add library="winmm" />
   <Add library="psapi" />
   <Add library="opengl32" />
   <Add library="glu32" />
   <Add library="user32" />
   <Add library="comdlg32" />
   <Add library="gdi32" />
   <Add library="shell32" />
   <Add library="ole32" />
   <Add library="advapi32" />
   <Add library="ws2_32" />
   <Add library="shlwapi" />
   <Add library="dsound" />
   <Add library="jpeg" />
   <Add library="opusfile" />
   <Add library="opus" />
</Linker>

From wiki:
https://wiki.allegro.cc/index.php?title=Windows,_Code::Blocks_and_Allegro_5

-lallegro_monolith-debug-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlibstatic
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-static-libstdc++
-static-libgcc


compile allegro with shared off


this is my cobeblock project file:

<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="default">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-pg" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add library="C:/mingw32/lib/liballegro_monolith.dll.a" />
			<Add library="C:/mingw32/lib/libnet.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libwsock32.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libz.a" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>


static version   liballegro_monolith-static.a

dynamic version  liballegro_monolith.dll.a

in build options tried moving from lefthand side with full path
to right hand side like this:

old:
C:\mingw32\lib\liballegro_monolith.dll.a
C:\mingw32\lib\libnet.a
C:\mingw32\i686-w64-mingw32\lib\libz.a
C:\mingw32\i686-w64-mingw32\lib\libwsock32.a
new:
-lallegro_monolith.dll
-lnet
-lzlib
-lwsock32
worked...




<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="dynamic">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-lallegro_monolith.dll" />
					<Add option="-lnet" />
					<Add option="-lzlib" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
			<Target title="static">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
					<Add option="-lallegro_monolith-static" />
					<Add option="-ljpeg" />
					<Add option="-ldumb" />
					<Add option="-lFLAC" />
					<Add option="-lfreetype" />
					<Add option="-lvorbisfile" />
					<Add option="-lvorbis" />
					<Add option="-logg" />
					<Add option="-lphysfs" />
					<Add option="-lpng16" />
					<Add option="-lzlib" />
					<Add option="-ldsound" />
					<Add option="-lgdiplus" />
					<Add option="-luuid" />
					<Add option="-lkernel32" />
					<Add option="-lwinmm" />
					<Add option="-lpsapi" />
					<Add option="-lopengl32" />
					<Add option="-lglu32" />
					<Add option="-luser32" />
					<Add option="-lcomdlg32" />
					<Add option="-lgdi32" />
					<Add option="-lshell32" />
					<Add option="-lole32" />
					<Add option="-ladvapi32" />
					<Add option="-lws2_32" />
					<Add option="-lshlwapi" />
					<Add option="-lnet" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-Wall" />
			<Add option="-pg" />
			<Add option="-Og" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>







Having trouble with static linking

I am new to static linking, have always used dynamic with no problem.
Thought I'd try it.

 - First of all, what are the advantages of static vs dynamic?

 - Second, what extra files do I need to include with my game?

With dynamic it seems I need:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

I don't know what static will require as I havent been able to get it working yet.


I am using:

mingw-w64
Version:7.2.0
Architecture:i686
Threads:posix
Exception:dwarf
Build revison:1

Allegro 5.2.4 (from source)

Code::Blocks 17.12


I built both the dynamic and static monolith debug release versions of allegro

The only thing I did different for static was uncheck the SHARED flag in CMake

I changed the linker library list from:
-lallegro_monolith.dll
-lzlib
-lnet
-lwsock32

to:
-lallegro_monolith-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlib
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-lnet
-lwsock32

I also set these compiler flags:
Static libgcc [-static-libgcc]
Static libstdc++ [-static-libstdc++]
Static linking [-static]



My project compiles, links and runs fine with dynamic linking.
But I am getting linker errors when I try static.

There seem to be 2 things linker can't find:

fixed point routines in fmaths.inl:
C:\mingw32\include\allegro5\inline\fmaths.inl|46|undefined reference to `_imp__al_fixtorad_r'|

and opus stuff:
C:\devel\Allegro5\addons\acodec\opus.c|102|undefined reference to `op_free'|


I am lost here.  I don't know how to fix these errors.
I barely understand how I got this far...


Any advice on static vs dynamic as it applies to Allegro would be greatly appreciated.

Do I even want or need to do this?
Should I just use dynamic and not worry about static?

I needed to compile with -DALLEGRO_STATICLINK


now everything is in the executable...
pm.exe 17,084K and needs nothing else

later i may try to trim out things i dont need...


level editor les
main is good in les=1
but zfs and viewers don;t get there until i cycle with F12
probably set map var...
actually instead of running ortho, run rebuild_bitmaps()..fixed


---------------------------------------------------------
bug pop-up message viewer on linux has extra blank line at end
---------------------------------------------------------

I looked at the string and there is an extra 13 at the end
but only on linux????

I changed to read files in binary mode and it seem to work the same in both now...
no it doesn't....

what the hell is going on??

in windows \n is 10 and \r is 13

it look like my file reading stuff uses \n (10) as a seperator

for messages why don't i just leave 126 as my newline

lets revert back...done

went back to opening in 'r' mode
now i dont do any messing with converting, i just leave 126 as my newline
works same in linux, but now I get ^ at end of text

when I load text, ignore 13...

this seems to work now...


lets look at the editor..its good too...

this is all done



when players health is clamped past 100 it generates a - health display
fixed....







i'm losing keypresses
like F12 key up...
in control i'm trying to filter multiple resize events
is it needed in linux...yes..

redid the control loop, seems to work good now...



can't quit demo mode
fixed



icons...

what does allegro say...

in windows I have one for the window and in the taskbar

I made a file called icon.rc
#include <windows.h>
allegro_icon  ICON  bitmaps/pm.ico
added it to my project and that's literally all it took!!!

what about linux...

the function:
al_x_set_initial_icon(tmp);
is supposed to be called before you create the display
need to include:
#define ALLEGRO_UNSTABLE
#include <allegro5/allegro_x.h>
and the fucntion will not be found on a windows system
but after all that it doesn't seem to do anything...
I made a pm.desktop file in ubuntu
you can specify an icon in that..
not sure how usefull that will be...





after playing a netgame for 3 level dones
server player is getting random moves..

this bug is hard to reproduce...


could it be something to do with re-joining after level done??


reproduced on 8  player game after a loooooooonnnnnggg time
level 12 about 50 frames in


i had logging on!!!

server log file:20180418-165728.txt
17,746 KB
313400 lines
16897 frames
/ 40 = 422 seconds
/60 = 7 minutes

log file starts at level 5
and ends on level 5 7 minutes later...
wtf??
where are the rest of my logs!!!?????

does the passcount not reset??

--------------------------

level 14 approx 100 sec or 4000 frames

20180418-185448
5,501KB
98,894 lines
4830 frames

looks like there were only 6 players that joined
player 7 did not
i have stats for player 7 at the end but no name at the top...weird

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 y510
p5 eid
p6 e6410
p7 m-4230-3


could be my log file viewer....tis...
fixed that, now I have all 7 clients

moving on...

cant see anything on the server that would explain it

looked on client nv59, but its lin and even though i copied
i had old version cause its not compiled...

i'll need to look on a windows machine..
looked on pfv...found nothing
looked on y510...found nothing

looked on e6430:
file: 20180418-185448
it looks like a server file...wtf

----------------------------------------------------------

try to reproduce again


did it again...
level 14 100 frames in
when i took player nv59 off F1 mode
20180419-043626

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 eid
p5 e6410
p6 m-4230-3
p7 y510


notes:
end of level player array on nv59
server is mode 9??
at start server is mode 2
looks like they are all like that...


p0 i990
p1 nv59 ns
p2 pfv ns
p3 e6430 ns
p4 eid ns
p5 e6410 ns
p6 m-4230-3 ns
p7 y510 ns

none are pretending to be server...

what now??

is the corruption on the server and just propogated backtop the clients?
i'm thinking thats the case...
because if it wasn't i would be getting lots of stdf corrections
and i'm not

what can i do now??

look more closely at when cdats are rx'd

nv59
got game move on 2556 from server frame 2557
that i am pretty sure he did not send a cdat for...
actually thats not true...



------------------------------------

did it again

this time all players were acting weird even after i stopped f1 modes

lev 14 frame 42-50 on pfv was where i first noticed it...
20180419-060449

nv59 log
no moves received from server that were not sent by cdat
looks like f1 fake mode was stopped at frame 921

then manual keys pressed at
1022
1031

that does not match up with what i saw...
i get no game moves received for player 1 from 925 to 1022
then 5 manaul move from 1022 to 1098
then nothing until
5 manual moves from 1272 to 1285
then nothing until 8000 with fake mode again
ended with 12 stdf corrections

i got nothing....
why is it so fucky??

should i look in game moves??
compare server and client?

not until moves gets to 16000 or so on level 14


got another
level 14 around 40-50
look in game moves

on m-4230-3 at frame 1576 stopped f1 mode
then only got a few manual keys
1607
1651
1689
1710
1734
1783
so there should be no player 1 entries in game move after that
i don't see any on the server's game move





tried again this time only level 13 then 14

did not happen until 180 sec into game

what is getting counted up to???

game moves look identical

is it because how i am reading from the game moves array....

how can i check this...


what reads the game move array...

proc_game_move()
run once per frame
uses to iterate and or search



and this is run once per frame for each player

// common for all players;  get controls from game_move
int found = 0;
for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
   if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
      if (game_moves[g][0] <= passcount) // check to make sure its not in the future
      {
         found = 1;
         set_controls_from_comp_move(g);
         game_move_current_pos = g; // for savegame running only
         g = 0; // break out of loop
      }
if (!found) clear_keys(p); // if no match found


game_move_entry_pos


there is a global, and there is also one in players1 struct

53 matches in total..

i should un ambiguate this....

int game_move_entry_pos; (global variable)
- used to keep track of the entry point of the game move array

when a new game move is put in the array this is used
there should only be one way a new game move gets put in the array
add_game_move()
server calls it 6 time..
loop calls it twice when loading annd starting a new level
control call it twice
once for level done
once in single player local control

int game_move_entry_pos; (global variable)
- also used as a start point when reverse searching game_move array
like in proc_game_move() and when player gets move from game array

when do i reset it..


I THINK I FOUND SOMETHING!!!


if (start_mode != 2) // skip this when start_mode == 2 ; run game
{
   // reset game_move array
   for (int x=0; x<10000; x++)
      for (int y=0; y<4; y++)
         game_moves[x][y] = 0;
   game_move_entry_pos = 0;


i am only erasing the first 10,000 entries.....
its actually 1,000,000 now

10,000 / (7 moves per frame * 40 frames per second)
= 35 seconds

1,000,000 / (7 moves per frame * 40 frames per second)
= 58 minutes (at max keypresses per second)

log file name to have level and hostname..done

client log file to have full player array at end...done

start of log file after level done to have header with
hostname and player array..done

change game move logging (which is client only)
tag the logged move with the player it is for...
right now its tagged with the active local player...



what is client sync error that keeps showing up on clients?
when a client gets game moves with passcounts in the past
that will never be processed
its bad, but stdf will fix it..
lets not have that show, except in debug overlay..done



---------------------------------------------------------
in order for save game to play back correctly
they need to have the same values for pbullets, etc...
---------------------------------------------------------
save as 3 ints at start of gm
restore after by loading config
modified gm and txt save
modified gm load..
modified existing demos
added 1 5 1...
in demo mode and run game restore after...done
this should be done



make some automated post build setup stuff...

make a folder called pm_win_release

can i do it from the command line..
all i really want to do is copy stuff...

made a windows batch file that does what i want....

to make a windows release...

set version number in code and in help file
define pm_release

compile the project with win_static_release build target
run the batch file
zip and rename

how can I static build in linux
too complicated...

compile
run bash file
compress

make some more stand alone text files, like
setting up dev env on win and lin



death animation??
enemies have them, why not for player??

editing timeset with gimp

image->configure grid
view-> show grid
view-> snap to grid
view-> snap to canvas edges

file->overwrite (save back in same format)

to make a proper death animation seq
it will have to be for each player's color ....

what if I just do a shrink, rotate, and draw item disapear ans...

where would I do this??

at the end of player move, do the shrink and rotate
in draw_player() superimpose the item disapear thingy
done...



files still not added (probably never...)
- e_bitmap
- e_guifnx

I just realize I have no way of setting blocks drawable
copying and moving blocks
or doing anything with animation sequences

I could probably make some of e_bitmap work...

like select bitmap and animation sequence..

i made select bitmap and animiation work
but no link to them...

make select bitmap, coopy bitmap accsesiable from animation

also add save...

done...now link to it in editor...done



re-write help file
font and credits..done
screen mode..done
in game function keys..done
commandline..done
history update..done
installing..done
linux..done
add pixel_sub font credits..done



---------------------------------------------------------
what are my difs that happen every frame??
---------------------------------------------------------
tested and found a dif when other player joined and color was updated
also got archwag: type 3 difs
Ei[][1]  off by 5
Ei[][5]  off by 5
Efi[][0] // once  (x)
Efi[][1] // many  (y)
its usually this pair
Ei[][5]  off by 5
Efi[][1] off by .5, 1 , 3...

played a huge long netgame and they don't happen every frame...
actually quite infrequently....





add source available on request...
license: none
just a copyright notice...


what version number? 7.0


trying other linux os's
linuxmint-18.3-cinnamon-64bit.iso

missing: libopenal.so.1

copied from m-4230j

what if i recompile allegro on m-4320
to disallow open al
and redo all that...
or I could just distribute libopenal.so.1...
I recompiled the game so I don;t need the file now.

title on main menu screen is cut off when text is too wide?
only on cinnamon mint??

has max size as 8192
and is creating same size as other one

4865 violet missing V and !
4888 mauve  missing !
4767 bluey  missing !
6777 reddy  missing !
4219 pink   good
4335 taan   missing !
5213 orange missing O and !
5136 purple missing P and !
5088 forest missing F and !
4089 red    good
4874 green  missing !
4444 blue   missing !
4462 aqua   missing !
5164 yellow missing Y and !
4600 white  missing !

fixed by changing size of title bitmap..
old was max bitmap / 16
new is max bitmasp / 20

now mint works great....



updated windows version to 7.01, now with demo files!!!

updated linux version to 7.01,
now updated allegro libary that dosent require png support...


help screens width when changing les..fixed

fixed final_wrapup()
now hopefully wont die as much in linux


make the releases...
put on allegro.cc...
...
profit?


new license (zlib)

change help.. done

add license.txt.. done

make 7.03 release for win and lin...done



crashes on exit in win 10

try removing all bitmap destrying in final wrapup

also remove:
al_destroy_event_queue(event_queue);
al_destroy_display(display);

also remove complile optimizations


seems crash free on win 10 exit now...
linux version exits good too...
lets make release version 7.04


rename save and run game...
to what?
save demo
run demo

the best way to do that is to use the logging options
because as soon as a level ends, its too late to save it anymore
what if i remove save game completely?
its only use is when you stop a game mid-level and want to save...
just rename them for now..




When archwag y speed is set to 9 (max) they fall through floors...

found the bug!!

Ei[EN][5] +=5; // gravity

// this line is wrong!!!!
if (Ei[EN][5] < -160) Ei[EN][5] = -160; // terminal velocity

//fixed
if (Ei[EN][5] > 160) Ei[EN][5] = 160; // terminal velocity


now are all my demos going to be fucked?  probably any that used archwag...

dl_01 (pretty short anyway) kill it
dl_02 (pretty short anyway) kill it

dl_13 no archwag, good keep
dl_14 still good keep
dl_15 doesnt look good kill it

24 has a million arch wags, needs to be redone
26 doesn't work
27 bad
29 bad

30 good
33 good

zm21...bad  :(


after all these are the one I can keep


redid some demo levels, now I have:
13
14
20
23
24
26
30
33


new default keys:
arrows, x, z

p0_up_key=84
p0_down_key=85
p0_left_key=82
p0_right_key=83
p0_jump_key=24
p0_fire_key=26
p0_menu_key=59


20180508
copy in zfs has rect 1 block to big in x and y...fixed

20180508
adding new enemies erases last...wtf
only after copy paste enemies in zfs??
i broke something in level 42
now any enemy that I add either from draw_item copy paste or selection window
erases the last enemy...why??
bug in code in editor line 1160
should be:
int c = get_empty_enemy(); // get a place to put it
not:
int c = get_empty_item(); // get a place to put it
bug first appeared 20180401
fixed...



Make a way to do "new level" in level editor

right now what I do is:
- load level (optional)
- save level (and choose filename that doesn't exist yet)
- go to zoom full screen
- select entire level
- click clear

add a menu item 'new level'
- prompts you for a filename to save
- clears level and saves as new filename

made the menu item

made erase_level_data() a seperate function and call from
load_level() and initial_setup()

now it goes like this...

if (al_show_native_message_box(display, "New Level", "Clicking OK will create a new blank level", NULL, NULL, ALLEGRO_MESSAGEBOX_OK_CANCEL) == 1)
{
   zero_level_data();
   draw_big(1);
   update_editor_background();
   al_flip_display();
   save();
}
load_level(level_num, 0); // blind load

seems to work just like I want...call it done


make a function that serially reads keys to call debug functions..

while game running:
STON  speed test on
STOFF speed test OFF

while level_editor_running:
SPLADJ  spline adjust
SPLTEST spline test

while not game running
LOGVIEW run the logfile viewer


if ima_client
FAKEKEY toggle

does it work with CAPS?? ..NO

done...


new level does not blank the number of lifts...fixed

new level has bad pmsg data
fixed method of declaring pmsg pointer and freeing and setting to NULL


Should I make pmsg not have clear center?? yes...


i messed with pmsg and now I get crashes and I'm not sure why

this was the code used to erase level data..

if (item[c][0] == 10) free (pmsg[c]);
i didn't like it because it didn't reset the pointer to NULL

I replaced it with:
if (pmsg[c] != NULL)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}

and then just:
free (pmsg[c]);
pmsg[c] = NULL;

because if it's NULL, free() should not do anything

I get random crashes and I don't like it, so I went back to the original plus this:

if (item[c][0] == 10)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}



trakbot initial direction button works, but the rotated display in enemy viewer is wrong...fixed

sel outline rect too small when at rl edges..fixed

make my webpage part of the sources

re-arrange levels and move less fun ones to the end...

I want to have a very solid set of levels with no duds

these are lame and should be segregated...

5
6
7
8
9
10
11
12
15
16
18
19
40

what if I had an overiding script that chose the order of levels...

start by moving lame ones to 50++


did a lot of that...

need to make the demo's line up


what if I gave all my levels names like anything.pml

then I made an array of playable levels
that would end my renaming bullshit



hard code into the program:
for each:

filenames
title
description


make a playlist of levels

int level_playlist[400]

this gets iterated through when playing
and is used by visual_level_select()

level_num is an index into this

how about do this, but still use numbers for levels

menu item "level set"
LEVEL SET:TRAINER
LEVEL SET:MAIN
LEVEL SET:EXTRA
LEVEL SET:ALL



This is what I actually did.

I made 3 levels that I call trainers and moved them to 90, 91, 92

I made a warp there and back from level 1

I think it works good enough...

made some more changes to the levels and then are looking good.

1 - trainer select
2-24 main levels
50-64 extra levels
90-93 training levels

20180514 new commit

auto create dir sel, like logs...done


sometimes I see trails in level_buffer when stimp/stamp or screen change
hard to reproduce..
re-did get new background to do full or region only
did a redraw at start of stamp
also slowed down stimp and stamp to make more visible
trails during stamp are good


when stimp and game zoom shows lots of the level, it doesn't line up

its like stimp and stamp expect the game position to be more left than it is




stimp and stamp have code with hystersis window like get_new_screen_buffer()

make that common??


what is found out by either function?
in get new background: WX, WY, SW, SH, sbx, sby, sbw, sbh


in stimp and stamp I just patched in an offest like this:

   // offset if entire level is smaller than screen
   int sbw = SCREEN_W-bw*2;
   int sbh = SCREEN_H-bw*2;

   // how big is the entire level after scale factor is applied?
   extern float scale_factor_current;
   int sls = (int) ((float)2000 * scale_factor_current); // sls = scaled level size

   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      px_final += a/2;

   }
   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      py_final += a/2;
   }

works now...

cursor height in text editor

draw lift..good
server name good
p message..fixed



fix demos

old demos from version 7.04


9
10
12
13
14
16
17
zm_11 chopped to 200s or 8000 frames

---done

commit done
made an old style backu too...

when run demo stimp of wrong level..fixed
cleaned up function prototypes
20180517 commit

working on cleaning up pm.h

pm.h has all function definitions listed by files
and sorted through

next I should work on global variables... I have a lot of them...


the beginning of main, where they are declared,
should mirror pm.h where they are externed

also remove lots of not used ones

also move all declarations from other source files to main

I have 500 lines of extern variables!!!

tmty
tmtx
position of text above the map on menu screen_msg
used in draw_level
set in set_map_var

I also have:
menu_map_x
menu_map_y
menu_map_size

I should use these get the text position and then get rid of tmtx and tmty
step 1
use them in draw level
now search and get rid of  tmtx and tmty done...


now how about md
used only to to make mx
mx is used a lot
made md local to set map var
md is gone now, local only to set_map_var

int map_double; // level editor map double
not used, removed...

tmy is the top_menu y_pos

always set to 10, never anything else
used to set mx = tmy + 130;
make that constant..
tmy is gone...

float steps is gone...

mx, my
what are they used for?
mx is used a lot locally
replace with smx if locally used
down to 89
turns out almost all my and my were local...
i kept a lot of them, just killed the extern ones
mx and my are not global anymore...

txc is used for the center of the right hand side panel in level editor...keep

that has cleaned up lots...

what is next?

group globals by function and make sure main and pm follow same format...

make item_name and enemy_name the same

both


menu_setup for game in zmenu

text_setup for level editor in e_menu

make them common...

both use global_string[9]

le uses 5 and 9
gm uses 3, 4, 7, 8, 9

make le use 6 instead of 9..done
move code from ts to ms done
remove e_menu.cpp from project...done
make enemy_name like item_name
replace ei_type_desc with enemy_name
6 used for lift pop up menu?? need to move editor menu to 2?
done...



4:30 AM

main
300 sorted
200 not

pm
550 sorted
200 not

5:30
400 sorted
100 not

pm
625 sorted
125 not

wx and wy are used 34 times
mostly as the origin block on the main level editor..


6:40
main 20 not sorted
pm same...

20180518 commit...

level_header is used in filecom only
uses only 3, 4, 5 for num item, enemy, lifts
made local

I am finished cleaning up pm.h

now I have approx 350 globals, but they are all grouped by function
and match the declarations in main

code stats:
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)


put log file viewer in logging menu..done

what if I add PG_UP and PG_DOWN to menu?
I would make navigating long menus easier.....done

text center in level editor is not right...
moved where txc is set to after where db in set..fixed

title obj for item not centered..fixed

raise text in color select 1 pixel...done

show door type button better...only show in title at full size..done

I think I'm ready for a new version release

I should make a checklist of all I need to do:

- make sure version string is incremented at start of initial setup
- change version in help file

- make sure linux version works

something (i'm looking at you git) changed the linux line endings to windows
op win
pml lin
lin_make_release win
readme_linux lin

log file viewer crashes hard on linux
never even runs...
didn't crash the 2nd or 3rd time...
PDE text for Trakbot says wall climber
too many lines for switch and flapper door
fixed PDE text...
need to make it look good on linux with line endings...done

compile lin version and make tar.gz
compile win version and make zip

upload to itch.io




- define RELEASE in pm.h






------------------------
20180523

Refactoring....


I need to sort out how the three tile bitmaps get load and such.....

right now its spread across too many places....done

now all 3 are load and initialy created in load sprit
only load sprit is called from main

recreate bitmaps destroys all sub bitmaps ane re-creates...


why is tilemap created in load_sprit, but ptilemap and dttilemap are not ???

this is a mess and should be straightened out...

make tilemap, ptilemap and dtilemap local to load sprit only.
all they do is create the M_ versions that need to be global...or do they??

fix this...



-------------------------------------------------------------------------------
these bitmaps are created when 'create_bmp()' is called from 'init_screen()'
this is the only time that 'create_bmp()' is called...

tilemap = al_create_bitmap(640, 640);
ptilemap = al_create_bitmap(380,320);
dtilemap = al_create_bitmap(160,640);

level_background = al_create_bitmap(2000,2000);
level_buffer = al_create_bitmap(2000,2000);

M_tilemap = al_create_bitmap(640,640);
M_ptilemap = al_create_bitmap(380,320);
M_dtilemap = al_create_bitmap(160,640);



-------------------------------------------------------------------------
in 'rebuild_bitmaps()'
M_tilemaps are drawn to tilemaps
sub_bitmaps are created / recreated from tilemaps


-------------------------------------------------------------------------
in 'load_sprit()'
tilemaps are loaded from file
M_tilemaps are created from tilemaps
rebuild_bitmaps()' is called



fill_door_bitmap() and fill_player_bitmap() are not called
so I commented them out


to do:

make load_sprit not create local copy of tilemap....done
make load_sprit only load M_, then call rebuild_bitmaps();

I tried to load M_ directly, but for some reason,
I need to load as video bitmap then convert alpha and store in M_


I would like to rename:

l2000 to level_background..done
memory_bitmap to tile...done
player_bitmap to player_tile...done
door_bitmap to door_tile..done

rename load and save sprit to load and save tiles..done





what is not used:

void test_window_size_and_pos(void) // never used...move to old...

// only declared and externed, never used.. removed
int disp_x_full = 0;
int disp_y_full = 0;
int disp_w_full;
int disp_h_full;

// last screen pos, to tell if it changed -- does not need to be global!!
int l_spx;
int l_spy;

what is saved to config:
disp_x_wind
disp_y_wind
disp_w_wind
disp_h_wind
fullscreen


renamed les to display_transform_double...done

renamed set_ortho() to set_display_transform()..done

after death, trails show on undrawn level background..fixed


----------------------------

Do I have to re-create all my tile sub bitmaps every time I rebuild bitmaps?
No, if I just reload the parent bitmaps the subs do NOT need to be re-created...done




trimmed down the number of calls to rebuild_bitmaps()

actually its called a lot more often that than.... why???
3 time in proc screen change

1 time in filecom after load_tiles


2 times in menu...at start and end of menu right after auto_set_display_transform_double

1 time in control after F12 to set display_transform_double


1 time in bitmap in animation at start when display_transform_double set to 1

2 time in editor at start and end of help when display_transform_double changed

? can I just add it to auto_set_display_transform_double()

? make manual set version and set it there too??


try to change the one in control...
replaced  rebuild_bitmaps();
with:
set_display_transform();
set_map_var();

bitmap..removed

add to end of auto set:
set_display_transform
set_map_var
done

find all call to this and remove rebuild_bitmaps...done
help x 2

now after all that: rebuild_bitmaps() is called only from proc_screen_change


-----------------------------------------------

do I need 'speed' to be seperate from passcount_timer_fps?

rename speed in the game to frame_speed for now, so I can tell it apart from the 150 mentions of speed

found 21 refs to 'frame_speed'
found 13 refs to 'passcount_timer_fps'

why do they need to be different?

what if I replaced all passcount_timer_fps with frame_speed??

done...

now remove:
void set_passcount_timer_fps(int x)

32 refs to frame_speed

should be done....

hopefully it didn't break anything....

-----------

sound...

why do I have lit_item and fuse_loop_playing?

do I need both??



lit_item
- set to zero in proc_sound
- set to one in proc lit rocket and bomb

used by proc_sound to continue fuse hiss...

code stats: 0524
36 files
19393  code only
 5368  empty lines
 3726  comment lines
 3376  code and comment
31863  total


-----------------

increment passcount in proc_frame_delay(), not update_animation()..done
here is how it moved in the game loop:
proc_controllers();
player_move();
proc_player_carry();
update_animation();  <- from here
enemy_move();
enemy_collision();
proc_ebullets();
proc_pbullets();
proc_player_health();
proc_sound();
proc_frame_delay();  <- to here

hope this doesn't break anything!

Rename passcount to mwPS.frame_num...done

rename event to game_event...done




in proc_controller()

change
if (mI.key[ALLEGRO_KEY_PRINTSCREEN]) mI.key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work
to
mI.key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work

also this line:

if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
looks like its in the wrong spot

orig:

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

fixed:


   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

now menu's seem to run a lot faster...fixed

make screenshots folder auto created...done
fix screenshot to use actual screen size instead of ortho doubled...done

make it so demo counter will not run when game is paused
cause when it does, paused game is lost...done

changed logo drawing to use max x or y scale instead of hypot for thickness

-------
fixed linux line ending on text files
removed license.md
edited license.txt and readme.md







i want to simplify the 2 variables used for menu timer wait in proc_controllers()

right now I use done and menu timer wait

done is used 3 time; menu_timer_wait is used 2 times

code before changes...


int proc_controllers()
{
   int ret = 0;
   int done = 0;
   int menu_timer_wait = 1;

   mI.key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
          if (menu_timer_wait) done = 0;
      }




new version:

menu_timer_block only and used in three places...much better

int proc_controllers()
{
   int ret = 0;
   int menu_timer_block = 1;

   mI.key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work properly
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_block = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
      }
      else // game is in progress
      {
         menu_timer_block = 0;






web docs:
rename events
or move out input to its own file..done
input to have key, mouse, joystick and game moves array...done


---------------
found a better way to get rid of warning like:
warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]|

previously i change all the time i called a funtion with a literal string from:
Packet("sdak");
to:
Packet((char *)"sdak");

but bamcaig said that wasn't actually correct

now I am going to redo them all by changing the function from:
void Packet(char *id) {
to:
void Packet(const char *id) {

that is the correct way.

I just changed 20 instances of Packet()
moving on...
20 x Packet()
12 PacketRead()
4 title()
30 help()
23 getxy()
5 getbox()
1 get_item()
2 ClientInit()
30 add_log_entry_centered_text()
94 add_log_entry_position_text()

all done....


what if I sort out the names for packet add and read

new...

void PacketPut1ByteInt(int b)
void PacketPut2ByteInt(int b)
void PacketPut3ByteInt(int b)
void PacketPut4ByteInt(int b)

int PacketGet1ByteInt(void)
int PacketGet2ByteInt(void)
int PacketGet3ByteInt(void)
int PacketGet4ByteInt(void)


void PacketPut1ByteInt(int b) replace 32
int PacketGet1ByteInt(void) replaced 22

void PacketPut2ByteInt(int b) replaced 3
int PacketGet2ByteInt(void) replaced 3

void PacketPut3ByteInt(int b) replaced 0
int PacketGet3ByteInt(void) replaced 0

void PacketPut4ByteInt(int b) replaced 26
int PacketGet4ByteInt(void) replaced 18


2 byte is only used for:
- play level in SJON and CJON
- specialized packet testing

I could remove the tests I put in for player num matching who...nah leave it...



what site did i use for my flowchart?



where is server_sync used..


client and server

in player1 struct


overlay
client while waiting for sync
client bottom overlay
server per client


I want to make them unique..

on client server_sync is used for display only and for adjust timer

rename that one to client_sync

add new var in player struct:client_sync
should be done....


next:

   int c_sync;
   int c_sync_min;
   int c_sync_err;

how about:

client_game_move_sync;
client_game_move_sync_min;
client_game_move_sync_err;

and

server_game_move_sync;
server_game_move_sync_min;
server_game_move_sync_err;



change client first....
make new var...
clear in player
fix in client
fix in overlay
fix in log
done

change server next....
make new var...
clear in player
fix in server
fix in overlay
done

still seems to work

























rename state correction stuff


stdf is the name of the buffer used by client to build chfd from packetsize
I could call it client_state_buffer

the array used to track if all the pieces have arrived: chdf_pieces
rename to client_state_buffer_pieces

client1_chdf is the clients base state
rename to client_state_base

client1_chdf_id is the frame num of the clients base state
rename to client_state_base_frame_num


old:
extern char chdf[STATE_SIZE];          // for client chdf building
extern int chdf_pieces[16];
extern char clientl_chdf[STATE_SIZE];  // last ack state for diffing
extern int clientl_chdf_id;            // mwPS.frame_num id

new:
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // mwPS.frame_num id

chdf to client_state_buffer..done
chdf_pieces to client_state_buffer_pieces..done
clientl_chdf to client_state_base..done
clientl_chdf_id to client_state_base_frame_num


old:
extern char dif[STATE_SIZE];
extern int dif_id[2]; //   (0 = src, 1 = dst)

new:
extern char client_dif[STATE_SIZE];
extern int client_dif_src;
extern int client_dif_dst;

server also uses dif....
client only uses dif_id

ok do this instead:
new:
extern int dif_src;
extern int dif_dst;

leave dif alone

dif_id[0] to dif_src..done
dif_id[1] to dif_dst..done



old:
// server chdf
extern char client_chdf[8][2][STATE_SIZE];
extern int client_chdf_id[8][2]; // mwPS.frame_num id

new:
extern char srv_client_state[8][2][STATE_SIZE];
extern int  srv_client_state_frame_num[8][2];

client_chdf to srv_client_state..done
client_chdf_id to srv_client_state_frame_num..done


final variable list:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2]; // mwPS.frame_num id

// local client's states
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // mwPS.frame_num id

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;  // client only
extern int dif_dst;  // client only


now I need to come up with a different term for the variables that make up a state

I have funtions called:
void chnk_to_state(char* b);
void state_to_chunk(char* b);

but what I used to be call state needs a new name: game_vars

new names:
void state_to_game_vars(char* b);
void game_vars_to_state(char* b);

chnk_to_state to state_to_game_vars..done
state_to_chunk to game_vars_to_state..done

these are good:
void reset_states(void);
void game_vars_to_state(char * b);
void state_to_game_vars(char * b);


these should all have chunk changed to state:
void get_chunk_dif(char *a, char *b, char *c, int size); // server only
void apply_chunk_dif(char *a, char *c, int size); // client only
void show_chunk_dif(char *a, char *b); // client only
done...


now the packet names....

chdf and chak

stdf and stak

did a global replace of chdf to stdf -- hundreds... hope it didn't break to much...

now chak to stak..done..only a few

lets see how broken it is....
I still seem able to play a 2 player game...

well now that everything has been renamed, lets move on with the documenting....

------------------------------
bug
-----------------------------

end of level on netgame???

seem to have trouble joining on new level...

client keeps getting difd from 0-20, 0-25 etc
but its base is 2 so it cant apply them

finally at frame 120, client resets base to 0 and applies dif

but its too late beacuse the server has already dropped the client
for no sdat_rx for 100 frames



when does base reset to zero? never mind


also client is approx 10 frames behind client
this is why chdf is never applied
client does not receive any sdat until 108
the moves it gets are the server drop moves!!

what controls when server send sync sdat?


if I press keys on the server after level done and force sdats to be sent, join works
if not, it times out


why is server not sending sync sdat's???


try removing else....that fixed it...
it was never doing the second block because the first one was true (client need more data)
but the first one was not sending more data beacuse of the duplicate blocker

void server_send_sdat(void)
{
   for (int p=1; p<NUM_PLAYERS; p++)
      if (players[p].control_method == 2)
      {
         if (players1[p].game_move_entry_pos < game_move_entry_pos) // client needs more data
         {
            int start_entry = players1[p].game_move_entry_pos;
            int end_entry = game_move_entry_pos;
            int num_entries = end_entry - start_entry;
            if (num_entries > 100) num_entries = 100;

            // to prevent multiple resends of exact same data
            if ((players1[p].server_last_sdat_sent_start != start_entry) || // different start pos
               (players1[p].server_last_sdat_sent_num != num_entries))      // different num entries
            {
               players1[p].server_last_sdat_sent_start = start_entry;
               players1[p].server_last_sdat_sent_num = num_entries;
               players1[p].server_last_sdat_sent_frame_num = mwPS.frame_num;

               Packet("sdat");
               PacketPut1ByteInt(p);
               PacketPut4ByteInt(mwPS.frame_num);
               PacketPut4ByteInt(start_entry);
               PacketPut1ByteInt(num_entries);

               for (int x=start_entry; x<start_entry + num_entries; x++)
               {
                  PacketPut4ByteInt(game_moves[x][0]); // mwPS.frame_num
                  PacketPut1ByteInt(game_moves[x][1]); // type
                  PacketPut1ByteInt(game_moves[x][2]); // data 1
                  PacketPut1ByteInt(game_moves[x][3]); // data 2
               }
               ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

               if (L_LOGGING_NETPLAY_sdat)
               {
                  #ifdef LOGGING_NETPLAY_sdat
                  sprintf(msg,"tx sdat p:%d [strt:%d num:%d]\n", p, start_entry, num_entries);
                  add_log_entry2(37, p, msg);
                  #endif
               }
            }
         }


         else if (mwPS.frame_num > players1[p].server_last_sdat_sent_frame_num + 19) // send even if no data, every 20 frames for sync
         {
            players1[p].server_last_sdat_sent_frame_num = mwPS.frame_num;
            int start_entry = players1[p].game_move_entry_pos;

            Packet("sdat");
            PacketPut1ByteInt(p);
            PacketPut4ByteInt(mwPS.frame_num);
            PacketPut4ByteInt(start_entry);
            PacketPut1ByteInt(0);
            ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

            if (L_LOGGING_NETPLAY_sdat)
            {
               #ifdef LOGGING_NETPLAY_sdat
               sprintf(msg,"tx sdat p:%d [strt:%d num:%d] (sync only)\n", p, start_entry, 0);
               add_log_entry2(37, p, msg);
               #endif
            }
         }
      }
}



--------------------------------------
end of bug


what if I remove the code that checks if packet are from who they are supposed to be?
that was never an issue...


old:

      if(PacketRead("serr"))
      {
         int sp = PacketGet1ByteInt();
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx serr player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            if (serr_type == 1) // error type (1 = cdat late)

            players1[p].serr_c_sync_err = serr_c_sync_err;
            players1[p].serr_display_timer = 120;

            sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
            if (L_LOGGING_NETPLAY_cdat)
            {
               #ifdef LOGGING_NETPLAY_cdat
               add_log_entry2(35, p, msg);
               #endif
            }
         }
      }


                  Packet("serr"); // server error
                  PacketPut1ByteInt(p);
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(mwPS.frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);




new:

      if(PacketRead("serr"))
      {
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (serr_type == 1) // error type (1 = cdat late)

         players1[p].serr_c_sync_err = serr_c_sync_err;
         players1[p].serr_display_timer = 120;

         sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
         if (L_LOGGING_NETPLAY_cdat)
         {
            #ifdef LOGGING_NETPLAY_cdat
            add_log_entry2(35, p, msg);
            #endif
         }
      }





                  Packet("serr"); // server error
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(mwPS.frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);









old:

      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sp = PacketGet1ByteInt();
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx sdat player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

            // this used to be a function , client timer adjust
            players1[p].client_sync = sdat_frame_num - mwPS.frame_num;
            int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;



new:
      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

         // this used to be a function , client timer adjust
         players1[p].client_sync = sdat_frame_num - mwPS.frame_num;
         int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;










old:

int process_stdf_packet(void)
{
   int retval = 0;
   int p = PacketGet1ByteInt();
   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   if (p != active_local_player)
   {
      sprintf(msg, "ERROR! rx stdf player:[%d] does not match local player:[%d]\n", p, active_local_player);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
   }
   else
   {
       memcpy(client_state_buffer + stdf_sb, packetbuffer+23, stdf_sz);  // put the data in the buffer












new:


int process_stdf_packet(void)
{
   int retval = 0;
   int p = active_local_player;

   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   memcpy(client_state_buffer + stdf_sb, packetbuffer+22, stdf_sz);  // put the data in the buffer








removed these from server:

void proc_server_check(void)
{
   for (int p1=1; p1<NUM_PLAYERS; p1++)
      for (int p2=1; p2<NUM_PLAYERS; p2++)
         if (p1 != p2)
         {
            int p1w = players1[p1].who;
            int p2w = players1[p2].who;
            if ((p1w != 99) && (p2w != 99))
               if (p1w == p2w) // we have a duplicate
               {
                  // do something here
                  sprintf(msg, "ERROR! duplicate whos for player:[%d] and player:[%d]\n", p1, p2);
                  printf("%s", msg);
                  #ifdef LOGGING_NETPLAY
                  add_log_entry2(10, 0, msg);
                  #endif
               }
         }
}


// check to see if this packet is from who its supposed to be and is valid
int check_packet_who(int p, int who, int type)
{
   if (players[p].control_method != 2)
   {
      //check if the player we received data for is an active client
      //sprintf(msg, "ERROR! rx cdat for player[%d].control__method[%d] != 2\n", p, players[p].control_method);
      //printf("%s", msg);
      //#ifdef LOGGING_NETPLAY
      //add_log_entry2(10, p, msg);
      //#endif
      return 0;
   }
   if ((players1[p].who != who) && (players1[p].who != 99))
   {
      char tmsg[80];
      if (type == 1) sprintf(tmsg, "cdat");
      if (type == 2) sprintf(tmsg, "sdak");
      if (type == 3) sprintf(tmsg, "stak");

      sprintf(msg, "ERROR! rx %s player[%d].who[%d] does not match packet who[%d]\n", tmsg, p, players1[p].who, who);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
      return 0;
   }
   return 1;
}


done.....

does it still work??...yes



warps on netgame???

warp starts next level immediately
client does not even join
but then client times out and quits

is the whole level done thing too complicated?


added global int next_level

added
play_level = next_level;
in proc_level_done()

added
next_level = play_level + 1;
in item exit collision


changed warp from:
play_level = item[x][8];
start_mode = 1;

to:
next_level = item[x][8];
level_done = 1;
game_event(4, itx, ity, 0, 0, 0, 0);

now warp should be exactly like exit except for the next level




-------------------------------------

dif is not really used by server, it just uses a local variable of the same name...

i propose more renaming:

old:

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;           // client only
extern int dif_dst;           // client only


new:
extern char client_state_dif[STATE_SIZE];
extern int client_state_dif_src;
extern int client_state_dif_dst;

---------------------------------------------------

ok now final looks like:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

// local client's states
extern char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
extern int  client_state_buffer_pieces[16];   // to mark packet pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state
extern int  client_state_base_frame_num;      // last ack state mwPS.frame_num
extern char client_state_dif[STATE_SIZE];     // uncompressed dif
extern int  client_state_dif_src;             // uncompressed dif src mwPS.frame_num
extern int  client_state_dif_dst;             // uncompressed dif dst mwPS.frame_num




------------------------------------

why do I use:
7 x memmove
7 x memset
27 x memcpy

---------------

working on join...

i want to move client_block_until_good_stdf_received(void)
to right after block for SJON rx

removed from main clinet loop:
if (mwPS.frame_num == 0) client_block_until_good_stdf_received();

added right after SJON rx:
client_block_until_good_stdf_received();

done and works, even after level done

but don't I need to call it in client loop for level done rejoin?

I guess not....
client and server should have just both loaded new level, no need to wait for state.

i'll leave it in for now, so it gets called from both places













i want to clean up the init code for client, its kinda like spaghetti...
could be a lot clearer....



now:

client_init
  - client_init_driver()
  - client_init_join()
     - send CJON
     - block wait for SJON
     - client_block_until_good_stdf_received()
        - block for good state





what if I flatten it all out


client_init
  - client_init_driver()
  - send CJON
  - block wait for SJON
  - block for good state





did a lot of cleaning up the client init stuff

now:

client_init
  -ClientInit
  -check for reply
  - client_init_join()




  moved check for reply to ClientInit
rename ClientInit to ClientInitNetwork()


now:

client_init
  -ClientInitNetwork()
  -client_init_join()


much better....

rename ServerInit to ServerInitNetwork() also...

renamed server and client exit also
now called after every call to server init (3 times each in main)


client exit takes care of resetting player stuff like:

   ima_client = 0;
   players[0].active = 1; // local_control
   active_local_player = 0;


no need to do it anywhere else, like if join fails...

change init_player(p,1)

to set inactive, not active....

client_init_join() is looking good

void client_block_until_good_stdf_received(void) is looking good.

its been coming along nicely......



redo where server chooses new client color...

   int color = req_color;  // try to use requested color, unless already used by another player
            int color_used;
            do
            {
               color_used = 0;
               for (int q=0; q<NUM_PLAYERS; q++)
                  if ((players[q].active) || (players[q].control_method == 9) || (players[q].control_method == 2))
                     if (color == players[q].color)
                     {
                        if (++color > 15) color = 1;
                        color_used = 1;
                      }
            } while (color_used);


make a function called:

int is_player_color_used(int color);


int is_player_color_used(int color)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) || (players[p].control_method == 9) || (players[p].control_method == 2))
         if (color == players[p].color) return 1;
   return 0;
}

   // try to use requested color, unless already used by another player
   while (is_player_color_used(color)) if (++color > 15) color = 1;

hell also fix why color and bitmap index are off by 1
shifted all my player bitmaps up one in tilemap
lose bitmap, only use color...
its in player1 struct whicg I dont want to mess with the size of
i'll just rename it there to find all refs then change them to use color instead
done...

now only color, no bitmap index...yay!!!


int who is a static int in server loop...

should I make it a global? no

who uses it?

CJON yes
stak no
sdak no
cdat no




rename a bunch of client and server functions...

move packet processing to one function for each packet type..


should I remove #ifdefs for logging...yes...


one file at a time..

client...done

bandwidth???
// gets the values in send and rx functions
#ifdef NETPLAY_bandwidth_tracking

leave bandwidth for now, do all others


server...done

now search for

#define LOGGING..done
#define LOGGING_NETPLAY..done
#define LOGGING_NETPLAY_JOIN..done
#define LOGGING_NETPLAY_client_timer_adjust..done
#define LOGGING_NETPLAY_cdat..done
#define LOGGING_NETPLAY_game_move..done
#define LOGGING_NETPLAY_sdat..done
#define LOGGING_NETPLAY_sdak..done
#define LOGGING_NETPLAY_stdf..done
#define LOGGING_NETPLAY_stdf_all_packets..done
#define LOGGING_NETPLAY_stdf_when_to_apply..done
#define LOGGING_NETPLAY_show_dif1..done
#define LOGGING_NETPLAY_show_dif2..done
#define LOGGING_NETPLAY_bandwidth.. only one in void process_bandwidth_counters(int p)..done

kill all these defines....done

// not this one
#define NETPLAY_bandwidth_tracking.. 6 in packet tx and rx fnx and  process_bandwidth_counters(int p)



still seems to work...


----------------------
20180518 code stats:
----------------------
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)

----------------------
20180605 code stats:
----------------------
39 files
18830  code only
 5177  empty lines
 3253  comment lines
 3333  code and comment
30393  total

25416 total - empty
22163 total - (empty + comment only)




main

NET_CONN *ListenConn = NULL;                         // listening connection
NET_CONN *ClientConn[MAX_CLIENTS] = {NULL, };        // array of connections for each client

NET_CHANNEL *ListenChannel = NULL;                   // listen channel
NET_CHANNEL *ClientChannel[MAX_CLIENTS] = {NULL, };  // array of channels for each client

int ClientNum = 0;

NET_CONN *ServerConn = NULL;
NET_CHANNEL *ServerChannel;


pm.h

// libnet client
#define MAX_CLIENTS 32
extern int ClientNum;

// libnet client TCP
extern NET_CONN *ListenConn;
extern NET_CONN *ClientConn[MAX_CLIENTS];

// libnet client UDP
extern NET_CHANNEL *ListenChannel;
extern NET_CHANNEL *ClientChannel[MAX_CLIENTS];

// libnet server TCP
extern NET_CONN *ServerConn;
// libnet server UDP
extern NET_CHANNEL *ServerChannel;

fixed this to only be in n_server and n_clinet
they are never refernced oytside these files...done




all the times when I am trying to break out of a loop with F11 or ESC I need to call proc_controllers()

I can only think of 2 times...
when client blocks waiting for SJON
when client blocks waiting for initial state

done....



make a way to have only one copy of the lhs panel with all the links..

what if I make my own tag that does nothing but mark where this is
then I can search and replace in files for anything in between these tags...

<mdw_lhs_nav>   </mdw_lhs_nav>

what language should I use to do this?
perl?

activeperl 5.24.3

# this updates the left hand side navigation panel in all html files in the current directory

# get the new text
open(MDATA, "<lhs_nav.html");
my $b = do {local $/; <MDATA>};

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   # print $file . "\n";

   # open the file to replace text in
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # replace the text
   $a =~ s/<mdw_lhs_nav>(.*)<\/mdw_lhs_nav>/<mdw_lhs_nav>$b<\/mdw_lhs_nav>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}












make an automated way to make a link list at the top of every file
like each header <mh7>
will have an anchor tag and be in a list at the top of the file

I will need to redo all of my mh7's as anchors


make a script to show all mh7 tags by filename...


this is how I do it in index.html:
<a name="description"></a>
<br><mh6>Description:</mh6>

then a link to that looks like this:
<a href="index.html#description" target="_top">Description</a>

this is how it looks in the other files:
<br><mh7>Overview</mh7>


change mh6 to mh7
the only place mh6 is used is in index...change them all...
done and removed mh6 from css

now only mh7...



now I have a list of mh7 tags in each file...


i should change each tag to a common format:

<mh7>Overview<a name="Overview"></a></mh7>

test this...

do it like this instead:
<br><a name="Overview"></a><mh7>Overview</mh7>

Yes...do them all like this...

can I automatically do it???


still not sure...

I want the whole thing wrapped in a unique tag

why? I dont plan on modifying it, just making auto TOC from it

can I use spaces in my names??yes


manually make them all look like this:
The name exactly the same as the anchor

<a name="Features"></a>
<mh7>Features</mh7>

do it in index first...
works good there.

copy all back to main dir on desktop...

now manually edit all mh7 tags...

do this in main dir...

blank.html - none

-----------------
display.html..done
-----------------
Global variables
Creating the Display
Process Screen Change
Display Transform Double
Detecting Window Move

-----------------
events.html..done
-----------------
Overview
Processing the event queue
Processing events
Handling multiple resize events

-----------------
game_moves_array.html..done
-----------------
Overview
The Game Moves Array
Netgame
Special Game Moves

-----------------
index.html..done
-----------------
Description
Demo Video
Features
Created by
Created with
License
Supported Systems
External Links
Older Versions
History

-----------------
input.html..done
-----------------
Overview
Keyboard Input
PRINTSCREEN hack
Mouse Input
Joystick Input
Bindings vs Controls

-----------------
level_array.html..done
-----------------
Overview
Drawing the Level Array
Rebuilding level_background
Drawing Sequence in the Game Loop
Get New Background
Get New Screen Buffer
Scale Factor

-----------------
lhs_nav.html
-----------------

-----------------
logo.html..done
-----------------
Demo Video
Overview
Splines
Setup of points on the grid

-----------------
netgame_config.html..done
-----------------
Overview
Settings you probably shouldn't change!

-----------------
netgame_join.html..done
-----------------
Overview
Client sends CJON
Server receives CJON and replies with SJON
Client blocks until it receives SJON
Client blocks until it gets initial state from server
Client chase and lock
Packets used for join

-----------------
netgame_main.html..done
-----------------
Overview
Game Move Sync
Client sends control change
Server receives control change
Server sends game move data to clients
Client receives game move data from server
Timing
Control lead frames
Player numbers
Player's control methods
Level Done

-----------------
netgame_packets.html..done
-----------------
Overview

-----------------
netgame_state.html..done
-----------------
Overview
Game state variables
Global variables for state correction
How a client gets a new state from the server
How a client applies the new state
How the server sends a new state dif to a client
Packets used for state correction

-----------------
netgame_status.html..done
-----------------
Overview
server_sync
client_sync
server_game_moves_sync
client_game_moves_sync

-----------------
sound.html..done
-----------------
Overview
Sound Setup
Mixer Volume Controls
Theme Music
Sound Effects
Sample Delay
Processing the Hiss Sound

-----------------
tiles.html..done
-----------------
Overview
Creating Tile Bitmaps
Loading Tile Bitmaps
Rebuilding Tile Bitmaps

-----------------
timers.html..done
-----------------
Overview
Menu Timer (mnu_timer)
Second Timer (sec_timer)
Frames per Second Timer (fps_timer)
Speed adjust during netgame


now that all of this is done I can get back to making my toc's



perl script: make_toc.pl

# makes a toc using <mh7> tags
# inserts the toc between <mdw_file_toc> tags

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   print "\nfile:$file\n";
   print "---------------------------------\n";

   # open the file
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # find <mh7> tags
   my @matches;
   push @matches, $1 while $a =~ /.*(<mh7>.*<\/mh7>)/g;

   # multi line toc we are going to insert
   my @toc;

   foreach (@matches)
   {
      #print $_ . "\n";

	  # strip tags
	  $_ =~  /<mh7>(.*)<\/mh7>/;
      $_ = $1;
      print $_ . "\n";

      # add single line in toc
      $toci = "<a href=\"$file\#$_\" target=\"_top\">$_</a>\n";
	  push @toc, $toci;
   }
   #print @toc;

   # replace the toc between <mdw_file_toc> tags
   $a =~ s/<mdw_file_toc>(.*)<\/mdw_file_toc>/<mdw_file_toc> @toc<\/mdw_file_toc>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}


tag in source files...

<mh3><hr></mh3>
<mh8>Tiles</mh8>
<mh3><hr><mdw_file_toc> </mdw_file_toc><hr></mh3>


display.html..done
events.html..done
game_moves_array.html..done
index.html..not done
input.html..done
level_array.html..done
logo.html..done
netgame_config.html..done
netgame_join.html..done
netgame_main.html..done
netgame_packets.html..done
netgame_state.html..done
netgame_status.html..done
sound.html..done
tiles.html..done
timers.html..done

wow, all of this stuff is looking good...




find all css tags and remove unused

header_main..removed...
mh12 removed
mh2 removed
mh4 removed
mh5 removed

mh3 - body text (368)
mh7 - section title (178)
mh8 - file title (34)

mh10 - by: Michael David Weiss (2)
mh11 - Purple Martians title only (68)
mh12 - Technical Code Description only (32)

me1 - secondary header used in netgame config and netgame status

pk0 - packets
pk1 - packets






I want to simplify this:

The offsets from 6,7 are not necessary

old:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points are relative to outer arm 0 positon
   points[0][2] = points[0][6] + 85;
   points[0][3] = points[0][7] + 107;
   points[0][4] = points[0][6] + 95;
   points[0][5] = points[0][7] + 31;

   // inner arm is relative to outer arm
   points[2][0] = points[0][6] + 30;
   points[2][1] = points[0][7] + 30;
   points[2][2] = points[0][6] + 77;
   points[2][3] = points[0][7] + 32;
   points[2][4] = points[0][6] + 93;
   points[2][5] = points[0][7] + 53;
   points[2][6] = points[0][6] + 109;
   points[2][7] = points[0][7] + 69;


new:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points
   points[0][2] = -115;
   points[0][3] = -93;
   points[0][4] = -105;
   points[0][5] = -169;

   // inner arm
   points[2][0] = -170;
   points[2][1] = -170;
   points[2][2] = -123;
   points[2][3] = -68;
   points[2][4] = -107;
   points[2][5] = -147;
   points[2][6] = -91;
   points[2][7] = -131;



looking in game moves thingy
do I make a clear distinction between keys and controls??
I have a function called clear_keys(), that actually clears controls
renamed clear_keys() to clear_controls()
void set_comp_move_from_controls(int p)...never used. delete




web game move array is looking really good...


why do I use:
7 x memmove
7 x memset
27 x memcpy
replaced memmove with memcpy...


0 x memmove
7 x memset
32 x memcpy

1 - client reads stdf and put data in buffer
1 - server builds stdf packet

1 - server updates client's base state

7 - game_vars_to_state(char * b)
7 - state_to_game_vars(char * b)

14 - show_state_dif(char *a, char *b)

1 - add_log_entry2(int type, int player, const char *txt)



Can this be made simpler?

   // check to see if frame_nums match and its time to apply dif
   if (mwPS.frame_num == client_state_dif_dst) // current mwPS.frame_num is dif destination
   {
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         // if server has sent dif from src == 0, reset our base to 0
         if (client_state_dif_src == 0)
         {
            memset(client_state_base, 0, STATE_SIZE);
            client_state_base_frame_num = 0;
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
         }
         else
         {
            sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
         }
      }
      if (client_state_base_frame_num == client_state_dif_src)  // stored base state matches dif source
      {


how about this?

   // check to see if frame_nums match and its time to apply dif
   if (mwPS.frame_num == client_state_dif_dst) // current mwPS.frame_num is dif destination
   {
      // if server has sent dif from src == 0, reset our base to 0
      if (client_state_dif_src == 0)
      {
         memset(client_state_base, 0, STATE_SIZE);
         client_state_base_frame_num = 0;
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
      }
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
      }
      else // stored base state matches dif source
      {


simplify this:

   if (start_mode < 3) // normal or run game
   {
      mwPS.frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


   if (start_mode == 3) // new level after level done
   {
      stamp();
      mwPS.frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


done:

   if (start_mode == 3) stamp(); // new level after level done

	mwPS.frame_num = 0;
	if (!load_level(play_level,0))
	{
		game_exit = 1;
		resume_allowed = 0;
	}



run demo mode does not use stored player color...

probably because color won't get set if player is already active....

fixed...
now restore saved color after demo play...
where??

demo play can end where?

level done
esc pressed..

how about when called from menu...done
and when called from demo mode...done





sort out init_player()

type 1 - all
type 2 - level done
type 3 - netgame join




8 calls

initial_setup()
calls 1 for every player

load_gm()
calls 1 for every player

proc_start_mode()
calls 2 for every player

client_init_join() after SJON rx'd
calls 1 for every player


server_exit()
calls 3 for every player ???? why??


server_init()
calls 1 for player 0


server_join
calls 1 for new player slot before tx SJON

proc_player_state_game_move()
calls 3 when new demo mode player comes active




there are a lot of things going on here....

make init_player call itself...


make some more specific calls

like 23 = clear bandwidth counters..done



game_move_entry_pos..used only by server....
don't clear on netplay join??..dont think it matters



i think I can get rid of 2 and 3 specifics...done

   if (t == 2) // level done
   {
      players1[p].game_move_entry_pos = 0; // server only  ( for client game_move data sync )
      players1[p].server_last_sdat_sent_frame_num = 0; // only server uses it, to keep track of when last sdat was sent to client
   }

   if (t == 3) // netplay join
   {
      players1[p].server_last_sdak_rx_frame_num = mwPS.frame_num + 200;
   }

now change the 2 calls to 3 to 2's..done




looks a lot cleaner now...hope it all still works....


i should set control_method to 0 in init 1



demo mode won't quit with any key...

esc just starts new demo...



make a new list of where I call init_player()

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;



when client rx SJON
-------------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[cp].control_method = 4;
ima_client = 1;
active_local_player = cp;
players[cp].color = color;
players1[cp].game_move_entry_pos = server_game_move_entry_pos;



server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = mwPS.frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this




this one was probably an issue so i removed it:
proc_player_state_game_move(int x)
----------------------------------
// player becomes active
if ((players[p].active == 0) && (val > 0) && (val < 16))
{
	init_player(p, 1);
	players[p].active = 1;
	players[p].color = val;
	players1[p].join_frame = mwPS.frame_num;



proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


demo_mode()
-----------
after pm_main is done:

// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 1;
active_local_player = 0;




in netgame client only stays alive for approx 5 sec or 200 frames after lock

can do next level good, but then 5s into next level same...

demo seems to exit good now...


-----------

when client quits...player lost server connection

this was missing:
void client_process_sdat_packet(void)
{
   players1[p].client_last_sdat_rx_frame_num = mwPS.frame_num;

seems to work good now...


there are 3 places after run game where stuff is reset...can i make it one place?
actually only 2...commandline line immediatley exits
easier to make them the same...done


when new players come active in demo mode they don't start at the right position

how about when they come active at all...

when is 'get_player_start_pos()' called? 3 times:

in load level for player 0 only

after death

init player mode 2 (after level done)

--------------------


remove from init player mode 2 (after level done)

add to when they come players come active


----------------------------------------------------------
Make a new list of when set_player_start_pos called
----------------------------------------------------------
3 times
- load level for all players
- when player comes active
- after death


----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;




server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;

server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;




server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = mwPS.frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


not sure about this one:

its run every time start_mode loads a level
- new game
- level done
- NOT run game


i agree its not needed for run game, because load_gm took care of that

what does new game set up before start mode?? nothing

i should bring back start_mode 3


redo start modes....         start_mode = 1;
         game_exit = 0;

1 = new game (single player) do init 1
2 = level done (do init 2)


3 = new game (client

9 = file play

done...

now make start mode 1 clear everything

I can't beacuse it is called by single player start as well as server and client




proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);



------------------------------------------------------------------
major refactor...
------------------------------------------------------------------


I want to have more of my start up code in pm_main.


change its name to game_loop

make it take a variable..start_mode

make it set game_exit = 0 on entry



make it so that all the times its called for each mode, the code is common

make it so that more of my player setup is doen there.




how many modes can it be started in??


1 single player new game
2 server new game
3 client new game
5 level done
7 resume single player
9 run demo mode

also make some common exit code




list where called:
-demo mode

game menu x 6
-new
-resume
-server
-client
-after level editor
-run demo


command line x 7
- client 1 arg
- server 1 arg
- client 2 arg
- server 2 arg

- immed run 1 arg
- immed run 2 arg

- run demo



---------------------------------------------------------

game_exit = 0 set in game_loop start
rename pm_main to game_loop and pass it start_mode
then in turn pass start mode to proc_start_mode()

I can make start mode totally local to game_loop, but how will I deal with level_done setting it??

for now just set global to passed...

void game_loop(int passed_start_mode)
{
   start_mode = passed_start_mode;
   game_exit = 0;

this is all because of proc_level_done which also sets start_mode

game_loop()
   proc_controllers()
      proc_game_move()
         proc_level_done()

ill fix this later....

next move this to proc_start_mode()


   if (start_mode == 2) // server
   {
      if (!server_init())
      {
         server_exit();
         game_exit = 0;
      }
   }

   if (start_mode == 3) // client
   {
      if (!client_init())
      {
         client_exit();
         game_exit = 0;
      }
   }


make common exit code after

void game_loop(int passed_start_mode)
{
   while (!game_exit) // game loop
   {
   }

   // common exit stuff...
   if (ima_server) server_exit();
   if (ima_client) client_exit();
}



-------------------------------------------------------
now client init is only called once in start mode...
now client exit is called only 2 times...
once if client init fails
once at end of game loop if ima_client

same for server...


test...join good.


server can't re-start...failed to open listening channel....


is something setting ima_server to 0 before game_loop ends??

yes...proc_game_move when player goes inactive..
remove all stuff from there that messes with client or server player stuff
do it at end of game_loop()

done...

when client is waiting to join set level display to start pos...


moved player init to proc_start_mode common like this:

   if (start_mode == 5) // start new level after level done
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
   }
   else // 1, 2, 3, 9 - full player data reset
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
   }


then removed from:
client init()
server_init()
load_gm()


----------
test
single player good
client join good

client needs to set player pos while waiting to join...fixed
in load_level() set all players pos not just 0

client seems to take longer to join now...



----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


proc_start_mode()
------------------
if (start_mode == 5) // start new level after level done
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
}
else // 1, 2, 3, 9 - full player data reset
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
	players[0].active = 1;
}


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;

server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = mwPS.frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file

I am pretty confident about this....

----------------------------------------------------------------------------------

start_mode...

start_mode when calling game_loop only need to be processed the first time
EXCEPT for level done...

why not just make an exception for that...

make level_done have a new value of 2...

in game_loop:

if (level_done == 2) proc_start_mode(5);

before game_loop while

start_mode is no longer global and has a very small scope



---------------------------------
list of all level_done references
---------------------------------

in start_mode common set to 0

in item collision door and warp, set to 1

in single player control:
if (level_done == 1) add_game_move(mwPS.frame_num, 6, 0, 0);

in server_local_control(int p)
if (level_done == 1) add_game_move(fn, 6, 0, 0);

in proc_level_done()
level_done = 2;

in game_loop()
if (level_done == 2) proc_start_mode(5);


----------------------------------------
list of all places resume_allowed is set
----------------------------------------

only 2 places set to 0
- level is loaded
- start level changes

only one place set to 1
- exit game in single player mode

-----------------------------------------------------------

demo mode wont quit...
esc just starts new demo

fixed start mode resetting control_method 1
remove setting control_method 1 in load_gm...now just done in start mode


-----------------------------------------------
List of at all the places control_method is set
-----------------------------------------------

zplayer.cpp sets it  1 time
---------------------------
init_player (full mode)
players[p].control_method = 0;


zclient.cpp sets it 5 times
---------------------------
when SJON rx
players[cp].control_method = 4;

4 times for check dif


zserver.cpp sets it 2 times
---------------------------
in server_init
players[0].control_method = 3; // server_local_control
ima_server = 1;

when setting up new client
players[cn].control_method = 2; //server client view only

zcontrol.cpp sets it 2 times
----------------------------
when player comes active:
if ((ima_server) || (ima_client))
   if (p != active_local_player) players[p].control_method = 2;
// if player 0 is file play all added players will be too
if (players[0].control_method == 1) players[p].control_method = 1;

when remote client goes inactive:
players[p].control_method = 9; // prevent re-use of this player number in this level


zloop.cpp sets it 2 times
-------------------------
after level done free used clients
if (players[p].control_method == 9) players[p].control_method = 0;

in proc_start_mode()
if (start_mode == 9) players[0].control_method = 1;




fixed bug in load gm that was only erasing 10,000 game moves instead of 1,000,000
look at all references to game_moves
made a common clear_game_moves()
made a define for GAME_MOVES_SIZE 1000000



old:

   if (--players1[p].made_active_holdoff < 0) players1[p].made_active_holdoff = 0;
   if ((!players1[p].made_active_holdoff) && (players[p].active == 0) && (players[p].control_method == 2) && (players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      players1[p].made_active_holdoff = 6;
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }


new:

if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
{
   if (players1[p].made_active_holdoff) players1[p].made_active_holdoff--;
   else if ((players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      players1[p].made_active_holdoff = 6;
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }
}




-------------------------------------------------------------
I should straighten out what happens when a player quits...
-------------------------------------------------------------

it all starts when a player presses the menu key or escape...

all modes:

set_comp_move_from_player_key_check(p);

// if menu key ignore everything else and set to 127
if (mI.key[players1[p].menu_key])  cm = 127;
if (mI.key[ALLEGRO_KEY_ESCAPE])    cm = 127;


when this comp_move is sent to add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);

it is converted to a special player state move:

if ((type == 5) && (data2 == 127)) // change menu key to player state inactive special move
{
	game_moves[game_move_entry_pos][0] = frame;
	game_moves[game_move_entry_pos][1] = 1;     // type 1; player state
	game_moves[game_move_entry_pos][2] = data1; // player num
	game_moves[game_move_entry_pos][3] = 64;    // inactive
	game_move_entry_pos++;
	return; // to exit immediately
}


single player adds to local game moves array

in proc game move:
if (players[p].control_method == 0)
{
	game_exit = 1;
	resume_allowed = 1;
}


client sends raw move (5, 127) to server
server has special case to set frame to future (frame + 2)
server adds it with add_game_move() where it is converted to player state

server has a special case that just adds 2 to the frame number
   // this special case here is to fix bug that occurs when server_lead_frames > 0, and quit move doesn't get synced back to the client
   if (cm == 127) // client quit
   {
      add_game_move(fn+2, 5, p, cm);  // put in future
      sprintf(tmsg2,"<-- player:%d quit\n", p);
   }
   else
   {
      if (c_sync >= 0) add_game_move(fn, 5, p, cm); // add to game_move array


server drops client in proc_game_move() like this:
         // remote player quit
         if (players[p].control_method == 2)
         {
            players[p].active = 0;
            players[p].control_method = 9; // prevent re-use of this player number in this level
            players1[p].who = 99;

            // only makes sense to show this if not local player
            show_player_join_quit_timer = 60;
            show_player_join_quit_player = p;
            show_player_join_quit_jq = 0;
         }
other clients drop this client in the same way



client drops itself in proc_game_move() like this:
         // local client player quit
         if (players[p].control_method == 4)
         {
            if (val == 64) players1[p].quit_reason = 90;
            game_exit = 1;
            if (L_LOGGING_NETPLAY)
            {
               sprintf(msg,"Local Client(%s) quit the game.",local_hostname);
               add_log_entry_header(10, p, msg, 1);
               log_ending_stats();
            }
         }



what if I add to the frame number in add_game_move()??
then I can remove exception in server rx cdat

it will add for all modes, but that should be OK...

do it...done...still works...


what happens with player drop?
client...
quits the whole damn game with fast exit()!
that's too severe...what else can I do?

set game_exit = 1?

before that I want other client and server to know whats happening
or should I let the server take care of that??

well, if I've lost server connection, it doesn't make sense to send something to the server...

lets just set game_exit = 1 and:
players1[p].quit_reason = 75;
log_ending_stats();

the code at the end of game loop will clean up for me...

server:


void server_proc_player_drop(void)
{
   // check to see if we need to drop clients
   for (int p=1; p<NUM_PLAYERS; p++)   // server only; skip p[0]
      if (players[p].control_method == 2)
      {
         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
            add_game_move(mwPS.frame_num + 4, 1, p, 71); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
         if (players1[p].server_last_sdak_rx_frame_num + 100 < mwPS.frame_num)
         {
            //printf("[%4d][%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_last_sdak_rx_frame_num, p);
            add_game_move(mwPS.frame_num + 4, 1, p, 71); // make client inactive (reason no sdak for 100 frames)

            sprintf(msg,"Server dropped player:%d (last sdat rx > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
      }
}

---------------------------------------
how does quit reason work?
---------------------------------------

in the player struct we have: players1[p].quit_reason

void log_reason_for_client_quit(int p)
{
   char tmsg[80];
   sprintf(tmsg,"unknown");
   int r = players1[p].quit_reason;
   if (r == 64) sprintf(tmsg,"player quit game with ESC");
   if (r == 70) sprintf(tmsg,"server drop (server sync > 100)");
   if (r == 71) sprintf(tmsg,"server drop (no sdak for 100 frames)");
   if (r == 74) sprintf(tmsg,"client never became active");
   if (r == 75) sprintf(tmsg,"client lost server connection");
   if (r == 80) sprintf(tmsg,"level done");
   if (r == 90) sprintf(tmsg,"local client quit");
   if (r == 91) sprintf(tmsg,"local server quit");
   if (r == 92) sprintf(tmsg,"remote server quit");
   sprintf(msg,"reason for quit...........[%s]", tmsg);
   add_log_entry_position_text(22, 0, 76, 10, msg, "|", " ");
}



when client drops due to lost server connection:
players1[p].quit_reason = 75;
log_ending_stats();




in proc_game_move() when the special game move player state is read,
if (val > 63) it a player drop and val is quit reason


when players quit with esc reason is set to 64
this is done in add_game_move() and is common to all...

when players are dropped by server it is set to 70 for sync and 71 for sdak


proc_game_move() reads the special game move player state and if inactive:
by default sets:  players1[p].quit_reason = val;
at this point it could be 64, 70, 71

then can set these modes:

74 player never became active
90 local client quit the game
91 local server quit the game
92 remote server ended the game

at the end on set inactive:

         if (players1[p].quit_reason == 70) log_ending_stats();
         if (players1[p].quit_reason == 71) log_ending_stats();
         if (players1[p].quit_reason == 74) log_ending_stats();
         if (players1[p].quit_reason == 90) log_ending_stats();
         if (players1[p].quit_reason == 91) log_ending_stats_server();
         if (players1[p].quit_reason == 92) log_ending_stats();

---------------------------------
where is log_ending_stats called?
---------------------------------
4 main places:

proc_game_move() - player inactive
client drop
level done
fast_exit()



made a lot of changes...need to test...something do not seem right....


-----------------------------------------------------------
client init code no line endings in log...fixed
-----------------------------------------------------------

-----------------------------------------------------------
show dif local and server reversed??
-----------------------------------------------------------
void show_state_dif(char *a, char *b)

// make copy of current state
char tmp[STATE_SIZE];
game_vars_to_state(tmp);

// compare copy to modified base state
if (memcmp(tmp, client_state_base, STATE_SIZE))
{
   dif_corr = 1;
   players1[p].dif_corr++;
   sprintf(tmsg, "corrections applied - total corrections:%d", players1[p].dif_corr);
   show_state_dif(tmp, client_state_base); // show dif


looks like a is local b is server

then c1 = a, c2 = b


then here its printed in reverse....

sprintf(msg, "player[%d].active  server:[%d] local:[%d]\n", p, c1_players[p].active, c2_players[p].active );


where would it be easiest to change?

show_state_dif(client_state_base, tmp); // show dif

done.....
-----------------------------------------------------------


-----------------------------------------------------------
when demo runs it leaves log file entries ..done
added erase_log(void);
at end of demo mode and run demo
-----------------------------------------------------------

-----------------------------------------------------------
log player array uses player num for each player..fixe to only use 0 ...done
-----------------------------------------------------------

-----------------------------------------------------------
players colors in log file viewer are bad...
try to get them from the logs
also set them in player init...
too hard, just set them when getting data at start of log file viewer..done
-----------------------------------------------------------








-----------------------------------------------------------
no logging when player come active???
what if client comes active because of stdf instead of game move??
-----------------------------------------------------------


250 server got join
371 server says player locked

492 server says player locked
496 server says player became active


on client
nothing around 371
at frame 500 stdf from 495 to 500 sets player active...


what does game moves say:

server:
-------------
number of entries 1473
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][ 375]-------------PLAYER 1 ACTIVE (color:11)--
[  1][ 496]-------------PLAYER 1 ACTIVE (color:11)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]

client:
-------------
number of entries 1470
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:4)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:10)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  3][ 507][1][ 4]  [    ][    ][    ][UP][     ][    ]



why is client missing those....

why is server missing start...

why does client have stuff that server does not??



old:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 3) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }

new:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 2) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }



this would explain why client had start info but server did not
also client had higher game move pos so it wouldn't enter new moves....

try this all again...seems to work a lost better now...

-----------------------------------------------------------
-----------------------------------------------------------


4 player works with ubuntu as one of them....

can I speed up chase and lock?

do I need the <2 > -4 things still?




--------------------------------------------------------------
when client joins, after getting initial state,

gets 14 more stdf until caught up and can acknowledge??

why cant we acknowledge first one??


looks like the first dif received was not applied
base was zero, but current did not match??
current = 0
should force...

does this happen every time? yes...

fixed that on client by setting mwPS.frame_num after initial stdf rx, but before dif applied...

now:

dif gets applied on client and clients sends sdak on frame 142

server does not rx until frame 163
by then server has sent many more stdf's and fails to set new base for client

why is client 20 frames behind??

client gets first timer adjust at 162 with first sdat rx and is already 20 frames behind
server sends it at 142


is client timer slow until first adjust?? no

does start mode write over my start frame stuff?? no



-----------
new data

client fps = 40
client gets all 4 pieces of stdf (0-150)
client applies dif and sets frame_nums to 150

[client frame 150]
recieves all 4 peices of same stdf again
receives sdat from 154 and sets timer to 43
receives 2 4 peices of next stdf (0-155)
applies dif (0-150) again


[client frame 151]
client timer = 43
receives sdat from 174 and sets timer to 62

[client frame 153]
gets complete dif from (0-175)

[client frame 157]
receives sdat from 178 and sets timer to 60

[client frame 161]
gets complete dif from (0-180)

[client frame 163]
receives sdat from 182 and sets timer to 58




------------------

does it do the level load??

client init

load level

game loop start

client blocks for initial state

client chase



-------------
new data

[client frame 121]
client gets all 4 pieces of stdf (0-121)
client applies dif and sets frame_nums to 121

[client frame 122]

receives sdat from 125 and sets timer to 42
client gets all 4 pieces of stdf (0-125)

receives sdat from 129 and sets timer to 46
client gets first 2 pieces of stdf (0-130)

receives sdat from 145 and sets timer to 62
client gets first 3 pieces of stdf (0-145)



what if i flush the client rx buffer after good state rx'd? no dif
try setting stdf freq to 80...no dif


still cant figure out why client is 20 frames behind...



I put some time calls in client code and I dont see any delays....
do the same for server...





server send initial state on server frame 144 clock 6785

client gets it at clock 1350 and sets frame 144 to equal clock 1352

client gets sdat on frame 145 clock 1371 from server frame 166

server's clock was 7335 when it sent sdat 166



time dif at initial state rx:
server sent:6785
client rx: 1350
------------------
           5435



time dif at first sdat packet
server sent:7335
client rx: 1371
------------------
           5964



5964-5435 = 529ms / 25ms per frame = 21 frames



server:
166-144 = 22 frame * 25ms = 550ms
6785 + 550 = 7335
server checks out good


client:





tried TCP also

started at 10 sync then went down for 10 frames to 8
then got 9 sdats in one frame and went to 29



--------------------
just a thought...what if I did the chase part first?
then when that was good, just blast a state through
after rx sjon client starts in mode 2 inactive and uses sdats to chase and lock
--------------------------------------


20180616

all that I am doing here is to discover the 20 frame half second pause between
getting initial state and getting first sdat..

on the server I show a time stamp at the start of every server_control()
and make sure they agree...


server
------
frame 214
8507 server tx sjon
8507 server tx sdat

then every 25ms clock is working good

server sends another sdat every frame for sync

frame 236
9058
finally rx sdak and stak


client
------
first clock is 1146 after level start
1147 waiting for game state
1150 214 mwPS.frame_num updated
1166 215 rx sdat and already 20 frames late

need more clocks on client...

client send cjon
client rx sjon


i think i found my delay.....

771 client tx cjon 771
803 client rx sjon 803
1313 after level start


705 tx cjon
746 rx sjon
768 after clear game moves array

stimp() takes 400 frames......

remove for netgame...

client for sure but also server for level done so just do both...

606 client tx cjon
624 client rx sjon
646 after clear game moves array
721 after load level

--------------------------------------------
just a thought....
I would love to do without load level for client joining and just let the initial state do it...
what is missing??
lift step data
bullets (not loaded with level anyway)

i load the level, but when I get initial state I overwrite almost everything

ok if add list steps, what else should I do??, bullets??
remove unused in player...

how big is lift steps?? 25600

lets just leave it for now...

--------------------------------------------

remove clocks...done

what if I made timer adjust twice as much adjust?

old
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - mwPS.frame_num;
   int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));

new
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - mwPS.frame_num;
   int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames)*2;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));




---------------------------------------------------------
just a thought

proc_controllers()

acts differently when in menu vs game

this is controlled by game_exit

what if I just passed something to proc_controllers()
run one way if in game, another for menu, another for key only...
maybe later.....


---------------------------------------------------------


restore all things...
- stdf_freq
- sync_freq


what about server send sync...

can i fine tune it for each player?

like if they have high server sync, send more often??


2 is normal (1 + server_lead_frames)

add to player struct:
int server_sdat_sync_freq;
by default set to 0;

0  every frame
1  every other frame
20 every 20 frames

adjust when setting sync, when rx'ing sdaks

done....


sometimes client gets ahead of server before rx first sync
then client can get a pile of sync sdat's and adjust timer for each one
but only the last one matters...

remove client_flush...

can i combine rx sdat and timer to one log line...done

set stdf_freq to 10


what if i hold off sending more stdf's after initial, until locked?
or until initial has been ack'd and new base set?


simplify this complicated mess....


         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         do
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
         } while ((players[p].control_method != 2) && (not_found < 8));
         if (not_found == 8) p = 0;   // if no clients found set to 0 so no send will happen
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send



         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         int loop_done = 0;
         while (!loop_done)
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
            if ((players[p].active) && (players[p].control_method == 2)) loop_done = 1;
            if (not_found > 8) // no clients found
            {
               loop_done = 1;
               p = 0; set to 0 so no send will happen
            }
         }
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send




run a test with 3 clients..all good

its important to flush client and server at level done and wait after...
not sure why...


----------------------------------------------------------------
if client does not get reply from server game starts anyway..fixed
----------------------------------------------------------------


----------------------------------------------------------------
when starting log file viewer with pm -lr, if no log files exits badly..fixed
----------------------------------------------------------------


----------------------------------------------------------------
don't save any log file unless in netgame mode..done
remove L_LOGGING and replace with L_LOGGING_NETPLAY...done
remove L_LOGGING_NETPLAY_timeradjust..done
move version and allegro version logging to client and server init..done
----------------------------------------------------------------


----------------------------------------------------------------
make server sdat log look like client sdat..done
----------------------------------------------------------------

----------------------------------------------------------------
reset ortho double when leaving log file viewer..done
can't set ortho in log file viewer..done
----------------------------------------------------------------

----------------------------------------------------------------
client has both ending stats....fixed....
----------------------------------------------------------------


ran 8 player game with no problems.....


lost y510 on level 5
reason: server drop (no sdak rx for 100 frames)
only active for 4 frames
first and only thing server received was stak on frame 247..really late


lost 4230j on level 6
reason: server drop (no sdak rx for 100 frames)


----------------------------------------
fix get all keys for linux..done
----------------------------------------

spent 6 hours making the graph for log file viewer look great...




in what nested way are these called??

all from game loop:
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();


int player_drop_item(int p);
3 x
1 x in player carry when item dropped
2 x item collision door entry


void draw_pop_message(int c);
1 x in draw_item

void draw_door(int c, int x, int y);
1 x in draw_item

void do_bomb_damage(int i);
1 x proc_lit_bomb();

void remove_block(int x, int y);
3 x
2 x proc_item_move(); key
1 x 1 x proc_lit_bomb();


--------how can i simplify these 6 calls from game loop?
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();

to compare, enemy has 3
enemy_move();
enemy_collision();
draw_enemy();


how are they iterated?

proc_item_collision();
500 items then 8 players

proc_item_move();
500 items

proc_lit_bomb();
500 items

proc_lit_rocket();
500 items

proc_player_carry();
8 players


I want to call:
proc_lit_bomb();
proc_lit_rocket();
from
proc_item_move();
done....now its only 4

proc_item_collision();
proc_item_move();
proc_player_carry();
draw_items();

can I move player carry somewhere??

add code in main player code to reset scale and rot if not in paused 2 or rocket
what if I just reset it by default and let someething change it if it needs to...
cant make that work..just reset after door move done and when drop rocket...

also when rocket explodes...
when rocket explodes it turns into a lit bomb
when lit bomb explodes force drop, reset scale and rot there... seems to work



now I want to patch this into main player move

void proc_player_carry(void)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (players[p].carry_item))
         if (!players[p].paused || (players[p].paused && players[p].paused_type == 2))// player is carrying item
         {
            int pc = players[p].carry_item-1; // number of item
            if (item[pc][0] != 98)            // not lit rocket
            {
               // set item position relative to player that's carrying it
               itemf[pc][1] = players[p].PY - al_itofix(2);
               if (!players[p].left_right) itemf[pc][0] = players[p].PX - al_itofix(15);
               if (players[p].left_right) itemf[pc][0] = players[p].PX + al_itofix(15);
            }
            if (!players[p].fire) // drop
            {
               if (player_drop_item(p) < 6)
               {
                  if (item[pc][0] != 98)            // not lit rocket
                  {
                     itemf[pc][2] = players[p].xinc;  // inherit the players momentum
                     itemf[pc][3] = players[p].yinc;
                     if (players[p].up)    itemf[pc][3] -= al_itofix(6); // throw item upwards
                     if (players[p].left)  itemf[pc][2] -= al_itofix(2); // throw item left
                     if (players[p].right) itemf[pc][2] += al_itofix(2); // throw item right
                  }
                  else // drop a rocket
                  {
                     players[p].draw_rot = al_itofix(0);
                     players[p].draw_scale = al_itofix(1);
                  }
               }
            }
         }
}

void proc_player_carry(int p)

done...


rot not fixed after death



lets rename zemove to zenemy..done

lets move all file stuff to zfile and lose yfilecom..done

lets put underscores in all z files..done




---------------------------------------------------------
what happens if a client gets a dif with the wrong base from the server?
a log entry is created, but no other handling is done...
this can't be an issue cause it works, I'm just curious....

when could this happen?
client updates base, but ack never makes it back to server...

then server will keep sending difs with new dest, but same src that client does not have
client will never ack, cause they have wrong base

how about if client gets wrong base, it acks with correct base?

this cant be done in apply because it checks every frame and will often have base

do it when the full packet is rx and decompressed...at that point the src better match...

maybe it can be done in apply, but only on the frame where dest = frame
yes, that should work...

its just re-sending the ack, that for some reason the server does not have
then the server will detect the mismatch and reset base to 0



      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);

         // send ack to server with correct acknowledged base state
         Packet("stak");
         PacketPut1ByteInt(p);
         PacketPut1ByteInt(0);
         PacketPut4ByteInt(client_state_base_frame_num);
         ClientSend(packetbuffer, packetsize);
      }


done.....
---------------------------------------------------------







next..how f'd are the collision checks

proc_item_collision();
500 items - 8 players


proc_enemy_collision();
100 enemies - 50 pbullets
            - 8 players


ebullets
50 ebullets - 8 players

pbullets
50 pbullets - 8 players



I could straighten this out by:
put both bullet checks and item in player

I'm already iterating players...


what needs collision checks?
player - pbullets
       - ebullets
       - enemies
       - items

enemy - pbullets

what if I make the functions like:

proc_player_item_collision(int p)



made all item collision for specific types into their own functions...

               switch (item[x][0]) // item type
               {
                  case 1: proc_door_collision(p, x); break;
                  case 2: proc_bonus_collision(p, x); break;
                  case 3: proc_exit_collision(p, x); break;
                  case 4: proc_key_collision(p, x); break;
                  case 6: proc_freeman_collision(p, x); break;
                  case 7: proc_mine_collision(p, x); break;
                  case 8: proc_bomb_collision(p, x); break;
                  case 10: item[x][6] = item[x][7]; break; // set pop-up message timer
                  case 11: proc_rocket_collision(p, x); break;
                  case 12: proc_warp_collision(p, x); break;
                  case 14: proc_switch_collision(p, x); break;
                  case 15: proc_sproingy_collision(p, x); break;
               }
            } // end of player collision with active item


now I want to call item collison from player_move

where should I do the collision detection?

this means that the order of things in the game loop will change...

old:

      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_collision();
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();
      proc_player_move();
      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();

new:
      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();

      proc_player_move();
      proc_item_collision();

      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();



done

now I call
proc_item_collision(p);
from player_move

collision detection takes place in proc_item_collision(p);

that looks good, now what else?

move ebullet collision to player also
done
proc_ebullet_collision(p);

now enemy collision with player..

         int i = players[p].carry_item-1; // number of item

ok now I have moved all to player move....
player - pbullets
       - ebullets
       - enemies
       - items

the only collision I have left is
enemy to pbullet


got rid of the global EN in z_enemy
now what about EXint and EYint??..done

also rearrage game loop stuff

move some things out of player_move to simplify...looks good

need to test....

of all the things I don't do when paused, i maybe should proc player carry?? so i can carry through doors?

bounds check to be its own funtion...


streamline the 4 player collisions in player move

one function to do all the collision checks, then only call:
proc_item_collision(p, c);
when an actual collision has take place

items:
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
            if ( (players[p].PX  > itemf[x][0] - f16 ) &&
                 (players[p].PX  < itemf[x][0] + f16 ) &&
                 (players[p].PY  > itemf[x][1] - f16 ) &&
                 (players[p].PY  < itemf[x][1] + f16 ) )
            {



enemies:
void proc_enemy_collision_with_player(int p)
{
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if enemy active and not deathcount
      {
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;

         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2)) Ei[e][22] = p+1; // player collision

      }
   }
}


void proc_pbullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (pbullet[b][0])  // if bullet not active skip to next one
      {
         // check for player collisions
         if (deathmatch_pbullets)
         {
            int px = al_fixtoi(players[p].PX);
            int py = al_fixtoi(players[p].PY);
            int bx = pbullet[b][2];
            int by = pbullet[b][3];
            if ((bx > px - 10) && (bx < px + 10) && (by > py - 10) && (by < py + 10))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet



void proc_ebullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (ebullets[].active[b])  // if bullet not active skip to next one
      {

         // player position
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         // check for collision with player
         if ((x > px-ax) && (x < px+ax) && (y > py-ay) && (y < py+ay))









void proc_player_collisions(int p)
{

   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // player position
   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;

   // pbullets
   if (deathmatch_pbullets)
   {
      for (int b=0; b<50; b++)
         if (pbullet[b][0])  // if active
         {
            al_fixed bx1 = al_itofix(pbullet[b][2]) - f10;
            al_fixed bx2 = al_itofix(pbullet[b][2]) + f10;
            al_fixed by1 = al_itofix(pbullet[b][3]) - f10;
            al_fixed by2 = al_itofix(pbullet[b][3]) + f10;
            if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet
               // do something
            }
         }
   }

   // ebullets
   for (int b=0; b<50; b++)
      if (ebullets[].active[b])  // if active
      {
         // new collision box is based on bullet speed and has both x and z component
         al_fixed ax = abs(e_bullet_fxinc[b]);      // enemy_bullet_collision_window x
         al_fixed ay = abs(e_bullet_fyinc[b]);      // enemy_bullet_collision_window y

         // enforce some minimums
         if (ax < al_itofix(4)) ax = al_itofix(4);
         if (ay < al_itofix(4)) ay = al_itofix(4);

         al_fixed bx1 = e_bullet_fx[b] - ax;
         al_fixed bx2 = e_bullet_fx[b] + ax;
         al_fixed by1 = e_bullet_fy[b] - ay;
         al_fixed by2 = e_bullet_fy[b] + ay;

         if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
         {
            // do something
         }
      }

   // enemies
   for (int e=0; e<100; e++)
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2))
         {
            Ei[e][22] = p+1; // player collision
         }
      }

   // items
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;

         if ((px > ix1) && (px < ix2) && (py > iy1) && (py < iy2))
         {
            // do something
         }
      }
}


----------------


I've made a lot of changes


now I need to do a thorough testing....

20180618

ride rocket
drop rocket
ride rocket till it explodes rarely doesnt reset player size and rot

where do i reset player size and rot?
now only one place...by default in move_player
after not paused, because I dont want to mess with paused
before rocket beacuse rocket will set it..
seems simpler and seems to work

ride lifts up and down don't line up good with lift floor
switched move lifts to before move_player

bombs...


ride rocket
drop rocket
ride rocket till it explodes
multiple player ride rocket
shoot while riding rocket
get hit with bullet while riding rocket

player item collison when riding rocket

ride rocket through door




doesnt drop rocket

according to door entry, items should be dropped if move type != -2
and rocket is set to -1

does it pick it up again really quick?

when riding rocket, i don't check for collisions?? no, i still do..

what do I want to happen?
when player riding rocket and hits door, drop rocket and travel through door

what actually happens?
nothing

player collision works for other items when riding rocket

when entering door rocket is dropped, but then picked up again right away...

both happen when processing item collision...

first door drops, then rocket pickes up...

how about if you drop an item one frame, you cant pick up until next frame...
sounds convoluted, is there an easier way??

its an exception for door entry only so things dropped stay dropped

why does re-picking up the rocket cancel door entry??
i dont know         int i = players[p].carry_item-1; // number of item


i think the door does the instant move for the player
but then the rocket moves it back

the players position for collision only happens before the iteration so when its is updated
its not used for further collsion checking

fixing this could fix it all and more...

done, now all collisions for player use actually players1.PX and PY so if
something in the collisions changes them, the next collisions will use the updated values


need to remove some test print code....



working on ride rocket through door
- only make sense if door if instant move
- can set to instant if auto and riding rocket



- will need to make rocket able to have carry through door flag set


looks like all rockets are set to -1, but code in slider buttons only does 0 and 1

do rockets need to be set to -1?

when touched they are changed to item 98
also if 0 or 1 set to -1
if -2 leave at -2

use glt to make all -1 rockets into 1
leave all 0

actually wouldn't it make more sense for rockets to be -2, -1, 0  ??

1 makes no sense for a rocket...

do it..

in glt set all 1 to -1...done
pde done...
sliders done...

looks like I have the ride rocket through door thing working....

what about carrying items through door?

if not -2 item is left behind

else appears at end after door move
works good, just looks funny when item is left behind during move then appears at end..

what if in paused mode, if carrying, do special draw for item carried??
at the very minimum, dont draw...
how can i set an item to not draw?

unused variables 2 for draw type
how about 1=drawn 0=not

later, this is so minor, add to wish list
------------------



------------------------------------------------
exit level in single player mode is broken

follow it through...

exit or warp sets level_done = 1;
move_player -> item collision...


single player local control adds game move..
proc game move sets to 2

they are in the wrong order in game loop.

before the level_done == 2 check is done, move player sets it back to one...
what's the solution?

make 2 variables? or change order?
level_done_trig
level_done_proc

done...now single and netgame level done are working good..

------------------------------------------------

what else to test??


----------------------

working on bomb explosion stuff.....

redrew the explosion sprites...

changed to have multiple times when the do bomb damage happens, as the explosion grows and moves


what are you trying to do for bomb?



make the blast area more dynamic, circular would be awesome!!

draw a better animation sequence with more shapes for explosion and make it more round



make the block removal work on every frame of explosion so it grows




made a function to show and remove blocks in the blast radius
for now everything else is commented out

fine tune the size and radius of the blast...ok i like it....

now what??

make the explosion shape match...


what if I do scale all by myself and not pass it with 10
yes, 10 is used by other items for different things...









----------------------------------------------------------------
re-did bottom msg to use al_map_rgb() instead of palette color indexes

thinking about how to do stretched text fast without changing target bitmaps

what if I make an array of bitmaps to hold each text line..
the only time I need to change target bitmap, will be when I enter a new one.
I'll do a simple copy of pointers to slide new bitmaps.
Then when I draw all the bitmaps, I can scale them then.

what is the max length in text of a bmsg?? at least 40 lest do 50

height = 8; width = 400; number = 20;

ALLEGRO_BITMAP bmsg_bmp[20];

this code is bad, it just copies pointers:
for (int c=19; c>0; c--)
  bmsg_bmp[c] = bmsg_bmp[c-1];

keep all the bitmaps in the original array and copy to temp array

done...

bottom message has been fixed and looks great
----------------------------------------------------------------








----------------------------------------------------------------
why are num_shapes for animation seq one less than actual??
----------------------------------------------------------------
i don't know... i don't want to change it in case it breaks other stuff, ill just work around it



I am quite happy with the block destruction

now enemies...happy with that...

now players...only do damage once....


its coming along very nicely...





do bomb damge is gone and have been replaced with:

bomb_blocks(c, 2);
bomb_enemies(c, 2);
bomb_players(c, 2);

these are called every frame when in explosion mode.
blocks and enemies destroy every frame, but players only when item[][8] == 1


these are all called in the draw code also:
            bomb_blocks(c, 1); // mark blocks that will be destroyed
            bomb_enemies(c, 1); // mark enemies that will be destroyed
            bomb_players(c, 1);

but with mode 1 that only marks...

cant make it common because...
- i don't want anything but drawing in the draw stuff
- i dont want any drawing in the non-drawing stuff

I'm about out of time for today, but the next things to do are:

make the markings flash based on mod passcount....

fix the fuse burning thing...
i'll probably go to another type of ans, like the original
and make a stopwatch with drawing primitives....


send ratio to 3 bomb_  functions as float int f
no, send range as int..done

well I now have all the bomb stuff looking good

make bomb range a circle in level editor..done

sticky bombs??

when a rocket turns into a bomb do I stop it?, i do now!!

mark player in bomb range with amount of health lost


make a new int in player struct about potential bomb damage

show with health display...i'm prety happy about how it looks now

bomb crosshairs draw when black..fixed


game_events...

remove all calls to 6 and 7 H- and H+
add to individula calls..

mines...done

11 you got shot...




----------------------------------------


i need to redo collisions...

make an easy way to test.....

player vs player bullets....

shoot a player bullet +80 x with no velocity...

make temp player move to move in x or y

ok thats good...

i'm getting lost in collision stuff


very high level stuff..
everything move then check collisions
how is it now

move_players() that call player collisions after move for each player
move enemies that call collision then move for each enemy

do i really need to do the stretch thing for bullet collisions??


first problem to solve, player bullets with players use 10's
then see how the collisons look...seems good...

now see how far away the initial bullet position is
it is zero'd with player

i do one move before leaving bullet creation, then the initial position is better

but by the time it draws its made a second move

move_player creates bullet
then collision
then bullet move
then bullet draw

so why doesn't just doing one initial move work
it does, but doesnt look good...

how am i going fix this

move the bullet moves to before player move in loop...
test...seems good....

suicide pblullets works good now...

bottom messages need to be re-written to use player name or number

use:
z1 for player number
z2 for item or enemy number
z3 ...
z4 for damage



void game_event(int ev, int x, int y, int z1, int z2, int z3, int z4)

case 10:
game_event(10, 0, 0, p, i, 0, item[i][8]);
sprintf(msg, "Player %d hit a mine! Health -%d", z1, z4); new_bmsg(msg); break;

case 11:
game_event(11, 0, 0, p, e_type, 0, damage);
sprintf(msg, "Player %d got shot by %s! Health -%d", z1, enemy_name[z2], z4); new_bmsg(msg); break;

case 12:
game_event(12, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
sprintf(msg, "Player %d hit by %s! Health -%d", z1, enemy_name[Ei[z2][0]], z4)


use Ei[e][26] to track what player killed the enemy..done

is there any way I can mark what player activated a bomb or rocket?
or better yet what player carried it last...

use 13....

set when lit in bomb or rocket..done

use when killing enemy

i think its good!!

now make it so that the last player that touched it gets the credit

fix sound events...done


after extensive changing, bottom messages are looking good.
still to do...

show when player damages another player with bomb

now I show when player takes explosion damage, just need to add from what player

add when player explodes themselves..done

removed screen messages to extra code file...







---------------------------------------------------------
player lags on fast rockets...fixed
---------------------------------------------------------
where is the code that binds them..

its in player move -> void proc_player_riding_rocket(int p)

then item move happens, then draw...

can I bind them in item move??

      // if player riding, bind player to rocket
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }








---------------------------------------------------------
sticky bombs..done
---------------------------------------------------------

what do I need to do to make this a thing?


re-use regular bomb, just modify move code...

for now do it on regular bomb, then later add new move type...

if not being carried, look to see if walls are close, if yes then set xinc, yinc to zero

make a funtion to do that

int is_item_stuck_to wall(int i)
{
   int x = al_fixtoi(itemf[i][0]);
   int y = al_fixtoi(itemf[i][1]);

   if ((is_left_solid(x,y, 0) || (is_right_solid(x,y, 0) ||
       (is_down_solid(x,y, 0) || (is_up_solid(x,y, 0) )

       return 1;

   return 0;
}


i'm ready to make a certain type of bomb

i plan to overload the already overloaded move_type of item

no just use 11 and make a new pde type

no add slider to existing and custom draw code tile 440..done

need to test how it works with lifts..seem to ignore them quite nicely except for regular ride...


---------------------------------------------------------
remote detonation of bombs
---------------------------------------------------------
this will differ from regular bombs in that the timer is replaced by a remote detonator.

whatever player triggers the bomb will always have the trigger.

should save the player num in the item, so a player can have many items triggered

can I reuse existing bomb?

what if I make another mode, mode 3

then when that is done move to mode 2 explosion like normal

can I use 12 for remote/timer?? yes...

make slider..done

when touch first time set mode 3 if 12...done

now add code in proc_lit_bomb()

use 13 to mark player that trigger it

that was easy!!

next make a different bitmap to show the remote detonator.

maybe draw a line to the player

as it is now, another player can steal the trigger by moving the bomb

i want to draw dynamite! 3 red sticks...
with a timer if appropriate, or a red button

537 - 539

looking good...

change color of remote line to gray..done

make editor set the correct initial shape..done

make bottom msg display correctly..done

test multiplayer..work exactly as i thought
players can steal bomb from other players by grabbing the bomb
then the remote belongs to them
it has no effect trying to grab the remote

test carrying remote through doors...good
can't drop it if you wanted to

test carrying bombs through doors...
works fine with remote..

what about a regular bomb?

what happens if it explodes while in door travel??
item is left behind in door travel until travel is complete
player is invincible in door travel


--------------------------------------------

rename and move stuff in editor...

to start with, move the three things that edit text to z_menu

// e_nlv.h
void edit_server_name(void);
int edit_lift_name(int lift, int step_ty, int bts);

// e_nev.h
void show_cursor(char *f, int cursor_pos, int xpos_c, int ypos, int cursor_color, int restore, int rot);
int edit_pmsg_text(int c, int new_msg);

removed global fst[80];

lift name good...
server name good...
pmsg good

fix pm.h..done


rename e_editor to e_editor_main

make e_editor_zfs
put all zfs and sel there...

move from main to zfs...done


these files are good and don't need anything:
bitmap
glt
pde (pde_editor)
special (could use a better name) (object_selection_and_status_windows?) (pde_sel_window)
combine pde...done
sliders
lev (could use a better name) visual level thingy

e_nlv change name to e_lift (has only lift stuff)

these are what really need arranging:

nev
item

fnx

make a new file e_object_viewer



--------------------------------------------
not that long ago I could carry items through moveable doors and it would show...
--------------------------------------------

I must have broke it in my rearrangment of player move..
added player carry at the end of paused mode door travel
now it works like it used to, but...
if drop during travel item goes back to door entry place..why??
because item was inheriting player's momentum in drop item...fixed
now what happens with bomb...

when dropping item in solid blocks...
player drop when checking for stuck, will move it left or right until not stuck
not for bomb, because wall stuck is not done for bomb...

what about rockets??
rocket never travel through doors.
if carry through door is set, rocket will do instant no matter what door is set to..

if not ride through door and fire is pressed, on exit player will snap to riding rocket again...
force drop on entry for this case...

on door entry, every item with carry through flag is dropped:
// check to see if player is carrying an item without the carry through door flag set
if (item[ci][3] != -2)  player_drop_item(p);

so why does rocket act different??

its not getting dropped on door entry
in the long list of item collisions, door is dropping, but then rocket as later item is picking up..
in item collision check for inactive player...done and fixed..



--------------------------------------------------
Rules for items, rockets, doors, bombs.
--------------------------------------------------

- when players are in door move they are invincible


- players can carry items through doors, if the items's carry_through_door flag is set

- if the flag is not set the item is dropped on door entry


- the only things a player can do when in door move is
- drop an item
- trigger a bomb

- if the item is dropped in solid blocks, it will move left or right until free.


- if a bomb is dropped in solid blocks it will stay where it was dropped

- a bomb can expode while in door travel, no player damage, player is paused, invincible


- rockets can be ridden through doors if the ride_through_door flag is set

- rockets will never do door move, they are forced to instant


- doors can be carried through other doors if the flag is set

- doors cannot be carried through themselves






---------------------------------------------------------
cant throw sticky bomb upwards when standing on ground, it gets stuck to ground...fixed
---------------------------------------------------------
// prevent sticky bombs from sticking to the ground when throwing upwards
if ((item[i][0] == 99) && (item[i][11]) && (players[p].up)) itemf[i][1] -= al_itofix(2);





---------------------------------------------------------
flapper uses passount mod for flap...
can i make them all custom based on flap speed?
---------------------------------------------------------

right now I have a counter in the enemy ints that goes from 0-22
and does something for each integer case..

I could convert it to a float and increment it a float ammount each time
then have all my cases based on percentages of the float...

I would need 2 floats (fixed), the counter and the inc
I will make the counter constant and the inc variable
called flap speed...
user will set 0.5 to 8
constant will be from 0-100

Efi[][9] flap speed counter
Efi[][10] flap speed inc


working good...

next thing...

with different flap speeds, the flap y inc is added a different amount of times

so the same flap yinc will have different effect with different flap speeds...

should be easy to make this constant

also maybe show in level editor how much flap yinc is...


the number of times flap is called is

50/flap inc


each time 3 * r * flap yinc..

so max swing = (50/item[i][9]) * 3 * item[i][8]

i want to change 8 to the max + or - amount that flap does...
mark it in editor, then make it happen in code


yflap is now a float from 0 to 4
i will change it to 0-400 and it could be an int...

Efi[][8] can still have a calculated value based on the rest...


target is flap height (Ei[][21])

adjust yflap (Efi[][8]) to make that happen...

equation:

Ei[][21] = (50/Ei[i][9]) * Ei[i][8]

Ei[i][8] = Ei[][21] / (50/Ei[i][9])


----------------

its looking good, but the 2 halves are not symetrical...
they drift...
seek was evening it out, but with seek disabled, drift is totally visible

to fix this i need to make both halves the same

they both need to start at 0
right now the second one starts at f-50

how about if i detect when > 50 and set to 50 exacltly

that seems to do it...


360 base

max 453
min 209

360 - 453 = -93
360 - 209 = 151


is it beacuse I start at 0 which is in the middle of a move
when I should start at 25 or 75 which is a zero point...

what if I rearrange my two halves:

0 to -1 and back to 0

0 to +1 and back to 0

also try a trig function


i am always adding the ammount, but they add up
i need to remove the last add then add a new one...


remove 3

put only flap in 3, then apply




applying the huge amount every time...
if it collides then the huge ammount is taken back..
this is not good...

calculate the difference between last and current...
apply and check for only that...

every time f = 0 save y pos in Ei[][14] for drawing only



can i use trakbot collisons for flapper? yes...

i think flappers are done...

they can still look bad at extreme values, like flap speed < 1 or > 5



-----------------------------------------------------------
make multiple player starts...
-----------------------------------------------------------

could be invisible if only one player...

how will i implement this...


marks starts with number..

0 is primary and all levels must have one

1 and higher are secondary...

if netgame show all
if single player only show 0

when players start if player is > 0 look for second start


how to map...


if st = 1 all players get 0

if st = 2
p0 0
p1 1
p2 0
p3 1


if st = 3
p0 0
p1 1
p2 2
p3 0
p4 1
p5 2
p6 0
p7 1


if st = 4
p0 0
p1 1
p2 2
p3 3
p4 0
p5 1
p6 2
p7 3

1st - count number of starts
2nd - player_num % ns = start


test this
   int p[8] = {0};
   for (int ns=1; ns<9; ns++)
   {
      printf("ns = %d\n", ns);
      for (int q=0; q<8; q++) p[q] = q % ns;
      for (int q=0; q<8; q++) printf("p:%d s:%d\n", q, p[q]);
   }
works

now make code in editor work...
item[][7] start index

now make code in game work...

void set_player_start_pos(int p)

it seems to work...

now how to make it safer..
in editor, enforce that:
- starts must not have duplicate indexes
- starts must have consectutive numbers

- at least one start must exist
- no more than 8 starts exist

in create start, make the new start one plus the old one

when changing start number...

how about on save flag if error and let user fix manually...



for the most part I want start blocks to not even be noticed and have the old behaviour
they are only used rarely when multiple starts are desired


one idea would be to have 2 creators, one for the main start and one for secondary starts
secondary starts would have a different shape

when running the main one it will:
-erase any other index 0
-make a new index 0
-ignore any secondary

when running the secondary one
-find the next position
-enter there



for now mark them with a number...

when level is loaded, save number of starts as global...
when drawing starts only mark with number if more than 1...

do this in level check which is called when level is saved...
or loaded...done...

this will be good enough for now..

- when using the start creator all other starts are erased (no change)
- to make secondary start copy, paste, and change index
- start checks are in place on level save and load
- index numbers are shown when start is drawn only if more than one start
- in sort_item() (editor only) number of starts is updated
- secondary starts only affect when other players join




--------------------------------------------------------------
remote lasts through death, and can trigger remote while death paused..fixed
--------------------------------------------------------------
to fix this make player lose any remotes when dead
bomb will go back to having remote...
OR....bomb could explode!!!
where does player die??
in proc player paused == 1


--------------------------------------------------------------
make block walker and archwag share common code...done
--------------------------------------------------------------
--------------------------------------------------------------
same as bouncer and cannon..done
--------------------------------------------------------------




--------------------------------------------------------------
clean up enemy drawing modes...block walker...done
--------------------------------------------------------------
all have only 2...

where is Ei[e][4] used?

anywhere in draw code??
no..

trakbot uses it for fall count...

removed from archwag and walker...
cleaned up comments related to Ei[][4]...


---------------------------------------------------------
I've somehow inroduced a bug
cloner creator is all screwy
makes a block walker??
podzilla creator makes a cloner??
those are the only 2 things made with creators...
fixed bug in int get_empty_enemy(int type)
done
---------------------------------------------------------




---------------------------------------------------------
cloners to have nicer drawing stuff, like a better shape, boxes around areas, etc
---------------------------------------------------------

what if I draw lines on level background, like lift_lines?

made a new ans 104 for cloner...


split between draw code and move code
I can draw the tiny old status bar in draw

i can set a shape in move...working on getting it looking good...


move the drawing code to draw from lift lines..

make it flash when cloning...

it seems to take too long when cloning instantly

32 frames is almost 1 second

changed to 8 and it looks better

there are times when you dont want the trigger box shown...
like when it is very huge

make a flag to turn it off in cloner...
all three or just trigger...

or trigger and source dest boxes...

done, used Ei[][4] for both...

now make clone happen on earlier count

cloner is coming along nicely

death ans..done

shape in level editor

make creator set
231 - 550

do glt to fix all cloners...
new shape 550 in 1
new draw type 0 in 2
done

-------------------------------------------------------------------
after changing flapper stuff all existing flappers do not work...
-------------------------------------------------------------------

flap speed and flap height

better defaults are:
x 2.7
xa .2

y 2
fs 3
fh 30
hap 60


Ei[][20] height above player
Ei[][21] flap height

Efi[][5] max x speed
Efi[][6] x accel
Efi[][10] flap speed inc


player lit a rocket bottom message on level wiuth no rockets, only flappers, sproingies..fixed

editor pop menu does not scroll up, goes off bottom of level...fixed




---------------------------------------------------------
i miss the first few frame becuae of stimp...
reset frame_nums at end of stimp...fixed
---------------------------------------------------------


---------------------------------------------------------
sometimes when riding rockets, you let go of one and grab another
but you snap to the last one and are drawn there, but you control the new one???
---------------------------------------------------------
problem was in proc_lit_item

      // if any players are riding this rocket, bind then to rocket's position
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (players[p].carry_item) && (players[p].carry_item == i+1 ))
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }

//      // if player riding, bind player to rocket
//      for (int p=0; p<NUM_PLAYERS; p++)
//         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
//         {
//            players[p].PX = itemf[i][0];
//            players[p].PY = itemf[i][1];
//         }



---------------------------------------------------------
when pressed up against a breakable block you shoot through it...fixed
---------------------------------------------------------
only facing right...
added this line to buillet code..
if (players[p].left_right) pbullet[b][4]--;



---------------------------------------------------------
flapper twitches when seek yinc is more than flap yinc??
---------------------------------------------------------

they fight each other...

should i seperate them??



right now I use Ei[14] for base for drawing only


pick a fixed and use it for base y

base_y will only be affected my seek yinc

Efi[e][11] will have base_y

need to set to same as [1] in level editor for initial...
or I could set it to a negative value, to signal emove stuff to set it to 1
for now if zero set to 1


i'm getting lost...
if i cant describe it in words how can i hope to fix it?

y position of flapper...
stored in Efi[][1]

affected by seek yinc and flap

flap needs to have memory of last flap, so it can convert to yinc


i think the two can be added and then checked and applied

but what about when flap goes up and seek goes down??
funny oscillations, that's what....


------------
tried...

make a variable for base_y set only by seek and that got weird...

---------------
could I avoid this by choosing only good values for seek_yinc and flap_height??



what looks bad:

-----------------------
seek_yinc = 2
flap_speed = .5
flap height = 100
when passing through height above player position,
there is a quite noticeable stutter as seek flips from -2 to 2
max flap_yinc = 3.5

----------------------
seek_yinc = 2
flap_speed = 1.0
flap height = 100
when passing through height above player position,
stutter is not as noticeable
beacause flap yinc is bigger in relation to seek_yinc
max flap_yinc = 7


I can avoid this by making sure max_flap is at least 4 times higher than seek

how about if I scale seek based on how far away it it..

more than 100 = full
< 100
get a ratio (100 - df)

implemented this and the above problem is fixed....






block #18 = ladder

make a function to detect if player in touching ladder block...done

add variable to player struct on_ladder...
added to main player struct..took place of old bitmap_index


can get off of ladder by moving away from detection area
except if moving up at top of ladder then I want player to just stop there...


player should be able to shoot if on ladder..done

player should be able to jump off ladder..done

player needs wall collision detection while on ladder..done
player can now navigate single block openings well while on ladder


add to move code if player moves up past top of ladder to just stop moving up
so that player does not fall off ladder...done


jump sets on_ladder to 0
jump only if up is not pressed


when players grabs ladder, need to make sure player is not embedded in wall
or else up and down will not work..
only when grabbing ladder when moving left or right...done



player should have different shape seq when on ladder


I think ladder is done except for new animation seq for ladder move



now what about rope?
block #19 = rope

snap to 0 position when on rope
can only move left and right
can't jump
can't shoot??
can carry
only way to leave rope is down or move off ends of rope left or right



ropes and ladders seem to be working fine, but now I will need
to spend some time doing nice animation sequences


what happens when player is shot?  do they fall off rope or ladder?

what does recoil do to them??
adds to xinc and yinc, then that takes effect when player leaves rope or ladder


how about don't do any recoil when on ladder or rope...




new player shapes.....

1 for jumping

2 for rope
2 for ladder

what process do I have to go through to add them?


brought back from the dead
void fill_player_tile(void)

call it from load tiles instead of other code...

make sure it works...yes it does

it needs these tiles from main tile set:

368-373 (look up)
400-405 (regular)
432-437 (look down)
755 (bullet)

made some changes to main tile set
now players down shapes are 432-437

i want to add 5 more shapes for each player color

438 jump
528-529 rope
560-561 ladder

increase array...

it was already
ALLEGRO_BITMAP *player_tile[16][32] = {NULL};

increase ptilemaps

old was 380x320
new 480 x 320


am i really done with ladder and ropes??


what about jumping on top of ladder?


normally I can jump any time while on ladder
I will not be on ladder after jump
but then I can grab it again with up

i disabled jump while up is pressed to prevent faster ladder climb



fixed this with a few techniques:

- changed order to process jump first and dont do any up if jump pressed

that still speeded up jump held while climbing
because for one frame when not on ladder yinc moved player 6.6
then next frame grabbed ladder again and moved at 3...

so i keep the saem yinc but offest y pos by 2.6...

   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
   }fix all refs to draw item of trakbot...
old 192
new 384

   else
   {
      if (players[p].up)   players[p].PY -=   is_up_solidfm(players[p].PX, players[p].PY, m, 0);
   }


this looks good and works....


---------------------------------------------
fix all refs to draw item of trakbot...done
---------------------------------------------
old 192
new 384


---------------------------------------------
player should be able to throw items down as well as up...done
---------------------------------------------
i did that but terminal velocity of items is only 3 and .1 for gravity
compare to player with terminal velocity of 7.8 and gravity of .6 or .2 for slow


---------------------------------------------
legend boxes flashing are still not seen sometimes...done
---------------------------------------------
use slash marking??
done for cloner, podzilla and key block range




---------------------------------------------
bug in item var 3 move type...done:
---------------------------------------------

   if (bn == 26)
   {
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");
   }


   if (bn == 2)
   {
      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] == -1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");
   }


all items use 2 or 26

non carryable (use type 2)
key
free man

carryable


rocket needs custom button 93

      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] ==  1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");



      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");



rocket are created with -1 carry??? is this needed??
no, set to 1 by default.. when lit if 0 or 1 they get changed to -1 carry
unless -2 then they stay -2...

need to glt and set all -1 to 1...done




go through all levels

see if cloners need boxes.. up to 100
fix flappers..up to 100


make a level with a huge cannon, like a boss level....done 330

make a level to test if you can chain throwing sproingies..done 331
hell you can do it with a single sproingy
just let go before the top of the jump while holding down so it doesnt get thrown up by inheriting players yinc
then fall on it again while holding fire and jump

reset vls end level before release..not sure what this is...
visual_level_select...to make the extra levels not shown...


20220305

I am back after a few years absense....

Figured out the new dev environment, for windows anyway, linux later


I will put some useful info in the HOWTO dir...I guess I can out everything except the github password with the project...


make level editor use display_transform_double = 2; in 4K done..looks better


make demo mode take 30s instead of 10
don't do demo mode if paused in a level
done



why does cloner show both shapes...fixed

smooth cloner animation sequence 7 steps
did a lot of cleaning up an refactoring cloner trigger stuff and mode stuff,
removed the mode controlling the red green flashes when cloning
now mode is only for telling if in trigger box last frame

what happened to:
sticky bombs?
remote bombs?
the new way of showing circular bomb damage?


they are not there in the official 7.05 release

but they are in the one from sources....

ladders, ropes?

I would like to add for rockets, a line to show where they will go and what blocks they will destroy..done
make the rocket line thing more accurate by moving exactly like real rocket does..done


lets start making some cool levels...
start at level 300


document the dev setup again, especially libnet
done and put in project files

figure out how to do github and add to docs in project...done
password and token saved in truecrypt vault like all my other passwords

document how to edit tileset with gimp and add to docs...done

made 2 new shapes for cloner and made new ans 107 with 9 shapes
added to code and it looks good



where is that randomizing thing I used for groups of enemies?
is it part of glt?? no it is in zoom full screen
press r and selection will be randomized
added to docs



what does start index do?

if multiple starts with multiple start indexes and multiple player start

they get different starts



what if I made an option that cloners could be invincible?
and then I would not have to protect them with layers of blocks
looking for an open variable...cloner is really busy
how about Ei[][30] deathloop count...i mean he should never die right??

ok lets do it

cloners now have the option to be invincible!!


document how to view netgame stats in game...done

make rocket guideline not blink like explosion...
if rocket is going slow enough the guide lines do not show...fixed




how about showing when a object is about to expire
a very small number that shows how many seconds left
if (item[i][14]) al_draw_textf(f3, mC.pc[15], x+10, y-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (item[i][14] - 10) / 40);

done...it was one line

now do the same for enemies ..done

if (Ei[e][27]) al_draw_textf(f3, mC.pc[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);












the linux version has screen problems too
when going into fullscreen mode, it is the same size as the window before


where is this in code??

-------------------------------------------------------------
z_control.cpp -- function:function_key_check() -- line 500
-------------------------------------------------------------
if (fullscreen) proc_screen_change(  disp_w_wind,    disp_h_wind, disp_x_wind, disp_y_wind, 0);
else            proc_screen_change(desktop_width, desktop_height,           0,           0, 1);


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 980
-------------------------------------------------------------
if (!fullscreen) // detect if window was moved
{
   int x, y;
   al_get_window_position(display, &x, &y);
   if ((x != disp_x_curr) || (y != disp_y_curr))
   proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
}


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 999
-------------------------------------------------------------
if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
{
   // check to see if we have more resize events piling up
   ALLEGRO_EVENT ev2;
   while (al_get_next_event(event_queue, &ev2))
   {
      if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
      else ret = proc_events(ev2, ret);
   }
   proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
}

-------------------------------------------------------------
z_screen.cpp -- function:proc_screen_change() -- lien 300 999
-------------------------------------------------------------

void proc_screen_change(int new_sw, int new_sh, int new_sx, int new_sy, int new_fs)




This is on windows and works just fine

changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn


This is linux:

Display change
x:1688 y: 842 w: 693 h: 450 fs:0  old
x:1689 y: 868 w: 693 h: 450 fs:0  new   <-------[why does it do this change? +1x +26y]



Display change
x:1689 y: 868 w: 693 h: 450 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1689 y: 868 w: 693 h: 450 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn      <--------- all good to here

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:   0 y:   0 w:3840 h:2160 fs:1  new   <-------[why does it do this change? no change]

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1689 y: 868 w: 693 h: 450 fs:0  new
changing away from fullscreen
x:1689 y: 868 w: 693 h: 450 disp_
x:1689 y: 868 w: 693 h: 450 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1689 y: 868 w:3840 h:2160 - curr         <---------right here wtf changed it
x:1689 y: 868 w: 693 h: 450 - wind
x:1690 y: 894 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:1689 y: 868 w:3840 h:2160 fs:0  old  <-------[why does it do this change? +1x +26y]
x:1690 y: 894 w:3840 h:2160 fs:0  new




win

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1094 y: 184 w:1644 h:1482 - disp
0:   0 0:   0 w: 822 h: 741 - scrn


lin

--------detected move or resize
x:1093 y: 158 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - disp

Display change
x:1093 y: 158 w:1644 h:1482 fs:0  old
x:1094 y: 184 w:1644 h:1482 fs:0  new <-------[why does it do this change? +1x +26y]

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:  37 y:  26 w:3840 h:2160 - curr  <-------[why does it do this change? +37x +26y]
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:  37 y:  26 w:3840 h:2160 fs:1  new


--------detected move or resize <------------x 60
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1095 y: 210 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:1094 y: 184 w:3840 h:2160 - curr
x:1095 y: 210 w:3840 h:2160 - disp

Display change
x:1094 y: 184 w:3840 h:2160 fs:0  old
x:1095 y: 210 w:3840 h:2160 fs:0  new
^[


i dont get it....is lin moving my window???

can I just force it to be what I want??
keep my own variables for screen x, y, w h??

never overwrite them by reading them...
just compare them to actual..

what do I have now?

extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // either wind in windowed mode or full fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

im going to add:

extern int disp_x_full; // fullscreen (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;




what if I change my code so that all the screen change stuff just changes variables
then once per cycle, if the variables don't match the actual, then process the changes


I have a conflict...

I changed

I have a function that checks if the window has moved by comparing actual to what is stored in curr
if it is different the function assumes that the user moved the window and updates curr

I also have a function that check if the size and position are different from what is in curr and assumes the system fucked it up
and restores it

these are at odds with each other...


what are the things that can change display?
F12
resize event
move detection...





I was having strange issues with fullscreen to windowed and then I discovered it matter the order of:

   al_resize_display(display, disp_w_curr, disp_h_curr);
   al_set_display_flag(display, ALLEGRO_FULLSCREEN_WINDOW, fullscreen);
   al_set_window_position(display, disp_x_curr, disp_y_curr); // make sure to set position last!!!



now in lin I get this weird ness





Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

resize final
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 843 y: 236 w:3840 h:2160
wind - x: 843 y: 236 w:3840 h:2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

We got a window resize event while in fullscreen...this is unexpected
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x: 843 y: 236 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

move
disp - x: 843 y: 236 w:3840 h:2160









omfg I think it is almost 100% working.....in linux too

same as win....


how about the only time I care about window position is when entering full screen mode or exiting the program
other than that I don't care about constantly monitoring it
seems to work good


resize event in linux seem to alway return x=1 y=26...why????

ignore x and y....not as nice in windows...

maybe the problem is the number of resize events I am getting...show them...

maybe the problem I have is that I should not be setting the display x, y, w, h

just read them....


the only time I want to set them is coming back from fullscreen to windowed...

that was is...it was all so simple...i spent days trying to figure that out....


clean up...

old code from control to stop pile up of events....not needed



if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) show_event(ev);
void show_event(ALLEGRO_EVENT e)
{
   int x = e.display.x;
   int y = e.display.y;
   int w = e.display.width;
   int h = e.display.height;

   printf("\nEV-raw-resize event---  x:%d y:%d w:%d h:%d\n", x, y, w, h);
}


            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_display_change();
            }
            else ret = proc_events(ev, ret);


new code
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) proc_display_change();


20220311
I can now truly say that is done and cleaned up and works great
it is a lot simpler code too.....

checked in

now I want to figure out what is causing the freeze on exit.....

in linux version exiting the game freezes the terminal
CTRL-ALT-END if game has focus or CTRL-C in terminal it spawns

look like I am not shutting down things individually...
I am just calling al_uninstall_system();

put some logging code around it, then try adding all individual ones...


al_destroy_display(*display);

in what order are they created?

first

al_init();

al_create_event_queue();


display = al_create_display(disp_w_wind, disp_h_wind);//

al_register_event_source(event_queue, al_get_display_event_source(display));

al_init_native_dialog_addon())


al_init_primitives_addon())
al_init_font_addon())
al_init_ttf_addon())
al_install_keyboard())
al_register_event_source(event_queue, al_get_keyboard_event_source());
al_install_mouse())
al_register_event_source(event_queue, al_get_mouse_event_source());
al_install_joystick())
al_register_event_source(event_queue, al_get_joystick_event_source());
al_init_image_addon())
   fps_timer = al_create_timer(1/(float)frame_speed);
   sec_timer = al_create_timer(1);
   mnu_timer = al_create_timer(.01);

   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mnu_timer));

   // start timers
   al_start_timer(fps_timer);
   al_start_timer(sec_timer);
   al_start_timer(mnu_timer);

   load_sound();

how can I get a debugger working?

installed gdb

re-compiled  allegro with debug
compiled with debug info
linked with -g

ran gdb ./pm

then run

when it crashed CTRL-C then:



^[[A^[[A
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409
(gdb) where
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409





in events.c

void al_destroy_event_queue(ALLEGRO_EVENT_QUEUE *queue)
{
   printf("deq 1\n");
   ASSERT(queue);
   printf("deq 2\n");
   _al_unregister_destructor(_al_dtor_list, queue->dtor_item);
   /* Unregister any event sources registered with this queue.  */
   while (_al_vector_is_nonempty(&queue->sources)) {
      ALLEGRO_EVENT_SOURCE **slot = _al_vector_ref_back(&queue->sources);
      al_unregister_event_source(queue, *slot);
   }
   printf("deq 3\n");
   ASSERT(_al_vector_is_empty(&queue->sources));
   _al_vector_free(&queue->sources);
   printf("deq 4\n");
   ASSERT(queue->events_head == queue->events_tail);
   _al_vector_free(&queue->events);
   printf("deq 5\n");
   _al_cond_destroy(&queue->cond);
   printf("deq 6\n");
   _al_mutex_destroy(&queue->mutex);
   printf("deq 7\n");
   al_free(queue);
   printf("deq 8\n");
}


Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160
al_uninstall_audio()
al_destroy_font()
al_shutdown_ttf_addon()
al_shutdown_font_addon()
al_shutdown_image_addon()
al_shutdown_native_dialog_addon()
al_shutdown_primitives_addon()
al_unregister_event_source(event_queue, al_get_keyboard_event_source())
al_uninstall_keyboard()
al_unregister_event_source(event_queue, al_get_mouse_event_source())
al_uninstall_mouse()
al_unregister_event_source(event_queue, al_get_joystick_event_source())
al_uninstall_joystick()
al_unregister_event_source(event_queue, al_get_timer_event_source(mnu_timer));
al_unregister_event_source(event_queue, al_get_display_event_source(display))
al_destroy_display()
al_destroy_event_queue(event_queue)
deq 1
deq 2
deq 3
deq 4
deq 5
deq 6
deq 7
deq 8

Before al_uninstall_system()
deq 1
deq 2
deq 3
deq 4
deq 5


now find:

_al_cond_destroy(&queue->cond);

I got lost here...


level where you fall all the time...the bottom of the screen is just doors that teleport you to the top
then some semi-solid vertical screens that cannons shoot at you through
and a rare rocket that you can ride through them....done

when player is riding a rocket they can pass through semi solid left and right....not so much a bug as a feature......!


------------------------------------------
new bug
------------------------------------------
when player is in key block range being removed weird things happen
it only happens when the key is in the middle of the block range
and the distance from key to center of block range = 0

But it always gets fixes when player leaves block range??

i think what matters is that the player is still touching the key, not in block range...test this
i think it is...also blocks don't get destroyed
the problem was that even though the key was moving, the player was still triggering a collision with it
fixed

show OS type on startup

save window x, y when exiting (only saves when resized or switching fullscreen)...done



I think I have all the debugging enabled:

Allegro:
-DCMAKE_BUILD_TYPE = {Debug | Release | RelWithDebInfo}
I used Debug

remade the library...
make
sudo make install

In the game:
compiler options: -Wall -g
link with -lallegro_monolith_debug

I ran gdb again and bt and where did not show anything new

I ran 'info threads' and 'thread apply all bt'

I got a lot more output, but nothing I can make sense of:


$ gdb ./pm
GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./pm...
(gdb) run
Starting program: /home/m/Desktop/pm_client22/pm
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff4ca7700 (LWP 728683)]

Purple Martians Version 7.10
Allegro Version: 5.2.8.0
[Detaching after vfork from child process 728684]
System ID: Xglx
Desktop Resolution: 3840x2160
[New Thread 0x7fffebe03700 (LWP 728688)]
[New Thread 0x7fffe3fff700 (LWP 728689)]
[New Thread 0x7fffeb602700 (LWP 728690)]
[New Thread 0x7fffeae01700 (LWP 728691)]
[New Thread 0x7fffe9d42700 (LWP 728692)]
[New Thread 0x7fffe9541700 (LWP 728693)]
[New Thread 0x7fffe8b96700 (LWP 728694)]
[New Thread 0x7fffe37fe700 (LWP 728695)]
[New Thread 0x7fffe2f67700 (LWP 728696)]
[New Thread 0x7fffe2766700 (LWP 728697)]
[New Thread 0x7fffe1f65700 (LWP 728698)]
[New Thread 0x7fffe1764700 (LWP 728699)]
deq 1
deq 2
deq 3
deq 4
deq 5
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) where
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep ()
   from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep () from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) thread apply all bt

Thread 14 (Thread 0x7fffe1764700 (LWP 728699) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x7fffa4000be0, mutex=0x7fffa4000bb0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e22c4f in al_wait_for_event (queue=0x7fffa4000b60, ret_event=0x7fffe1763820) at /home/m/Desktop/allegro5/src/events.c:435
#3  0x00007ffff7f396b0 in _al_kcm_feed_stream (self=0x555563568700, vstream=0x5555639d0900) at /home/m/Desktop/allegro5/addons/audio/kcm_stream.c:697
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x555563568700, _outer=0x555563568700) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x555563568700) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 13 (Thread 0x7fffe1f65700 (LWP 728698) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff744eda8 in pa_threaded_mainloop_wait () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7470a78 in pa_simple_write () at /lib/x86_64-linux-gnu/libpulse-simple.so.0
#3  0x00007ffff7f3d5c9 in pulseaudio_update (self=0x55556387d1d0, data=0x55556388dfd0) at /home/m/Desktop/allegro5/addons/audio/pulseaudio.c:212
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x55556387d1d0, _outer=0x55556387d1d0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x55556387d1d0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 12 (Thread 0x7fffe2766700 (LWP 728697) "threaded-ml"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff744e632 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7440079 in pa_mainloop_poll () at /lib/x86_64-linux-gnu/libpulse.so.0
#3  0x00007ffff74406ff in pa_mainloop_iterate () at /lib/x86_64-linux-gnu/libpulse.so.0
#4  0x00007ffff74407b0 in pa_mainloop_run () at /lib/x86_64-linux-gnu/libpulse.so.0
#5  0x00007ffff744e709 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#6  0x00007ffff625be08 in  () at /usr/lib/x86_64-linux-gnu/pulseaudio/libpulsecommon-14.2.so
#7  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#8  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 11 (Thread 0x7fffe2f67700 (LWP 728696) "pm"):
#0  0x00007ffff7b22c61 in clock_nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7b28443 in nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#2  0x00007ffff7ed3e79 in _al_unix_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/unix/utime.c:68
#3  0x00007ffff7e33803 in al_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/system.c:520
#4  0x00007ffff7e34c37 in timer_thread_proc (self=0x5555635fbea0, unused=0x0) at /home/m/Desktop/allegro5/src/timernu.c:94
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635fbea0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 10 (Thread 0x7fffe37fe700 (LWP 728695) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed2d8f in fd_watch_thread_func (self=0x7ffff7fa9d80 <fd_watch_thread>, unused=0x0) at /home/m/Desktop/allegro5/src/unix/ufdwatch.c:89
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x7ffff7fa9d80 <fd_watch_thread>) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 9 (Thread 0x7fffe8b96700 (LWP 728694) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e3492e in al_wait_cond (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/src/threads.c:380
#3  0x00007ffff7ee8c8d in hotplug_proc (thread=0x5555635709e0, data=0x0) at /home/m/Desktop/allegro5/src/linux/ljoynu.c:658
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x5555635709e0, _outer=0x5555635709e0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635709e0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 8 (Thread 0x7fffe9541700 (LWP 728693) "gdbus"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee40b in g_main_loop_run () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff5cdfa36 in  () at /lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 7 (Thread 0x7fffe9d42700 (LWP 728692) "gmain"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee1cf in g_main_context_iteration () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff65ee221 in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 6 (Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
--Type <RET> for more, q to quit, c to continue without paging--c
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 5 (Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 4 (Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 3 (Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 2 (Thread 0x7ffff4ca7700 (LWP 728683) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed9b9a in _al_xwin_background_thread (self=0x5555632e13f8, arg=0x5555632e1390) at /home/m/Desktop/allegro5/src/x/xevents.c:243
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555632e13f8) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 1 (Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"):
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60) at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0) at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8) at /home/m/Desktop/pm_client22/src/z_main.cpp:1421




what about files: there are 4 things: pm:disk$0 to 3
do I leave any file pointers open?
config uses allegro built in functions to access...they all look good

log?
        filepntr = fopen(filename,"w");
         fprintf(filepntr, "%s", log_msg);
         fclose(filepntr);
         printf("%s saved \n", filename);

others, help, pde, sprit...all look good



there is also pulseaudio and kcm_stream...what the hell are those???


I rebuilt allegro from git source and redid the make file
only chose Debug and Want Monolith

same crap...


what about a simpler program...like display test....


exits fine....

do I keep adding things and see if I can make it die?
or should I work with pm and remove things??

removed sound and it works!!

why do I not have sound stuff in my cleanup...i do..there is nothing for acodec addon..

most likely I am not destroying the xm stream....

         pm_theme_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
         if (pm_theme_stream == NULL) m_err("Error loading snd/pm.xm\n");

         al_set_audio_stream_playmode(pm_theme_stream, ALLEGRO_PLAYMODE_LOOP);
         al_set_audio_stream_playing(pm_theme_stream, 0);
         al_attach_audio_stream_to_mixer(pm_theme_stream, st_mixer);

         void al_destroy_audio_stream(ALLEGRO_AUDIO_STREAM *stream)

that was the solution...one simple line added to final wrapup
done 20220311



---------------------------------------
bug
------------------------------------------

When you pause and resume a single player game
sometimes it quits to the menu after a while....yes, i can reproduce it
play level for 5 sec the quit to menu, the resume
timer has reset to zero, player has left the game message appears right away
then 5 seconds in the game quits back to menu

where?


zcontrol at the end...

     for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active) // cycle all active players
            {
               if (players[p].control_method == 0) // local single player control
               {
                  if (level_done_trig) add_game_move(mwPS.frame_num, 6, 0, 0); // insert level done into game move
                  set_comp_move_from_player_key_check(p); // but don't set controls !!!
                  if (players1[p].comp_move != players1[p].old_comp_move)
                  {
                     players1[p].old_comp_move = players1[p].comp_move;
                     add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
                  }
               }
               if (players[p].control_method == 1) rungame_key_check(p, ret); // run game from file
               if (players[p].control_method == 3) server_local_control(p);
               if (players[p].control_method == 4) client_local_control(p);
               set_controls_from_game_move(p); // common for all players
            }   // end of active player iterate
         proc_game_move();  // run once per frame to process system messages from game_move







in saved game...

passcount is reset and player inactive is entered

figured it out...done

the code is rather complex....


---------------------------------------
fixed the code so it compiles without any dumb string errors
---------------------------------------

-----------------------------
bug --  warning in linux about
-------------------------------
||=== Build: ldm in pm (compiler: GNU GCC Compiler) ===|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp||In function ‘void new_bmsg(const char*, int, int, int)’:|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp|519|warning: ‘sprintf’ argument 3 overlaps destination object ‘b_msg’ [-Wrestrict]|
/home/m/Desktop/pm_client22/src/pm.h|173|note: destination object referenced by ‘restrict’-qualified argument 1 was declared here|
||=== Build finished: 0 error(s), 1 warning(s) (0 minute(s), 0 second(s)) ===|


      // slide_bmsg
      for (int c=39; c>0; c--)
         sprintf(b_msg[c], "%s", b_msg[c-1]);


first of all, why don't I see bmsg? 2 different types probaly took out to make faster
this is the fix...
      // slide_bmsg
      for (int c=39; c>0; c--)
         strcpy(b_msg[c], b_msg[c-1]);

done


-------------------
bug something screwy when exiting game in fullscreen mode on linux
when you come back, you come back with fullscreen, but windowed size???
-------------------------------

cleaned up init_display
forced w and h for fullscreen
did ack_resize after
seems to be fixed now...


I have a bit of a tricky math problem and I was wondering if anyone could provide insight.

Its about trigonometry and systems of equations.

This is all in 2D.

It is trivial to have an enemy shoot a bullet at the player. Simple trig.

But I want to have an enemy shoot a bullet, not at where the player is, but where they will be.
(assuming the player does not change velocity or direction)


My inputs are:
the player's position: px, py
the player's movement: pxinc, pyinc

the origin of the bullet: bx, by
the speed of the bullet: bspeed

What I want for an output is the angle of the bullet to ensure a collision
(or bxinc, byinc which I could calculate from angle)

Every method I can think of involves brute force, iterating through angles until I find a solution

There must be an more elegant solution.

I am trying to think of it as where two lines intersect...
But each line has a different velocity, so the line length are related to time...and speed?

Can any of you smart people help point me in the right direction?



You need to find out at what time(t) will they collide.

Basic position function: S(t) = S(0) + v(t) * t + 1/2 * a(t) * t^2

S(0) = starting position
v(t) = velocity at time t (constant in your case)
a(t) = acceleration at time t (zero if velocity is constant)
t = time

S(t) = S(0) + v(t)t

Can be broken into x,y components:
Sx(t) = Sx(0) + v(t)t
Sy(t) = Sy(0) + v(t)t

What are the player's and bullet's positions?

Player:
Px(t) = px + pxinc * t
Py(t) = py + pyinc * t

Bullet:
Bx(t) = bx + bxinc * t
By(t) = by + byinc * t

this creates a triangle
613141

You can either use x or y

Px(t) = Bx(t) or Py(t) = By(t)

px + pxinc*t = bx + bxinc*t
px - bx = pxinc*t + bxinc*t
px - bx = t(pxinc - bxinc)
t = (px - bx)/(pxinc - bxinc)

You can use original formula to then solve for x and y of final position:
x(t) = px + pxinc*t = bx + bxinc*t
y(t) = py + pyinc*t = by + byinc*t

float findPosition(float &x, float &y,
                  float px, float py, float pxinc, float pyinc,
                  float bx, float by, float bxinc, float byinc)
{
    float t = (px - bx)/(pxinc - bxinc);


    x = px + pxinc * t;
    y = py + pyinc * t;

    return t;
}

It's a mess. Hopefully I didn't miss anything.

Thank you for that. I am working on implementing it.
Time was the key. At what time will they collide?

UPDATE

Unfortunately I was unable to make your method work.

All I have for b is initial position and speed.
I do not have bxinc or byinc or the angle.
That is what I am trying to find.

The way I figured out how to do it was:

iterate on frame (time period) in a loop

for each frame find
- where we guess the player will be
- the distance from that position to the bullet origin
- find out how far the bullet could travel in the same amount of time

When those distances are equal (or close) that is where the will collide.
From the frame number that occurred at, I get the players position
That is where I shoot the bullet.
#SelectExpand
  1void fire_enemy_bulletb(int EN, int bullet_ans, int p)
  2{
  3   al_fixed bx = Efi[EN][0];
  4   al_fixed by = Efi[EN][1];
  5   al_fixed bspeed = Efi[EN][7];
  6
  7   al_fixed px = players[p].PX;
  8   al_fixed py = players[p].PY;
  9   al_fixed pxi = players[p].xinc;
 10   al_fixed pyi = players[p].yinc;
 11
 12   for (int i=1; i<100; i++)
 13   {
 14      px+=pxi;
 15      py+=pyi;
 16
 17      // calc distance from player's new pos to bullet origin
 18      al_fixed xlen = px - bx;  // get the x distance between enemy and player
 19      al_fixed ylen = py - by;  // get the y distance between enemy and player
 20      al_fixed hy_dist = al_fixhypot(xlen, ylen);   // hypotenuse distance
 21
 22      // get distance that bullet would travel in same amount of time
 23      al_fixed bd = bspeed * i;
 24
 25      // if they are close enough pull the trigger
 26      al_fixed bdif = hy_dist-bd;
 27
 28      al_fixed ltol = al_ftofix(-5);
 29      al_fixed utol = al_ftofix(5);
 30
 31      if ((bdif < utol) && (bdif > ltol))
 32      {
 33         i = 100; // break out of loop
 34
 35         al_fixed speed = Efi[EN][7];                     // speed
 36         al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
 37
 38         al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
 39         al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc
 40
 41         for (int z=0; z<50; z++)  // find empty e_bullet
 42            if (!e_bullet_active[z])
 43            {
 44               e_bullet_active[z] = 1;
 45               e_bullet_shape[z] = 1000 + bullet_ans;
 46               e_bullet_fx[z] = Efi[EN][0];
 47               e_bullet_fy[z] = Efi[EN][1];
 48               e_bullet_fxinc[z] = xinc;
 49               e_bullet_fyinc[z] = yinc;
 50               z=50;
 51            }
 52      }
 53   }
 54}

This actually works, but I am sure there is a much better way of doing it.



The closet I can come up with a formula is:

when these two things are equal:

bullet_distance = player_distance_from_bullet_origin

bullet_distance = (bullet_speed * t)


player_distance_from_bullet_origin_x = (px + (pxinx * t) - bx)
player_distance_from_bullet_origin_y = (py + (pyinx * t) - by)

then I need to do the hypot to get actual distance












what if I use my method but seek better?

like start with 10 frames at a time until I pass the limit
then reverse direction 1 frame to pass again
then reverse again and do .1




changed player move so that when player is riding a rocket, player's xinc and yinc are the same as the rocket
they used to be set to zero.
I needed to do that so that the bullets can seek in on the player using xinc, yinc

what enemies use that function? fire_enemy_bulleta()
flapper
trakbot
podzilla
canon

wow!



put this into equation editor
https://www.hostmath.com/

bulletvelocity * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

bspeed * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

px + (pxinc*t)
py + (pyinc*t)

\sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }





UPDATE

This is the equation I have come up with:

https://www.allegro.cc/files/attachment/613142

Now the fun part!

Solve for t.

My skills are not up to the task...

20220317
I am happy with my method for now...
I want to bench mark in a level with 100 cannons and see if it slows down...
not at all...
what is I patch this in for all enemies that use it...done




I had a method where I just increased time until I found a close enough solution.
That took a lot of iterations.
And if I wanted it more accurate, I would have to step time even slower, which meant even more iterations

I found a method where I search for t in large steps.
Then when I overshoot it, I reverse direction and decrease the step size...
I keep doing this until I get close enough.
This greatly reduces the ammount of values of t I need to test.

<code>
al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;

   int tries = 0;
   int done = 0;
   while (!done)
   {
      t+=tinc;
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 100) done = 1; // break out in case something goes wrong
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);
}
<\code>

However I consider this entire approach an inlegant brute force method.

I can't help but think there is a better way of doing this.

My whole approach can be condensed to:

Find the time when the player's future position has an equal distance to the bullet origin as the time the bullet will travel in the same amount of time.

Then it is trivial to get the player's future x and y position from the time.

I came up with an equation to describe that, but I don't know if it is possible to isolate t on one side (solve for t)











bug  -- does level actually run while stimp is happening??
did I just change this recently?

when I run the screen overlay frame skip always happens during stimp

change the order of these things:

old
   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

new
   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

also this:

old
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      set_frame_nums(mwPS.frame_num); // set fps_timer count to mwPS.frame_num
      stimp();
      return;
   }

new
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      stimp();
      set_frame_nums(mwPS.frame_num); // set fps_timer count to mwPS.frame_num
      return;
   }

that seems to work better












Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.

I'm going to work on finding angle from t. My approach would be to set a time (like say a few seconds) and then find the angle necessary to hit that time.


Edgar's method works great

   float bx = Efi[EN][0];
   float by = Efi[EN][1];
   float bv = Efi[EN][7];

   float px  = players[p].PX;
   float py  = players[p].PY;
   float pvx = players[p].xinc;
   float pvy = players[p].yinc;

   float A = (pvx*pvx) + (pvy*pvy) - (bv*bv);
   float B = 2*(px*pvx) + 2*(py*pvy) -2*(bx*pvx) -2*(by*pvy);
   float C = (px*px) + (bx*bx) + (py*py) + (by*by) - 2*(bx*px) -2*(by*py);
   float t = ( -B - sqrt((B*B) - 4*(A*C)) ) / (2 * A);

   al_fixed px1 = px + al_fixmul(pvx, al_ftofix(t)); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pvy, al_ftofix(t));
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

I don't know how he came up with that equation though

his explanation starts with that














I came up with a quadratic but not quite the same as ER's. It cuts down on the maths chores if you set the origin to be where the bullet starts, and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t). Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations - now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t. There are 2 solutions usually and you have to take the bigger (I don't know why or what the other one means!)

When you have t then work out dx = x + pxinc*t and dy = y + pyinc*t (displacement to where the ship will be)
then bxinc = dx/sqrt(dx*dx+dy*dy)*bspeed and byinc = dy/sqrt(dx*dx+dy*dy)*bspeed


#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>
#include <math.h>
#include <random>

#define W 800
#define H 600

static const float bullet_speed = 5.0f;

struct thing {
  float x;
  float y;
  float dx;
  float dy;
  float radius;
  ALLEGRO_COLOR color;
  float speed;
  bool active;
  thing(ALLEGRO_COLOR c, float r, float s)
      : color(c), radius(r), speed(s), active(true) {}
  void move() {
    if (active) {
      x += dx;
      y += dy;
      while (x < 0.0f)
        x += float(W);
      while (x >= float(W))
        x -= float(W);
      while (y < 0.0f)
        y += float(H);
      while (y >= float(H))
        y -= float(H);
    }
  }
  void draw() {
    if (active)
      al_draw_circle(x, y, radius, color, 1.0f);
  }
  void setup() {
    static std::minstd_rand engine;
    double theta;
    x = std::uniform_real_distribution<float>(0.0f, float(W))(engine);
    y = std::uniform_real_distribution<float>(0.0f, float(H))(engine);
    theta = std::uniform_real_distribution<>(-1.0, 1.0)(engine);
    switch (std::uniform_int_distribution<>(0, 3)(engine)) {
    case 0: // top
      theta += M_PI / 2.0;
      y = 20.0f;
      break;
    case 1: // right
      theta += M_PI;
      x = float(W - 20);
      break;
    case 2: // bottom
      theta -= M_PI / 2.0;
      y = float(H - 20);
      break;
    case 3:  // left
    default: // can't happen
      x = 20.0f;
      break;
    }
    dx = float(cos(theta)) * speed;
    dy = float(sin(theta)) * speed;
    active = true;
  }
};

thing fire(const thing &from, const thing &to) {
  float x = to.x - from.x;
  float y = to.y - from.y;
  float r2 = x * x + y * y;

  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  float A = to.dx * to.dx + to.dy * to.dy - bullet_speed * bullet_speed;
  float B = x * to.dx + y * to.dy;
  float rt = B * B - A * r2;
  if (rt >= 0.0f) {
    float t1 = (sqrt(rt) - B) / A;
    float t2 = (-sqrt(rt) - B) / A;
    float t = std::max(t1, t2);
    float vx = x + to.dx * t;
    float vy = y + to.dy * t;
    float v = sqrt(vx * vx + vy * vy) / bullet_speed;
    bullet.dx = vx / v;
    bullet.dy = vy / v;
    bullet.x = from.x;
    bullet.y = from.y;
  } else {
    // Bullet can't reach the target
    bullet.active = false;
  }
  return bullet;
}
bool collide(const thing &a, const thing &b) {
  float r2 = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
  return r2 < a.radius + b.radius;
}

int main(int, char *[]) {
  al_init();
  al_init_primitives_addon();
  ALLEGRO_DISPLAY *display = al_create_display(W, H);
  ALLEGRO_TIMER *timer = al_create_timer(1.0 / 30.0);
  ALLEGRO_EVENT_QUEUE *queue = al_create_event_queue();
  al_register_event_source(queue, al_get_display_event_source(display));
  al_register_event_source(queue, al_get_timer_event_source(timer));
  bool running = true;
  bool advance = true;
  thing ship(al_map_rgb(255, 128, 128), 10.0f, 1.0f);
  thing ufo(al_map_rgb(128, 255, 128), 10.0f, 2.0f);
  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  ship.setup();
  ufo.setup();
  bullet.active = false;
  al_start_timer(timer);
  while (running) {
    ALLEGRO_EVENT event;
    al_wait_for_event(queue, nullptr);
    while (al_get_next_event(queue, &event)) {
      if (event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
        running = false;
      } else if (event.type == ALLEGRO_EVENT_TIMER) {
        advance = true;
      }
      if (advance) {
        al_clear_to_color(al_map_rgb(0, 0, 0));
        ufo.draw();
        bullet.draw();
        ship.draw();
        al_flip_display();
        ufo.move();
        bullet.move();
        ship.move();
        if (!bullet.active) {
          bullet = fire(ufo, ship);
        } else {
          if (collide(bullet, ship)) {
            ship.active = bullet.active = false;
          }
        }
        if (!ship.active)
          ship.setup();
      }
    }
  }
  return 0;
}




I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.



bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

what???

square LHS of 1...(bxinc*t)^2 is that the same same bxinc^2*t^2...yes

try it out
3^2 * 4^2 = 9 * 16 = 144
(3*4)^2 = 12^2 = 144
yes....i'm good with that...so now I am at


(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2


And I need to expand that...


This method works too...


Clean up how it was derived:

From Peter Hull

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.

(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2














The better solution

After asking for help on the allegro.cc forums I was shown a much better method.

Edgar Reynaldo showed me a quadratic equation to solve for t.

Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.



Peter Hull showed me a similar method with slightly simpler math.

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.




(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2

I tried to covert this to fixed but A B and C are huge:

A:-85899345920.000000
B:1909319532544.000000
C:97443614031872.000000

they totally overflow fixed...so I guess I am stuck with float for now

I am removing all the old code and pasting it here:



al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulletaa(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed initial_distance = al_fixhypot((px-bx), (py-by));    // initial distance
   printf("\ninitial distance:%f\n", al_fixtof(initial_distance));

   al_fixed t = al_fixdiv(initial_distance, bspeed);         // start time


   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   //al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;


   int tries = 0;
   int done = 0;
   while (!done)
   {

      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      // if (( bdif < al_ftofix(.0001)) && (bdif > al_ftofix(-.0001))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 50) done = 1; // break out in case something goes wrong
      t+=tinc;
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

   printf("number of tries:%d\n", tries);

// show where the target position is
   tx1 = al_fixtoi(px1);
   ty1 = al_fixtoi(py1);
   ttc1 = 15;
   //ttfloat1 = al_fixtof(bdif);
   ttfloat1 = (float) tries;


}


/*
void fire_enemy_bulletabf(int EN, int bullet_ans, int p) // the original method of stepping time
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed t = al_itofix(0);     // start time
   al_fixed tinc = al_itofix(1);  // time step
   al_fixed bdif = al_itofix(0);

   for (t=al_itofix(0); t < al_itofix(1000); t+=tinc)
   {
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(5)) && (bdif > al_itofix(-5))) // is the difference with the threshold?
      {
         al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
         al_fixed py1 = py + al_fixmul(pyi, t);

         fire_enemy_bulletz(EN, bullet_ans, px1, py1);

         t = al_itofix(1000); // break out of loop
      }
   }
}


void old_fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed xlen = players[p].PX - Efi[EN][0];   // get the x distance between enemy and player
   al_fixed ylen = players[p].PY - Efi[EN][1];   // get the y distance between enemy and player
   al_fixed hy_dist =  al_fixhypot(xlen, ylen);     // hypotenuse distance
   al_fixed speed = Efi[EN][7];                  // speed
   al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
   al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
   al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc

   for (int z=0; z<50; z++)  // find empty e_bullet
      if (!e_bullet_active[z])
      {
         e_bullet_active[z] = 1;
         e_bullet_shape[z] = 1000 + bullet_ans;
         e_bullet_fx[z] = Efi[EN][0];
         e_bullet_fy[z] = Efi[EN][1];
         e_bullet_fxinc[z] = xinc;
         e_bullet_fyinc[z] = yinc;
         z=50;
      }
}



------------------------------------------------------
figure out how to do a windows release

run the batch file...

that seemed to work

published a new release 7.1.1-win on github


make my doc pages point at main page






BUG--------------------------------------------------------------------

level 62 jumping from top of ladder warps through solid block to the left???

test on level 329
immediately above ladder have a semi solid block
jump off the ladder while holding up

When player is climbing ladder they are blocked by semi-solid above
If they then jump everything works fine.
But if they hold [UP] and jump they try to grab ladder again and trigger
code that happens only when player is first grabbing ladder


I think its because ladder up moves don't recognize semi-solid because they use the new is_solid_fm type.
There is code about when a player get on a ladder initially that checks to see if the player is embedded in a wall.
This is getting triggered by the semi solid and pushing the player left until they are free.

show ladders that could be grabbed

on ladder, up pressed, jump pressed



trace what happens the instant jump is pressed while on ladder

move player() calls
proc_player_ladder() which calls
proc_player_ladder_move()

where this happens:


   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
      return;
   }


what the hell is this line?

if (players[p].up) players[p].PY += al_ftofix(2.6);

if up then move the player down??

this is how I fixed it:
   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      players[p].yinc = al_ftofix(-6.6); // initial_jump_velocity;
      players[p].PY += players[p].yinc;  // make the first move here
      return;
   }

fixed the bug...as long as it doesn't cause any unforseen complictaions it is fixed


increase archwagon bullet prox upper limit from 600 to 2000...done...



-----------------------------------------------
Bug
----------------------------------------------------
small letters to show how much health you lost on player, -20 shows as -2
only for mines...how do they work again?

void proc_mine_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(item[i][8]) / 10;
   game_event(50, 0, 0, p, i, 0, item[i][8]);
}

with enemies they have a hold off before they can damage the player again

         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount


should I change mines to be like enemies? with a hold off?

leave it...not really a bug



show all pop-messages at once to assist with aligning in level editor....done





when duplicate bmsgs occur, edit the last one and add x2 x3 etc to it....

not that simple

// make new structure to hold all of the data
I could keep it forever like a log file

only show the last 20 or so as bmsg
and consolidate like types

which ones repeat??

mines
exit when not allowed



right now all the variable that are used are:

char b_msg[40][80];
int bottom_msg=0;


I propose a simple solution of an array of structs



extern struct bmsg bmsgs[100];

struct bmsg
{
   char txt[80];
   int ev
   int frame
   int p1
   int p2
};


there are bitmaps that go with each one too???

ALLEGRO_BITMAP *bmsg_bmp[20] = {NULL};
ALLEGRO_BITMAP *bmsg_bmp2[20] = {NULL};
int bmsg_index = 0;

what is index used for??
so that I don't have to redraw all the text bitmaps
I just use a circular index

this looks way to hard...I just want to cut down on a lot of duplicates

if I stored just ev and player....


I should make a function that build the bmsg bitmap
instead of going back and replacing text with coloured text, do it the first time.

what would the function look like?

it would go somewhere between event and where event calls add_bmgs

why don't I just make event pass everything to add_bmg and do it there?

done...

next... draw uncentered while building colored line then center it after...

make a temp bitmap for that...
400x8

now I need to keep track of how wide the bitmap is so I can center it


keep the text in bmsg for now, if for no other reason than to compare for doubles

do all the real drawing in second part...









player collison with enemy
Ei[e][22] = p+1;

player collison with bullet:
only has e_type

   int e_type = 0;
   switch (e_bullet_shape[b])
   {
      case 488:   e_type = 3;  damage = 5;  break; // arrow
      case 489:   e_type = 3;  damage = 5;  break; // arrow
      case 1055:  e_type = 6;  damage = 7;  break; // cannon ball
      case 1020:  e_type = 8;  damage = 9;  break; // yellow things
      case 1054:  e_type = 7;  damage = 10; break; // green ball
      case 1062:  e_type = 12; damage = 8;  break; // flapper thing
   }

   game_event(43, 0, 0, p, e_type, 0, damage);

so in bmsg I will ne tp convert e number to etype for enemy collisions..



I'm getting a lot of these done, but I want to get rid of the whole text thing..


the only thing I have it for now is to see if I have duplicates

I want to make an array of 100 events

game_event_array[100][8]

0 - frame
1 - ev
2 - x
3 - y
4 - z1
5 - z2
6 - z3
7 - z4

whenever I get an event:

only for certain types that retrigger a lot
- like mines
- like exits

I check to see if there are any others exactly the same in the last 40 frames (1 second)
if there are, I toss it and modifiy the last

or i could only do it for a problematic few that keep retriggering

game_event_retrigger_holdoff[10][1]

when I get an exit event stick the retrigger time in this array

I have removed all traced of the old text bmsg...except for the char arrays


now all that is left is to devise the retrigger block method to prevent duplicates

game_event_retrigger_holdoff[10][1]

   if (ev == 3) // exit
   {
      if (game_event_retrigger_holdoff[1] < mwPS.frame_num)  game_event_retrigger_holdoff[1] = mwPS.frame_num + 60;
      else ev = 0;
   }

   if (ev == 50) // mine
   {
      if (game_event_retrigger_holdoff[2] < mwPS.frame_num)  game_event_retrigger_holdoff[2] = mwPS.frame_num + 20;
      else ev = 0;
   }

done...

this all looks good... I need to test all the messages

tested all but squished and stuck


make some nice looking icons that work in 8x8...maybe


maybe I could document this fully and try to encapsulate the vaiarble and function so they are not global
- at many place in the code game_event() is called
- then after that it is all handled by a few function


add some more messages, like:

player joins and quits...done

heath bonus pickups





make an array of bitmaps loaded from disk called

bmsg_icon[64]

that has 64 8x8 tiles used for drawing on bmsgs

figure out which ones I need

make a custom function to scale and save them

then edit by hand to make them look nice

once exported and touched up, never overwite them!!


step 1, collect all the shapes I will possible need


leave out player...looks good enough when just normal 20->8 with shape 1

all enemies(8)
free man
all bonus fruit, flower and diamond

exit and exit with lock

mine

rocket
bomb
bomb with det
bomb with no det
det

4 switch
4 key

done...


now get good starting values



wait....this whole thing is fucky...

when I draw scaled 20 to 8 to display it looks perfect

when I draw 20 to8 to a bitmap then to screen, it looks really bad

?????? !!!!! ??????

what if i do the whole bmg line 20 pixels high, then shrink it only when final drawing it???


What will I do about text?? double it to 16 high and leave a 2 pixel buffer above and below...



increased size of:

bmsg_bmp[x] = al_create_bitmap(800, 20); from 400, 8


made it work with bmg lines that are 20 pixels high and look great

what a lot of wasted time with shrinking 20x20 tiles to 8x8 tiles
they look really bad when another bitmap is the destination, but great when the display is...why?

It looks really good now...and its a lot simpler

still to do...
show mine..
show free man
show health bonus
done

now with much nicer (and simpler) bmsg

that was a couple of days spent working on bmsg...



why don't I practice cleaning up the sources a bit by making
game_event its own source file and header
only source files that call functions from it will need to include it
create z_gameevent.cpp and game_

gave up and reverted... there is a huge tangled mess of intertwined dependencies...
I would still like to do this...but its a huge task......

I wish I could start small, like with something like sound



get a spring sound from zapsplat

https://www.zapsplat.com/
make a free account...
mweiss001
mweiss001@gmail.com zaiden

upgraded to gold for 4GBP recurring monthly but i'll just cancel
now I don't have to give credits...





should you grab ropes by default?
only drop if you press down?
it seems really hard to stay on them....

changed ropes to grab automatically, you don't need to press up

anytime you are within reach of a rope you will automatically grab it

this caused issues about not being able to press down to fall off a rope
you would just grab it again immediately

added code to where pressing down made you fall off rope to add 4 to PY so he would actually fall

maybe I should make it only if you are falling that you automatically grab rope
and any other time you need to press up...done
I like how this works!!!

change order of w and h in zfs...done

co-located doors bug
I tried to make a linked chain of doors, one exit landing right on another entrance,
but I could never enter the second door...fixed

old:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {
      players[p].marked_door = i;

      if (item[i][8]) // do nothing if exit only
      {
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door


new:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {

      if (item[i][8]) // do nothing if exit only
      {
         players[p].marked_door = i;
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door





fixed a bug in this function...
when displaying percentages near zero it did not look perfect
the white frame was overwriting the start...

old: al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, mC.pc[15], 1); //  white frame
new: al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, mC.pc[15], 1); //  white frame
all that for one pixel!

void draw_percent_bar(int cx, int y, int width, int height, int percent)
{
   int x = cx - width/2; // get x from center
   al_draw_filled_rectangle(x+0.5f, y+0.5f, x + width+0.5f, y + height+0.5f, mC.pc[10]); //  all red to start
   if (percent > 0)
   {
      int w2 = (int) (width * ((float)percent/100)); // how much green
      al_draw_filled_rectangle(x+0.5f, y+0.5f, x + w2+0.5f, y + height+0.5f, mC.pc[11]); //  green
   }
// al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, mC.pc[15], 1); //  white frame
   al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, mC.pc[15], 1); //  white frame
}

























I could make the item 'mine' have a larger rectangular area

I could make other items like that too...like one that kills enemies...

I have wanted to do these rectangular areas for years, I just never thought to make them part of an item...

omg...I was think of making them stationary, but what if I made their position slave to another object, like a lift??!!


start by making a new item..


added one in PDE..

type 20, temp holder bitmap 889

added one to level...

added its name in menu setup:  strcpy (item_name[20],"Minefield");

incresed size of:
int item_num_of_type[20];
int item_first_num[20];
char item_name[20][40];

to

int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];


set all to 200 for testing...

item[][6] = minefield x (int) (2000)
item[][7] = minefield y (int) (2000)
item[][8] = minefield w (int) (2000)
item[][9] = minefield h (int) (2000)


make it show...

void draw_minefield(int i)
{
   float x1 = item[i][6];
   float y1 = item[i][7];
   float x2 = x1 + item[i][8];
   float y2 = y1 + item[i][9];
   rectangle_with_diagonal_lines(x1, y1, x2, y2, 10, 10, 10);
}


check collision...

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_item_collision(p, x);
      }
      if (item[x][0] == 20) // check for minefield collision
      {
         al_fixed ix1 = al_itofix(item[x][6]);
         al_fixed iy1 = al_itofix(item[x][7]);
         al_fixed ix2 = ix1 + al_itofix(item[x][8]);
         al_fixed iy2 = iy1 + al_itofix(item[x][9]);
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_minefield_collision(p, x);
      }
   }


void proc_minefield_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(1);
}

it works!!!!


make an editor so you can adjust x, y, w, y

new button in sliders:

if (bn == 84) sprintf(smsg, "Get New Minefield Rectangle");

if (bn == 84)
   if (getbox( "Minefield Range", 2, 4, num) == 1)
   {
      if (--bx2 < bx1) bx2++;
      if (--by2 < by1) by2++;
      item[num][6] = bx1*20;
      item[num][7] = by1*20;
      item[num][8] = (bx2 - bx1)*20;
      item[num][9] = (by2 - by1)*20;
      Redraw = 1;
   }

in object viewer:

case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
break;


it works!!!

now what?

it would be nice to adjust with map...
but I can easily make it work without that....

- can I kill the item? // probably won't do this... no other item supports getting killed

- hide the main icon

- make it cycle on and off?

- make it turn on when touched, turn off when touched?

- link it's position to a lift?


lets pick an int for mode...
item [][10] == mode
mode == 0 // always on

lets pick an int for damage
item [][11] == health dec (/100)

what variables does that leave me?
12 and 13 only


mode 1:
become active when touched
timer value = 13;
timer counter = 12;


mode 2:
become inactive when touched
timer value = 13;
timer counter = 12;


implement 11 health dec...

if (bn == 81) item[num][11] = (int)f;              // minefield damage

if (bn == 81) sprintf(smsg, "Damage:%d", item[num][11]);

case 81: sul=1000;  sll=0;   sinc=10; sdx=item[num][11];           break;  // minefield damage


case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
   mdw_slider(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 81, num, type, obt, 0, 12, 15, 15, 1,0,0,0); a++;  // damage
break;

void proc_minefield_collision(int p, int i)
{
   al_fixed d = al_itofix(item[i][11]) / 100;
   int id = al_fixtoi(d);

   players[p].LIFE -= d;
   game_event(50, 0, 0, p, i, 0, id);
}

done and works great!!

getting new rectangle make it one block smaller at lr corner..done

heath event of zero shows green...made it blue, but still need to address this

inc should be 1 not 10...done

implement mode 1 and 2.....


I would love to have 2 rectangles, one for the trigger and one for the damage...
however I do not have enough integers

unless I do something tricky

is item[][2] really not used by anything??

if I ignore these I could get 2 more here:
item[][14] = time to live
item[][15] = tag with cloner item id

basically if I want 2 boxes i will need 8 variables....

what if I used an enemy to make this whole thing work?
they have a lot more variables to work with...
plus, I could kill them if I wanted!!



snap decision...lets do that....

I can still keep the item version...maybe use it for simpler ones...



[10]--field-----------------------------------------------------------------------------

Ei[][0] = 10;
Ei[][1] = 476; // bitmap
Ei[][2] = 0;   // draw mode (v and h flips)

//Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)
Ei[][5]  mode

Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2

Ei[][15] = 200; field box x
Ei[][16] = 200;  field box y
Ei[][17] = 200;  field box w
Ei[][18] = 200;  field box h

Efi[][4] = 2.3;  // life dec
Efi[][12] = 1.0; // scale
Efi[][14] = 0.0; // rot

made an enemy like this in PDE...done and added to level...

add enemy to lists...done
strcpy (enemy_name[10], "Field");


add code to draw...very similar to cloner...done

if (Ei[e][0] == 10) // field
{
   // trigger box
   float tx1 = (float)Ei[e][11]*20;
   float ty1 = (float)Ei[e][12]*20;
   float tx2 = (float)Ei[e][13]*20+20;
   float ty2 = (float)Ei[e][14]*20+20;
   int tc1 = 14 + 128; // trigger box color

   // field
   float sx1 = (float)Ei[e][15];
   float sy1 = (float)Ei[e][16];
   float sx2 = sx1 + (float)Ei[e][17];
   float sy2 = sy1 + (float)Ei[e][18];
   int sc1 = 11 + 128; // field box color

   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box
   rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
}

add code to take damage....done...
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((players[p].PX > ex1) && (players[p].PX < ex2)
          && (players[p].PY > ey1) && (players[p].PY < ey2)) Ei[e][22] = p+1;
      }


      if (Ei[e][0] == 10) // check for field collision
      {
         al_fixed ix1 = al_itofix(Ei[e][15]);
         al_fixed iy1 = al_itofix(Ei[e][16]);

         al_fixed ix2 = ix1 + al_itofix(Ei[e][17]);
         al_fixed iy2 = iy1 + al_itofix(Ei[e][18]);

         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_field_collision(p, e);
      }
   }

void proc_field_collision(int p, int x)
{
   players[p].LIFE -= Efi[x][4];
   game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
}


add code to adjust boxes...hopefully its close to cloner...

if (bn == 85) sprintf(smsg, "Get New Field Rectangle");
if (bn == 86) sprintf(smsg, "Get New Field Trigger Box");

if (bn == 85)
   if (getbox("Get New Field ", 3, 10, num))
   {
      Ei[num][15] = bx1*20;
      Ei[num][16] = by1*20;
      Ei[num][17] = (bx2-bx1)*20;
      Ei[num][18] = (by2-by1)*20;
      Redraw = 1;
   }

if (bn == 86)
   if (getbox("Get New Field Trigger Box", 3, 10, num))
   {
      Ei[num][11] = bx1*20;
      Ei[num][12] = by1*20;
      Ei[num][13] = (bx2-bx1)*20;
      Ei[num][14] = (by2-by1)*20;
      Redraw = 1;
   }


perfect...now I can edit both boxes...now for map move...





if ((obt == 3) && (type == 10)) // field boxes
{
   // field trigger box coordinates
   int x1 = Ei[num][11]/20;
   int y1 = Ei[num][12]/20;
   int x2 = x1 + Ei[num][13]/20 -1;
   int y2 = y1 + Ei[num][14]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_ftb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, mC.pc[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, mC.pc[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_ftb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, mC.pc[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, mC.pc[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }

   // field damage box coordinates
   x1 = Ei[num][15]/20;
   y1 = Ei[num][16]/20;
   x2 = x1 + Ei[num][17]/20 -1;
   y2 = y1 + Ei[num][18]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_fdb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, mC.pc[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, mC.pc[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_fdb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, mC.pc[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, mC.pc[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }
}


if (mouse_on_tb_ul) // move trigger box from ul
{
   // get the width and height
   int w = Ei[num][13] - Ei[num][11];
   int h = Ei[num][14] - Ei[num][12];
   // set new position
   Ei[num][11] = mx;
   Ei[num][12] = my;
   Ei[num][13] = mx + w;
   Ei[num][14] = my + h;
}
if (mouse_on_ftb_ul) // move field trigger box from ul
{
   Ei[num][11] = mx*20;
   Ei[num][12] = my*20;
}
if (mouse_on_fdb_ul) // move field damage box from ul
{
   Ei[num][15] = mx*20;
   Ei[num][16] = my*20;
}
if (mouse_on_tb_lr)  // resize trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < Ei[num][11]) mx = Ei[num][11];
   if (my < Ei[num][12]) my = Ei[num][12];
   // set new postion
   Ei[num][13] = mx;
   Ei[num][14] = my;
}

if (mouse_on_ftb_lr) // resize field trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][11]/20)) mx = (Ei[num][11]/20)+1;
   if (my < (Ei[num][12]/20)) my = (Ei[num][12]/20)+1;
   Ei[num][13] = mx*20 - Ei[num][11];
   Ei[num][14] = my*20 - Ei[num][12];
}

if (mouse_on_fdb_lr) // resize field damage box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][15]/20)) mx = (Ei[num][15]/20)+1;
   if (my < (Ei[num][16]/20)) my = (Ei[num][16]/20)+1;
   Ei[num][17] = mx*20 - Ei[num][15];
   Ei[num][18] = my*20 - Ei[num][16];
}


map works......

now detect trigger collision also....done

if (Ei[e][0] == 10) // check for field collision
{
   // trigger field
   al_fixed ix1 = al_itofix(Ei[e][11]);
   al_fixed iy1 = al_itofix(Ei[e][12]);
   al_fixed ix2 = ix1 + al_itofix(Ei[e][13]);
   al_fixed iy2 = iy1 + al_itofix(Ei[e][14]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 0);

   // damage field
   ix1 = al_itofix(Ei[e][15]);
   iy1 = al_itofix(Ei[e][16]);
   ix2 = ix1 + al_itofix(Ei[e][17]);
   iy2 = iy1 + al_itofix(Ei[e][18]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 1);
}


void proc_field_collision(int p, int x, int b)
{
   if (b == 0) // trigger field
   {

   }
   if (b == 1) // damage field
   {
      players[p].LIFE -= Efi[x][4];
      game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
   }
}


now add slider to adjust the amount of damage....done...reused the same one as all other enemies
...does it also work for the main enemy?...no...collision box..set to 10 and still no..

I don't have any specific code to handle this type of enemy....


added this line to move_enemies()
case 10:  enemy_field(e);  break;


void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
}


now I can take damage from enemy and kill it, but it doesn't die nicely

added to enemy_killed()


case 10: // field
   na = Ei[e][3] = 105;  // new ans
   dl = Ei[e][30] = 40; // death_loop_wait; set delay
   Ei[e][24] = 934+(ht-1)*32; // shape
   Efi[e][11] = al_ftofix(.98); // scale multiplier
   Efi[e][13] = al_ftofix(306/dl); // rot inc
   mwB.zz[0][na] = zz[5][na]; // set shape
   zz[1][na] = 0;         // point to zero
   zz[2][na] = mwPS.frame_num; // set counter
   zz[3][na] = dl / zz[4][na]; // set ans timer
break;

change this at end of enemy killed to include type 10
// almost all do this but not enough to do by default
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12 )
{
   if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
   if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
   Ei[e][0] = 99; // set type to death loop
}


OK now that works, but later, I'll need to make it look nice
for now if I don't want to be able to shoot it, set collision box to 0
...can still kill with bomb...





now lets implement some modes....

0 = static, damage always

1 = no damage until triggered, then timer runs

2 = damage until triggered, then none while timer runs

what are my variables for mode, timer and timer count?

Ei[][5] = mode;
Ei[][6] = timer_value;
Ei[][7] = timer_count;

Ei[][8] = damage; // currently in damage mode




set up buttons for these...

if (bn == 87) // field mode
{
   if (Ei[num][5] == 0) sprintf(smsg, "Damage Always");
   if (Ei[num][5] == 1) sprintf(smsg, "No Damage Until Triggered");
   if (Ei[num][5] == 2) sprintf(smsg, "Damage Until Triggered");
}

if (bn == 87)
{
   Ei[num][5]++;
   if (Ei[num][5] > 2) Ei[num][5] = 0;
}

if (bn == 82) Ei[num][6] = (int)f;        // field timer
if (bn == 82) sprintf(smsg, "Field Timer:%d", Ei[num][6]);
case 82: sul=1000;  sll=10;  sinc=1; sdx=Ei[num][6];           break;  // field timer

now lets actually write some code to process this


void draw_enemy_field(int e)
{
   float tx1 = (float)Ei[e][11]; // trigger
   float ty1 = (float)Ei[e][12];
   float tx2 = tx1 + (float)Ei[e][13];
   float ty2 = ty1 + (float)Ei[e][14];
   int tc1 = 14 + 128; // trigger box color
   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box

   if (Ei[e][8]) // currently in damage mode
   {
      float sx1 = (float)Ei[e][15]; // field
      float sy1 = (float)Ei[e][16];
      float sx2 = sx1 + (float)Ei[e][17];
      float sy2 = sy1 + (float)Ei[e][18];
      int sc1 = 11 + 128; // field box color
      rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
   }
}

void proc_field_collision(int p, int e, int b)
{
   if (b == 0) // trigger field
   {
      Ei[e][7] = Ei[e][6]; // reset timer
   }
   if (b == 1) // damage field
   {
      if (Ei[e][8]) // currently in damage mode
      {
         players[p].LIFE -= Efi[e][4];
         game_event(50, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
      }
   }
}

void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer
   int damage = 0;
   if (Ei[e][5] == 0) damage = 1;                       // damage always
   if ((Ei[e][5] == 1) && (Ei[e][7] > 0)) damage = 1;   // damage when timer is running (no damage until triggered)
   if ((Ei[e][5] == 2) && (Ei[e][7] == 0)) damage = 1;  // damage unless timer running  (damage when triggered)
   Ei[e][8] = damage;  // field is currently in damage mode
}


this is all working good...

now some minor bug fixes...

cant see the field in obj viewer

also what color should they be??
trigger yellow
field red

OK that looks good...now make field always show in level editor
what is that global? level_editor_running


looking good...now figure out how to tell when timer is running...done
show small number counting down second above the enemy..

test if I can use this at the bottom of a pit that kills you instantly...
not unless I set the damage higher...set to 100

move rect to be red...done
hide trigger if not used...done


I want to try slaving it to a lift...just the damage field..always on for now
mode = 3; works as proof on concept...

can we make the field kill enemies

right now I think all my collisions are with player...
I only really care if things collide with players....??

where will I do the collision detection?

I propose to make a new collision detection based on what collides with fields

Then I can do players, enemies, items...


made void proc_field_collisions(void);
and added it to loop....


seems to be working good...

items...done...


wow!!!

now I need to be able to set this in the field somehow....









lets just list a bunch of possible types here:


always on, invisible invulnerable enemy
always on, enemy can be killed


type 3 - always on, following lift

type 4 - shooting enemy toggles field

have a bunch of toggles for enemy shape
- hidden, invulnerable
- shown, killable
- shown, shooting toggles


lets implement hit type
Ei[e][4]

0 normal (can kill)
1 invulnerable
2 toggle also need mode == 4

its better to do this with modes...

pick which modes are invincible...choose a variable also used for death ans...will never be used for this



mode 4 toggle
don't show trigger or allow timer to run
maybe I could make my own bullet handler so it doesn't eat the bullet???

5 trigger be time based only...on time off time...

6 timed like 1 but triggered with shot
7 timed like 2 but triggered with shot

8 timed like 2 but triggered with enemy collision
8 timed like 2 but triggered with enemy collision

immdiate when in zone



I've got to use some more variables
dig into the fixed...

on  count
off count

runs with timer only



lets start with what triggers it:
---------------------------------
player in trigger zone
enemy in trigger zone
player shoots enemy
player touches enemy
strictly timer based on and off

then what happens next:
-----------------------
zone on with timer
zone off with timer

toggle

immediate on or off


then what does it affect:
-------------------------
players
enemies
items

optionally
------------------
move with lift


how many modes do I have that work?

-------------------
5-0 - normal
4-0 - normal
always on
not invulnerable
--------------------
5-1 - off until triggered, then timer runs
4-0 (0 normal, 1 invul, 3 add time)

not invulnerable
--------------------
2 - on until triggered, then timer runs
not invulnerable
--------------------
3 - alway on, follows lift
not invulnerable
--------------------


lets get some nicer drawing for the stuff


spike pit...
flames...
acid...


20220327 new day
did a lot yesterday
kind of ran out of steam after 12 hours
today I am going to bring it on home...complete a lot of this.

I want to start by implementing what objects are affected by the field

use a single int and also use it for invul


bit 1 player
bit 2 enemy
bit 3 item
bit 4 invuln


typedef union
{
 uint8_t     all_flags;      /* Allows us to refer to the flags 'en masse' */
 struct
 {
  uint8_t foo : 1,        /* Explanation of foo */
          bar : 1,        /* Explanation of bar */
          spare5 : 1,     /* Unused */
          spare4 : 1,     /* Unused */
          spare3 : 1,     /* Unused */
          spare2 : 1,     /* Unused */
          spare1 : 1,     /* Unused */
          spare0 : 1;     /* Unused */
 };
} EX_FLAGS;

static EX_FLAGS    Flags;  /* Allocation for the Flags */

Flags.all_flags = 0U; /* Clear all flags */

...

Flags.bar = 1U; /* Set the bar flag */

-----------------------------------------------------------

if(x & 0x01){} // tests if bit 0 is set using bitwise AND
x ^= 0x02;     // toggles bit 1 (0 based) using bitwise XOR
x |= 0x10;     // sets bit 4 (0 based) using bitwise OR

-----------------------------------------------------------


/* Each of these preprocessor directives defines a single bit,
   corresponding to one button on the controller.
   Button order matches that of the Nintendo Entertainment System. */
#define KEY_RIGHT  0b00000001
#define KEY_LEFT   0b00000010
#define KEY_DOWN   0b00000100
#define KEY_UP     0b00001000
#define KEY_START  0b00010000
#define KEY_SELECT 0b00100000
#define KEY_B      0b01000000
#define KEY_A      0b10000000

int gameControllerStatus = 0;

/* Sets the gameControllerStatus using OR */
void KeyPressed( int key ) { gameControllerStatus |= key; }

/* Clears the gameControllerStatus  using AND and ~ (binary NOT)*/
void KeyReleased( int key ) { gameControllerStatus &= ~key; }

/* Tests whether a bit is set using AND */
int IsPressed( int key ) { return gameControllerStatus & key; }

---------------------------------------------------------------------------

lets call Ei[e][3] flags

make 4 button to set player, enemy, items, invul

if (bn == 89) // field affects player flag
{
   if (Ei[num][3] & 0b00000001) sprintf(smsg, "Affects Players");
   else sprintf(smsg, "Does Not Affect Players");
}
if (bn == 90) // field affects enemy flag
{
   if (Ei[num][3] & 0b00000010) sprintf(smsg, "Affects Enemies");
   else sprintf(smsg, "Does Not Affect Enemies");
}
if (bn == 91) // field affects item flag
{
   if (Ei[num][3] & 0b00000100) sprintf(smsg, "Affects Items");
   else sprintf(smsg, "Does Not Affect Items");
}
if (bn == 92) // field enemy invulnerable flag
{
   if (Ei[num][3] & 0b00001000) sprintf(smsg, "Invulnerable");
   else sprintf(smsg, "Not Invulnerable");
}

if (bn == 89) Ei[num][3] ^= 0b00000001; // bitwise OR
if (bn == 90) Ei[num][3] ^= 0b00000010; // bitwise OR
if (bn == 91) Ei[num][3] ^= 0b00000100; // bitwise OR
if (bn == 92) Ei[num][3] ^= 0b00001000; // bitwise OR

int cdp = ((Ei[e][8]) && (Ei[e][3] & 0b00000001)); // damage active and player flag
int cde = ((Ei[e][8]) && (Ei[e][3] & 0b00000010)); // damage active and enemy flag
int cdi = ((Ei[e][8]) && (Ei[e][3] & 0b00000100)); // damage active and item flag


lets add to this trigger:

trigger field player
trigger field enemy
trigger shoot enemy
trigger timer

remove Ei[][4]...done

if toggle is set, inv should be too, unless you want one toggle then enemy dies...


if toggle is set and in mode 1 or 2 they will override....

how about mode 0 is default and if you dont want any changes just implement with flags

mode 3 is now toggle
when setting that mode, automatically set the toggle flag and unset the inv flag

make a button to set initially on or off..



can i use another flag bit for damage on?  this will be the ninth bit...try it...I think I can...it seems to work...

now I got rid of Ei[][8] for damage currently on and replaced it with another flag...

should I set up some nice defines for these??

#define PM_ENEMY_FIELD_AFFECTS_PLAYER 0b000000001
#define PM_ENEMY_FIELD_AFFECTS_ENEMY  0b000000010
#define PM_ENEMY_FIELD_AFFECTS_ITEM   0b000000100
#define PM_ENEMY_FIELD_INVULNERABLE   0b000001000
#define PM_ENEMY_FIELD_TRIGGER_PLAYER 0b000010000
#define PM_ENEMY_FIELD_TRIGGER_ENEMY  0b000100000
#define PM_ENEMY_FIELD_BULLET_TOGGLE  0b001000000
#define PM_ENEMY_FIELD_TRIGGER_TIMER  0b010000000
#define PM_ENEMY_FIELD_CURRENT_DAMAGE 0b100000000


done....



when setting mode 3 (toggle), automatically set the toggle flag and unset the inv flag
in sliders...done

player should never take damage from cloner, but I can't set the collison box to zero because it's used by bullets

in void proc_player_collisions(int p)

changed this line
for (int e=0; e<100; e++)
{
// if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
   if ((Ei[e][0]) && (Ei[e][0] != 99) && (Ei[e][0] != 10) // if active and not deathcount or field
done...
make collison box a little more forgiving maybe 12 or 14 instead of 10... change PDE to 12...can still edit manually...done


bullet is back to getting eaten....fix and maybe make it a flag....

in proc_enemy_collision_with_pbullet(int e)

if ((Ei[e][0] == 10) && (Ei[e][5] == 4)) // don't kill bullet used to toggle field
{
}
else pbullet[c][0] = 0;       // bullet dies

if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE)) // don't kill bullet used to toggle field
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

done and works...

test the collision areas of fields, they are a little off...changed the offset in collison detection...done

old:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]);
 al_fixed tfy1 = al_itofix(Ei[e][12]);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]);
 al_fixed dfy1 = al_itofix(Ei[e][16]);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);


new:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]-10);
 al_fixed tfy1 = al_itofix(Ei[e][12]-10);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]-10);
 al_fixed dfy1 = al_itofix(Ei[e][16]-10);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);



when setting mode = 0
clear bullet toggle flag...done

don't reset inv flag

now what?

make new shapes including hidden...

make a shape that has a hole for the timer count!!


made default from PDE have damage on and mode 0 and draw mode 1

I won't enforce it, but it makes sense to have hidden and inv both set

if hidden, I should still show it in level editor...

if on off switches make then change...done

make button for initial setting on/off in toggle mode...done

make a slider for choosing lift number...and a place to store it...
Ei[][21]

it follows lift just great...I can even center it nicely
maybe make a flag for centering later


now it is always on...I want to change this...

turned it off....

bullet toggle works good...

in level editor, show the field centered on the lift....
how about actually set it when lift is changed with slider....

I should make a function to do this...done


now can we do the timers while in lift mode?

no.. timers only work when mode == 1 or 2

maybe I could make lifts separate from mode...
I would need to use an int for the lift number

I could also potentially move the trigger box with another lift...whooa!!

can timer and toggle co-exist right now??

no, because the timer forces it on or off


I think if I remove lift from mode then I can have modes realted to trigger only...like


then I can have a separate int for the lift stuff
I could jam 4 things in there

1 bit field follow lift
7 bits lift number

1 bit trigger follow lift
7 bits lift number

or I can add a few more flags to 3 and use 2 ints for lifts


I will also need two more variables for the second timer

Ei[][5]  mode
Ei[][6]  timer1 value
Ei[][7]  timer1 count
Ei[][8]  timer2 value
Ei[][9]  timer2 count

let's re-arrange the modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

no lift...move in to flag and lift numbers in:
Ei[][19]
Ei[][20]

what am I using 21 for?? lift number! perfect!

OK lets do this...
start with lift flags

#define PM_ENEMY_FIELD_LIFT_SETS_FLD  0b0000010000000000
#define PM_ENEMY_FIELD_LIFT_SETS_TRG  0b0000100000000000

Ei[][20] // trig lift
Ei[][21] // field lift

sliders...done

patched that all in nicely...

now rearrange modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

screw it, im leaving toggle out, it does nothing...

0 on
1 on till trigger
2 on when trigger
3 double timer trigger

NO! I need a mode that is not a timer, so timers wont fuck over toggle

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger


good so far....now implement double timer...

make slider to adjust

Ei[][8]  timer2 value



why do I have 2 timers?

would it not be simpler to run one from value to zero then reset...and have a midpoint where the damage flips??
lets just call timer 2 the flip point

that works great.

hide timer numbers in modes 0 and 1

in mode 3 do a modified count down for each stage...done





I would say that most of the basic funtionality has been implemented...
now for some polish and testing...



naming

enemy is called Field
is has a
Damage Field
Trigger Field
make this naming consistant

at the top should be the stuff related to the enemy
inv and shape

then the stuff related to the Damage Field

get new...etc

the viewer page looks good...

it all looks good...
not implemented:
anything except player triggering
unused flag trigger timer


I want to make a test level to show this off....

bugs

when creating, a creator might be nice..done
or take me to the edit page right away
of just make the lr trigger not exactly the ul damage!!..this is done...

remove old simpe PDE for field...
remove old item field thing...done

when invisible, its kinda hard to find in level editor...fixed

death sequence needs something more than just copying cloner

make some better shapes for damage fields...

how will I show different draw types
use an int? patched it in..

Its use as an item killer is nice too... I can make a screen that items can't go through

to kill items nicely, have the killing screen ignore things in the death phase...done
redraw attached to lift when stuff moves in level editor....done
make boxes snap to 20 grid..not a problem unless attached to lift...done


I want to make field able to kill enemy and player bullets also....done!!!
when checking collisions, I realized I can also have bullets affect trigger!!!

make damage field able to be invisible...done

also add display options for trigger field use Ei[][10]... done for now only default and none


20220328 6:20 AM
wow this is coming along so great......time for a push


lets try some other things that can trigger...

enemy
item
enemy bullet
player bullet

right now trigger only makes sense in mode 2 and 3
and then timers run...

can it be instant by setting timer to 0?
0 and 1 never work, 2 works...why??

moved dec counter to last thing in enemy proc...now 1 works

patch in trigger sources...
did a bunch of re-arranging flags and slider button toggles

now make the new trigger source functionality work....done

why does a new filed have damage of 0?...done

fix display of damage to only 2 decimals...done

why is bullet getting eaten in mode 1?


in void proc_enemy_collision_with_pbullet(int e)
old:
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
new
if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field



Change the wording of MODE.
ON until triggereg
OFF until triggered

Make Mode capitalized


I want to make a toggle mode based on field...
but how will i make it work?...I'll need a hold off
when something first enters

detect if nothing is in trigger box
then if next frame something is in then trigger

then wait until it is empty again before allowing another trigger
I'll need something to keep track of how it was the last frame

I could use a flag...

each frame:
if not set from last frame...
and set this frame...toggle trigger fires

use 2 flags...

start of frame clear current
when checking collisions if any trigger, set current trigger
after checking collisions if not last the yes this then fire toggle
set last to current for next time...

I have been doing the triggers wrongs
collisions with damage need to afect specific things
but collisions with triggers?
who cares where they came from?
all that matters is that a trigger happened

new flags

#define PM_ENEMY_FIELD_TRIGGER_CURR  0b1000000000000000
#define PM_ENEMY_FIELD_TRIGGER_LAST  0b1000000000000000

at the start of the enemy proc loop CURR is cleared
if any trigger collisions, CURR is set

at the end of the collision checks...

if CURR is set: proc things that happen when something is in trigger box
if CURR is set and PREV is clear: process things that only happen when initiallt triggered

set PREV to CURR


what if I remove all toggle by shooting actual enemy...might make things easier....
once I get the trigger toggle stuff working I'll look at it...

I'm ready to do it

there is custom code in

void proc_enemy_collision_with_pbullet(int e)

for when a bullet hits the field enemy...
i am going to try to take it out completely
I still want the enemy to be invincible...but I can just set collision box to zero....
wait....

just leave code there so pbullets completely ignore field enemy
then I should just make it always invincible...
use the enemy tile stuff just for counter and progress bar....
I can get collision box for something else too maybe....

old:

   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2)))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has

//            if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

      if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
      {
      }
      else pbullet[c][0] = 0;       // bullet dies

   }

new:
   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2) && (Ei[e][0] != 10))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has
      pbullet[c][0] = 0;       // bullet dies
   }


I can go back one higher to the function that call this:

old:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if (Ei[e][0] < 50) proc_enemy_collision_with_pbullet(e);

         // check for time to live
         int ttl = Ei[e][27];

new:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if ((Ei[e][0] < 50) && (Ei[e][0] != 10)) proc_enemy_collision_with_pbullet(e);



now it does not even detect bullet, but I kept the invincible code because of bombs
if I removed that, nothing could ever kill it

this whole thing that every enemy has....

   if (Ei[e][31]) // hit
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_INVULNERABLE)) // invulnerable flag not set
      {
         enemy_killed(e);
         return; // don't do anything else past here
      }
   }
   enemy_player_hit_proc(e);

void enemy_player_hit_proc(int e)
{
   if (--Ei[e][23]<0) // hit player retrigger
   {
      if (Ei[e][22]) // player hit!
      {
         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount
      }
   }
  else Ei[e][22] = 0;
}

I'm going to remove all this...

then I will get back 22 and 23

edit this to ignore fields

void bomb_enemies(int i, int t, int dr, al_fixed x, al_fixed y)
{
   for (int e=0; e<100 ; e++) // enemies in damage window?
      if ((Ei[e][0]) && (Ei[e][0] != 10))
      {
//         al_fixed dist = al_fixhypot( (Efi[e][0] - itemf[i][0]), (Efi[e][1] - itemf[i][1]) );
         al_fixed dist = al_fixhypot( (Efi[e][0] - x), (Efi[e][1] - y));
         if (dist < al_itofix(dr))
         {
            if (t == 1) bomb_crosshairs(10 + al_fixtof(Efi[e][0]), 10 + al_fixtof(Efi[e][1]));
            if (t == 2)
            {
               Ei[e][31] = 2; // set bomb hit
               Ei[e][26] = item[i][13];  // player that did bomb
            }
         }
      }
}


now I have reclaimed a lot more ints....

bottom line:
field is now invincible, nothing, not bombs or bullets can kill it
it should not interact with player at all...

that makes things a lot simpler and I have freed up all these variables

Ei[][22] =                 player hit
Ei[][23] =                 player hit retrigger
Ei[][24] =                 health bonus shape
Ei[][25] =                 health bonus amount
Ei[][26] =                 used to tell what player killed enemy
Ei[][27] = time to live
Ei[][28] =                 cloner create id
Ei[][29] =                 collision box size
Ei[][30] =                 death loop count
Ei[][31] =                 flag that this enemy got shot with bullet


now I need to make the toggle mode in obj viewer show all the trigger stuff


For timed on and off, make custom button that say time on and time off.

also make initial time [7] adjustable for synchronization...

which is which???
total time...6
on time 8
initial time 7



I think I am abandoning drawing with tile stuff, maybe just a place holder

I want to implement a draw mode for the main shape

like show the number and progress bar in different ways

my main function is very small now



void enemy_field(int e)
{
   int mode = Ei[e][5];
   int trig_toggle = 0;

   Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_CURR;  // clear current trigger flag
   detect_field_collisions();
   if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) // is current trigger flag set?
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_PREV)) trig_toggle = 1; // if triggered this frame and not triggered last frame, set trigger toggle
      Ei[e][3] |=  PM_ENEMY_FIELD_TRIGGER_PREV; // set previous trigger for next frame
   }
   else Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_PREV; // clear previous trigger for next frame

   if (mode == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE; // in mode 0, always set damage flag

   if ((mode == 1) && (trig_toggle)) Ei[e][3] ^= PM_ENEMY_FIELD_CURRENT_DAMAGE; // toggle current damage flag

   if (mode == 2) // damage unless timer running  (no damage when triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 3) // damage when timer is running (no damage until triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] > 0)  Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 4) // timed on and off
   {
      // timer will run outside this function always, but in this mode, when it gets to zero, we will reset it
      if (Ei[e][7] == 0) Ei[e][7] = Ei[e][6];
      if (Ei[e][7] < Ei[e][8]) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else                     Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;  // set damage off
   }

   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_FLD) set_field_location_from_lift(e, 0, 0);
   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_TRG) set_field_location_from_lift(e, 1, 0);

   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer

}



what is still left to do?

get some draw modes for the main enemy

probably never show the shape when game is running

what do I want to do with the main bitmap Ei[][1]?

leave it blank and use another var for draw mode??
or customize the drawing routines so that field always draws itself...yes do that...

void draw_enemies(void)
{
   al_set_target_bitmap(level_buffer);
   for (int e=0; e<100; e++)
      if (Ei[e][0])  // if enemy active
      {
         if (Ei[e][0] == 10) draw_enemy_field(e); // field - do not draw anything here for field, let draw_enemy_field() do it all
         else
         {
             int EXint = al_fixtoi(Efi[e][0]);
             int EYint = al_fixtoi(Efi[e][1]);
             int flags = 0;
             if (Ei[e][2] == 0) flags = ALLEGRO_FLIP_HORIZONTAL;
             if (Ei[e][2] == 1) flags = 0;
             if (Ei[e][2] == 2) flags = ALLEGRO_FLIP_VERTICAL;
             if (Ei[e][2] == 3) flags = ALLEGRO_FLIP_VERTICAL & ALLEGRO_FLIP_HORIZONTAL;
             int tn = Ei[e][1];

             float rot = al_fixtof(al_fixmul(Efi[e][14], al_fixtorad_r));
             float sc = al_fixtof(Efi[e][12]);
             al_draw_scaled_rotated_bitmap(tile[tn], 10, 10, EXint+10, EYint+10, sc, sc, rot, flags);

             // if enemy is expiring show how many seconds it has left
             if (Ei[e][27]) al_draw_textf(f3, mC.pc[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);
         }



do this is my draw code..

if (level_editor_running) al_draw_bitmap(tile[476], ex, ey, 0);


OK all that is done...

now I have freed up

Ei[][1]
Ei[][2]
Ei[][27]

I have so many free variables now at the expense of..
invulnerable
can't hit player
can't get hit players, bullets or bombs
no regular display, all custom
no time to live

use Ei[][2] for enemy draw mode
how I will draw stuff

0 = draw nothing
1 = small text counter
2 = large text counter
3 = small progress bar
4 = large progress bar
done...

in creator
make field initially on
remove collision box
done....


should I make them show all the time, or only when timer is running?
numbers...only when running
percent bars..always

make it so that when I copy and paste, the boxes are offset also, like cloner boxes....
done with regular copy and zfs copy.....

then test all type 3....all looks good!!!!

now apply all that to the timed mode...done...

wow that was easy.....



What do I have left?

I think all the functionality is there, maybe just some nice drawing code stuff for fields...

Oh yeah and also how the field attach to lifts

right now they just center

in the x axis:
center , right or left

in the y axis
center, right of left

6 flags....9 combinations

no...do it this way
XC
XF
XL

if c=1 ignore the rest
if c=0 four possibilities
fx1 = lx1
fx1 = lx2
fx2 = lx1
fx2 = lx2

XC XF XL
0  0  0 Field X1 = Lift X1
0  0  1 Field X1 = Lift X2
0  1  0 Field X2 = Lift X1
0  1  1 Field X2 = Lift X2
1  x  x Centered

so now there are 5 setting for x and 5 for y for a total of 25 combinations
I like that a lot better than 9

I have all the stuff done for allignment of fields to lifts

removed the flags for invuln, toggle and eat bullet

link the creator back in for the viewer button...done

after creating field, open the viewer...

unless create is called from the viewer already....

how can I tell if the viewer is running? ... another global...
or I can hook it from what called it...




PDE special calls create_obj
in PDE I am hooking in the viewer after...

obj viewer create button calls create_obj

those are the only 2 places...

why am I hooking in in PDE?
that is too far up the chain

hook in in craete OBJ that is common, or even better in the actual creators...

this works, but what happens in recursion as the viewer calls another viewer after creating...
when escaping out you go bakc through the nested viewer...I can live with it...

what about cancelling in the middle of creating? works great

what about pmsg?...patched in obj viewer at the end of create..done...

what about game_events caused by enemies getting killed by fields...
right now it says player killed with bullet...


in enemy killed this is called:
game_event(62, 0, 0, Ei[e][26], e, 0, 0);
where is 26 set?
and this
int ht = Ei[e][31]; // hit type

make a custom event...

still needs to be called from enemy_killed()

   if (type == 1) // enemy
   {
         Ei[x][31] = 1;           // flag that this enemy got shot with bullet
         Ei[x][26] = p;           // number of player's bullet that hit enemy
   }

lets try
         Ei[x][31] = 3;           // flag that this enemy got killed by a field
         Ei[x][26] = x;           // number of field


int ht = Ei[e][31]; // hit type
int hb; // health bonus
if (ht == 1) hb = 1; // bullet
if (ht == 2) hb = 2; // explosion
if (ht == 1) hb = 1; // field

// almost all do this but not enough to do by default
int a = Ei[e][0];
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12)
{
   Efi[e][4] = al_itofix(0);  // cant hurt anymore
   Ei[e][25]*=hb; // health bonus

}
switch (Ei[e][0])
{
   case 3: // archwagon
      na = Ei[e][3] = 34;  // new ans
      dl = Ei[e][30] = 20; // death_loop_wait; set delay
      Ei[e][24] = 929+(hb-1)*32; // shape
      Efi[e][11] = al_ftofix(1.08); // scale multiplier

if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);

done... enemy killed by field!

what does player damage from field look like??
player hit a mine

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(50, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
   }

make new game_event
game_event(58, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
customize the message by the draw type of the field
default = "was hurt by a damage field"
others "was hurt by a spiked floor"
I can get that info from the field number in the event...

done...

this is one of those that keep retriggering

in the retrigger code.. everytime one is skipped, tally the damage...



where can I check it?

something that happens every frame...
proc_frame_delay()

I need to do this for every player, don't I??

what if I keep track of that in the player struct?

damage tally, holdoff till display event...

or I could do a damage holdoff in the player...so that he doesn't take damage every frame...
enemies have a player damage holdoff built into them...
yes...once an enemy hurts any player, they cannot hurt any player for 60 frames...
this is kind naive, but it works good enough...


add something to struct player1, not synced....


float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;




done
in events

   if (ev == 57) // damage field raw
   {
      int p = z1;
      int e = z2;
      float damage = al_fixtof(Efi[z2][4]

      if (player1[p].field_damage_holdoff < mwPS.frame_num) // triggered and not in holdoff
      {
         player1[p].field_damage_holdoff = mwPS.frame_num + 20; // set holdoff
         player1[p].field_damage_tally = damage; // init tally with current damage
         ev = 0; // don't let this event do anything
      }

      if (player1[p].field_damage_holdoff > mwPS.frame_num) // triggered and in holdoff
      {
         player1[p].field_damage_tally += damage; // inc tally with current damage
         ev = 0; // don't let this event do anything
      }
   }

in void proc_player_health(int p)





These are the pieces that make this work:


added to struct player1 (not synced)

float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;

the event that draws:

if (ev == 58) // player took damage from a field
{
   custom_drawn = 1;
   int damage = (int) players1[z1].field_damage_tally;
   int e = players1[z1].field_damage_enemy_number;
   int type = Ei[e][19];

   if (type == 1) bmsg_length += bmsg_show_text(" was hurt by spikey floor ", 15, bmsg_length);
   else           bmsg_length += bmsg_show_text(" was hurt by a damage field ", 15, bmsg_length);
   bmsg_length += bmsg_show_health(-damage, bmsg_length);
}

the event that tallies:

if (ev == 57) // damage field raw
{
   int p = z1;
   int e = z2;
   float damage = al_fixtof(Efi[z2][4]);
   players1[p].field_damage_enemy_number = e;

   if (players1[p].field_damage_holdoff < mwPS.frame_num) // triggered and not in holdoff
   {
      players1[p].field_damage_holdoff = mwPS.frame_num + 20; // set holdoff
      players1[p].field_damage_tally = damage; // init tally with current damage
      ev = 0; // don't let this event do anything
   }

   if (players1[p].field_damage_holdoff > mwPS.frame_num) // triggered and in holdoff
   {
      players1[p].field_damage_tally += damage; // inc tally with current damage
      ev = 0; // don't let this event do anything
   }
}

where event 58 is triggered:

void proc_player_health(int p)
{
   if (players1[p].field_damage_holdoff == mwPS.frame_num) game_event(58, 0, 0, p, 0, 0, 0);

where event 57 is triggered:

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(57, 0, 0, x, e, 0, 0);
   }

It seems to be working...
make the sound effect happen on 57 so there is not delay...done...



huge idea here........

what if I seperate triggers and actions?


right now triggers and actions are a one to one relationship

what if it could be many to one, or one to many, or many to many?

the possibilites would increase exponentially.


how about for each field enemy....

add the ability to set the trigger to another field enemy

then it could look it up with flags

I will need to add a flag for toggle...
right now toggle is only calculated internally

I will need to make sure these damn links do not get broken when resorting

is that the only change I need? to make the trigger source able to be set to another field?
what if I want multiple triggers for one source?


what if I set input for each field and output for each trigger

then I can do:
many to one (input for each damage field) and
one to many (output for each trigger)...NO this will not work...just one to many





I would need some kind of event mapper from sources to actions

I think this is the way to go...it will be complicated but worth it

let try to plan this out:

create a link

create a event

named?

thingy till I get something better

when triggered set 'action 1'

action[1000]

if triggered set action[x] = 1;

then have a function to do the mapping

like

if (action[1]) action[23] = 1;

field enemies can have:
trigger action that they will set when triggered and damage action when they receive a trigger


the table of rules would look like

index action1 action2 proc
0       1      250    set
1       2      200    clear
2       4      100    toggle

the action list would be just one int, set or clear

fields could output three actions:
one for on/off
one for toggle (off to on)
one for toggle (on to off)

I would have to manually set these in the field trigger and the field damage
then I would need to create the links in the link table...

this sounds complicated...

all these events can be blank for now unless needed....

I am thinking of case when one field's timer ends and it triggers another field's timer to start....

like I said...complicated

triggers for trigger fields:

object in field
object just entered field
object just left field

number of objects in field > num
number of objects in field < num
number of objects in field == num

all these but only when they first occured
number of objects in field > num
number of objects in field < num
number of objects in field == num

triggers for damage fields
depends on type

inputs
none for always on and timed on and off
toggle would only get the ones when they first occured
timer modes would get the perstant ones

outputs
none for always on
for the other ones send a trigger when they change
and also have the ability to constantly send when on or off

I can also make a new thing that sets blocks on or off, based on triggers

after seeing all this, do you still want to proceed?

I think so...

Maybe I can make triggers items...but why, because I have lots of them...

I could make keys respond of actions, or send them..
I can make switches do the same..
Also I can make switches have an area of effect, like keys...

I also want to make blocks that stop bullet, or not, players, items, etc...

I think this action or event thing will be the heart of some great new things...

I need to plan it carefully...

each action will simply be an indexed entry in the action table.

int pm_event[1000][4];

pm_event[1000][0] - action ID
pm_event[1000][1] - clear, set, toggle off, toggle on (0, 1, 2, 3)
pm_event[1000][2] - type of initiator
pm_event[1000][3] - ID of initiator


the mapping table will look like this:

int pm_event_map[1000][3];

pm_event_map[1000][0] - source pm_event
pm_event_map[1000][1] - target pm_event
pm_event_map[1000][2] - action (0 = copy) others could be set->clear, clear->set ...

this looks like a good start...I'm scared of all this work...

when I implement this, don't kill the existing stuff...in case I give up and go back....


I want to start by cretaing an item called trigger

that looks a lot like the trigger part of field

what variables do I need?



// common

item[][0] = 9 active and type
item[][1] = bitmap or ans
item[][2] = draw type (not used)
item[][3] = (0=stat, 1=fall, -1=carry, -2=carry through door -3=sticky)
item[][4] = x pos (int) (2000)
item[][5] = y pos (int) (2000)

item[][6]  = trigger field x (2000)
item[][7]  = trigger field y (2000)
item[][8]  = trigger field w (2000)
item[][9]  = trigger field x (2000)

item[][10] = trigger field lift
item[][11] = trigger draw type


what do I still need places for?
mode
action_id
action_id type static|toggle

I can probably get rid of 1, 2, 3
use 3 for flags

item[][14] = time to live
item[][15] = tag with cloner item id


#define PM_ITEM_TRIGGER_PLAYER   0b0000000000000001
#define PM_ITEM_TRIGGER_ENEMY    0b0000000000000010
#define PM_ITEM_TRIGGER_ITEM     0b0000000000000100
#define PM_ITEM_TRIGGER_PBUL     0b0000000000001000
#define PM_ITEM_TRIGGER_EBUL     0b0000000000010000
#define PM_ITEM_TRIGGER_CURR     0b0000000000100000
#define PM_ITEM_TRIGGER_PREV     0b0000000001000000
#define PM_ITEM_TRIGGER_TGON     0b0000000010000000
#define PM_ITEM_TRIGGER_TGOF     0b0000000100000000
#define PM_ITEM_TRIGGER_LIFT_ON  0b0000001000000000
#define PM_ITEM_TRIGGER_LIFT_XC  0b0000010000000000
#define PM_ITEM_TRIGGER_LIFT_XF  0b0000100000000000
#define PM_ITEM_TRIGGER_LIFT_XL  0b0001000000000000
#define PM_ITEM_TRIGGER_LIFT_YC  0b0010000000000000
#define PM_ITEM_TRIGGER_LIFT_YF  0b0100000000000000
#define PM_ITEM_TRIGGER_LIFT_YL  0b1000000000000000


what number am I going to use 9


start making it so that the draw, move, collison code, etc all ignores type 9...


where do I patch it in?

what gets called every frame for items...move item


move_items()
if (item[i][0] == 9) process_trigger(i);
else

draw_items()
if (item[i][0] == 9)
{
    draw_trigger(i);
    drawn = 1;
}

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if ((item[x][0]) && (item[x][0] != 9))


hopefully that should do....

now make one of these....

should I make a creator...yes


I can create, I can run viewer...
display show the rectangle...

next...

fix the create making rectangle too small in lr...done
allow me to change the rectange with a button...done
and on the map...done
with legend and all that shit...done

what am I going to use for flags item[][3]

now attach to lift...done

implement the filters and do the collision detection




need to implement collison checks


the field enemy iterated all enemies in the collison detection...WTF!!!

void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies

         if (Ei[e][0] != 10) // skip all this for field
         {
             if (Ei[e][0] < 50) proc_enemy_collision_with_pbullet(e);

             // check for time to live
             int ttl = Ei[e][27];
             if (ttl)
             {
                if (ttl < 11)
                {
                   Ei[e][0] = 66;             // change to different type to prevent use
                   Efi[e][4] = al_itofix(0);  // cant hurt anymore
                   Ei[e][29] = 0;             // no collision box
                   int sq = 10-ttl;
                   Ei[e][1] = zz[5+sq][74];
                }
                if (ttl == 1) Ei[e][0] = 0; // kill instantly
                Ei[e][27]--;
             }

             // check for out of bounds
             if ((Efi[e][0] < al_itofix(0)) || (Efi[e][0] > al_itofix(1999))) Ei[e][0]=0;
             if ((Efi[e][1] < al_itofix(0)) || (Efi[e][1] > al_itofix(1999))) Ei[e][0]=0;
         }
         switch (Ei[e][0])
         {
            case 3:   enemy_archwagon(e);  break;
            case 4:   enemy_bouncer(e);  break;
            case 6:   enemy_cannon(e);  break;
            case 7:   enemy_podzilla(e);  break;
            case 8:   enemy_trakbot(e);  break;
            case 9:   enemy_cloner(e);  break;
            case 10:  enemy_field(e);  break;
            case 11:  enemy_block_walker(e);  break;
            case 12:  enemy_flapper(e);  break;


so enemy_field(e) is called once for each time 10 is found......

void enemy_field(int e)
{
   int mode = Ei[e][5];
   int trig_toggle = 0;

   Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_CURR;  // clear current trigger flag
   detect_field_collisions();
   if (Ei[e][3] & PM_ENEMY_FIELD_TRIG

which calls detect_field_collisions();

void detect_field_collisions(void)
{
   for (int e=0; e<100; e++)
      if (Ei[e][0] == 10)
      {
         int mode = Ei[e][5];
         int FLAGS = Ei[e][3];

which iterates all enemies................there...that is the WTF moment......
fix this later....









void process_trigger(int i)
{
   int FLAGS = item[i][3];
   if (FLAGS & PM_ITEM_TRIGGER_LIFT_ON) set_item_trigger_location_from_lift(i, 0);

   item[i][3] &= ~PM_ITEM_TRIGGER_TGON;  // clear Toggle ON  trigger flag
   item[i][3] &= ~PM_ITEM_TRIGGER_TGOF;  // clear Toggle OFF trigger flag
   item[i][3] &= ~PM_ITEM_TRIGGER_CURR;  // clear current    trigger flag

   detect_trigger_collisions(i);

   if ( (item[i][3] &  PM_ITEM_TRIGGER_CURR)    // is current trigger flag set?
   && (!(item[i][3] &  PM_ITEM_TRIGGER_PREV)))  // and previous trigger flag not set?
         item[i][3] |= PM_ITEM_TRIGGER_TGON;    // set trigger ON toggle


   if (!(item[i][3] &  PM_ITEM_TRIGGER_CURR)    // is current trigger flag not set?
   && ( (item[i][3] &  PM_ITEM_TRIGGER_PREV)))  // and previous trigger flag set?
         item[i][3] |= PM_ITEM_TRIGGER_TGOF;    // set trigger OFF toggle


   if   (item[i][3] &   PM_ITEM_TRIGGER_CURR)    // is current trigger flag set?
         item[i][3] |=  PM_ITEM_TRIGGER_PREV;    // set previous trigger flag

   if (!(item[i][3] &   PM_ITEM_TRIGGER_CURR))   // is current trigger flag not set?
         item[i][3] &= ~PM_ITEM_TRIGGER_PREV;    // clear previous trigger flag


   if (item[i][3] & PM_ITEM_TRIGGER_CURR) printf("%d - CURR\n", mwPS.frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_PREV) printf("%d - PREV\n", mwPS.frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_TGON) printf("%d - TGON\n", mwPS.frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_TGOF) printf("%d - TGOF\n", mwPS.frame_num);

   printf("\n");

}

this works exactly like I thought it would....




now I am thinking of 4 sliders:

ACTION send ON
ACTION send OFF
ACTION send TOGGLE ON
ACTION send TOGGLE OFF

each of which can be set to a number from 0-100 (or more)
if 0 they are disabled

right now I have all this done up to the point that I have 4 print statements where I would emit actions number some how

what next?

draw items still need to be implemented....


make something that accepts these?

make something that is triggered by these?


my action array can be nothing more than a singel row of ints


int act[100]

if I put 34 in like..

act[34] = 1;

then if anything is listening it will react...
after something reacts to it, that something should clear it...



then I can have one to many code there
if 34 then set 45, 46, 47 also

many to one can be achieved by setting multiple source to the same action #



the rule table is a double int...or triple

0   1
34  45

34 46

34 47

34 sets 45
45 clears 67


what if I made special items that did this?

source actions up to 4
34 45 33

main s1
an int before to say what affect

1 32 (must have 32)
0 44 (must not have 34)
2 or



target actions up to 4

34 67 88



this seems rather complicated

for now I would like to make a simple one

or modify one...


make a switch that take an action input

(am I calling it action? what about pm_event?)


20220330 8:30 PM



20220331 4:00AM

made a new shape for item trigger in level editor
made draw type work
changed creator defaults
re-arranged button and slider fuctions in sliders.cpp

I could make the draw type able to choose color for the grid

how many vars do I have left...lots...maybe later...

next is to create something that will accept a trigger

kind of like key and switch rolled into one...

'block manipulation' but come up with a better name....

strcpy (item_name[16],"Block Manip");

do all the same stuff as the other item to not draw it...etc...




where do I patch it in?

what gets called every frame for items...move item






move_items()
void move_items()
{
   for (int i=0; i<500; i++)
      if (item[i][0])
      {
         if      (item[i][0] == 9) process_trigger(i);
         else if (item[i][0] == 16) process_block_manip(i);
         else
         {

draw_items()
if (item[i][0] == 16)
{
    draw_block_manip(i);
    drawn = 1;
}

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if ((item[x][0]) && (item[x][0] != 9) && (item[x][0] != 16))



make a creator...done
make shape..done

viewer...done
map...done
buttons...


now how am I going to set this up?



item[][1] = pm_event_trigger

item[][2] = draw mode

item[][3] = mode




item[][10] block 1
item[][11] block 2

0 none
1 set all blocks to block1 (one time only)
2 change all block2 to block1 (one time only)
3 toggle block1 and block2


im at the point I need to create pm_event...


extern int pm_event[100];

where to clear it? in start level stuff...

I hooked in an event and it works!!! I am so excited!


got to go...

20220331 6:25 AM

at work...
20220331 8:20 AM

add sliders to trigger...done


this pm_event thing was very easy to implement, but the method I use is very naive..
problems:

one to many won't work because the receiver erases the pm_event
same with many to one??

what if I erase all events every loop, and not erase when received?
that could work...

then many input could read one output


I also have an issue of the ordering of things...right now input and output happen in any order...
depends on when each particular object is called..

If I erase at the start of every frame...an object could be listening for one that only occurs after it...
I don't have that problem with the other method...

I'm going to stick with this simple methods for now....
a solution could be special events the do the one to many or the many to one

clean up trigger obt viewer....done....

Set Events Always While On:
Set Events Always While Off:
Set Events When Switching On:
Set Events When Switching Off:

clean up Event Trigger in block manip...done...

make a nice block selection button...kind of like color select...
when you click it, you are prompted to select a block...done....

made the modes work...nice!!!

make block manip able to be hidden.....

make trigger and block manip draw modes able to be colored....

do trigger first then copy...
need a var for color...or use draw_mode...0 == hidden

color are implemented, but need to clean up in viewer...done


wow this shit looks good!!

what could I do to make it easier?

in viewer, show thing that have matching events....

in trigger, show block manip

in block manip, show triggers


where are they located?

sources:

trigger:
item[][11]
item[][12]
item[][13]
item[][14]

destinations:

block manip:
item[1]

what I did was...in bm show link to triggers

make copying and pasting linked thing easier

add the stuff to move the boxes in zfs copying
also in there if you find linked item when copying make a new link...this will be complicated..but not impossible...


now I really want to add another item called damage...just like the enemy...how many variables will I need?

I might just barely be able to squeeze it in....

item[][0]  = 17 - Block Damage
item[][1]  = event trigger
item[][2]  = damage draw type
item[][3]  = flags
item[][4]  = x pos (2000)
item[][5]  = y pos (2000)
item[][6]  = field x (2000)
item[][7]  = field y (2000)
item[][8]  = field w (2000)
item[][9]  = field x (2000)
item[][10] = lift number
item[][11] = mode
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val
item[][15] = damage




20220331 1:49

shut it down for a bit and do a push







20220331 5:00PM

make it so that when I move trigger and bm the box moves too...where is that????


in zfs
void save_selection(int save)

            if (item[b][0] == 4) // key
            {   // set new destination
               ft_item[c][6] = item[b][6] - stx;
               ft_item[c][7] = item[b][7] - sty;
               ft_item[c][8] = item[b][8] - stx;
               ft_item[c][9] = item[b][9] - sty;
            }


            if (item[b][0] == 9) // trigger
            {   // set new destination
               ft_item[c][6] = item[b][6] - stx*20;
               ft_item[c][7] = item[b][7] - sty*20;
            }



in

void do_fcopy(int qx1, int qy1)
{

                  if (item[c][0] == 9) // // move trigger rect
                  {
                     // apply offsets
                     item[c][6] += qx1*20;
                     item[c][7] += qy1*20;

                     //item[c][8] += qx1;
                     //item[c][9] += qy1;
/*
                     if (erase_out_of_bounds_secondary)
                     {
                        if (check_limit(item[c][6], 0, 99)) lim = 1;
                        if (check_limit(item[c][7], 0, 99)) lim = 1;
                        if (check_limit(item[c][8], 0, 99)) lim = 1;
                        if (check_limit(item[c][9], 0, 99)) lim = 1;
                     }
                     else // adjust if out of bounds
                     {
                        item[c][6] = enforce_limit(item[c][6], 0, 99);
                        item[c][7] = enforce_limit(item[c][7], 0, 99);
                        item[c][8] = enforce_limit(item[c][8], 0, 99);
                        item[c][9] = enforce_limit(item[c][9], 0, 99);
                     }
*/

                  }
i really should do some boundary checks...

now for the regular move from draw item...



               if (item[draw_item_num][0] == 9) // trigger
                  //if (al_show_native_message_box(display, "Move?", "Move the range also?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
                  {
                     item[c][6] = item[draw_item_num][6] + (x100*20) - item[draw_item_num][4]; // move x
                     item[c][7] = item[draw_item_num][7] + (y100*20) - item[draw_item_num][5];
                  }

               if (item[draw_item_num][0] == 16) // block manip
                  //if (al_show_native_message_box(display, "Move?", "Move the range also?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
                  {
                     item[c][6] = item[draw_item_num][6] + (x100*20) - item[draw_item_num][4]; // move x
                     item[c][7] = item[draw_item_num][7] + (y100*20) - item[draw_item_num][5];
                  }




this is all good now...
copying trigger and bm now move range relative to main item...


now can I do something magic about the links?

should I start making the damage item?

lots of it would be just copied from field enemy


make a creator...done
patch draw...done
patch move...done
player collision...done

title obj...done
map move...done

zfs copy...done
draw item copy...done

drawing mode...done
lift mode...done

next is mode and timers...

event slider...done

implement the flags for damage...slider done
do collisions.....done

current damage button...done

for player damage add a flag to make it instant death.....

sliders for timers...done
ttl is showing for bd...made code to ignore items 9, 16, 17...done

finish modes...done

do drawing timer counts....done...
I have no variables left...make 2 flags for 4 combos..what about off?
the less complicated way would be to use 4 flags, one for each...

#define PM_ITEM_DAMAGE_TIMR_SN  0b00010000000000000
#define PM_ITEM_DAMAGE_TIMR_BN  0b00100000000000000
#define PM_ITEM_DAMAGE_TIMR_SP  0b01000000000000000
#define PM_ITEM_DAMAGE_TIMR_BP  0b10000000000000000

made button and implemented....done

seems like all this is working...

still to do...

add player instant death option...flag and button...

make the viewer menu look good.....


20220401 6:20 AM  push....

10:30 AM

back...

add get new box button...


fix the bitmap shown for draw item and in viewers.........





Draw Trigger Field:ON
Draw Trigger Field:OFF
Trigger Field Color

Draw Block Manip Field:ON
Draw Block Manip Field:OFF
Block Manip Field Color


Damage Field Draw Type:

Draw Block Damage Field:OFF
Block Damage Field Color

timer display could have a divide by zero error
also set some times in creator

...need to prevent this...


I would like to set key to use the same block standard as trig, manip, damage
0-1999
x, y, w, h
then so much of the code can be re-used
also cloner and podzilla??

OK the viewer menus look pretty good now....

make sure you can't divide by zero when doing calcs before calling percent...done

fix the bitmap shown for draw item and in viewers...done


add player instant death option...flag and button...done

hook into game_event...done


figure out values for player damage....
now 0-99 / 100

(good at low range, needs more damege at high range)
at lowest (1) lose 1 health every 2 sec
at highest (99) lose 100 in 3 sec

try 0-1000 / 100
at 1000 running through a single block as fast as you can takes 50 health

lets go with 2000
when jumping up through a single block...20?
when jumping up on the fastest sproingy, you can easily go right through it witout getting hit...
that's just because you are moving so fast...nothing to do, just accept it...

make text line up on
player instant death 403
player damage 98
line up with all the affect lines...421-424
.............done....


what about the link lines when link is zero?
only on block manip is it shown...
fix it and make it work for block damage also...
what about trigger??

make a helper function...
pass it current item and have it show links...done


what if a make a button...create link...if I press it then I am prompted to choose an item to link to...

when I do it will search and make choose a unique event id to use...
as I am moving around the map to choose, it will show stuff about the items I am trying to link to...


make a function to find an unused pm_event.

search all items

how many?

100? changed to 1000

int get_unused_pm_event(void)
{
   int ev = 1; // don't ever use event 0
   int done = 0;
   while (!done)
   {
      int used = 0;
      for (int i=0; i<500; i++)
      {
         if (item[i][0] == 9)
         {
            if (item[i][11] == ev) used = 1;
            if (item[i][12] == ev) used = 1;
            if (item[i][13] == ev) used = 1;
            if (item[i][14] == ev) used = 1;
         }
         if ((item[i][0] == 16) && (item[i][1] == ev)) used = 1;
         if ((item[i][0] == 17) && (item[i][1] == ev)) used = 1;
      }
      if (!used) return ev;
      else if (++ev > 999) done = 1;
   }
   return 0; // only if no unused can be found
}


in zfs copy...only for items 16 and 17

if 16 or 17...

if exactly one linked item...and its a trigger...
make both items have a new unique link

give up...will not work...



how about the button on manip

right under link...
choose linked item....

there is some great code I can copy in door that does something very similar...

      if (bn == 4)
      {
         if (item[num][8] == 1) // Set Linked Item
         {
             int i = get_item("Select Another Door To Link To", 2, 1, num );
             if (i > -1) item[num][9] = i;
             Redraw = 1;
         }
      }



      if (bn == 320)
      {
         {
             int i = get_trigger_item("Select A Trigger To Link To", 2, 9, num );
             if (i > -1) item[num][1] = i;
             Redraw = 1;
         }
      }

I got it to work....


int get_trigger_item(const char *txt, int obj_type, int sub_type, int num )
{
   int itx, ity, dx, dy;
   int mouse_on_item = 0;
   int quit = 0;
   int ret_item = -1;

   while (mouse_b1) proc_controllers();      // wait for release

   int x2 = item[num][4]/20; // get the original item position
   int y2 = item[num][5]/20;




   while(!quit)
   {
      // show text line
      al_draw_text(font, mC.pc[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, mC.pc[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "with left mouse button");
      al_draw_text(font, mC.pc[14], txc, 120, ALLEGRO_ALIGN_CENTER, "Cancel");
      al_draw_text(font, mC.pc[9],  txc, 128, ALLEGRO_ALIGN_CENTER, "with right mouse button");

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));
      title_obj(obj_type, sub_type, num, 0, 15);

      proc_controllers();

      dx = mI.mouse_x/db;
      dy = mI.mouse_y/db;

      draw_bs(14);      // show bullseye map

      mouse_on_item = 0;

      if ((dx<100) && (dy<100))      // if mouse on map
         for (int x=0; x<500; x++)
            if (item[x][0] == 9)    // trigger only
            {
               itx = item[x][4]/20;
               ity = item[x][5]/20;
               if ((dx == itx) && (dy == ity))
               {
                  mouse_on_item = 1;
                  ret_item = x;
               }
            }

      itx = item[ret_item][4]/20;
      ity = item[ret_item][5]/20;

      crosshairs(0, 0, x2, y2, 13); // draw the original position
      if (mouse_on_item)
      {
         crosshairs(0, 0, itx, ity, 14); // draw the selected item position
         int o = db/2;
         al_draw_line(x2*db+o, y2*db+o, itx*db+o, ity*db+o, mC.pc[14], 1);
         al_draw_textf(font, mC.pc[15], txc, 180, ALLEGRO_ALIGN_CENTER, " Item:%d ", ret_item);
      }
      else
      {
         find_and_show_event_links(num); // assume for now that this just gets called with item type 16 and 17
      }






      while (mouse_b1)
      {
         proc_controllers();
         quit = 1;
      }
      while ((mouse_b2) || (mI.key[ALLEGRO_KEY_ESCAPE]))
      {
         proc_controllers();
         quit =1;
         ret_item = -1;
      }
   } // end of while(!quit);
   if (!mouse_on_item) ret_item = -1;
   return ret_item;
}



if (bn == 320)
{
   int i = get_trigger_item("Select A Trigger To Link To", 2, 16, num );
   if (i > -1)
   {
      int ev = get_unused_pm_event();
      item[num][1] = ev;

      // which trigger should I link to? for now just pick 11, but later detect if I need to use toggle
      item[i][11] = ev;
   }
   Redraw = 1;
}


now I want to be able to pick the right trigger....


in bm if mode 3 then toggle

if item[][0] == 16) && item[][3] == 3 //toggle


      if (bn == 320)
      {
         int i = get_trigger_item("Select A Trigger To Link To", 2, 16, num );
         if (i > -1)
         {
            int ev = get_unused_pm_event();
            item[num][1] = ev;

            if (item[num][3] == 3) // mode 3 - toggle blocks
            {
               item[i][11] = 0;
               item[i][12] = 0;
               item[i][13] = ev;  // needs a toggle trigger
               item[i][14] = 0;
            }
            else
            {
               item[i][11] = ev;  // regular trigger
               item[i][12] = 0;
               item[i][13] = 0;
               item[i][14] = 0;
            }
         }
         Redraw = 1;
      }

even better....
now do the same for bd
if item[][0] == 17) && item[][11] == 1 //toggle
done...


its working good.....

im tired and need to go to bed...

20220401 9:21PM

make some things to show off the new stuff...


the floor that keeps growing as you get to the end

a spikey floor that is damaging if you don't keep jumping


a room that you can't exit until all enemies in the room are killed


I really want to have the copy paste thing make new links...

before the paste happens...

iterate everything that is going to be pasted....

if there any items that have links, put them in a list...

like...

int copy_link_tranform[500][4]

0 - source item number
1 - source item var
2 - source item ev
3 - new ev number



then after filling the list...
iterate the list
- find ev number
- does it exist in destination item array?
- if yes find new empty and set in dest
- iterate the rest of the list and see if any more are found with same source ev
- set then also

then when copying use the new number...

I need a place to put pm_event related funtions...
I like e_fnx....

lets do that...
then make a new funtion that determines in an event is used...

all the fucntions are now in e_fnx....

made these....

int is_pm_event_used(int ev)
{
   for (int i=0; i<500; i++)
   {
      if (item[i][0] == 9)
      {
         if (item[i][11] == ev) return 1;
         if (item[i][12] == ev) return 1;
         if (item[i][13] == ev) return 1;
         if (item[i][14] == ev) return 1;
      }
      if ((item[i][0] == 16) && (item[i][1] == ev)) return 1;
      if ((item[i][0] == 17) && (item[i][1] == ev)) return 1;
   }
   return 0;
}

int get_unused_pm_event(void)
{
   int ev = 1; // don't ever use event 0
   int done = 0;
   while (!done)
   {
      if (!is_pm_event_used(ev)) return ev;
      else if (++ev > 999) done = 1;
   }
   return 0; // only if no unused can be found
}



made int copy_link_tranform[500][4] global...
I have a few function that I want to manip it...

wait a tick...do I need to make it global? can I just pass the array ref to the calling function?
lets try it....

here is how to do it:

pass it like this clt
in function that gets it use clt[][4]

this is what I have so far...


// this section is to make any copied pm_event links have new unique pm_events and still linked properly
int clt[500][4] = { 0 };
int clt_last = 0; // index

for (b=0; b<500; b++)       // iterate items in selection
{
   if ((ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // manip or block
   {
      clt_last += add_item_link_translation(b, 1, ft_item[b][1], clt, clt_last);
   }

   if (item[b][0] == 9) // trigger
   {
      clt_last += add_item_link_translation(b, 11, ft_item[b][11], clt, clt_last);
      clt_last += add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
      clt_last += add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
      clt_last += add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
   }
}

int add_item_link_translation(int sel_item_num, int sel_item_var, int sel_item_ev, int clt[][4], int clt_last)
{
   if (sel_item_ev)
   {
      // check if this event already has a translation and get it if it does
      int ev2 = check_clt_for_event(sel_item_ev, clt, clt_last);

      if (ev2) // existing translation found
      {
         clt[clt_last][0] = sel_item_num;   // item # in selection
         clt[clt_last][1] = sel_item_var;   // item var #
         clt[clt_last][2] = sel_item_ev;    // original link
         clt[clt_last][3] = ev2; // new link

         printf("et %d %d %d %d\n", clt[clt_last][0], clt[clt_last][1], clt[clt_last][2], clt[clt_last][3]);

      }
      else // no existing translation found
      {
         ev2 = get_unused_pm_event_extended(clt, clt_last);
         clt[clt_last][0] = sel_item_num;   // item # in selection
         clt[clt_last][1] = sel_item_var;   // item var #
         clt[clt_last][2] = sel_item_ev;    // original link
         clt[clt_last][3] = ev2; // new link
         printf("ne %d %d %d %d\n", clt[clt_last][0], clt[clt_last][1], clt[clt_last][2], clt[clt_last][3]);
      }
   }
   else return 0; // nothing added
   return 1; // added
}



// does this copy item have an entry in the clt table?
for (int i=0; i<clt_last; i++)
   if (clt[i][0] == b) // found index of source item table
   {
      int var_index = clt[i][1]; // var #
      int ev2 = clt[1][3];       // new ev

      item[c][var_index] = ev2;
   }


I am missing an important step.....

the link translation table is being correctly built....

but when I go to appy it, all i have is the link to to sel_item...I need the link to the dest item...
need to add it to array... then set it when copying from sel to dest...
belay that...when I am doing it already, I have both source and dest...should work fine...(now that I fixed a bug!)
yup, it seems to work fine...

for the first set...

then the triggers don't seem to copy nice after that...they stick with the copy items...

it works fine when copying everything...found the bug!!!

back to making some really cool demo levels....

a spikey floor that is damaging if you don't keep jumping

bug, can set timer for bd but slider does not update....
104 and 103...fixed

bug instant death(403) affects timer draw mode(401)
same flag define!!



I made a really cool level...

Level 58

- floor that grows when you get to the end... or shoot bullet across it
- room that locks you in when you enter
- room that you need to kill all enemies before the wall will open
- spikey floor that retracts on a timer when you trigger it
- room that you are locked in until you lead an enemy into an area

This is really cool looking... This level is done...
Next, I will make more cool stuff, like....

Block toggle puzzle


bug if you escape out of block select it dies badly.....fixed

rectangle_with_diagonal_lines(x1, y1, x2, y2, 10, col, col+96);
draws 1 pixel up and to the left......fixed by adjusting the clipping rectangle

I want to check collisions, especially bullets...
there is one spot.....
when facing right and shooting up x=26 does not hit either block
when facing left  and shooting up x=93 does not hit either block
when shooting left and right y=49 does not hit either block
I think 1 pixel is close enough

i want to make bombs bigger than 800...lets try 1200...nice....

what else can I do to show off the new stuff?










can I do my own effect of a coing spinning...like logo...?


extend bonus item to include the new coins...


I could make key just emit event...then it would not draw nice...maybe I could...


pm_event logic...


make an item that does nothing but acts as a switch point for pm_events

have a group of AND inputs, OR INPUTS

and one on more outputs

how will it handle toggles?
will it erase pm_events every frame?
yes, if it uses or looks at them

right now I can't have a trigger affect muliple things because when it is used, it is deleted
right now I can have multiple trigger affecting the same thing, but...
one might overide the other
- toggle bad
- reset damage timer, ok


make a trigger item...count...
number of enemies > num
number of enemies < num
same for items and players





extend bonus to also include free man and coins....
maybe I can do my own rotate, like with logo...later


[2] - bonus

item[][6] bonus type
1 = health
2 = free man
3 = purple coin

item[][7] health bonus
item[][8] bullet bonus (ignored now)
item[][9] timer bonus  (ignored now)

now I need to run glt and set all bonus type 2 to have 6 = 1...
I have 330 bonus types and all have 7 set and nothing for 8 and 9...

set all to have type = 1...

fix in PDE...done


fix when flowers and diamonds are created....
at the very end of enemy death...done

now add free man...

all that matters is

item[][6] bonus type = 2

old:
item[][0] = 6
item[][1] = 1038
item[][2] = 1
item[][3] = 1

new:
item[][0] = 2
item[][1] = 1038
item[][2] = 1
item[][3] = 1
item[][6] = 2

done in PDE...

now do in glt...done, there are no item 6 any more...

where in code should I kill it...
item text in menu...

in e_items  remove 6 from testing good...

in z_items  removed:

//  if (c ==  6) sprintf(msg, "%d Free Men    ", item_num_of_type[c]);

void proc_freeman_collision(int p, int i)
{
   item[i][0] = 0;
   players[p].LIVES++;
   game_event(70, 0, 0, p, i, 0, 0);
}

case 6:  proc_freeman_collision(p, i);  break;

make purple coin...

new:
item[][0] = 2
item[][1] = 192
item[][2] = 0
item[][3] = 1
item[][6] = 3

OK it is done...I can easily add one to level and there is code to touch it...later patch in something usefull....

now I want to make key have the same type of field as 9, 16, 17....

this is a huge task....

6:42 AM

find the one place where the key removes blocks...done

void move_items()
{
   for (int i=0; i<500; i++)
      if (item[i][0])
      {

               if (item[i][11] == 0)
               {
                  // remove the key
                  item[i][0] = 0;
                  if (item[i][12]) // matching keyed blocks only
                  {
                     int key = item[i][1] - 1039;
                     for (int x = item[i][6]; x <= item[i][8]; x++)
                        for (int y = item[i][7]; y <= item[i][9]; y++)
                           if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
                              remove_block(x, y);
                  }
                  else // remove all blocks in range
                  {
                     for (int x = item[i][6]; x <= item[i][8]; x++)
                        for (int y = item[i][7]; y <= item[i][9]; y++)
                           remove_block(x, y);
                  }





key creator.....

         item[c][6] = bx1*20;
         item[c][7] = by1*20;
         item[c][8] = (bx2-bx1)*20;
         item[c][9] = (by2-by1)*20;

/*       item[c][6] = bx1;
         item[c][7] = by1;
         item[c][8] = bx2;
         item[c][9] = by2; */



create and test...does not work...
i think move key puts it off screen then it dies....

void proc_key_collision(int p, int i)
{
   if (item[i][11] == 0) // only collide if not already moving
   {

//      int x2 = (item[i][6] + item[i][8]) * 10;         // get the center of the block range
//      int y2 = (item[i][7] + item[i][9]) * 10;
      int x2 = (item[i][6] + item[i][8] / 2);         // get the center of the block range
      int y2 = (item[i][7] + item[i][9] / 2);

now it works!!!!

show in obj viewer nicely.....

            int x2 = item[num][6]/20 * db;
            int y2 = item[num][7]/20 * db;
            int x3 = x2 + (item[num][8]/20 + 1) * db;
            int y3 = y2 + (item[num][9]/20 + 1) * db;;
            int x4 = (x2+x3)/2;
            int y4 = (y2+y3)/2;


/*            int x2 = item[num][6] * db;
            int y2 = item[num][7] * db;
            int x3 = item[num][8] * db + db - 1;
            int y3 = item[num][9] * db + db - 1;;
            int x4 = (x2+x3)/2;
            int y4 = (y2+y3)/2; */



now map move thinks its one smaller than it is....
leave map move and fix the others....
just fix it
when creating save one bigger...done...now the only thing is to fix the block killer...done....


I think this all works now...


// remove the key
item[i][0] = 0;
if (item[i][12]) // matching keyed blocks only
{
   int key = item[i][1] - 1039;
   int x1 = item[i][6] / 20;
   int y1 = item[i][7] / 20;
   int x2 = (item[i][6] + item[i][8]) / 20;
   int y2 = (item[i][7] + item[i][9]) / 20;
   for (int x = x1; x < x2; x++)
      for (int y = y1; y < y2; y++)
         if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
            remove_block(x, y);
/*                     for (int x = item[i][6]; x <= item[i][8]; x++)
      for (int y = item[i][7]; y <= item[i][9]; y++)
         if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
            remove_block(x, y); */
}
else // remove all blocks in range
{
   int x1 = item[i][6] / 20;
   int y1 = item[i][7] / 20;
   int x2 = (item[i][6] + item[i][8]) / 20;
   int y2 = (item[i][7] + item[i][9]) / 20;
   for (int x = x1; x < x2; x++)
      for (int y = y1; y < y2; y++)
         remove_block(x, y);
/*                     for (int x = item[i][6]; x <= item[i][8]; x++)
      for (int y = item[i][7]; y <= item[i][9]; y++)
         remove_block(x, y); */
}

// creator
item[c][6] = bx1*20;
item[c][7] = by1*20;
item[c][8] = (bx2-bx1+1)*20;
item[c][9] = (by2-by1+1)*20;
/* item[c][6] = bx1;
item[c][7] = by1;
item[c][8] = bx2;
item[c][9] = by2; */

// title obj (same as 9, 17, 17)
int x2 = item[num][6]/20 * db;
int y2 = item[num][7]/20 * db;
int x3 = x2 + item[num][8]/20 * db - 1;
int y3 = y2 + item[num][9]/20 * db - 1;;
int x4 = (x2+x3)/2;
int y4 = (y2+y3)/2;


/*            int x2 = item[num][6] * db;
int y2 = item[num][7] * db;
int x3 = item[num][8] * db + db - 1;
int y3 = item[num][9] * db + db - 1;;
int x4 = (x2+x3)/2;
int y4 = (y2+y3)/2; */

map move is now the same as 9, 16, 17


am I ready to change all keys in glt????
test on level 62 only...

make a backup of the level folder...

do I have any new style keys?  kill them...done...

lets do glt on everything.....did 430 keys...test....seems to work

7:52 that only took 1:10...


I want a trigger draw type that obviously looks like you can shoot it

see if I can amke shapes for bonus look like they are rotating....
I'm thinking of using scale and flip...

do it for purple coins...


I have it done....

can I make it a nice function?

what do I need:

tile number
x and y ul corner
0 0 20 20 inputs

over all scale of output
how dim the back side is
how fast to turn



void spin_shape(int tn, int x, int y, int tsx, int tsy, int tsw, int tsh, float scale, float dim, int cycle)
{
   int cti = cycle; // how many frame a full spin takes

   float ct = (int)cti; //cycle time
   float ct1 = ct/4;    // 20
   float ct2 = ct/2;    // 40
   float ct3 = ct1*3;   // 60
   float ct4 = ct;      // 80

   int tm = mwPS.frame_num % cti; // get a number from 0 to cti than increments every frame

   float tmr = (int) tm;

   float xs = 0;
   int flags = 0;


   // 80-60 = narrow to wide xs = 0 to 20 regular draw
   // 60-40 = wide to narrow xs = 20 to 0 regular draw

   // 40    = narrowest      xs = 0       flip draw from regular to reverse

   // 40-20 = narrow to wide xs = 0 to 20 reverse draw
   // 20-0  = wide to narrow xs = 20 to 0 reverse draw

   // 0     = narrowest      xs = 0       flip draw from reverse to regular


   if (tmr > ct2)
   {
      if (tmr>ct3) xs = ct4-tmr;  // 80-60 ---> 0-20
      else         xs = tmr-ct2;  // 60-40 ---> 20-0
   }
   else
   {
      if (tmr>ct1) xs = ct2-tmr;    // 40-20 ---> 0-20
      else xs = tmr;                // 20-0  ---> 20-0
      flags |= ALLEGRO_FLIP_HORIZONTAL;
   }

   // scale xs (if ct == 80 scale = 1)
   // or more accurately full width of tile (20) * 4
   float xscale = (tsw*4)/ct;
   xs *= xscale;

   float ys=tsh; // y scale is the same as the source height of the tile


   // optionally scale the entire thing
   xs *= scale;
   ys *= scale;

   // get draw offsets based on scale of final tile
   int xo = 10 - (xs/2); // x offset
   int yo = 10 - (ys/2); // x offset

   ALLEGRO_COLOR c2 = al_map_rgba_f(dim, dim, dim, 1.0); // show dimmer on back side

   if (flags == 0) al_draw_scaled_bitmap(       tile[tn],     tsx, tsy, tsw, tsh, x+xo, y+yo, xs, ys, flags);
   else            al_draw_tinted_scaled_bitmap(tile[tn], c2, tsx, tsy, tsw, tsh, x+xo, y+yo, xs, ys, flags);

}





in view object for does blast radius only show discreet (20) values?
this is how its drawn in title obj:
int bs = (item[num][7] / 20) * db;
what if i did this?
int bs = (item[num][7] * db) / 20;
that seems to have fixed it...



just for shits and giggles, how are pods trigger, cloners trigger source and set stored....

all are 0-99
only source and dest use w and h

pod
Ei[][11] = trigger box x1
Ei[][12] = trigger box x1
Ei[][13] = trigger box x2
Ei[][14] = trigger box y2

cloner
Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2

Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height

why doesn't cannon have a prox for bullet firing?

make circles have adjustments in map move...
only when that object is active...


try it for bomb...done for bomb and rocket.....






I have this idea for the tiles. Or more for the level array l[100][100].

I want to store more info in the ints that make up the array.


Right now I use special indexes to tell what kind of block it is.
I make no distinction between level drawing blocks and ones uses to draw items and enemies.

0-31  empty blocks
32-63 semi solid

>63 are full solid

64-95  bombable
96-127 breakable

I also have rope and ladder shapes that are empty, but have special properties...

What I want to do is use some of the higher bits for flags that implement these properties

the way I check if a block is solid right now is simply is:
if (tile>63)

the way I propose to do it is:
if (tile & PM_TILE_SOLID)

to get the actual tile index, I would just strip off the higher bits

right now I use 1024 tiles or 2^10 10 bits, that leaves 22

right now in level editor, I only show a subset of these blocks in the selection window

when loading I use swbl or somthing like that to determine which ones are in that group

I could do something similar to tag all the tiles when loading level editor

then fropm that point, once a blcock was placed in the level, it would have those flags..

they could be manipulated after being placed, like if I wanted to make a normally solid
block act as if it was empty to make a secret

then in the drawing code...

lets make some flags:


PM_TILE_SOLID_PLAY
PM_TILE_SOLID_ENMY
PM_TILE_SOLID_ITEM
PM_TILE_SOLID_EBUL
PM_TILE_SOLID_PBUL

PM_TILE_SEMISOLID_PLAY
PM_TILE_SEMISOLID_ENMY
PM_TILE_SEMISOLID_ITEM

PM_TILE_SOLID_EBUL
PM_TILE_SOLID_PBUL

PM_TILE_BOMBABLE

PM_TILE_BREAKABLE_PBUL
PM_TILE_BREAKABLE_EBUL

PM_TILE_LADDER_MOVE
PM_TILE_ROPE_MOVE

PM_TILE_SECRET (when touched by player it shows empty)

PM_TILE_SHOW_IN_SELECTION_WINDOW


Wow, I've used 16 already

I'm sure I'll think of others...

make a function to apply these to the entire tileset

view attributes in bitmap thingy....

Should I go even further and put block tiles in their own bmp file?

It would require a huge re-write....
block_tiles...
I can leave the main one (tiles)

and migrate all blocks to the new one...I can even keep the same positions to make migration easier...

step 1 - make a copy and rename it block_tiles...done

step 2 - load it and store it just like tiles..

step 3 - change all block tile drawing to use the new one...

added to main

ALLEGRO_BITMAP *tilemap = NULL;
ALLEGRO_BITMAP *btilemap = NULL;  <-------
ALLEGRO_BITMAP *ptilemap = NULL;
ALLEGRO_BITMAP *dtilemap = NULL;
ALLEGRO_BITMAP *M_tilemap = NULL;
ALLEGRO_BITMAP *M_btilemap = NULL; <-------
ALLEGRO_BITMAP *M_ptilemap = NULL;
ALLEGRO_BITMAP *M_dtilemap = NULL;

ALLEGRO_BITMAP *tile[NUM_SPRITES] = {NULL};
ALLEGRO_BITMAP *btile[NUM_SPRITES] = {NULL}; <-------


called from setup in main..





void create_bmp(void)
{
   // create tilemap bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);
   tilemap = al_create_bitmap(640, 640);
   btilemap = al_create_bitmap(640, 640);   <------------------
   ptilemap = al_create_bitmap(480,320);
   dtilemap = al_create_bitmap(160,640);
//   printf("tilemap\n");
//   show_pixel_format(al_get_bitmap_format(tilemap));
//   show_bitmap_flags(al_get_bitmap_flags(tilemap));


   // create memory bitmaps as temp storage for restoring tilemaps after screen change
   al_set_new_bitmap_flags(ALLEGRO_MEMORY_BITMAP);
   M_tilemap = al_create_bitmap(640,640);
   M_btilemap = al_create_bitmap(640,640);  <------------------
   M_ptilemap = al_create_bitmap(480,320);
   M_dtilemap = al_create_bitmap(160,640);
//   printf("M_tilemap\n");
//   show_pixel_format(al_get_bitmap_format(M_tilemap));
//   show_bitmap_flags(al_get_bitmap_flags(M_tilemap));



int load_tiles(void)
{
   int load_error = 0;

   // get main tiles
   tilemap = al_load_bitmap("bitmaps/tiles.bmp");
   if (!tilemap)
   {
      m_err("Can't load tiles from bitmaps/tiles.bmp");
      load_error = 1;
   }
   else
   {
      //printf("load good\n");
      al_convert_mask_to_alpha(tilemap, al_map_rgb(0, 0, 0)) ;
      al_set_target_bitmap(M_tilemap);
      al_draw_bitmap(tilemap, 0, 0, 0);
      for (int y=0; y<32; y++)
         for (int x=0; x<32; x++)
            tile[y*32 + x] = al_create_sub_bitmap(tilemap, x*20, y*20, 20, 20);
   }


void rebuild_bitmaps(void)
{
   //printf("rebuild bitmaps\n");

   // rebuild main tiles
   al_set_target_bitmap(tilemap);
   al_draw_bitmap(M_tilemap, 0, 0, 0);

   // rebuild block tiles
   al_set_target_bitmap(btilemap);
   al_draw_bitmap(M_btilemap, 0, 0, 0);

   // rebuild player tiles
   al_set_target_bitmap(ptilemap);
   al_draw_bitmap(M_ptilemap, 0, 0, 0);


use them to draw levelbackground.....

void init_level_background(void) // fill level_background with blocks and lift lines
{
   //printf("init_level_background\n");
   al_set_target_bitmap(level_background);
   al_clear_to_color(al_map_rgb(0,0,0));
   for (int x=0; x<100; x++)
      for (int y=0; y<100; y++)
      {
         int c = l[x][y];
         if (c < NUM_SPRITES)
            al_draw_bitmap(btile[c], x*20, y*20, 0);  <---------------
      }
   draw_lift_lines();
}


make a backup copy of tiles.bmp
draw all over blocks in original...
looks like they are working.....


use glt to find out what blocks are being used in what levels....


block:0 count:748538
block:7 count:459
block:8 count:493
block:9 count:145
block:10 count:234
block:11 count:47
block:12 count:38
block:13 count:4
block:14 count:133
block:15 count:37
block:16 count:112
block:17 count:4
block:18 count:883
block:19 count:706
block:32 count:3280
block:33 count:274
block:34 count:461
block:35 count:312
block:36 count:22
block:37 count:122
block:38 count:21
block:39 count:2
block:64 count:7265
block:65 count:71
block:66 count:141
block:96 count:10292
block:97 count:20
block:98 count:20
block:99 count:213
block:100 count:231
block:128 count:5808
block:129 count:5547
block:130 count:633
block:132 count:126
block:133 count:819
block:134 count:3695
block:135 count:1911
block:136 count:250
block:137 count:863
block:138 count:5568
block:139 count:3843
block:140 count:8389
block:141 count:7421
block:142 count:4715
block:143 count:2918
block:160 count:56
block:161 count:15
block:162 count:69
block:163 count:15
block:164 count:764
block:166 count:3309
block:172 count:249
block:173 count:486
block:174 count:411
block:175 count:361
block:177 count:946
block:178 count:5300
block:179 count:762
block:188 count:102
block:189 count:59
block:190 count:44
block:191 count:17
block:204 count:126
block:205 count:48
block:206 count:29
block:207 count:50
block:220 count:768
block:221 count:698
block:222 count:328
block:223 count:1134
block:576 count:680
block:577 count:683
block:578 count:717
block:579 count:719
block:580 count:12954
block:581 count:8
block:582 count:16830
block:584 count:243
block:585 count:116
block:586 count:240
block:587 count:146
block:588 count:250
block:589 count:124
block:590 count:260
block:591 count:221
block:592 count:92
block:608 count:136
block:609 count:108
block:610 count:110
block:611 count:138
block:612 count:2113
block:614 count:2294
block:616 count:44
block:617 count:40
block:618 count:41
block:619 count:51
block:620 count:79
block:621 count:37
block:622 count:80
block:623 count:57
block:624 count:49
block:625 count:77
block:640 count:40
block:641 count:54
block:642 count:41
block:643 count:41
block:644 count:258
block:645 count:257
block:646 count:543
block:647 count:490
block:656 count:2587
block:672 count:176
block:673 count:182
block:674 count:182
block:675 count:186
block:676 count:371
block:677 count:354
block:678 count:345
block:679 count:359
block:704 count:145
block:705 count:137
block:706 count:144
block:707 count:139

123 unique blocks

If I move some around in my new tile thingy, I will need to do glt for the translation...


what is next?

make level_editor selection thing use the new btiles...

selection window draws itself....

int process_select_window(int draw_only)


   // blocks top bar frame and text
   if (select_window_block_on)
   {
      al_draw_filled_rectangle(swx1, syb, swx2, syb+12, mC.pc[9+192]);
      al_draw_rectangle(       swx1, syb, swx2, syb+12, mC.pc[9], 1);
      al_draw_text(font, mC.pc[9], swx1+2,  syb+2, 0, "Block Selection ");
      al_draw_text(font, mC.pc[9], swx2-9,  syb+2, 0, "X");
      al_draw_text(font, mC.pc[9], swx2-25, syb+2, 0, "-");
      al_draw_text(font, mC.pc[9], swx2-41, syb+2, 0, "+");

      for (c=0; c<16*swnbl_cur; c++)
         al_draw_bitmap(btile[swbl[c][0]], swx1+(c-((c/16)*16) )*20+1, swy1+select_window_block_y+1+14+(c/16*20), 0 );   <-----------------
   }


now draw item and point item....



void show_draw_item_cursor(void)
{
   else switch (draw_item_type)
   {
      case 1: al_draw_bitmap(btile[draw_item_num], x, y, 0); break;  <-------------
      case 2: draw_item_shape(draw_item_num, x, y); break;



void draw_item_info(int x, int y, int color, int type, int num)
{
   int a, b;
   switch (type)
   {
      case 1:
         al_draw_bitmap(btile[num], x, y, 0);   <----------------
         al_draw_textf(font, mC.pc[color], x+22, y+2, 0, "Block #%d",num);



OK I think everything now points at the new btiles.....


now what???

make a way of moving the tiles around and editing flags...

this will be saved just like the old swbl thing, but only for the new stuff...

First thing I should do is remove all the none block things from btiles...

I could do this automatically with a combo of glt and save bitmap....



int save_tiles(void)
{
   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(tile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tiles.bmp", temp);
   al_destroy_bitmap(temp);

   char sprit_filename[20] = "bitmaps/sprit001.pm";

   for (int c=0; c<NUM_ANS; c++)    // set all to initial
      if (zz[4][c] != 0)
      {
         zz[0][c]=zz[5][c];
         zz[1][c]=0;
         zz[2][c]=0;
      }
   filepntr = fopen( sprit_filename,"wb");
   for (int c=0; c<NUM_ANS; c++) // put animation sequences
      for (int y=0; y<20; y++)
      {
         int ho = (zz[y][c] / 256);
         int lo = zz[y][c] - (ho*256);
         fputc(ho, filepntr);
         fputc(lo, filepntr);
      }
   for (int c=0; c<NUM_SPRITES; c++)  // shape attributes sa[512][2]
      for (int y=0; y<2; y++)
         fputc(sa[c][y], filepntr);

   fclose(filepntr);
   return 0;
}


use just this.....


   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(btile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tempb_tiles.bmp", temp);
   al_destroy_bitmap(temp);



void remove_unused_tiles(void)
{
   for (int z=0; z<NUM_SPRITES; z++)
   {
      if (blt[z] == 0) // block is not used
      {
         al_set_target_bitmap(btile[z]);
         al_clear_to_color(al_map_rgb(0,0,0));
      }
   }

   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(btile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tempb_tiles.bmp", temp);
   al_destroy_bitmap(temp);

}


holy shit that worked!  block_tiles.bmp is so much cleaner now.....

now make the code to edit and set flags.... I will still use swbl I think....

sa[NUM_SPRITES][2]
sa[0] = locked
sa[1] = type
0 = empty
1 = block
2 = special

right now selection window only uses the ones marked B to fill swbl array

void set_swbl(void)
{
   int swbn = 0;
   // erase array
   for (int c=0; c<NUM_SPRITES; c++)
   {
      swbl[c][0] = 0;
      swbl[c][1] = 0;
   }
   for (int c=0; c<NUM_SPRITES; c++)
      if ((sa[c][0] == 1) && (sa[c][1] == 1)) // if block and locked
            swbl[swbn++][0] = c;   // put shape # in list and inc counter
   for (int c=0; c<NUM_SPRITES; c++)
      if ((sa[c][0] == 1) && (sa[c][1] == 0)) // if block and unlocked
            swbl[swbn++][0] = c;   // put shape # in list and inc counter

   swnbl = (swbn / 16) + 1;
   if (swnbl_cur == 0) swnbl_cur = swnbl; // initial only
}


I plan to use sa to store flags for each btile....

sa[][0] show in selection window (or maybe later to force order)
sa[][1] flags


#define PM_BTILE_SOLID_PLAY      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENMY      0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM      0b00000000000001000000000000000000
#define PM_BTILE_SOLID_EBUL      0b00000000000010000000000000000000
#define PM_BTILE_SOLID_PBUL      0b00000000000100000000000000000000
#define PM_BTILE_SEMISOLID_PLAY  0b00000000001000000000000000000000
#define PM_BTILE_SEMISOLID_ENMY  0b00000000010000000000000000000000
#define PM_BTILE_SEMISOLID_ITEM  0b00000000100000000000000000000000
#define PM_BTILE_BOMBABLE        0b00000001000000000000000000000000
#define PM_BTILE_BREAKABLE_PBUL  0b00000010000000000000000000000000
#define PM_BTILE_BREAKABLE_EBUL  0b00000100000000000000000000000000
#define PM_BTILE_LADDER_MOVE     0b00001000000000000000000000000000
#define PM_BTILE_ROPE_MOVE       0b00010000000000000000000000000000
#define PM_BTILE_SECRET          0b00100000000000000000000000000000
#define PM_BTILE_SHOW_SELECT_WIN 0b01000000000000000000000000000000



the main function is:

int animation_proc(void)
it calls:
select_bitmap_ans()
select_bitmap_proc()
copy_bitmap_proc()
save_tiles()





I want to make a new edit bitmap attributes....
maybe with a new sa[][] variable....
but the existing one is nicely saved to disk...

I also need a copy function...not only for in the same file, but from file to file....

Also make a function to test spinning tiles and set all the parameters for that...

for now change it so that sa[][1] controls whether or not to show in select window....
later I'll extend it to use an int to control position in that window

its coming along...


this function that I just did works great for setting sa[][1]

now I want to make a new function to set sa[][0] with flags...

have a list of all the flags...


when i save an int to file im only using putc so I only save 8 bits....

im going to try fwrite and fread...it looks like I might come out of the stone age!!!


int arr[3] = {101, 203, 303};

fwrite(arr, sizeof(arr), 1, fp);






change the save method...

old:


   char sprit_filename[20] = "bitmaps/sprit001.pm";
   FILE *filepntr = fopen( sprit_filename,"wb");
   for (int c=0; c<NUM_ANS; c++) // put animation sequences
      for (int y=0; y<20; y++)
      {
         int ho = (zz[y][c] / 256);
         int lo = zz[y][c] - (ho*256);
         fputc(ho, filepntr);
         fputc(lo, filepntr);
      }


   for (int c=0; c<NUM_SPRITES; c++)  // shape attributes sa[512][2]
      for (int y=0; y<2; y++)
         fputc(sa[c][y], filepntr);

   fclose(filepntr);


new write:
   FILE *fp = fopen("bitmaps/sprit001.pm", "wb");
   fwrite(zz, sizeof(zz), 1, fp);
   fwrite(sa, sizeof(sa), 1, fp);
   fclose(fp);

new read:
   FILE *fp = fopen("bitmaps/sprit001.pm", "rb");
   fread(zz, sizeof(zz), 1, fp);
   fread(sa, sizeof(sa), 1, fp);
   fclose(fp);

that is so much simpler....


If I'm planning on doing the same for l[100][100]
I'll need to to the same...
that will come later...

now sa[][1] is not used for showing in the select window...I have a flag for that....

Now I need to work on a better way of setting groups of tile flags



multiple selection could be one thing...



I could have a special list of settings that I apply to what I click on.
each flag could be force on, force off, or ignore
I will call it setting tool....


modes:

0 - change 1 tiles flags at a time
selection can be only one

1 -


I am so close, but I am so tired....

9:52pm 20220404


5:00 am 0405

do I really need single and multiple modes?
multiple mode works good with only one block selected...





now I want a function that marks blocks based on selected flags

each flag can be set, clear or don't care

each block will be marked if they match the criteria

then I want a section that I can use to set blocks
each flag can be marked set, clear or ignore...then I can apply this to selected blocks...


I also want to show the flags for the moused over tile...

all these things could be just colums on the one list of flags...





extend proc_controllers....

make 2 global ints that can be adjusted with arrows in proc control_lead_frames

int pct_x = 0;
int pct_y = 0;

that took minutes to do an will be so goddamn useful in aligning stuff and seeing how it looks...


I have the multiple secletion and mouse selection all lined up and looking good


rethink modes...

- When in multiple select any changes to the multiple selection affect all selected...
this is how it is already

- When only one tile is selected, make a mode that I can copy the flags to any other tile by just clicking b2...

"Copy flags from selected tile to other tiles"
b1 - set selected tile
b2 - copy flags from selected tile to clicked tile

"Change flags of all selected tiles"
b1 - drag and click to select rectangular area
click on the flag toggles to change


................this part is done...done good enough....


now I want to be able to move tiles around
from position to position within one file and from file to file....

master will be just like 32x32 then have a separate file that can only be copied from....



it works!

lest see if I can get one from a long time ago...


pm0_1 has no level editor..took a screenshot of the game, pasted into gimp and cropped to block boundary
exported as bmp.
in pm it came in at 2x size, but when I scaled it down it seemed to work

pm0_2 has level editor, there are 512 bitmaps 16 in a row and only 8 rows show on the screen at once...
4 screens would get them all...do it...


pm1 is very similar to pm0

pm2 has 512 bitmaps in 32x16

pm3 does not allow looking at bitmaps in level editor...only has block editor...

pm4 does the same...

I know how I can force it...I could edit pmhelp to show arbitrary shape, or I could do the same with a level....

anyways, I have some cool old tiles...

what else to do?

show where pasting
basically just show where pointer is in 32x32

this function to copy and move tiles is done and works great...

now what??

I should fix the save and load stuff..
mostly for level, but do it all while I'm at it...

I'll need to make backups of the levels...
and use glt to convert

first modify save...
then run glt
then modify load...


at the start of .pml is

level_header[20]
level_header[3] items
level_header[4] enemies
level_header[5] lifts

read and write mode is r and w

now all the levels are 122k
89 levels = 10.7M
old was 3.7M


modified the read also and it works...until I try to do something with pmsg....

how the hell does that work?

I think pmsg is just pointers....

look into it, this needs to be fixed...

old load:
pmsg[c] = (char*) malloc (strlen(buff)+1);
strcpy(pmsg[c], buff);


old save:
if (item[c][0] == 10) // pmsg
{
   y = 0;
   while (pmsg[c][y] != 0)
   {
      if (pmsg[c][y] == 13) fprintf(filepntr,"%c", 126);
      else fprintf(filepntr,"%c", pmsg[c][y]);
      y++ ;
   }
   fprintf(filepntr,"\n");
}


the reason for malloc was to save memory...
what if I just malloc'd a fixed amount in pmsg only if the corresponding item = 10
or I could extend pmsg to have a second variable for the length...

or I could simply write 500 lengths in the pml file while saving...yes...do this...


I need to save pl then save the string one at a time  if not len=0

I think I got it!!!!


lets go back and do it right...

this is the way....


save:

   // how many pmsg?
   int num_pmsg = 0;
   for (int i=0; i<500; i++)
      if (pmsg[i] != NULL) num_pmsg++;

   // make an array to store data about them
   int pl[num_pmsg][2] = {0};

   // fill the array
   int pl_indx = 0;
   for (int i=0; i<500; i++)
   {
      if (pmsg[i] != NULL)
      {
         pl[pl_indx][0] = i;               // pmsg index
         pl[pl_indx][1] = strlen(pmsg[i]); // length of pmsg
         pl_indx++;
      }
   }

   // write the num of pmsg
   fwrite(&num_pmsg, sizeof(int), 1, fp);

   // write the array
   fwrite(pl, sizeof(pl), 1, fp);

   // write the text of the pmsg's
   for (int c=0; c<num_pmsg; c++)
   {
      int pi = pl[c][0]; // pmsg index
      int ps = pl[c][1]; // pmsg length
      fwrite(pmsg[pi], ps, 1, fp);
   }

load:

   // read the number of pmsg's
   int num_pmsg = 0;
   fread(&num_pmsg, sizeof(num_pmsg), 1, fp);

   // make the array to store data about them
   int pl[num_pmsg][2] = {0};

   // read the array
   fread(pl, sizeof(pl), 1, fp);

   // read the strings
   for (int c=0; c<num_pmsg; c++)
   {
      int pi = pl[c][0]; // pmsg index
      int ps = pl[c][1]; // pmsg length
      pmsg[pi] = (char*) malloc (ps); // allocate
      fread(pmsg[pi], ps, 1, fp);     // read
   }




is there someplace I should be freeing all these??

in zero_level_data()

old
   for (int c=0; c<500; c++)  // items
   {
      if (item[c][0] == 10)
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }


new:
   for (int c=0; c<500; c++)  // items
   {
      if (pmsg[c])
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }


seems to work...

now some of the text is not coming out how I would like...

I used to do something different in linux to eat char 13 or soething like that...



old_save replaces 13 with 126 '~'

   if (item[c][0] == 10) // pmsg
   {
      y = 0;
      while (pmsg[c][y] != 0)
      {
         if (pmsg[c][y] == 13) fprintf(filepntr,"%c", 126);
         else fprintf(filepntr,"%c", pmsg[c][y]);
         y++ ;
      }
      fprintf(filepntr,"\n");


old_load ignores 13

   if (item[c][0] == 10) // get pmsg
   {
     loop = 0;
     ch = fgetc(filepntr);
     while((ch != '\n') && (ch != EOF))
     {
        if (ch != 13) // ignore and don't add if 13 ( needed for linux)
        {
           buff[loop] = ch;
           loop++;
        }
        ch = fgetc(filepntr);
     }
     buff[loop] = 0;
     pmsg[c] = (char*) malloc (strlen(buff)+1);
     strcpy(pmsg[c], buff);



what the hell? what am I going to do?

use glt to see how many I have....


it was a stupid off by one error

when I got the size of the string, I needed to add 1 to include the NULL terminator...

I only has to change one line....

old: pl[pl_indx][1] = strlen(pmsg[i]); // length of pmsg

new: pl[pl_indx][1] = strlen(pmsg[i]) + 1; // length of pmsg (don't forget about the NULL at the end)

mucho goodlier.....


I also want to implement a version for the pml file format.....
when loading level, check for version

keep old versions around so you can load older stuff...

don't even try to load unless you have a handler for that version...

I'm going to call the version I have now 1.0 (once I implement versioning)

The version previous to this will be 0.9

I should go back and see what older levels I have.....

make a search and load function.....

make something to detect...

20220406 12:03PM...push....


20220406 7:20 PM

file stuff is totally done....

removed old....


I should test this stuff in linux...
how do I boot from grub command line
kingston uefi boot to mx1 on mr5

lifts and pmsg seem to look good

linux version has problems with filename seperators in copy bitmap...
the load button works, but the title did not find the separator to remove path...not a big deal
fixed with allegro specific path stuff

the save button really messed up the tiles...all the tiles that were empty...the rest still look good...
did not clear to color...duh...try it now...works great

linux version randomly crashes...


20220407 5:00AM
did some more work on copy bitmap, looks better, added button to load edit_tile_attributes()

make switch and key use proper btiles instead of tiles...
did all in item file, block manip, keys, switch, bombs


10:00AM at work...

when choosing what item to pick up when there are multiple, choose bonus last...
this might be hard...
when choosing pick up an item, if player is already carrying, nothing is done...
I could make this work by:
if player is carrying bonus, and comes in contact with something that is not a bonus
automatically drop the bonus and carry the other item...


old:
// check if player can carry item
if ( (!players[p].carry_item)  // not carrying
  && (item[i][3] < 0)          // item is carryable
  && (players[p].fire) )       // fire pressed

new:

int already_carrying = 0;
if (players[p].carry_item) // already carrying item
{
   already_carrying = 1;
   if ((item[players[p].carry_item][0] == 10) && (item[i][0] != 10)) // carried item is bonus and new item is not bonus
      already_carrying = 0;
}

// check if player can carry item
if ( (!already_carrying)  // not carrying
  && (item[i][3] < 0)     // item is carryable
  && (players[p].fire) )  // fire pressed


what is the next step in l[100][100] stuff???

I'm at the point of doing something huge....

like changing all the values in level blocks...

in glt...

have a list of blocks that we will change

most are empty and have no change

0-31   empty
32-63  semisold
64-95  bombable
96-127 breakable

>127 solid

18 ladder
19 rope


next most common are solid and will get:
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

then semisolid...add to solid
#define PM_BTILE_SEMISOLID_PLAYER  0b00000000001000000000000000000000
#define PM_BTILE_SEMISOLID_ENEMY   0b00000000010000000000000000000000
#define PM_BTILE_SEMISOLID_ITEM    0b00000000100000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

#define PM_BTILE_BOMBABLE          0b00000001000000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

#define PM_BTILE_BREAKABLE_PBUL    0b00000010000000000000000000000000
#define PM_BTILE_BREAKABLE_EBUL    0b00000100000000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000


#define PM_BTILE_LADDER_MOVE       0b00001000000000000000000000000000

#define PM_BTILE_ROPE_MOVE         0b00010000000000000000000000000000



for now just do solid blocks
empty will have no change

backup level folder...

make changes:

      // blocks
      for (y=0; y<100; y++)
         for (z=0; z<100; z++)
         {
            blt[l[y][z]]++; // inc block counter

            if (l[y][z] > 127) // solid block
            {
               l[y][z] |= PM_BTILE_SOLID_PLAYER;
               l[y][z] |= PM_BTILE_SOLID_ENEMY;
               l[y][z] |= PM_BTILE_SOLID_ITEM;
               l[y][z] |= PM_BTILE_SOLID_PBUL;
               l[y][z] |= PM_BTILE_SOLID_EBUL;
            }

         }


start trying to make this work in game....

the biggest thing will be masking the higher bits so I can draw....

then the collison detection...


tiles are 0-1023 or 2^9

l[][] & 0b00000000000000000000000111111111 // keep the lower 9 bits

l[][] & 1023 // keep the lower 9 bits



void init_level_background(void) // fill level_background with blocks and lift lines
{
   //printf("init_level_background\n");
   al_set_target_bitmap(level_background);
   al_clear_to_color(al_map_rgb(0,0,0));
   for (int x=0; x<100; x++)
      for (int y=0; y<100; y++)
      {
         int c = l[x][y] & 1023; <----------------works!!!!
         if (c < NUM_SPRITES)
            al_draw_bitmap(btile[c], x*20, y*20, 0);
      }
   draw_lift_lines();
}



now I am modifying the 4 directional checks.....
as prrof on concept it works, but its about to get a lot more complicated.....

everytime it is called, it now needs to ask who wants to know if I'm solid?

add another int to the parameters...
int type;
1 = player
2 = enemy
3 = item
4 - pbul
5 - ebul


then fix all the places that it is called....done...

bullets do their own collisons
ebullets done....later will need to be breakable here

if (d & PM_BTILE_SOLID_EBUL)  // bullet hit solid or breakable wall
{
   e_bullet_active[b] = 0;        // bullet dies
   if ((d > 95) && (d < 128))     // remove breakable wall
   {
      remove_block(xi, yi);
      draw_lift_lines();
   }
}


lets do breakable now...
add this to glt....

breakable and bombable done...

now what about semisolid
just add the 3 semisolid flags

there is only 2 places where I care if is_up_solid returns 2 and it would be the same if it returned zero....i think

made semi solid work, but just for player now...needs way more testing...

revert level and push...work calls....

2:00PM push

5:00PM

in glt I did ladders too, now everything is done there


make ladders and rope work...done

finish semisolid

the way semisolid works....
there is a custom handler for is_up_solid....
as one on the conditions it checks that semisolid is not set for the blocks it is checking

there is no return value of 2 if semi-solid...


semisolid looks good, but...

bullets do not go through

i should change the glt from:

if ((l[y][z] > 31) && (l[y][z] < 64)) // semi solid
{
   l[y][z] |= PM_BTILE_SOLID_PLAYER;
   l[y][z] |= PM_BTILE_SOLID_ENEMY;
   l[y][z] |= PM_BTILE_SOLID_ITEM;
   l[y][z] |= PM_BTILE_SOLID_PBUL;
   l[y][z] |= PM_BTILE_SOLID_EBUL;
   l[y][z] |= PM_BTILE_SEMISOLID_PLAYER;
   l[y][z] |= PM_BTILE_SEMISOLID_ENEMY;
   l[y][z] |= PM_BTILE_SEMISOLID_ITEM;
}

to:

if ((l[y][z] > 31) && (l[y][z] < 64)) // semi solid
{
   l[y][z] |= PM_BTILE_SOLID_PLAYER;
   l[y][z] |= PM_BTILE_SOLID_ENEMY;
   l[y][z] |= PM_BTILE_SOLID_ITEM;
   l[y][z] |= PM_BTILE_SEMISOLID_PLAYER;
   l[y][z] |= PM_BTILE_SEMISOLID_ENEMY;
   l[y][z] |= PM_BTILE_SEMISOLID_ITEM;
}



that seems to work....


now the big one...change mv's...
or I could make level editor not crash...

it was very easy...whenever I went to draw tile[num] i did tile{num&1023}

now I want to see the flags in a small window...

I just show them under the draw item and it works good...

workflow....

- copy block to draw item
- edit flags
- draw with it
...
profit?

shut it down at 10:00 PM could not keep my eyes open

20220408 5:00AM

What I need to do is do this right...
this flags menu thing needs to be its own official window

its working but could stand to be cleaned up....

push


8:00 AM

I can't believe how good this is working....

still to do....
make select window items apply sa when drawing them
how about when swbl is filled...

for (int c=0; c<NUM_SPRITES; c++)
   if (sa[c][0] & PM_BTILE_SHOW_SELECT_WIN)
      swbl[swbn++][0] |= sa[c][0];   // put shape # in list and inc counter

al_draw_bitmap(btile[swbl[c][0] & 1023], swx1+(c-((c/16)*16) )*20+1, swy1+select_window_block_y+1+14+(c/16*20), 0 );

current:
d = process_select_window(0);
if (d < 999) // block
{
   draw_item_num = d;
   draw_item_type = 1;
}
if (d >= 3000) // pd
{
   draw_item_num = d-3000;
   draw_item_type = 5;
}

999 or 1001 do nothing...
how do I fix this?
now

0-huge == block
< -1000 == pde copy type (add 2000 to get actual pde #)
-1 all other returns (doesnt do anything)

I can get stuff from select window and it seem to work good.

make it so that the select window flag is not shown...
(not that critical, will have no effect on level)

make the block range draw special shapes things work....done

show just tile number in pde block descrption...done


20220408 6:00PM

most of the integration of the new tiles are done...

i need to make mv things work...done...that was easy

bug... drawing tile zero in block draws not empty...fixed.....


keys don't work?? they do with erase all....fixed...

lets test and see what is broken...

keys shapes on key creator...

switches....looks like the 2 tiles that swap are hard coded into the switch item...
color   shape   10   11
purple  841     175  10
blue    809     174   9
green   745     172   7
red     777     713   8

kept that the same...just made some minor changes to the switch code...done...


h block walker...need to make solid...done...



now for block manip

set all to block

if empty no prob
if not then I need to set the appropriate flags...I could use the defaults from sa....
yes...do that...done
that is great.....

to compare to do this:
if ((l[x][y]&1023) == block1)

to set block using default flags, do this:              {
l[x][y] = block2 | sa[block1][0];

when selecting block for bm uses btiles not tiles....maybe even use swbl...only get tiles that are supposed to be blocks....
made a really nice bitmap chooser than uses swbl


I sometimes have trouble tracking down errant flags...
I want a way to detect this.
like maybe an overlay
choose a flag and see if it it set by marking any tile with that flag

or...

how about this...

check every entry in l[][] that does not match the default flags for the specific shape....

mark that tile....

toggle with a key in editor...

global value show_non_default_blocks = 0;


this works great...type sndb and serial key will turn it on....
them red x's show up on non default blocks....


its getting really late...like 11:49

all I can think of to do is make a simple flag viewer when mouse over pde blocks



push....

20220409 7:00AM

make the flag rectangles toggle off, most of the time regular block draw will be fine...done

make a simple and detailed description for view and draw item and pde blocks...done

hide the show select win flag..it is not needed...done

make the tile attribute thingy look better...done
buttons like copy bitmap...done...

block puzzle is broken, look again at what happens in block manip toggle...done

wow... I think it's all done....

I could remove old blocks from tiles.bmp...



rename the copy_tiles thing in the menu...

Block and Default Flag Editor






Commit message:

Tiles used for blocks now have their own file: block_tiles.bmp
There are 1024 tiles in a 32x32 grid, just like the regular tiles.bmp
They are loaded into btiles[1024] just like the other tiles use tiles[1024].
All tiles used to draw blocks now use btiles[] instead of tiles[]

Completely redid the block attribute method.
The old method used the tile number as an indicator of the block properties.
The new method uses bit flags stored in the same int as the tile number

Made some nice graphical tools to manipulate tiles and .bmp file and flags.

Added a new page to the html documentation 'block_flags.html'


12:02 pushed...

This is a huge chapter completed...

I want to make some test levels to show off...

sndb shows in game....fixed

sometimes I have a weird crashing error when save and exit from level editor

why does pmsg view show extra stuff?
'P' in level editor runs void show_all_pmsg(void)

this actually shows pmsg, not item 10

maybe they are not all NULL like they should be...

   for (int i=0; i<500; i++)
   {
      if (pmsg[i] != NULL)
      {
         int len = strlen(pmsg[i]);


lets force it...
trace it through its life

declaration:
char *pmsg[500] = { NULL };
extern char *pmsg[500];

in file

void zero_level_data(void)
{
   for (int c=0; c<500; c++)  // items
   {
      if (pmsg[c])
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }
      for (int x=0; x<16; x++) item[c][x] = 0;
      for (int x=0; x<4; x++) itemf[c][x] = al_itofix(0);
   }
   sort_item();


I want to view after loading a file pmsg and item10.

its only this level that I am currently working on that has the problem

more pmsg's are being created than should be

Maybe it's been like this since I changed the file stuff...

how can I fix it?

band aid - find the extra's and kill them
what I should really do is find out why and where the problem is...


// load
int pc = 0;
int i10 = 0;
for (int i=0; i<500; i++)
{
   if (item[i][0] == 10) i10++;
   if (pmsg[i]) pc++;
}
if (i10 != pc) printf("lev:%d npm:%d  pc:%d  i10:%d\n", level_to_load, npm, pc, i10);


// save
// how many pmsg?
int num_pmsg = 0;
for (int i=0; i<500; i++)
   if (pmsg[i] != NULL)
   {
      if (item[i][0] == 10) num_pmsg++; // is there a corresponding item 10?
      else // found a pmsg with no item linked to it...wtf
      {
         printf("while saving level:%d -- found rogue pmsg[%d] with no corresponding item\n", level_to_save, i);
         pmsg[i] = NULL;          // set the pointer to NULL, don't worry about freeing
      }
   }



lev:56 npm:10  pc:10  i10:4
lev:56 npm:10  pc:10  i10:4
while saving level:56 -- found rogue pmsg[0] with no corresponding item
while saving level:56 -- found rogue pmsg[1] with no corresponding item
while saving level:56 -- found rogue pmsg[6] with no corresponding item
while saving level:56 -- found rogue pmsg[7] with no corresponding item
while saving level:56 -- found rogue pmsg[8] with no corresponding item
while saving level:56 -- found rogue pmsg[9] with no corresponding item

problem is fixed with a bandaid.....

I want to save status and select window positions...only move if off screen
also sbf and sndb

what are they?


this is called a lot...



with 1
in set map_var
start of edit_menu
twice when stat and sel winodw become active from menu

with 0
when moving windows
lets make all but map var 0







void check_s_window_pos(int reset_pos)
{
   int swx1 = status_window_x;
   int swy1 = status_window_y;
   int swh = status_window_h;
   int sww = status_window_w;
   int swx2 = swx1 + sww;
   int swy2 = swy1 + swh;
   if ((swx2 > SCREEN_W) || (swx1 < 0)) reset_pos = 1;
   if ((swy2 > SCREEN_H) || (swy1 < 0)) reset_pos = 1;

   swx1 = select_window_x;
   swy1 = select_window_y;
   swh = select_window_h;
   sww = select_window_w;
   swx2 = swx1 + sww;
   swy2 = swy1 + swh;
   if ((swx2 > SCREEN_W) || (swx1 < 0)) reset_pos = 1;
   if ((swy2 > SCREEN_H) || (swy1 < 0)) reset_pos = 1;

   if (reset_pos)
   {
//      status_window_x = SCREEN_W-(sww+10);
//      status_window_y = 10;
//
//      select_window_x = SCREEN_W-(sww+10);
//      select_window_y = status_window_y + status_window_h + 10;


      status_window_x = 10;
      status_window_y = 10;

      select_window_x = SCREEN_W-(sww+10);
      select_window_y = 10;

   }
}
added status_window_x and y to config.
made it so that it will never force...

done...

when drawing a block range, use the flags from the draw item block for all....done....




tested on MX linux, sometimes sigaborts double free detected..traced back to zero level data....



I fucking hate alloacting and freeing memory!!
how much fucking time have I wasted chasing down this shit!!


How can I do it differently?

what is the longest pmsg I have?


use glt....max is 299 from level 1...



what are my options?

worst case, 500 pmsg, 500 char each

250,000 bytes...nothing!!!!
wait.. that is 250,000 per level

100 levels...25M of text

pm.wav takes 30,000,000
tiles takes 1,200,000
l[100][100] takes 40,000

levels are around 120,000 this would increase their size by 200%
unless I just stored what is used...
Am it just trading one problem for another?

OK fuck it
what if I zip the files

just do it......

while doing it coexist with existing...

new var

char pmsgtext[500][500];




I've gone through file

make a copy of levels 90 files 10.5 M

change save routine....

run glt...

      for (int y=0; y<500; y++)
         if (pmsg[y]) strcpy(pmsgtext[y], pmsg[y] ) ;

change load routine....done

change draw routine in z_items...I can see them!!

new size 90 levels 31.8M

changed edit stuff in zmenu, successsdfully changed text, save and it worked.

file, item, menu is done...


editor is done...

editor_zfs does so funky shit saving and loaded selection...
there is a ft_pmsg....
lets just skip zfs for now....


there is not a single trace of pmsg in the fucking codebas anymore!!!! yay

still need to look into zfs ft_pmsg

maybe straighten up the save and load selection stuff....

look like I just need to shadow pmsgtext with ft_pmsgtext....

search for ft_pmsg, removed all traces

there is some weird code when saving ft...


//               while (ft_pmsg[c][y] != (char)NULL)
//               {
//                  if (ft_pmsg[c][y] == 13) fprintf(filepntr,"%c",126);
//                  else fprintf(filepntr,"%c",ft_pmsg[c][y]);
//                  y++ ;
//               }
//               fprintf(filepntr,"\n");

i'm going to leave it as long as I am not fwriting in bimary mode

sel only puts what is used
I can still probably make it work
save the items from 0 to last item
save pmsg from 0 to last item....
it's far to complex for such a minor thing


now how about that zlib level things?

this looks so simple...

fread(level_header, sizeof(level_header), 1, fp);
fread(l,            sizeof(l),            1, fp);
fread(item,         sizeof(item),         1, fp);
fread(Efi,          sizeof(Efi),          1, fp);
fread(Ei,           sizeof(Ei),           1, fp);
fread(lifts,        sizeof(lifts),        1, fp);
fread(lift_steps,   sizeof(lift_steps),   1, fp);
fread(pmsgtext,     sizeof(pmsgtext),     1, fp);


void game_vars_to_state(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(players); memcpy(b+offset, players, size);
   offset += size; size = sizeof(Ei);      memcpy(b+offset, Ei,      size);
   offset += size; size = sizeof(Efi);     memcpy(b+offset, Efi,     size);
   offset += size; size = sizeof(item);    memcpy(b+offset, item,    size);
   offset += size; size = sizeof(itemf);   memcpy(b+offset, itemf,   size);
   offset += size; size = sizeof(lifts);   memcpy(b+offset, lifts,   size);
   offset += size; size = sizeof(l);       memcpy(b+offset, l,       size);
}

void state_to_game_vars(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(players); memcpy(players, b+offset, size); offset += size;
   size = sizeof(Ei);      memcpy(Ei,      b+offset, size); offset += size;
   size = sizeof(Efi);     memcpy(Efi,     b+offset, size); offset += size;
   size = sizeof(item);    memcpy(item,    b+offset, size); offset += size;
   size = sizeof(itemf);   memcpy(itemf,   b+offset, size); offset += size;
   size = sizeof(lifts);   memcpy(lifts,   b+offset, size); offset += size;
   size = sizeof(l);       memcpy(l,       b+offset, size); offset += size;
}



I need to find the actual sizes....

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4000
lift_steps  : 25600
pmsgtext    :250000
-------------------
       total:370880


now I need to make at least to varaibles to store these.

one for the live and one for the extracted...but as soon as I am done with them I can free them...

// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];


#define PML_SIZE 370880
char pml[PML_SIZE];
char pmz[PML_SIZE];

void pml_to_var(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(level_header); memcpy(level_header, b+offset, size); offset += size;
   size = sizeof(l);            memcpy(l,            b+offset, size); offset += size;
   size = sizeof(item);         memcpy(item,         b+offset, size); offset += size;
   size = sizeof(Ei);           memcpy(Ei,           b+offset, size); offset += size;
   size = sizeof(Efi);          memcpy(Efi,          b+offset, size); offset += size;
   size = sizeof(lifts);        memcpy(lifts,        b+offset, size); offset += size;
   size = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, size); offset += size;
   size = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, size); offset += size;
}

void var_to_pml(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(level_header); memcpy(b+offset, level_header, size);
   offset += size; size = sizeof(l);            memcpy(b+offset, l,            size);
   offset += size; size = sizeof(item);         memcpy(b+offset, item,         size);
   offset += size; size = sizeof(Ei);           memcpy(b+offset, Ei,           size);
   offset += size; size = sizeof(Efi);          memcpy(b+offset, Efi,          size);
   offset += size; size = sizeof(lifts);        memcpy(b+offset, lifts,        size);
   offset += size; size = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   size);
   offset += size; size = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     size);
}

ready to test write...back up levels


// decompress client_state_buffer to client_state_dif
uncompress((Bytef*)client_state_dif, sizeof(client_state_dif), (Bytef*)client_state_buffer, sizeof(client_state_buffer));


char dif[STATE_SIZE];
char cmp[STATE_SIZE];

// compress dif to cmp
uLongf destLen= sizeof(cmp);
compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
int cp = destLen;


now 90 files take up 246K, that is less than 1%...omg....can I load?

load:
// read the compressed data
char cmp[PML_SIZE];
fread(cmp, sizeof(cmp), 1, fp);
fclose(fp);

// decompress cmp to pml
char pml[PML_SIZE];
uLongf destLen = sizeof(pml);
uncompress((Bytef*)pml, (uLongf*)&destLen, (Bytef*)cmp, sizeof(cmp));

pml_to_var(pml);

save:
// put variables in pml
char pml[PML_SIZE];
var_to_pml(pml);

// compress pml to cmp
char cmp[PML_SIZE];
uLongf destLen= sizeof(cmp);
compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), 5);
int cmp_size = destLen;

// write cmp to file
FILE *fp = fopen(level_filename,"wb");
fwrite(cmp, cmp_size, 1, fp);
fclose(fp);

total of all 90 levels
size compression level
 233K 9
 238K 8
 249K 7
 251K 6
 268K 5
 289K 4
 400K 3
 418K 2
 576K 1
3180K 0

 251K -1




20220410 8:00 AM

fixed a bug where items would not trigger...

I want to make block manip work with blocks that have flags

so I'm thinking of grabbing them from the actual level rather than the PDE thing
that way they have have all the benefits of flags...
like being able to just turn off a flag

Or I could go all out and make a flag manip item...
or i could extend bm to iunclude flags...
the easiest seems to be to choose the blocks from the level...

how will I do that?


            if (mode == 1) // set all blocks to block 1
            {
               l[x][y] = block1;
               al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
               al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
            }

            if (mode == 2) // set all block2 to block 1
            {
               if (l[x][y] == block2)
               {
                  l[x][y] = block1;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
               }
            }

            if (mode == 3) // toggle block1 and block 2
            {
               if (l[x][y] == block1)
               {
                  l[x][y] = block2;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block2&1023], x*20, y*20, 0 );
               }
               else if (l[x][y] == block2)
               {
                  l[x][y] = block1;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
               }
            }


/* old way...uses only tile number, not tile and flags


            if (mode == 1) // set all blocks to block 1
            {
               l[x][y] = block1 | sa[block1][0]; // replace block (use default flags)
               al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
               al_draw_bitmap(btile[block1], x*20, y*20, 0 );
            }

            if (mode == 2) // set all block2 to block 1
            {
               if ((l[x][y]&1023) == block2)
               {
                  l[x][y] = block1 | sa[block1][0]; // replace block
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block1], x*20, y*20, 0 );
               }
            }

            if (mode == 3) // toggle block1 and block 2
            {
               if ((l[x][y]&1023) == block1)
               {
                  l[x][y] = block2 | sa[block2][0];
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block2], x*20, y*20, 0 );
               }
               else if ((l[x][y]&1023) == block2)
               {
                  l[x][y] = block1 | sa[block1][0];
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                  al_draw_bitmap(btile[block1], x*20, y*20, 0 );
               }
            }



*/

OK that works....

now make the block selector a little nicer...done

now see what we have broken in all the block manips out there....

can I make the block number show better in slider?



52 good
56 good
58 good
59 good
70 good
71 good
314 has a lot, let try to set them with glt
315 has a lot too..

10 and 11

get tile appply default flags...
done....

how many tiles in all my levels have the PM_BTILE_SHOW_SELECT_WIN set?

I should check...looks like only level 59...

then remove
then make it so PDE does not keep it...


when void set_swbl(void) adds it to swbl, flag is not removed

when int process_select_window returns it, flag is not removed

lets nip in in the bud...

when its added to swbl...done

use glt to remove flag....done


moved set_swbl from being called every frame to start of edit menu..
also should do it when it might change like in set tile attributes...done

blank spaces in select window special items have funny tile..
need to make tile 0 in tiles, actually blank...


does the old animation editor stuff actually save and mess stuff up??



save_tiles()
saves the tiles.bmp
and
FILE *fp = fopen("bitmaps/sprit001.pm", "wb");
fwrite(zz, sizeof(zz), 1, fp);
fwrite(sa, sizeof(sa), 1, fp);
fclose(fp);

I have commented out both places that call this...

I should really diable a lot of this stuff...for safety...

I need to keep animation editor...

and copy bitmap could be nice for editing tiles.bmp

- make animation editor do only that and only save zz
but zz and sa are saved together...

make a save and load sprit functions...done

call load_sprit from load_tiles...done
remove saving sprits from saving tiles...done

there are still only two things that call save_tiles and they are both commented out...

the only thing that calls save_sprit is my new void edit_tile_attributes(void)

after i clean up animation it can call it too...

remove all traces of old attributes editor...
it was called int select_bitmap_proc() and has been moved to old_fnx...

animation_sequence_editor() is the new name...
it will call save sprit

            case 20: animation_sequence_editor(); break;
            case 21: copy_tiles(); break;
            case 22: copy_btiles(); break;
            case 23: edit_btile_attributes(); break;



this is all done...
next I need to make a save button for copy_tiles()...
this is the only things that calls save_tiles()...
done and works great...erased blocks from tiles.bmp..

you know...it would have been better to make a tile copier than works from any file to any file....
then I wouldn't have had to do this twice.....

save and load PDE....done....

int load_PDE()
{
   FILE *fp =fopen("bitmaps/pde.pm","rb");
   if (fp)
   {
      fread(PDEfx, sizeof(PDEfx), 1, fp);
      fread(PDEi,  sizeof(PDEi),  1, fp);
      fread(PDEt,  sizeof(PDEt),  1, fp);
      fclose(fp);
      return 1;
   }
   m_err("Error loading pde.pm");
   return 0;
}

void save_PDE()
{
   FILE *fp =fopen("bitmaps/pde.pm","wb");
   if (fp)
   {
      fwrite(PDEfx, sizeof(PDEfx), 1, fp);
      fwrite(PDEi,  sizeof(PDEi),  1, fp);
      fwrite(PDEt,  sizeof(PDEt),  1, fp);
      fclose(fp);
   }
   else m_err("Error saving pde.pm");
}

block number showing better in sliders for manip, now its just a huge number...done just &1023
manip creator to stay on viewer after create..done for manip dmg and trigger

make copy tiles work from any bitmap file to any other...done...that was easy
it is called copy tiles...
fix menu...done...
add gridlines...done
remove the other 2....done
add option to scale 2nd one...done

now the bitmap stuff is much more streamlined:

case 20: animation_sequence_editor(); break;
case 21: copy_tiles(); break;
case 22: edit_btile_attributes(); break;

save_tiles() is called by nothing...
save_btiles() is called by nothing...
move them both to old fnx

save_sprit() is called by:
edit_btile_attributes()
animation_sequence_editor()




make perl script to automatically iterate all cpp files and generate a list of function prototypes

also for all global variables make a list of what files and functions use them






improve lifts with more modes



what variables do I have?

its a struct...no room for expansion

al_fixed fx;
al_fixed fy;
al_fixed fxinc;
al_fixed fyinc;
int x1;
int y1;
int x2;
int y2;
int width;
int height;
int color;
int current_step;
int num_steps;
int limit_counter;
int limit_type;
char lift_name[40];
x2, y2
hell, even x1, y1
could be repurposed

I don't want to change the size because of netgame...but is that really such big deal?
lets see if I can just ignore the 4 ints, x1, y1, x2, y2...
what does lift move use??

this looks too hard

If I wanted to add something what would it look like?

int flags
int mode
int count
int val1

so 4 more ints?

what is the damage?


40 lifts x 4 ints x 4 bytes = 640 bytes

I would need to increase...

#define STATE_SIZE 104640 to #define STATE_SIZE 105280

this would not change at all....

void game_vars_to_state(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(players); memcpy(b+offset, players, size);
   offset += size; size = sizeof(Ei);      memcpy(b+offset, Ei,      size);
   offset += size; size = sizeof(Efi);     memcpy(b+offset, Efi,     size);
   offset += size; size = sizeof(item);    memcpy(b+offset, item,    size);
   offset += size; size = sizeof(itemf);   memcpy(b+offset, itemf,   size);
   offset += size; size = sizeof(lifts);   memcpy(b+offset, lifts,   size);
   offset += size; size = sizeof(l);       memcpy(b+offset, l,       size);
}

void state_to_game_vars(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(players); memcpy(players, b+offset, size); offset += size;
   size = sizeof(Ei);      memcpy(Ei,      b+offset, size); offset += size;
   size = sizeof(Efi);     memcpy(Efi,     b+offset, size); offset += size;
   size = sizeof(item);    memcpy(item,    b+offset, size); offset += size;
   size = sizeof(itemf);   memcpy(itemf,   b+offset, size); offset += size;
   size = sizeof(lifts);   memcpy(lifts,   b+offset, size); offset += size;
   size = sizeof(l);       memcpy(l,       b+offset, size); offset += size;
}


i would need to iterate all the levels and save in the new type...
how the hell will I do that???


shadow the lift struct with something 16 bytes bigger

read into old, copy to new, save as new...



extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];
extern int num_lifts;
extern char lift_step_type_name[10][10];
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int val;
   int x;
   int y;
};

extern struct lift2 lifts2[NUM_LIFTS];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;

   int flags;
   int mode;
   int user1;
   int user2;

   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};




// copy lifts to temp structure to resize

for (int l=0; l<num_lifts; l++)
{
   lifts2[l].fx =            lifts[l].fx;
   lifts2[l].fy =            lifts[l].fy;
   lifts2[l].x1 =            lifts[l].x1;
   lifts2[l].y1 =            lifts[l].y1;
   lifts2[l].x2 =            lifts[l].x2;
   lifts2[l].y2 =            lifts[l].y2;
   lifts2[l].width =         lifts[l].width;
   lifts2[l].height =        lifts[l].height;
   lifts2[l].color =         lifts[l].color;
   lifts2[l].current_step =  lifts[l].current_step;
   lifts2[l].num_steps =     lifts[l].num_steps;
   lifts2[l].limit_counter = lifts[l].limit_counter;
   lifts2[l].limit_type =    lifts[l].limit_type;
   lifts2[l].flags = 0;
   lifts2[l].mode = 0;
   lifts2[l].val1 = 0;
   lifts2[l].val2 = 0;
   strcpy(lifts2[l].lift_name, lifts[l].lift_name);
}



void pml_to_var(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b)
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


I need to resize...


#define PML_SIZE 370880
#define PML_SIZE2 371520












------------------------------------------------------------------------------------------------------------------
step 0 -

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4000
lift_steps  : 25600
pmsgtext    :250000
       total:370880


level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2      :  4640
lift_steps  : 25600
pmsgtext    :250000
       total:371520


#define PML_SIZE 370880
#define PML_SIZE2 371520

------------------------------------------------------------------------------------------------------------------
step 1 - backup levels
------------------------------------------------------------------------------------------------------------------
step 2 - original load  new save
------------------------------------------------------------------------------------------------------------------

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // save
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


char cmp[PML_SIZE];
char pml[PML_SIZE];


struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

loads fine...
------------------------------------------------------------------------------------------------------------------
step 3
modify save and run glt


void var_to_pml(char * b) // save
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


int save_level(int level_to_save)
{
   level_check();

   for (int i=0; i<20; i++) level_header[i] = 0;

   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   level_header[5] = num_lifts;  // num of lifts

   make_filename(level_to_save);   // update filename

   // put variables in pml
   char pml[PML_SIZE2];
   var_to_pml(pml);

   // compress pml to cmp
   char cmp[PML_SIZE2];
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), -1);
   int cmp_size = destLen;

   // write cmp to file
   FILE *fp = fopen(level_filename,"wb");
   fwrite(cmp, cmp_size, 1, fp);
   fclose(fp);
   return 0;
}


      // copy lifts to temp structure to resize
      for (int l=0; l<num_lifts; l++)
      {
         lifts2[l].fx =            lifts[l].fx;
         lifts2[l].fy =            lifts[l].fy;
         lifts2[l].x1 =            lifts[l].x1;
         lifts2[l].y1 =            lifts[l].y1;
         lifts2[l].x2 =            lifts[l].x2;
         lifts2[l].y2 =            lifts[l].y2;
         lifts2[l].width =         lifts[l].width;
         lifts2[l].height =        lifts[l].height;
         lifts2[l].flags = 0;
         lifts2[l].mode = 0;
         lifts2[l].val1 = 0;
         lifts2[l].val2 = 0;
         lifts2[l].color =         lifts[l].color;
         lifts2[l].current_step =  lifts[l].current_step;
         lifts2[l].num_steps =     lifts[l].num_steps;
         lifts2[l].limit_counter = lifts[l].limit_counter;
         lifts2[l].limit_type =    lifts[l].limit_type;
         strcpy(lifts2[l].lift_name, lifts[l].lift_name);
      }



------------------------------------------------------------------------------------------------------------------
step 4


modify load

keep this the same

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}


PML_SIZE2 in 2 places
int load_level(int level_to_load, int display)
{
      // read the compressed data
      char cmp[PML_SIZE2];
      fread(cmp, sizeof(cmp), 1, fp);


modify lift to add 4 ints
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};


success!!!!!!!!
------------------------------------------------------------------------------------------------------------------

clean up the code...

increase the state size and test netplay.....
#define STATE_SIZE 104640 to #define STATE_SIZE 105280
netplay works fine....

made a function to display this:

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4640
lift_steps  : 25600
pmsgtext    :250000
------------:------
total       :371520

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  4640
l        : 40000
---------:------
total    :105280

now that I have 4 more variables in the lift struct, what am I going to do with them?

mode

0 = normal
the last lift step moves to the first at the speed defined in the first step....

1 = instant restart
after the last step, instantly warps to the first step

2 = prox reset
if the player is away from the lift (prox) for a certain time, the lift will reset






1 = one shot
moves to the last step and stays there, forever (this could be done with a prox=0 step)


4 = lift only moves when player is on it... this is probably better as a step...


I want to have some more step types defined also...
step type grow or shrink the lift size...

step type, wait for trigger!!!

   int type;
   int val;
   int x;
   int y;

           case 1: // move
               set_lift_xyinc(d, step);
            break;
            case 2: // wait time
               lifts[d].limit_type = 5; // wait time
               lifts[d].limit_counter = lift_steps[d][step].val; // limit
               lifts[d].fxinc= 0; // no xinc
               lifts[d].fyinc= 0; // no yinc
            break;
            case 3: // wait prox
               lifts[d].limit_type = 6; // wait prox
               lifts[d].limit_counter = lift_steps[d][step].val; // limit
               lifts[d].fxinc= 0; // no xinc
               lifts[d].fyinc= 0; // no yinc
            break;
            case 4: // move to step 0
               step = lifts[d].current_step = 0; // set step 0
               set_lift_xyinc(d, step);


type 5 - resize
val - time to complete
x - new width
y - new height

type 6 - wait for trigger
val - trigger event number


type 7 - move to pos only if player is on lift
val - speed
x
y

type 8 - reset if player off for more than time
val - speed
x
y




20220411 5:00 AM commit

load and save PDE now use binary mode
made a new universal copy tile routine than work from any file to any file
made a new tile select routine for block manip to choose from level block to include flags
cleaned up old bitmap and tile routine
increased lift struct size by 16 bytes for new features


OK lets get into lifts....

This could take some doing, but everything should be nicer when done

I've been thinking about increasing the size of lift steps also

It would be nice to have 2-4 more ints there

All I would need to increase is the level save size, just like I just did for main lift...

40 lifts x 40 steps x 4 ints x 4 bytes = 25600 bytes per level

the good thing is that they are not synced with netgame, they are static...



in lift editor fixed lift help button

added a button lift mode...

modes are
0 continuous loop
1 instant loop

that was very easy to implement...


next...


prox reset...works but lifts prox rect blinks in step 0.....


commit and get ready for work...

7:15 AM






8:50 PM

I thinks I know why it blinks...
it keeps resetting to step zero every frame...

how can I make it not?


set the time out to 80 when resetting?

detect when already in step 0 and stay there?

this type of lift really only makes sense if the first step is a prox anyway...



I had some new ideas today...

use raising damage feild attached to lift like a mario rising lava stage


make walls that chase you down a corridor

make player run a gauntlet of raising and lowering platforms



make the lifts possible to be invisible and have no effect on players, enemies, items, bullets, etc, just like fields


then I could have a moving damage damage field, or trigger!!!


20220412 5:00AM


I'm going to hold off on adding more ints to lift steps for now..
I'm not sure what I would do with them.

I can do a lot with that..

implement new step...change size


type 5 - warp to step 0
val - time to complete
x - new width
y - new height

type 6 - resize
val - time to complete
x - new width
y - new height

type 7 - wait for trigger
val - trigger event number


type 8 - move to pos only if player is on lift
val - speed
x
y


what do I have already


step type 1 - move
val = speed scaled by 10
x new position
y



----------------------

redoing the insert step stuff with new buttons...

it all sems to work but no new step are actually added....


make 3 new sliders for step 6


I think that this is too much for the limited variable that I have...

If I want to manipulate width and height at the same time as x and y I will need 4 more fixed in the main and 2 more for each step...


I could do my own kind of fixed by multipying a shifting a regular int...no


------------------------------------------------------------------------------------------------------------------
step 0 -

original:



Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4640
lift_steps  : 25600
pmsgtext    :250000
------------:------
total       :371520

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  4640
l        : 40000
---------:------
total    :105280



extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int val;
   int x;
   int y;
};


extern struct lift2 lifts2[NUM_LIFTS];
extern struct lift_step2 lift_steps2[NUM_LIFTS][40];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;

   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step2
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};


Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5280
lift_steps2  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts2    :  5280
l        : 40000
---------:------
total    :105920

#define PML_SIZE  371520
#define PML_SIZE2 384960

#define STATE_SIZE  105280
#define STATE_SIZE2 105920

------------------------------------------------------------------------------------------------------------------
step 1 - backup levels
------------------------------------------------------------------------------------------------------------------
step 2 - original load  new save
------------------------------------------------------------------------------------------------------------------

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps2);   memcpy(b+offset, lift_steps2,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}

char cmp[PML_SIZE];
char pml[PML_SIZE];


loads fine...
------------------------------------------------------------------------------------------------------------------
step 3
modify save and run glt

modify save and run glt

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps2);   memcpy(b+offset, lift_steps2,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}




int save_level(int level_to_save)
{
   level_check();

   for (int i=0; i<20; i++) level_header[i] = 0;

   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   level_header[5] = num_lifts;  // num of lifts

   make_filename(level_to_save);   // update filename

   // put variables in pml
   char pml[PML_SIZE2];
   var_to_pml(pml);

   // compress pml to cmp
   char cmp[PML_SIZE2];
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), -1);
   int cmp_size = destLen;

   // write cmp to file
   FILE *fp = fopen(level_filename,"wb");
   fwrite(cmp, cmp_size, 1, fp);
   fclose(fp);
   return 0;
}

// copy lifts to temp structure to resize
for (int l=0; l<num_lifts; l++)
{
   lifts2[l].fx =            lifts[l].fx;
   lifts2[l].fy =            lifts[l].fy;
   lifts2[l].fxinc =         lifts[l].fxinc;
   lifts2[l].fyinc =         lifts[l].fyinc;

   lifts2[l].fw =            al_itofix(lifts[l].width);
   lifts2[l].fh =            al_itofix(lifts[l].height);
   lifts2[l].fwinc =         al_itofix(0);
   lifts2[l].fhinc =         al_itofix(0);

   lifts2[l].x1 =            lifts[l].x1;
   lifts2[l].y1 =            lifts[l].y1;
   lifts2[l].x2 =            lifts[l].x2;
   lifts2[l].y2 =            lifts[l].y2;

   lifts2[l].width =         lifts[l].width;
   lifts2[l].height =        lifts[l].height;
   lifts2[l].flags = 0;
   lifts2[l].mode = 0;
   lifts2[l].val1 = 0;
   lifts2[l].val2 = 0;
   lifts2[l].color =         lifts[l].color;
   lifts2[l].current_step =  lifts[l].current_step;
   lifts2[l].num_steps =     lifts[l].num_steps;
   lifts2[l].limit_counter = lifts[l].limit_counter;
   lifts2[l].limit_type =    lifts[l].limit_type;
   strcpy(lifts2[l].lift_name, lifts[l].lift_name);

   for (int s=0; s<40; s++)
   {
      lift_steps2[l][s].type = lift_steps[l][s].type;
      lift_steps2[l][s].x    = lift_steps[l][s].x;
      lift_steps2[l][s].y    = lift_steps[l][s].y;
      lift_steps2[l][s].w    = 0;
      lift_steps2[l][s].h    = 0;
      lift_steps2[l][s].val  = lift_steps[l][s].val;

   }
}




------------------------------------------------------------------------------------------------------------------
step 4

modify load

keep this the same

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}


PML_SIZE2 in 2 places
int load_level(int level_to_load, int display)
{
      // read the compressed data
      char cmp[PML_SIZE2];
      fread(cmp, sizeof(cmp), 1, fp);


modify lift and lift_steps

extern struct lift2 lifts2[NUM_LIFTS];
extern struct lift_step2 lift_steps2[NUM_LIFTS][40];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;

   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step2
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};


success!!!!!!!!
------------------------------------------------------------------------------------------------------------------

clean up the code...


Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105920



-------------------------------------------------------
-------------------------------------------------------


OK, now that that is all done...lets make resize lift work

I think one of the problems is that we are storing height and width with a resolution of 20 pixels


how much of a major rewrite would it take to make it by the pixel...with a hard minimum?


lets do that first...could be huge....


use glt to change all height and width to *20.......

      // make height and width 0-1999 from 0-99
      for (int l=0; l<num_lifts; l++)
      {
         lifts[l].width *= 20;
         lifts[l].height *= 20;
      }
backup levels and do it...

most places use x2 snd y2, only move seems to set them...changed there...and lift lines...

sliders....done...


did a search for width and fixed mostly everything...broke all of the rotated text stuff though...commented out for now..


moving lift step on map needs fixing...done...

if item has focus cant go back to lift viewer...done....



creating new lift...default size...done

icon at the top of lift viewer...

do I even need draw lift mp? what uses it???

nothing in lifts anymore...


can player ride lifts??? yes...


the resize finally work, but it's rough.....

the lift line do not take into account the resize...
could call init_level_background() after resize, or I could just draw lines every frame...

also when resizing and player riding, they are pushed to one side....

that's it for today...

10:05 PM push

20220413 4:30 AM

lets figure out the deathmatch bullets thing...

it looks very straight forward...
void proc_pbullet_collision(int p, int b)
{
   players[p].LIFE -= al_itofix(deathmatch_pbullets_damage);

looks like I can't send a negative number with my packet routines...offset by 1000...fixed...


riding lift when width exanding pushed player to the right...width contracting is fine....
reset incs when move is done...fixed...


moving lift lines to draw each time works but does not look good....
what would be better is if the original one was smart enough to take into account the size changes....



nothing keeps track of initial lift size once it changes....
I should make step 0 keep that info....

should I just make move and resize the same type?
I can always set one or the other to do nothing....


I think I need to, because step 0 needs both...

w and h will no longer be set in lift, they will be set in step0


extend type 1
make the button a 4 way split...time(speed) get pos, w, h,


remove step type 6 resize...type 1 extended to do that also....


looks like its working good...

I need to do somthing about val...

for resize it makes sense, it is the total time
I will leave it like this

How can I set it like I used to with speed?

pick a speed value and it will calculate the time...

in the slider stuff, have another button called speed.
fill it with ditance/time
if you change it, the time button will change also...


how to calculate distance from this move step to the last move step
I have step and I know that it's a move step so I have x and y
search back from that step to find next move step.
if I go back from step 0 choose the move step

I have a function to do that now!!!!

2 buttons:

time
display: the actual val
range 1-1000
sets speed like this:
calc distance / time



speed
display =
calc distance / time

set from 1-50
sets time like this:
calc distance / speed

what if distance == 0?
speed will not be valid and will show 0...
time will still be valid...

for now I have just allowed the time button, but displayed the calculated speed

lift does not show up anymore in lift viewer, only on step 0
fixed....draw lift lines was resetting he lifts...

I want to make player move detection with lifts use the mv functions so that lifts can move faster and still detect collisions...

when creating lift make a sensible default size and copy it to each new step....done...


I have messed up all my lift speeds here...

I want to go back to the old way...



void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   lifts[d].limit_type = 7;   // move step countdown limit type 7

   // get the integer x and y distances between current pos and next step
   int xln = lifts[d].x1 - lift_steps[d][step].x;
   int yln = lifts[d].y1 - lift_steps[d][step].y;
   if ((xln == 0) && (yln == 0)) // no move needed
   {
      lifts[d].limit_counter = 1;
      lifts[d].fxinc = al_itofix(0);
      lifts[d].fyinc = al_itofix(0);
   }
   else
   {
      al_fixed xlen = al_itofix(xln);   // get the x distance
      al_fixed ylen = al_itofix(yln);   // get the y distance

      al_fixed hy_dist = al_fixhypot(xlen, ylen);     // hypotenuse distance
      al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;  // speed is stored scaled by 10

      al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
      al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
      al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc

      if (abs(xlen) > abs(ylen))  // xlen is longer so use this to set limit counter
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(xlen, xinc))); // steps = distance / increment

      if (abs(xlen) <= abs(ylen)) // ylen is longer or they are equal
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(ylen, yinc))); // steps = distance / increment

      lifts[d].fxinc = -xinc;
      lifts[d].fyinc = -yinc;
   }
}

this test proved I was doing an unecessary calcultion to get time, when in reality what I called scaler was time
I am going to keep the original method but simplify the code...

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   lifts[d].limit_type = 7;   // move step countdown limit type 7

   // get the integer x and y distances between current pos and next step
   int xln = lifts[d].x1 - lift_steps[d][step].x;
   int yln = lifts[d].y1 - lift_steps[d][step].y;
   if ((xln == 0) && (yln == 0)) // no move needed
   {
      lifts[d].limit_counter = 1;
      lifts[d].fxinc = al_itofix(0);
      lifts[d].fyinc = al_itofix(0);
   }
   else
   {
      al_fixed xlen = al_itofix(xln);   // get the x distance
      al_fixed ylen = al_itofix(yln);   // get the y distance

      al_fixed hy_dist = al_fixhypot(xlen, ylen);     // hypotenuse distance
      al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;  // speed is stored scaled by 10

      al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
      al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
      al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc

      if (abs(xlen) > abs(ylen))  // xlen is longer so use this to set limit counter
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(xlen, xinc))); // steps = distance / increment

      if (abs(xlen) <= abs(ylen)) // ylen is longer or they are equal
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(ylen, yinc))); // steps = distance / increment


      int lc = lifts[d].limit_counter;
      int sc = al_fixtoi(scaler);


      if (lc == sc) printf("sc:%4d lc:%4d\n", sc, lc);
      else          printf("sc:%4d lc:%4d  <----------\n", sc, lc);

      lifts[d].fxinc = -xinc;
      lifts[d].fyinc = -yinc;
   }
}



this is the final version:

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)


   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);   // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);   // y dif

   al_fixed hy_dist = al_fixhypot(xlen, ylen);                       // hypotenuse is distance
   al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;         // speed is stored scaled by 10
   al_fixed move_time = al_fixdiv(hy_dist, speed);                   // get time (time = distance / speed)

   lifts[d].fxinc = al_fixdiv(xlen, move_time);                      // set xinc
   lifts[d].fyinc = al_fixdiv(ylen, move_time);                      // set yinc

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}

this was the old one that just used val as a straight timer
void set_lift_xyinc(int d, int step)
{
   al_fixed move_time = al_itofix(lift_steps[d][step].val*20);      // get move time

   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);  // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);  // y dif
   lifts[d].fxinc = al_fixdiv(xlen, move_time);                     // set xinc
   lifts[d].fyinc = al_fixdiv(ylen, move_time);                     // set yinc

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}





there...now that is reverted

do I need to worry about zero moves, will there be a div by zero error?



Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\pm>pm

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
xlen:-100.00 ylen:-640.00 hy:647.77 mt:66.10 fxinc:-1.51 fyinc:-9.68
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-80.00 ylen:400.00 hy:407.92 mt:370.84 fxinc:-0.22 fyinc:1.08
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97

C:\pm>
divide by zero did not seem to cause issues, but I made a check to avoid it anyway.

while doing that I stubled across a method to use val as straight time, if there is not x y move
then there can be a stationary resize that does not happen immediately...

if there is no xy move and no resize, the step will do nothing while the timer runs...

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   int val = lift_steps[d][step].val;

   al_fixed move_time = al_itofix(0);

   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);   // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);   // y dif
   al_fixed hy_dist = al_fixhypot(xlen, ylen);                       // hypotenuse is distance

   if (hy_dist < al_itofix(1))        // no move
   {
      move_time = al_itofix(val);     // use val as straight timer
      lifts[d].fxinc = al_itofix(0);  // no xinc
      lifts[d].fyinc = al_itofix(0);  // no yinc
   }
   else // get time based on speed and distance
   {
      al_fixed speed = al_itofix(val) / 10;         // stored speed scaled by 10
      move_time = al_fixdiv(hy_dist, speed);        // get time (time = distance / speed)
      lifts[d].fxinc = al_fixdiv(xlen, move_time);  // set xinc
      lifts[d].fyinc = al_fixdiv(ylen, move_time);  // set yinc
   }

//   printf("xlen:%4d ylen:%4d hy:%4d mt:%4d fxinc:%4d fyinc:%4d\n",
  //         al_fixtoi(xlen), al_fixtoi(ylen), al_fixtoi(hy_dist), al_fixtoi(move_time), al_fixtoi(lifts[d].fxinc), al_fixtoi(lifts[d].fyinc));

   printf("xlen:%3.2f ylen:%3.2f hy:%3.2f mt:%3.2f fxinc:%3.2f fyinc:%3.2f\n",
           al_fixtof(xlen), al_fixtof(ylen), al_fixtof(hy_dist), al_fixtof(move_time), al_fixtof(lifts[d].fxinc), al_fixtof(lifts[d].fyinc));

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}

Now I need to change the slider button back...done...

On the pop up menu for a step, add set wh to previous step..done.


I don't think I need a separate resize type step, I can do it all with type 1

I want to add a special end type step...instant jump to step 0 or move to step 0
It can be the same step, none of the variables are used..
make
val = 0 loop (old normal deafault)
val = 1 warp
val = 2 fade out??

then I don't really need to do that with mode....


I want to make a mode that if not in step 0 it will reset after player leaves.....

I want to make a move step that does not advance if player is not riding
It can also be used in conjuntion with the mode that resets after time...

then I can do things like falling platforms

extend step type 4...call it end

make type do 1 of 3 things...

0 move to step 0
1 warp to step 0
2 stay here forever

done....



bug, fix stuff in zfs for coying lift...since last variable increase....

from pm.h
extern int ft_lift[NUM_LIFTS][4];
extern int ft_ls[NUM_LIFTS][40][4];

increase steps to 6
extern int ft_lift[NUM_LIFTS][4];
extern int ft_ls[NUM_LIFTS][40][6];


what about lifts?

this is all I currently store:
ft_lift[c][0] = lifts[b].width;
ft_lift[c][1] = lifts[b].height;
ft_lift[c][2] = lifts[b].color;
ft_lift[c][3] = lifts[b].num_steps;

new list:
ft_lift[c][0] = lifts[b].mode
ft_lift[c][1] = lifts[b].flags;
ft_lift[c][2] = lifts[b].color;
ft_lift[c][3] = lifts[b].num_steps;
ft_lift[c][4] = lifts[b].val1;
ft_lift[c][5] = lifts[b].val2;

that should be all done....

test??...good.

bug: blocks don't show in zfs paste selection...done
bug: lifts show weird in xfs paste selection...done

bug: zfs copying start makes multiples with same start index...same as everywhere else...
how many times is level check called
once in load and once in save...all good here


--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
it blows my mind how many different time in code I draw lift...
I should have only one!!
how many times do I mess with rtext...it should be a flag
--------------------------------------------------------------------------------------



I already have mode 2 for reset when player leaves...but no settings
and I need to remove or diasble mode 1 beacuse steps now do it....

mode 2 is gone
now mode 1 is called prox run and reset

hard coded time of 80...
make a way to set it....
show it....
make visually, like shrink the lift or show progress bar

make counter not run when already reset, like in step 0...

should I start this type of lift with a prox?
make the mode 1 stuff only apply for type 1 steps....
did all that...

now to make them look nice, in mode 1 the first step should be a wait prox.
it is not required, but without it the lift will constantly reset to step 0 when the timer runs out.
also with this method, the rest timer will not run for other prox or wait steps
prox steps can't be used alone
but if you insert a wait then a prox in the middle....
player rides lift to the wait spot, then jumps off and runs away before the wait timer expires
when the wait timer expires, the prox step will sit there and wait and not reset....


bug, inserting steps erases w and h..fixed


--- make the original width and height sliders affect the current step, then they can be removed from the actual step button
 what is the current button is not a move step...hide them...
 actually I chose to just show them disabled..


 bug...make sure that current step in lift viewer is valid...mouse sometimes sets it to a negative value...done

bug cant set last two steps to be current step...
no matter how many steps in lift
highlight works fine...

there was a dumb redraw lift_viewer that was drawing the button off by one....

then there was the button for end step probably eats the mouse click....yes
finally this bug is closed....



make current step more obvious... like color it red or something....

step colors right now:

regular   = 3 med blue
highlight = 13 light blue
current   = 14 dark blue

where are they set?

void draw_steps(int step_ty, int lift, int current_step, int highlight_step)
{
   int color = 3;
   if (step == current_step) color = 13;
   if (step == highlight_step) color = 12;

changed it to 15 for regular, 10 for current and a yellow outline for highlight....i like it

now I need to change the text of the move step to be like the others....

then the buttons width and height that only apply to current step
I was thinking of making that more obvious
like put it next to the steps
have something similar for other types of steps


what about the buttons having columns?
first one is the step #
second step type
those can be rather narrow, then the rest of the space can be adjusters, etc

---------------------------------------------------------------------
make one and one only draw_lift
---------------------------------------------------------------------

// this is it....the one base function that draws a lift
void draw_lift(int l, int x1, int y1, int x2, int y2)
{
   int color = lifts[l].color;
   int a;

   // faded outer shell
   for (a=0; a<10; a++)
     al_draw_rounded_rectangle(x1+a, y1+a, x2-a, y2-a, 4, 4, mC.pc[color + ((9 - a)*16)], 2 );

   // solid core
   al_draw_filled_rectangle(x1+a, y1+a, x2-a, y2-a, mC.pc[color] );

   // name
    al_draw_textf(font, mC.pc[color+160], (x1+x2)/2, (y1+y2)/2 - 3, ALLEGRO_ALIGN_CENTRE, "step:%d val:%2d", lifts[l].current_step, lifts[l].val1);
}



removed this from void highlight_current_lift(int l)

   // draw lift
   int a;
   for (a=0; a<10; a++)
      al_draw_rectangle((x1+a)*db/20, (y1+a)*db/20, (x2-a)*db/20, (y2-a)*db/20, mC.pc[color+ (9-a)*16], 1 );
   al_draw_filled_rectangle((x1+a)*db/20, (y1+a)*db/20, (x2-a)*db/20, (y2-a)*db/20, mC.pc[color] );

//   if ((lifts[l].width == 1) && (lifts[l].height > 1)) // rotate lift name for vertical lifts
//      rtextout_centre(NULL, lifts[l].lift_name, ((x1+x2)/2)*db/20, ((y1+y2)/2)*db/20, color+160, (float)db/20, 64, 1);
//   else

      rtextout_centre(NULL, lifts[l].lift_name, ((x1+x2)/2)*db/20, ((y1+y2)/2)*db/20, color+160, (float)db/20, 0, 1);



places I have used it:
-------------------------
draw_lifts()
int lift_editor(int lift)
void draw_fsel(void)


places I have checked:
-----------------------
e_lifts
z_lifts

places I have left...
the text editor ?? in menu

void draw_item_info(int x, int y, int color, int type, int num)
{
   int a, b;
   switch (type)
   {
      case 1:
         al_draw_bitmap(btile[num&1023], x, y, 0);
         al_draw_textf(font, mC.pc[color], x+22, y+2, 0, "Block #%d",num&1023);
         al_draw_textf(font, mC.pc[color], x+22, y+12, 0, "%s", get_text_description_of_block_based_on_flags(num) );
      break;
      case 2:
         draw_item_shape(num, x, y);
         a = item[num][0]; // type
         al_draw_textf(font, mC.pc[color], x+22, y+2, 0, "%s", item_name[a]);
         al_draw_textf(font, mC.pc[color], x+22, y+12, 0, "%d of %d", 1+num - item_first_num[a],item_num_of_type[a]);
      break;
      case 3:
         draw_enemy_shape(num, x, y);
         a = Ei[num][0]; // type
         al_draw_textf(font, mC.pc[color], x+22, y+2, 0, "%s", enemy_name[a]);
         al_draw_textf(font, mC.pc[color], x+22, y+12, 0, "%d of %d", 1+num - e_first_num[a],e_num_of_type[a]);
      break;
      case 4:
      {
         int col = lifts[num].color;
         int width = lifts[num].width;
         if (width > 140) width = 140;
         for (a=0; a<10; a++)
            al_draw_rectangle(x+a, y+a, x+(width)-1-a, y+19-a, mC.pc[col+((9-a)*16)], 1 );

//         if ((lifts[num].width == 1) && (lifts[num].height > 1)) // rotate lift name for vertical lifts
  //          rtextout_centre(NULL, lifts[num].lift_name, x+(width*10), y, color+160, 1, 64, 1 );
    //     else
            al_draw_text(font, mC.pc[col+160], x+(width/2), y+6, ALLEGRO_ALIGN_CENTER, lifts[num].lift_name);
      }
      break;
      case 5:
         a = PDEi[num][1]; // bmp or ans
         if (a < NUM_SPRITES) b = a; // bmp
         if (a > 999) b = zz[5][a-1000]; // ans
         al_draw_bitmap(tile[b], x, y, 0);
         a = Ei[num][0]; // type
         al_draw_text(font, mC.pc[color], x+22, y+2, 0, "Special Item");
         al_draw_textf(font, mC.pc[color], x+22, y+12, 0, "%s", PDEt[num][1]);
      break;
   }










-----------------------------------------

20220415 3:48AM


I have a block of uninterrupted time.
I am going to try to finish polishing up lift viewer
Then I am going to implement more of my lift improvements...

To start with...

finish list of steps with header...

why does the highlight and mouse_pointer and chosen current step not line up since I added header row?

when I draw steps, i use -1 for the header row

I pass ysb to draw_steps

I draw the frame at y1 = ysb

the buttons start at ya (ysb+fs) // frame size = 14

I draw the row header at ya + (a*bts) a = 0;

i draw step button 0 at  ya + (a*bts) a = 1;


so back in lift viewer I calculate the mouse highlight step with:

if ((mI.mouse_x > xa + 10) && (mI.mouse_x < xb - 10))         // mouse on step buttons
{
   int step0_y_offset = ysb + 14 + bts;
   int step = (mI.mouse_y step0_y_offset) / bts;           // calculate step that mouse is on
   if ((step >= 0) && (step < lifts[lift].num_steps))   // is step valid



this works...i have a few tweaks...

step -1 draws....

because -1 marks a not valid highlight selection....fixed to -99

lower the bottom of the inside of frame by 2 pix...done
make the highlight not spill outside the button so much...done

that looks great..

now finish the row header...done
looks great

fix names of sliders to remove step# done...

move all lift related buttons and slider numbers to 500-599

buttons:500-549

   if (bn == 500) // lift mode
   if (bn == 501)
   if (bn == 502)
   if (bn == 503) sprintf(smsg, "Parameters");    // show row header

504   29 lift name

505   74 end step...



sliders:550-599

550   if (bn == 72) sprintf(smsg, "Timer:%-3d",lift_steps[type][num].val);
551   if (bn == 73) sprintf(smsg, "Distance:%-3d",lift_steps[type][num].val);
552   if (bn == 105) sprintf(smsg, "Speed:%d", lift_steps[type][num].val); // lift step resize time
553   if (bn == 106) sprintf(smsg, "Width:%d", lift_steps[type][num].w); // lift step resize time
554   if (bn == 107) sprintf(smsg, "Height:%d", lift_steps[type][num].h); // lift step resize time
done

fix name edit location and draw mode...done

now can I finally move on to making new stuff?

6:00AM

I just looked back in the notes for other things I wanted to add.


- option to make the lift invisible (probably use a flag)
- option to make the lift affect things differently
- player, enemies, items
- maybe even direction to (like an option to make the lift only raise the player, not push sideways or down)



- better indication of when it will disappear...did a nicer progress bar...good for now

- set the time the player can be away before reset in mode 1
val1 runs the counter
val2 sets the counter
make a slider...all done


bug --- when in mode 1, when moving to original step 0, step is actually 0 and the reset away timer does not activate
right now it looks for step>0...how about step != 1

does this break the shit where step 1 should be prox?
now step 1 while moving does not reset...

I should just ignore that and let the timer reset..that works...
I just need a way to hide the reset indicator when sittin at step 0 not moved..done



- new step wait on external trigger
type 5 - wait trig
x,y,w,h - not used
val - trigger event

lifts[lift].limit_type = 5; // wait trigger
lifts[lift].limit_counter;  // event number

case 5: // trigger wait
   if (pm_event[lifts[l].limit_counter]) next_step = 1;
   pm_event[lifts[l].limit_counter] = 0; // clear the trigger
break;

case 5: // wait trig
   lifts[l].limit_type = 5; // wait trig
   lifts[l].limit_counter = lift_steps[l][step].val;
break;



      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Time", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0, 100, 2);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Prox", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0, 80, 3);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Trig", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0,  0, 5);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Done", c1, c2, 1)) quit = 99;


   if (bn == 502)
   {
      if (num == -1) sprintf(smsg, "Type");  // show row header
      if (num == 1)  sprintf(smsg, "Move and Resize");
      if (num == 2)  sprintf(smsg, "Wait for Timer");
      if (num == 3)  sprintf(smsg, "Wait for Player");
      if (num == 4)  sprintf(smsg, "End Step");
      if (num == 5)  sprintf(smsg, "Wait for Trigger");
   }


added slider 556 for event trigger

added to list of steps and step details

holy shit it works!!! that was so easy to do..

rather than manually setting event, how do I do it in other cases?...


   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 320,  num, type, obt, 0, 13, 15, 15, 1,0,0,0); a+=2; // set trigger
      if (bn == 320)
      {

         int i = get_trigger_item("Select A Trigger To Link To", 2, item[num][0], num );
         if (i > -1)
         {
            int ev = get_unused_pm_event();
            item[num][1] = ev;

            if (item[num][0] == 16) // block manip
            {
               if (item[num][3] == 3) // mode 3 - toggle blocks
               {
                  item[i][11] = 0;
                  item[i][12] = 0;
                  item[i][13] = ev;  // needs a toggle trigger
                  item[i][14] = 0;
               }
               else
               {
                  item[i][11] = ev;  // regular trigger
                  item[i][12] = 0;
                  item[i][13] = 0;
                  item[i][14] = 0;
               }
            }

            if (item[num][0] == 17) // block damage
            {
               if (item[num][11] == 1) // mode 1 - toggle damage
               {
                  item[i][11] = 0;
                  item[i][12] = 0;
                  item[i][13] = ev;  // needs a toggle trigger
                  item[i][14] = 0;
               }
               else
               {
                  item[i][11] = ev;  // regular trigger
                  item[i][12] = 0;
                  item[i][13] = 0;
                  item[i][14] = 0;
               }
            }


         }
         Redraw = 1;
      }


make my own button



when I call button i pass bn, lift, step

button calls them num and type then passes them to:
fill_smsg_button(bn, obt, type, num);


then I call
int i = get_trigger_item("Select A Trigger To Link To", 4, type, num );

int get_trigger_item(const char *txt, int obj_type, int sub_type, int num )

so num = step and st=lift

this is so confusing!!!

num should always be the index to the obj(item, enemy, lift)...
the second number can be whatever else...
num should alway come right after the button num...


the whole trigger lift thing works great...
by default, if event trigger is zero it is skipped??
I think all trigger item set 0 every frame.....

it looks like it is one pixel bigger when waiting for trigger??
fixed....

so all the trigger stuff working great....

- option to make the lift invisible (probably use a flag)
- option to make the lift affect things differently
- player, enemies, items
- maybe even direction to (like an option to make the lift only raise the player, not push sideways or down)

implement some flags...

#define PM_LIFT_NO_DRAW          0b00000001
#define PM_LIFT_SOLID_PLAYERS    0b00000010
#define PM_LIFT_SOLID_ENEMY      0b00000100
#define PM_LIFT_SOLID_ITEM       0b00001000


make items that follow lift also able to take the exact size of the lift




make a level about running down a hall way and getting smashed by lifts from above


bug with triggers....

if the lift is not in the right step to detect the trigger, it will wait until it is...
I want to erase unused triggers from other steps


at the end of move lift,
cycle step and clear mentioned events...done

make pop up menu for new steps, one step bigger...done


this is so awesome!....make new levels


20220415 10:00 AM push


Redid much of the lifts code, increased size of lifts and lift steps
Implemented many new features for lifts, like resizing, triggers, reset when player not riding
Many improvements to the lift viewer in level editor

make lift steps that can turn on and off the solid effects, change color, etc

change color step!!



make it so that level editor remembers where you were...
like level, viewer and obj type
save it in config file
how about like a bookmark in level editor?
B to load and SHIFT B to set...

int bookmark_level = 0;
int bookmark_obj = 0;
int bookmark_num = 0;

extern int bookmark_level;
extern int bookmark_obj;
extern int bookmark_num;

added to save and load config




where am I going to put this?


in obt_viewer and lift viewer for the save...

load in edit menu..



   if (level_editor_running)
   {
      if (mI.key[ALLEGRO_KEY_B])
      {
         while (mI.key[ALLEGRO_KEY_B]) proc_controllers();


         if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT]))
         {
            printf("save bookmark\n");

            bookmark_level = last_level_loaded;
            bookmark_level = last_level_loaded;



            save_config();
         }
         else
         {
            printf("load bookmark\n");

         }
      }
   }


start with lift...
added to lift viewer and it works...


      if (mI.key[ALLEGRO_KEY_B])
      {
         while (mI.key[ALLEGRO_KEY_B]) proc_controllers();
         if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT]))
         {
            printf("save bookmark\n");

            bookmark_level = last_level_loaded;
            bookmark_obj = 4;
            bookmark_num = lift;
            save_config();
         }
         else
         {
            printf("load bookmark\n");
            if ((bookmark_level == last_level_loaded) && (bookmark_obj == 4) && (bookmark_num != lift))
            {
               if (bookmark_num < num_lifts) lift = bookmark_num;
            }

         }
      }

now edit menu:
if (mI.key[ALLEGRO_KEY_B])
{
   while (mI.key[ALLEGRO_KEY_B]) proc_controllers();
   printf("load bookmark\n");
   if (bookmark_level == last_level_loaded)
   {
      if ((bookmark_obj == 2) && (item[bookmark_num]))       object_viewer(2, bookmark_num);
      if ((bookmark_obj == 3) && (Ei[bookmark_num]))         object_viewer(3, bookmark_num);
      if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) object_viewer(4, bookmark_num);
   }
}
works...

now obj viewer
if (mI.key[ALLEGRO_KEY_B])
{
   while (mI.key[ALLEGRO_KEY_B]) proc_controllers();
   if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT]))
   {
      printf("save bookmark\n");
      bookmark_level = last_level_loaded;
      bookmark_obj = obt;
      bookmark_num = num;
      save_config();
   }
   else
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
          if ((bookmark_obj == 2) && (item[bookmark_num]))
          {
             obt = 2;
             num = bookmark_num;
          }
          if ((bookmark_obj == 3) && (Ei[bookmark_num]))
          {
             obt = 3;
             num = bookmark_num;
          }
          if ((bookmark_obj == 4) && (bookmark_num < num_lifts))
          {
             obt = 4;
             num = bookmark_num;
          }
      }
   }
}
works

the only thing that doesn't work yet is lift_viewer to 2 or 3
if (mI.key[ALLEGRO_KEY_B])
{
   while (mI.key[ALLEGRO_KEY_B]) proc_controllers();
   if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT]))
   {
      printf("save bookmark\n");

      bookmark_level = last_level_loaded;
      bookmark_obj = 4;
      bookmark_num = lift;
      save_config();
   }
   else
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
         if ((bookmark_obj == 2) && (item[bookmark_num]))
         {
            ret = 2000 + bookmark_num;
            quit = 1;
         }
         if ((bookmark_obj == 3) && (Ei[bookmark_num]))
         {
            ret = 1000 + bookmark_num;
            quit = 1;
         }
         if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) lift = bookmark_num;
      }
   }
}
now it does...

to use:

Save Bookmark of current viewer object
when in any viewer, item, enemy, lift
SHIFT B to save

Load bookmark

from any viewer or edit menu
B to load...


now to set up auto load....


change color step!!

flags
1 line in draw:
if (!(lifts[l].flags & PM_LIFT_NO_DRAW))

make a button to toggle it...

while we are at it make buttons to toggle all flags...

hide works good...hide lift lines too....done
maybe later make it its own toggle


now see if I can patch in solids

old:
   if (lift_check)
      for (int d=0; d<num_lifts; d++)
         if (solid_x > lifts[d].x1-18)
            if (solid_x < lifts[d].x2-2)
               if (solid_y > lifts[d].y1 - 25)
                  if (solid_y < lifts[d].y1 - 10)
                      return d+32;


new:
   if (lift_check)
      for (int d=0; d<num_lifts; d++)
         if ( ((type == 1) && (lifts[d].flags & PM_LIFT_SOLID_PLAYER)) ||
              ((type == 2) && (lifts[d].flags & PM_LIFT_SOLID_ENEMY )) ||
              ((type == 3) && (lifts[d].flags & PM_LIFT_SOLID_ITEM  )) )
            if (solid_x > lifts[d].x1-18)
               if (solid_x < lifts[d].x2-2)
                  if (solid_y > lifts[d].y1 - 25)
                     if (solid_y < lifts[d].y1 - 10)
                         return d+32;


that was easy...

now can I set these flags for each step??
or I can have base flags, and steps can change them
I would need a special step to do this...
if steps change the flags in lift, there will be no way to go back to the original
unless I do what I do for x, y, w, h in step 0...

can I also encode flags in move steps? what about color? I only need 4 bits for color...



I just broke all existing lifts...
by default flags are all zero and none are solid

what if I swap it around so zero is solid and 1 is passthrough?

Or I could just glt it and change all existing....done

now make it so that newly created one have those flags...done....

push

20220415 4:44 PM

damage range potential improvements
make the player damage the amount and the retrigger time..
time 1 would be every frame, etc...

I really think I should encode the flags in every move step
I could easily put 4 bits of color and flags in step type...


how many bit should I reserve for step type?
5-6 for 32-64

color needs 4 bits for 16 colors

i currently use 4 bits for flags..

I have lots left over...

lowest 5 for step type
next 4 for color_name
then remaining for flags




when I do these with a move step, do they take effect at the end of the step
or the start....I think the end...
when I insert a step in between 2 others what step I copy?

right click on step and choose copy from previous, copy from next.

then alter what I want...

make some funtions to extract what I need from step and put it in lift vars


lift_step[l][s].type & 31 -- step type

flags should be obvious like all other flags

color should be the highest 4 bits...
shift 28 to get it...

how do I start implementing this?

lets just do color...

add color button to step type 1


to start with add & 31 to all type checks...done for all of e_lifts and z_lifts

next I should use glt to put color in all step type 1 ....

how?

take color and shift it 28 bits...
combine with type...



int temp = color << 28



lift_step[l][s].type |= (color << 28)

color = lift_step[l][s].type >> 28;


this works:
if ((lift_steps[lift][step].type & 31) == 1)

this does not:
if (lift_steps[lift][step].type & 31 == 1)


this is how you set color:
first you have to clear those 4 bits
lift_steps[num][type].type &= 0b00001111111111111111111111111111; // clear old color

then shift the 4 bits into place
int cf = color << 28;

lift_steps[num][type].type |= cf; // lift color


this is how you have to extract color:
col = (lift_steps[l][0].type >> 28) & 15;
you cannot just do the shift because sign bits are inserted instead of zero's


then I can put some flags in there too...

first of all make the buttons to toggle flags

the rest of the lift stuff should work, no matter how the extra flags are set...

I should make the flags from the step, line up with the main lift flags...
to make it easier to copy across...

hell I could make flags and color do that... then all I would have to do is copy the flags

across when a new move step happens...
i could make the flags also do stuff when in wait type steps...why does it have to only be move steps?

re-arranged flags

#define PM_LIFT_COLOR_BITS       0b11110000000000000000000000000000
#define PM_LIFT_NO_DRAW          0b00001000000000000000000000000000
#define PM_LIFT_SOLID_PLAYER     0b00000100000000000000000000000000
#define PM_LIFT_SOLID_ENEMY      0b00000010000000000000000000000000
#define PM_LIFT_SOLID_ITEM       0b00000001000000000000000000000000

re-do glt and put color and default flags in ALL steps, not just move steps...

restore levels...
iterate all valid lifts and steps
mask off everthing except lowest 5 bits

add color...
add default solid flags



20220418 5:00 AM
all my colors are gone

went to a prev version of levels...

got the color back....
have not erased from main lift..

now make copy from steps happen...

lifts[lift].flags = lift_steps[lift][step].type; // get all the flags from the step type

done in:
void set_lift_to_step(int lift, int step)
and in move lifts when setting a new step


now make color come from this place:
flags upper 4 bits
I think it mostly does..its read from the step in draw lift lines...


in draw_lift and draw_lifts:

old:   int col = lifts[l].color;
new:   int col = (lifts[l].flags >> 28) & 15;

in set xyinc, removed  done when changing any step...



ok we are moving along here...
- all steps have color and flags embedded in type....
- they are copied to main lift flags for every step...
- lifts[].color is not used anymore...color is embedded in flags

now I need add color and solid flags to move step buttons...


added 510-513...


fixed the goddam button and slider bullshit calling order for all lift stuff...
call it in this order... lift, step....

button bn, num, type, obt
slider bn num, type, obt

all must be called in e_lifts.cpp


colsel 8 uses l, s


slider...done
550
551
552
553
554
556

button...done
505
510
511
512
513
520

use sl...fix...

500
504
use l only...good


new lift defaults
color and solids



all steps need flags buttons...done

need a way to show current step color....


make list of step buttons, not the place to edit, just show

x, y, w, h if applicable

color

flags??




bug player can't drop item on lift...it falls through....





make two versions of construct_lift_step



sets all parameters:
int construct_lift_step(int l, int s, int type, int x, int y, int w, int h, int val)


copies from previous step:
int construct_lift_step(int lift, int step, int type);
if new step is a move step, get xywh fwom previous move step
always get flags from prev step even if not move step

push
20220418 7:41 AM


how about if contruct lift step is passed a type < 16, then assume you want the rest copied from a previuos step...
no end step??
default speed = 80??



make list of step buttons, not the place to edit, just show

make type much shorter

1 move
235 wait
4 end


I want to make button capable of left justified text...

q4 for slider4 makes the fading in or out...


if going to use q5 for button centering.
0 default..centered
1 left justified..done..



I think I have this stuff pretty much done...
I should do some tests and see if everything works...

How to see hidden lifts in level editor...use color 0

color for step 0 does not show...instead color of loop to zero shows...

lift steps are kind of non-intuitive...

the place where I show them is where they will end up.. the place they come from is alway the lift before

when you are in a current move step, you are always behind where it shows in level editor...
maybe in level editor I should also show the prevous step with an an arrow on the line....


If I set step 0 to be the same as end step, lift lines and color do what I expect...
step 0 does not matter...only step end...
test by setting step 0.....does not line up...

lift lines are set by only looking for move steps, they should look at all...no..just no...

keep end step the same color as first and alll will be good.


now I want to try making my smash lifts shows warning color change...

looks good...

push for lunch...12:00


I would like to be able to hide the timer counter...
three options: hide, number, progress bar

the same with the lift mode reset....






bug - cant's detect lifts from object viewer map mode...fixed

bug - copy and paste lifts in zfs...done
pastes lift but no steps...fixed

bug - lifts has color 0 when editing text...fixed


add lift resize to map move options....


make a level with a long wide rising floor.







I want to make my button stuff simpler?, easier?
integrate fill smsg into button routine
check for mouse press at start
do one pass through...if or switch case  for each button number..
set the text there
process click there
at the end draw the common text...
i can do them one by one...removing the fill smsg entry...
done...now it is just one big monlithic function with a section for each button number
there you set how it displays and what happens when it is pressed.
in one place, instead of two...this should make it easier instead of scrolling up and down for pages
to work with buttons...


push

20220419 7:20 AM

make an option to hide lift lines. per step or for entire lift
per lift...just another flag...done



make some buttons to apply to all lift steps...
like right click on a step and get:
-apply size to all steps
-apply flags to all steps
-apply color to all steps...etc
all these are done from step 0....

in lift viewer make up and down arrow move current step....done

make a step or mode that is frozen or not based on a trigger....



working on map move to resize lift step..got too tired
8:43 PM

5:46 AM got the map resize thing to work just like I wanted...


what if I force end step to have same color as step 0?
same draw and line mode too, why would I ever want them to differ?
no time is ever spent in last mode, unless it freezes there...
in that case I might want something different...
leave it the way it is for now...


I want some sort of checkpoint system...

I juts made a long complicated level and I did not consider that if the player died he could not continue from start..


I could make multiple starts, each with a number...

I could make it so the last touched start is the one that you respawn at...per player or for all players?
maybe both

----------------------------
normal:
only one start
----------------------------

--------------------------------
all players common:
have a flag, current spawn point
if set to 1 then all players use this..

when any player touches it, that becomes the new current spawn point
there can only be one active at any time
----------------------------------

------------------------------------
each player has their own current spawn point
saved in player struct

each start will need an index
-------------------------------------------

whatever plan i use I want it to take all uses into account
the most complicated would be multi player where each player has their own spawn point..
I don't know how I would do teams...so for now I would just split them based on odd/even player number


----------------------------------------
team spawn:
item[][5] - team spawn
0 = off
1 = for odd players
2 = for even players
-----------------------------------------


----------------------------------------
common spawn:
item[][6] - common spawn
0 = off
1 = on

if on, then of all spawn points only one can be currently active
item[][8] - current active spawn point

if off, then each player keeps track of index of their own current spawn point





-----------------------

would it not be easier for player to keep track of that in all cases?
how hard is is to add a variable to player struct that is synced?

call it spawn_point_index

most of the time it will be zero, and link to spawn index 0..

when starting a level, if there is only one start, players have that set..

if there are multiple starts, and the starts are marked as team, then players will get corresponding starts...

as the level is played, if a player touches a start, their spawn point index will change

if the spawn point is marked team, then player much match team for it to be updated

otherwise all players can touch any spawn...

to make this work...

add spawn_point_index to player struct...
and make sure that does not break anything....

then starts need to be modified:

7 = index
----------------------------------------
team spawn:
item[][8] - team spawn
0 = off
1 = for odd players
2 = for even players
-----------------------------------------




20220420 9:20

before:

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105920

added 'int spawn_point_index;' to 'player' struct

Variables used for netgame state exchange

players  :  1472
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105952

32 bits larger

//#define STATE_SIZE 105920
#define STATE_SIZE 105952



void set_player_start_pos(int p)

called from load_level for all 8 players
called when player becomes active...
called after death

single player no teams...
p0 gets index 0 set in player struct at level load..


modify set_player_start_pos(int p)

set_player_start_pos(int p, int cont)

if (cont == 0) set to initials
like load level and player comes active

cont == 1; // is for respawning



void set_player_start_pos(int p, int cont)
{
   if (cont == 0) // players initial entry
   {
      players[p].spawn_point_index = 0;
   }


   if (cont == 1) // players re spawn
   {
      for (int i=0; i<500; i++)
         if ((item[i][0] == 5) && (item[i][7] == players[p].spawn_point_index))
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];

         }
   }


now make some code for collision with start...


void proc_start_collision(int p, int i)
{
   players[p].spawn_point_index = item[i][7];
}


this works great!

I want to see a change in the start that is active
this could be a good opportunity to make some new tiles

how about when ever player collision with lift, mark it and unmark all others...
11 still
21 scroll
void proc_start_collision(int p, int i)
{
   players[p].spawn_point_index = item[i][7]; // set new spawn point

   // mark this one as active and all others as not
   for (int ii=0; ii<500; ii++)
      if (item[ii][0] == 5)
      {
         if (item[ii][7] == item[i][7]) item[ii][1] = 1021;
         else item[ii][1] = 1011;
      }
}

all this works great for single player, but not so good more multi..

any player can trigger new starts..








I want to add the ability to trigger with events. so the player does not have to actually touch the start..




I want to be able to draw a lift with blocks....

Make archwagon able to turn around before hole, not jump...









starts and modes...


team mode vs single player

with single player, all players have the same start


maybe a bunch of modes...

0 = normal default regular...exactly one start and everyone uses it the same way
- 1 start

1 = team
- 2 starts (0 and 1)
- even/odd player number split

2 = checkpoint common
- 2 or more starts
- all players use current start
- any player can set any checkpoint

3 = checkpoint individual
- 2 or more starts
- each player can set their own checkpoint
- all players start at checkpoint zero


this will all be set in start block with index zero..

what variable do I have to play with:

6-13

item[][6] - mode
item[][7] - index

made a button...

this all works exactly like I thought it would...

how can I show this for individual?  don't for now...



New write up for starts...

Mode:Default
- there is only one start with start index 0
- all players uses this start

Team Start
- 2 start blocks with index's 0 and 1
- even numbered players use start 0
- odd numbered players use start 1

Checkpoint Common
- 2 or more starts with indexes 0,1,2 etc...
- all players initially start at start 0
- when any start is touched by any player...
- that start becomes the new spawn point for all players


Checkpoint Common
- 2 or more starts with indexes 0,1,2 etc...
- all players initially start at start 0
- when a start is touched by a player...
- that start becomes the new spawn point for only that player



in help...I need to distinguish between tiles and btiles...

        if (strncmp(msg, "<s", 2) == 0) // <sxxx> show shape left just)
        if (strncmp(msg, "<ms", 2) == 0) // <msxxxxxxx....> show 20 shapes (left just)

        if (strncmp(msg, "<ac", 3) == 0) // <acxxx> show animation sequence (centered)
        if (strncmp(msg, "<a", 2) == 0) // <axx> show animation sequence (left just)


help has been fixed...made a few new tags...

            if (strncmp(msg, "<ab", 3) == 0) // <axx> show animation sequence (left just) // for block tiles instead of tiles
            else if (strncmp(msg, "<a", 2) == 0) // <axx> show animation sequence (left just)

            if (strncmp(msg, "<sb", 3) == 0) // <sxxx> show shape left just) // for block tiles instead of tiles
            else if (strncmp(msg, "<s", 2) == 0)   // <sxxx> show shape left just)

also in help, fixed the weird allignent issue on the first and last sections that use title and spinning mdw
also in help, completely updated the last section (credits)


now what?
the start improvements are completely done....


what about lifts?
- different drawing methods (blocks) other primitives...
- is that all?

bug---when adding steps in a loop it shows 2 ends...fixed.....



would it be so hard for zoom full screen to be able to paste only flags?

im thinking like a single block type of thing
why think small...

add a filter, block flags..

when on it acts just like blocks


when b abd bf are both on: same as b on now

when b abd bf are both off: same as b off now

when only blocks are on or only flags are on..same as now...

difference is in paste:

if only B then use default flags and ignore existing flags

if only F then ignore shape and just apply flags..


so the only difference would be in the pasting of blocks only...




OK do I want to redo 12 buttons in zfs?


yes I do...

how hard would it be to send a pointer to an int for buttons?
I would have to redo so many things....
every mention of button would need to be redone.
why?
so that I could get the button to manipulate the variable directly...
very useful for toggles....
in all the cases where it is not used send a pointer to a dummy variable...

or...

copy_blocks = button(intin intinint copy_blocks)

BUG - even when flags are off rectangle still show under draw item check boxes...

now that I redid the menu on zfs lets implement the button flags...

looks like it is working for me...

only works in block fill...
must have block filter off and flag filter on
gets flags from draw item, ignores tile, applies to all in range...


      if (draw_item_type == 1) // don't even show these 3 buttons unless...
      {
         if (mdw_button(x3, yfb+a*bts, x4, yfb+(a+1)*bts-2, 610, 0,  0, 0, 0,  9, 15, 0, 1,0,0,0)) // block fill
         {
            for (int x=stx; x<sux; x++)
               for (int y=sty; y<suy; y++)
               {
                  if ((copy_flags) && (copy_blocks))  l[x][y] = draw_item_num;
                  if ((copy_flags) && (!copy_blocks))
                  {
                     int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
                     l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
                     l[x][y] |= flags;                                // merge
                  }
               }
         }






this might be a huge project, but I want to make the randomize stuff work...

if I don't patch it into zfs, it will be something very similar

- make a selction on the map
- from that selection
- narrow it down to a certain type of enemy

I want to be able to do a discontinous selection...
I might need to have a list that I can fill by just rectangle selecting or clicking on individual enemies..

then in that list I can do things...

workflow:
- from obj selection choose cannon
- fill the list by rect selecting or clicking to toggle
- remove and reorder
when list is good
- randomize, increment on selected variables..


cannon will have x, y origin, speed, bullet speed, bullet retrigger, seek count, extra hits to kill

actions

min, max randomize
min max increment/decrement

special for x and y pos
set a box.
randomize in box
evenly space in x axis
evenly space in y axis


what does my list look like?

enemy and item can share?

obj_list[100][2]

obj_lift[][0] = type (0 empty, 1 enemy, 2 item)
obj_lift[][1] = number of item or enemy





I want to start building this:


I like building things like this!

group_edit

make selection buttons
all toggles
one for each enemy and item



I really want to make button toggles so I can do it in one line
send a pointer to the int and text true and text false


make a new type of button that does just that...


int mdw_button( int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )
void mdw_slider(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )
void mdw_colsel(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )



int mdw_toggle( int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7, int &var, int & flags, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1)



int mdw_toggle(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1);


int mdw_togglf(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, int flags, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1);



// here it is...one line
mdw_toggle(x1, yfb+a*bts, x2, yfb+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, copy_blocks, "OFF", "ON", 15, 15, 15+64, 9); // block filter


try it out with int from an array
key...
mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, item[num][12], "Erase All Blocks In Range ", "Erase Only Matching Blocks", 15, 15, 4, 4); a++; // range type
works...

it makes the call more complicated...
from:
mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 48, num, type, obt, 0,  4, 15,  0, 1,0,0,0); a++; // range type
to:
mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, item[num][12], "Erase All Blocks In Range ", "Erase Only Matching Blocks", 15, 15, 4, 4); a++; // range type

but....
-I don't need custom button code for each type
-I can change colors of text and frame without custom code



try out togglef for trigger draw...

old:

if (FLAGS & PM_ITEM_TRIGGER_DRAW_ON)
{
   int col = item[num][2];
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 201,  num, type, obt, 0, col, 15, 15, 1,0,0,0); a++; // Draw on/off
   mdw_colsel(xa, ty+a*bts, xb, ty+(a+1)*bts-2,  6,   num, type, obt, 0,  0,   0,  0, 0,0,0,0); a++; // color select
}
else
{
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 201,  num, type, obt, 0, 15+96, 15+96, 15, 1,0,0,0); a++; // Draw on/off
}
a++;

new:
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0,item[num][3], PM_ITEM_TRIGGER_DRAW_ON, "Draw Trigger Field:OFF           ","Draw Trigger Field:ON            ", 15+96, 15, 15+96, item[num][2]); a++; // Draw on/off
if (FLAGS & PM_ITEM_TRIGGER_DRAW_ON)
{
   mdw_colsel(xa, ty+a*bts, xb, ty+(a+1)*bts-2,  6,   num, type, obt, 0,  0,   0,  0, 0,0,0,0); a++; // color select
}
a++;

OK...it works....

this could simplify some stuff...

old:
if (FLAGS & PM_ITEM_TRIGGER_PLAYER) { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 202, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 202, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_ENEMY)  { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 203, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 203, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_ITEM)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 204, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 204, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_PBUL)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 205, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 205, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_EBUL)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 206, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 206, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }


new:
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_PLAYER, "Triggered by Players:OFF         ","Triggered by Players:ON          ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_ENEMY,  "Triggered by Enemies:OFF         ","Triggered by Enemies:ON          ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_ITEM,   "Triggered by Items:OFF           ","Triggered by Items:ON            ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_PBUL,   "Triggered by Player's Bullets:OFF","Triggered by Player's Bullets:ON ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_EBUL,   "Triggered by Enemy's Bullets:OFF ","Triggered by Enemy's Bullets:ON  ", 15+d, 15, 14+d, 14); a++;

also removed:

   if (bn == 201) // Item Trigger Draw Type
   {
      if (item[num][3] & PM_ITEM_TRIGGER_DRAW_ON) sprintf(smsg,"Draw Trigger Field:ON            ");
      else                                        sprintf(smsg,"Draw Trigger Field:OFF           ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_DRAW_ON;
   }
   if (bn == 202)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_PLAYER) sprintf(smsg, "Triggered by Players:ON          ");
      else                                       sprintf(smsg, "Triggered by Players:OFF         ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_PLAYER;
   }
   if (bn == 203)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_ENEMY)  sprintf(smsg, "Triggered by Enemies:ON          ");
      else                                       sprintf(smsg, "Triggered by Enemies:OFF         ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_ENEMY;
   }
   if (bn == 204)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_ITEM)   sprintf(smsg, "Triggered by Items:ON            ");
      else                                       sprintf(smsg, "Triggered by Items:OFF           ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_ITEM;
   }
   if (bn == 205)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_PBUL)   sprintf(smsg, "Triggered by Player's Bullets:ON ");
      else                                       sprintf(smsg, "Triggered by Player's Bullets:OFF");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_PBUL;
   }
   if (bn == 206)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_EBUL)   sprintf(smsg, "Triggered by Enemy's Bullets:ON  ");
      else                                       sprintf(smsg, "Triggered by Enemy's Bullets:OFF ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_EBUL;
   }


yes...this is nice...
lets move on....

I want to be able to select any combination of enemy and items type...
where will I store that?

int obf_filter[2][20] = {0};

obf_filter[1][num] = item types
obf_filter[2][num] = enemy types


1 door
2 bonus
3 exit
4 key
5 start

mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, obj_filter[2][1], "Door:ON ", "Door:OFF", 15+64, 15, 15, 4); a++;



I have all the selection filters done...

now make it so that obj in the filter are marked on screen...done
now only filtered obj can be added to the list...done



now lets work on the list....

when adding, don't allow duplicates....done

show the list better...did bitmaps...more later

if mouse on map item that is in list, flash that item in the list
and vice versa


how am I going to mark things on the map?
- things that can get added to list (lt blue)
- things already added to list (red)
- mouse pointer (white)

if (++highlight_counter > 16) highlight_counter = 1;
if ((highlight_counter > 0)  && (highlight_counter < 5)) title_obj(obt, type, num, legend_line, 10);
if ((highlight_counter > 4)  && (highlight_counter < 9)) title_obj(obt, type, num, legend_line, 14);
if ((highlight_counter > 8)  && (highlight_counter < 13)) title_obj(obt, type, num, legend_line, 15);
if ((highlight_counter > 12) && (highlight_counter < 17)) title_obj(obt, type, num, legend_line, 11);

now back to making the list look better....

detect if mouse is on the list and what list item

should I do that at the same time as draw??

frame list after drawn, because then you know ho long it will be...done

move list off the map...done
add legend line...done
when mouse is on list item, mark as highlighted...done

problem with highlight showing when we have co-located objects on map...fixed....

now what?

I need a way to remove things from the list...done
draw rect around highlighted item in list...done
remove with SHIFT mouse_b1...works
and maybe re-order...done with mouse drag move

and when a filter is de-selected, remove that object type from list...done...

bug..can't add enemies to list...fixed...


OK... now I can add to list, delete, filter, rearrange....

what is next?

now based on what is in the list, show some options, if applicable to things in the list....
nice! I just came up with that on the spur of the moment...

everything can do randomize x y pos, but for some it makes little sense...


here is a list of all objects

[2][1] Door
[2][2] Bonus
[2][3] Exit
[2][4] Key
[2][5] Start
[2][7] Mine
[2][8] Bomb
[2][9] Trigger
[2][10]Message
[2][11]Rocket
[2][12]Warp
[2][14]Switch
[2][15]Sproingy
[2][16]Block Manip
[2][17]Block Damage
[3][3] Archwagon
[3][4] Bouncer
[3][6] Cannon
[3][7] Podzilla
[3][8] Trakbot
[3][9] Cloner
[3][10]Field
[3][11]Block Walker
[3][12]Flapper


list of obj that can have x y randomized
its most of them!!!

[2][1] Door
[2][2] Bonus
[2][3] Exit
[2][4] Key
[2][5] Start
[2][7] Mine
[2][8] Bomb
[2][10]Message
[2][11]Rocket
[2][12]Warp
[2][14]Switch
[2][15]Sproingy

[3][3] Archwagon
[3][4] Bouncer
[3][6] Cannon
[3][7] Podzilla
[3][8] Trakbot
[3][9] Cloner
[3][10]Field
[3][11]Block Walker
[3][12]Flapper



bouncer and cannon:
Ei[b][8] = (int) mdw_rnd(1, 4); // seek count
Efi[b][5] = al_ftofix(mdw_rnd(2, 5)); // seek speed
initial direction (random for point at start block)

cannon:
Ei[b][9] = (int) mdw_rnd(0, 4); // extra hits to kill
Ei[b][8] = (int) mdw_rnd(1, 4); // seek count
Efi[b][5] = al_ftofix(mdw_rnd(2, 5)); // seek speed
Efi[b][7] = al_ftofix(mdw_rnd(3, 8)); // bullet speed
Ei[b][15] = (int) mdw_rnd(60, 200); // bullet retrigger
initial direction (random for point at start block)


lets try implementing just seek speed for now.
just to get the frame work going

have separate function for all of them?



int ge_seek_speed(int e)
{



}



min max random
min max inc/dec
set to value



make a function to search list and find out what modify functions apply.

if selection has only enemy type 6




I am making some custom blocks of code to edit groups, but

they get called every frame and I want them to have some persistant data storage..



struct ge_datum
{
   char name[40];

   int type;   // 2=item, 3=Ei, 4=Efi
   int varnum; // index of the variable

   int adj_mode;
   float adj_min;
   float adj_max;

   float min_allowed;
   float max_allowed;
}

struct ge_datum ge_data[20];




make a new slider that you can pass a pointer to the var as well as limits and var type..
and format display string

I need to amke versions for int and fixed beacuse I can't pass pointers to unknown variable type

void mdw_slider2_int(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                 int &var, float sul, float sll, float sinc, char *txt)


lets test this out...

health bonus...

   if (bn == 1) sprintf(smsg, "Health Bonus:%d", item[num][7]);

   if (bn == 1) item[num][7] = (int)f;      // health bonus

      case 1:  sul=100;  sll=2;     sinc=1;   sdx=item[num][7];                break;  // health bonus


mdw_slider(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1,  num, type, obt, 0, 12, 15, 15, 1,0,0,0); a++; // health bonus

mdw_slider2_int(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 0,0,0,0,  0, 12, 15, 15, 1,0,0,0, item[num][7], 100, 2, 1, "Health Bonus:"); a++; // health bonus

works....



lets try the fixed version...

if (bn == 19) sprintf(smsg, "Bullet Speed:%-1.1f", al_fixtof(Efi[num][7]));
if (bn == 19) Efi[num][7] = al_ftofix(f);  // bullet speed
case 19: sul=20;   sll=.8;    sinc=.1;  sdx=al_fixtof(Efi[num][7]);      break;  // bullet speed


mdw_slider(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 19, num, type, obt, 0,  9, 15, 15, 1,0,0,0); a++;  // bullet speed
mdw_slider2_fix(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 0,0,0,0,0,  9, 15, 15, 1,0,0,0, Efi[num][7], 20, 0.8, 0.1, "Bullet Speed:"); a++;  // bullet speed

works...

now a float version....done...

now back to ge_data...

extend buttont to be able to be pressed too....done



I have the randomize working...

I want to show variables in the list...
if when checking the list for ge that apply also use that to show that var in list...

this is all coming along nicely...

I want to make the selection thing add everything to list....done

now I want to add seek speed...done
and in doing so, make the ways of doing it more generic


now I need to make the list wider to account for all the extra columns...

And I can start on making the ge's look nicer..much nicer...

add another ge then fix list

bullet speed
bullet retrigger

done...

now move the list...or
move the filter buttons to be right justified with screen edge...

the list is looking good now...

can bullet speed and retrigger be applied to other enemies?
Archwagon yes for both
podzilla yes for speed only
trakbot yes for both
flapper yes for both

fucking beautiful...

what next to add...

bullet prox
Ei[][17]
for both archwag and trakbot

               Ei[b][2] = (int) mdw_rnd(0, 2);  // initial direction


archwag:
initial direction...done
8 ge's already...



bouncer:
initial direction
could have random shapes...

cannon:
initial direction






trakbot:
initial direction...done

flapper:
initial direction
same as archwag...done




why does flapper have 3 variables for bullet prox?
should be redone like trakbot to be a circle
it should calculate the angle and if it's too steep don't fire..
don't get bogged down on it now....put it to do later...

width   = Ei[EN][17]
height  = Ei[EN][18]
depth   = Ei[EN][19]

now some fun stuff...

initial directions...should be all done...



now the big one...common to all...randomize start pos....
for this one I think I will use the selection rectangle to set bounds

how do I use that without affecting anything else...

always show sel...
have a button..add objects in sel window to list

when getting new sel window how to tell between click and click drag...


mode button?
0 click select
1 selection window




I have a much better solution

selection on or off:
when off click one obj at a time

when on show selection and draw new with mouse

then the button add selection does that..

now I can do the initial position for all...done...

I am 90% done, the remaining 10% will take the other 90% of the time...


What do I need to do?

Is there anything from items that you might want to adjust?
mine damage
health bonus
bomb and rocket damage
rocket accell, max speed, steerability
sproingy jump height

what about flapper bullet prox?
bouncer shapes?


there is only one way to remove things from list shift click

make a way so that list, ge and filters can coexist...

collapseable filters??

each filter besides the valid flag should have a hide/show flag
when clicking on the title it will hide/show
done

now make filters smaller...done

hide columns in list if collapsed...done

put ge under list...done....


now this shit is looking real good...

what about podzilla speed?
if (bn == 29) sprintf(smsg, "Speed:%-2.1f", al_fixtof(Efi[num][9]));
   if (bn == 29)                           // pod speed
   {
      Efi[num][9] = al_ftofix(f);
      recalc_pod(num);
   }


void recalc_pod(int EN)
{
   al_fixed xlen = Efi[EN][5] - Efi[EN][0];      // get the x distance
   al_fixed ylen = Efi[EN][6] - Efi[EN][1];      // get the y distance
   al_fixed hy_dist =  al_fixhypot(xlen, ylen);     // hypotenuse distance
   al_fixed speed = Efi[EN][9];                  // speed
   al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
   al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
   al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc
   Efi[EN][2] = xinc;
   Efi[EN][3] = yinc;
   Efi[EN][14] = al_fixatan2(ylen, xlen) - al_itofix(64);  // rotation

   // set number of steps
   al_fixed ns;
   if (abs(xlen) > abs(ylen)) ns = al_fixdiv(xlen, xinc);
   else  ns = al_fixdiv(ylen, yinc);
   int num_steps = al_fixtoi(ns);
   if ((num_steps > 0) && (num_steps < 2000))
      Ei[EN][7] = num_steps;


}
case 29: sul=30;   sll=.5;    sinc=.5;  sdx=al_fixtof(Efi[num][9]);      break;  // pod speed
case 30: sul=40;   sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // pod wait time

needed a special case for pod 4 9
added this three times in do it section...
if ((gvt == 4) && (gvn == 9)) recalc_pod(num);


I want to make a pod with a spline..

tried some levels with a lots more objects...thinking of increasing obj list to 600....700 done...

pause time should not be a part of archwag...fixed

20220424 8:30 PM push...

20220425 5:00AM

added menu item for group edit
made a new source file e_group_edit.cpp
has approx 1000 lines of code....

fix title of object list to not exceed frame...done

rearrange filters so enemys are on top

rearrange ge so x and y speeds are on top...done

next should be initial directions

looking good...all in good order...



commit message:

Created 'Group Edit' for editing group of objects
can randomize or step sets of variables


what about block walker in common with archwagon?...done...


what if I decouple the whole viewer thing from full screen?
have the map part not be the entire screen up in the corner
what if the side panel of viewer buttons was a moveable window in its own right
sitting on top of the normal level display
and the normal level display was zoomable, just like in the game...
wow...mind blown...


can I do it for group edit to start?


mouse pointer item in regular editor show the view window for that item...

I would have to redo the entire object viewer to show the right panel in a window

make a new file..
e_object_viewer_windows.cpp

copy everything from object viewer and make it pop up windows...



make an object for this window

it needs to know

x1, y1, x2, x2

how to draw...

I can also patch it in where real obj viewer is called...done



now how to make it draw map things on the full size map...

how does editor do it?


I can draw the obj location highlight and archwagon prox for now...

working on key block range...


wx, wy are (0-99)

key block ranges are
6 7 x y (0-2000)
8 9 w h (0-2000)


move buttons for each object to its own function...done...
int obj_buttons(int x1, int x2, int ty, int a, int bts, int obj_type, int type, int obj_num)



what are my longest buttons and sliders?

go through them one at a time

archwagon:

Initial Driection:Right    23
Bullet Retrigger Time:100  25



I am making the map draw stuff work for full screen resoltuion, but I think I am on the wrong track...
I need to draw it on the level buffer so that it can be resized to any arbitary size....


do this for ovw for now but later for regular editor also


in the loop draw the background...very similar to how it is done in the game...






      proc_scale_factor_change();

      proc_controllers();

      get_new_background(0);

      draw_lifts();
      draw_items();
      draw_enemies();

      get_new_screen_buffer();

      al_flip_display();


before get new screen buffer is where I need to draw on the level buffer...

after get screen new screen buffer is where I need to draw the button control thing...

this is done and works but kind of sloppy.


I can resize level with F5 and F6

when in viewer all the highlights work..


the speed seems to fast...










i have a few things messed up..

legend line 1 does not blink in legend although frame around item does... for no reason...fixed
buttons don't show for anything....fixed...flip display too soon

animated shapes are smeared....

its like there is an animated shape and a static shape overlaid...


20220427
lets go through it one step at a time....
load level calls init_level_background()
draws blocks and lift lines on level background...

edit menu calls draw_big

void draw_big(int draw_lifts)
{
   init_level_background(); // fill level_background with blocks and lift lines
   draw_level2(level_background, 0, 0, 2000, 1, 1, 1, 1, 0);
   draw_level2(lefsm, 0, 0, db*100, 1, 1, 1, draw_lifts, 0);
   al_set_target_backbuffer(display);
}



what bitmap do these even draw on?...level_buffer


void draw_level2(ALLEGRO_BITMAP *b, int mx, int my, int ms, int blocks, int items, int enemies, int lifts, int players)
{
   if (blocks) get_new_background(1);
   if (valid_level_loaded)
   {
      if (lifts)   draw_lifts();
      if (items)   draw_items();
      if (enemies) draw_enemies();
      if (resume_allowed)
      {
         if (players) draw_players();
         draw_ebullets();
         draw_pbullets();
      }
   }
   if (b == NULL) al_set_target_backbuffer(display);
   else al_set_target_bitmap(b);
   al_draw_scaled_bitmap(level_buffer, 0, 0, 2000, 2000, mx, my, ms, ms, 0);
}


void get_new_background(int full)
{
   al_set_target_bitmap(level_buffer);
   if (full) al_draw_bitmap(level_background, 0, 0, 0);
   else
   {
      // this only grabs the visible region, in the interests of speed
      int x = level_display_region_x - 20; if (x < 0) x = 0;
      int y = level_display_region_y - 20; if (y < 0) y = 0;
      int w = level_display_region_w + 40; if (x+w > 2000) w = 2000-x;
      int h = level_display_region_h + 40; if (y+h > 2000) h = 2000-y;
      al_draw_bitmap_region(level_background, x, y, w, h, x, y, 0);
   }
}

void draw_items(void)
{
   al_set_target_bitmap(level_buffer);


I don't know why....

I found a way around it...
I don't actually need to call proc_frame_delay()
it works just fine without it, doesnt run too fast...
also don't need draw_screen_overlay();

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
//      proc_frame_delay();
      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();
      draw_object_overlays(obt, num, legend_line, highlight_counter);
      get_new_screen_buffer();
//      draw_screen_overlay();
      // draw button title, frame and legend lines
      title_objw(ov_x1, ov_y1, ov_x2, ov_y2, obt, num, 0, 15);

leave it like this for now...move on...

next make the background scrollable just like main editor


int ovw_process_scrolledge(void)
{
   int scrolledge=10;
   int old_wx = wx;
   int old_wy = wy;
   if (mI.mouse_x < scrolledge) wx--;           // scroll left
   if (mI.mouse_x > SCREEN_W-scrolledge) wx++;  // scroll right
   if (mI.mouse_y < scrolledge) wy--;           // scroll up
   if (mI.mouse_y > SCREEN_H-scrolledge) wy++;  // scroll down

   int rx = 100 - (SCREEN_W/20);
   int ry = 100 - (SCREEN_H/20);

   if (wx > rx) wx = rx;
   if (wy > ry) wy = ry;
   if (wx < 0) wx = 0;
   if (wy < 0) wy = 0;

   if ((old_wx != wx) || (old_wy != wy))
   {
      al_rest(.02);
   }
   return 0;
}


get_new_screen_buffer uses PX and PY to set WX and WY...im going to need to do something different...
maybe mouse....no

went with position of the object in the viewer...seems to work for now...
no mouse scroll at all...only zoom in and out and change object....

seem to work good...

now I really want to be able to move the button window by dragging the title bar...

then I want to make the button window automatically resize its height based on how many buttons it has...
and still have the legend at the bottom...

then maybe resize the width too, based on how wide the buttons are...

I should go through all the buttons and do them with them new slider and button functions
and at the same time make them return the width of the text?? would that even work??
its too late by then to adjust the width....



back at home...
F5 and F6 go all the way to the end...anyway to slow down??
added back frame delay
fixed the problem with the smearing...
needed to run init_level_background when starting ovw...
too much stuff was drawn on level_backbround already...

move button window

how do I do it for selection window?

   int swx1 = status_window_x;
   int swy1 = status_window_y;
   int swh = status_window_h;
   int sww = status_window_w;
   int swx2 = swx1 + sww;
   int swy2 = swy1 + swh;


// object viewer window
int ov_window_active = 1;
int ov_window_x = SCREEN_W - 300;
int ov_window_y = 140;
int ov_window_w = 240;
int ov_window_h = 600;

// object viewer window
extern int ov_window_active;
extern int ov_window_x;
extern int ov_window_y;
extern int ov_window_w;
extern int ov_window_h;

made it moveable!


now make it the right height
need to call draw buttons first and have that set ov_window_h...done
need to make title not erase buttons...done
need to make title add number of legend lines to ov_window_h ...
got to where legend is moveable, but mouse on it shows up in a different place...fixed..

now it is moveable and resizes height nicely....

what about width?

make up and down arrow change types...whoah!
this is done, but I want it to also switch from item to enemy and vice versa
later I will be able to do this with map...

increased width to 300 and all buttons seem to fit well now...
still would be nice to do dynamic width somehow...

so what is the next big thing to do to this??
map move......


erase the background of buttons
this is harder than I thought...I don't know how big they are until I draw them

I could store w and h for each obt and type...

I could draw on a extra long cleared bitmap then chop blank section...

I went with storing w and h for each object..
now I can have custom width...but I have to manually edit it..
I still have automatic height, but I know what it is before I draw the buttons
so that I can erase before...

this seems to be working....




redoing sliders and buttons...

archwag...

   if (bn == 12) sprintf(smsg, "X-Speed:%-1.2f", al_fixtof(Efi[num][6]));
   if (bn == 13) sprintf(smsg, "Y-Speed:%-1.2f", al_fixtof(Efi[num][3]));


   if (bn == 12)                            // x - speed
   {
      Efi[num][6] = al_ftofix(f);
      if (Efi[num][2] > al_itofix(0)) Efi[num][2] = Efi[num][6];
      if (Efi[num][2] < al_itofix(0)) Efi[num][2] = -Efi[num][6];

   }
   if (bn == 13) Efi[num][3] = al_ftofix(f);  // y - speed

      case 12: sul=9;    sll=.7;    sinc=.01; sdx=al_fixtof(Efi[num][6]);      break;  // archwagon x speed
      case 13: sul=9;    sll=.7;    sinc=.01; sdx=al_fixtof(Efi[num][3]);      break;  // y speed

does anything else use 12 and 13...
block walker...
do I need to set 2 also when changing 6??  look at archwag code...no I can ignore it...just set 6...


            mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 8,  num, type, obt, 0, 15, 13,  0, 1,0,0,0); a++;  // initial direction
            mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 9,  num, type, obt, 0, 15, 13,  0, 1,0,0,0); a+=2; // bounce mode

   if (bn == 8) // archwag direction
   {
      if (Ei[num][2]) sprintf(smsg, "Initial Direction:Right");
      else            sprintf(smsg, "Initial Direction:Left ");
      if (press)
      {
         Ei[num][2] = !Ei[num][2];
         Redraw = 1;
      }
   }
   if (bn == 9) // archwag and walker
   {
      if (Ei[num][8]) sprintf(smsg, "Bounce Mode");
      else            sprintf(smsg, "Follow Mode");
      if (press) Ei[num][8] = !Ei[num][8];
   }




mdw_slider(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 19, num, type, obt, 0,  9, 15, 15, 1,0,0,0); a++;  // bullet speed
also pod and trakbot and cannon


if (bn == 19) sprintf(smsg, "Bullet Speed:%-1.1f", al_fixtof(Efi[num][7]));


   if (bn == 20) sprintf(smsg, "Bullet Proximity:%d", Ei[num][17]);

      case 20: sul=2000; sll=20;    sinc=1;   sdx=Ei[num][17];                 break;  // bullet prox
   if (bn == 20) Ei[num][17] = (int)f;     // bullet prox
arch and trak




   if (bn == 21) sprintf(smsg, "Bullet Retrigger Time:%d", Ei[num][15]);
   if (bn == 21) Ei[num][15] = (int)f;     // retrigger time
      case 21: sul=200;  sll=1;     sinc=1;   sdx=Ei[num][15];                 break;  // retrigger time
arch, cannon, trakbot, flapper





      case 24: sul=20;   sll=0;     sinc=1;   sdx=Ei[num][29];                 break;  // collision box
      case 25: sul=10;   sll=0;     sinc=.1;  sdx=al_fixtof(Efi[num][4]);      break;  // health dec
      case 42: sul=50;   sll=0;     sinc=1;   sdx=Ei[num][25];                 break;  // dead enemy health bonus




      case 22: sul=12;   sll=0;     sinc=.01; sdx=al_fixtof(Efi[num][5]);      break;  // cannon speed
      case 23: sul=100;  sll=0;     sinc=1;   sdx=Ei[num][8];                  break;  // seek count



//   if (bn == 35) sprintf(smsg, "Extra Hits to Kill:%d", Ei[num][9]);
   if (bn == 35) Ei[num][9] = (int)f;         // cannon extra hits to kill
      case 35: sul=40;   sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // cannon hits


bouncer and cannon speed and initial direction need custom shit..
direction and speed are saved with xinc, yinc....

revert 22....done



   if (bn == 12) // trakbot drop mode
   {
      if (Ei[num][7] == 0) sprintf(smsg, "Drop Mode:Off");
      else                 sprintf(smsg, "Drop Mode:On ");
      if (press)
      {
         if (bn == 12) Ei[num][7] = !Ei[num][7]; // trakbot drop mode
      }
   }



   if (bn == 45) sprintf(smsg, "X-speed:%-1.2f",al_fixtof(Efi[num][2]));
   if (bn == 46) sprintf(smsg, "Y-Speed:%-1.2f",al_fixtof(Efi[num][3]));


   if (bn == 36) sprintf(smsg, "Y Speed:%-1.2f", al_fixtof(Efi[num][3]));
   if (bn == 36) Efi[num][3] = al_ftofix(f);     // flapper x speed
      case 36: sul=5;    sll=0;     sinc=.01; sdx=al_fixtof(Efi[num][3]);      break;  // flapper y speed




   if (bn == 79) sprintf(smsg, "Flap Speed:%-1.2f", al_fixtof(Efi[num][10]));
   if (bn == 80) sprintf(smsg, "Flap Height:%d", Ei[num][21]);

   if (bn == 79) Efi[num][10] = al_ftofix(f);       // flap speed
   if (bn == 80) Ei[num][21] = (int)f;              // flap height

      case 79: sul=8;    sll=.5;    sinc=.1;  sdx=al_fixtof(Efi[num][10]);     break;  // flap speed
      case 80: sul=400;  sll=0;     sinc=10;  sdx=Ei[num][21];                 break;  // flap height


      case 63: sul=1000; sll=-1000; sinc=10;  sdx=Ei[num][20];                 break;  // height above player
   if (bn == 63) sprintf(smsg, "Height Above Player:%d",Ei[num][20]);
   if (bn == 63) Ei[num][20] =(int)f;       // flapper height above player



   if (bn == 38) Ei[num][17] = (int)f;        // flapper trigger box width
   if (bn == 39) Ei[num][18] = (int)f;        // flapper trigger box height
   if (bn == 40) Ei[num][19] = (int)f;        // flapper trigger box depth
   if ((bn == 38) ||(bn == 39) ||(bn == 40) ||(bn == 63))  // update flapper trigger box while adjusting
   {
       draw_big(1);
       show_big();
   }

   if (bn == 38) sprintf(smsg, "Trigger Box Width:%d", Ei[num][17]);
   if (bn == 39) sprintf(smsg, "Trigger Box Height:%d", Ei[num][18]);
   if (bn == 40) sprintf(smsg, "Trigger Box Depth:%d", Ei[num][19]);

      case 38: sul=500;  sll=20;    sinc=1;   sdx=Ei[num][17];                 break;  // width
      case 39: sul=600;  sll=1;     sinc=10;  sdx=Ei[num][18];                 break;  // y1
      case 40: sul=600;  sll=1;     sinc=10;  sdx=Ei[num][19];                 break;  // y2



      case 60: sul=8;    sll=.5;    sinc=.1;  sdx=al_fixtof(Efi[num][5]);      break;  // flapper max x speed
      case 61: sul=2;    sll=.01;   sinc=.01; sdx=al_fixtof(Efi[num][6]);      break;  // flapper x accel
      case 62: sul=4;    sll=0;     sinc=.1;  sdx=al_fixtof(Efi[num][8]);      break;  // flapper yinc flap scale

   if (bn == 60) sprintf(smsg, "X Speed:%-3.2f",al_fixtof(Efi[num][5]));
   if (bn == 61) sprintf(smsg, "X Accel:%-3.2f",al_fixtof(Efi[num][6]));
   if (bn == 62) sprintf(smsg, "Y Flap :%-3.2f",al_fixtof(Efi[num][8]));

   if (bn == 60) sprintf(smsg, "X Speed:%-3.2f",al_fixtof(Efi[num][5]));
   if (bn == 61) sprintf(smsg, "X Accel:%-3.2f",al_fixtof(Efi[num][6]));
   if (bn == 62) sprintf(smsg, "Y Flap :%-3.2f",al_fixtof(Efi[num][8]));






   if (bn == 83) // cloner only
   {
      if (Ei[num][30] ==  0) sprintf(smsg,  "      Normal     ");
      if (Ei[num][30] ==  1) sprintf(smsg,  "    Invincible   ");
      if (press)
      {
         Ei[num][30] = !Ei[num][30]; // cloner invinciblility
      }
   }



   if (bn == 34) sprintf(smsg, "Delay Timer:%d", Ei[num][6]);

   if (bn == 34)                           // cloner create delay
   {
      Ei[num][6] = (int)f;
      Ei[num][7] = (int)f;
   }

      case 34: sul=1000; sll=20;    sinc=1;   sdx=Ei[num][6];                  break;  // create delay



         if (bn == 74) sprintf(smsg, "Created Objects Time To Live:%-2d", Ei[num][9]);
   if (bn == 75) sprintf(smsg, "Max Created Objects At One Time:%-2d", Ei[num][10]);



         if (bn == 74) Ei[num][9] = (int)f;        // cloner created object time to live
   if (bn == 75) Ei[num][10] = (int)f;       // cloner max created objects active at one time


      case 74: sul=4800; sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // cloner created obj time to live
      case 75: sul=600;  sll=0;     sinc=1;   sdx=Ei[num][10];                 break;  // cloner max created obj at one time




made all enemy button widths 220 by changing 'viewer help' 'archwagon help' to 'help' 'archwagon help'...


now what is wrong with the map stuff...fixed crosshairs and podzilla legend




bonus needs fixing...
now it can be health, free man or purple coin



   if (bonus_type == 1) // health bonus
   {
      al_fixed f100 = al_itofix(100);


      if (players[p].LIFE < f100)
      {
         item[i][0] = 0;
         players[p].LIFE += al_itofix(item[i][7]);
         if (players[p].LIFE > f100) players[p].LIFE = f100;

         game_event(72, 0, 0, p, i, item[i][1], item[i][7]);
      }
   }

   if (bonus_type == 2) // free man
   {
      item[i][0] = 0;
      players[p].LIVES++;
      game_event(70, 0, 0, p, i, 0, 0);
   }



   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      // game_event(70, 0, 0, p, i, 0, 0);

   }


bonus is fixed....


fix door destination....done




   if (bn == 47) sprintf(smsg, "Exit with %d enemies left",item[num][8]);
   if (bn == 47) item[num][8] = (int)f;       // exit with x enemies left
      case 47: sul=100;  sll=0;     sinc=1;   sdx=item[num][8];                break;  // exit with x enemies left


working on lining up the message stuff...its a lot better but maybe not 100%...nah...its good...


High level shit here...where am I going with this?

If I make map move stuff work, then I have basically replaced all the viewer stuff (item and enemy anyways) with my new zoomable stuff....

then should I go further?
- integrate the main editor
- integrate the zoom full screen stuff
- integrate group edit
- integrate lift viewer?


could all of these things just be windows that float on top of the zoomable level background?
like status, selection, and now object viewer


added scroll to viewer
centers display on current obj when first started or when changing obj

I want podzilla to show tile at extended pos and connecting line...done


detect what object mouse pointer is on
this is the start of map move...


this is harder than it should be:


         float bs = scale_factor_current * 20; // block size

         float xpos = (float) (WX+mI.mouse_x-BORDER_WIDTH);

         float fgx = xpos/bs;
         int gx = (int) fgx;

         float fgy = (WY+mI.mouse_y-BORDER_WIDTH)/bs;
         int gy = (int) fgy;

         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f bs:%2.1f fgx:%2.1f gx:%d\n", mI.mouse_x, WX, WX+mI.mouse_x, WX+mI.mouse_x-BORDER_WIDTH, scale_factor_current, bs, fgx, gx);
//         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen
         float sgx = gx*bs - WX+BORDER_WIDTH;
         float sgy = gy*bs - WY+BORDER_WIDTH;
         al_draw_rectangle(sgx, sgy, sgx+bs, sgy+bs, mC.pc[14], 1);


this does not work:

when scale_factor_current = 1 it works no matter what WX and WY are
when WX and WY = 0 it works no matter what sfc is...
when either of those is different it does not line up


WX is a pointer to the unscaled source.....scale WX and try again...


WX is in 0-2000 format and is a pointer the the left edge of the source position in level buffer

what is shown on the screen has been scaled, but the left edge has the same x as the level buffer source


this works....


            // the mouse position past the border width is how far we are into the scaled map
            float mx1 = mI.mouse_x-BORDER_WIDTH;

            // divide that by bs to get how many blocks we are into the map
            float mx2 = mx1 / bs;

            // get block position of WX
            float mx3 = WX / 20;

            // add WX
            float mx4 = mx3 + mx2;

            int gx = (int) mx4;


            // the mouse position past the border width is how far we are into the scaled map
            float my1 = mI.mouse_y-BORDER_WIDTH;

            // divide that by bs to get how many blocks we are into the map
            float my2 = my1 / bs;

            // get block position of WX
            float my3 = WY / 20;

            // add WY
            float my4 = my3 + my2;

            int gy = (int) my4;





/*

            float my1 = (mI.mouse_y-BORDER_WIDTH) * scale_factor_current;
            float my2 = (WY + my1) / 20;
            int gy = (int) my2;
*/
//            printf("mx1:%2.1f mx2:%2.1f mx3:%2.1f mx4:%2.1f gx:%d\n", mx1, mx2, mx3, mx4, gx);


//         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f gx:%d\n", mI.mouse_x, WX, WX+mI.mouse_x, WX+mI.mouse_x-BORDER_WIDTH, scale_factor_current, gx);
         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen
//         float sgx = gx*bs - WX+BORDER_WIDTH;
//         float sgy = gy*bs - WY+BORDER_WIDTH;

         float sgx = BORDER_WIDTH + (gx-WX/20) * bs;
         float sgy = BORDER_WIDTH + (gy-WY/20) * bs;
         al_draw_rectangle(sgx, sgy, sgx+bs, sgy+bs, mC.pc[14], 1);



but it only works when WX and WY are multiples of 20.....

I gave up all this bullshit and just draw directly on the level buffer like this:

      if (block_highlight_show) crosshairs_full(block_highlight_x, block_highlight_y, block_highlight_color, 1);

/*



         printf("WX:%d mx1:%2.1f mx2:%2.1f mx3:%2.1f mx4:%2.1f gx:%d\n", WX, mx1, mx2, mx3, mx4, gx);
//         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f gx:%d\n", mI.mouse_x, WX, WX+mI.mouse_x, WX+mI.mouse_x-BORDER_WIDTH, scale_factor_current, gx);
//         printf("mx:%d WX:%d sfc:%2.1f gx:%d\n", mI.mouse_x, WX, scale_factor_current, gx);
//         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen

         // block position of WX
         float bwx = (float)WX/20;

         // subtract from obj pos
         float gwx = (float)gx - bwx;

         // muliply obj block pos by bs
         float gwx2 = gwx * bs;

         float sgx = BORDER_WIDTH + gwx2;

         printf("WX:%d bwx:%2.1f gwx:%2.3f gwx2:%2.3f sgx:%2.3f scf:%2.1f bs:%2.1f\n", WX, bwx, gwx, gwx2, sgx, scale_factor_current, bs);






//         float sgx = BORDER_WIDTH + ( (float)gx -(float)WX / 20) * bs;

         float sgy = BORDER_WIDTH + ( (float)gy -(float)WY / 20) * bs;

         int sgx1 = (int)sgx;
         int sgy1 = (int)sgy;
         int sgx2 = (int)(sgx + bs + 1);
         int sgy2 = (int)(sgy + bs + 1);

         al_draw_rectangle(sgx1, sgy1, sgx2, sgy2, mC.pc[14], 1);



*/










now move on...



when I scroll away...
clicking to move window resets the map pos...fixed...




what am I going to do with this block the mouse is on??
detect and set viewer to that object...

         // detect if we are on an object...
         for (int b=0; b<100; b++) // add enemies in selection
            if ((Ei[b][0]) && (al_fixtoi(Efi[b][0])/20 == gx) && (al_fixtoi(Efi[b][1])/20 == gy))
            {
               obt = 3;
               num = b;
               new_obj = 2;
            }

         for (int b=0; b<500; b++) // add items in selection
            if ((item[b][0]) && (item[b][4]/20 == gx) && (item[b][5]/20 == gy))
            {
               obt = 2;
               num = b;
               new_obj = 2;
            }


that was easy...

now do mouse move....




make a function that gets block x and y
from mouse, scf and WX



void ob_get_block_position_on_map(int*x, int*y)
{
   // scaled block size
   float bs = scale_factor_current * 20;
   // the mouse position past the border width is how far we are into the scaled map
   float mx1 = mI.mouse_x-BORDER_WIDTH;
   float my1 = mI.mouse_y-BORDER_WIDTH;
   // divide that by bs to get how many blocks we are into the map
   float mx2 = mx1 / bs;
   float my2 = my1 / bs;
   // get block position of WX
   float mx3 = (float)WX / 20;
   float my3 = (float)WY / 20;
   // add WX
   float mx4 = mx3 + mx2;
   float my4 = my3 + my2;
   *x = (int) mx4;
   *y = (int) my4;
}


int gx=0, gy=0;
ob_get_block_position_on_map(&gx, &gy);



// mouse move
if (mouse_on_obj)
{
   //printf("mouse on obj\n");
   if (mouse_b1)
   {
      //printf("mouse pressed on obj\n");
      while (mouse_b1)
      {
         if (obt == 2)
         {
            ob_get_block_position_on_map(&gx, &gy);
            item[num][4] = gx*20;
            item[num][5] = gy*20;
            itemf[num][0] = al_itofix(gx*20);
            itemf[num][1] = al_itofix(gy*20);
         }

         if (obt == 3)
         {
            ob_get_block_position_on_map(&gx, &gy);
            Efi[num][0] = al_itofix(gx*20);
            Efi[num][1] = al_itofix(gy*20);
         }
         al_flip_display();
         proc_scale_factor_change();

         proc_controllers();
         proc_frame_delay();
         get_new_background(0);
         draw_lifts();
         draw_items();
         draw_enemies();
         draw_object_overlays(obt, num, legend_line, highlight_counter);
         get_new_screen_buffer(3, obj_x, obj_y);
      }
   }
}

mouse move was easy....


things do not work nice if zoomed in so far that map is not in upper right corner....
how can I prevent this from happening...fixed...


   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      sbw = sls;         // new screen_buffer blit width = sls
      if (!level_editor_running) sbx += a/2;        // new screen_buffer blit xpos
   }

   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      sbh = sls;         // new screen_buffer blit height = sls
      if (!level_editor_running) sby += a/2;        // new screen_buffer blit ypos
   }




bug red line on exit only door...fixed....


now lets do pozilla extended position....
click and drag motherfucker!

make a function to get pod extended position and see how many places we can us it...

done and done

bug archwagon empty arrow ans seem to be blank....i think I got it back..must have erased ans#3 by accident....


next I want to do rectangular boxes....

start with podzilla and cloner trigger...done...

make the mouse pointer better...
only show higlighted square if object detected...otherwise just show regulat pointer....
tie this in with the mouse pointer...

then see if you can do the mouse pointer more accurate than block resolution

gx and gy are fine, but I want something better also....
hx and hy....done


old:
if ((al_fixtoi(Efi[b][0])/20 == gx) && (al_fixtoi(Efi[b][1])/20 == gy)) // if x and y position match, set this to current object

new:
int ex = al_fixtoi(Efi[b][0]);
int ey = al_fixtoi(Efi[b][1]);
if ((hx>ex+6) && (hx<ex+14) && (hy>ey+6) && (hy<ey+14))

much nicer...

just redid all detection like this and I like it a lot...

next to add would be the 4 item box moves....

            // ranges for key, trigger, manip and damage
            if (mouse_on_kbr_ul) // move block range from ul
            {
               // set new position
               item[num][6] = mx*20;
               item[num][7] = my*20;
            }
            if (mouse_on_kbr_lr) // adjust block range from lr
            {
               // don't allow lr to be less than ul
               if (mx < item[num][6]/20) mx = item[num][6]/20;
               if (my < item[num][7]/20) my = item[num][7]/20;

               // set new position
               item[num][8] = mx*20 - item[num][6];
               item[num][9] = my*20 - item[num][7];
            }


that was so easy.....


what next?


cloner src and dest...done...

messages done....

rocket and bomb damage ranges done...

sproingy done...


there is no trakbot bullet prox?
make one...done

did not do the part where moving main item also moves other stuff
cloner, pod, trigger bm bd, key, etc....


if (mouse_on_enemy)
{
   // get offset of move
   int x_off = al_fixtoi( al_itofix(mx * 20) - Efi[num][0] ) / 20;
   int y_off = al_fixtoi( al_itofix(my * 20) - Efi[num][1] ) / 20;

   // set new position
   Efi[num][0] = al_itofix(mx * 20);
   Efi[num][1] = al_itofix(my * 20);

   // move podzilla's trigger box too
   if (Ei[num][0] == 7)
   {
      Ei[num][11] += x_off;
      Ei[num][12] += y_off;
      Ei[num][13] += x_off;
      Ei[num][14] += y_off;
   }

   // move cloner's stuff too
   if (Ei[num][0] == 9)
   {
      Ei[num][11] += x_off; // trigger box
      Ei[num][12] += y_off;
      Ei[num][13] += x_off;
      Ei[num][14] += y_off;
      Ei[num][15] += x_off; // source
      Ei[num][16] += y_off;
      Ei[num][17] += x_off; // dest
      Ei[num][18] += y_off;
   }
} // end of mouse on enemy

did this also, but made it so that only by holding shift are those moved also.
should do it also for key msg, trigger bm bd...done...


now.....

can I merge some other things with this....

how about group edit?


I would need to make the windows for that float....or not...they could just be stuck where they are for now....

all I need to change is the map background....


make a new source file

e_group_edit_windows.cpp

copy everything there...then start modifying....


first of all I want to get rid of old obj viewer....

if it got lift stuff it just passed it on....
make that work again....


what about title obj...make a stripped down version....
this broke, or made look bad....the creators....fix later...I need to get lift viewer working though


patched lift viewer back in...

now you can right click on a lift from main editor and ovw will pass it to lift viewer
then if you mouse on an item or enemy in the lift viewer map it will switch to ovw for that obj....
not back yet though...now it is....


what if I made a function like get box, but that used the scaled map background....
I want to get rid of anything that uses the 100x100 map and title stuff...




for keys...
get rid of color select..
make 4 PDE..
make color changeable in viewer
make a new getbox and use it...


int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2)

find all the places I can swap for

int getbox(const char *txt, int obj_type, int sub_type, int num )

16 occurances!!

key block range done
type 1 0-1999 x y w h

move trigger box for 7 and 9...done
type 2 0-99 x1 y1 x2 y2

cloner source area creator...done
type 3 0-99 x y w h


field damage creator
field trigger creator
type 1 0-1999 x y w h

key creator
type 1

creators all type 1
trigger
bd
bm


button 5 key

button 17 cloner src

button 85 get new field
button 86 get new field trigger

200 trigger

now retired!!!
//int getbox(const char *txt, int obj_type, int sub_type, int num );

int getbox(const char *txt, int obj_type, int sub_type, int num )
{
   int bs_on = 1;
   int quit = 0;
   while (mouse_b1) proc_controllers();    // wait for release
   while (!quit)
   {
      proc_controllers();
      int dx = mI.mouse_x/db;
      int dy = mI.mouse_y/db;

      title_obj(obj_type, sub_type, num, 0, 15);

      // show text line
      al_draw_text(font, mC.pc[9],  txc, 72,  ALLEGRO_ALIGN_CENTER, "Draw a new");
      al_draw_text(font, mC.pc[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, mC.pc[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "by clicking and");
      al_draw_text(font, mC.pc[9],  txc, 96,  ALLEGRO_ALIGN_CENTER, "dragging with the");
      al_draw_text(font, mC.pc[9],  txc, 104, ALLEGRO_ALIGN_CENTER, "left mouse button");
      al_draw_text(font, mC.pc[14], txc, 130, ALLEGRO_ALIGN_CENTER, "Cancel with <ESC> or");
      al_draw_text(font, mC.pc[9],  txc, 138, ALLEGRO_ALIGN_CENTER, "the right mouse button");

      if (bs_on) draw_bs(15);

      if ((obj_type == 3) && (sub_type == 9)) // cloner
         draw_cloner_boxes(num);

      // show block cursor
      if ((dx<100) && (dy < 100)) al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, mC.pc[127-32], 1); // show which block is selected

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));

      if (mouse_b1)
      {
         quit = 1;
         bx1 = mI.mouse_x/db;
         by1 = mI.mouse_y/db;
         while (mouse_b1) // trap while b1 is held
         {
            proc_controllers();
            title_obj(obj_type, sub_type, num, 0, 15);

            // show text line
            al_draw_text(font, mC.pc[9],  txc, 72,  ALLEGRO_ALIGN_CENTER, "Draw a new");
            al_draw_text(font, mC.pc[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
            al_draw_text(font, mC.pc[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "by clicking and");
            al_draw_text(font, mC.pc[9],  txc, 96,  ALLEGRO_ALIGN_CENTER, "dragging with the");
            al_draw_text(font, mC.pc[9],  txc, 104, ALLEGRO_ALIGN_CENTER, "left mouse button");
            al_draw_text(font, mC.pc[14], txc, 130, ALLEGRO_ALIGN_CENTER, "Cancel with <ESC> or");
            al_draw_text(font, mC.pc[9],  txc, 138, ALLEGRO_ALIGN_CENTER, "the right mouse button");

            if (bs_on) draw_bs(15);

            if ((obj_type == 3) && (sub_type == 9)) // cloner
              draw_cloner_boxes(num);


            // show selection rectangle
            bx2 = (mI.mouse_x/db)+1;
            by2 = (mI.mouse_y/db)+1;
            al_set_clipping_rectangle(0, 0, display_transform_double*db*100-1, display_transform_double*db*100-1);
            al_draw_rectangle((bx1)*db, (by1)*db, (bx2)*db, (by2)*db, mC.pc[15], 1);
            al_reset_clipping_rectangle();

            al_flip_display();
            al_clear_to_color(al_map_rgb(0,0,0));
         }

         // limits
         if (bx1<0) bx1 = 0;
         if (bx2<0) bx2 = 0;
         if (by1<0) by1 = 0;
         if (by2<0) by2 = 0;

         if (bx1>99) bx1 = 99;
         if (bx2>99) bx2 = 99;
         if (by1>99) by1 = 99;
         if (by2>99) by2 = 99;

         // ensure top-right, bottom left format
         if (bx1 > bx2)
         {
            int btemp = bx2;
            bx2 = bx1;
            bx1= btemp;
         }
         if (by1 > by2)
         {
            int btemp = by2;
            by2 = by1;
            by1= btemp;
         }
      }
      if  (mouse_b2)
      {
         while (mouse_b2) proc_controllers(); // wait for release
         return 0;
      }
      if (mI.key[ALLEGRO_KEY_ESCAPE])
      {
         return 0;
      }
   } // end of while not quit
   return 1;
}


getbox is dead...I wish I could get rid of the globals that it uses....bx1...etc

how about getxy? there are only 27 calls to that!!

could be done...keep all the cool shit
make it on the zoomable map also and no title obj

podzilla could have random extended position

get block range needs checks to prevent upside down...done



getxy...

the part at the start where variable are saved will be easier once I pass pointers

I think I might just redo the existing one instead of making a new one...

almost done...

when called ignore get100_y...done

get100x and y are completely gone....






int old_getxy(const char *txt, int obj_type, int sub_type, int num )
{
   int dx=0, dy=0;

   // in case these are needed for lifts
   int lift = sub_type;
   int step = num;

   int retval=0;
   int quit=0;

   while (mouse_b1) proc_controllers(); // wait for release
   al_flip_display();
   al_clear_to_color(al_map_rgb(0,0,0));


// get original positions in case we are cancelled
   int original_dx=0, original_dy=0;
   if (obj_type == 2)
   {
      original_dx = item[num][4];
      original_dy = item[num][5];
   }
   if (obj_type == 3)
   {
      original_dx = al_fixtoi(Efi[num][0]) / 20;
      original_dy = al_fixtoi(Efi[num][1]) / 20;
   }

   if (obj_type == 99) // pod extended
   {
      original_dx = al_fixtoi(Efi[num][5]) / 20;
      original_dy = al_fixtoi(Efi[num][6]) / 20;
   }

   if (obj_type == 98) // cloner destination
   {
      original_dx = Ei[num][17];
      original_dy = Ei[num][18];
   }

   if (obj_type == 4)
   {

      original_dx = lift_steps[lift][step].x / 20;
      original_dy = lift_steps[lift][step].y / 20;
   }

   while(!quit)
   {
      dx = mI.mouse_x/db;
      dy = mI.mouse_y/db;

      if ((dx < 100) && (dy < 100)) // if mouse on map
      {
         switch (obj_type) // show draw_item
         {
            case 2: // show item
               if (sub_type == 1010) // message display only
               {
                  show_big();
                  al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
                  al_draw_bitmap(mp, dx*db, dy*db, 0);
                  al_reset_clipping_rectangle();
               }
               else // all other items
               {
                  item[num][4] = dx*20;
                  item[num][5] = dy*20;
                  itemf[num][0] = al_itofix(dx*20);
                  itemf[num][1] = al_itofix(dy*20);
                  draw_big(1);
                  show_big();
                  draw_bs(14);            // show bullseye map
                  al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
                  al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, mC.pc[127-32], 1); // draw box to show cursor
                  al_reset_clipping_rectangle();
               }
            break;
            case 3: // show enem
               Efi[num][0] = al_itofix(dx * 20);
               Efi[num][1] = al_itofix(dy * 20);
               draw_big(1);
               show_big();
               draw_bs(14);            // show bullseye map
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, mC.pc[127-32], 1); // draw box to show cursor
               al_reset_clipping_rectangle();
            break;
            case 99: // move pod extended
            {
               Efi[num][5] = al_itofix(dx * 20);
               Efi[num][6] = al_itofix(dy * 20);
               draw_big(1);
               show_big();
               draw_bs(14);
               int ex = al_fixtoi(Efi[num][0])*db/20;
               int ey = al_fixtoi(Efi[num][1])*db/20;
               int px = al_fixtoi(Efi[num][5])*db/20;
               int py = al_fixtoi(Efi[num][6])*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ex, ey, ex+db-1, ey+db-1, mC.pc[13], 1);           // draw box to show pod location
               al_draw_filled_rectangle(px, py, px+db-1, py+db-1, mC.pc[10]);       // draw box to show pod extended
               al_draw_line(ex+db/2, ey+db/2, px+db/2, py+db/2, mC.pc[10], 1); // connect with line
               al_reset_clipping_rectangle();
            }
            break;
            case 98: // cloner destination
            {
               Ei[num][17] = dx;
               Ei[num][18] = dy;
               draw_big(1);
               show_big();
               draw_bs(14);
              // draw_cloner_boxes(num);
            }
            break;
            case 97: // set new rocket direction
            {
               draw_big(1);
               show_big();
               draw_bs(14);
               int ix = item[num][4]*db/20;
               int iy = item[num][5]*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ix, iy, ix+db-1, iy+db-1, mC.pc[13], 1);                     // show rocket location
               al_draw_filled_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, mC.pc[10]);   // show cursor
               al_draw_line(ix+db/2, iy+db/2, dx*db+db/2, dy*db+db/2, mC.pc[10], 1);     // connect with line
               al_reset_clipping_rectangle();
            }
            break;
            case 96: // set cannon or bouncer direction
            {
               draw_big(1);
               show_big();
               draw_bs(14);
               int ex = al_fixtoi(Efi[num][0])*db/20;
               int ey = al_fixtoi(Efi[num][1])*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ex, ey, ex+db-1, ey+db-1, mC.pc[13], 1);                   // draw box to show enemy location
               al_draw_filled_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, mC.pc[10]); // draw box to show cursor
               al_draw_line(ex+db/2, ey+db/2, dx*db+db/2, dy*db+db/2, mC.pc[10], 1);   // connect with line
               al_reset_clipping_rectangle();

            }
            break;
            case 4: // show lift
            {
               lift_steps[lift][step].x = dx*20;
               lift_steps[lift][step].y = dy*20;

               //  redraw
               set_lift_to_step(lift, step);   // set current step in current lift
               draw_big(1);
               show_big();
               draw_bs(14);            // show bullseye map

               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               highlight_current_lift(lift);   // crosshairs and rect on current lift
               al_reset_clipping_rectangle();
            }
            break;
         }
      } // end of if mouse on map

      al_set_target_backbuffer(display);

      // show text line
      al_draw_text(font, mC.pc[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, mC.pc[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "with left mouse button");
      al_draw_text(font, mC.pc[14], txc, 120, ALLEGRO_ALIGN_CENTER, "Cancel");
      al_draw_text(font, mC.pc[9],  txc, 128, ALLEGRO_ALIGN_CENTER, "with right mouse button");

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));
      proc_controllers();

      title_obj(obj_type, sub_type, num, 0, 15);

      while (mouse_b1)
      {
         proc_controllers();
         quit = 1;
         retval = 1;  // b1 xy
      }
      while (mouse_b2)
      {
         proc_controllers();
         quit = 1;
         retval = 2;  // b2 xy
      }
      while (mI.key[ALLEGRO_KEY_ESCAPE])
      {
         proc_controllers();
         quit = 1;
         retval = 0;  // ignore xy
      }
   } // end of while(!quit);


   if (dx > 99) dx = 99;
   if (dy > 99) dy = 99;

   if (retval != 1) // restore old positions if cancelled
   {
      if (obj_type == 2)
      {
         item[num][4] = original_dx;
         item[num][5] = original_dy;
         itemf[num][0] = al_itofix(original_dx);
         itemf[num][1] = al_itofix(original_dy);
      }
      if (obj_type == 3)
      {
          Efi[num][0] = al_itofix(original_dx * 20);
          Efi[num][1] = al_itofix(original_dy * 20);
      }

      if (obj_type == 99)
      {
          Efi[num][5] = al_itofix(original_dx * 20);
          Efi[num][6] = al_itofix(original_dy * 20);
      }

      if (obj_type == 98)
      {
          Efi[num][5] = original_dx;
          Efi[num][6] = original_dy;
      }

      if (obj_type == 4)
      {
         lift_steps[lift][step].x = original_dx * 20;
         lift_steps[lift][step].y = original_dy * 20;
         set_lift_to_step(lift, step);   // set current step in current lift
      }
   }
   return retval;
}

old getxy is gone....

should slso get rid of bx1...



now can I get rid of title....lifts needs it I think...
14 occurances...

get_trigger_item()
called by sliders for bm and bd

redo it like the others....

fix this too....done
find_and_show_event_links(num);

this looks great...check if it works for lifts....

did a bunch of stuff to make it work for lifts...
show event links works great...
does not work for plain lift viewer because that still uses 100 map for now...




so back to what I was doing....

get trigger item is done....now uses new scaleable map and does not use title object_viewer

now get_item()

used only by doors to get linked door...done...


now what is left for title_obj()...?
draw and redraw lift_viewer...
a bunch of comment out stuff from the old object_viewer()...

hack it up so that only lift can use it...


this is all that is left....

void title_obj(int obj_type, int sub_type, int num, int legend_highlight, int highlight_color)
{
   al_draw_rectangle(0, 0,  SCREEN_W-1, SCREEN_H-1, mC.pc[13], 1);         // outline screen
   al_draw_rectangle(0, 0, 100*db-1, 100*db-1, mC.pc[13], 1);              // outline map
   al_draw_rectangle(100*db-1, 0,  SCREEN_W-1, SCREEN_H-1, mC.pc[13], 1);  // outline side panel

   show_big();
   title("Lift Viewer",  0, 15, 13);

   int lift = sub_type;
   al_draw_rectangle(txc-90, 20, txc+90, 43, mC.pc[15], 1);
   al_draw_textf(font, mC.pc[13], txc, 29, ALLEGRO_ALIGN_CENTER, "Lift %d of %d",lift+1, num_lifts);
}

moved to e_lifts.cpp and renamed:

void title_lift(int lift)
{
   al_draw_rectangle(0, 0,  SCREEN_W-1, SCREEN_H-1, mC.pc[13], 1);         // outline screen
   al_draw_rectangle(0, 0, 100*db-1, 100*db-1, mC.pc[13], 1);              // outline map
   al_draw_rectangle(100*db-1, 0,  SCREEN_W-1, SCREEN_H-1, mC.pc[13], 1);  // outline side panel
   show_big();
   title("Lift Viewer",  0, 15, 13);
   al_draw_rectangle(txc-90, 20, txc+90, 43, mC.pc[15], 1);
   al_draw_textf(font, mC.pc[13], txc, 29, ALLEGRO_ALIGN_CENTER, "Lift %d of %d",lift+1, num_lifts);
}

now all of object_viewer() is commented out....removed from project...yay!!

bx1 stuff...that global has been removed!!! yay!!


now what...



group edit was very easy.....

flash of item on level buffer does not work??
mouse on item in map make list flash, but not the other way...fixed by redordering

do not show crosshairs when show selection...done

do not show crosshairs when on windows...

made flash color global...

make the windows moveable....
how many windows do I have?

filters
list
ge_actions
buttons

move them all at once for now...
with the title bar...

make a way to get sizes of all the windows...

title bar is easy, it is 300 wide and 15 high

redo filter so that sizes are right...done
same with object list...done
what I mean is that the x and y are the actual sizes and not offset by frame..


now make it so that I can drag the whole thing....done



group edit to do:

make it easy to clear the list.

make it easier to add..like..set filters then selection could add automatically...

make it so that I can line up a group of enemies...
set the y values to all the same..
set the x in a increment thing...
right now that is not possible...

removed e_group_edit.cpp from sources....



next big thing....
lift viewer to match object viewer...
would that not be so awesome if they were one and the same
lift viewer if 400 LOC and the map move part is 200 of that....




// ----------------------------------------------------------------------
// ------------there are multiple ways to pass pointers....
// ----------------------------------------------------------------------


this is one way:
-------------------------------------------
int gx=0, gy=0, hx=0, hy=0;
ovw_get_block_position_on_map(&gx, &gy, &hx, &hy);

void ovw_get_block_position_on_map(int*x, int*y, int *hx, int *hy)
{
   *x = (int) mx4;
   *y = (int) my4;


this is another way:
-----------------------------------------
int mdw_toggle(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_col0, int frame_col1)

mdw_toggle(x1+fs, y+a*bts, x2-fs, y+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, obj_filter[2][5],  "Start",  "Start",  tc1, tc2, fc1, fc2); a++;



and this is an int, passed as an int to a different function, then that function in its parameters casts it to a pointer and send it to another function
------------------------------------------------------------------------------------------------------------------------------
void group_edit(void)
{
   int show_sel_frame = 1;
   ge_draw_on_screen_buffer(ge_window_x, ge_window_y, show_sel_frame);

int ge_draw_on_screen_buffer(int xa, int ya, int &show_sel_frame)
{
   mdw_toggle(bpx1+2, bpy1, bpx1+110, bpy2, 1000, 0,0,0,   0,0,0,0,1,0,0,0, show_sel_frame,  "Selection:OFF", "Selection:ON ", 15, 15, 15+64, 14);



20220502 6:20 AM

cleaned up object_viewerw() main function....
moved out map move and a few others...

now it is only 270 lines....
150 for button retvals and keys

it getting lean....

I am thinking of merging the lift viewer code into it....

it will be awesome....

20220502 7:22 PM

got lift map move to work in obv...!!!

pasted in the buttons, step list and current step details...

now I need to:

run lifts button replaces move...done
make all the upper buttons work...done


make sure everything stil works
clicking step in list does not set that step to current...fixed

make sure popup menus work and are in the right place...

do not let lift step buttons draw past right edge....done

run lifts gets stick on event trigger steps...
make it so that mouse in trigger box triggers
same for player in prox setp...

dynamic height with background erasing...
finally hacked together something that works for dynamic size and erase

int ovw_draw_buttons(int num, int type, int obt)
draws the default buttons
then calls  obj_buttons()??
why not combine??
why keep separate?


now I want to narrow the whole thing....done...down to 300 wide and looking good
Current Step (0) Details
First line has the long text description
second line
in list, change the details for move to:
and Resize Speed:50

object_viewer_window.cpp has 2300 lines
e_lifts.cpp has 600 lines


ovw dissappears when mouse_move is on....fixed...
legend lines have transparent background.....not erasing enough...fixed...

lift color does not update when changing step color, need to redraw something...fixed


test add lift steps and shit like that for updating screen...
pop-up menu for insert step....fixed that, I think..just made its position mI.mouse_x and mI.mouse_y


20220504 6:31 AM
got to go ...push


I need to make something like a redraw object viewer function...
so I can call it when I am in the middle of adding lifts steps

also can call it when I am moving window, or map moving things...




this is from line 1947 at the end of map_move...

         al_flip_display();
         proc_scale_factor_change();
         proc_controllers();
         proc_frame_delay();

         if (obt == 4) init_level_background(); // to draw new lift lines

         get_new_background(0);
         draw_lifts();
         draw_items();

         // if current object is messages, show all messages
         if ((obt == 2) && (type == 10))
         {
            for (int i=0; i<500; i++)
               if (item[i][0] == 10) draw_pop_message(i);
         }

         draw_enemies();
         ovw_draw_overlays(obt, num, 0);
         get_new_screen_buffer(3, obj_x, obj_y);


this is from window move
            al_flip_display();
            proc_scale_factor_change();
            proc_controllers();
            proc_frame_delay();

            get_new_background(0);

            draw_lifts();
            draw_items();
            draw_enemies();
            ovw_draw_overlays(obt, num, 0);
            get_new_screen_buffer(3, 0, 0);

            ovw_draw_buttons(num, type, obt);
            ovw_title(obt, num, 0);




this is from the main object viewer

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
      proc_frame_delay();

      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();

      ovw_draw_overlays(obt, num, legend_line);

      // if current object is message, show all messages
      if ((obt == 2) && (type == 10))
      {
         for (int i=0; i<500; i++)
            if (item[i][0] == 10) draw_pop_message(i);
      }

      get_new_screen_buffer(3, obj_x, obj_y);

      int mb = ovw_draw_buttons(num, type, obt);
      ovw_title(obt, num, 0); // draw button title, frame and legend lines



this is from insert lift_step

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
      proc_frame_delay();
      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();
      ovw_draw_overlays(4, lift, 0);
      get_new_screen_buffer(3, 0, 0);

      ovw_draw_buttons(lift, 0, 4);
      ovw_title(4, lift, 0); // draw button title, frame and legend lines



what am I going to call it

int ovw_redraw_background(int obt, int type, int num, int legend_line, int show_window)
{
   al_flip_display();
   proc_scale_factor_change();
   proc_controllers();
   proc_frame_delay();
   if (obt == 4) init_level_background(); // to draw new lift lines
   get_new_background(0);
   draw_lifts();
   draw_items();
   draw_enemies();

   ovw_draw_overlays(obt, num, legend_line);

   // if current object is message, show all messages
   if ((obt == 2) && (type == 10))
   {
      for (int i=0; i<500; i++)
         if (item[i][0] == 10) draw_pop_message(i);
   }

   get_new_screen_buffer(3, 0, 0);

   int mb = 0;
   if (show_window)
   {
      mb = ovw_draw_buttons(num, type, obt);
      ovw_title(obt, num, 0); // draw button title, frame and legend lines
   }
   return mb;
}

replaced in all 4 places...


now look at lift creator...fixed...


when inserting lifts steps

-blue title list of steps ypos is too low...fixed
-frame y2 is not correct until done...done..run redraw twice to get proper height



I think I have the lift viewer stuff all done.. seems to work very nicely...


what should I do next??

zoom full screen?

main editor?


even before that I could re do the status window...

I want to show something like the button list, but probably custom, smaller and read only...

at the top of the screen I want to have a collapsable filter window with lots of options...

each indivdual item and enemy
lifts
block and block flags

these would apply to viewer to filter what could be selected, or shown.


20220505



re enable bookmarks...done
can be in object viewer with obt and num
save in object viewer
load and auto load in edit_menu
all works good...


save positions of windows in cfg file just like status and sel...
group edit, and ovwindow...



zoom full screen....
make the side panel into a moveable window
call it something else...rectangular copy paste



do something about display_transform_double
make it automatic or manual and in cfg file...



void auto_set_display_transform_double(void)
{
   display_transform_double = 2;

/*
   display_transform_double = 1;

   if (disp_w_curr > 1023) display_transform_double = 2;
   if (disp_h_curr > 1023) display_transform_double = 2;

   if (disp_w_curr < 1024) display_transform_double = 1;
   if (disp_h_curr < 700)  display_transform_double = 1;

   if (level_editor_running) display_transform_double = 1;

   if (help_screens_running)
   {
      if (disp_w_curr > 1279) display_transform_double = 2;
      if (disp_w_curr < 1280) display_transform_double = 1;
   }
   */
   set_display_transform();
   set_map_var();
}


where is it called?
init_display(void)
proc_display_change(void)
help start and exit
why on help??
comment those out...



this is at the start of edit_menu:

   int original_display_transform_double = display_transform_double;

//   int target_display_transform_double = 1; // this is the orig

   int target_display_transform_double = original_display_transform_double; // this is the hacked line

   if (disp_w_curr > 3800) target_display_transform_double = 2;
   if (display_transform_double != target_display_transform_double)
   {
      display_transform_double = target_display_transform_double;
      set_display_transform();
      set_map_var();
   }


this is at the end...

   if (original_display_transform_double != display_transform_double)
   {
      display_transform_double = original_display_transform_double;
      set_display_transform();
      set_map_var();
   }

comment those out too...done



now I want to save just a single variable in cfg file for this...

if -1 then autoset, otherwise it is display_transform_double




remove all calls to:
auto_set_display_transform_double()

and replace them with calls to:
set_display_transform()


then call:
auto_set_display_transform_double()

only from from:
set_display_transform()


pass a value to set_display_transform()

if 1-3 then set that
if -1 then auto...

need a global variable for value saved in config file


saved_display_transform_double


when called most of the time, use saved_dtd to set dtd...
that could be a forced value or -1 for auto


when called with a forced value, set saved_dtd to that value


most calls will be 0...
only when changing with F12 use a forced val...

this is getting complicated....


lets me try to simplify:

you can set the variable "saved_display_transform_double" in the config file or CTRL-SHIFT-F12

(1, 2, 3) - forces the specific value for display_transform_double
0 lets it be set automatically



20220506 6:20 AM
started converting zfs to the same scaled background stuff..
made all buttons and controls into a moveable window


20220507 5:00 AM
making good progress on zfs...

make the paste selection bitmap work....


how about taking it directly from level background?

should I aleady have level background hide items, enemies, etc if not selected??

I made it work with only one line:
al_draw_bitmap_region(level_buffer, stx*20, sty*20, sw*20, sh*20, gx*20, gy*20, 0);

now I want to filter it to only show what actually will be pasted...

I think I will need ft_bmp for that...
I want the level background to show everything
so that means my copying a region of it and excluding things will not work as is..


made it work...


void draw_fsel(void)
{
   if (copy_blocks)
   {
      init_level_background();
      get_new_background(0);
   }
   else
   {
      al_set_target_bitmap(level_buffer);
      al_clear_to_color(al_map_rgb(0,0,0));
   }


   if (copy_items) draw_items();
   if (copy_enemies) draw_enemies();
   if (copy_lifts) draw_lifts();


   int sw = sux-stx;
   int sh = suy-sty;
   al_destroy_bitmap(ft_bmp);
   ft_bmp = al_create_bitmap(sw*20, sh*20);
   al_set_target_bitmap(ft_bmp);
   al_clear_to_color(al_map_rgb(0,0,0));
   al_draw_bitmap_region(level_buffer, stx*20, sty*20, sw*20, sh*20, 0, 0, 0);
}

void zfs_redraw_background(int gx, int gy)
{
   al_flip_display();
   proc_scale_factor_change();
   proc_controllers();
   proc_frame_delay();
   get_new_background(0);
   draw_lifts();
   draw_items();
   draw_enemies();

   zfs_show_level_buffer_block_rect(stx, sty, sux, suy, 14, "selection");

   if (copy_mode)
   {
      int sw = sux-stx;
      int sh = suy-sty;
      al_draw_bitmap(ft_bmp, gx*20, gy*20, 0);
      zfs_show_level_buffer_block_rect(gx, gy, gx+sw, gy+sh, 10, "paste");
   }
   get_new_screen_buffer(3, 0, 0);
}


I would really like the selection to show as transparent when block are not being copied....

in order to make that work...
I need to create level_buffer like this:

   // create level_background and level_buffer bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
// al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);
   level_background = al_create_bitmap(2000,2000);
   level_buffer = al_create_bitmap(2000,2000);
//   printf("level_background\n");
//   show_pixel_format(al_get_bitmap_format(level_background));
//   show_bitmap_flags(al_get_bitmap_flags(level_background));

   // reset defaults to use for new bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);

then when I use it to create ft_bmp I need to clear it like this:
//al_clear_to_color(al_map_rgb(0,0,0));
al_clear_to_color(al_map_rgba(0,0,0,0));

then when I create ft_bmp I need to:
al_clear_to_color(al_map_rgba(0,0,0,0));

were all of these changes worth it?

pro's
- now all bitmaps are created with the same format

con's
- might use a little more memory

do it for now, but leave options to revert....

what is left?
- implement scroll...done


I think everything is working...

do some code cleanup and test....

// e_editor_zfs.h
void zfs_pointer_text(int x, int y, int ty);
void zfs_do_brf(int x, int y, int flood_block);
void zfs_clear_ft(void);
int zfs_load_selection(void);
void zfs_save_selection(int save);
int enforce_limit(int val, int ll, int ul);
int check_limit(int val, int ll, int ul);
void zfs_do_fcopy(int qx1, int qy1);
void zfs_do_clear(void);
void zfs_draw_selection_filters(int x1, int y1, int x2);
void zfs_draw_buttons(int x3, int x4, int yfb);
void zfs_proc_window_move(int *x1, int *y1, int *x2, int *y2, int w, int h);
void zfs_draw_fsel(void);
void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
void zfs_redraw_background(int gx, int gy);
int zfs_redraw_window(int zfs_window_x1, int zfs_window_y1, int zfs_window_x2, int zfs_window_y2, int gx, int gy);
int zoom_full_screen(int wx, int wy, int draw_item);


does anything in zfs use ty, bts..no mention at all....

what globals does it use?

extern int stx;
extern int sty;
extern int sux;
extern int suy;

extern int copy_blocks;
extern int copy_enemies;
extern int copy_items;
extern int copy_lifts;
extern int copy_flags;
extern int copy_mode;
extern int brf_mode;

extern int ft_level_header[20];
extern int ft_l[100][100];
extern int ft_item[500][16];
extern char ft_pmsgtext[500][500];

extern int ft_Ei[100][32];
extern al_fixed ft_Efi[100][16];

extern char ft_ln[NUM_LIFTS][80];
extern int ft_lift[NUM_LIFTS][6];
extern int ft_ls[NUM_LIFTS][40][6];


what would happen if I put some in the file zfs?
I moved all these to the start of e_editor_zfs and it compiles clean....

int copy_blocks=1;
int copy_enemies=1;
int copy_items=1;
int copy_lifts=1;
int copy_flags=1;
int copy_mode = 0;
int brf_mode =0;

int ft_level_header[20];
int ft_l[100][100];
int ft_item[500][16];
char ft_pmsgtext[500][500] = {0};


int ft_Ei[100][32];
al_fixed ft_Efi[100][16];

char ft_ln[NUM_LIFTS][80];
int ft_lift[NUM_LIFTS][6];
int ft_ls[NUM_LIFTS][40][6];


all that is left is these:
extern int stx;
extern int sty;
extern int sux;
extern int suy;

they are shared with group_edit...

do they need to be?  no....
but its nice that the selection is persitant between those two functions so I'm going to leave it

in block floodfill mode, show selected block...done


I am done with zfs..


move on to the hugest one of all...editor_main....

20220507 8:20 AM..
make point item blink on level background....



select_bitmap uses some shit from editor_main...
process_scrolledge();
update_editor_background();

lets fix that first
then remove...done


now I am working on showing the draw item....


there are a lot of function that are all doing close to the same thing



draw_item...get item shape...etc...



I want one function that when you pass it item number, it will draw the item...
either where it belongs in the level, or an arbitary x and y

in all cases, draw on whatever bitmap is active...

void draw_item(int i, int default, int x, int y, float scale);


this can be called by the main game draw_items..like:
 i, 1, 0, 0, 0)


I have gotten rid of the extra draw item stuff and now only use:
void draw_item(int i, int custom, int cx, int cy)

what about enemies? done also...

now that all looks good and much extra duplicated code has been removed....

why do I get a crash when putting draw item? i and e only not block....fixed...


what about the section where you draw under the windows...done...

what about multiple selected objects...seems like its working as well as it did before...


only 900 lines...and 235 are for setblockrange...

clean up function names..done..

// e_editor_main.h
void em_set_block_range(int bx1, int by1, int bx2, int by2);
void em_get_new_box(int*bx1, int*by1, int*bx2, int*by2);
char* em_get_text_description_of_block_based_on_flags(int flags);
void em_show_draw_item_cursor(void);
void em_draw_item_info(int x, int y, int color, int type, int num);
int edit_menu(int el);

now only 850 lines....


what globals does this use...
int draw_item_num;
int draw_item_type;
int point_item_type;
int point_item_num;










int move_pod_extended(int num)
{
   if (getxy("Pod Extended Position", 99, 7, num) == 1) return 1;
   else return 0;
}

replace with just: getxy("Pod Extended Position", 99, 7, num)


int move_trigger_box(int num, int type)
{
   if (get_block_range("Trigger Box", &Ei[num][11], &Ei[num][12], &Ei[num][13], &Ei[num][14], 2)) return 1;
   else return 0;
}

replace with just:
get_block_range("Trigger Box", &Ei[num][11], &Ei[num][12], &Ei[num][13], &Ei[num][14], 2)


ty is gone!!!

bts??

don't kill them all, just the global ones...

there are a lot of them especially in lifts...I'll come back to this...
zfs paste crashes....fixed

level disappears when moving status and selection window..fixed

erase background under flags

I am going to make status window do its own detection of mouse on window...done

make sel window take pointer parameter instead of convoluted return values


holy shit...under 50 lines!

int edit_menu(int el)
{
   al_show_mouse_cursor(display);
   level_editor_running = 1;
   resume_allowed = 0;
   draw_item_type = 1;
   draw_item_num  = 0;
   check_s_window_pos(0);
   load_PDE();
   sort_enemy();
   sort_item();
   set_swbl();
   set_frame_nums(0);
   for (int k = ALLEGRO_KEY_A; k < ALLEGRO_KEY_MAX; k++) mI.key[k] = 0; // clear_key array
   int quit=0, mouse_pointer_on_window=0;
   int gx=0, gy=0, hx=0, hy=0;
   if (!el) load_level_prompt(); // load prompt
   else load_level(el, 0);       // blind load
   if (autoload_bookmark)
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
         if ((bookmark_obj == 2) && (item[bookmark_num]))       object_viewerw(2, bookmark_num);
         if ((bookmark_obj == 3) && (Ei[bookmark_num]))         object_viewerw(3, bookmark_num);
         if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) object_viewerw(4, bookmark_num);
      }
   }
   while (!quit)
   {
      ovw_process_scrolledge();
      ovw_get_block_position_on_map(&gx, &gy, &hx, &hy);
      em_redraw_background(gx, gy);
      mouse_pointer_on_window = 0;
      if (status_window_active) process_status_window(0, gx, gy, &mouse_pointer_on_window);
      if (select_window_active) process_select_window(0, &mouse_pointer_on_window);
      if (!mouse_pointer_on_window) // mouse pointer is not on window
      {
         em_find_point_item(gx, gy, hx, hy);
         if (mouse_b1) em_process_mouse_b1(gx, gy);
         if (mouse_b2) quit = em_process_mouse_b2(gx, gy);
      }
      else point_item_type = -1; // to mark that
      quit = em_process_keypress();
   }
   level_editor_running = 0;
   al_hide_mouse_cursor(display);
   return last_level_loaded;
}


OK edit menu is looking really good....now what?

status window:

- somehow accomodate the button lists....
- erase background for flags..
- maybe make some buttons to turn on and off the more detailed shit...like buttons and flags...


PDE...can you redo it?...why?..its only ~500 self contained lines..

move status and select windows to their own file
or stick them in with editor...yes do that....done

db is gone...

z_map.cpp
omg...i did not even know this was still in the sources!  wow!....
I am removing so much stuff....


20220507 8:02 PM
code stats:
code stats:
39 files
23126 code only
 6983 empty lines
 4023 comment lines
 4331 code and comments
38463 total


--------

where are the flags drawn?


ftx text x
tfy text y

frx - tfx-frw-2

   if ((show_flag_details) && (draw_item_type == 1))
   {
      // flags section
      int ftx = swx1+11;
      int fty = swy1+47;
      int ys = 10; // y spacing
      draw_flag_text(ftx+4, fty, ys, 15, 0);

      int frw = 6;         // flag rectangle width
      int frh = 6;         // flag rectangle height
      int frx = ftx-frw-2;        // flag rectangle x
      int fry = fty - (frh/2)+4;  // flag rectangle y

      draw_and_proc_flag_rects_draw_item(frx, fry, frw, frh, ys);


      int frx2 = frx+frw;
      int fry2 = fty+frh+(ys*13);

      frx  -=2;
      frx2 +=2;
      fry  -=2;
      fry2 +=4;

      if ((mI.mouse_x > frx) && (mI.mouse_x < frx2) && (mI.mouse_y > fry) && (mI.mouse_y < fry2))
      {
         *mpow = 1;
         al_draw_rectangle(frx, fry, frx2, fry2, mC.pc[14], 1);
      }
   }


I'm going to change all of this
from now on, you just draw the rectangle and pass x and y
the text will automatically be called..
int draw_flags(int x1, int y1)
done and it looks good...
I have a dilemma...
when on a window, the flags don't show, the point item flags dissappear then a block is selected as point item
and the flags reappear
just don't do mpow...done
now all the flag drawing for draw item, point item and block select all use the same function..



maybe a second line in status window
ore controls like:
simple/detailed descriptions
sndb on/off
save
zfs
ge

make button list better...its as good as it gets

I really want to get a handle on the proliferation of globals and find an elegant way to encapsulate them...


20220508 - 6:00 AM

bug...items are all messed up with number like 42 of 0...fixed
sort was done before load level at start of edit menu



in all of these level editor map things I want a thin line to show the edge of the level if smaller than the screen...done



bug...group edit, when mouse on list, flash on screen..
when highlight are show in draw on level buffer, they are cleared first..
when this is removed it works, but they need to be cleared somehwere...
fixed by on checking for mouse on item in map if mouse not on window



--make the copying of items secondary things like keys block range work like map move with holding shift
instead of native pop up prompts.

tried to copy from zfs but that was wrong too...

make a txt file that describes all the different rectangles and formats...done...

now fix it...I have made em copy move the stuff correctly....

lets actually change all the things to a common format....

very easy should be pmg
position from 100 to 2000


do a glt thing to muliply all 10 and 11 by 20...done
changed void draw_pop_message(int i)
they work fine in game...

map move....done...
adjust in ov...follow button to getxy and fixed there...
create...works fine
edit text...all good...one done!!!
wait!!! what about:

obv move main item..msg should follow....
copy with em...done..moves msg too
copy with zfs...not yet...
in zfs you have to adjust when saving and loading...done
copy with cloner...

secondary items move:
msg
k t m d

em copy....done
zfs paste...done
ov map move..done
cloner copy..only message text was changed nothing adjusted

ok items should be all done...


next do pod and cloner trigger
range and w h
this could take some time

x1 = Ei[][11];
y1 = Ei[][12];
x2 = Ei[][13];
y2 = Ei[][14];

glt line....


      for (y=0; y<100; y++)
         if ((Ei[y][0] == 7) || (Ei[y][0] == 9))
         {
            int w = Ei[y][13] - Ei[y][11];
            Ei[y][11] *= 20;
            Ei[y][13] = w*20;

            int h = Ei[y][14] - Ei[y][12];
            Ei[y][12] *= 20;
            Ei[y][14] = h*20;

         }

backup levels and pull the trigger.....done...

now where to start...


void enemy_cloner(int e)

old:
   int x4 = Ei[e][11]*20 - 10; // trigger box
   int y4 = Ei[e][12]*20 - 10;
   int x5 = Ei[e][13]*20 + 10;
   int y5 = Ei[e][14]*20 + 10;

new:
   int x4 = Ei[e][11] - 10; // trigger box
   int y4 = Ei[e][12] - 10;
   int x5 = Ei[e][11] + Ei[e][13] + 10;
   int y5 = Ei[e][12] + Ei[e][14] + 10;


draw cloner...

old:
      // trigger box
      float tx1 = (float)Ei[e][11]*20;
      float ty1 = (float)Ei[e][12]*20;
      float tx2 = (float)Ei[e][13]*20+20;
      float ty2 = (float)Ei[e][14]*20+20;
new:
      // trigger box
      float tx1 = (float)Ei[e][11];
      float ty1 = (float)Ei[e][12];
      float tx2 = (float)(Ei[e][11]+Ei[e][13]+20);
      float ty2 = (float)(Ei[e][12]+Ei[e][14]+20);

void ovw_draw_overlays(int obt, int num, int legend_highlight)

pod old:
            int tx1 = Ei[num][11]*20;
            int ty1 = Ei[num][12]*20;
            int tx2 = Ei[num][13]*20 + 20;
            int ty2 = Ei[num][14]*20 + 20;
pod new:
            int tx1 = Ei[num][11];
            int ty1 = Ei[num][12];
            int tx2 = Ei[num][11]+Ei[num][13] + 20;
            int ty2 = Ei[num][12]+Ei[num][14] + 20;

same for cloner


void ovw_map_move(int &obt, int &num)
old:
            int x1 = Ei[b][11]*20;
            int y1 = Ei[b][12]*20;
            int x2 = Ei[b][13]*20+20;
            int y2 = Ei[b][14]*20+20;
new:
            int x1 = Ei[b][11];
            int y1 = Ei[b][12];
            int x2 = Ei[b][11]+Ei[b][13]+20;
            int y2 = Ei[b][12]+Ei[b][14]+20;



old:
         if (mouse_on_tb_ul) // move trigger box from ul
         {
            //printf("mouse pressed on tb_ul\n");
            // get the width and height
            int w = Ei[num][13] - Ei[num][11];
            int h = Ei[num][14] - Ei[num][12];
            // set new position
            Ei[num][11] = gx;
            Ei[num][12] = gy;
            Ei[num][13] = gx+w;
            Ei[num][14] = gy+h;
new:
         if (mouse_on_tb_ul) // move trigger box from ul
         {
            //printf("mouse pressed on tb_ul\n");
            Ei[num][11] = gx*20;
            Ei[num][12] = gy*20;
         }


old:
         if (mouse_on_tb_lr)  // resize trigger box from lr
         {
            // prevent lr corner from being less than ul corner
            if (gx < Ei[num][11]) gx = Ei[num][11];
            if (gy < Ei[num][12]) gy = Ei[num][12];
            // set new postion
            Ei[num][13] = gx;
            Ei[num][14] = gy;
         }

new:
         if (mouse_on_tb_lr)  // resize trigger box from lr
         {
            // prevent lr corner from being less than ul corner
            if (gx < Ei[num][11]/20) gx = Ei[num][11]/20;
            if (gy < Ei[num][12]/20) gy = Ei[num][12]/20;
            // set new postion
            Ei[num][13] = gx*20 - Ei[num][11];
            Ei[num][14] = gy*20 - Ei[num][12];
         }



old:
               if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT])) // move stuff also
               {
                  // move podzilla's trigger box too
                  if (Ei[num][0] == 7)
                  {
                     Ei[num][11] += x_off;
                     Ei[num][12] += y_off;
                     Ei[num][13] += x_off;
                     Ei[num][14] += y_off;
                  }
                  // move cloner's stuff too
                  if (Ei[num][0] == 9)
                  {
                     Ei[num][11] += x_off; // trigger box
                     Ei[num][12] += y_off;
                     Ei[num][13] += x_off;
                     Ei[num][14] += y_off;


new:
               if ((mI.key[ALLEGRO_KEY_LSHIFT]) || (mI.key[ALLEGRO_KEY_RSHIFT])) // move stuff also
               {
                  // move podzilla's trigger box too
                  if (Ei[num][0] == 7)
                  {
                     Ei[num][11] += x_off*20;
                     Ei[num][12] += y_off*20;
                  }
                  // move cloner's stuff too
                  if (Ei[num][0] == 9)
                  {
                     Ei[num][11] += x_off*20; // trigger box
                     Ei[num][12] += y_off*20;
                     Ei[num][15] += x_off; // source
                     Ei[num][16] += y_off;
                     Ei[num][17] += x_off; // dest
                     Ei[num][18] += y_off;
                  }


all that seem to work great:

now onto
em_copy
old:
            if (al_show_native_message_box(display, "Move?", "Move podzilla's trigger box too?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
            {
               Ei[c][11] = Ei[din][11] + ofx/20;
               Ei[c][12] = Ei[din][12] + ofy/20;
               Ei[c][13] = Ei[din][13] + ofx/20;
               Ei[c][14] = Ei[din][14] + ofy/20;

new:
               Ei[c][11] = Ei[din][11] + ofx;
               Ei[c][12] = Ei[din][12] + ofy;

same for cloner...tested








zfs_copy

old save:

            if (ft_Ei[c][0] == 7 ) // podzilla
            {
               ft_Ei[c][11]-= x1/20;
               ft_Ei[c][12]-= y1/20;
               ft_Ei[c][13]-= x1/20;
               ft_Ei[c][14]-= y1/20;
            }
            if (ft_Ei[c][0] == 9 ) // cloner
            {
               ft_Ei[c][11]-= x1/20;
               ft_Ei[c][12]-= y1/20;
               ft_Ei[c][13]-= x1/20;
               ft_Ei[c][14]-= y1/20;

new save:
            if (ft_Ei[c][0] == 7 ) // podzilla
            {
               ft_Ei[c][11]-= x1;
               ft_Ei[c][12]-= y1;
            }
            if (ft_Ei[c][0] == 9 ) // cloner
            {
               ft_Ei[c][11]-= x1;
               ft_Ei[c][12]-= y1;

old fcopy:
                  if (Ei[c][0] == 7) // podzilla trigger box
                  {
                     Ei[c][11]+= x3/20;
                     Ei[c][12]+= y3/20;
                     Ei[c][13]+= x3/20;
                     Ei[c][14]+= y3/20;
                  }
                  if (Ei[c][0] == 9) // cloner
                  {
                     Ei[c][11]+= x3/20;
                     Ei[c][12]+= y3/20;
                     Ei[c][13]+= x3/20;
                     Ei[c][14]+= y3/20;

new fcopy:
                  if (Ei[c][0] == 7) // podzilla trigger box
                  {
                     Ei[c][11]+= x3;
                     Ei[c][12]+= y3;
                  }
                  if (Ei[c][0] == 9) // cloner
                  {
                     Ei[c][11]+= x3;
                     Ei[c][12]+= y3;

that works flawlessly


create and move with buttons...done

in: int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2, int type)
could modified type 2 only used for this

or I can try type 1...
size is off by one

modify type 2 then...done...


now on to cloner source and dest and then I will be done....


glt line:

      // converting cloner source and dest from 100 xywh to 2000 xywh format
      for (int y=0; y<100; y++)
         if (Ei[y][0] == 9)
         {
            Ei[y][15] *= 20;
            Ei[y][16] *= 20;
            Ei[y][17] *= 20;
            Ei[y][18] *= 20;
            Ei[y][19] *= 20;
            Ei[y][20] *= 20;
         }



backup levels and do it...





void enemy_cloner(int e)
draw cloner
void ovw_draw_overlays(int obt, int num, int legend_highlight)
map move...
all done...

I think this is all done....

now all rects have the same format

implement the shift thing in em copy...done




filter for object viewer..controls what the map move snaps to...
i, e, l and sub types...
i picture clicking on the top bar and a drop down filter list will pop up...

this will be used by more than just viewer
ge has one
zfs has one

I want to make a common very good one

ge has the most detailed one

could right click on it and get a popup menu:
clear all
clear all items
clear all enemies
set all enemies
set all items

It should also have lifts, blocks and block flags,
altough they won't be needed in every case, but they can be turned on and off as needed.

What variable structure?


int obj_filter[4][20] = {0};

change this to 5 and make it global

1 block
2 item
3 enemy
4 lift



ge - item and enemies only
ov - item, enemies, lifts
zfs - everything
em - ???

pass an int mode

now show it in ov

now use it in ov
map move....

that is fucking awesome...


now I want to be able to collapse it and stick it on the top border


it should be easy to use it for zfs also...

lifts, block and flags already have corresponding buttons

the only difference will be to filter for item and enemy types

but before I do that...
i want to make it an independant window
moveable, collapseable, resizable
is there a case for making this a structure?
all variables could be contained there.
and all in one source file

first of all it needs its own x and y positions
and hidden or not..

int ft_window_x1 = 100;
int ft_window_x1 = 180;
int ft_window_y1 = 200;
int ft_window_collapsed = 0;




i ran into a problem when one window is on top of another..
you would expect the window on top to be the active one, but..
on top just means it was draw last...
the one underneath that was drawn first will eat the mouse clicks first...


20220508
got filter window to work
it moves and it collapseable...
need to figure out how to make only one window get mouse when more than one overlap and are active
once i figure that out the rest of the window stuff will work

I might have to do more window management stuff, but it might be worth it in the end.

i also have to do something to make sure all these new moveable window are not off

redo push..crashed last time..hope it's ok










to solve my window problem....

I need to get more complex...

each window should be like an object..a C++ object...

it should have its own variables, methods, etc...

it should keep track of its position and size..

it should have a method to draw itself and a separate method to accept input

lets see what I can do with this, with the filter window....

class mWindow
{
   public:
   int x1, y1, x2, y2, w, h;
   void set_pos(int, int);
   void set_size(int, int);
};

void mWindow::set_pos(int x, int y)
{
   x1 = x;
   y1 = y;
   x2 = x + w;
   y2 = y + h;
}

void mWindow::set_size(int sw, int sy)
{
   w = sw;
   h = sh;
   x2 = x + w;
   y2 = y + h;
}

where do I declare it?
in pm.h

20220510 6:00 AM

Some thought on windows..

declare an array of them so they can be accessed in a loop

each one will have properties like:

active
has_focus
draw_order
moveable

'active'
used to determine if the window is shown or hidden
if not active the window is completely ignored, not drawn or processed at all
I am thinking that only one should accept input at a time
and I am thinking of enfocring that by only allowing one to have focus

'has_focus'
if the mouse moves to another window, that window will grab focus
when a window has focus, show it with a frame highlight
if the mouse is on multiple windows do not change focus
only when the mouse is on only one window
only the window that has focus can accept input or be moved

'draw_order'
maybe not needed as long as window that has fcous is drawn last



when they are called in a loop, the entire edit menu will change...

- draw level background, but customized, based on what edit_mode we are in
- process the window loop that draws and accepts input from all the active windows
- process mouse click and drags on the background based on what mode we are in..


the modes will be:
- edit menu
- group edit
- object viewer
- zfs

I will have a separate file for each window...
status
select
filter
object_viewer
zfs action
group edit list
group edit buttons

- edit menu
status
select

- group edit
filter
group edit list
group edit buttons

- object viewer
filter
object_viewer

- zfs
filter
zfs action


Then I can do things with each window like:
resizeable or not
moveable or not
collapseable or not
dockable to the frame

Then I can implement a method to ensure they are not off the edges of the screen

This will be a major re-write, but I think it will be worth it.

Buttons and slider will all have to be modified.
They need a variable they are passed that tells them to draw only or draw and process mouse clicks




I cannot get clipping to work....probably has something to do with display transform

   /*

   int cx, cy, cw, ch;
   al_get_clipping_rectangle(&cx, &cy, &cw, &ch);
   printf("1 - x:%d y:%d w:%d h:%d\n", cx, cy, cw, ch);



   al_set_clipping_rectangle(x1, y1, w, h);

   al_get_clipping_rectangle(&cx, &cy, &cw, &ch);
   printf("2 - x:%d y:%d w:%d h:%d\n", cx, cy, cw, ch);

//   al_reset_clipping_rectangle();


*/




20220510 6:00 PM

I have a nice example going...3 window in an array...

- the class "mWindow" is defined in pm.h
- all the member functions are prototyped there too

the actual function implementations are all in c_mWindow.cpp

10 objects are declared in main and externed in pm.h

mWindow mW[10];
this should make them visible everywhere


make only one have focus...
or none...

I might have to go higher...
run through all windows, but only detect if mouse is on window

if only one window set that to the one that has focus

if more than one, choose the one with the high layer (or draw order)...

i could achieve the same effect by drawing them in reverse order and detecting mouse on in that order

start with mouse_on_window = 0

if on lowest window set mow to that window
then move to higher windows
if any overlap the higher ones will overwrite the lower one...

maybe this is all too complex

draw order...0 is on top and is the only one with focus

whenever a new one is brought to top all others slide down in order

what I did:
int layer
draw them in order by layer and detect mouse also
that way the highest layer mouse detection will override lower layers
mouse detected window has focus

this works good but the draw order never changes

how about at the end...
make the mouse detected window the highest layer

function to re-arrange layers


pass it a window number..

void set_to_new_top_layer(int wn)
{
   // get layer number of wn we are promoting
   int oln = mW[wn].layer;

   // slide everything up one layer (add 1 to all layers)
   for (int a=0; a<NUM_MW; a++)
      if (mW[a].active) mW[a].layer++;

   // set new top layer
   mW[wn].layer = 0;

}

it is looking good..
I can move and resize
only one window has focus and is on top


lets add some more functionality like
moveable
resizable
min_w
min_h
max_w
max_h

it might be time to make some numbers permanently tied to window numbers...

filter = 3;
always....

make a custom function to draw the buttons
done

edit toggle so that it can do the read only thing..
find unused var...q7

how about:
q6 = draw
q7 = process input

done...i bet that broke a lot of stuff!!!

eventually I will do this for all the buttons and slider...

wait...in the interests of not breaking everything and being backwards compatible....
lets reverse those.....
q6 = don't draw (hide)
q7 = don't process input

that works!!!

I am on the way!!!

now implement the collapse button on the title bar...

use a toggle but with only a single char + or -
make a way to not draw the frame...

when in drag mode, deactivate the button detection...
still if you drag too fast and the mouse in on the buttons it freezes...done...

20220512 6:30 AM  push

implement the +/- collapse button

what kind of button?? the same!
that was easy!
still need to make it look better, like with no frame...done...

bug..why do I have a funny sized red rect when moving window...
its like my y2 is off...fixed..when I set y2 I also need to set h

implement the b2 menu...done..

I think filters is perfect...

next up for an easy one...

status_window

will always be 1...

fixed size..

I think I want to make mouse_on_window a static int in the class
i will still need to externally clear, check and set it.
but then I could see it inside the instances...
try it...
cant get it to work...
make it a global...no need, just calulate in place

status window looks perfect
hide old one...done
make pop up menu for status window to show/hide sbf..done

when moving a window, show all windows...done
need to make an external funtion to draw all windows in order...done

status window looks great...
still want to:
make status window collapse like filters
when collapsed move y pos to title bar

now all I need to do in a loop is:
mouse_on_window = mw_cycle_windows(0);

move on to select window...it will be 2...

selection window is coming along fine....

currently working on text desription lines for special...
and how to only show if mouse is on window and selection is valid...fixed...use have_focus

push

20220513 6:32 AM
friday the 13th!...woooo!
now show blocks....
holy shit this is coming along so good...i think its done....

when resuming game, items return to start of level positions
more accuratlely, when exiting to menu...
sort item called by item_data to show list of items on menu
I hope removing it wont mess things up...

lift viewer end step text wrong..is is only on old lifts??
now I can't reproduce...
I found some lifts that have an end step with a val of 20
don't know how it happened, this should not be
I think the value used to be ignored until recently when I made different types of end step
used glt to make all 20 into 0
changed buttons to show undefined val


20220513 6:00PM
make filters collapse to top frame
when collapsed, can still move in x axis
restoring restores both x and y
will need more variables...
int alt1_x1
int alt1_y1

int alt2_x1
int alt2_y1

collapsing switches to using alt2

normal:
collapse = 0;
use x1 and y1


switch to collapse
put x1 and y1 in alt1
get x1 and y1 from alt2
only allow x move...

switch to expand
put x1 and y2 in alt2
get x1 and x2 from alt1
back to normal...

this all sounds so complex....

enforce windows to be on screen...done

fix the bug - cannot draw backwards selection in em...
or in zfs
or in ge

fix it once and use it everywhere dammit

first click...set x1, y1
release...set x2, y2
simple...

show proper progress

void get_new_box(void) // keep the mouse !!
{
   int z; // for swap
   bx2 = bx1; // set all three to intial
   by2 = by1;
   int x1 = bx1;
   int y1 = by1;
   int x2 = bx2;
   int y2 = by2;

   while (mouse_b1)
   {
      al_flip_display();
      proc_controllers();
      show_draw_item_cursor();
      process_scrolledge();
      update_editor_background();

      bx2 = (mI.mouse_x)/20+wx; // set both with mouse pointer
      by2 = (mI.mouse_y)/20+wy;

      x2 = bx2;  // set with mouse
      y2 = by2;

      x1 = bx1; // get inital in case it was swapped
      y1 = by1;

      // swap x1 and x2 if neccesary
      if (x1 > x2) { z = x1; x1 = x2; x2 = z;}
      if (y1 > y2) { z = y1; y1 = y2; y2 = z;}

      if (x1>99) x1 = 99;
      if (y1>99) y1 = 99;
      if (x2>99) x2 = 99;
      if (y2>99) y2 = 99;

      // show the selection rectangle
      al_draw_rectangle((x1-wx)*20, (y1-wy)*20, (x2-wx)*20+19, (y2-wy)*20+19, mC.pc[127], 1);
      al_draw_textf(font, mC.pc[15], 100, 20, 0, " x1:%d y2:%d ", x1, y1);
      al_draw_textf(font, mC.pc[15], 100, 28, 0, " x2:%d y2:%d ", x2, y2);

   }
   // swap bx1 and bx2 if neccesary
   if (bx1 > bx2) { z = bx1; bx1 = bx2; bx2 = z; }
   if (by1 > by2) { z = by1; by1 = by2; by2 = z;}

   // always set second to one more
   bx2++;
   by2++;
}


fuck it...make it so that they can be the same......



what is stx, sty, sux, suy bullshit?
lets use..bx1, by1, bx2, by2 // block selection x1, y1, x2, y2
main and pm.h...done

I should remove all traces of stx and sty and fix stuff as I go...

ge_edit first.....I think it is done....all that was needed was to add selection to list....

can I make this common?

I think zfs is good....


all stx shit is gone...

I want to make the function that draws the sel on level buffer common...

void ge_draw_box(void)
{
   int x1 = bx1;
   int y1 = by1;
   int x2 = bx2;
   int y2 = by2;
   if (x1 > x2) swap_int(&x1, &x2);
   if (y1 > y2) swap_int(&y1, &y2);
   int dstx = x1*20;
   if (dstx == 0) dstx = 1;
   int dsty = y1*20;
   if (dsty == 0) dsty = 1;
   al_draw_rectangle(dstx, dsty, (x2*20)+19, (y2*20)+19, mC.pc[14], 1);
   al_draw_text(font, mC.pc[14], x1*20+2, y1*20+3,  0, "selection");
   //al_draw_textf(font, mC.pc[14], x1*20+2, y1*20+3,  0, "selection bx1:%d by1:%d bx2:%d by2:%d", bx1, by1, bx2, by2);
}

void zfs_show_level_buffer_block_rect(bx1, by1, bx2, by2, int color, "selection")

void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)
{
   if (x1 > x2) swap_int(&x1, &x2);
   if (y1 > y2) swap_int(&y1, &y2);
   int dstx = x1*20;
   if (dstx == 0) dstx = 1;
   int dsty = y1*20;
   if (dsty == 0) dsty = 1;
   al_draw_rectangle(dstx, dsty, (x2*20)+19, (y2*20)+19, mC.pc[14], 1);
   al_draw_text(font, mC.pc[color], x1*20+2, y1*20-11,  0, text);
}
done...
now there is only one....
void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)

patch it into em....done...

bug zfs does not copy items....yes it does...
sort item used to set itemf pos, removed to fix another bug...

now I made item sort set itemf for all cased except the one where items are listed...

next I will do zfs...its a simple single window
then make the new filter window work with zfs...

then group edit...
it has:
-filter window
-a few buttons
-list
-gedit action list
I will probably attach the buttons to the list and make the action stuff a separate window

then object viewer..
one window and filters...
this could take some time cleaning up all the sliders and buttons, there are a lot!!!

finally when all of that is done....

make more things common...

all of these methods that I am treating as separate:
em
ge
ov
zfs

they all have many things in common...

they all have the scaled level as the background

the redraw background will be made to be common
with custom drawing on the level background as necessary for each mode...
em:
selection,
non-defult flags

zfs:
selection

group edit:
selected objects

ov:
lots of things to adjust

then after the get screen buffer:
then window processing will be very streamlined..

then if mouse not on window, process mouse on the background...
quite a lot......

first things...i need to get all the windows working under the new manager...

in zfs loop...
put filter...

20220514 5:00AM

make zfs use filter window values...

should be easy for lifts, blocks, flags, they have a 1-1 with exist buttons...
old var:
int copy_blocks=1;
int copy_enemies=1;
int copy_items=1;
int copy_lifts=1;
int copy_flags=1;

new vars:
obj_filter[1][1],  "Blocks"
obj_filter[1][2],  "Flags"
obj_filter[4][1],  "Lifts"

obj_filter[3][3],  "Arcwgn"
obj_filter[3][4],  "Bouncr"
obj_filter[3][6],  "Cannon"
obj_filter[3][7],  "Podzil"
obj_filter[3][8],  "Trakbt"
obj_filter[3][9],  "Cloner"
obj_filter[3][10], "Field"
obj_filter[3][11], "Blk Wk"
obj_filter[3][12], "Flappr"

obj_filter[2][1],  "Door"
obj_filter[2][2],  "Bonus"
obj_filter[2][3],  "Exit"
obj_filter[2][4],  "Key"
obj_filter[2][5],  "Start"
obj_filter[2][7],  "Mine"
obj_filter[2][8],  "Bomb"
obj_filter[2][9],  "Triggr"
obj_filter[2][10], "Messge"
obj_filter[2][11], "Rocket"
obj_filter[2][12], "Warp"
obj_filter[2][14], "Switch"
obj_filter[2][15], "Spring"
obj_filter[2][16], "Blk Mn"
obj_filter[2][17], "Blk Dm"

obj_filter[2][item[b][0]]

if ((item[b][0]) && (item[b][4] >= x1) && (item[b][4] < x2) && (item[b][5] >= y1) && (item[b][5] < y2))

filter window has been integrated into zfs...

now convert window to 4...

what if I try status window for zfs?



---- should I just bite the bullet and make gx, gy, hx, hy global?????
I pass them around a lot....
do it...right beside bx1...

there are a lot of refernces...

start by removing all other declarations..done 11 times...

now stop passing them to this
ovw_get_block_position_on_map(&gx, &gy, &hx, &hy); .. done 19 refs

OK I think Im done....

new zfs looks good..disable old one....

now fix the buttons so they only detect mouse b when have focus

int mw_draw_filter_buttons(int x1, int x2, int y1, int mode, int have_focus, int moving)
{
   int d = 1;
   if (have_focus) d = 0;
   if (moving) d = 1;


this uses custom buttons...
610, 611, 612
620, 621, 622, 623, 624

replace them all with generic

if (mdw_button(x3, yfb, x4, yfb+bnh, 610, 0,  0, 0, 0,  9, 15, 0, 1,0,0,0)) // block fill

// just display a text string, and return 1 if pressed
int mdw_buttont(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7, const char* txt)

those buttons are completely removed....
there is some weirdness around block fill and frame...

   if (draw_item_type == 1) // don't even show these 3 buttons unless draw item type is block
   {
      yfb+=bnh/2; // spacing between groups
      if (mdw_buttont(x3, yfb, x4, yfb+bnh, 0,0,0,0, 0,9,15,0, 1,0,0,d, "Block Fill"))
      {
         for (int x=bx1; x<bx2+1; x++)
            for (int y=by1; y<by2+1; y++)
            {
               if ((obj_filter[1][2]) && (obj_filter[1][1]))  l[x][y] = draw_item_num;
               if ((obj_filter[1][2]) && (!obj_filter[1][1]))
               {
                  int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
                  l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
                  l[x][y] |= flags;                                // merge
               }
            }
         init_level_background();
      }
      yfb+=bnh+2;
      if (mdw_buttont(x3, yfb, x4, yfb+bnh, 0,0,0,0, 0,9,15,0, 1,0,0,d, "Block Frame"))
      {
         for (int x=bx1; x<bx2+1; x++)
         {
            l[x][by1] = draw_item_num;
            l[x][by2] = draw_item_num;
         }
         for (int y=by1; y<by2+1; y++)
         {
            l[bx1][y] = draw_item_num;
            l[bx2][y] = draw_item_num;
         }
         init_level_background();
      }
      yfb+=bnh+2;

make a function to set a block from draw_item

void set_block_from_draw_item(int x, int y)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {

      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = draw_item_num;

      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {
         int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
         l[x][y] |= flags;                                // merge
      }

      // blocks only (same as block and flags???)
      if ((obj_filter[1][1]) && (obj_filter[1][2])) l[x][y] = draw_item_num;
   }
}

8:00 AM I think zfs is done

moving on to group edit
the list window will be 5..
disable existing filter window...

ge list was very easy to add....
make the draw only version....done
ge_show_obj_list(int x, int y, int *ew, int *eh)

ge list is done....

next....
ge controls will be 6

looking good....
give it a title bar for dragging...done
remove old one...i removed a lot

draw only buttons...done

find a way to implement mouse on window so mouse click won't pass through to level beneath..done

find a way to add functionality of two buttons....
show selection
add selection to list
and maybe more...
pop up menu toggles...
show/hide selection
put in on the object list...done

hide when no valid controls...
here is the thing...if I make the window inactive, i won;t be able to detect when to bring it back???
I can do it from the list maybe...
or I can make another setting for mWindows called hidden...done


11:31 AM

my next step is a big one...

object viewer is huge...

luckily there is only window....
it will be 7

it still uses the old filters....

it needs some clean up....

all these four modes should be cleaned up so that they all look common and can be integrated easily


something is stealing my mouse....fixed

making a new title function...

pass it x1, y1, x2, y2...something else will figure that out....
this is not the place to do it...


OK i got the title to somewhat work....
only buttons left

the height is working good...
get the return mb to where I can use it...done...
now the legend highlights...

making great progress....

now to go through all the buttons...

clean them up...and make them respect draw only...
everything in sliders has been modified to be read only if q7==1
everything in buttons has been done too....
yay!!!

20220514 7:00PM
I have probably introduced some bugs that I will need to catch...
the next thing on the list was to try to merge and simplify more things

make an global int that tells me what mode the level editor is in

level_editor_mode
0 = undef
1 = em
2 = zfs
3 = ge
4 = ov

make a common redraw background function
void cm_redraw_level_editor_background(int mode)
{

em replaced 3 calls
zfs replaced 2 calls
ge replaced 2 calls
ov 3 calls and 4 in lifts...
that is coming along nicely....

I know I have some bugs in the lifts stuff
but what the hell am I going to do about it?...fixit!!

so the high level common stuff....

- redraw the background
- redraw the windows

- process mouse on windows
- process mouse on background

this is pretty much done like this:

      cm_redraw_level_editor_background();

      mouse_on_window = mw_cycle_windows(0);

      if (!mouse_on_window) // mouse pointer is not on window
      {
         em_find_point_item();
         if (mouse_b1) em_process_mouse_b1();
         if (mouse_b2) quit = em_process_mouse_b2();
      }
      else point_item_type = -1; // to mark that
      quit = em_process_keypress();


20220515 6:00 AM
cleaning up...

made some common functions:
void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)
void cm_get_new_box(void)
make get box use my new stuff...done...
lets do getxy also...

make a version of cm_redraw_level_editor_background() that stops just before get_new_screen_buffer()
mode 0...

more common stuff sorted out..
run lifts looks good now....

what about mouse_on_window??
for all the bullshit time I spend passing it around...
I could make it a global...
make it part of the mWindow class...
calculate it every time I need it...
how about

this is how condensed I got the edit menu loop:

em:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) quit = em_process_mouse();
   quit = em_process_keypress();
}

lets see if I can do similar for others

zfs:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) zfs_process_mouse();
   quit = zfs_process_keypress();
}

ge:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) ge_process_mouse();
   quit = ge_process_keypress();
}
ovw:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) ovw_process_mouse();
   quit = ovw_process_keypress();
}


now...

go through the variables....
each window used to have its own custom global variables...

I could hide a lot of the window globals in mWindow...

got rid of a bunch, but these I will add...

// status window only used by mW[1]
extern int draw_item_num;
extern int draw_item_type;
extern int point_item_type;
extern int point_item_num;

// object viewer window
extern int ov_window_lift_buttons_h;

// status window
extern int draw_item_num;
extern int draw_item_type;
extern int point_item_type;
extern int point_item_num;

// select window
extern int select_window_block_on;
extern int select_window_special_on;
extern int select_window_num_special_lines;

extern int swbn;  // number of special
extern int swnbl; // number if special lines (just swbn / 16 + 1)
extern int swnbl_cur; // current number of lines shown
extern int swbl[NUM_SPRITES][2];

extern int show_non_default_blocks;
extern int show_flag_details;

Well I got rid of a lot.....the list is smaller now

lifts seem to work fine
pop message seem to be fine


viewer lock has some issues:
- when locked, it still switches
- can't move any secondary stuff on map for current object when not selected in filters...
if viewer lock on and current obt = 3
only do stuff for that
wow this is tougher that I thought...
if viewer_lock only process move for main obj and aux things for that object...
if obt is different dont even do that section...
maybe I need to split this huge function into detection and processing....
its kind of like that already...only one thing can be pass to the second half for adjustment
the detection part will stop at the first valid match and send it....
another assumption is that if you are adjusting a secondary thing, the main object is set to current object
I think I have fixed it....

I want to see the non-default blocks in the draw item and view_item and draw item cursor....done

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
running level editor for level:4
00000000 00011001 00000000 10000000  - draw_item
00000000 00011001 00000000 00000000  - flags only
00000000 00011111 00000000 11011100  - destination block
00111111 11111111 00000000 00000000  - PM_BTILE_MOST_FLAGS
11000000 00000000 11111111 11111111  - ~PM_BTILE_MOST_FLAGS
00000000 00000000 00000000 11011100  - destination block =~PM_BTILE_MOST_FLAGS
00000000 00011001 00000000 11011100  - merge l[x][y] |= flags

this works exactly as intended....

void set_block_from_draw_item(int x, int y)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {

      printBits(4, &mW[1].draw_item_num);
      printf("%s - draw_item\n", msg);

      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = mW[1].draw_item_num;




      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {

         int flags = mW[1].draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item

         printBits(4, &flags);
         printf("%s - flags only\n", msg);


         printBits(4, &l[x][y]);
         printf("%s - destination block\n", msg);

         int f = PM_BTILE_MOST_FLAGS;
         printBits(4, &f);
         printf("%s - PM_BTILE_MOST_FLAGS\n", msg);


         f = ~PM_BTILE_MOST_FLAGS;
         printBits(4, &f);
         printf("%s - ~PM_BTILE_MOST_FLAGS\n", msg);


         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
         printBits(4, &l[x][y]);
         printf("%s - destination block =~PM_BTILE_MOST_FLAGS\n", msg);

         l[x][y] |= flags;                                // merge
         printBits(4, &l[x][y]);
         printf("%s - merge l[x][y] |= flags\n", msg);


      }

      // blocks only (same as block and flags?)
      if ((obj_filter[1][1]) && (!obj_filter[1][2])) l[x][y] = mW[1].draw_item_num;
   }
}

I think I was expecting the other part of zfs to do this...the copy paste...
I made a common function to do both:


void set_block_with_flag_filters(int x, int y, int tn)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {
      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = tn;

      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {
         int flags = tn & PM_BTILE_MOST_FLAGS; // get only flags from draw item
         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                       // clear flags in destination
         l[x][y] |= flags;                                      // merge
      }
      // blocks only (same as block and flags?)
      if ((obj_filter[1][1]) && (!obj_filter[1][2])) l[x][y] = tn;
   }
}

look into brf mode also...done...

also if block filter is not set, nothing gets copied to ft_...fixed

make it so that the paste selection is updated when ever filter changes...done...

clean up variables for old window positions...
maybe find a way to save them...
I could save the entire array of window objects...
have a simple load and save thing...T-save Y-load
when do I load? in
save when quitting level editor
load when starting
seems to work pretty good...


20220516 4:30AM

rockets cannot go through semisolid..has it alwats been this way?
I could just clear item solid...

rockets can go off the edge of the level....fixed for all items


demo mode annoys me when it starts in the middle of things I am doing
I could make it start on a timer, but only if nothing happens after the program is first run
after that do not automatically start it again
done...and it is so much nicer now!


add 4 keys to PDE and remove key creator....done



I am going to remove enemy field...everything it does can be done with trig, bm and bd...
PDE is removed....

20220516 6:30 AM push

bug...when moving lift step from map move, take into account the offset...done

in PDE custom draw 4 keys and 4 switches on a line by themselves...done
allow key color (and switch) to be changed in viewer...done

when doing highlights for key, show blocks that will be removed...done...
do the same for switch...done...


20220517 4:30 AM

clean up the mWindows stuff

there are 4 outside functions that are used to do things to all mWindows:

void set_windows(int mode)
int is_mouse_on_any_window(void)
int mw_get_max_layer(void)
int mw_cycle_windows(int draw_only)
they are all in the file: c_mWindow.cpp
I am thinking of putting all the common funtions there too.
maybe renaming it to e_mWindows.cpp for consistancy...
do it...done...
did that gain me anything??
its a little cleaner

draw item show sticky....done
name is too long for remote detonator bomb..
try Remote Bomb and Remote Sticky Bmb..works...

bug...when adjusting damage range of bomb...if it gets small enough you move item at same time...
did not fix...I just don't care...

bug zfs crashes hard....
after loading mW from file, there are a few things that need to be reset.
one is copy mode...
as a matter of fact, I should do that whenever I start zfs...fixed...

removed just about all traces of enemy field...





fix the bullet proximity for flapper...
right now it uses a lot of variables..I am thinking of just using a circle like trakbot...
maybe some fancy pie slice arc....

start with just a circle...

what var currently used??
//   Ei[][17] = prox width
//   Ei[][18] = prox height
//   Ei[][19] = prox depth

remove all this and use as a circle...
//     Ei[e][17] = prox

did all the editor stuff

now I just need to fix the actual code...done

// try to shoot right
      p = find_closest_player_flapper(e, 1);
      if (--Ei[e][16] < 0)


I can see the pieslice if I turn on debug flapper stuff..
i just use a circle in level editor...
now I can add it to group edit...done

bug in level 314 with trigger and bd?????
trigger justs keep falling....
make move never apply to trigger, bm, bd..

many things have been done, what is next?
a new enemy? a new item?
implement some more things that emit triggers...
some more fields like maybe gravity direction change or very low gravity might be easier...
maybe field that regenerates health instead of taking it...



bug - item viewer for bd..height should dynamically change and text length too long for draw...


I can do dynamic size of height by letting the buttons draw, then at the end of that setting size...
It only works if I disable the set size from lookup table in the draw code...
and it has to draw twice to get the proper height...

I could disable the set height for just one item, like trigger and let it do its own....
that works....


do more later...gtg

20220519 6:25 AM push....


bug in bd display in level editor, spikey red floor draw doubles and is not lined up...
changes when screen scaling changes
the only thing I can find that draws it is draw_block_damage()
called by draw_item()...
fixed...
when draw_item is called in custom mode, do not draw bd damage field


change archwagon prox to match all others
add prox to cannon, just like every other enemy
done all in viewer...

now I need to do a glt and set all cannons 17 to 2000....done

when this is done these will all have the same:
archwagon
cannon
trakbot
flapper
done...added to ge...done

bug - when items (post death flower) expire they leave a dot and do not erase...fixed

bug - zfs block fill and frame do not work..fixed



make leaving ropes to ladder immed instead of fall and vice versa
ladder to rope looks good...player falls, but then immediately grabs rope
leaving rope by moving past ends....
detect if on ladder before fall...done

   if (players[p].on_rope)                 // if player is currently on rope
   {
      if (!is_player_within_rope_reach(p)) // check to see if player is still on rope
      {
         players[p].on_rope = 0;
         players[p].on_ladder = is_player_within_ladder_reach(p); // automatically grab ladder if with reach and just leaving rope
      }
   }




20220521 7:00AM

make the switches able to see through if stacked


I am going to make a single switch capable of having more than one color


right now, so much of the code for a switch is tied to the switch itself

there is:



item[i][6]  // bit to indicate what position it is currently in
item[i][7]  // lockout
item[i][8]  // on bmp
item[i][9]  // off bmp
item[i][10] // solid block
item[i][11] // empty block

how will I change it?

use a bitfield for each color
use item[][6] for that
0000 = none (do not allow)
0001 = green
0010 = red
0100 = blue
1000 = purple

do not need a value for what position it currently is in
use the bitmap
use only one set (green) 745, 746
toggle everytime it is jumped on

make a function that based on flags toggles the appropriate blocks

make a custom draw to fill in colors based on flags
       6     8    9    10   11
green  0001  745  746  172  7
red    0010  777  778  173  8
blue   0100  809  810  174  9
purple 1000  841  842  175  10


just a side note:
this kind of looks like what a trigger and bm set could do

also...

how hard would it be to set a range like key has?
what var does key use? 6, 7, 8, 9

I would need to move my current 6,7 to 10, 11....not a big deal....

do it...

item[i][6]  // x
item[i][7]  // y
item[i][8]  // w
item[i][9]  // h
item[i][10] // color flags
item[i][11] // lockout



it all works...now to do the drawing....
make a neutral shape...


how many different shapes do I need?

nc = 1;
4 - one for each color

nc = 2;
1st color could be any one of four
2nd color coule be any one of four
16?? no...
no doubles, order does not matter...
i think 6...

g r
g b
g p

r b
r p

b p





nc = 3;
4 - one missing each color

nc = 4;
1 - with all four colors


so total of 15...

make a funtion to colorize...later will decide dynamic or static...


static....

switch_tile[16]
0 white

1 g
2 r
3 b
4 p

5 gr
6 gb
7 gp
8 rb
9 rp
10 bp

11 grb
12 grp
13 gbp
14 rbp

15 grbp




I have all these drawn...

now what about the yin/yang circle?
draw on top...

make two yin yang versions and save to disk with all other tiles

or I could use regular tiles...96-124  do it..



how do I save??


   tilemap = al_load_bitmap("bitmaps/tiles.bmp");
   if (draw_and_process_button(b1_x2-36, b1_y-12, "Save", 15, 10, 0)) al_save_bitmap(b1_fn, b1);

al_save_bitmap("bitmaps/tiles.bmp", tilemap);


done... they are all a part of tiles now....
now patch that into draw....

draw code is the same as every other item.. draw the tile in item[][1]...
make the logic to set that somehwere else...

in proc_switch_collision?... only gets called when collision...
can use that to add or subtract 16 when jumped on....

in level editor is where it will need to be set...
when creating or changing color flags...done...

now I want to implement the range thing, just like keys...

to start with, all existing switches need to be glt'd to have 0,0 2000, 2000...
also existing switches need the new color format...done...


now implement the switch block range...

PDE make all 2000 for new...done...
edit in ov...


I think it is all done...
map move, draw new range, highlights...

maybe redo the shapes to get some black see through....
that took much longer than expected, but finally I am happy with it...

made it possible for field to give health...

has a bad noise though...


zfs paste from disk, just gets stuff from current level
it looks like the draw fsel uses the real level...it should use the ft_stuff...


zfs move....erases stuff after paste

I recently added some calls to save selection...
I wanted fresh stuff when filters changed
I might have to rethink this...



it looks like the draw fsel uses the real level...it should use the ft_stuff...
is that the real problem??
the ft_bmp has a 1-1 scale
fixed this so that draw_fsel uses ft_

now test to see what still doesn't work...

move still erases after copy...
it's beacuse of when I call zfs_save_selection from draw_filter_buttons...
any mouse button will trigger it...

am I doing this wrong?
I filter when i draw from the ft_ that should be good enough??
just tested and it does nothing...fixed a few occurances of missing ft_ when testing...

when load from disk, set size properly...done...
now check to see that the block filter stuff is working properly...ok...

can I show ndf in selection? yes...done




20220522 6:00 AM


bug - purple coin cannot set carry fall lift..fixed

bug - fix show items complaints...done

p msgs show funny @ char sometimes...fixed
never on level, only when drawn below buttons
only when <cr>


increase max bullet recoil in -y direction...done from 5 to 8
also decrease max x from 5 to 4...


made all the viewer buttons dynamically set height...


right now when something uses an event, it clears it
this works because we are never sure it what order items are processed
and clearing them at the start of every frame, might clear them bofore they get to be used...
this also means that multiple event receiver cannot use the same trigger...
I was thinking of a different method...
The thing that sets the event could be the thing that clears it...
right now only trigger sets events...

this seems to work..i need to finish implementing it...

remove where bd bm and lift eats triggers...done...

make a level where the field gives you health...
then cannons shoot you from below and push you up...
can enemies control how powerful their bullets are?...no bullets have fixed damage...for now
done...



going to clean up sliders...

use regex to find calls

I want something that matches mdw_button( x, x, x, x, !!! )

mdw_button(

then skip past 4 values and commas...

then the next number

tried:
mdw_button(.*15
lots of results


better:
mdw_button(.*[,]+ 15



mdw_button(.*[,]+ 15
nothing


mdw_button( ([A-Za-z0-9]{1}[,])4 15




it would also be nice if I did not have to increment y pos in a seperate line
what if I passed bts as y2...
passed ya as a pointer... and let the function add to it and return...

lets just do it for mdw_buttont for now...
how many calls



the new function is:

// just display a text string, and return 1 if pressed
// in this version y2 has been replaced by height
// y1 is modified to add height if bn == 1
int mdw_buttont2(int x1, int &y1, int x2, int bts, int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7, const char* txt)
{
   int y2 = y1+bts-2;
   int ret = 0;


   if (!q6)
   {
      sprintf(smsg, "%s", txt);
      draw_slider_frame(x1, y1, x2, y2, q0, q1, q2, q3, q4, q5, q6, q7); // draw button frame
      if (q5) al_draw_text(font, mC.pc[q2], x1+4,      y1+bts/2-3, 0,                    smsg);
      else    al_draw_text(font, mC.pc[q2], (x2+x1)/2, y1+bts/2-3, ALLEGRO_ALIGN_CENTER, smsg);

   }

   if ((!q7) && (mouse_b1) && (mI.mouse_x > x1) && (mI.mouse_x < x2) && (mI.mouse_y > y1) && (mI.mouse_y < y2))
   {
      while (mouse_b1) proc_controllers(); // wait for release
      ret = 1;
   }
   if (bn) y1+=bts;
   return ret;
}

when I remove all traces of the original, i will rename this to remove the 2....done....

this is a lot cleaner...
what about toggle_f2....done....

what about colsel? all 6 occurences are done...


plain old buttons have 90 matches...I am going to try to thin that out....

lets do 6 of buttonp first....done...



how many left now....83 matches



now to convert the stat fall things...
button p


now I am down to 65....


now I am down to ~30

fuck it, lets make buttons like all the others...done



10 slider0_int...done
32 slider2_int...done
23 slider2_fix...done


35 slider
I should convert as many as I can...


i have 31 left...I need to take a break...

20220522 7:30PM

push....


i have vewy few weft....heh heh heh....
9:10 PM

20220523 5:00AM

I only have 2 sliders left and they have custom code...

pod extended
bouncer cannon speed



list the funtions and variables...

int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 );

they all have 4 ints to start:
int x1, int &y1, int x2, int bts,

then the next four ints:
int bn, int num, int type, int obt,

then the next 8 ints:
int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7

I want to make q6 the y inc flag for all....

right now a few use something else....

these uses bn beacuse b6 is used for no draw....
toggle not actually used...fixed
togglef not actually used...fixed
buttont not actually used... fixed

make them all common...
q0 = background color; (not used)
q1 = frame color
q2 = text color    (use white 99% of time)
q3 = slider color  (use white 99% of time)
q4 = slider color  (draw frame mode) now i always use 1
q5 = text justify  (0-center 1-left...buttons only)
q6 - add bts to y1
q7 - (0-normal) (1-dont process mouse b1 press)





I really want to put the last 2 sliders in slider2_int...
2 never uses bn...i think I could...

slider is gone.....

now I want to make the function names not so long...and the same length...

mdw_slider2_int
mdw_slider2_fix
mdw_slider2_flt
mdw_slider0_int
mdw_button
mdw_buttont
mdw_buttonp
mdw_colsel
mdw_toggle
mdw_togglf


mdw_slideri int
mdw_sliderf fixed
mdw_sliderd float
mdw_slider0 int 0
mdw_button
mdw_buttont
mdw_buttonp
mdw_colsel
mdw_toggle
mdw_togglf


change all slider2_int to slideri..done
change all slider2_fix to sliderf..done
change all slider2_flt to sliderd..done
change all slider0_int to slider0..done



I think I have all the buttons in ov lined up nice...

there are a few in lifts that do not have the no draw d q7 thing....

int draw_current_step_buttons(int x1, int x2, int y, int l, int s)

pass d to it...


void draw_step_button(int xa, int xb, int ty1, int ty2, int l, int s, int rc)

called by:

int draw_steps(int x1, int x2, int y, int lift, int current_step, int highlight_step)

called by
int insert_lift_step(int lift, int step) // inserts a step in 'lift' before 'step'
and ov
      int ycs = ysb + draw_steps(xa, xb, ysb, lift, step, step_pointer);
      ycs +=bts;


int draw_steps(int x1, int x2, int y, int lift, int current_step, int highlight_step)
will now have d....

when called from insert steps pass 1 for d to make it read only...

now pass d on to

void draw_step_button(int xa, int xb, int ty1, int ty2, int l, int s, int rc)..


OK done...

lets go through all the things once and then call it done...

mdw_slideri 58 all good
mdw_sliderf 26 all good
mdw_sliderd 2 all good
mdw_slider0 16 all good
mdw_button 31 all good
mdw_buttont 56 all good
mdw_buttonp 27 all good
mdw_colsel 6 all good
mdw_toggle 39 all good
mdw_togglf 24 all good


now do I have some bugs to fix??

can bd be cleaned up more...nah...its good...

filters does not display properly...fixed


set speed for cannon does not have effect until next seek
also bouncer

this function could work without knowing the old speed...


- use the old speed to get angle
- use the new speed to make xinc, yinc

void scale_bouncer_and_cannon_speed(int num, float f)
{
   al_fixed old_speed = Efi[num][5];
   Efi[num][5] = al_ftofix(f);
   al_fixed fratio = al_fixdiv(Efi[num][5], old_speed);
   Efi[num][2] = al_fixmul(Efi[num][2], fratio);
   Efi[num][3] = al_fixmul(Efi[num][3], fratio);

   if (f == 0)
   {
      Efi[num][2] = al_itofix(0);
      Efi[num][3] = al_itofix(0);
   }
}

or...
- use xinc and yinc to get old speed (just hypot)
- the calculate the scale factor between old speed and new speed
- then apply that to the xinc, yinc,
bad things happen when speed == 0....fixed



make pod look at you when extending...
podzilla has some weird old code that I barely can comprehend..
frame number is being used count delay between modes??
Ei[][6] is the extend retract counter
Ei[][7] is used to reset Ei[][6]..
where does this come from??
the number of steps needed to reach the extended position??
it is set in recalc pod...
OK..moving on....
removed the bit where it uses frame number...
now to figure out the ans stuff...done
also fixed trigger box...
podzilla is done now...

lets make sure everything else works, too...

add sliders to PDE and remove edit int....
got rid of bottom menu....

animation sequence editor has been redone with buttons
lost edit_edit...

back to PDE...
am I ready to kill the old edit int shit??

i think so...OK now PDE looks a lot better....
edit text is its own function..
edit int and fixed are gone...

looking good...

door shit in ov..
door uses 6 custom button...
when exit only, 4 buttons could disappear...done
make all filters on by delfault..done
door links show to draw item...fixed

update the switch page in help...done....
what else has changed?
keys..same
doors..same
bonus has changed...not done yet...
bombs have changed....yes they have....


20220523 9:14 PM push

finished cleaning up the sliders
removed bottom_menu edit_int...
fixed up PDE with sliders
did some additions to help

some buttons have text that is not centered in the y axis
did a bunch of button clean up...

as soon as bomb starts to explode...don't draw spikes anymore...done

make a pde for warp...done...


make a new item to emit trigger
something like a ball on a stalk that turns greens when triggered
what to call it...orb
what number...6
tiles:
417 empty
418 green
419 red

only 2 values.. on or off
can emit 4 events, just like trigger

modes like trigger...
toggle
timed on/off
permanent on/off

can have different triggers like:
touch
up
down

#define PM_ITEM_ORB_STATE       0b0000000000000001
#define PM_ITEM_ORB_PREV_STATE  0b0000000000000010
#define PM_ITEM_ORB_TGON        0b0000000000000100
#define PM_ITEM_ORB_TGOF        0b0000000000001000
#define PM_ITEM_ORB_TRIG_TOUCH  0b0000000000010000
#define PM_ITEM_ORB_TRIG_UP     0b0000000000100000
#define PM_ITEM_ORB_TRIG_DOWN   0b0000000001000000
#define PM_ITEM_ORB_PREV_TRIG   0b0000000010000000

item[][0] = 6 - orb
item[][1] = bitmap
item[][2] = flags
item[][3] = stat | fall | carry
item[][4] = x pos (2000)
item[][5] = y pos (2000)
item[][6]  = MODE
item[][7]  = timer val
item[][8]  = time count
item[][9]  =
item[][10] = STATE ON  pm_event
item[][11] = SATEE OFF pm_event
item[][12] = TGON pm_event
item[][13] = TGOF pm_event

void proc_orb_collision(int p, int i)
if touch or up or down set the flags...

modes...

toggle
in order for this to work I'll need to keep track of what triggered it
so i don't just keep retriggering it

triggered is indicated by CURR being set

the only way toggle happens is when transitioning

let make mode 1 toggle...

it can toogle from any trigger but only when TGON
I will need a variable to keep track of what state it is in...
separate from trigger..

STATE...

I don't even need CURR
I calculate if triggered every frame
all I need to save is is triggered last frame...PREV


to re-iterate...

STATE is whether the orb is on or off..
if ON then it is red, OFF is green
If ON then every frame it will set the event for CURR ON
IF OFF then then every frame it will set the event for CURR OFF

PREV_STATE is used to set the events TGON and TGOF

PREV_TRIG is used for toggle mode


right now all I have is toggle mode...
what are some others...

one time ON or OFF

timed ON or OFF

      if (var == 0) sprintf(smsg, "Mode:Toggle");
      if (var == 1) sprintf(smsg, "Mode:Stick ON");
      if (var == 2) sprintf(smsg, "Mode:Stick OFF");
      if (var == 3) sprintf(smsg, "Mode:Timed ON");
      if (var == 4) sprintf(smsg, "Mode:Timed OFF");

having trouble with touch trigger

the code only works when a collision is detected so cant be reset

add back TRIG_CURR and make collsion do nothing but set that.

move the rest of the code to main proc function..

OK, now this all works good....
how about timed modes...

does the timer run down always, or does it wait until not triggered
wait...

this works good...

now I want a small progress bar to count down, or up...done...

I think that the new item is fully functional

I could make it look a little better....

I could make it rotatable so it would look good anchored to walls and ceilings

how do other items handle rotation?


I should be able to do the rotation with 2 bits

00 normal
01 right wall
10 celing
11 left wall

// get rb
#define PM_ITEM_ORB_ROTB        0b1100000000000000
int rb = (item[][2] & PM_ITEM_ORB_ROTB) >> 14;

// set rb
int rb = rb << 14; // shift bits into place
item[][2] &= ~PM_ITEM_ORB_ROTB; // clear bits in target
item[][2] |= rb; // merge

I could make it capable of being triggered by players bullets...
that sounds like a lot more work...done

still need to patch into filters...

rotation wrong in sel view of zfs for orb...fixed



make new enemy...jumpworm

expands and contracts as it moves side to side

number 5
tile 768-775


20220528 7:00AM
orb is done
working on jumpwagon

added 'turn before hole' to archwagon common
now archwagons can patrol platforms without falling off the ends...


make jumpworm move along the floor in a wormlike manner...

expanding has no x motion, contracting does
4 tiles: 768-771
all have nose at the right side of tile
768 longest
771 shortest



8 cycles
4 of them are expanding and 4 retracting
get them from frame % 8

expanding head moves forward while tails is stationary
contracting head is stationary with tails catched up

0-3 expand
4-7 contract

cycle tile xinc
0     771   +2   (shortest)
1     770   +2
2     769   +2
3     768   +2    (longest)
4     768   0
5     769   0
6     770   0
7     771   0


this works:
int cycle = mwPS.frame_num % 6;

if (cycle < 3) ...move

if (cycle == 0) tn = 770;
if (cycle == 1) tn = 769;
if (cycle == 2) tn = 768;
if (cycle == 3) tn = 769;
if (cycle == 4) tn = 770;
if (cycle == 5) tn = 771;



I just made a 6 tile version...
704-709


int cycle = mwPS.frame_num % 10;
if (cycle < 5) ...move

// moving (expanding)
// x is increasing, and tile is expanding
// it looks like the tail is stationary while the head moves

if (cycle == 0) tn = 708;
if (cycle == 1) tn = 707;
if (cycle == 2) tn = 706;
if (cycle == 3) tn = 705;
if (cycle == 4) tn = 704;

// not moving (contracting)
// x is not changing, tile is contracting
// it looks like the head is stationary while the tail is moving

if (cycle == 5) tn = 705;
if (cycle == 6) tn = 706;
if (cycle == 7) tn = 707;
if (cycle == 8) tn = 708;
if (cycle == 9) tn = 709;


that looks better...

because of the tiles, this only looks good moving at 2 frames

I want to do something for wall collisions

when collisions happen, it must be in the move phase, because that is the only time x changes

when that happens, I want to stop expanding and have the tail contract
then when the tail is fully retracted, then turn around and start from 0...

I might be able to do this with a cycle offset from mwPS.frame_num

I need some more variables...
13 change dir on next cycle 0
14 cycle offset



I am very happy with how that looks...

now for the y movement
different shape for that..or rotated...
float rot = al_fixtof(al_fixmul(Efi[e][14], al_fixtorad_r));

I have rotation for y working..might look better if I made the lines on the worm thicker..yes..

what else do I need to do for this?

death ans 79

somehow I managed to shift tiles.bmp by one pixel....arghhhhh!...fixed
bug... cloner has a big delay from first clone in timed mode....cloner fixed
bug... jumpworm can escape from a 1x1 box...
only when jumping...fixed...
add speed divider as a control
seperate for inch and jump...
I need a fixed for jump x speed
I need an int for inch divider..done

this enemy is looking good..was there anything else you wanted to do with it?
nothing comes to mind right now...use it in a level


seg fault when seting orb mode timed on...fixed div by zero error

key move? stops at solid blocks?? fixed by adding exclusion for moving key in move items

add help entries for trigger, bm, bd, orb, jumpworm

fix adding trigger with orb...done...

get used event needs to find orbs also...done
also made it find lifts...

made a function to show used events that are not zero
add jumpworm to filters...done


got a lot done...time for a push...

20220528 7:20 PM

20220529 7:00 AM

working on docs

level_array
block_flags
tiles
are all good
display...done

events needs changing...

OK i have a few thing to change:
rungame_key_check(p, ret); // run game from file
is only called once...ret is needed to determine if you can change players in the view or any key exits....
no! it is the keypress that is sent...keep it...
done...

now events, timer and input...which are all related...

link input in events
link timer in events
events...done
input...done
timers..done
change the created with section...done

now do some pm_help....
make freeman and purple coin a part of bonus...done
I have done trigger, bm, bd, orb
now just jumpworm left..done...
trakbot prox....

make switch move range with shift like key...done

lifts is out of date too.....
there are many changes


seg fault when switching lift mode...can't reproduce...???
happens when current step is not step 0
happens when reset timer is zero..
how can i fix it??
when the division by zero happens for the percent bar, detect 0 and change to 1...fixed


I think I should combine the loops for all 4 modes...

   while (!quit)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) quit = em_process_mouse();
      quit = em_process_keypress();
   }
   while (!quit)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) zfs_process_mouse();
      quit = zfs_process_keypress();
   }
   while (!ge_process_keypress())
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) ge_process_mouse();
   }
   while (!quit)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) ovw_process_mouse();
      quit = ovw_process_keypress();
   }


All that needs to change is a selector to call the appropriate mouse and key functions based on what mode we are in

then I will need a way to change modes..

right now em is the base and I only go from em to the other 3 and back
I want to go from any mode to any other

level_editor_mode = 1; // em
level_editor_mode = 2; // zfs
level_editor_mode = 3; // ge
level_editor_mode = 4; // ov

right now...do the combine....

move all other setup code into set_windows()
for all except em..

ov has 14 calls
could replace with something just sets mode and then returns
this could fix the issue of ov calling itself when already in it...
now it will just set obt and num

ge has one call from em
zfs has one call from em


made the loops even smaller

   while (!zfs_process_keypress())
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) zfs_process_mouse();
   }
   while (!ovw_process_keypress())
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) ovw_process_mouse();
   }


   make a function...

   cm_process_mouse that calls all the others


20220531 3:00 AM

made common cm_process_mouse and cm_process_keypress


lets remove call to ge and replace with set_windows(3);
works, but when exiting, le quits to game...
replace xfs call also...done

now ovw calls...done...

now the only loop is the one in em...

now what?

add some common buttons on the top border...

start with zoom +-


I need to make the holdoff not tied to the keys...done


now can I do F12 double...done


make it so that mpow also counts border as window


??? edit

int is_mouse_on_any_window(void)
{
   for (int a=0; a<NUM_MW; a++)
      if ((mW[a].active) && (mW[a].detect_mouse())) return 1;
   return 0;
}

this works but now scroll is broken...

made it so scroll works all the time...
now if I go on top border for menu it scrolls up...

this is a real catch 22

I could make the scroll happen before the border...??

Make the file menu


slider for zoom
can I make a live slider?? one that does not capture the mouse??


I think I have done it..

just call

cm_redraw_level_editor_background();
mw_cycle_windows(1);

in the loop where the slider has captured the mouse
then I needed to pass the 1 for not draw in the call to mw_cycle_windows(1);
all the way down to ovw_draw_buttons...
If I didn't the button would get called in a recursion loop and when I let go they loop would unwind
and you would see all of the moves replay...

for now it is only done for slider int b1...

I am wondering if I should do it for all, or have it able to be set by a parameter
I like how the whole screen updates...it looked funny before when only up to the one slider did...

I like it a lot...I want to make them all that way....

do I have an unused q value I could use to turn it off?
basically just don't run the cycle window and redraw_backgound


I am going to need to make a different kind of menu...


when I click on the name with mouse b1, the menu will display and stay there
it will block and do nothing until another mouse b1
then it will either be a choice made or menu goes away


mouse b1 on menu title
wait for release
show menu
keep mouse and wait for mouse b1
wait for release
if on menu item do that
menu done


i need to do the same for group edit..pass draw only

did a bunch of cleanup to make sliders use common functions...

hope I didn't break other stuff...

try the sliders in animation_sequence_editor...
yes, its broken...
make a way to disable this...


choose between these 2: with q4

   proc_controllers();
   al_flip_display();

//   cm_redraw_level_editor_background();
//   mw_cycle_windows(1);

done....
now where else??
PDE..done..
i think that is all...


now what the heck was I doing before this??

a new kind of menu

top_menu

done for file!!

now what?



fix the mouse detection when on upper border bar...
in em it draws sel, should do nothing...same in zfs

here is the problem...

      cm_redraw_level_editor_background();
      cm_process_menu_bar(quit);
      if (!mw_cycle_windows(0)) cm_process_mouse(quit);
      cm_process_keypress(quit);

menu_bar needs to detect mouse on it, just like the windows do...

I should make it a window

one that is always active in all level editor modes

then it could be processed just the same as all the other windows and detect mouse just the same....

what number should I make it?

1-7 are used so use 8...
that works....
now how to get quit out of it...use mW[8].active...done
and how to draw it so that it does not erase background..done

still drawing selection rectangle when on menu....fixed
mW[8] was moveable!

everything is looking good now...

object viewer with no object..works but is it OK?

save position even in other modes??
no..go back to mode 1


width of mW[8] when double changes...fixed

scroll edge?? variable speed?...done and works great!!!

put level and xy on bottom...
yes...status stuff on bottom...maybe show zoom level and double also
done....

make the quit common, now its only keys, but do the same for mouse...ok done

make tmenu look better??
highlight under menu items??



mouse b2 takes me out of ov..disable this...
fix the exit from each mode...
mouse b2 does not exit
esc sets mW[8].active to 0
ov done...
zfs ge done...
I sure am passing quit around a lot...can I reduce this to never?
main edit loop is now:

   while (mW[8].active)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) cm_process_mouse(quit);
      cm_process_keypress(quit);
   }
done...quit is never passed and the code is simpler...


do something about ov not having a valid obt and num
what if I delete last obt of type?...
I think this is fixed....



put more variables in mW[8]

can I combine level_editor_mode and level_editor_running?

if mode == 0???
same as level editor not running?

I should be able to do this

first add level_editor_mode to mW[8]...done

now make level_editor_running use it too...

where are the windows created??
do I want to drag all that into the game?
don't do it yet..

ov still starts bad....
do a start with no loadmW then set mode to ov..fixed
now I also check for obt==0

do I need bookmark?? can I just use saved mW.. i think I can...
removed bookmarks


I don't like some of the changes

I want to be able to exit ov, zfs, ge with mouse b2 like I used to be able to
em will be the default mode...done...
em can be quit with esc or menu only..already like that


change file menu to add save as, use current
make save do a blind save
make reload do a blind load..
done....

add to the detection length of mode menu button...done

make the pop-up menu shorter..done

level stats..makes more sense in level editor than in game!
removed from game and added under lists in level editor


bug...in map move, when holding mouse button and moving...the windows are hidden but still detected and won't let the mouse move where they are...
fixed...
if ((!mouse_on_window) || (mW[8].level_editor_mode == 0) || (mW[8].level_editor_mode == 4)) cm_get_block_position_on_map();



fix mouse move with sproingy height, mouse pointer goes off the screen
I want to do this with the actual postion, not mouse_dy..

I can get main position and distance from that with hy...


al_fixed get_sproingy_jump_height(int num)
{
   al_fixed t1 = al_fixdiv(al_itofix(item[num][7]), al_ftofix(7.1));
   al_fixed t2 = al_itofix(-15); // jump starts not at zero, but at almost one block height off ground
   while (t1 > al_itofix(0))
   {
      t2 += t1; // distance moved this time period
      t1 -= al_ftofix(.2); // minus slow gravity
   }
   return t2;
}


t1:
start with int (item[][7]) from 40 to 200
divide by 7.1
this is the upwards velocity

t3 = (t1/0.2) * t1;


t2: this is the y position
start at -15


what am I trying to do here?

make it so that I can drag the jump height position of sproingy and have sproinginess set automatically...

I need the reverse of this formula

formula to get jump height given sproiginess
s = sproinginess (int 40-200)

s/=7.1
while s>0
{
   th+=s
   s-=.2
}
h = th - 15;

----------
reverse

given h

th = 0
s = 0

while (th< h+15)
{
   th+=s;
   s+=0.2;
}
return s*7.1

I spent too much time on this before giving up....
fuck it...who cares?


make sure mouse cursor is set properly...a few random times it is wrong
when ever leaving ov..do it in set windows...





implement the end of level summary thing...

the biggest challenge is modifying the netgame code

that expects the next level to start immediately....

here is how I want it to go...

- when level done show a summary screen for all players
- time out after 20s or when all players have pressed any key


make a new state....
the game loop needs to keep running
but the players are paused and the level done screen is shown


I am hoping I can do pretty much what I did before only now I will pause before doing it..


how about a new paused type, 3

players[p].paused
players[p].paused_type
players[p].paused_mode
players[p].paused_mode_count

trigger it from server only with a keypress for now
or maybe when level_done is triggered

then have another special move item to start the new level

when first starting that mode
- all players need to have paused=1, type=3,

- the server will keep track of when clients press any key, or when the timer runs out


I will need to hook into the game_moves array special moves thingy..




20220611
figure out how you can pause a netgame...
it must come from the server...

I am thinking about letting the game run and just pausing all the players, enemies, lifts, bullets, etc...
some of that depends on mwPS.frame_num and the netgame code does also...

if I only freeze at the end of the game that can be handled...

lets make some test levels...71, 72, 73

what happens now when level done is activated...

in both single and netgame a special move is inserted in game moves

then this is processed by



            case 6:  // 'level done'
               if ((ima_client) || (ima_server))
               {
                  for (int p=0; p<NUM_PLAYERS; p++)
                     if (players[p].active) players1[p].quit_reason = 80;

                  if (L_LOGGING_NETPLAY)
                  {
                     sprintf(msg,"LEVEL %d DONE", play_level);
                     add_log_entry_header(10, 0, msg, 3);
                     if (ima_client) log_ending_stats();
                     if (ima_server) log_ending_stats_server();
                  }
               }
               proc_level_done();




I need to seprate this into 'level done' and 'next_level'

make another special game move: 'next_level'

move most of the funtionality of existing 'level_done' to 'next_level'

then make level done pause and show end of level stats


what game moves do I have now? 1 and 6

add 7 'next_level'

rename proc_level_done to proc_next_level...
done...
framework is in place...

void proc_game_move(void)
{
         switch (game_moves[x][1])
         {
            case 1: proc_player_state_game_move(x); break;

//            case 6: proc_level_done(); break; // new one
            case 6: proc_next_level(); break; // old one
            case 7: proc_next_level(); break;
         }
      }
   }
}


now add stuff to proc_level_done()
- pause all players
- set up something that will time out

void proc_level_done(void)
{
   // set all players to paused mode 3
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active)
      {
         players[p].paused = 1;
         players[p].paused_type = 3;
      }

   // set player 0
   players[0].paused_mode = 0;
   players[0].paused_mode_count = 200;

}

- then add new game move 'next_level'


the problem now is that players do not process moves from game move array when paused


the global variable 'level_done_trig' is set...

void proc_warp_collision(int p, int i)
{
   next_level = item[i][8];
   level_done_trig = 1;
   game_event(4, 0, 0, p, i, 0, 0);
}

void proc_exit_collision(int p, int i)
{
   int exit_enemys_left = num_enemy - item[i][8];
   if (exit_enemys_left <= 0)
   {
      level_done_trig = 1;
      next_level = play_level + 1;
      game_event(4, 0, 0, 0, 0, 0, 0);
   }
   else game_event(3, 0, 0, p, i, exit_enemys_left, 0); // not enough dead yet
}

a game move is entered in single and server mode..
and the flag is cleared


         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_trig)
            {
               add_game_move(mwPS.frame_num, 6, 0, 0); // insert level done into game move
               level_done_trig = 0;
            }

void server_local_control(int p)
{
   int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
   set_comp_move_from_player_key_check(p);
   if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
   {
      players1[p].old_comp_move = players1[p].comp_move;
      add_game_move(fn, 5, p, players1[p].comp_move);
   }
   if (level_done_trig)
   {
      add_game_move(fn, 6, 0, 0);        // insert level done into game move
      level_done_trig = 0;
   }


then in proc game moves the game move is read...


void proc_game_move(void)
{
   // this function looks in the game_moves array for an exact mwPS.frame_num match
   // this only processes system moves, not regular game_moves
   // its likely that an exact mwPS.frame_num match won't be found and nothing will be done
   // if multiple frame_nums match they all will be processed

   int ll;
   if (players[0].control_method == 1) ll = 0; // run game needs to look back to the start
   else ll = game_move_entry_pos - 100; // every other mode can just look back 100
   if (ll < 0) ll = 0; // don't look back past zero!

   for (int x=game_move_entry_pos; x>ll; x--)  // look back for mwPS.frame_num
   {
      if (game_moves[x][0] == mwPS.frame_num)
      {
         switch (game_moves[x][1])
         {
            case 1: proc_player_state_game_move(x); break;

            case 6: proc_level_done(); break; // new one

//            case 6: proc_next_level(); break; // old one


then in

void proc_level_done(void)
{
   // set all players to paused mode 3
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active)
      {
         players[p].paused = 200;
         players[p].paused_type = 3;
      }
}


then in

void proc_player_paused(int p)
{
   players[p].player_ride = 0;

   if (players[p].paused_type == 3)// paused type 3: level done
   {
      if (p == 0)
      {
         if (--players[0].paused < 1)
         {
            int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
            add_game_move(fn, 7, 0, 0);
         }
      }
   }



need to reset player in new level...

   if (t == 17) // player common
   {
      players[p].paused = 0;


make level_done show on first step..


make level done show as part of screen overlay...
it seems to slow things down

how about level_done_mode
0 = normal
4 = triggered (can only trigger from mode 0)
3 = ld_gm entered
2 = ld_gm proc (waiting mode)
1 = wait done (nl_gm entered)





void proc_exit_collision(int p, int i)
{
   int exit_enemys_left = num_enemy - item[i][8];
   if (exit_enemys_left <= 0)
   {
      if (level_done_mode) == 0)
      {
         level_done_mode = 4;
         next_level = play_level + 1;
         game_event(4, 0, 0, 0, 0, 0, 0);
      }
   }
   else game_event(3, 0, 0, p, i, exit_enemys_left, 0); // not enough dead yet
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode) == 0)
   {
      level_done_mode = 4;
      next_level = item[i][8];
      game_event(4, 0, 0, p, i, 0, 0);
   }
}

removed all level_done_trig

replace level_done_proc with level_done_mode = 1;
used to trigger start mode 5...then set to zero..

at start of loop

//      if (level_done_proc) proc_start_mode(5);
      if (level_done_mode == 1)
      {
          level_done_mode = 0;
          proc_start_mode(5);
      }

at the end of next_level set to 1


back to documenting all level_done_mode references..

---------------------------------

at the start of game_loop()

if (level_done_mode == 1)
{
    level_done_mode = 0;
    proc_start_mode(5);
}


at the end of proc_next_level()
level_done_mode = 1;

when triggered by exit or warp
if (level_done_mode == 0)
{
   level_done_mode = 4;


single player mode
void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 4)
            {
               level_done_mode = 3;
               add_game_move(mwPS.frame_num, 6, 0, 0); // insert level done into game move
            }


void server_local_control(int p)
{
   int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
   set_comp_move_from_player_key_check(p);
   if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
   {
      players1[p].old_comp_move = players1[p].comp_move;
      add_game_move(fn, 5, p, players1[p].comp_move);
   }
   if (level_done_mode == 4)
   {
      level_done_mode = 3;
      add_game_move(fn, 6, 0, 0); // insert level done into game move
   }
}

OK now what is needed?
when processed by

void proc_level_done(void)
{
   level_done_mode = 2;
   // set all players to paused mode 3
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active)
      {
         players[p].paused = 120;
         players[p].paused_type = 3;
      }

   if (L_LOGGING_NETPLAY)
   {
      sprintf(msg,"LEVEL %d DONE", play_level);
      add_log_entry_header(10, 0, msg, 3);
      if (ima_client) log_ending_stats();
      if (ima_server) log_ending_stats_server();
   }

}

while in mode 2, show the level done overlay...done

when 2 is done, game_move 'next_level' is entered
when that is processed set mode to 1..already done...


what is left?

while in mode 2 can something else besides player_paused control things?

while in mode 2, stop updating enemies, lifts, items, etc players....
how?

make a custom event loop for level_done?





how about each player has the paused count set..
if a player presses any key then that is set to 0




go back to using paused_mode_count...done

         players[p].paused = 1;
         players[p].paused_type = 3;
         players[p].paused_mode_count = 120;


now all that player paused does is count this down

   if (players[p].paused_type == 3)// paused type 3: level done
   {
      if (players[p].paused_mode_count>0) players[p].paused_mode_count--;
   }

   can't do this here ...wont be called





then make a separate function to process this..




      {
            int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
            add_game_move(fn, 7, 0, 0);

         }
      }



It is working good now...
-------------------------------------------
time for some new documentation...
---------------------------------------------
global int level_done_mode

0 = normal
4 = triggered (can only trigger from mode 0)
3 = game move 'Level Done' entered
2 = game move 'Level Done' received and processed (waiting mode)
2 - when done game move 'Next Level' is entered
1 = game move 'Next Level' received and process started


when triggered by any player touching exit or warp
if (level_done_mode == 0)
{
   level_done_mode = 4;
}

can only be triggered from mode 0, to prevent multiple triggering


In single player mode:

void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 4)
            {
               level_done_mode = 3;
               add_game_move(mwPS.frame_num, 6, 0, 0); // insert level done into game move
            }


In netgame, only server processes it:

void server_local_control(int p)
{
   int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
   if (level_done_mode == 4)
   {
      level_done_mode = 3;
      add_game_move(fn, 6, 0, 0); // insert level done into game move
   }
}

These are the only 2 ways that we go from mode 4 to mode 3...

In mode 3 we are waiting for the special game move 'Level Done' to be received and processed..

in proc_controllers(), proc_game_move() is called very frame in every mode
it calls proc_level_done();

void proc_level_done(void)
{
   level_done_mode = 2;
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active)
      {
         players[p].paused = 1;
         players[p].paused_type = 3;
         players[p].paused_mode_count = 120;
      }
}

now we are in mode 2...

all active players are paused..

nothing different happens with move player..

void game_loop(int start_mode)
{
   game_exit = 0;
   while (!game_exit)
   {
      if (level_done_mode > 1)
      {
         stop_sound();
         while (level_done_mode > 1)
         {
            proc_scale_factor_change();
            if (ima_server) server_control();
            if (ima_client) client_control();
            proc_controllers();

            proc_level_done_mode2();
            proc_frame_delay();
            if (draw_frame)
            {
               get_new_screen_buffer(0, 0, 0);
               draw_screen_overlay();
               al_flip_display();
            }
         }
      }



lets make the count larger like 400.

then I need to work on ways of detecting keypresses from clients

I should ignore all for the first 1-2 seconds...


what other methods do I have for client keypress on the server...

last cdat received...??

could let the client set its own timeout and then wait for that to be synced back to the server
that won't work..sync does not go that way...


look in the game moves array to see if a game move change from that player was received since level done
that could work...on clients, once level done is received and more cdats sent should just do an acknowledge on the server...



what if I had more level done game events

ld1 to ld2 - 2 seconds no skip possible

after ld2 - 10 seconds with possible skip if all active players press a key


why am I doing this? to get a hold off where pressed keys don't do anything

I could have a series of screens....


bug..pressing esc during the timeout freezes game...

when inserting ld1 game move also insert ld2 game move 40 frames in the future...

while in mode ld1 accept no input at all

in mode ld2 accept input

i need to make more level done game moves

-----------------

Im going to fix it, by adding more modes


0 = normal
8 = triggered (can only trigger from mode 0)
7 = game move 'Level Done 1' and 'Level Done 2' entered
6 = game move 'Level Done 1' received and processed (wait mode 1 - time only)
5 = game move 'Level Done 2' received and processed (wait mode 2 - time or keypress)
4 = local player timed out or keypress
3 = all players timed out or keypress
2 - game move 'Next Level' entered
1 = game move 'Next Level' received and process started
0 = new level started


in modes 1234 678 - input from player disabled
in modes 12345678 - player move disabled, all other moveable objects movement disabled
actually this happens when switching from mode 7 to 6 when 'Level Done 1' is processed
does that happen differently between server and client?

in game loop stuff happens differently when mode 8 and 7 are active..
this happens on server, but not on client until gm is received

make is so that in game loop nothing different until mode 6
to make server and client do the same thing
7 and 8 sre still need to prevent multiple level done



void proc_exit_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = play_level + 1;
      game_event(4, 0, 0, 0, 0, 0, 0);
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = item[i][8];
      game_event(4, 0, 0, p, i, 0, 0);
   }
}

void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 8)
            {
               level_done_mode = 7;
               add_game_move(mwPS.frame_num,     6, 0, 1); // insert level done into game move
               add_game_move(mwPS.frame_num+120, 6, 0, 2);
            }

void server_local_control(int p)
{
   int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
   if (level_done_mode == 8)
   {
      level_done_mode = 7;
      add_game_move(fn,     6, 0, 1); // insert level done into game move
      add_game_move(fn+120, 6, 0, 2); // insert level done into game move
   }


void proc_game_move(void)
{
   if (game_moves[x][0] == mwPS.frame_num)
   {
      switch (game_moves[x][1])
      {
         case 1: proc_player_state_game_move(x); break;
         case 6: proc_level_done(x); break;
         case 7: proc_next_level(); break;
      }
   }
}

void proc_level_done(int x)
{
   if (game_moves[x][3]) // level done 1
   {
      level_done_mode = 6;
      // set all players to paused type 3
      for (int p=0; p<NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].paused = 1;
            players[p].paused_type = 3;
            players[p].paused_mode_count = 120;
         }
   }
   else // level done 2
   {
      level_done_mode = 5;
      // set all players to paused type 3
      for (int p=0; p<NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].paused = 1;
            players[p].paused_type = 3;
            players[p].paused_mode_count = 120;
         }
   }
}


in game loop
I pass it all to proc_level_done_mode();

void game_loop(int start_mode)
{
   game_exit = 0;
   proc_start_mode(start_mode);
   while (!game_exit)
   {
      if ((level_done_mode > 0) && (level_done_mode < 7)) proc_level_done_mode();
      else
      {





now I am thinking about using game_move entries to track acknowledgements

level done 1
level done 2
player acknowledgements or time outs
next level

I will need a new type of game move...
type 8 player acknowledge (pak)

when any cdat is received in mode 5 enter pak



- disable all player input in mode 6
- turn it back on for mode 5, but only to acknowledge


what if I put all three gms in at once:

ld1
ld2+120
nl+200

then if all players ack after ld2 nl can be done sooner...

now make no input..done

insert player ack in mode 5

check for all players ack to skip wait...

I think I have it working in single player mode..now net also...

doc again..

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------

0 = normal
8 = triggered (can only trigger from mode 0)
7 = all three game moves entered 'Level Done 1' 'Level Done 2' 'Next Level'
6 = game move 'Level Done 1' received and processed (wait mode 1 - time only)
5 = game move 'Level Done 2' received and processed (wait mode 2 - time or keypress)
4 = all players timed out or keypress
1 = game move 'Next Level' received and process started
0 = new level started

game moves:

6 0 1 "Level Done 1"
6 0 2 "Level Done 2"
7 0 0 "Next Level"
8 p 0 "Player Acknowledge"

High Level
- All game moves are entered with future frame_nums
- 1st stage does nothing but wait
- 2nd stage waits, but also accepts ack from players
- if all players ack, or timer runs out
- insert another 'next level' game move with a earlier frame num


Details:

in all mode (single, netgame, client, server, rungame), any player will trigger level done

void proc_exit_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = play_level + 1;
      game_event(4, 0, 0, 0, 0, 0, 0);
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = item[i][8];
      game_event(4, 0, 0, p, i, 0, 0);
   }
}


but...only in single player or server will that have any effect:

void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 8) start_level_done(p);

void server_local_control(int p)
{
   if (level_done_mode == 8) start_level_done(p);


void start_level_done(int p)
{
   level_done_mode = 7;
   int fn = mwPS.frame_num + control_lead_frames;
   add_game_move(fn,     6, 0, 1); // insert level done 1 into game move
   add_game_move(fn+100, 6, 0, 2); // insert level done 2 into game move
   add_game_move(fn+200, 7, 0, 0); // insert next level into game move
   players1[p].old_comp_move = players1[p].comp_move = 0; // reset both
}

Then nothing happens for a few frames, until the game move "Level Done 1" is processed
this is common to all (single, server, client)

once that happens we are in mode 6

level_done_mode = 6;
for (int p=0; p<NUM_PLAYERS; p++)
   if (players[p].active)
   {
      players[p].paused = 1;
      players[p].paused_type = 3;
   }

while in mode 6, in game_loop() things are done differently
there is an entirely different main loop

in mode 6 this does nothing

void game_loop(int start_mode)
{
   game_exit = 0;
   proc_start_mode(start_mode);
   while (!game_exit)
   {
      if ((level_done_mode > 0) && (level_done_mode < 7)) proc_level_done_mode();
      else
      {


proc_player_input has been modifoed to only do the regular stuff in level_done_mode == 0
so it does nothing in mode 6 either

void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {

            if (level_done_mode == 0)
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
               }
            }


so in this mode we are just waiting for the next game_move "level done 2"

the screen overlay is shown in all level_done_modes that are not zero...

then when 'level_done 2' is received we go into mode 5


in mode 5 game_loop calls

void proc_level_done_mode(void)
{
   if (level_done_mode == 5) // check if all players have acknowledged
   {
      int aa = 1; // yes by default, set to no if any have not ack
      for (int p=0; p<NUM_PLAYERS; p++)
         if (players[p].active)
            if (!has_player_acknowledged(p)) aa = 0;
      if (aa)
      {
         int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
         add_game_move(fn, 7, 0, 0); // insert next level into game move
         level_done_mode = 4;
      }
   }

int has_player_acknowledged(int p)
{
   for (int x=game_move_entry_pos; x>0; x--)  // look back for mwPS.frame_num
      if ((game_moves[x][1] == 8) && (game_moves[x][2] == p)) return 1;
   return 0;
}

also in mode 5:

single player and server have a special cases to enter ack

            if (level_done_mode == 5)
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  if (players1[p].comp_move) add_game_move(mwPS.frame_num, 8, p, 0); // insert player ack
               }
            }

client still sends cdat exactly the same, but when received on server...

void server_proc_cdat_packet(void)
{
   if (level_done_mode == 5) add_game_move(fn, 8, p, 0); // add ack to game_move array
   else

this all seems to work fine but it seems overly complicated....

test more...

modify this:



            if (level_done_mode == 0)
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
               }
            }
            if (level_done_mode == 5)
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  if (players1[p].comp_move) add_game_move(mwPS.frame_num, 8, p, 0); // insert player ack
               }
            }


            if (level_done_mode == 5) if (players1[p].comp_move) add_game_move(mwPS.frame_num, 8, p, 0); // insert player ack



void add_game_move(int frame, int type, int data1, int data2)
{

   if ((level_done_mode == 5) && (type == 5) && (data2))  // ack mode and not zero move
   {
      game_moves[game_move_entry_pos][0] = frame;
      game_moves[game_move_entry_pos][1] = 8;
      game_moves[game_move_entry_pos][2] = data1; // player num
      game_moves[game_move_entry_pos][3] = 0;
      game_move_entry_pos++;
      return; // to exit immediately
   }


make every player that initiates level_done_mode 8 get paused...
just so that it looks good...and the player does not keep moving past the exit or warp...done


fix it so that no input can happen while in modes...

in single player esc during wait kills it bad...

added this to single and server:

            if ((level_done_mode == 0) || (level_done_mode == 5))
            {

















docs looks good...now test everything...


here is a normal single player game


number of entries 29
deathmatch_pbullets 0
deathmatch_pbullets_damage 5
suicide_pbullets 0
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:71)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:12)--
[  2][  18][0][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[  3][  19][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  4][  27][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[  5][  41][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[  6][  42][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[  7][  45][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  8][  47][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[  9][  50][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 10][  53][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 11][  54][0][38]  [FIRE][    ][    ][UP][RIGHT][    ]
[ 12][  55][0][36]  [FIRE][    ][    ][UP][     ][    ]
[ 13][  56][0][52]  [FIRE][JUMP][    ][UP][     ][    ]
[ 14][  58][0][21]  [    ][JUMP][    ][UP][     ][LEFT]
[ 15][  62][0][37]  [FIRE][    ][    ][UP][     ][LEFT]
[ 16][  63][0][36]  [FIRE][    ][    ][UP][     ][    ]
[ 17][  64][0][ 4]  [    ][    ][    ][UP][     ][    ]
[ 18][  66][0][ 6]  [    ][    ][    ][UP][RIGHT][    ]
[ 19][  67][0][22]  [    ][JUMP][    ][UP][RIGHT][    ]
[ 20][  69][0][23]  [    ][JUMP][    ][UP][RIGHT][LEFT]
[ 21][  71][0][39]  [FIRE][    ][    ][UP][RIGHT][LEFT]
[ 22][  72][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 23][  76][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 24][  84]-------------LEVEL DONE 1 ----------------
[ 25][ 184]-------------LEVEL DONE 2 ----------------
[ 26][ 684]-------------NEXT LEVEL!------------------
[ 27][ 215]-------------PLAYER 0 ACKNOWLEDGE------
[ 28][ 216]-------------NEXT LEVEL!------------------


here is a 2 player game


number of entries 63
deathmatch_pbullets 0
deathmatch_pbullets_damage 5
suicide_pbullets 0
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:71)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:12)--
[  2][  97]-------------PLAYER 1 ACTIVE (color:13)--
[  3][ 154][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  4][ 164][0][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[  5][ 166][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  6][ 196][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  7][ 204][0][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[  8][ 205][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  9][ 209][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 10][ 210][0][16]  [    ][JUMP][    ][  ][     ][    ]
[ 11][ 215][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 12][ 254][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 13][ 259][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 14][ 263][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 15][ 268][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 16][ 282][0][16]  [    ][JUMP][    ][  ][     ][    ]
[ 17][ 302][0][48]  [FIRE][JUMP][    ][  ][     ][    ]
[ 18][ 303][0][32]  [FIRE][    ][    ][  ][     ][    ]
[ 19][ 306][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 20][ 311][0][32]  [FIRE][    ][    ][  ][     ][    ]
[ 21][ 314][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 22][ 318][0][32]  [FIRE][    ][    ][  ][     ][    ]
[ 23][ 321][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 24][ 392][1][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[ 25][ 394][1][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 26][ 407][1][16]  [    ][JUMP][    ][  ][     ][    ]
[ 27][ 410][1][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 28][ 418][1][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 29][ 421][1][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 30][ 423][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 31][ 426][1][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 32][ 429][1][33]  [FIRE][    ][    ][  ][     ][LEFT]
[ 33][ 430][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 34][ 434][1][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 35][ 437][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 36][ 440][1][33]  [FIRE][    ][    ][  ][     ][LEFT]
[ 37][ 442][1][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 38][ 443][1][48]  [FIRE][JUMP][    ][  ][     ][    ]
[ 39][ 444][1][ 0]  [    ][    ][    ][  ][     ][    ]
[ 40][ 447][1][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 41][ 449][1][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 42][ 450][1][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 43][ 459][1][ 0]  [    ][    ][    ][  ][     ][    ]
[ 44][ 468][1][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 45][ 484][1][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 46][ 489][1][16]  [    ][JUMP][    ][  ][     ][    ]
[ 47][ 498][1][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 48][ 503][1][16]  [    ][JUMP][    ][  ][     ][    ]
[ 49][ 506][1][ 0]  [    ][    ][    ][  ][     ][    ]
[ 50][ 521]-------------LEVEL DONE 1 ----------------
[ 51][ 621]-------------LEVEL DONE 2 ----------------
[ 52][1121]-------------NEXT LEVEL!------------------
[ 53][ 593][1][16]  [    ][JUMP][    ][  ][     ][    ]
[ 54][ 598][1][ 0]  [    ][    ][    ][  ][     ][    ]
[ 55][ 684]-------------PLAYER 1 ACKNOWLEDGE------
[ 56][ 687]-------------PLAYER 1 ACKNOWLEDGE------
[ 57][ 767]-------------PLAYER 0 ACKNOWLEDGE------
[ 58][ 768]-------------NEXT LEVEL!------------------
[ 59][ 769]-------------NEXT LEVEL!------------------
[ 60][ 770]-------------NEXT LEVEL!------------------
[ 61][ 771]-------------NEXT LEVEL!------------------
[ 62][ 771][0][ 0]  [    ][    ][    ][  ][     ][    ]

here is a 3 player game

number of entries 96
deathmatch_pbullets 0
deathmatch_pbullets_damage 5
suicide_pbullets 0
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:71)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:12)--
[  2][ 113]-------------PLAYER 1 ACTIVE (color:13)--
[  3][1522]-------------PLAYER 2 ACTIVE (color:14)--
[  4][1662][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  5][1681][0][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[  6][1682][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  7][1686][0][17]  [    ][JUMP][    ][  ][     ][LEFT]
[  8][1688][0][16]  [    ][JUMP][    ][  ][     ][    ]
[  9][1697][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 10][1700][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 11][1703][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 12][1704][0][16]  [    ][JUMP][    ][  ][     ][    ]
[ 13][1708][0][48]  [FIRE][JUMP][    ][  ][     ][    ]
[ 14][1709][0][32]  [FIRE][    ][    ][  ][     ][    ]
[ 15][1714][0][48]  [FIRE][JUMP][    ][  ][     ][    ]
[ 16][1716][0][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 17][1717][0][17]  [    ][JUMP][    ][  ][     ][LEFT]
[ 18][1721][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 19][1722][0][33]  [FIRE][    ][    ][  ][     ][LEFT]
[ 20][1723][0][32]  [FIRE][    ][    ][  ][     ][    ]
[ 21][1724][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 22][1728][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 23][1730][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 24][1731][0][17]  [    ][JUMP][    ][  ][     ][LEFT]
[ 25][1734][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 26][1735][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 27][1736][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 28][1740][0][33]  [FIRE][    ][    ][  ][     ][LEFT]
[ 29][1741][0][17]  [    ][JUMP][    ][  ][     ][LEFT]
[ 30][1745][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 31][1746][0][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 32][1747][0][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 33][1749][0][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 34][1751][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 35][1752][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 36][1796][2][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 37][1803][2][ 3]  [    ][    ][    ][  ][RIGHT][LEFT]
[ 38][1812][2][33]  [FIRE][    ][    ][  ][     ][LEFT]
[ 39][1815][2][49]  [FIRE][JUMP][    ][  ][     ][LEFT]
[ 40][1817][2][17]  [    ][JUMP][    ][  ][     ][LEFT]
[ 41][1819][2][19]  [    ][JUMP][    ][  ][RIGHT][LEFT]
[ 42][1821][2][22]  [    ][JUMP][    ][UP][RIGHT][    ]
[ 43][1822][2][38]  [FIRE][    ][    ][UP][RIGHT][    ]
[ 44][1827][2][54]  [FIRE][JUMP][    ][UP][RIGHT][    ]
[ 45][1828][2][22]  [    ][JUMP][    ][UP][RIGHT][    ]
[ 46][1831][2][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 47][1832][2][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 48][1838][2][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 49][1839][2][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 50][1843][2][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 51][1844][2][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 52][1849][2][50]  [FIRE][JUMP][    ][  ][RIGHT][    ]
[ 53][1851][2][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 54][1857][2][34]  [FIRE][    ][    ][  ][RIGHT][    ]
[ 55][1863][2][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 56][1865][2][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 57][1870][2][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 58][1881][2][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 59][1884][2][16]  [    ][JUMP][    ][  ][     ][    ]
[ 60][1889]-------------LEVEL DONE 1 ----------------
[ 61][1989]-------------LEVEL DONE 2 ----------------
[ 62][2489]-------------NEXT LEVEL!------------------
[ 63][1889][2][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 64][1902][2][16]  [    ][JUMP][    ][  ][     ][    ]
[ 65][1903][2][ 0]  [    ][    ][    ][  ][     ][    ]
[ 66][1981][1][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 67][1989][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 68][1994]-------------PLAYER 1 ACKNOWLEDGE------
[ 69][1998]-------------PLAYER 1 ACKNOWLEDGE------
[ 70][2099]-------------PLAYER 0 ACKNOWLEDGE------
[ 71][2103][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 72][2117]-------------PLAYER 0 ACKNOWLEDGE------
[ 73][2121][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 74][2129]-------------PLAYER 0 ACKNOWLEDGE------
[ 75][2134][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 76][2141]-------------PLAYER 0 ACKNOWLEDGE------
[ 77][2146][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 78][2171]-------------PLAYER 0 ACKNOWLEDGE------
[ 79][2176][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 80][2194]-------------PLAYER 0 ACKNOWLEDGE------
[ 81][2199][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 82][2205]-------------PLAYER 0 ACKNOWLEDGE------
[ 83][2210][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 84][2216]-------------PLAYER 0 ACKNOWLEDGE------
[ 85][2221][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 86][2231]-------------PLAYER 0 ACKNOWLEDGE------
[ 87][2237][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 88][2245]-------------PLAYER 0 ACKNOWLEDGE------
[ 89][2250][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 90][2273]-------------PLAYER 2 ACKNOWLEDGE------
[ 91][2276]-------------NEXT LEVEL!------------------
[ 92][2277]-------------NEXT LEVEL!------------------
[ 93][2278]-------------NEXT LEVEL!------------------
[ 94][2279]-------------NEXT LEVEL!------------------
[ 95][2277]-------------PLAYER 2 ACKNOWLEDGE------


now lets work on making the overlay look better...

what can I show?


I really don't have anything

I will have to add all that I need:

They will need to be in the synced part of players


re-spawns
bullets fired
enemies killed

Time spent in level

Health lost
Health restored
Health wasted

Other players killed
Damage to other player

Purple Coins collected
Free Men collected


% of kills

moves made (control changes)



lets just add these for now...

6 more ints

   int stat_respawns;
   int stat_bullets_fired;
   int stat_enemy_hits;
   int stat_player_hits;
   int stat_self_hits;
   int stat_purple_coins;


   reset here in common

   if (t == 17) // player common
   {
      players[p].stat_respawns = 0;
      players[p].stat_bullets_fired = 0;
      players[p].stat_enemy_hits = 0;
      players[p].stat_player_hits = 0;
      players[p].stat_self_hits = 0;
      players[p].stat_purple_coins = 0;



now what do I have to do if the size changes??


Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1664
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :106144


now start to count these...
bullets_fired...done
enemy hits...done
respawns...done
purple coins..done

I want to know how many purple coins there are in total
the only way I can think of to do that is a global variable
that got me thinking...can I group a bunch of current_level variables together and put them in a struct?

what are some candidates?

level_done_mode
last_loaded_level
is_level_valid

// global game control
extern int game_exit;
extern int level_done_mode;
extern int next_level;

how can I show level done nice
stop music

the show 2 lines things for level done really slows shit down

what can I do?

make it static
- temp bitmap for screen buffer or for level done overlay

don't draw it every time...i think I have it fixed..

I dont draw it in the screen overlay code..
I dont get a new screen buffer in the loop code
I draw in once in proc_game_move when I get level done 1
seems to work good..

- time display in top border borks when too big?? maybe due to freeze at end of level
this is in all modes...timer keeps updating, but the screen buffer does not so timer smears
fix it but not updating that stuff when frozen in level_done state...fixed

- blocks that are erased, like breakable, still show as solid on clients that joined after the were removed.
they act erase, but show as there...do i need to redraw level background after receiving new state?
I added init_level_background to client code just before sending stak and that seemed to fix that problem





good single player exit


number of entries 15
deathmatch_pbullets 1
deathmatch_pbullets_damage 1
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:71)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:8)--
[  2][  49][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  3][  77][0][ 0]  [    ][    ][    ][  ][     ][    ]
[  4][  82][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  5][  87][0][ 0]  [    ][    ][    ][  ][     ][    ]
[  6][  97][0][16]  [    ][JUMP][    ][  ][     ][    ]
[  7][ 105][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[  8][ 123][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  9][ 124][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 10][ 137]-------------LEVEL DONE 1 ----------------
[ 11][ 237]-------------LEVEL DONE 2 ----------------
[ 12][ 737]-------------NEXT LEVEL!------------------
[ 13][ 361]-------------PLAYER 0 ACKNOWLEDGE------
[ 14][ 362]-------------NEXT LEVEL!------------------


good 2 player exit
no press any key or anything showed on client...


number of entries 33
deathmatch_pbullets 1
deathmatch_pbullets_damage 1
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:71)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:8)--
[  2][ 129]-------------PLAYER 1 ACTIVE (color:9)--
[  3][ 252][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  4][ 267][0][ 0]  [    ][    ][    ][  ][     ][    ]
[  5][ 270][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  6][ 276][0][ 0]  [    ][    ][    ][  ][     ][    ]
[  7][ 277][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[  8][ 282][0][ 0]  [    ][    ][    ][  ][     ][    ]
[  9][ 283][0][ 1]  [    ][    ][    ][  ][     ][LEFT]
[ 10][ 286][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 11][ 287][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 12][ 297][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 13][ 307][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 14][ 312][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 15][ 362][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 16][ 367][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 17][ 374][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 18][ 379][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 19][ 381][0][16]  [    ][JUMP][    ][  ][     ][    ]
[ 20][ 389][0][18]  [    ][JUMP][    ][  ][RIGHT][    ]
[ 21][ 398][0][ 2]  [    ][    ][    ][  ][RIGHT][    ]
[ 22][ 408][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 23][ 413]-------------LEVEL DONE 1 ----------------
[ 24][ 513]-------------LEVEL DONE 2 ----------------
[ 25][1013]-------------NEXT LEVEL!------------------
[ 26][ 751]-------------PLAYER 0 ACKNOWLEDGE------
[ 27][ 755][0][ 0]  [    ][    ][    ][  ][     ][    ]
[ 28][ 817]-------------PLAYER 1 ACKNOWLEDGE------
[ 29][ 820]-------------NEXT LEVEL!------------------
[ 30][ 821]-------------NEXT LEVEL!------------------
[ 31][ 822]-------------NEXT LEVEL!------------------
[ 32][ 823]-------------NEXT LEVEL!------------------



netgame bugs
- end of level stats freezes everything when fake keypress mode
loop is still running, F12 works...
when server actually quits by closing window, only then do clients show lost server connection

- when 2 player end, second player eol does not show any timeout or press any key..

my end of level stuff is not working properly
why?? how??

turn on some more debugging...

reproduce:

2 player game server exits...
display on client is not correct
never shows press any key or ready....
on server it shows properly

game moves array looks the same...

showed mode...client is stuck on mode 8...why??

what moves you from 8 to 7...when server or single player adds packets..never happens on client...
client has no state 7

what gets you into state 6?
when the game move 'level done 1' is processed...

this should happen on client also, right?
it does and it does get set, but something must set it back....

added this check...

void client_local_control(int p)
{
   if ((level_done_mode == 0) || (level_done_mode == 5))
   {
      if (players1[p].fake_keypress_mode) players1[p].comp_move = rand() % 64;
      else set_comp_move_from_player_key_check(p);
   }

still the same...

try this...

void client_local_control(int p)
{
   if ((level_done_mode == 0) || (level_done_mode == 5))
   {
      if (players1[p].fake_keypress_mode) players1[p].comp_move = rand() % 64;
      else set_comp_move_from_player_key_check(p);
      if (players1[p].old_comp_move != players1[p].comp_move)  // player's controls have changed
      {
         players1[p].old_comp_move = players1[p].comp_move;
         Packet("cdat");
         PacketPut1ByteInt(p);
         PacketPut4ByteInt(mwPS.frame_num + control_lead_frames); // add control_lead_frames to mwPS.frame_num
         PacketPut1ByteInt(players1[p].comp_move);
         ClientSend(packetbuffer, packetsize);

         players1[p].client_cdat_packets_tx++;
         sprintf(msg,"tx cdat - move:%d\n", players1[p].comp_move);
         if (L_LOGGING_NETPLAY_cdat) add_log_entry2(35, active_local_player, msg);
      }
   }
}

had no effect, but i'm going to leave it...


now I think this might be the cause:
in mode 8 the level done keeps triggering


void game_loop(int start_mode)
{
   game_exit = 0;
   proc_start_mode(start_mode);
   while (!game_exit)
   {
      proc_scale_factor_change();
      proc_sound();

      if (ima_server) server_control();
      if (ima_client) client_control();
      proc_controllers();

      if ((level_done_mode > 0) && (level_done_mode < 7)) proc_level_done_mode();
      else


      try this

      if ((level_done_mode > 0) && (level_done_mode < 9)) proc_level_done_mode();


no dif...
maybe its not that the mode is 8, maybe its that it never updates..never calls screen_overlay...
it does...
I added  al_set_target_backbuffer(display); and now it seems to work...

well that was many hours of troubleshooting to fix that....

now test with fake keypress mode....that seems to work...

server player did not timeout...
single player does...

all that is need for timeout is for the game move 'next level' to get processed
of course now I can't make it fail...
when I saw it fail, the countdown on the server went negative






bugs - why frameskipping...is it when I added init_level_background to client code just before sending stak...yes
calling that causes minor frameskipping

moved it to:
void proc_player_state_game_move(int x)
{
   // player becomes active
   if ((players[p].active == 0) && (val > 0) && (val < 16))
   {
      if (ima_client) init_level_background();

better, but still off by a couple of blocks here and there
maybe if I could trigger it to do after the first state after join


bug.. why does the end of level thing suck so bad!


everytime I do a three players end of game, one of them quits before the count starts....


it looks like server dropped the player due to lack of sdat rx for the last 100 frames...
coincidentally the same amount of time between level_done 1 and 2..

should I increase it to make it more obviuos... also, why does only one player do that and not both?

it is always this one client, e6400, doesn't matter if it's client 1 or 2...why??

what is the deal behind this drop anyway??
it was a typo that i fixed, it is supposed to be SDAK not SDAT...

how often does the server send sdat with no data...
players1[p].server_sdat_sync_freq = 20 or 0

from the server logs....

[22][0][339]+--------------------------------------------------------------------------+
[22][0][339]|                               Player Array                               |
[22][0][339]+--------------------------------------------------------------------------+
[22][0][339]|        [p][wh][a][co][m]                                                 |
[22][0][339]|        [0][99][1][ 8][3] - mi3  <-- server                               |
[22][0][339]|        [1][ 0][1][ 9][2] - e6430  <-- active client                      |
[22][0][339]|        [2][ 1][1][10][2] - e6400  <-- active client                      |
[22][0][339]|        [3][99][0][ 0][0] -                                               |
[22][0][339]|        [4][99][0][ 0][0] -                                               |


[37][1][337]tx sdat p:1 st:15 nm:3
[37][2][337]tx sdat p:2 st:15 nm:3
[39][1][338]rx sdak p:1 nep:[18] server_sync:[2] frames skipped:2
[39][2][338]rx sdak p:2 nep:[18] server_sync:[2] frames skipped:1

[10][0][339]|                            LEVEL 71 DONE (1)                             |

[37][1][358]tx sdat p:1 st:18 nm:0 (sync only) (sf:20)
[37][2][358]tx sdat p:2 st:18 nm:0 (sync only) (sf:20)

[39][1][368]rx sdak p:1 nep:[18] server_sync:[28] frames skipped:3
[27][1][368]rx stak p:1 ack frame:365 corr:0 total_corr:1 set new base

[37][1][368]tx sdat p:1 st:18 nm:0 (sync only) (sf:1)




[39][1][369]rx sdak p:1 nep:[18] server_sync:[2] frames skipped:29
[27][1][377]rx stak p:1 ack frame:375 corr:0 total_corr:1 set new base
[37][2][379]tx sdat p:2 st:18 nm:0 (sync only) (sf:20)
[27][1][387]rx stak p:1 ack frame:385 corr:0 total_corr:1 set new base
[37][1][389]tx sdat p:1 st:18 nm:0 (sync only) (sf:20)
[39][1][390]rx sdak p:1 nep:[18] server_sync:[2] frames skipped:29
[27][1][397]rx stak p:1 ack frame:395 corr:0 total_corr:1 set new base
[37][2][400]tx sdat p:2 st:18 nm:0 (sync only) (sf:20)
[27][1][407]rx stak p:1 ack frame:405 corr:0 total_corr:1 set new base

[37][1][410]tx sdat p:1 st:18 nm:0 (sync only) (sf:20)
[39][1][411]rx sdak p:1 nep:[18] server_sync:[2] frames skipped:29
[27][1][417]rx stak p:1 ack frame:415 corr:0 total_corr:1 set new base

[37][2][421]tx sdat p:2 st:18 nm:0 (sync only) (sf:20)

[27][1][427]rx stak p:1 ack frame:425 corr:0 total_corr:1 set new base
[37][1][431]tx sdat p:1 st:18 nm:0 (sync only) (sf:20)
[39][1][432]rx sdak p:1 nep:[18] server_sync:[2] frames skipped:29
[27][1][437]rx stak p:1 ack frame:435 corr:0 total_corr:1 set new base
[10][2][439]+--------------------------------------------------------------------------+
[10][2][439]|                                                                          |
[10][2][439]|               Server dropped player:2 (last sdat rx > 100)               |
[10][2][439]|                                                                          |
[10][2][439]+--------------------------------------------------------------------------+
[37][1][440]tx sdat p:1 st:18 nm:1
[37][2][440]tx sdat p:2 st:18 nm:1
[10][2][440]+--------------------------------------------------------------------------+
[10][2][440]|                                                                          |
[10][2][440]|               Server dropped player:2 (last sdat rx > 100)               |
[10][2][440]|                                                                          |
[10][2][440]+--------------------------------------------------------------------------+
[39][1][441]rx sdak p:1 nep:[19] server_sync:[2] frames skipped:29

[37][1][441]tx sdat p:1 st:19 nm:1
[37][2][441]tx sdat p:2 st:18 nm:2

[10][2][441]+--------------------------------------------------------------------------+
[10][2][441]|                                                                          |
[10][2][441]|               Server dropped player:2 (last sdat rx > 100)               |
[10][2][441]|                                                                          |
[10][2][441]+--------------------------------------------------------------------------+
[39][1][442]rx sdak p:1 nep:[20] server_sync:[2] frames skipped:29
[37][1][442]tx sdat p:1 st:20 nm:1
[37][2][442]tx sdat p:2 st:18 nm:3
[10][2][442]+--------------------------------------------------------------------------+
[10][2][442]|                                                                          |
[10][2][442]|               Server dropped player:2 (last sdat rx > 100)               |
[10][2][442]|                                                                          |
[10][2][442]+--------------------------------------------------------------------------+
[39][1][443]rx sdak p:1 nep:[21] server_sync:[2] frames skipped:29
[37][1][443]tx sdat p:1 st:21 nm:1
[37][2][443]tx sdat p:2 st:18 nm:4
[10][2][443]+--------------------------------------------------------------------------+
[10][2][443]|                                                                          |
[10][2][443]|               Server dropped player:2 (last sdat rx > 100)               |
[10][2][443]|                                                                          |
[10][2][443]+--------------------------------------------------------------------------+
[39][1][444]rx sdak p:1 nep:[22] server_sync:[2] frames skipped:29
[37][1][444]tx sdat p:1 st:22 nm:1
[39][1][445]rx sdak p:1 nep:[23] server_sync:[2] frames skipped:29
[27][1][445]tx stdf p:1 [src:435 dst:445] cmp:136 ratio:0.13 [1 packets needed]
[28][1][445]tx stdf p:1 piece [1 of 1] [435 to 445] st:   0 sz: 136
[27][1][447]rx stak p:1 ack frame:445 corr:0 total_corr:1 set new base
[27][1][450]tx stdf p:1 [src:445 dst:450] cmp:126 ratio:0.12 [1 packets needed]
[28][1][450]tx stdf p:1 piece [1 of 1] [445 to 450] st:   0 sz: 126
[27][1][452]rx stak p:1 ack frame:450 corr:0 total_corr:1 set new base
[27][1][455]tx stdf p:1 [src:450 dst:455] cmp:126 ratio:0.12 [1 packets needed]
[28][1][455]tx stdf p:1 piece [1 of 1] [450 to 455] st:   0 sz: 126
[27][1][457]rx stak p:1 ack frame:455 corr:0 total_corr:1 set new base
[27][1][460]tx stdf p:1 [src:455 dst:460] cmp:126 ratio:0.12 [1 packets needed]
[28][1][460]tx stdf p:1 piece [1 of 1] [455 to 460] st:   0 sz: 126
[27][1][462]rx stak p:1 ack frame:460 corr:0 total_corr:1 set new base
[37][1][465]tx sdat p:1 st:23 nm:0 (sync only) (sf:20)
[27][1][465]tx stdf p:1 [src:460 dst:465] cmp:126 ratio:0.12 [1 packets needed]
[28][1][465]tx stdf p:1 piece [1 of 1] [460 to 465] st:   0 sz: 126
[39][1][466]rx sdak p:1 nep:[23] server_sync:[2] frames skipped:29
[27][1][467]rx stak p:1 ack frame:465 corr:0 total_corr:1 set new base
[27][1][470]tx stdf p:1 [src:465 dst:470] cmp:126 ratio:0.12 [1 packets needed]
[28][1][470]tx stdf p:1 piece [1 of 1] [465 to 470] st:   0 sz: 126
[27][1][472]rx stak p:1 ack frame:470 corr:0 total_corr:1 set new base
[27][1][475]tx stdf p:1 [src:470 dst:475] cmp:126 ratio:0.12 [1 packets needed]
[28][1][475]tx stdf p:1 piece [1 of 1] [470 to 475] st:   0 sz: 126
[27][1][477]rx stak p:1 ack frame:475 corr:0 total_corr:1 set new base
[27][1][480]tx stdf p:1 [src:475 dst:480] cmp:126 ratio:0.12 [1 packets needed]
[28][1][480]tx stdf p:1 piece [1 of 1] [475 to 480] st:   0 sz: 126
[23][0][480]bandwidth (B/s) TX cur:[ 1389] max:[ 3702] RX cur:[  196] max:[  384]
[24][0][480]packets per s TX cur:[ 16] max:[ 25] RX cur:[ 13] max:[ 23]
[23][1][480]bandwidth (B/s) TX cur:[ 1287] max:[ 2751] RX cur:[  196] max:[  187]
[24][1][480]packets per s TX cur:[ 13] max:[ 17] RX cur:[ 13] max:[ 11]
[27][1][482]rx stak p:1 ack frame:480 corr:0 total_corr:1 set new base
[27][1][485]tx stdf p:1 [src:480 dst:485] cmp:126 ratio:0.12 [1 packets needed]
[28][1][485]tx stdf p:1 piece [1 of 1] [480 to 485] st:   0 sz: 126
[37][1][486]tx sdat p:1 st:23 nm:0 (sync only) (sf:20)
[39][1][487]rx sdak p:1 nep:[23] server_sync:[2] frames skipped:29
[27][1][487]rx stak p:1 ack frame:485 corr:0 total_corr:1 set new base
[27][1][490]tx stdf p:1 [src:485 dst:490] cmp:126 ratio:0.12 [1 packets needed]
[28][1][490]tx stdf p:1 piece [1 of 1] [485 to 490] st:   0 sz: 126
[27][1][492]rx stak p:1 ack frame:490 corr:0 total_corr:1 set new base
[27][1][495]tx stdf p:1 [src:490 dst:495] cmp:126 ratio:0.12 [1 packets needed]
[28][1][495]tx stdf p:1 piece [1 of 1] [490 to 495] st:   0 sz: 126
[27][1][497]rx stak p:1 ack frame:495 corr:0 total_corr:1 set new base
[27][1][500]tx stdf p:1 [src:495 dst:500] cmp:126 ratio:0.12 [1 packets needed]
[28][1][500]tx stdf p:1 piece [1 of 1] [495 to 500] st:   0 sz: 126
[27][1][502]rx stak p:1 ack frame:500 corr:0 total_corr:1 set new base
[27][1][505]tx stdf p:1 [src:500 dst:505] cmp:126 ratio:0.12 [1 packets needed]
[28][1][505]tx stdf p:1 piece [1 of 1] [500 to 505] st:   0 sz: 126
[27][1][507]rx stak p:1 ack frame:505 corr:0 total_corr:1 set new base
[37][1][507]tx sdat p:1 st:23 nm:0 (sync only) (sf:20)
[39][1][508]rx sdak p:1 nep:[23] server_sync:[2] frames skipped:29
[27][1][510]tx stdf p:1 [src:505 dst:510] cmp:126 ratio:0.12 [1 packets needed]
[28][1][510]tx stdf p:1 piece [1 of 1] [505 to 510] st:   0 sz: 126
[27][1][512]rx stak p:1 ack frame:510 corr:0 total_corr:1 set new base
[27][1][515]tx stdf p:1 [src:510 dst:515] cmp:126 ratio:0.12 [1 packets needed]
[28][1][515]tx stdf p:1 piece [1 of 1] [510 to 515] st:   0 sz: 126
[27][1][517]rx stak p:1 ack frame:515 corr:0 total_corr:1 set new base
[27][1][520]tx stdf p:1 [src:515 dst:520] cmp:126 ratio:0.12 [1 packets needed]
[28][1][520]tx stdf p:1 piece [1 of 1] [515 to 520] st:   0 sz: 126
[23][0][520]bandwidth (B/s) TX cur:[ 1210] max:[ 3702] RX cur:[  122] max:[  384]
[24][0][520]packets per s TX cur:[ 10] max:[ 25] RX cur:[ 10] max:[ 23]
[23][1][520]bandwidth (B/s) TX cur:[ 1210] max:[ 2751] RX cur:[  122] max:[  196]
[24][1][520]packets per s TX cur:[ 10] max:[ 17] RX cur:[ 10] max:[ 13]
[27][1][522]rx stak p:1 ack frame:520 corr:0 total_corr:1 set new base
[39][2][522]rx sdak p:2 nep:[18] server_sync:[182] frames skipped:2
[39][2][522]rx sdak p:2 nep:[18] server_sync:[182] frames skipped:2
[39][2][522]rx sdak p:2 nep:[18] server_sync:[182] frames skipped:2
[39][2][523]rx sdak p:2 nep:[18] server_sync:[183] frames skipped:2
[39][2][523]rx sdak p:2 nep:[19] server_sync:[183] frames skipped:2
[39][2][523]rx sdak p:2 nep:[20] server_sync:[183] frames skipped:2
[39][2][523]rx sdak p:2 nep:[21] server_sync:[183] frames skipped:2
[39][2][523]rx sdak p:2 nep:[22] server_sync:[183] frames skipped:2
[27][2][523]rx stak p:2 ack frame:440 corr:0 total_corr:0 set new base
[27][1][525]tx stdf p:1 [src:520 dst:525] cmp:126 ratio:0.12 [1 packets needed]
[28][1][525]tx stdf p:1 piece [1 of 1] [520 to 525] st:   0 sz: 126
[27][1][527]rx stak p:1 ack frame:525 corr:0 total_corr:1 set new base
[37][1][528]tx sdat p:1 st:23 nm:0 (sync only) (sf:20)
[39][1][529]rx sdak p:1 nep:[23] server_sync:[2] frames skipped:29
[27][1][530]tx stdf p:1 [src:525 dst:530] cmp:126 ratio:0.12 [1 packets needed]
[28][1][530]tx stdf p:1 piece [1 of 1] [525 to 530] st:   0 sz: 126
[27][1][532]rx stak p:1 ack frame:530 corr:0 total_corr:1 set new base
[27][1][535]tx stdf p:1 [src:530 dst:535] cmp:126 ratio:0.12 [1 packets needed]
[28][1][535]tx stdf p:1 piece [1 of 1] [530 to 535] st:   0 sz: 126
[27][1][537]rx stak p:1 ack frame:535 corr:0 total_corr:1 set new base
[10][0][539]+--------------------------------------------------------------------------+
[10][0][539]|                                                                          |
[10][0][539]|                                                                          |
[10][0][539]|                                                                          |
[10][0][539]|                            LEVEL 71 DONE (2)                             |
[10][0][539]|                                                                          |
[10][0][539]|                                                                          |
[10][0][539]|                                                                          |
[10][0][539]+--------------------------------------------------------------------------+

it looks like the server kept sending periodic sdat but got no reply from p2
from 358 on, until frame 522 when 8 arrived at once...
522-358=164/40 = 4.1s


tried it again with p1 and p2 reversed

e6400 was still the one to quit

last sdak rx just before level done 497
then none till 680 when 8 came at once
680-497=183/40 = 4.6s

and only on e6400...

tried a reboot
tried TCP instead of UDP
tried turning off microsoft QOS
still the same....
fuck that computer...swap it out...

that solved that problem....

next problem...the level after that does not level done nicely
works and looks good on the server but the clients never show press any...


tested a few times...

sometimes it works fine

sometimes just does show on client but still ack on server

sometimes nothing on clients or server and it just freezes in mode 8 on clients...

I think I have some issues with the state sync thing still going..

how about once level done happens, one more state sync happens then that shuts down
on the server, no more changes are accepted, that is the final state, push it out to the clients

I wonder if I can or should decouple the state sync thing from the game loop...

all I need to do is stop sending states from the server...

after level done 1, send a state then stop the periodic sending until the next level starts...

after level done 1 is processed on the server, wait 5 frame then send the final state...
then wait until we are sure it has been processed before level done 2...


to implement this:

use level_done mode to stop periodic states
in server mode when processing level done 1, send a state to all clients....


void server_send_stdf(void)
{
   if ((mwPS.frame_num > 1) && (level_done_mode == 0))

   for (int p=1; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (players[p].control_method == 2))
         server_send_stdf(p);


this worked fine from 71-72-73 but leaving 73 client were frozen
74 started without them but the joing at frame 1500, server looked good but clients were still stuck on level done..



when the clients get stuck, they get stuck in mode 8
on the server they come active around fram 1500, but on the client they are still stuck in mode 8...


what could cause a client getting stuck in mode 8?

colliding with exit but never getting the level done game move synced back to make them go to mode 6

try to capture this...

71-72 good
72 level done bad

client game moves for 72 has no actual moves...
just a bunch of starts for frame 0

it looks like locally it thinks it is inactive, but the state keeps correcting it to active


even on a good one...
client has a lot of frame 0 starts
client does not have anything right in the game moves array till about 1300 frames

I might have to re-think this entire method....

20220617 4:00AM

why does client get stuck on mode 8?
it puts itself in mode 8
the only way from 8 to 6 and beyond is to receive the level done game move
why is that not happening?

are they being sent?

server log 281 level done starts

server sent sdat:
278 sync only 16 0 reply 279
299 sync only 16 0 reply 300
320 sync only 16 0 reply 321

they are not being sent!!!...why??

check the succesful level before...

server log 168 level done starts
server sent sdat:
166 6 3 reply 167


right from the start of the bad level, client keeps acknowledging move 16
i think the problem is in the game move sync stuff..

I want to show on the debug screen the game move entry position

i think the reason the server does not send the game moves is, right away the client acknowledges moves in the future...

add some sanity checks...
don't let server rxing sdaks set gmep in the future...ignore the packet entirely and flag an error...

void server_proc_sdak_packet(void)
{
   int p = PacketGet1ByteInt();
   int client_fn = PacketGet4ByteInt();
   int gmep = PacketGet4ByteInt();
   int sl = PacketGet4ByteInt();
   int fs = PacketGet4ByteInt();

   if (gmep > game_move_entry_pos)
   {
      sprintf(msg,"rx sdak p:%d nep:[%d] server_sync:[%d] frames skipped:%d -- error client tried to acknowlege future game move entry position\n", p, players1[p].game_move_entry_pos, players1[p].server_sync, players1[p].frames_skipped);
      if (L_LOGGING_NETPLAY_sdak) add_log_entry2(39, p, msg);
   }
   else
   {
      players1[p].game_move_entry_pos = gmep; // mark as rx'ed by setting new entry pos
      players1[p].stdf_late = sl;
      players1[p].frames_skipped = fs;



holy shit!  i think I finally fixed it!


lets test more....

8 player game with fake keypress

71-72 good

72 level done
-player 5 did not acknowledge
all others did
p5 stuck in mode 8
press any count went negative for p5
exactly the same on all clients and server
never went to next level...
killed the server and all players lost server connection...


look into the logs....
server log:

all 7 clients send a cdat every frame
for some reason server only sends sdat back to 12347
why not 5 and 6??

when server sends sdats, show why it chose which ones to send


or just show the entire player structure every frame

20220618 7:00AM

saturday...I should have a bigger block of time today...
work on netgame and how you broke it...
the issue is how level done works..all the rest of netgame seems to work fine


test... end of level 72 server froze...

it looks like there are lots of problem in the game move sync thing
packets arriving in chunks way too late,
huge amount of packets arriving in the same frame



test end of level 73 server froze stuck in mode 6
game moves:
652 ld1
732 ld2
1452 nl

in server logs: 652 level_done 1 is there...
by then only client 1 and 5 were up to date with gmep at 4000
all other clients were stuck at 200
server kept sending periodic sdats to these clients, but with nm=0 (sync only)

lets go back and see if we can find where it all went wrong...

right at the start server is still receiving cdats with frame numbers from the last level
and they are getting entered in the game moves array

how about adding some more checks:
on server when receiving cdats:
- do not enter any gm for players that are currently not active
- do not eneter any gm if more than 20? frames in the future
on client:
when in ld2 mode....can't think of a way to stop sending...leave it for now...


try again....
got all the way to 74 with no errors...


try again

player 6 stuck in mode 8...
same thing...
gm sync for that player went bad and it was way behind...

try again...good till 74

what variable on the server shows timing drift for each client? players1[p].server_sync

clients could be drifting too much...lets see...

once the game is running server_sync is very stable at 2...
but at the start is goes from approx 20 to -7 for the first 5 seconds or so...

lets do some more tests...
71-74 perfect..again...

I think I might have completed it.

make it so that player array can be switched on and off in log viewer..
does it need its own type?? yes 26 player array color 15
that was easy...done

I would like to have more information...
like a graph of how the timing drift fixes itself
and at the same time, errors on the same graph
just the sync graph for now....
now I can experiment with different sync strategies ...


what are the inputs?
what can I change?

server_sync
clients fps
how often the fps gets changed

where do I want to see this?

server would be nice...

client adjusts when rxing sdat
client needs to respond with actual fps in sdak...

   // client timer adjust
   players1[p].client_sync = sdat_frame_num - mwPS.frame_num;
   int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames)*2;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));

just reply with fps_chase also...
then what? when server gets it..log it...

I cant tell the frequency in fake keypress mode, server sends sdat every frame anyways

I would like to do the graph as a two part...one on top of the other
this took a long time, but it's done!!

i would like to learn how to do a dashed line in allegro..gave up again...



show comparison between
int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames)*2;
and
int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames);
maybe three also...

test method...
- 8 players
- fake keypress
- ld 71, 72, 73, quit on 74 once they have all stabilised...
run the graph and printscreen...
did 1, 2 and 0.5....1 is the best



bug--timout does not work on server player level done...

only when fakekeypress mode

game moves gets so filled up that looking back 100 does not find next level..

solution..prevent duplicate ack's

also when server read cdats it directly entered acks..changed this so that add_game_move does this now...

its looking really good now....

made graph look even better and now I am re-doing the sync graphs

bug - server cannot cancel timeout...fixed. in add_game_move allow next level to be added in ld mode 5..

clamped fps chase to 10 and 70...

make logging parr optional...done...



extern ALLEGRO_BITMAP *level_done_bitmap;
extern int level_done_bitmap_create;

I think I have it done....

now use it and fix the loop..


i want to make draw_2_lines be able to draw on an arbitrary bitmap that i pass it...or the screen_buffer

then I will use it for splash screen, level_done and demo_mode

why don't I make them all use the same bitmap that is the same size as the screen....

and have an int flag that tells the status so I dont redraw it

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;

0 - not_valid and needs to be created
1 - PURPLE MARTIANS
2 - LEVEL DONE
3 - DEMO MODE

replaced level done...

all have been replaced and it is a lot simpler now...

test run game...seems to work....


bug - when blocks are erased in netgame...
players joining later have the exact level array (because state_dif makes sure of that)
but they sometimes might not have the correct level_background
I can't redraw that too often as it causes frame skips
I tried redrawing it whenever I got a state on the client, but that was like once per second and I got skips every second
I tried redrawing it when client first synced, but still missed a few...

I could do on client if l has any state dif errors...yes...

I think this is working...only a few occur and its right around when syncing...






what if I re-did the chase and lock thing...
right now I think it joins too soon...

make it so that if sync is between 0 and 4 for 40 frames then set active...

can I show on the graph where players became active??
I should...

what log entry?? 10
but it is shared with other stuff....

now the graph shows when client become active...

players1[p].made_active_holdoff is used so that I dont set player active every frame

added:
int sync_stabilization_holdoff;

changed:

if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
{
   if (players1[p].made_active_holdoff) players1[p].made_active_holdoff--;
   else if ((players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      players1[p].made_active_holdoff = 6;
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }
}

to:

if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
{
   if ((players1[p].server_sync >= 0) && (players1[p].server_sync <= 4)) players1[p].sync_stabilization_holdoff++;
   else players1[p].sync_stabilization_holdoff = 0;
}

if (players1[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
{
   add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
   players1[p].sync_stabilization_holdoff = 0;
   sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
   if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
}

did not do that much for stabilization..
the oscillation seems to happen after the clients come active and fake keypress happens

set the holdoff to much in the future to test...
yes...oscillation comes when clients go active

try it without fake keypress....






test on linux...

mx linux on mr5mx1

l - erase all from shared folder
w - copy all files to shared folder
l - sudo ./op
open proj in code::blocks
set build target ldm
build all
run from command line ./pm

seems to work just fine in linux

opengl does not look as nice...

stats:

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
available fullscreen modes:
w: 640 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 640 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 640 h: 480 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 640 h: 480 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 400 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 480 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 480 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 576 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 576 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 576 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 720 h: 576 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 800 h: 600 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 800 h: 600 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 800 h: 600 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1024 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1024 h: 768 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1024 h: 768 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1152 h: 864 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 720 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 800 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h: 960 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h:1024 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1280 h:1024 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1360 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1440 h: 900 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1600 h: 900 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1600 h:1200 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1600 h:1200 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1600 h:1200 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1600 h:1200 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1680 h:1050 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1080 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1200 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1200 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1200 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:1920 h:1200 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2048 h:1536 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2048 h:1536 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2048 h:1536 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2048 h:1536 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2560 h:1440 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2560 h:1440 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2560 h:1440 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:2560 h:1440 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:1620 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:1620 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:1620 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:1620 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:2160 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:3840 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:4096 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:4096 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w:4096 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
w: 640 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 640 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 640 h: 480 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 640 h: 480 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 400 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 480 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 480 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 576 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 576 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 576 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 720 h: 576 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 800 h: 600 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 800 h: 600 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w: 800 h: 600 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1024 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1024 h: 768 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1024 h: 768 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1152 h: 864 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 720 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 800 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h: 960 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h:1024 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1280 h:1024 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1360 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1440 h: 900 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1600 h: 900 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1600 h:1200 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1600 h:1200 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1600 h:1200 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1600 h:1200 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1680 h:1050 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:50 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1080 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1200 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1200 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1200 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:1920 h:1200 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2048 h:1536 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2048 h:1536 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2048 h:1536 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2048 h:1536 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2560 h:1440 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2560 h:1440 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2560 h:1440 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:2560 h:1440 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:1620 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:1620 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:1620 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:1620 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:2160 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:3840 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:4096 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:4096 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
w:4096 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:5
ALLEGRO_GREEN_SIZE:6
ALLEGRO_BLUE_SIZE:5
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:11
ALLEGRO_GREEN_SHIFT:5
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:16
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:16384
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:30



Purple Martians Version 7.10
Allegro Version: 5.2.8.0
System ID: Xglx
Desktop Resolution: 3840x2160
available fullscreen modes:
w:3840 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:4096 h:2160 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:4096 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:4096 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:4096 h:2160 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:3840 h:2160 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:3840 h:2160 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:3840 h:2160 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2880 h:1620 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2560 h:1600 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2560 h:1440 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2560 h:1440 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2048 h:1536 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2048 h:1536 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1440 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1440 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1856 h:1392 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1856 h:1392 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1792 h:1344 -- refresh rate:74 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1792 h:1344 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2048 h:1152 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2048 h:1152 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:2048 h:1152 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1200 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1200 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1920 h:1080 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h:1200 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h:1200 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h:1200 -- refresh rate:65 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h:1200 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1680 h:1050 -- refresh rate:74 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1680 h:1050 -- refresh rate:69 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1680 h:1050 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1680 h:1050 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h:1024 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1400 h:1050 -- refresh rate:74 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1400 h:1050 -- refresh rate:69 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1400 h:1050 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h: 900 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h: 900 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1600 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h:1024 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h:1024 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1440 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1440 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1400 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1400 h: 900 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 960 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1440 h: 810 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1440 h: 810 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1368 h: 768 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1368 h: 768 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1360 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1360 h: 768 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1360 h: 768 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 800 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 800 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 800 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 800 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1152 h: 864 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1152 h: 864 -- refresh rate:74 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1152 h: 864 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1152 h: 864 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:30 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:29 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:24 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1280 h: 720 -- refresh rate:23 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 768 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 768 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 768 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 768 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 768 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 720 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 720 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 928 h: 696 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 928 h: 696 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 896 h: 672 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 896 h: 672 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 576 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 576 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 576 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w:1024 h: 576 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 600 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 600 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 832 h: 624 -- refresh rate:74 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 540 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 540 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 540 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 960 h: 540 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:140 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:130 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 600 -- refresh rate:56 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 840 h: 525 -- refresh rate:149 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 840 h: 525 -- refresh rate:139 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 840 h: 525 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 840 h: 525 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 864 h: 486 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 864 h: 486 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 512 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 700 h: 525 -- refresh rate:149 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 700 h: 525 -- refresh rate:140 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 700 h: 525 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 450 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 800 h: 450 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 512 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 512 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 450 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 700 h: 450 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 700 h: 450 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:72 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:75 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:60 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 480 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 405 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 405 -- refresh rate:58 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 720 h: 400 -- refresh rate:70 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 684 h: 384 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 684 h: 384 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 680 h: 384 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 680 h: 384 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 400 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 400 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 576 h: 432 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 576 h: 432 -- refresh rate:149 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 576 h: 432 -- refresh rate:140 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 576 h: 432 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 360 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 360 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 360 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 640 h: 360 -- refresh rate:59 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 512 h: 384 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 512 h: 384 -- refresh rate:140 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 512 h: 384 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 512 h: 288 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 512 h: 288 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 416 h: 312 -- refresh rate:149 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 480 h: 270 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 480 h: 270 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 400 h: 300 -- refresh rate:144 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 400 h: 300 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 400 h: 300 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 400 h: 300 -- refresh rate:112 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 432 h: 243 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 432 h: 243 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 320 h: 240 -- refresh rate:145 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 320 h: 240 -- refresh rate:150 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 320 h: 240 -- refresh rate:120 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 360 h: 202 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 360 h: 202 -- refresh rate:118 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 320 h: 180 -- refresh rate:119 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
w: 320 h: 180 -- refresh rate:118 pixel format:ALLEGRO_PIXEL_FORMAT_ANY
display flags:
ALLEGRO_OPENGL
ALLEGRO_RESIZABLE
ALLEGRO_FULLSCREEN_WINDOW
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:8
ALLEGRO_RED_SHIFT:0
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:16
ALLEGRO_ALPHA_SHIFT:24
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:2
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:32867
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:16384
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:4
ALLEGRO_OPENGL_MINOR_VERSION:3
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_ABGR_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
m@mr5mx1:~/Desktop/pm_client22




some things in linux flicker...

level_viewer in level_editor

after some testing I have come to realize...
the stuff in linux looks way better when I change the desktop resoultion to 1920x1080 and the refresh rate to 60
it looks way better, the splash screen is way faster, level editor is way more responsive.
the old way 3840x2160 30fps was very choppy and the game was always skipping frames to match the desktop refresh rate..


20220619 10:05PM
lots done this weekend
large text screen overlay
chase fps and sync graph
tested new player lock code
fixed blocks not erasing on clients level background
netgame is much more stable...


bug:
why is logo so goddam slow in linux? ...opengl?
when I set mnu_timer faster the first screens go by really fast, but all the spline ones are very slow...
even in a small screen resolution
maybe later I could profile and see what takes up all the time...
it's most likely an opengl thing
seems to work a lot better when linux desktop refresh rate is 60, not 30...


20220620 6:00AM
fixed some things in level viewer where it compares levels to find duplicates

load_level make a way to not display

all 28 calls to load_level send display=0
but load_level does nothing with it...

load_level



this does not flicker:

   // load every level and get icon bitmaps
   for (int x=0; x<num_levs; x++)
      if (load_level(le[x], 0))
      {
         al_set_target_bitmap(level_icon_bmp[x]);
         draw_level2(level_icon_bmp[x], 0, 0, grid_size, 1, 1, 1, 1, 0);
         int pc = x*100 / num_levs;

         al_set_target_backbuffer(display);
         draw_percent_bar(SCREEN_W/2, SCREEN_H/2, SCREEN_W-200, 20, pc );
         al_draw_text(font, mC.pc[15], SCREEN_W/2, SCREEN_H/2+6, ALLEGRO_ALIGN_CENTER, "Creating level icon grid");
         al_flip_display();

      }

this does:

      al_set_target_bitmap(le_temp);
      al_clear_to_color(al_map_rgb(0,0,0));
      for (int my=0; my<20; my++)
         for (int mx=0; mx<20; mx++)
         {
            al_set_target_bitmap(le_temp);
            int level = my*20 + mx;
            int col = 11;
            if (!load_level(level, 0)) col = 10;
            else draw_level2(le_temp, mx*ms, my*ms, ms, 1, 1, 1, 1, 0);
            al_draw_textf(font, mC.pc[col], mx*ms +ms/2, my*ms+ms/2, ALLEGRO_ALIGN_CENTER, "%d", level);

            // show progress bar
            int pc = level*100 / 400;
            al_set_target_backbuffer(display);
            draw_percent_bar(SCREEN_W/2, SCREEN_H/2, SCREEN_W-200, 20, pc );
            al_draw_text(font, mC.pc[15], SCREEN_W/2, SCREEN_H/2+6, ALLEGRO_ALIGN_CENTER, "Loading Levels");
            al_flip_display();
         }

changed the order of load level and set target...
did not make any dif...


the same bullshit difference happens when inserting a new lift step

I think what is going on is in opengl....
you can't just leave stuff on the backbuffer, draw on it again, then flip
you have to completely erase it every time you flip or weird shit happens

if I use single buffer mode in opengl it seem to work...
and its also just as fast...

it also still seems to work in windows...

level editor for new lift step does not work nicely for move step...in linux..
new_lift_step type move does not show where the new step will be in linux, but when you click there it is placed there..
works fine in windows
fixed by adding al_flip_display() in getxy()


I think I have broken stuff in level editor windows...can't right click on lift step in map mode and get pop-up menu...
both lin and win...


tried 4230 ubuntu 20.04 1280x800 60Hz
main logo speed good
level editor seems a little sluggish but still works
speed test can do over 100fps
i though that open gl capped it to desktop refresh rate? not in this case open gl 1.4
when expanding screen in game, speed test fps drops to 50 when you can see the whole level...


20220623 6:00AM

bugs to work on...

display init broken on windows
errors and upside down
could be due to new display settings I recently changed
also need to add the checking of cfg values against desktop settings
also if display init fails, set sensible values in cfg for next time...

this is set during initial setup and can be relied upon...

void get_desktop_resolution()
{
   ALLEGRO_MONITOR_INFO aminfo;
   al_get_monitor_info(0, &aminfo);
   desktop_width  = aminfo.x2 - aminfo.x1;
   desktop_height = aminfo.y2 - aminfo.y1;
   printf("Desktop Resolution: %dx%d\n", desktop_width, desktop_height);

   disp_x_full = 0; // fullscreen  (set to 0, 0, desktop_width, desktop_height and never change)
   disp_y_full = 0;
   disp_w_full = desktop_width;
   disp_h_full = desktop_height;
}

added this in init display

   show_disp_values(0, 0, 1, 1, 1, "init");
   // check if windowed values are valid
   int th = 100;
   if (disp_x_wind > disp_w_full-th) disp_x_wind = disp_w_full-th;
   if (disp_y_wind > disp_h_full-th) disp_y_wind = disp_h_full-th;
   if (disp_w_wind > disp_w_full) disp_w_wind = disp_w_full;
   if (disp_h_wind > disp_h_full) disp_h_wind = disp_h_full;
   show_disp_values(0, 0, 1, 1, 1, "pc");
   save_config();

cannot reproduce the upside down display



level editor sluggish in linux,
what fps does it run at?
same as game?

display the fps of level editor same as game....

the problem is that init_level background is called every frame....
when that is removed, level editor draws a lot faster
so how can i only call it when needed?

I like how lift lines are dyanmically redrawn when moving lift steps


add it where it is needed....
after drawing blocks in em...done..

drawing blocks in zfs
block and fraem is good already..
need something for floodfill..done

paste selection in zfs...
menu bar is drawn on top of fsel and pasted into level...
why don't I just make sure menu sets backbuffer before drawing...
yes that did it..


when moving lift step

map move...

at the start of move, init level background with no lift lines

change init


done, but now draw lift lines assume we are always drawing on level background
I want to make it optional to draw on level buffer...



would it make it easier if lift lines were drawn when lift is drawn...always...everywhere...
yes did that...
getxy...done

now all I need to to find where mwPS.frame_num gets ahead of itself...
like in add lift steps

maybe I can remove the draw frame wait entirely....now that init level background is gone...

i just did this instead:

   proc_frame_delay();

   if (mwPS.frame_num <  al_get_timer_count(fps_timer)) set_frame_nums(mwPS.frame_num); // set fps_timer count to mwPS.frame_num

   if (draw_frame)
   {
      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();
   }



   seems to work, need to test in linux

seems to work just fine in linux


20220625 6:00 AM

bug...right click menu for lift step has been inadvertantly disabled..fixed

bug...getxy leaves draw cursor crosshair on level_backround
lift fixed
pod extended...create only...
testing creators...
why does trig bm bd show object for initial placement and pod and cloner does not??
fixed....

bug -- if you quit level editor in zfs paste mode, it crashes hard when you start le again...fixed
on load if ft_bmp is NULL do not draw and set copy_mode = 0;


bug...orb timed on..when time set to 1, never triggers toggle on
figure this out later maybe, for now just set timer to 2 or use always on event
- added 1 to count when reset
- subtracted 1 from count when calc percent to draw red/green
...fixed


bmsg has some spurious messages
always starts with damage field
ev 58
if ((mwPS.frame_num) && (mwPS.frame_num == players1[p].field_damage_holdoff)) game_event(58, 0, 0, p, 0, 0, 0);
fixed by not doing when frame num == 0....

purple coin shows as free man
check all bonus...
health..good 72
free man..good 70
purple coin..good 71

bug show non default blocks does not initially show in level editor...fixed

bug toggling show non default blocks should trigger init_level_background...done

going through levels

test the save game thing...

how does it deal with the acks?
not well??

what should it do?
stop at level done 2

what if it doesnt have level done?
stop at last gm...

where do I do this in code?

it all seems to work good, but what about a level that does not end with level done?

lets see if we can make that happen...
it just keeps going...
there is a progress screen overlay...if it is over 100% kill the level...


   if (players[0].control_method == 1) // file play
   {
      // find last gm with mwPS.frame_num !=0
      int last_pc = 0;
      for (int g = game_move_entry_pos; g>0; g--)
         if (game_moves[g][0] != 0)
         {
            last_pc = game_moves[g][0];
            break; // exit loop immed
         }


where can I do this??

in rungame_key_check

rungame happens from 3 places
- menu 'DEMO'
- menu "RUN DEMO"
- command line

should I have a common function they all pass through?

looks like they all just load the files then run game_loop(9); // demo game

how about in start_mode
extern int demo_mode_last_pc;

set it in start_mode...done

use it in screen overlay done..

use it in rungame key check...done

   // in run game mode and past the end of the file
   if ((players[p].control_method == 1) && (mwPS.frame_num > demo_mode_last_pc)) clear_controls(p);

should be all done now...



bug..player carry is supposed to favor anything but bonus
it doesn't seem to be working properly
is bonus type 10?? change to 2 like it should be....fixed

fixed bmsg switch...

20220625 4:00 PM

time for a push

notes:
separated draw lift lines from init_level_background
fixed sluggish level editor by removing call to init_level_background every frame
init display now uses single buffer so that opengl and d3d both act the same
init display limit checks
player carry bug fixes
demo mode bug fixes



bug-- when holding on to sproingy that expires you immediatley get it again with full time...
same thing if it is destroyed by a field
during player carry I need to check if item being carried has been destroyed
fixed

bug--zfs enemies don't respect selection filter
well they do, but the selection window stats show everything
while the actual stuff that will be copied respects the filters
fixed...

I spent a fair amount of time on level 17 - the one with the big blue rocket
it will probably be one of the main ones..

bug -- H blocks are erased from level background??
was still using tile from tiles instead of btiles...fixed...

bug - new bullet thing need to check for bad discriminant and A==0...done



20220628

set up OBS and do some screen recording

show creating a level and playing it...very simple

bug creating a new level should take you to that level....fixed


warp is just like an exit, only it takes you to a specified level instead of next one numerically



Can I say that I am done changing things in the game mechanics?

I think so..



what about the level rearrangement?

that was kind of the main reason for coming back...

if I make an over world it will need to be scalable for all screen sizes...




bug - when window is too small level viewer crashes

400x405 works
402x347 works


407x220 works


407x210 good ia 450
407x202 good ia 433
407x201 good ia 431
407x200 bad ia 427


300x340 good

282x340 good
281x340 bad

so the min is 282x201
no that is bad also???

enforce minimum screen size of 320x240
did this in init display...seems to work

   al_set_window_constraints(display, 320, 240, 0, 0);
   al_apply_window_constraints(display, 1);
   save_config();


make is so that resizing during vls works...done...




bug -- rockets cannot go through semisolid at an angle anymore
just clear the block flags for item solid


bug - jumping while pressing up on ladder
when I get to the semi-solid at the top i warp over
only when a ladder is directly below

When player is jumping and has up pressed

up makes you want to grab ladder
jump make you want to no grab ladder

how about make the up grab only work when jump is not also pressed...

that is just crazy enough to work, lets try it...

it can still happen but much less frequently




I am thinking more about the overmap thing...

I really don't like rearranging levels

This could be a solution to that

but is the solution more complicated than the problems?

right now all level done just starts the next level


I would need something that intercepts that and either:

goes to the next level on the list...

goes to the overmap...

what would the overmap look like?

A long horizontal scrolling?  A grid?


types of levels...lists...flags...tags...

- training
- show off object capablities
- good for multiplayer
- difficult
- not that good...
- best



its like I am paralyzed, trying to figure out the level thing...

and yet that is the main reason I came back to do more with the game...


level sets...

training...

main story game...

all


20220705 6:00AM

bug -- delete config and run game crashes
saved_display_transform_double is -1...is that valid??
SCREEN_W and H are being set to -800 and -600
what is auto? 0?...fixed...


working on beginning level and default keys
space alt...confirm....no...make it so....
p0_jump_key=75
p0_fire_key=219
done....



2020710

I have been working on levels...


I could use a config file for high score stuff



each entry would be:

lev_num
num players
finished (yes/no)
time
enemy killed
enemy left alive
shots fired
purple coins



bug -- some blocks are still not being shown as being erased when bombed or shot
remove_block is called when:
 remove key block range
 pbul hits breakable block
 ebul hits breakable block
 do bomb damage

the problem was that in bomb damage, cycling the blocks would cycle some out of range block
added code to test for this:
   for (int e = (bx-bd); e < (bx+bd)+1; e++)        // cycle blast range of blocks
      for (int f = (by-bd); f < (by+bd)+1; f++)
      {
         if ((e) && (e < 100) && (f) && (f < 100))



change controller setup to WASD ULDR..done

20220722
pixel in ul corner of purple player only when player color is zero... should use color 8 instead..fixed




hide bmsg when player is there...
how to detect if player is there...
detect what level blocks are covered by bmsg
made a method to reduce number of lines shown depending how close player is to bottom of screen
seems to work good...


I want to remove the entire lives and game over concept
- do not display in top_display
- remove free men bonus...
just have purple coins...

for now just replaced free men with purple coins on top display


bug -- if you are riding a rocket when it explodes, no damage is done to blocks
only rockets, bombs are fine
looks like explosion moves downwards, but only if player is still riding...fixed by forcing any player riding to drop rocket item


20220730

bug in block damage in mode "off until triggered"...triggers initially
unless go into toggle mode and set initial off???
fixed

when clearing blocks in zfs, need to init_level_background...fixed



make the init_level_background different...
make a flag to do it...
then only during the draw frame thing do it...

this would ensure:
it was only called once per frame
it was only called when the frame was drawn..

when is it called in the game...
switch
key
bomb
breakable


actually remove_block does not call it...

very few things do call it...

- when applying a state if block errors are detected
- switch block....

instead..I want to modify switch thing to not use it...

after much testing there was no difference with either method

I think the new way would be better when fewer block are changed


so now the only call to init_level_background when game running are:
when level is loaded
when state detects block differences
when client becomes active



bug - when lift is in timer rest mode, does not count down unless move step?
does not work in end step freeze or wait for trigger...

changes this line:

not sure if it has unforseen consquences...need to test...

//      if ((mode == 1) && (cst == 1)) // prox run and reset mode, current step type = move
      if (mode == 1) // prox run and reset mode


this looks tricky to fix....

I could add a flag to lift step...apply reset timer to this step...

there are two parts to this:

the part where the timer runs

the part where the timer is drawn

I am confident I want the timer to run all the time

now just don't show it in certain situations
like if step 1 and same x y as step 0
that seems to have fixed the issue...


bug - blocks that are marked by bomb to explode are not the same ones that are actually removed
does the bomb shift slightly??

it looks like I am trying to make the explosion circle start small and grow
probably that is where the problem is...no that was good
the bomb falls slightly with gravity..
i want to disable gravity, but not the constant motion of the bomb
done...


bug - if a key is exactly in the center of the block range it crashes, probably divide by zero..
now I can't reproduce....



actually it was a bonus item with health 100








20220813

I am going to add functionality for extra displays
right now it only is designed to work on the main one

the simplest way is to add a config value and let the user set it to something else if they want...

what are the correct terms:
"monitor" or "display adapter"
primary will be 0 and x and y will be zero
other monitors will be relative to that and may be negative





20220821

make blocks line up in block selection...done



make a smart floodfill

set region like zfs

set source and or destination to be a group of blocks

automatically do the corners and edges



to do this with outline only I need a different approach...

do nothing for bound blocks

how about the first pass that only sets non bound blocks with h and v thrus

then a second pass that only connects those




I want to make a whole new editor screen...block manip...

It will have a selection that is show on the level using ft[100][100]

you will be able to add to the selection
single blocks by clicking on them
block range by drawing
all blocks of the same tile within a selection area
all blocks of the same tile group within a selection area
advanced - set selection to only outline

then you can change all the selected blocks based on a pattern or block..

make a new mWindow...

th_

tile helper
mW[9].
mode == 9

add to file menu mode...


buttons...


mode:

add single tile
add rect selection of tiles

add all tiles that match one tile
add all tiles that match group


show marked blocks
where am I going to declare 100 100
global...where else??
int fhl[100][100] = {0};   // array of blocks to mark


show marked blocks is working

now what??

action: add/remove
all
specific block or rectangular range
all of one type of block
all of one type of block group


range:
entire level
within selection only

all blocks
connected blocks

change highlight color

where do I add buttons??
in the draw method

need a variable for mode or something
// mW[9] - tile helper only
int th_mode;


mode 1 is add blocks
mode 2 is remove blocks

add del works

now another mode..
single
match all
match connected

global/only in selection

single block / block group

th_add_del
0 = del
1 = add

th_match
0 = single specific tile position
1 = match all tile with same tile num
2 = match only connecting tiles with same tile num

th_group
0 = single tile num
1 = any in tile group


th_sel
0 = global
1 = only in selection


I want to do some replacement stuff now...

make a button for purple pipes and for wires


how do I add default block flags??

make the esc key work in th just like all other windows


make a section header like modify marked tiles
make a button to clear all

made new brown bricks
448

remove old brown bricks
640-656
10
23
33
116
322
370
375
done...

erased from tilemap and default flags...done

done in em_set_block_range()

next I need to make open purple pipes work



make it so that when the tiles are changed the block flags stay the same

make it less confusing what the buttons do


header:
"Modify Which Tiles Are Marked"
Tiles marked: 0/10,000
Clear all Marks
Action: Add Marks/Remove Marks
Add Specific Tile / Add Tile Group  || Remove Specific Tile / Remove Tile Group
Add Single / Add Connected / Add All

this looks a lot better now..
















20200910

make a hub level with warps to various things

made warp faster
without fucking up level_done..

add level_done_mode 9 for warp

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      players[p].paused = 5;
      level_done_mode = 9;
      next_level = item[i][8];
      game_event(4, 0, 0, p, i, 0, 0);
   }
}

void start_level_done(int p, int t1, int t2)
{
   level_done_mode = 7;
   int fn = mwPS.frame_num + control_lead_frames;
   add_game_move(fn,     6, 0, 1); // insert level done 1 into game move

   add_game_move(fn+t1,  6, 0, 2); // insert level done 2 into game move
   add_game_move(fn+t2, 7, 0, 0); // insert next level into game move
   players1[p].old_comp_move = players1[p].comp_move = 0; // reset both

   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) players1[p].quit_reason = 80;
}

void server_local_control(int p)
{
   int fn = mwPS.frame_num + control_lead_frames;               // add control_lead_frames to mwPS.frame_num
   set_comp_move_from_player_key_check(p);
   if (level_done_mode == 8) start_level_done(p, 80, 800);
   if (level_done_mode == 9) start_level_done(p, 10, 40);


void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 8) start_level_done(p, 80, 800);
            if (level_done_mode == 9) start_level_done(p, 1, 2);



made it so that pmsg will stay forever if time is set to -1

made block selection window line up with different set of blocks

bug...triggers, bd and bm are item, but are not destryoed with bd set to kill items
top kill them item[][14] is set to 10, but these three items have custom uses for that varaiable
kill them outright...9 16 17 orb?


bug - sometimes tiles are not drawn with proper masking, like player
they don't have transparent alpha channel for black background
restarting fixes it...
make sure that all bitmaps are properly cleared before use....
changed a bunch of
//   al_clear_to_color(al_map_rgb(0,0,0));
   al_clear_to_color(al_map_rgba(0,0,0,0));


bug - when starts are erased with BD bad stuff happens
how about we never erase starts with bd...done


fixed code for archwagon follow mode
now has hystersis to prevent oscilation
now does not oscillate when blocked by right wall




make podzilla have the opion to only be killed while extended
or only when at rest, or both
with bombs always??

I wish podzillas used splines to move
splines need 4 points, but I already have 2, the start and end
not really, I have start and xinc, yinc

6 fixed (5 to 10)
7 ints (15-21)

start is already 4,5 so i only need 6 more

I should make a brand new enemy for now

variable to control how long it take to get there in frames

then calculate all the points (one per frame)

then draw where we are in the array...

new enemy VinePod type 13
basic PDE

basic move and get killed functions

to do editor, set extended and contol points


what variables??

what order are spline points? start cp1 cp2 end

it would be nice to have them all in order:
45 start
67 cp1
89 cp2
1011 end

trigger is 11 12 13 14

lets do:
4 5 start
15 16 cp1
17 18 cp2
19 20 end

then I do not have to move trigger or other stuff

wait a minute!  enemies do not use 4 and 5 for initial position
i could use 3 to 10 for my 8 variables

3 is used for enemy deathcount but until then I plan to use it

3,4 initial postion
5,6 cp1
7,8 cp2
9,10 extended position
11,12,13,14 trigger box

then I have seven ints (15, 16, 17, 18, 19, 20, 21) for other stuff

somehow I need to enforce that 3,4 are the same as fixed 0,1

show exended pos..done
next make a way to change...
then do the same for cp1 and cp2
done...
now I can set and move all six points
now come the fun part... draw a spline based on them!!
nice!!!
now make the control points just circles and map moveable..done
now read in the whole spline to set the start rot and end rot..done
even nicer!!!

I think I am ready to start implementing how it works in the game...

I want to run a counter, very similar to the old method.
But this time there will be no speed variable.
The one variable will the the counter and it will correspond to the position in the array of points.

these are the old variables
//     Ei[e][5] = mode
//     Ei[e][6] = sequence counter
//     Ei[e][7] = sequence limit
//     Ei[e][8] = wait count
//     Ei[e][9] = wait limit

I can just add 10

//     Ei[e][15] = mode
//     Ei[e][16] = sequence counter
//     Ei[e][17] = sequence limit
//     Ei[e][18] = wait count
//     Ei[e][19] = wait limit

this works exactly like I had hoped

in draw enemy code draw the spline path

and the path traveled so far...done

make it so that moving main with shift moves all..done

creator..done
where? find old one

fix damage when touched (now is zero by default for both pod and vinepod) .. done..set to 2

add flag variable...
- invincible in initial pos
- invincible in extended pos
- invincible when moving
- show path

Ei[e][20] // flags

#define PM_ENEMY_VINEPOD_SHOW_PATH   0b00000000000000001
#define PM_ENEMY_VINEPOD_INV_INIT    0b00000000000000010
#define PM_ENEMY_VINEPOD_INV_EXTN    0b00000000000000100
#define PM_ENEMY_VINEPOD_INV_MOVE    0b00000000000001000

how should I handle invincible?
eat bullet but do not kill? ignore bullet?
eat bullet but do not kill...done

I am not entirely happy with the way the animation changes as it extends and how it looks when waiting

I want it to rotate from the base of the shape, not the middle...done

I would like to make some leaves on the vine as it extends..done


/*

      float dist = 0;
      float ld = 25;  // distance between leaves
      float tl = ld;  // leaf distance tally

      // cycle points as far as vine has extended
      for (int i=2; i<=Ei[e][16]*2; i+=2)
      {
         float x1 = dest[i-2];
         float y1 = dest[i-1];
         float x2 = dest[i+0];
         float y2 = dest[i+1];

         // get distance of this step
         float xlen = x1-x2;
         float ylen = y1-y2;
         float ds = sqrt(pow(xlen, 2) + pow(ylen, 2));

         dist += ds; // add to total distance

         if (dist>tl)
         {
            // printf("dif:%f\n", dist-tl);
            tl+=ld;
            //al_draw_circle(x1, y1, 3, c2, 1);

            // find the angle of a tangent line at this point
            float ang = atan2(ylen, xlen);

//            printf("ang:%f\n", ang);

            // lets try drawing a line with this angle

            float xo = cos(ang) * 20;
            float yo = sin(ang) * 20;

            al_draw_line(x1-xo, y1-yo, x1+xo, y1+yo, mC.pc[11], 0);


            ang += ALLEGRO_PI/2;

            xo = cos(ang) * 20;
            yo = sin(ang) * 20;

            al_draw_line(x1-xo, y1-yo, x1+xo, y1+yo, mC.pc[10], 0);


            // I have xlen a ylen aleady


            // rotate + or - 90

            // travel a set distance

//
//            // draw a leaf
//            float ra = atan2(ylen, xlen); // get the angle of a tangent line at this point
//
//
//            lsa = !lsa;
//
//            if (lsa) ra+= ALLEGRO_PI;
//

            al_draw_circle(x1+xo, y1+yo, 3, mC.pc[10], 0);
//

               // how far off the vine is each leaf
               //float xo = cos(ang - ALLEGRO_PI/2) * 0;
               //float yo = sin(ang - ALLEGRO_PI/2) * 0;



//
//           al_draw_scaled_rotated_bitmap(tile[311], 10, 20, x1+xo, y1+yo, .6, .6, ra, 0);
//
//           //al_draw_textf(f3, mC.pc[15], x1+xo, y1+yo, 0,"%2.1f", ra );





         }
      }


*/




make it so that when moving with zfs, all points move too..

what about copy with draw item? that too??



i just realized that all these points are absolute
they could be relative to the initial position...
is it worth it to change them?? not now..maybe later..

copy item done...
zfs done...

still need to do a help file entry for this

also what about making control points not snap to 20??



straighten out the creators...done
start block should not erase all others...done
how are creators sorted??

change block walker...
make it so that the blocks created can be breakable


need a variable for what type of block to create..

normal solid
breakable with p_bullets
what other options?
bombable? breakable with e_bullets

i think by far the most common will be breakable with p_bullets
so much in fact that I think that could be the only option
it is very dangerous to make soild blocks, so easy to get trapped...

search with glt and see where used...nothing I need to worry about

OK do it and make a test level..

make it so that permanent pmsg show all the time in level editor...for aligning with other things
I tried to do this before and ran in to a bug where the buttons on pmsg veiwer did not show...
this time I fixed it!  when item icon was drawn at the top of viewer with draw item custom
it was some how changing what gets drawn on..

bug when block walkers get copied with zfs, turn before hole gets changed..cannot reproduce...

make start creator make checkpoint common..done
and make it use the next index...done


make doors able to be invisible
item[i][13] - base anaimation shape
448 old style
done but may be a bit buggy....

the only enemy left to make an advanced level for is jumpworm

then lifts will be rather complex

then items?

start, exit, keys, swicthes, bonus are all very simple

complex..trigger..bm..bd


make sliders able to set default values if out of range
start with jumpworm jump before hole
changed slider0 so that a mouse click anywhere not on the adjustment bar will jump to that value and act like a mouse click on slider bar


in jumpworm, adjust the is up solid...
this is harder than it would first seem..
do it only when jumping...when Ei[][5] < 0
its just too complex...all my collison code assumes that everything is 20x20
if I have to make exceptions for things that are 20x10 I would need some very complex exceptions
just live with it, they hit ceilings with a 10 pixel margin...


in jumpworm, make an option to wall jump, get a boost when kicking off a wall
add a variable 'Wall Jump Boost' from 0 (off) to 160 (max)
done....

I think that is all I want to add to the mechanics of jumpworm...
should not break any existing, because Ei[][8] is zero...

What if jumpworms left some kind of damaging slime on walls and floors?

I would need to add a whole new mechanic to deal with that...



make pmsg always on if any player is in trigger box area...
dont break existing, just add this functionality


all other item triggers use 6,7,8,9 and these are already used for pmsg

I will need to move some things around....

also while working on pmsg, can we make them have a fixed size?
I spend so much time lining everything up nicely, adding line breaks so that the size comes out the way I want
what if I use the fancy multi-line print in allegro


I will need two more variables for the width and height of the msg


current:

[10] - pop-up msg
item[][6]  timer counter
item[][7]  timer value
item[][8]  text color
item[][9]  frame color
item[][10] msg x pos (100)
item[][11] msg y pos (100)


what can i not use?

item[][14] = time to live
item[][15] = tag with cloner item id

I'll need to get creative here, i want 6 more variables, but only have 2...

2 - flags
6, 7, 8, 9 trigger
10 - msg x, y
11 - msg w, h
12 - timer count and val
13 - frame and text color
when I split an 32 bit int, I get 16 for each 65,536

to start with move timer count and val and colors to 12, 13 and convert all existing psmgs

then I will have 6, 7, 8, 9, 10, 11 free...



how to pack these in...

what if I make a generic function?

void set_int_3216(int *I32, int H16, int L16)
// packs two 16 bit ints into one 32 bit int

void get_int_3216(int I32, int *H16, int *L16)
// extracts two 16 bit ints from one 32 bit int


usage:

int tc = 0;
int fc = 0;
get_int_3216(item[][13], &tc, &fc);

set_int_3216(&item[][13], tc, fc);

implementation:


void set_int_3216(int &I32, int H16, int L16)
{
   I32 = H16*65636 + L16;
}


void get_int_3216(int I32, int &H16, int &L16)
{
   L16 = I32 << 16; // shift lower into place
   H16 = I32 - L16;
}


test this....done

now patch in for color....

in glt...

for (int y=0; y<500; y++)
   if (item[y][0] == 10) // pmsg
   {
      set_int_3216(item[y][13], item[y][8], item[y][9]);
   }


patched it in draw_pop_message...seems to work...is this the only place I draw??

erase 8 and 9 and see!!!

backup levels....

still seems to work...

now fix where the colors are changed in level editor...

changed also in:
void display_pop_message(int c, char *f, int xpos_c, int ypos, int redraw_map, int show_line_breaks)

I think that the color stuff is all done...

now for the timer stuff

item[][6]  timer counter
item[][7]  timer value

12 - timer count and val

this can be negative, watch out!!

lets remove that whole negative thing and go with flags

maybe i should do the flags first

#define PM_ITEM_PMSG_SHOW_ALWAYS   0b00000000000000001
#define PM_ITEM_PMSG_SHOW_SCROLL   0b00000000000000010
#define PM_ITEM_PMSG_TRIGGER_BOX   0b00000000000000100
#define PM_ITEM_PMSG_AUTOSIZE      0b00000000000001000


check 2 with glt...

with glt...

if timer 7 < 0 then set 1001 (9)
else set                1010 (8)

set all <0 timers to 120;


for (int y=0; y<500; y++)
   if (item[y][0] == 10) // pmsg
   {
      // set flags
      item[y][2] = 0;
      item[y][2] |= PM_ITEM_PMSG_AUTOSIZE;
      item[y][2] |= PM_ITEM_PMSG_SHOW_SCROLL;

      if (item[y][7] < 1)
      {
         item[y][7] = 120; // set timer to default value
         item[y][2] |= PM_ITEM_PMSG_SHOW_ALWAYS;
         item[y][2] &= ~PM_ITEM_PMSG_SHOW_SCROLL; // clear
      }


now make the always show thing work...

I think I have it figured out...

now move 67 to packed 12

basically just put 7 in 12

i think the timer is done.....

now do the trigger....

detect if any player in trigger area..works!!

now make it adjustable with map...done

now what I have up to here is:

item[][2]  - flags
item[][6]  - trigger x
item[][7]  - trigger y
item[][8]  - trigger w
item[][9]  - trigger h
item[][10] - msg x
item[][11] - msg y
item[][12] - timer count and val
item[][13] - frame and text color

I still want to expand these:
10 - msg x, y
11 - msg w, h


make the rectangle showable for now and apply it later...
pack x and y into 10....

in glt:

   int mx = item[y][10];
   int my = item[y][11];

   item[y][10] = 0;
   item[y][11] = 0;

   set_int_3216(item[y][10], mx, my);




works for existing

fix set new pos...done

fix map move...move

map move both scroll and msg...done...

show in map overlays and allow lr adjust...done


now I'm ready to try custom draw!!!


its looking really good....


to do...what to do when w and h are off the screen?
make a button to draw new msg area...done


fix copying from draw item....done...

what to do about newlines?  I currently use 126 for newlines
before displaying, make a copy and modify that...done
extern char pmsgtext[500][500];
so I have 500 lines....

can I make xywh not snap to 20's, yes!


still need to:
fix creator...done

fix zfs

clean up objv...

when trigger is on or off...done

drawing in obv

title and overlays

Scroll Location (lt blue)

move trigger box also

Message Area (red)

Trigger Area (yellow)


still need to do:
fix zfs...done

do I ever need to carry or move a message??
out of 383 only 4 are not stat...
one was a mistake but in level 10 there is a legit use for them

drawing in obv
show how many characters left in msg when editting

i really dont want to have two version that draw the pmsg
can I extend one...

what does the second one do differently?

the first one is called 3 times
main draw function
getxy
redraw level editor to show all pmsg...

lets extend this one...

now it only takes int c

add:
int custom
int xpos_c
int ypos
char *f

void draw_pop_message(int c, int custom, int xpos_c, int ypos, char *f);
done

now try to extend and patch it in


I think it is working, but the text does not line up when editing...

what if I let this function highlight the text being edited
can I even do that??

yes I can!!!
when cursor is on line feed weird shit happens.. i think I have it fixed

I want to know have many char I have used
put in on the title

now that I have done all this...I want to try to edit in place...not draw another copy on the viewer
I will need to update the actual string as I go...abandoned this...just move on....

Now I am finally done with messages until I find new things to do with them, or bugs...


when the hell did I delete all my lifts??
I see nothing in glt that looks like it would have done that....

in load_level if passed load only...num_lifts is not set...
then when the level is saved no lifts get saved....

fix this bug, then see how far back we have to go to restore levels...



found levels from yesterday....now use glt to convert pmsgs...

or wait....I could maybe copy lifts from old levels to new??

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


get old levels folder on desktop....

get new levels folder on desktop.....


now I have levels (the new ones) and old_levels that have lifts not deleted

hi level plan...


- load old level
- save lifts in temp struct
- load new level
- copy lift structure over
- save

in main:

struct lift lifts[NUM_LIFTS];
struct lift_step lift_steps[NUM_LIFTS][40];

struct lift t_lifts[NUM_LIFTS];
struct lift_step t_lift_steps[NUM_LIFTS][40];

in pm.h

extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];

extern struct lift t_lifts[NUM_LIFTS];
extern struct lift_step t_lift_steps[NUM_LIFTS][40];


now make a custom load_level

loads from alt location

fills the temp variables

int t_load_level(int level_to_load, int load_only);

I thinks I've restored them all!

now clean up....done....




I need top fix that goddamn dialog box I just lost a lot of work...

where it is used??
al_show_native_message_box(display, "Save?", "Save before exit?", NULL, NULL, ALLEGRO_MESSAGEBOX_OK_CANCEL) == 1)

I show 14 occurrances....

what do I want??

when ESC is used to quit
- exit and save
- exit without saving
- cancel


what do I want from my dialog box

int mdw_message_box_1(char * text, char * button1)

int mdw_message_box_2(char * text, char * button1, char * button2)

show the text in a frame with the buttons below
block until dismissed

return the button that was pressed or 0 if none or dismissed
what about keypresses ?

I made a custom one for level_editor exit
it looks good

how about I make a version thing

whenever a level is saved, backup versions are created

save level 10...
- rename level 10 to old level 10
save level 10


nake msg creator not prompt for trigger box

msg edit text...

deal with the blinking cursor jumping better
what if i just blink the prev char if LF??


deal with cursor past the end better
now I can't seem to make it go past the end...


this is getting so complicated....

all I want is to highlight the cursor pos..
easy, except when the cursor position is LF
then all I want is to highlight the previous char...

at the start...
figure out if current pos is LF or NULL

set these...


cursor_actual_pos
cursor_display_pos

cursor_actual_char
cursor_display_char



what if I just did a second draw...
convert to a new string that has spaces for all printable char...
except the cursor pos...

then draw again...

if LF just move second draw x+8...

try it...


multitext breaks lines differently when I replace char with spaces...


trying new fonts to replace old built in 8x8

I'm liking Pristine by

https://damieng.com/typography/zx-origins/

These fonts are free to use in your games commercial or otherwise (email me to get permission for non-games).
A credit is nice if you have a place for that but don't sweat if you don't.
Either way, let me know about your game so I can add it to the list of real games using each font too.


I am using Pristine regular for my built in 8x8 font now...

I use 30 instead or 32 for space and things line up good...


now make it work for auto size...


it would be so nice to not have auto size....just saying....

if you go through all levels and replace all autosize, I will let you kill it...

424 msg
352 autosize....wow!!

how about an autosize button....

how about showing height and width....
then set manual to that and see how it looks...


I want to do it automatically...

1-100 319 242

if autosize, set area and not autosize...


I have changed all pmsg to manual size and gone throough levels up to 89

still to do...

remove button to set autosize mode
creator to make manual size

remove code taht deals with that

fix editor in other mode...

also now no messages are anything other than stationary

creator is fixed...


marking the cursor position in edit text has been really hard

the way I want to do it now is not change the text string at all...
every time I go down that path the multiline string splits at different places

the way I did it now it just to go back to the previous char and print my cursor there...


needs more testing....look slike I got it...

when loading pxw from item[i][11] I dec 8 every time...
pxw -=8; // adjust width by -8

use glt to modify all then remove the dec...

int pxw = 0, pyh = 0;
get_int_3216(item[y][11], pxw, pyh);
pxw -=8; // adjust width by -8
set_int_3216(item[y][11], pxw, pyh);



I would really like to get rid of 126 for LF and just use 10

lets do it...

for (int y=0; y<500; y++)
   if (item[y][0] == 10) // pmsg
   {
      count0++;


      int len = strlen(pmsgtext[y]);
      if (len > 0)
      {
         for (int j=0; j<len; j++)
            if (pmsgtext[y][j] == 126) pmsgtext[y][j] = 10;
      }
   }



I think it is done!!!




cleaning up so much to do with pmsg...

its getting late

tomorrow

show xywh while adjusting
put char count and current char off frame...

use flags for some different frame options, including none

cycle through:
none
1
2
4
12


better controls on edit text
done

credits for new font...done

fix the door invisible causing crashes
when door is invisible, do not play sound...

make text pos show in text button instead of frame...
but it needs to show when editting...put it below msg...done

finish trigger

finish lifts


make warps send player back to specfic loaction in level 1...

I will need a global_variable...

int warp_level_location

if zero start level just like normal
otherwise find warp that matches that value and warp to there..
after starting level for any reason set to zero..


void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      if (play_level > 1) warp_level_location = play_level;

      players[p].paused = 5;
      level_done_mode = 9;
      next_level = item[i][8];
      game_event(4, 0, 0, p, i, 0, 0);
   }
}


void set_player_start_pos(int p, int cont)
{
   int found = 0;
   if (warp_level_location)
   {
      for (int i=0; i<500; i++)
         if (item[i][0] == 12)
         {
            if (item[i][8] == warp_level_location)
            {
               found = 1;
               //printf("Found warp level location %d\n", warp_level_location);
               players[p].PX = itemf[i][0];
               players[p].PY = itemf[i][1] + al_itofix(20);
            }
         }
      warp_level_location = 0;
   }

   if (found == 0)
   {

      int ns = 0; // count number of starts
      int s[8] = {0};
      for (int i=0; i<500; i++)
         if (item[i][0] == 5)


this seems to work....


trigger and block manip are done

still to do...

block damage
orb

done...

clean up levels and level 1


am i really done?

can I move on and release and make some videos?



make a new lift mode..prox reset without stopping the moving when player is absent...done

bug... lift prox run and reset after player dies

when lift resets, due to prox expiring and player is dead, but in location to ride lift..

when player dies, paused should be not zero..
when detecting if player is riding lift, it should ignore pauswed players.
so why then?

actually it only happens when in prox reset only mode and when the first step is a prox step
the prox step check did not have the paused check so I added it and all is good now...



make bullets accurately shoot moving player when on lift or riding rocket
can I do this by just setting xinc and yinc???
riding rocket already works
fixed for riding lifts..

make it when field adds health to immediately disallow > 100...done


remove some weaker levels....done

show zoom in and out very early....done..


now go through levels 1 by one for the final time....

also record demos...


no more changes allowed!!

where do I set max level in level chooser? found it...

lift name and player died to use old fonts...
done for lift name...

went down a rabbit hole for font...

void rtextout_centre(ALLEGRO_BITMAP *dbmp, char *txt1, int x, int y, int col, float scale, int rot, float op)

is called many times...

removed rot from show cursor pos only called by edit server name and edit lift name

done...


try erasing cfg and starting new...


script win release....

compile win_static_release

I think I have made a windows release on github

now for a linux version...





did both releases 7.24..no more changes!!

testing netgame and linux..

ubuntu 22.04 has some issues with DNS
it has errors with local DNS stuff
and local pinging IP's

works good as server, but cannot get to work as client

mi3  192.168.1.154 (win7)
dred 192.168.1.111 (u22) test
feck 192.168.1.106 (u22) dev

mi3 can ping dred and 111



local dns is still bad on all ubuntu
but I can ping now...

just not from and u to mi3
but u to a different windows system is good..

used 4230i as server and lin clients can connect but not with hostname

i don't know what the hell is going on






I am going to take some notes on how the linux version is compiled and the systems I try to run it on...


put multiple versions on github

the one I have now was compiled with:
ubuntu 22.04 (lsb_release -a)
gcc 11.2.0 (gcc -v)
kernel version 5.15.0-52 (uname -r)
allegro 5.2.9

first of all do a version b

u22
gcc 10.3
kv 5.15.0-52
a 5.2.9


then a version c
u20
gcc 10
a 5.2.9
































ubuntu 22.04 did not need any libraries, it just worked out of the box


MX21-64 live fails with missing:
also
MX21.2.1

demo@mx1:~/Downloads/purple_martians__linux
$ ./pm
./pm: error while loading shared libraries: libOpenGL.so.0: cannot open shared object file: No such file or directory
demo@mx1:~/Downloads/purple_martians__linux
$ ./pml
./pm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.33' not found (required by ./pm)
./pm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./pm)
./pm: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.35' not found (required by ./linux_libs/liballegro_monolith.so.5.2)
./pm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.33' not found (required by ./linux_libs/liballegro_monolith.so.5.2)
./pm: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by ./linux_libs/liballegro_monolith.so.5.2)
demo@mx1:~/Downloads/purple_martians__linux
$

root@mx1:/lib/x86_64-linux-gnu# ls -l libc.*
-rw-r--r-- 1 root root 5211330 Oct  2  2021 libc.a
-rw-r--r-- 1 root root     283 Oct  2  2021 libc.so
lrwxrwxrwx 1 root root      12 Oct  2  2021 libc.so.6 -> libc-2.31.so
root@mx1:/lib/x86_64-linux-gnu#



Manjaro 21.2.4 live
works right out of the box
no libs needed
netgame works as client and server

Fedora 35 live
./pm: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.35' not found (required by ./linux_libs/liballegro_monolith.so.5.2)


Linux Mint 20.3
same errors as mx21

ubuntu 20.04
same errors...



I'm going to try compiling a version with ubuntu 20.04

or maybe a version with gcc 10...










mi3 server died at 3051 seconds with 6 clients

later it died at 3362 with 7 clients...wonder what is timing out....






testing...

u22 dev machine
all 3 work...

mx21-2.1
only c works, but crashes hard with seg fault when starting level editor

manjaro
all 3 work but all seg fault for level editor

linux mint
only c works, but crashes hard with seg fault when starting level editor

fedora
only c works, but crashes hard with seg fault when starting level editor



fixed a bug when loading mW.pm

I checked for NULL before reading from it but not before trying to close it.
it was fine in windows, but segfaulted in linux....

also check out the funny colors for sliders when dim...does not do it now....

I will need to redo all the releases

new versions:

7.24.0_win
7.24.0_lin

skip the u22 one...





even more tests with 7.24.0
I only included levels 1-99 ???

u22 dev machine
runs without libraries
level editor good.
netgame server good
netgame client good (but no dns, had to use IP)

Linux Mint 20.3
needs library script
level editor good
netgame server good
netgame client good (but no dns, had to use IP)

Fedora 35 live
needs library script
level editor good
netgame server good
netgame client good (dns works!)

MX-21
needs library script
level editor good
netgame server good
netgame client good (dns works!)
funny colors on sliders

Manjaro 21.2.4 live
needs library script
level editor good
netgame server good
netgame client good (dns works!)
funny colors on sliders (sometimes yes, sometimes no)




When I redo this the last time...lol
- include all levels (well 1-199...)
- when starting client game waiting for sync...adjust the screen pos to where the player will start, not top left...  done on client and server, because server will sync to client...
- color of dim buttons...draw frame probably goes past 255 index
- linux libs, use the build target that builds them into the executable see if we can get a few distros that don't need the library script


release again...

now...

when running as client saw this:
Got reply from server
Error: no start found.

I think the client is trying to set start position, but there might not be a level loaded yet....

One more thing to fix...

Also fix the text for mW.pm.. make it say error loading -- creating new..just like pm.cfg....

I am very happy with how this is going....

Who cares about ubuntu lan dns???






Manjaro 21.2.4 live
does not need library script
level editor good
netgame server good
netgame client good (dns works!)

MX-21.2.1
does not need library script
level editor good
netgame server good
netgame client good (dns works!)

Fedora 35 live
does not need library script
level editor good
netgame server good
netgame client good (dns works!)

ubuntu 20.04 live
needs library script
level editor good
netgame server good
netgame client good (no dns)

ubuntu 22.04 live
does not need library script
level editor good
netgame server good
netgame client good (no dns)

Linux Mint 20.3
needs library script
level editor good
netgame server good
netgame client good (no dns)



ubuntu 20.04
ubuntu 22.04
Linux Mint 20.3
Manjaro 21.2.4 live
MX-21
Fedora 35





20221020  one more bug...

rectangular fields draw in linux are missing the bottom line
they look good in level editor, but not when game is running.
see cloner, trigger, etc..fixed...

Help file...

redo section about tested systems

redo bonus to remove free man

add jumpworm to enemy list

add orb to item list
done...

now do one more release....





----

I have a bug...

when running demo for level 11 about 445 seconds in it crashes hard and the program exits...

it has 4172 game moves

the last frame it has is 23,293

23293/40 = 582s

453 * 40 = 18120

pm -f demo\level_done_20221016-170102-lev11.gm

exactly frame 18123...

no game move for that exact frame

18103
5
0
33
18139
5
0
32


it dies in draw_items....

item 78 type 2 bonus... a created bonus...

frame:18122
item:[73] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [799] [0]
item:[74] [2 ] [929 ] [1] [-1] [1152] [340 ] [1] [3] [0] [0] [0] [0] [0] [0] [439] [0]
item:[75] [2 ] [929 ] [1] [-1] [1160] [340 ] [1] [3] [0] [0] [0] [0] [0] [0] [443] [0]
item:[76] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [799] [0]
item:[77] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [799] [0]
frame:18123
item:[73] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [798] [0]
item:[74] [2 ] [929 ] [1] [-1] [1152] [340 ] [1] [3] [0] [0] [0] [0] [0] [0] [438] [0]
item:[75] [2 ] [929 ] [1] [-1] [1160] [340 ] [1] [3] [0] [0] [0] [0] [0] [0] [442] [0]
item:[76] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [798] [0]
item:[77] [2 ] [10497] [1] [-1] [1080] [240 ] [1] [900] [0] [0] [0] [0] [0] [0] [798] [0]
item:[78] [2 ] [147951074] [1] [-1] [1080] [240 ] [1] [41610987] [0] [0] [0] [0] [0] [0] [799] [0]

what enemy died that created that?

it was the cannon...enemy 38

it gets 1 from ei[24] flower shape
24 is set to 9 just like all the other cannons

it was in the code when an enemy is killed and converted to death animation
unintialized value for health bonus multiplier

check for other crashes...

level 8 f 11505
11627 is actual last move
cant reproduce

im going to run in speedtest mode to make sure every frame is drawn
that causes some weirdness with press any key at level done

crashes!!
level 95 frame 1023
it has block walkers
pm -f demo\level_done_20221018-074236-lev95.gm

it happens in move enemies
game_event(60);

// this is wrong....
game_event(60, 0, 0, e, Ei[e][26], 0, 0);


this is how game_event is called for other enemies
if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);

now that I have fixed those 2 bugs, I ran demo mode for > 11 passes with no crashes

now I'm really ready for a new release...

20221022 8:34 PM

played some massively long demo sessions and the game never crashed

however there were some differences in linux...some levels did not play the same

level 11 40% done player dies in lin
level 17 short ends differently
level 17 long out of sync about 70%
level 32 out of sync around 75%

update the web docs...at least the version and supported systems...

tried it on an xp system and got 'pm.exe is not a valid Win32 application'
oh well, i'm not going to troubleshoot any further
maybe if I had a winxp 64bit system?

what version of gcc am I using in code::blocks

gcc -v
8.3.0 (Strawberry Perl???)
8.1.0 (codeblocks mingw)


make a new youtube account... see if I can get mweiss0002...or just keep the same one???


ran into a weird bug on mr5
changed desktop to 1920 from 3840
ran OBS
kept getting jumpworms tile underneath corners of rounded rainbow tiles
F12 did not fix, sometime it would, sometimes it was good until F12
sometimes resizing window fixed...weird
changing back to 3840 and stopping OBS did not do anything...
tried on mi3 and cannot reproduce...

I am sure that I clear the all the bitmaps before using...
maybe I don't...

added 4 x al_clear_to_color(al_map_rgba(0,0,0,0));

void rebuild_bitmaps(void)
{
   //printf("rebuild bitmaps\n");

   // rebuild main tiles
   al_set_target_bitmap(tilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_tilemap, 0, 0, 0);

   // rebuild block tiles
   al_set_target_bitmap(btilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_btilemap, 0, 0, 0);

   // rebuild player tiles
   al_set_target_bitmap(ptilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_ptilemap, 0, 0, 0);

   // rebuild door tiles
   al_set_target_bitmap(dtilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_dtilemap, 0, 0, 0);


that seemed to fix it....


20221024

I have a few more changes to make....

fix diplayed text in pmhelp when typing 2 digit section number..done

make it capable to display on second monitor
add a config value...done

now I should be able to do obs on second monitor...



I found 3 more bugs that I want fixed

new level leaves menu artifacts on level buffer..fixed

save and guit from menu still calls native file chooser dialog

pop up menu
save calls prompt
save and quit calls prompt then calls my dialog
make save do blind save....done
make save and quit just call my dialog...done

menu bar
save blind saves
save as calls prompt
this is good...

load and save demo default directories
look at save_gm and load_gm...can't seem to reproduce this bug....

block floodfill from zfs does not work as intended....
always fills with purple pipes....
zfs_do_brf(gx, gy, mW[1].draw_item_num);
removed a lot of special block corner drawing code...
now it just does a straight replace
any fancy stuff like that can be done in tile helper
fixed

zfs clear selection leaves artifacts??
yes it draws the menu on the level buffer instead of the screen buffer...
added      al_set_target_backbuffer(display);
after call to zfs_do_clear();
for both clear and move...
fixed



2022119 I have found yet another bug....
get a spring from selection window
place in level
copy from level
place another copy on level
2nd paste will not have correct location

cannot reproduce on source version


on dl version....
sproingy at location 10,11 with sproinginess of 64
copy, first paste good, second paste wrong location

first paste at 13,11 good
second paste at 15, 11 was placed at 12,11

first paste at 18,11 good
second paste at 24, 11 was placed at 16,11


it is because its the first item?

yes, I can reproduce if the switch is item 0
also works with switch...
why??

find empty item moves shit around
the item we are copying from might have moved...
no, that's not it....
not exactly sure why, but changing get_empty_item() to not specify type fixes the bug
this skips the find empty, set type, sort, then find where it was sorted to, then return empty...
and just finds the first empty...




20221120 bug for initial direction of cannon...
how does it work?
if ((Ei[e][8]) && (Ei[e][7] > Ei[e][8])) // seek
{
   Ei[e][7] = 0;
   seek_set_xyinc(e);
}
so by default how are new cannon set from PDE
7 is set to 0... all good here...
what about xinc, yinc....they are all set to 1.63, 1.68
lets make them set to the full down (y speed)
al_fixed speed = Efi[EN][5];                  // speed
normal = 3
faster = 5
do the same with the 4 bouncers
done....

when changing speed in group edit, the seek speed changes, but the xinc and yinc do not change until a seek is called....
it does when changing with slider....
if (bn == 22) scale_bouncer_and_cannon_speed(num);

i think I have that fixed too...
if ((gvt == 4) && (gvn == 5) && ((Ei[num][0] == 4) || (Ei[num][0] == 6))) scale_bouncer_and_cannon_speed(num); // cannon and bouncer speed only
in 3 places, set all to min, min to max, random...

do another version....

also removed some build targets
now only have windows_static and linux

removed e_group_edit.cpp
was not actually compiled in project
the real file is e_group_edit_windows.cpp



20221128

documenting netgame...

how come server does not log when it receives stak....

maybe it does, but the viewer does not display it...


type 27
frame 532

never mind...it does....


made some very minor changes...need to commit them...don't need to bother with a release


20221203

what is up with the bandwidth graphs?
too many graph lines....server has >8 lines??
the one that acted bad had 7 clients, 932k lines 20k frames

did a test with 1 client and looks good
did a test with 7 clients, 40k lines 2k frames...good

how mnay log lines does p array waste? 9 per frame i believe
9 x 2000 = 18000, almost half the lines

log lines are read into an array that can only hold 1 million lines

what happens if the log file is larger than that??

I want it to fail gracefully, not overrun arrays...

this is what we currently have:
char log_msg[100000000]; // for logging
int log_msg_pos = 0;
char log_lines[1000000][100]; // for log file viewer
int log_lines_int[1000000][3]; // for log file viewer


100M char in log_msg
1M in log_line_int
1M x 100 in log_lines[100]


make some defines for max limits

respect them....

in pm.h

#define NUM_LOG_CHAR  1000000000
#define NUM_LOG_LINES 1000000
extern char log_msg[NUM_LOG_CHAR]; // for logging
extern int log_msg_pos;
extern char log_lines[NUM_LOG_LINES][100]; // for log file viewer
extern int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer


in main

char log_msg[NUM_LOG_CHAR]; // for logging
int log_msg_pos = 0;
char log_lines[NUM_LOG_LINES][100]; // for log file viewer
int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer

reading file in log file viewer

   filepntr=fopen(fname,"r");
   while(ch != EOF)
   {
      int loop = 0;
      ch = fgetc(filepntr);
      while((ch != '\n') && (ch != EOF))
      {
         if (ch != 13)
         {
            buff[loop] = ch;
            loop++;
         }
         ch = fgetc(filepntr);
      }
      buff[loop] = 0;
      strcpy (log_lines[num_lines], buff);
      num_lines++;

      if (num_lines >= NUM_LOG_LINES)
      {
         ch = EOF;
         printf("log file exceeded %d lines\n", num_lines);
      }
      //printf("num_lines:%d\n", num_lines);
   }
   fclose(filepntr);
   num_lines--;




   set to a smaller number and see how it works


#define NUM_LOG_LINES 10000

that seems to work...

what about when generating log files?
it looks like all log generation passes through this one function:

void add_log_entry2(int type, int player, const char *txt)
{
   char tmsg[200];
   sprintf(tmsg, "[%2d][%d][%d]%s", type, player, mwPS.frame_num, txt);
   // strcat(log_msg, tmsg);
   memcpy(log_msg + log_msg_pos, tmsg, strlen(tmsg));
   log_msg_pos += strlen(tmsg);
   log_msg[log_msg_pos+1] = 0; // NULL terminate

   //sprintf(log_msg, "%s", txt);
   //printf("%s", tmsg);
}


void add_log_entry2(int type, int player, const char *txt)
{
   char tmsg[200];
   sprintf(tmsg, "[%2d][%d][%d]%s", type, player, mwPS.frame_num, txt);
   // strcat(log_msg, tmsg);

   if ((log_msg_pos + strlen(tmsg) >= NUM_LOG_CHAR)
   {
      printf("log array full\n");
   }
   else
   {
      memcpy(log_msg + log_msg_pos, tmsg, strlen(tmsg));
      log_msg_pos += strlen(tmsg);
      log_msg[log_msg_pos+1] = 0; // NULL terminate
      //sprintf(log_msg, "%s", txt);
      //printf("%s", tmsg);
   }
}


try this with a much smaller value

that seems to work...
now change back to original

when i tried 1G char program will not run!!
100M good...

should I compile and make a new version?

not yet....

try a long one like 10 min...



ran a long one...lev 11 8 players, fake key...

clients time 3666 frame 146,640
server time 7550, still running...
log array full
see if we can find out when it quit...

log file exceeded 1,000,000 lines
last frame 33,124
increased lines to 2,000,000 and loaded
size on disk...101,416,960 bytes ??? should be less that 100,000,000...

even with 1.5M entries last frame was 46670, way too short

try this again and remove some logging

parr and sdak off
lev 15 8p fk
log array full at before 1900 seconds
ending frame 64013 / 40 = 1600s = 26 min
size on disk 101,531,648
wtf why is parr stil getting logged?
parr 576K
cdat 439
sdat 447


check out this massive bug!!!

void server_control() // this is the main server loop to process packet send and receive
{
   log_player_array2();

   if (L_LOGGING_NETPLAY_PLAYER_ARRAY)

   if (mwPS.frame_num == 0) reset_states(); // for stdf
   ServerListen();      // listen for new client connections
   int who;


try again with parr off for real
#define NUM_LOG_CHAR  500000000
#define NUM_LOG_LINES 5000000

20221203-195145-[11][m36].txt

came back 12300 on server
one client p1 with windows error pm.exe has stopped working time 1187 (frame 47480)
all other clients lost server connection 4073s x 40 = 162,920f 67minutes
server log 162827 server starts dropping clients based on last sdak rx > 100
it looks like the game_moves_array is full...
server is sending sdats to clients with start of 999999
so there we have it, the limit...

lets go over the theory again
1,000,000 game moves
divided by 8 players
divided by 40 fps
3125 seconds
divided by 60
52 minutes

this is the worst case with all 8 players pressing keys 40 times each second
in reality with human players, this should be much less

can I do something to make this fail gracefully?

on the server, if approaching 1M end the game? go to the next level?
anything but crashing without any explanation












nothing in the server log about why p1 stopped working sometime around frame 47480
looked into it in more detail...
last rx cdat from p1 was frame 47490
cdats were arriving in pairs with sync of 0 and 1
then at frame 4759 server dropped p1 (last sdak rx > 100)


why do graphs not work?
what packets are required for each...


sync graph
max of 10,000 points
uses log lines:
type 10 (player becomes active, inactive)
type 39 sdak to get server sync and fps_chase

why does nothing show before player comes active?


bandwidth graph
max of 10,000 points
uses log lines:
type [23][0][1360]bandwidth (B/s) TX cur:[ 1878] max:[ 5060] RX cur:[  480] max:[  514]
these packets come once per second for each player
10000 / 8 = 1250s / 60 = 20.8 min

what if I increase x10 I would get 208 min or 3.5 hours
this is a temp variable that only has scope when graph is viewed...do it

end_pc is passed to the graphs, but it would be better if the graphs calculated it
there may be less range in the graph set

do it for bandwidth...done

I have increased bandwidth to 100,000 points
and it seems to work


pm.exe uses 67M then when bw graph is started it goes to 69M


to do...


make server quit gracefully when game_moves_entry reaches 1,000,000

make a scroll and zoom bar for graphs

make so that a drag click on the graph sets the x zoom to that area
have that working


I want to make the redraw a seperate function so that I can call it when sliding..

first try drawing it every frame to see what performance hit i take...

its not bad, but I am on a very fast computer

broke redraw out and made it a function
same with autoscale

make home key set gs_pc = 0 and autoscale





I am fixing variable names so they more accurately describe what they do...

int end_fn; // data set last frame number

int g_stf; // graph start frame
int g_rng; // graph frame range

float x_scale;
float y_scale;


that looks a lot better

next...

mouse_z zoom in and out...

that was easy to do, but now I want to make it so that it zooms in and out bu what is under the mouse stays the same..

- get x value under mouse
- change x_scale
- adjust g_stf to make same position under mouse...

that was quite easy and it looks amazing!!

check limits....



bug when drawing zoom area very small y_scale disappears, does not happen with any other zoom in, just drag....
fixed divsion by zero error...




how about drag slide?

we already have mouse click for drawing an area to zomm in on....

maybe that could be change to shift drag

and normal drag will scroll

that has all been done and looks great...


do i really need to go to the effort of implementing a scroll bar?

not at this time...

I know it would look great, but it would take a lot of time...

convert the other graph now....

first of all make a test log....

its has all been converted....

I would like to make the y values scale to fit the data better, this one is always hard coded....

first, clip the data so it can't draw on other graphs

I am having one hell of a time figuring out the graph coordinates....
fy is the base, the lowest part
fh must be how high up it goes...


try to autoscale g2...
g2 and g1 done
frame g2 and g1 and g3 done
remove some gridlines

looking really good....

why do clients even have to have the level the server asks for?
what is not synced?  lift steps...

did a long 8 player netgame, till the game_moves_array got to 999,990 and exited gracefully...


log
20221204-204923-[11][m36].txt 179.896k

[10][0][132891]+--------------------------------------------------------------------------+
[22][0][132891]+--------------------------------------------------------------------------+
[22][0][132891]|                        Server (m36) ending stats                         |
[22][0][132891]+--------------------------------------------------------------------------+
[22][0][132891]+--------------------------------------------------------------------------+
[22][0][132891]|        level.....................[11]                                    |
[22][0][132891]|        total frames..............[132891]                                |
[22][0][132891]|        total moves...............[999980]                                |
[22][0][132891]|        total time (seconds)......[3322]                                  |
[22][0][132891]|        total time (minutes)......[55]                                    |
[22][0][132891]|        server frames skipped.. ..[14]                                    |
[22][0][132891]|        total tx bytes............[81109237]                              |
[22][0][132891]|        max tx bytes per frame....[5382]                                  |
[22][0][132891]|        avg tx bytes per frame....[610]                                   |
[22][0][132891]|        max rx bytes per second...[32014]                                 |
[22][0][132891]|        avg tx bytes per sec......[-7905]                                 |
[22][0][132891]|        total tx packets..........[951603]                                |
[22][0][132891]|        max tx packets per frame..[34]                                    |
[22][0][132891]|        max tx packets per second.[335]                                   |
[22][0][132891]|        total rx bytes............[32417689]                              |
[22][0][132891]|        max rx bytes per frame....[880]                                   |
[22][0][132891]|        avg rx bytes per frame....[243]                                   |
[22][0][132891]|        max rx bytes per second...[10530]                                 |
[22][0][132891]|        avg rx bytes per sec......[9757]                                  |
[22][0][132891]|        total rx packets..........[1856379]                               |
[22][0][132891]|        max rx packets per frame..[51]                                    |
[22][0][132891]|        max rx packets per second.[603]                                   |
















gm
game_exit_20221204-204922-lev11.gm 16,627k

when viewing, need to increase lines for sync

bw 54 mim
sy 1 min

changed from   10000
int max_data = 100000;
now 5.5 min

int max_data = 1000000;
crash...

the log has 2.8 million lines
923,000 sdaks

int max_data = 500000;
crash...

int max_data = 200000;
crash...

leave it at 100000...
at least it doesnt crash...




having a hard time playing back
game_exit_20221204-204922-lev11.gm
it has almost 1,000,000 game moves
can't do more than 80-90 fps or it freezes the display...

there must be some searching the whole array...

void set_controls_from_game_move(int p)
{
   // this will search back from entry position until it finds the first 'move' type
   // entry that matches the player and is not in the future
   int found = 0;
   for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
      if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
         if (game_moves[g][0] <= mwPS.frame_num) // check to make sure its not in the future
         {
            set_controls_from_comp_move(g);
            game_move_current_pos = g; // for savegame running only
            g = 0; // break out of loop
            found = 1;
         }
   if (!found) clear_controls(p); // if no match found (no move entry for player in entire game move array)


   // in run game mode and past the end of the file
   if ((players[p].control_method == 1) && (mwPS.frame_num > demo_mode_last_pc)) clear_controls(p);


I need to rethink this....


try a netgame overnight, but no fakekey
24000 seconds / 3600 = 6.667 hours
24000 x 40 = 960,000 frames

game_moves is 7498, the same as when I started it

p1 died at 7425 seconds / 60 = 123m /60 = 2.0h
7425 x 40 = 297000 f

what can i see in the log


how do I move large amounts in the log??

L - changes between line mode and frame mode


    up -1
  pgup -100
s pgup -1000
c pgup -10000

same with down


write new help for graphs
click and drag scrolls the graph
shift click and drag zooms to the selected x region
mouse wheel zooms in and out centered on mouse position
F10 resets graph x axis
the other keys are not that usefull any more, now that I have these mouse controls
maybe make a help screen page

no labels on sync when zoomed in..fixed


I have done doc and clean up for graphs


I was starting doc for log viewer and realized I wanted a scroll bar for the position in the log...

make it temp to start

x height is screen height

correspond to how many lines

also how many lines can be shown on the screen..

do I even need line number mode and frame number mode with this new scroll bar?

lets lose frame mode...That simplified things a lot...


now lets line up the scroll bar better....

what is xpos of legend text?


hard coded at 760....

lets set it dynamically after drawing lines

done...

show loading when loading a huge log file...done

next...

document lfv

add button for help, or at least a text label that says press ? for help

add help

I think log file viewer is done

so am I ready to make a new release?

store some log files elsewhere...



I made a release and uploaded it, but...it does not work on clients

travelmate 4230...


all I can think of is that I increased the size of the log file array...

with task manager
pm normal game takes 10% cpu and 1,421 MB memory and 10% gpu....on m36!!

that is a lot of resources


tried an earlier version (last realease) and got same for cpu and gpu, but only 600MB for mem


when i tried this on travelmate (win 7) it was 50%cpu and 136M memory



look into the memory thing...

currently
#define NUM_LOG_CHAR  500000000
#define NUM_LOG_LINES 5000000

old




extern char log_msg[100000000]; // for logging
extern int log_msg_pos;
extern char log_lines[1000000][100]; // for log file viewer
extern int log_lines_int[1000000][3]; // for log file viewer
extern int log_timer;


500000000
100000000

5000000
1000000

what if I revert and try again....

make pm_test3

that seems to fix it....

make a new release and version the goddamn thing 7.24.1




its still doing it...wtf

what else did I change?

that shit in get new game move from game array....

yes, i found an obvious bug there...


I want to redo that whole system of searching through the game moves array

I do it for every player seperately??

I want to narrow the search range

I want to integrate the system moves search into it as well...


can I assume that the game moves array is sorted by frame number?

maybe not 100% but it should be no more than a few frames out...


void proc_game_move(void)
called from proc_controllers() when game_in_progress

also called from same place is:
proc_player_input()
which for all players calls input based on control method...
but then calls this for all players:

         if (level_done_mode == 0)
         {
            set_controls_from_game_move(p); // common for all players
         }


the way it is now:
do all system moves for gme
do player input
set player controls from gme


the way I want to do it

do player input
search gme once for all system and player crap

test that shit works first before changing all of this...
seems to have fixed the bug

I should actually make this the official 7.24.1 release
because the old one doesnt work...
done

now start chopping away at the control gme thing...

do one search through game_move_array

search method

start at the end: game_move_entry_pos
except if in rungame, then start at game_move_current_pos +100

search to game_move_entry_pos -100

except in rungame then search to 0

normal
game_move_entry_pos (should be end of array and only a few ahead of current pos)
game_move_entry_pos -100

rungame
game_move_current_pos+100 (could be many moves before end
game_move_current_pos-100


how about players keep track of last gme array index they used to set their controls
why?
so that we don't have to search back past that
is that actually as issue?

what problem am I trying to solve?

when searching backward for gme to set controls for a player, could do a lot of searching
so fucking what??

I am also trying to make the way I do this less complicated, not more


2 variables for each player (not synced)

index of last gme used to set controls

-1 if no gme matches player in entire array

last frame that gme searched from

1M x 4 ints x 4bytes per int == 16M


pm right now takes 600 to 617M on win10
when drop gma from 1M to 100K drops to 382 to 386
now I can't make it take 600 again
it take 382 no matter what: 1M 10M 100K for gme

10M  383.1
1M   381.9
100K 382.4


what are my most expensive memory hogs?


STATES 100K x 2 for client and 16 for server
1.8M


what about bitmaps??

try resmon on win10
commit working set
1300M
1076M when removed 200M in logging...


OK nevermind
I am using way too much memory, like 1.3G





20221211

I have a huge new plan for netgame

I hate the 75ms control lag delay....

I want to remove the whole game_moves_sync thing

clients just send their moves to the server then execute them locally, immediately

stdf is how the moves get sync'd back, not the actual moves, just the result of the moves..

stdf happens very fast anyway
I get an ack either the next frame or at most 2 frames

where do I control stdf freq? in pm.cfg set to 5
how fast can I make it?
2P game
5 3400 140
4 4400 150
3 5500 180

lets go with 4 for now
now I do this cyclic thing where I only send to one client when stdf_freq comes due
that would mean a larger delay as I get more clients

frame 0 1 6
frame 1 2 6
frame 2 3 7
frame 3 4

anyway, this is good enough to test the concept

set the client to put moves directly in the array, no frame lead...



I have run into a problem...the clients moves arrive too late on the server


do I need to rethink this entire approach?


I have the client running one frame behind the server.
what would happen if I made the client run ahead of the server?

then the states the server sends would be too old, by the time they got to the client

Its a chicken and egg thing...before I go any further, I need to figure this out...


what if on the server, it got these late cdats, then rewound and replayed from the last known ack



server has last acked state
collects info from clients
run simulation from last acked acked state

where should server and client run with respect to each other? exact time, one lagging?


on each client:
keep track on local control changes since last state
every frame run simulation fro last state with new control inputs
copy that state to actual state

when a new state arrives, only apply control changes since then


on the server:
collect input from each client and store

for each client,
keep track of last state acked
apply all control changes to that
send to client

I will still need the game_moves_array on the server

This will make somthing already quite complicated, even more complicated


Server:
take last acked state for a specific client and put it somewhere it can be manipulated
run the game simulation from that state to the current state
send that state to the client

where can I do this?

probably best to do it in the main game engine

it would be just like rewinding then replaying

- put saved state in game vars
- set frame number to saved state frame
- run without drawing to current
- make a dif from saved state and send to client

repeat for all clients


Client:
put local player input in local array, and send to server

play local game and use only input from last acked state

play local game as normal

when a new state arrives, rewind to that state and play back any local changes since then
dont just set the new state, or local changes since then will be lost

this way, when a new state arrives, it will not matter if it is late...
the client will rewind and play from that state, adding new moves the client has made since then

Does the client needs to keep anymore states? It currently only has one old one.
I don't think that needs to change.

When it gets a new one, all keypresses before that state do not matter
even if the state bas gets corrupted and new one from zero is sent, it should not matter..

what changes need to be made on client?

do not add anything to gma from sdats
add local moves to local gma directly and send cdat as normal
still receive sdats for sync purpose (later I may do away with these and just use stdf)

when an stdf is received and a complete dif is decompressed:
check to see if the base matches and we can apply it (the destination frame will probably aleady have passed)
apply it to the current game state
rewind to that state
play back to current state (but this time any new moves also get executed)

int client_process_stdf_packet(void)
this does not need to be changed, all it does it rx packets and decompress state



I think I have the client done...

now for server...

I don't think I need to save current state anywhere, after rewind and replay, it will be where it should be

remove the part were server sends sdats, except for sync...done

fix it so that server adds cdats, even if late..done
but not if so late they are before last ack state...not done yet...


when it is time to send stdf for a client:

load last ack state for that client into game
rewind and replay (this is necessary to get skipped game moves)
make dif and send to client




tried running...


client has error setting base state for initial join

client gets as far as starting chase and locking
server complains about not having the ackd state from client...

client was acking to frame num before replaying...changed order...


client starts chase and lock, but server sends only one sdat for sync on same frame as join info...
client does not receive any sdats....


lets drill down and see where client locks..

turn on debug by default....

could it be that gma is still being used to set players active?

interesting...logged player array on server and p0 was active and mode 3 until join, then 0 and 0


find out where on server, is the player array reset...
it is after the server replies to the join request

I think I might have an idea...

the base state is set to zero? should it be set to the level when it is first loaded?
am I going back to this state, (which is zero, then trying to play from there?)
cause that will not work!
on the server, keep a copy of the state immediately after loading level??
clients too?

yes...

// copy of the state immediately before starting frame 0
char level_base_state[STATE_SIZE];
done.


well, now the server does not reset itself to 0...making progress...
now client does not get its control method updated to 2...
figure that out....

it is set on server whemn replying with sjon....
then what happens...
server sends state, but it is based on zero, is it not??
that will erase player shit that was not set when state was made....
here is what is needed:
-load level base state
-modify player
-save new level base state
-fast forward to current frame

or:
enter a new type of game_move_entry that specifies when a client starts the join process

I am a little confused here, am I going to have to rewind and replay the game from frame 0 very often??
I hope not, with a lost base just send with a fake base of zero.

moving on...

make a new game_state_move
1 is player state and it is overloaded already with active, color, quit reason....

1 - player state
5 - reg game move
6 - level done

lets make
3 - client started chase mode, also add color here
do this on server

I can get the client to join!!

on the client, server player is 0 0

could it be that the client is fighting the server, trying to set player shit from gma??



could it be that client and server have different cm for each player?
int players[p].control_method;

0 = local player in single player mode
1 = file play (run demo game from file)
2 = in netgame, any non-local player (client players on server, and server and other clients on client)
3 = in netgame, local server player on server
4 = in netgame, local client player on client
99 = in netgame, used client in current level (to prevent re-use in same level)

control_method is synced...wtf!!

on client, fix this to change 2 to 4...
better!!!


server sends stdf, but stak always one less

example

stdf 0-365
stak 364

from the start...
server send stdf

OK it looks like that is fixed


next, why do client moves not go to server?
i dont see any cdats in client or server logs..

control_method on client should be 4 not 2...

now its looking a lot better...


why are player shapes on client all messed up??

is it something that did not get synced?

why is client color 18??
it is 9 until it becomes active

server 8 client 9
server 7 client 16?

I think the base state is using predefined colors
when I choose 8 or 7 or 6 for server, the client shows 8
there is a game move at 0 for server color and active....
where does it go wrong??

color numbers are correct on server...why are they not synced to client??
maybe the base is different...

all 8p on server are 8
all 8p on client are 1

when i change server to color 7, all are 7

how can i fix this??

make all 0 clients

I'm having a hard time finding where color is initialized....

i think I have it fixed by doing this:

   if ((ima_client) || (ima_server))
   {
      for (int p=0; p<NUM_PLAYERS; p++) players[p].color = 0;
   }

   if ((ima_client) || (ima_server))
   {
      game_vars_to_state(level_base_state);
   }


That seems to work as intended:

choose server color and start
choose client color and start

bugs...
when client is waiting to sync, his color is zero
when client quits, he becomes p0 and gets the server color



why is this bullshit so convoluted?

do I actually initialize players[].color?

find out...

in main init:



   val = al_get_config_value(cfg, "GAME", "color");
   if (!val) players[0].color = 8;
   else
   {
      players[0].color = atoi(val);
      if (players[0].color < 1) players[0].color = 1;
      if (players[0].color > 15) players[0].color = 15;
   }


this does not change colors....

   // init all players
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
   players[0].active = 1;

Changed to manually setting all colors to 0 just before loading from config for p0

maybe saving at the end of start mode is not the right place...
maybe it should be done closer to


What is the purpose of that original state?
So i can play back from zero with game moves...
I will only ever do this on the server
clients need a copy so they can decompress a dif based on it..

here is the dilemma with colors...
the base state should have all colors 0;
if the base state differs between client and server, difs will not work...

my plan is to set them all to zero on the client and server, then save_state

then on the server, when the game_moves_array is read, they will come active and get proper colors
this will get synced back to the clients



in server_init

   // create the level_base_state
   // all players colors should be zero for this base state
   // restore server color after

   int save_color = players[0].color;
   for (int p=0; p<NUM_PLAYERS; p++) players[p].color = 0;
   game_vars_to_state(level_base_state);
   players[0].color = save_color;


15 4
4 8


I am so confused why I can't get the colors right....

lets try with 2 clients....


maybe I can leave the color thing for now....


what about sync??

I removed the server_lead_frames and it still seems to run 1 frame behind...hard to tell, my resolution is only 1 frame or 25ms

why does it chase from so far back?
example...
sjon at 54, locked at 254
had to chase the whole way...

sjon at 54, locked at 254
had to chase the whole way...

when it gets first stdf it should run from there...
uncommented set frame after block until stdf...fixed

now I want to see if I can lose sdat and sdak
they are only used for sync

add their functionality to stdf and stak

frequency?

sdats
chasing 2
when used for sync only also 2
that's a lot of packets

stdf
every 4 frames...



         if (mwPS.frame_num > players1[p].server_last_sdat_sent_frame_num + players1[p].server_sdat_sync_freq)
         {
            players1[p].server_last_sdat_sent_frame_num = mwPS.frame_num;
            int start_entry = players1[p].game_move_entry_pos;

            Packet("sdat");
            PacketPut4ByteInt(mwPS.frame_num);
            PacketPut4ByteInt(start_entry);
            PacketPut1ByteInt(0);
            ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

            sprintf(msg,"tx sdat p:%d st:%d nm:%d (sync only) (sf:%d)\n", p, start_entry, 0, players1[p].server_sdat_sync_freq);
            if (L_LOGGING_NETPLAY_sdat) add_log_entry2(37, p, msg);
         }
      }


is that it? frame_number?

im sure stdf already does that

      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;

      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

it does not...unless dst mwPS.frame_num counts.....it does!!

so no changes needed there.....


   Packet("sdak"); // send acknowledgement of game moves received
   PacketPut1ByteInt(p);
   PacketPut4ByteInt(mwPS.frame_num);
   PacketPut4ByteInt(nep);
   PacketPut4ByteInt(players1[p].stdf_late);
   PacketPut4ByteInt(players1[p].frames_skipped);
   PacketPut4ByteInt((int)fps_chase);
   ClientSend(packetbuffer, packetsize);

   sprintf(msg,"tx sdak nep:[%d] stdf_late:[%d] frames skipped:%d\n", nep, players1[p].stdf_late, players1[p].frames_skipped);
   if (L_LOGGING_NETPLAY_sdak) add_log_entry2(39, p, msg);

nep is not needed
mwPS.frame_num is probably used on the server to see how far the client is lagging
stdf_late - does that even matter anymore? they will all be late
frames_skipped - is nice but hardly necessary
fps_chase - same...

do stdf's get sent when chasing? if not, they should....
it does not look like they do....fixed...

add chasing to rx stdf on client....done


remove sending of sdat on server....

server drops players...last sdak rx > 100
lets swap this with stak

rename variable to stak....



add stuff from sdak to stak on server

already has mwPS.frame_num...
but can I use it? it is ack for dif, not necessarily the clients current mwPS.frame_num.....
added mwPS.frame_num

lets add the rest of the stuff then kill sdak and sdat...done...


its really coming together...

what next to fix?


ive got a client that wont connect

client sync graph uses different packets

make stak and stdf use different packets types in log viewer
stdf = 28

make stak packets log server sync and chase fps so I can graph it
done...


needs more work on the chase and sync thing


how can I tell if client and server are really in sync or not
2 screens side by side with a moving lift??
it looks like they are lined up...
lets try some sync either way....
even if I do large amounts like +40 -40 -80 stuff still seems to sync???
game timer is off by 2s but lifts are the same??


animation sequences on clients are all messed up...


fix it so that when clients quit they go back to menu
also when server quits, clients go back to menu

I might need to pass some more info...
when a client goes inactive the only place it matters in the server's player array

the game moves array on the client is solely for local moves to be executed before being confirmed with a state, then they are never needed again


cdat's sent from client to server could be extended to do more, but I'm not sure that is needed



tell me again what happens when server loses base
server rewinds to 0 and loads that state
server fast_forwards to current frame
server sends that state to client

why am I doing it this way?
why can I not send a state based on zero and skip the whole fast forward thing?

I don't know...

I think I just had en epiphany

I need the previous states on the server because I have to rewind and replay
I don't need the previous states on the clients for rewinding, just for applying difs to


how does server normally send a state?
jump back to last frame ackd by client
replay to current frame (and apply game_move that may have been missed)
send state

so if base is lost how about:
jump back and replay a few frames
send that state based on zero

just because a client has acked a state, does not mean that the server didn't have more input after that
maybe I could keep track on the server
what frame has been rendered to (just mwPS.frame_num)
when a cdat with earlier frame is rx'd, set new var, earliest frame not rx'd



lets tackle this first...
client quit
it used to be handled by game_moves special move read on the client and executed
now the client becomes inactive on the server and this never gets passed to the client

I need a way to keep sending to the client until the client lets the server know it got the quit

or I could set the client inactive and wait for the server to drop it for not responding


one method
- when client quits, send cdat and locally quit immediately

when server initiates the drop...
set cm to 8, but still active
when client gets that, drop like above

let's try something
on server, keep syncing for used clients

this causes the server to exit without any warning a few seconds later

what happens
start with client pressing escape
cdat is sent
game move type 5 is entered

in add_game_move()

type 5 with escape does something special

         // change menu key to player state inactive special move
         game_moves[game_move_entry_pos][0] = frame + 2; // add 2 frames so server has time to sync back to client before dropping
         game_moves[game_move_entry_pos][1] = 1;     // type 1; player state
         game_moves[game_move_entry_pos][2] = data1; // player num
         game_moves[game_move_entry_pos][3] = 64;    // inactive
         game_move_entry_pos++;
         return; // to exit immediately


change this for client
don't let client enter game_move special type
special types are not run on clients...
actually I just left it and allowed special moves to run on clients...

that solves the client initiating the quit, what about the server?
the client will evetually timeout...

when server quits

here is my dilemma, when I set clients to inactive on the server, they don't sync anymore....

maybe I need more fine tuned control over this

how about some variables for the sync stuff

active should still mean actively particiapting in the game, dont change that.


but how about another one for netgame status?

0 not in netgame
1 syncing
2 locked

then I could run the sync indepandant of the rest...

so it could be joined, but not actually active and playing

I just want to seperate the two



-----------------------------------



Lets try to document exactly what you are doing.

Netgame Method.

I have given up on syncing game moves from server to client.

Clients send game moves to server.
Server consolidates them.
Game states are sent to clients.

There are fewer packets now.

Client sends cdat to server.

Server sends stdf's to clients.

Clients acknowlegde with stak.


Synchronization.
The server is the master timing reference and runs at 40fps.
Clients adjust their fps to stay in sync with the server.

When the server sends time stamped stdf's to clients, clients use that timestamp to determine how close its clock is to the server.
This is called client_sync and it it calculated on the client like this:

client_sync = server_frame_num - client_frame_num;

Positive values are when the client is behind the server (ealier in game time).
Negative values are when the client is ahead of the server (later in game time).

This value is used to adjust the client clock like this:



Ideally the server should be (ahead, behind??)


When the client sends time stamped stak's to server, the server uses that timestamp to determine how close the client's clock is to ther server.






Resetting base:
server sets a clients base to zero when sending a stdf and the lask ack is 0

when client rx's complete dif with src to zero it resets its base

if client rx's a dif but does not have correct base:
- currently it just sends staks with actual base it has...is this correct..i guess...

When server rx's stak, if it does not have that base for the client, it does the reset on the server

I want to count these (on the server seems like the best place)

   int client_base_resets;


Other things I am tracking:

when server receives cdats, what is their relation to current frame on server?

void server_proc_cdat_packet(void)
{
   int p = PacketGet1ByteInt();
   int cdat_frame_num = PacketGet4ByteInt();
   int cm = PacketGet1ByteInt();
   players1[p].server_game_move_sync = cdat_frame_num - mwPS.frame_num;
   sprintf(msg, "rx cdat p:%d fn:[%d] sync:[%d]\n", p, cdat_frame_num, players1[p].server_game_move_sync);
   add_game_move(cdat_frame_num, 5, p, cm); // add to game_move array

   if (L_LOGGING_NETPLAY_cdat) add_log_entry2(35, p, msg);
}





--------------------------------------
add chase_fps to player1 struct (not sync)
repurpose something not used..done


what else do I want to keep track of:


when client receives stdf (actually complete dif) how much rewind and replay is needed

when base is reset

implement this...

on server when rxing cdat

int server_game_move_sync;



change the join thing

initial join state should be from zero state, not level_base_state...

do i even need level base state???
we will see?
completely removed


server replies to join
sets player up locally with player_num color and control_method 2
adds game move type 3...??

then in normal server_send_stdf they are sent because now control_method is 2

in send_stdf:
- rewind to last ack state frame for that client
- replay to current frame
- send dif of current and last ack state

if last ack state frame == 0
send dif of current frame and zero;

do the colors work now???

yes, they seem to work great

when client quits, server quits unexpectedly

added some delay to entering the player inactive game_move and it seems to work much better...
but still when server quits, client just hangs

I think it actually made it to the client, but the client did not know what to do with it...
or its the same old situation where I set the client inactive on the server and immediately sync stops...

why don't I make a special control_method for clients that are getting dropped by server

mode = 8; active = 0;

it was there for 2 frames then rewind killed it....

make a special game_move like 3 and 4

now how to handle it on the client...done!!!!

-------------------------------------------------------------------------------------------------
make a method of the server being able to send special system messages to clients...

use 2 variables in players[]
- type
- data

if 0 do nothing
if non zero then do something based on the type..

for example:
1
2356
client quit game on frame 2356


2 3345
level done and load next level on frame 3345


what extra variables do I have in players


One thing I need to keep in mind, if I just change things on the server and expect them to make it to the client...
rewind and replay can undo those changes
I have had to make special game move entries so that rewind and replay do not erase changes
-------------------------------------------------------------------------------------------------
One thing I am thinking of is to keep the sync loop always going...

even when players are paused, or waiting for the next level to load...

I have always wanted to make the loop asynchronus, or at least not have to rely on the frame counter
-------------------------------------------------------------------------------------------------------







next bug to fix, why does client need a long chase?

test 100 frames then join...went really fast....

its something that is not getting reset between client joins
does not happen when quitting to command line

happens when quitting to menu and rejoining
on the server log the second joining client start at the frame number the previous one ended at...

in start_mode

   if (start_mode != 3) set_frame_nums(0);

why is there an exception for client ???
lets comment it out and see if shit breaks....
seems to work


now client quitting does not work good....
goes to server timeout again
only happens if quit is the first control a client presses
there was a bug where system game moves only looked back to >0...changed to >=0


can I get rid of serr packet?...done!!



now what?

why does client not show all join stuff in log?

I get
- waiting for game state
- fn updated

but I am missing chase and lock done
actually, I never get the player active on the client
it comes from state sync, not game_moves_array...

never mind...



next bug.....
why do bullets sometimes not draw properly on clients?
to be more specific, server player's bullets on client..
you've got to be shitting me! bullets are not sync'd
why the fuck not??

how do I deal with that?


// bullets
int pbullet[50][6];
int e_bullet_active[50];
int e_bullet_shape[50];
al_fixed e_bullet_fx[50];
al_fixed e_bullet_fy[50];
al_fixed e_bullet_fxinc[50];
al_fixed e_bullet_fyinc[50];



size:

50x6x4 = 1200 bytes

I can do this....

first of all, make the enemy bullets into one structure, not 6

ebullet.active
ebullet.shape
ebullet.fx
ebullet.fy
ebullet.fxinc
ebullet.fyinc


converted

1200 for each
2400 total
add this to game state shit

its only like 2.2% bigger

old:
Variables used for netgame state exchange

players  :  1664
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :106144


new:
Variables used for netgame state exchange

players  :  1664
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
---------:------
total    :108544


OK that is done and was easier than i thought


next bug
animations run way too fast on the clients

I'm sure I don't know why

update_animation is only called from proc_frame_delay() and that is not called when rewinding and fast forwarding...as far as I know


what if I cheated and synced zz also...

I really shouldn't need to....

loop frame is not even called on client

does anything manipulate the frame number on client??

I don't know what I did, but the clients animation is normal now
I put a printf with frame in update_animation...













---------------

looking into sync..

on client the stdf's arrive on the frame that they are needed on
this is surprising to me

I was expecting to have to play a few moves that were not sent yet, but I don't need to...

that must mean that the server is ahead, it can make a dif of its current frame, send it and the client can rx, decompress and apply in time for the same frame






I want to measure things...


how late are stdf's when received on client
make that a part of stak
actually I already do that
that is the value I use for sync

so to make this easy:

server sends stdf with server frame number
when client gets it it compares with local frame number and gets a sync from that
then clinet replies with stak and client frame number
when server gets that it compares with local again

there should be 3 frame numbers

1 - server origin
2 - rx on client and send ack
3 - rx back on server

then on the server
3-1 = round trip
3-2 = c to s sync
2-1 = s to c sync


s-s round trip
s-c sync
c-s sync

when I get an stak packet back on the server I want to have those three numbers
too bad they only have a resolution of 25ms

sfn1
cfn
sfn2


when client gets stdf we can use the already existing dst frame of the dif
that was sent from the server using the server's current frame num

then when the last stdf piece is rx'd and its time to reply with stak
add the clients current frame number to stak....
this is already done

then when stak is received on server we have all three frame numbers



lose dif corr on stak....


      Packet("stak");
      PacketPut1ByteInt(p);
      PacketPut4ByteInt(client_state_dif_dst);
      PacketPut4ByteInt(mwPS.frame_num);
      PacketPut4ByteInt(players1[p].frames_skipped);
      PacketPut4ByteInt(players1[p].client_chase_fps);






I want to make a dynamic grid for server debug overlay

there are many things I could put on the grid, but I want to be able to dynamically add and arrange them


each one will have a column header, a column width, and a variable to display with optional color

I will get to choose the columns and the the order
done and I added the new three syncs
they dont show much
round trip is one frame

what else do I want to monitor?

how many frames need to be rewound on server and client

right now on client it is zero....
how do i measure?

when client applies dif, compare current frame number to dif_dst
I already do this:
its part of the three frames i use on server when rxing stak
cfn and sfn1
and it is stored in player array as sc_sync

what about how many frames need to be rewound on server when making dif?
logging it, its usually 4

lets try more clients and different clients

it works...the problem with more clients is that the stdf frequency is distributed across all clients

what if I make it them all go at the same time?


lots of experimenting needed here


when I go to stdf freq of 8 and only 1 client....
server player on client warps a lot....all the rest is acceptable
4.5k
server rewind = 8


stdf 4
warp less noticeable
7-8k
server rewind = 4


stdf 2
even smoother
12-13k
server rewind = 2

stdf 1
I cant beleive it still works!! nice
25k
server rewind = 1


try stdf 2 and 2 clients at that rate
for now if i do stdf 1 and two client it should share
33k
sr 2 for both
fake keypress and all

server local client went all squirelly, cycling between 2 states, but clients felt rock solid and very responsive



next to do....
make the stdf sending scheduler better

when I say I want stdf_freq = 2, i mean that I want every client at that freq, not shared

I will stagger the sends though

if I only have 2 frames, ill do half on one and half on the other


can I remove control_lead_frames and server_lead_frames...yes...done...


i did the most major stress test ever..

7 client, stdf freq 1, forced all 7 to send every frame, fake key mode_t

got up to 900k

some clients were reseting base every frame!


20221212 took the day off work today, stayed up till midnight....

I am very happy with how well this is working!

I must commit...

20221213

figuring out send stdf...done...
if we don't send initial stdf, client locks...fixed so escape exits gracefully

next huge bug...why does server player go all squirrely?
clients seem to work fine...

I don't even know how the loop goes for local server player
I suspect the rewind and fast forwarding are messing something up

how can I go about figuring out what is happening?

reproduce..needed a few clients before it would reproduce

where do I enter server local game moves? server_local_control
tried +1 and -1 frame when adding game move, both caused double p0 on server

when sending stdf's look closer at the rewind and playback...

what if I store max_rewind frames? done


it seems to not happen until a base reset occurs, no that can happen and still good...


frame 123...nothing happening there...no base resets...

new game 4 client fake key happened before 20s

I'm not seeing anything in the logs

how about add rewinds to the logs

whenever a rewind happens make a log


I think that one of the clients states is messed up
then when I load it and ff I get a different state than the others...
that would make sense
one frame im here, next frame I'm there

could it be that I'm not replaying on the client when I should?
If that was the case, the clients should be messed up, right?

nothing the clients do should mess up the server...


I could check for a rogue client state

after rewinding and ff on the server
store something like p0 health or xpos
then compare to all the others

for testing, make all stdf send on same frame...
of course now it wont do it...
stdf = 1;
4 clients all fake key
200s, no error

again 200s with no error


goddamn it, now I cant make it fail
stdf = 1;
240s
7 clients fakekey
500 to 1000kBs
tons of base resets

try stdf=2 and see if it breaks....
yes, very quickly...

I think that the server rewinding for one client gets a different state than another client on a different frame
I don't know why, but that could explain it

How about I send all stdf on the same frame?
I can wait a few frames in between.

Lets take this even further...

- rewind to oldest client ack
- ff to now
- make difs for each client based on last client ack

then I will only have to do one rewind, not one for each client

when I am doing a rewind, it's only to apply the game_moves that have not been applied
maybe I can keep track of game moves received earliest frame numbers
then when its time to send dif and do rewind, only go as far back as needed to apply...

I would like to implement this:

write it out again:

dif's are made periodiacally. every 2 to 4 frames..

every time that frame happens:
- rewind to previous dif frame and play back to current to apply late game moves
- send that dif to all clients
thid could work...
and it sounds simple...

and only one rewind is needed


I just found a pretty major bug in the send_stdf code...
rewind was only done if not basing from zero
wait...is that a bug?
what would it play back from...

this is the original...




// send stdf to a specific client
void server_send_stdf(int p)
{

  // printf("stdf:%d %d\n", mwPS.frame_num, p);

   int last_ack_state_frame = srv_client_state_frame_num[p][0];


   // if last ack state is 0 dont replay anything, just send current state
   // in this case the dif will be from all zeros to current
   // and will skip any un processed moves on the client
   // I would like this method to rewind and replay a bit
   if (last_ack_state_frame == 0) // set base to all zeros
   {
      memset(srv_client_state[p][0], 0, STATE_SIZE);
   }


   // rewind and fast forward from last ack state to apply missed game moves received late
   // in this case the dif will be from last_ack_state to current
   else
   {
      int saved_current_frame_num = mwPS.frame_num;               // save old current frame


      players1[p].server_rewind_frames = mwPS.frame_num - srv_client_state_frame_num[p][0];



      if (players1[p].server_rewind_frames > players1[p].server_rewind_frames_max)
          players1[p].server_rewind_frames_max = players1[p].server_rewind_frames;




      mwPS.frame_num = srv_client_state_frame_num[p][0];          // rewind
      state_to_game_vars(srv_client_state[p][0]);

      while (mwPS.frame_num < saved_current_frame_num) loop_frame(); // fast forward

   }



   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   // set dif dest to current mwPS.frame_num
   srv_client_state_frame_num[p][1] = mwPS.frame_num;

   // get current state
   game_vars_to_state(srv_client_state[p][1]);

   // make a new dif from base and current
   get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);

   // compress dif to cmp
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
   int cmp_size = destLen;



















// what do I rewind to?

// pick a state from the clients_states??

// any of them should have a copy

// or should I rely on my own...

// im really stuck here??

// i think the server should keep at least a few of the last
// i know this would work, but is it really necessary?
// i can always remove it later...


// lets keep the last 1 for now

// call it
//// server's copies of last stdf states
//char srv_stdf_state[4][STATE_SIZE];
//int srv_stdf_state_frame_num[4];
// use only 0 for now


// how do i get the first one?


// nothing to rewind to


// after ff set:

   // put current state in client's state slot 1
   game_vars_to_state(srv_stdf_state[0]);

   // put current mwPS.frame_num
   srv_stdf_state_frame_num[0] = mwPS.frame_num;



   before rewind check...

   if (srv_stdf_state_frame_num[0] == 0)

   don't do rewind


why do clients that join after key removes blocks, still show the blocks
I think all they need to do is redraw the level_buffer...

why does that not happen anyway??
i think it only happens when level is loaded...

so when should I do it?
after rx first dif?? sure...try that..done....

now what to fix, or log, or improve??

as some point I will need to fix level_done...i hope its not as hard as it was last time....


so where have we left this stdf thing?
it seems to be working good


stdf_freq = 2
seems to work good

if I play a long enough game, moves bleed through to other players
I was 600 frames in and in and eight player game

moves on player would make would cause other players to move also...

im pretty sure its something on the server
when it happens all client still look the same
problem with game moves array on server?

why do i even bother with game moves array on client?
just enter the keys imediately
that is the way they always happen anyway

how long was the game?
log file is 25M and wont open

could I be overwriting stuff when log file overflows?

log file has 25 million char and 350,000 lines? that seems excessive
frames  24,491 / 40 = 612s

#define NUM_LOG_CHAR  100000000
#define NUM_LOG_LINES 1000000

i guess it could take 100M...

how many game moves?
I dont think I am recording the size of the game_moves array anywhere..?
clients dont have the full one
why do i even bother with game moves array on client?
just enter the keys imediately
that is the way they always happen anyway
the only reason I still use it is so that I could replay moves on the client, but i don't do that
also for symetry, to keep all control methods the same (not that important)
also to replay games, doesnt matter on client, we dont have all moves...


[22][0][24572]+--------------------------------------------------------------------------+
[22][0][24572]|                        Server (m36) ending stats                         |
[22][0][24572]+--------------------------------------------------------------------------+
[22][0][24572]+--------------------------------------------------------------------------+
[22][0][24572]|        level.....................[13]                                    |
[22][0][24572]|        total frames..............[24572]                                 |
[22][0][24572]|        total moves...............[32083]                                 |
[22][0][24572]|        total time (seconds)......[614]                                   |
[22][0][24572]|        total time (minutes)......[10]                                    |
[22][0][24572]|        server frames skipped.. ..[8]                                     |
[22][0][24572]|        total tx bytes............[73295321]                              |
[22][0][24572]|        max tx bytes per frame....[27338]                                 |
[22][0][24572]|        avg tx bytes per frame....[2982]                                  |
[22][0][24572]|        max rx bytes per second...[364412]                                |
[22][0][24572]|        avg tx bytes per sec......[-55475]                                |
[22][0][24572]|        total tx packets..........[107108]                                |
[22][0][24572]|        max tx packets per frame..[32]                                    |
[22][0][24572]|        max tx packets per second.[460]                                   |
[22][0][24572]|        total rx bytes............[2414515]                               |
[22][0][24572]|        max rx bytes per frame....[329]                                   |
[22][0][24572]|        avg rx bytes per frame....[98]                                    |
[22][0][24572]|        max rx bytes per second...[4951]                                  |
[22][0][24572]|        avg rx bytes per sec......[3930]                                  |
[22][0][24572]|        total rx packets..........[168461]                                |
[22][0][24572]|        max rx packets per frame..[23]                                    |
[22][0][24572]|        max rx packets per second.[362]                                   |
[22][0][24572]+--------------------------------------------------------------------------+


add total game moves to server ending stat's and show on debug...

also make client debug grid like ServerSendTo

why doesn't client show servers name??
when client gets a join reply it should set the hostname for server
clients don't have names for all the other clients
they could if I moved local_hostname to players instead of players1 so it gets synced...
not important enough to do..maybe later if I allow clients to name themselves
it looks like server ending stats already does total game moves...

so back to finding the weird bug where player's moves affect other players

try to reproduce again...

level 13
max clients and fake key
run for 60s at a time then check
happened arounf 420s or 32000 game moves

double check to see if it happens at 32000 game moves....
happened around 413s
total game moves was suddenly reduced to 20K when it was a lot higher, like maybe close to 100k??

wtf? I know, right?

do it again...
99 -> 14 at time 356s
WTF?

can open log file, dies at loading screen...
file is 20k char 300k lines

dies after parsing line 202569

[28][7][10406]tx stdf piece [2 of 2] [10402 to 10406] st:1000 sz: 356
[30][1][10407]rx stak sync:[1] chase:[40] ack_fn:10406 cli_fn:10406 set new base
[35][1][10407]rx cdat p:1 fn:[10406] sync:[-1]
[35][2][10407]rx cdat p:2 fn:[10405] sync:[-2]
[30][3][10407]rx stak sync:[1] chase:[40] ack_fn:10406 cli_fn:10406 set new base ------------------------- THIS ONE 569
[35][3][10407]rx cdat p:3 fn:[10406] sync:[-1]
[30][5][10407]rx stak sync:[2] chase:[38] ack_fn:10404 cli_fn:10405 failed to set new base! cl:10406
I think the line is too long ...over 100 char...
fixed in 2 places...when specific log line is added and when lfv adds to lines...


now back to why it rolled over....

save game list moves to 3000, then a jump to 14000...

still not sure why

log gmep in server somehow

when rx cdat....

[30][3][13771]rx stak sync:[1] chase:[40] ack_fn:13770 cli_fn:13770 set new base
[35][3][13771]rx cdat p:3 fn:[13770] sync:[-1] gmep:[99998]
[30][4][13771]rx stak sync:[1] chase:[40] ack_fn:13770 cli_fn:13770 set new base
[35][4][13771]rx cdat p:4 fn:[13770] sync:[-1] gmep:[99999]
[30][5][13771]rx stak sync:[1] chase:[40] ack_fn:13770 cli_fn:13770 set new base
[35][5][13771]rx cdat p:5 fn:[13770] sync:[-1] gmep:[100000]
[30][6][13771]rx stak sync:[1] chase:[40] ack_fn:13770 cli_fn:13770 set new base
[35][6][13771]rx cdat p:6 fn:[13770] sync:[-1] gmep:[13771]
[30][7][13771]rx stak sync:[1] chase:[40] ack_fn:13770 cli_fn:13770 set new base
[35][7][13771]rx cdat p:7 fn:[13770] sync:[-1] gmep:[13772]
[35][1][13772]rx cdat p:1 fn:[13771] sync:[-1] gmep:[13774]

it looks like gmep is being set to mwPS.frame_num...but why? and where???


for the purposes of reproducing, can I start with gmep at 99990?
yes and it happens just the same, even with no clients


it happens in proc_controllers...

it happens in proc_player_input(ret)

it happens in server_local_control()

it happens in add_game_move()

YOU HAVE GOT TO BE SHITTING ME!!!!
#define GAME_MOVES_SIZE 100000
why the fuck?...its my own fault!!!!

OK this is now fixed...

I forgot what the hell I was doing....

what next

I did a long game and it seem to work good, tried playing back as demo and it did not work....

try some shorter demos??

maybe later...


---------------------------------------------------------------------------------------------------
if client never plays back moves from its own gma, why do I even bother putting them in there?
can I do away with that completely on the client and just set controls directly?


sort out controls, comp move and game move

the function 'set_controls_from_comp_move' actually sets them from a specific game move

the function 'set_controls_from_game_move' does the whole search thing


new:

#define PM_COMPMOVE_LEFT   0b0000000000000001
#define PM_COMPMOVE_RIGHT  0b0000000000000010
#define PM_COMPMOVE_UP     0b0000000000000100
#define PM_COMPMOVE_DOWN   0b0000000000001000
#define PM_COMPMOVE_JUMP   0b0000000000010000
#define PM_COMPMOVE_FIRE   0b0000000000100000
#define PM_COMPMOVE_MENU   0b0000000001111111

void set_controls_from_comp_move(int p, int comp_move)
{
   clear_controls(p);
   if (comp_move & PM_COMPMOVE_LEFT)  players[p].left  = 1;
   if (comp_move & PM_COMPMOVE_RIGHT) players[p].right = 1;
   if (comp_move & PM_COMPMOVE_UP)    players[p].up    = 1;
   if (comp_move & PM_COMPMOVE_DOWN)  players[p].down  = 1;
   if (comp_move & PM_COMPMOVE_JUMP)  players[p].jump  = 1;
   if (comp_move & PM_COMPMOVE_FIRE)  players[p].fire  = 1;
   if (comp_move & PM_COMPMOVE_MENU)  players[p].menu  = 1;
}


void set_comp_move_from_player_key_check(int p) // but don't set controls !!!
{
   int cm = 0;
   if (mI.key[players1[p].left_key])  cm |= PM_COMPMOVE_LEFT;
   if (mI.key[players1[p].right_key]) cm += PM_COMPMOVE_RIGHT;
   if (mI.key[players1[p].up_key])    cm += PM_COMPMOVE_UP;
   if (mI.key[players1[p].down_key])  cm += PM_COMPMOVE_DOWN;
   if (mI.key[players1[p].jump_key])  cm += PM_COMPMOVE_JUMP;
   if (mI.key[players1[p].fire_key])  cm += PM_COMPMOVE_FIRE;
   if (mI.key[players1[p].menu_key])  cm |= PM_COMPMOVE_MENU;
   if (mI.key[ALLEGRO_KEY_ESCAPE])    cm |= PM_COMPMOVE_MENU;
   players1[p].comp_move = cm;
}


now on client:
set controls from keys directly and send cdat
do nothing with game_move_array
never rewind
just update state when server sends it

this seems to work great, but I'm only testing on LAN
hope it still works good on less than ideal network

right now the server state arrives exactly on the frame it is needed
but if it arrived a frame or two late, then controls pressed on those frames would have to wait until the next state arrives
---------------------------------------------------------------------------------------------------


moving on... I want to do something about level done, but first lets record some bandwidths

stdf_freq = 1 (25ms)
level 13 8p fk
500 to 800kBs max 980
lots of base resets on all but 6430

stdf_freq = 2 (50ms)
level 13 8p fk
180 to 260kBs max 370
occasional base resets on 4230's

stdf_freq = 3 (75ms)
level 13 8p fk
120 to 140 max 150
only base resets on 6400

stdf_freq = 4 (100ms) still seems very responsive
level 13 8p fk
100 to 110 max 112
only base resets on 6400

stdf_freq = 5 (125ms)
level 13 8p fk
82 to 86 max 90
only a few base resets on 6400

stdf_freq = 6 (150ms)
level 13 8p fk
66 to 78 max 82
only a few base resets on 6400


I think I will go with 3 for now....

try it without 6400..
stdf_freq = 3 (75ms)
level 13 8p fk
125 to 135 max 140
very rare base resets (no 6400!)
quite stable bandwidth when no base resets!!
the clients all overlay on the graph, they all transmit at the same time

OK now onto the big one...level done...


If I can simplify it in anyway that would be great....

I will need to keep the game_loop running, or do I?

Do I want to freeze all players, enemies, items. lifts??
How about:

Keep level running but:
Freeze all players, items, lifts
Kill all enemies.
Bring all clients to the exit also.
Show the ending stats and wait for all players to acknowledge or timeout.
Start the next level.
Show door opening and player going in.

I still might accomplish this with the game moves array, but only on the server of course.

The client will still take their cues from there....
I might need a new mode for player.

make a new gmtype the sets all clients to freeze mode


how can I handle all these changes getting to the clients?

I am going to rely on the server setting things in the clients player structure and having that synced to clients
and also setting things in the player0(server struct)

maybe that's where level_done_mode should live...


does it need to get synced to clients? can't I just control them directky

I want to set some variable in players struct on the server, might as well call it level done mode...

then do all the normal stuff with that..

but only the server controls it

first mode is freeze and move to exit
clients, should not have to do anything. let the server move them..


20221215 6:45 AM

what do we have now?

when level done,
server shows end stat, server can ack, client can not...

level done does not work on server even with no clients



what happens

I have this weird variable that controls the level_done procedure

I have active, control_method, paused, paused_type..

I like control_method. it very closely describes what it is meant to do..

active is very useful. binary 0 or 1, ignore complete if zero..

what I don't like is inactive and control method 2 for chasing
it seems wrong, like here is an excpetion when inactive is not really active

what two should signify is that difs are being sent to this from the server




how about chase is:
active 1
cm 2
paused



do this...


make more space in the player array, like at least 10 more ints
keep most of them unused for now, but later use them for more control structures...

current 1664 or 208 per player
new 2048 or 256 per player

update STATE_SIZE 108928 ...done

now my thoughts on level done are:

add some overall state thing to player 0

like a level_done_mode

the advantages are that I do not have to worry about this getting to the clients
it will get there!!!

but then what?

do mostly what you already did for level_done

change all level_done_mode to players[0].level_done_mode

done...

just for the hell of it, test it...


both client and server were able to ack
problem is after that...

I think we get as far as proc_next_level();

it looks like the server is frozen until the same ammount of time passes on the new level as the one we just left
then server player starts at same pos as last level and exits immed...


could possibly be a rewind thing...


trace the order of things on serv

ldm = players[0].level_done_mode



loop() calls move_items()
when exit is touched by any player
if (players[0].level_done_mode == 0)
{
   players[p].paused = 5;
   players[0].level_done_mode = 8;
   next_level = play_level + 1;



in loop:
if (players[0].level_done_mode) proc_level_done_mode();
proc_level_done_mode(); has its own custom loop where stuff is drawn but nothing is moved
and this:
if (players[0].level_done_mode == 5)
{
   if (ima_server)
   {
      int aa = 1; // yes by default, set to no if any have not ack
      for (int p=0; p<NUM_PLAYERS; p++)
         if ((players[p].active) && (!has_player_acknowledged(p))) aa = 0;
      if (aa) add_game_move(mwPS.frame_num, 7, 0, 0); // insert next level into game move
   }


in loop() process_controllers() server_local_control()
if (players[0].level_done_mode == 8) start_level_done(p, 80, 800);
void start_level_done(int p, int t1, int t2)
{
   players[0].level_done_mode = 7;
   int fn = mwPS.frame_num;
   add_game_move(fn,     6, 0, 1); // insert level done 1 into game move
   add_game_move(fn+t1,  6, 0, 2); // insert level done 2 into game move
   add_game_move(fn+t2,  7, 0, 0); // insert next level into game move
   players1[p].old_comp_move = players1[p].comp_move = 0; // reset both

   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) players1[p].quit_reason = 80;
}

loop() calls proc_controllers() calls proc_game_move()
when type 6 level done 1 is received, set ldm to 6

loop() calls proc_controllers() calls proc_game_move()
when type 6 level done 2 is received, set ldm to 5

loop() calls proc_controllers() calls proc_game_move()
when type 7 next_level is received, calls proc_next_level();










20221217 saturday and I hope I have enough time to fix this level done thing today

leaving the whole detailed description above for now, I want to focus on next level

I all seems to work good, touch exit, level_done 1, level done 2 server and client ack...
but then when next level happens it freezes...

void proc_next_level(void)
{
   if (L_LOGGING_NETPLAY) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }
   if ((ima_client) || (ima_server))
   {
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         // free all the used clients, so they can be re-assigned on the next level
         if (players[p].control_method == 9) players[p].control_method = 0;
         // set all clients inactive on server and client, to force them to re-chase and lock on the new level
         if ((players[p].control_method == 2) || (players[p].control_method == 4)) players[p].active = 0;
      }
      if (ima_server) server_flush();
      if (ima_client) client_flush();
      al_rest(1);
   }
   stop_sound();
   blind_save_game_moves(1);
   save_log_file();
   play_level = next_level;
   players[0].level_done_mode = 0;
   proc_start_mode(5);
}

OK right away, I see that this will never run on the client, unless I make it somehow, but
lets just focus on the server for now

- changes all mode 2 to inactive
- flushes server
- sets level_done_mode to 0
- start mode 5

that means that the sync is ended and these local changes to players never get to the client..

that is something else that will need to be fixed, but first, why does the server freeze?

this all might take some time to figure out, but I want to make it simpler...


High Level Level Done

Controlled by server, lets skip to the part where the server decides its time to actually do next level...

in every active client set something in player[0] sruct

something that says we are going to start a new level in so many frames
this will get synced to clients
when they get it, they will wait until that frame, then load the new level and reset a bunch of things

Do I actually need to quit and re-chase? I would like to do without that...

let's try to flesh this out in more detail

add mode 4 to players[0].level_done_mode

when setting mode 4, also set a delay...

   int next_level_num;
   int next_level_frame_num;



make these changes:

When ldm 5 is done (timed out or all players acked)
- still enter the next level special game move as before

when next_level gm is processed..




- start ldm mode 4
- set next_level_num and next_level_frame_num
- make the next level game move still entered





this will get sync to clients

in all players:
monitor for ldm4 and mwPS.frame_num






how about on the server I keep track of these states in player struct instead of special game moves?

when the server plays or replays and any player starts exit....

set players[0].level_done_mode
no special game moves....

this will also happen on clients, but clients are to do nothing with it

players[0].level_done_mode will have a corresponding timer...

on the server when the timer runs down, it goes to the next level_done_mode and gets a new timer


ldm 0

exit touched
ldm 8
ldt 100
level freezes
when this times out

ldm 7
ldt 100
if all ack then ldt = 0;
when this times out or all ack

ldm 6
ldt 40
when this times out immediately load new level


this looks a lot simpler

lets see if I can implement for single player...


start with exit touched:

      if (players[0].level_done_mode == 0)
      {
         players[0].level_done_mode = 8;
         players[0].level_done_timer = 80;
         next_level = play_level + 1;
         game_event(4, 0, 0, 0, 0, 0, 0);
      }

for now it does it for all player and client and server, maybe later I'll need to refine....


next, monitor for players[0].level_done_mode in main loop...

      if (players[0].level_done_mode)
      {
         stop_sound();
         proc_frame_delay();
         if (draw_frame) draw_frame1();
         proc_level_done_mode();
      }
      else
      {
         move_ebullets();
         move_pbullets();
         move_lifts(0);
         move_players();
         move_enemies();
         move_items();
         proc_frame_delay();
         if (draw_frame) draw_frame1();
      }

this draws the same but does not move any objects

void proc_level_done_mode(void)
{
   if (players[0].level_done_mode == 8)
   {
      if (--players[0].level_done_timer <= 0)
      {
         players[0].level_done_mode = 7;
         players[0].level_done_timer = 80;
      }
   }

   if (players[0].level_done_mode == 7)
   {
      if (--players[0].level_done_timer <= 0)
      {
         players[0].level_done_mode = 6;
         players[0].level_done_timer = 80;
      }
   }

   if (players[0].level_done_mode == 6)
   {
      if (--players[0].level_done_timer <= 0)
      {
         players[0].level_done_mode = 5;
         players[0].level_done_timer = 80;
      }
   }



this simply changes modes...

remove all the things that happen with special game moves....done
removed start_level_done()

now what?

ldm 0 - nothing


ldm 9 - trigger (only last 1 frame)
ldm 8 - delay only
ldm 7 - delay and ack
ldm 6 - wait for actual load new level
ldm 5 - is the actual call to proc_next_level();

if called from warp, start on 6


accept input on 0 and 7
move objects 0 only


the method of acking is still entering game moves
server_local control 0 or 7
client_local control 0 or 7
single player 0 or 7

ack add game move now checks for ldm mode 7 and enters gm type 8(no change there)

now display level_done_mode... and do the timer properly and the ack check

actually make the ack knowledge thing change the timer...

works good in single player...

in 2p mode keeps getting reset??
9 8...

add proc_level_done_mode to rewind loop....

it looks like it is working!!!

client does not show that it has acked, we should set this on server...

its working so good I am going to remove old stuff....

add warp...done...





Document

Level Done Procedure


When any player touches an unlocked exit, or warp, the Level Done Procedure is started.

The main variables that control this are:

int players[0].level_done_mode
int players[0].level_done_timer
int players[p].level_done_ack


In normal game play, players[0].level_done_mode is zero.

At the start of the Level Done Procedure players[0].level_done_mode is set to 9 or 6;


players[0].level_done_mode = 0; // normal game play
players[0].level_done_mode = 9; // exit touched
players[0].level_done_mode = 8; // 2s unskippable delay
players[0].level_done_mode = 7; // 10s skippable delay
players[0].level_done_mode = 6; // both delays done, start load new level countdown
players[0].level_done_mode = 5; // load new level

All in game objects are frozen in modes 9-5
Player input only occurs in modes 0 and 7 (in mode 7 input is used only for acknowledging and skipping delay).

When a warp is touched, the Level Done Procedure is started at mode 6, skipping the first two delays.



there are some bugs

client does not have the same blocks as server??
only the ones that are drawn...

I don't know how anything I changed should affect that...

its not just the client's moves, server's moves also break blocks that don't appear broken on client


that is something that has never been synced, only the player array...

it would be expensive to redo this every frame...right??

what about doing it in sections?




instead of 10,000 blocks at a time, maybe 1000


test this...
speed test on
m36 fs z1.0
4000 fps 98% gpu
117  fps 84% gpu init_level_background() every frame

test this on client

I don't think this is a new bug, it has always been this way..

the problem is that the server can manipulate the level blocks array and while the changes to that make it to the client, the actual level_buffe bitmap does not...

how about comparing the array on the client and redrawing blocks that differ...


added this in clients apply dif...seems to work good....


      // make a copy of the old l[][]
      int old_l[100][100];
      memcpy(old_l, l, sizeof(l));

      // copy modified base state to game_vars
      state_to_game_vars(client_state_base);

      // compare old_l to l
      for (int x=0; x<100; x++)
         for (int y=0; y<100; y++)
         {
            if (l[x][y] != old_l[x][y])
            {
               printf("dif at x:%d y:%d\n", x, y);
               al_set_target_bitmap(level_background);
               al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, al_map_rgb(0,0,0));
               al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
            }
         }



has_player_acknowledged uses game move entries....
do I still need to do this?

it would be easier to just mark the flag players[p].level_done_ack..
...but then I might lose it on rewind...

leave it the way it is for now...

look into game moves at the end


why are there moves at the end? after acks...
I should clear controls...but where? multiple places...

I also should set player paused, like it used to be done...yes that looks better...



now what about the delay I have 20 to load new level...could I do 10?
there is a 1s dealy in proc_next_level..try to remove it...still seems to work...

lets try a longer test....


OK I am quite happy with this...now document it



i want to reomve the global int draw_frame...done...handled with a return value from proc_frame_delay()


what would happen if I did not force clients to re-chase? its not that easy....



in mode 8 make all players converge on the active exit

what is the active exit?
there could possibly be many exits...
store the data for the one the triggered...where? p0 again...why not...

   int level_done_x;
   int level_done_y;

ok, now where do I move to that...













what the fuck did i break?

level done for 2p breaks everything

normally server should send first stdf from 0 to somethng but it send from src == dst ???

wtf?

also on client, srv is set inactive??


what is not getting done?



print frame number to screen...

runs for 3 frames then resets to old fn from last level



probably in server sen stdf when it reads from


void server_control() // this is the main server loop to process packet send and receive
{
   if (L_LOGGING_NETPLAY_PLAYER_ARRAY) log_player_array2();

   if (mwPS.frame_num == 0) reset_states(); // for stdf


there must be a better place to reset_states
I do it in proc_next_level() now....

client does it when joining...blocking, waiting for first stdf

what about putting it in start mode...yes
now the only place it is called is in start_mode, right after loading level and resetting frame numbers and it seem to work...


now that I fixed that reset_states() bullshit what about not making inactive??
I might be able to make that work...
needed to set clients player position...
it used to be when it came active, I will still leave that there
for when joining and the start could be mobile or different one active
but I also added a set position when resetting player info in start mode....
it seems to pass the level done shit just fine, but I want to test it more...
seems to work


sometime I get error about not being able to load a level...added more logging shit...












what about reusing clients?
try it....

when client quits, do not mark with 9, just mark with zero and init_player shit....
tried it when player quits, does not seem to cause any bad shit

also happens when server drops player, could try it there...

this will break end of level stats amd possibly rungame demo...

but I can worry about that shit later...

20221217 10:00 PM

I got a lot of shit done today...
I am so happy that I got level done in a good place, and far less convoluted than before...






20221218 sunday 5:00 AM

what do I want to accomplish today?

more testing and refining...

documentation
complete level_done
work on redoing netgame to match what I am doing now




why does client quitting not work anymore?
is because on client we are setting the controls directly
there is no game move used at all on clients
I will need to do something different there

why does menu set all bits? don't do that anymore
fixed in pm.h BIT defines
look for other places...
searched for comp_move...nothing there
can't quit single player game
fixed at add game_move

fixed the local client quitting

now what about when server quits on client?
it just times out...


when add game_moves get a quit from local server:

      if ((active_local_player == 0) && (players[0].control_method == 3) && (data1 == 0)) // local server quitting
      {
         printf("local server quitting f:%d\n", mwPS.frame_num);
         // first set all connected clients to inactive
         for (int p=1; p<NUM_PLAYERS; p++)
            if (players[p].control_method == 2)
            {
               game_moves[game_move_entry_pos][0] = frame + 2;
               game_moves[game_move_entry_pos][1] = 4;   // type 4; client quit
               game_moves[game_move_entry_pos][2] = p;   // player num
               game_move_entry_pos++;

               game_moves[game_move_entry_pos][0] = frame + 10;
               game_moves[game_move_entry_pos][1] = 1;   // type 1; player state
               game_moves[game_move_entry_pos][2] = p;   // player num
               game_moves[game_move_entry_pos][3] = 64;  // inactive
               game_move_entry_pos++;
            }



what is the purpose of the type 4??
so when server rewinds and replays it still happens

but what it does is set control method to 8??

what does that do?

I think it is still supposed to send stdf

      // send dif based on this state to all clients
      for (int p=1; p<NUM_PLAYERS; p++)
         if ((players[p].control_method == 2) || (players[p].control_method == 8)) server_send_stdf(p);

then when client gets that, it shuts down..
// fix control methods
players[0].control_method = 2; // on client, server is mode 2
if (players[p].control_method == 2) players[p].control_method = 4; // but don't touch if 8!
if (players[p].control_method == 8) game_exit = 1; // server quit

This seems to work fine....

also, remove all game move stuff from client then, if not used...
at least, do not save on client


make player face exit when seeking..done
exit seek to happen before level done display makes display dim..done
display jq message at that time? yes...done
I don't know which player actually did the exit...use another player var and save it...done




there seems to be a lot of duplication bewteen

proc_next_level() and proc_start_mode()

I would like to put everything from proc_next_level() in proc_start_mode()...done

now clean up proc_start_mode()..done


I have currently disabled the part where client are set inactive so they redo chase and lock on new levels
I just realized that there is no game move making them active in the new level...hope this does not cause any issues
maybe its because they are never reset when starting a new level...

that reminds me to reset more level_done_ stuff in init player....done..

I am done with documenting level done!!!


start making new netgame docs

I don't want to kill the old one


I have been through a few iteration of how I approach the multplayer netgame.


The approach I use now:

The server is the final authority of the game state.
The server syncs its game state to clients.
Clients send control changes to the server.

This all still the same as the previous way I did things.
The old method also synced game moves back to client, and I did not execute them on the client until I got them.
This method worked, but had a few major flaws.

There was considerable lag. Not unplayable, but definitely annoying.
A client would have to send a control change to the server and wait for a reply before actually applying the control change.
I only tested it in a LAN and even with that optimal network, the lag was on the order of 75ms (or three frames)
The server had to run 1 frame behind the client to ensure it got the control changes in time to apply them.
The client had to mark control changes 3 frames in the future to make sure they could get them back in time to apply them.

The new method I use does not ever try to sync the game moves back to the client. I have abandoned that completely.

Instead, the server's game state is how the changes are propogated back to the clients.

frame 100  - client receives new game state from server and overwrites clients current state
frame 101  - client makes a control change, applies it directly to its local state, and sends a packet to the server with the control change
frame 102  - another change
frame 103  - client receives new game state from server and overwrites clients current state

frame 100 server sends state to client
frame 101
frame 102 server gets control change from client for frame 101, too late to apply, stores it.
frame 103 server rewinds to last time it sent a state (100) then replays and applies all missed moves, then sends state to client

The client and the server are almost running at the same time.
The server is the timing master and never changes
The client adjusts its timer slightly so that it always gets the state from the server on exactly the frame it is needed.

This is vastly simpler than the previous method I was using, and the lag is imperceptable!

Occasionally there are corrections when the client's state does not match the servers, but they are neglible, barely noticeable.

What happens on the client, to phrase it differently:

The client runs for a few frames, assuming its local input will be received and applied by the server.
When the client gets a new state from the server, if the moves were all recieved and applied, the clients guess will be pretty close to the server.
There are also other players inputs (server, other clients) that the client cannot predict, so those changes will also affect the drift between the client and server.
But the instant that the client gets a new state, they will be in perfect sync with everyone else.





see how broken run game is...it actually seems to work pretty good
all the demos I have tried seem to work
lets try recording something

there are definitely some bugs....

long 8P did not work

short 2P OK but went past end


when a level_done level is started there will not be all the player active things...need to fix


fix the txt version to show other types...done...

I want to simplify type 1


right now it handles active, inactive, color and quit reason

I want:

type 1 active and color
type 2 inactive and reason


look at all the add_game_move() s and fix

there are 11 occurances of add_game_move()

2 are defs


1 type 0 start
3 type 5 reg move

1 type 3 client join

0 type 4 for client quit??

2 type 1 inactive
2 type 1 active

changed both inactive to type 2 and nothing else

done now test...

-----------

client quitting makes server quit also

I missed some manual entries...
4 exists!!
8 exists!!



------------------------

20221219
why does rungame not work for multiplayer?

around 70s which is about how many game moves are in the file???

there is a bug here


where do I set demo_mode_last_pc ?

first of all, change to demo_mode_last_frame...done

it is set in start_mode, but I am going to move it to load_gm()...done


I have a test file 4062 frames long (100s)

player 0 goes dumb around 2800 frames (70s)

coincidentally, 2800 is the number of game moves in the file....

those should not interfere....

is that 100 gm from end??? YES!!

I think in this function:

void set_controls_from_game_move(int p)


we always search back from game_move_entry_pos...
but that index is the next one to be set, I think we should search from one less than that.
many things use this function, could they all be wrong??

fixed this to game_move_entry_pos-1; still the same...

could it be when 2nd players come active??

tried to look at the log, but none is created in rungame mode??

looking in the log, p 0 and 1 are still both active and cm 1


I am not getting anywhere....


SUCCESS!!! THIS IS THE CODE THAT FUCKS IT UP!!!


   // in rungame mode game_move_entry_pos is always at the end of the already filled array
   // it can take a long time to search backwards through the entire array, so set the search position 100 moves in the future
   if (players[p].control_method == 1)
   {
      gme_search_index = game_move_current_pos + 100;
      if (gme_search_index > game_move_entry_pos-1) gme_search_index = game_move_entry_pos-1;
   }
















simplifed add game move like this...


// just enter the move
void add_game_move2(int frame, int type, int data1, int data2)
{
   game_moves[game_move_entry_pos][0] = frame;
   game_moves[game_move_entry_pos][1] = type;
   game_moves[game_move_entry_pos][2] = data1;
   game_moves[game_move_entry_pos][3] = data2;
   game_move_entry_pos++;
}


void add_game_move(int frame, int type, int data1, int data2)
{
   if ((players[0].level_done_mode == 5) && (type == 5) && (data2)) // all move type inputs are acks in this mode
   {
      if (!has_player_acknowledged(data1)) // to prevent multiple acks
      {
         add_game_move2(frame, 8, int data1, 0);

//         game_moves[game_move_entry_pos][0] = frame;
//         game_moves[game_move_entry_pos][1] = 8;
//         game_moves[game_move_entry_pos][2] = data1; // player num
//         game_moves[game_move_entry_pos][3] = 0;
//         game_move_entry_pos++;
      }
      return; // to exit immediately
   }

   if ((type == 5) && (data2 & PM_COMPMOVE_MENU))  // menu key
   {
      if ((active_local_player == 0) && (players[0].control_method == 0)) // single player mode
      {
         // eat this keypress and pretend it never happened
         game_exit = 1;
         resume_allowed = 1;
         return; // to exit immediately
      }
      if ((active_local_player == 0) && (players[0].control_method == 3) && (data1 == 0)) // local server quitting
      {
         printf("local server quitting f:%d\n", mwPS.frame_num);
         // first set all connected clients to inactive
         for (int p=1; p<NUM_PLAYERS; p++)
            if (players[p].control_method == 2)
            {
               add_game_move2(frame + 2, 4, p, 0); // type 4 - client quit

//               game_moves[game_move_entry_pos][0] = frame + 2;
//               game_moves[game_move_entry_pos][1] = 4;   // type 4; client quit
//               game_moves[game_move_entry_pos][2] = p;   // player num
//               game_move_entry_pos++;


               add_game_move2(frame + 10, 2, p, 64); // type 2 - player inactive
//
//               game_moves[game_move_entry_pos][0] = frame + 10;
//               game_moves[game_move_entry_pos][1] = 2;   // type 2 - player inactive
//               game_moves[game_move_entry_pos][2] = p;   // player num
//               game_moves[game_move_entry_pos][3] = 64;  // inactive
//               game_move_entry_pos++;
            }

         // then set server to inactive in future
         add_game_move2(frame + 10, 2, 0, 64); // type 2 - player inactive

//         game_moves[game_move_entry_pos][0] = frame + 10;
//         game_moves[game_move_entry_pos][1] = 2;          // type 2 - player inactive
//         game_moves[game_move_entry_pos][2] = data1;      // player num
//         game_moves[game_move_entry_pos][3] = 64;         // inactive
//         game_move_entry_pos++;

         return; // to exit immediately
      }

      if ((active_local_player == 0) && (players[0].control_method == 3) && (data1 > 0)) // remote client quitting
      {
         printf("remote client quitting\n");
         // set client inactive

         add_game_move2(frame + 2, 2, data1, 64); // type 2 - player inactive


//         game_moves[game_move_entry_pos][0] = frame + 2; // need to set in future
//         game_moves[game_move_entry_pos][1] = 2;         // type 2 - player inactive
//         game_moves[game_move_entry_pos][2] = data1;     // player num
//         game_moves[game_move_entry_pos][3] = 64;        // inactive
//         game_move_entry_pos++;

         return; // to exit immediately
      }



      // everything else

      printf("everything else\n");


      add_game_move2(frame + 4, 2, data1, 64); // type 2 - player inactive


      // change menu key to player state inactive special move
//      game_moves[game_move_entry_pos][0] = frame + 4;  // add 2 frames so server has time to sync back to client before dropping
//      game_moves[game_move_entry_pos][1] = 2;          // type 2 - player inactive
//      game_moves[game_move_entry_pos][2] = data1;      // player num
//      game_moves[game_move_entry_pos][3] = 64;         // inactive
//      game_move_entry_pos++;
      return; // to exit immediately
   }


   // the normal method of simply entering the game move

   add_game_move2(frame, type, data1, data2);

//   game_moves[game_move_entry_pos][0] = frame;
//   game_moves[game_move_entry_pos][1] = type;
//   game_moves[game_move_entry_pos][2] = data1;
//   game_moves[game_move_entry_pos][3] = data2;
//   game_move_entry_pos++;
}




















not working
f:2699 p:1 scfgm gmep:2821 gmcp:2625 gmsi:2725
f:2700 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2700 p:1 scfgm gmep:2821 gmcp:2626 gmsi:2726
f:2701 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2701 p:1 scfgm gmep:2821 gmcp:2627 gmsi:2727
f:2702 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2702 p:1 scfgm gmep:2821 gmcp:2628 gmsi:2728
f:2703 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2703 p:1 scfgm gmep:2821 gmcp:2629 gmsi:2729
f:2704 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2704 p:1 scfgm gmep:2821 gmcp:2630 gmsi:2730
f:2705 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2705 p:1 scfgm gmep:2821 gmcp:2631 gmsi:2731
f:2706 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2706 p:1 scfgm gmep:2821 gmcp:2632 gmsi:2732
f:2707 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2707 p:1 scfgm gmep:2821 gmcp:2633 gmsi:2733
f:2708 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2708 p:1 scfgm gmep:2821 gmcp:2634 gmsi:2734
f:2709 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2709 p:1 scfgm gmep:2821 gmcp:2635 gmsi:2735
f:2710 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2710 p:1 scfgm gmep:2821 gmcp:2636 gmsi:2736
f:2711 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2711 p:1 scfgm gmep:2821 gmcp:2637 gmsi:2737
f:2712 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2712 p:1 scfgm gmep:2821 gmcp:2638 gmsi:2738
f:2713 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2713 p:1 scfgm gmep:2821 gmcp:2639 gmsi:2739
f:2714 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2714 p:1 scfgm gmep:2821 gmcp:2640 gmsi:2740
f:2715 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2715 p:1 scfgm gmep:2821 gmcp:2641 gmsi:2741
f:2716 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2716 p:1 scfgm gmep:2821 gmcp:2642 gmsi:2742
f:2717 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2717 p:1 scfgm gmep:2821 gmcp:2643 gmsi:2743
f:2718 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2718 p:1 scfgm gmep:2821 gmcp:2644 gmsi:2744
f:2719 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2719 p:1 scfgm gmep:2821 gmcp:2645 gmsi:2745
f:2720 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2720 p:1 scfgm gmep:2821 gmcp:2646 gmsi:2746
f:2721 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2721 p:1 scfgm gmep:2821 gmcp:2647 gmsi:2747
f:2722 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2722 p:1 scfgm gmep:2821 gmcp:2648 gmsi:2748
f:2723 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2723 p:1 scfgm gmep:2821 gmcp:2649 gmsi:2749
f:2724 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2724 p:1 scfgm gmep:2821 gmcp:2650 gmsi:2750
f:2725 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2725 p:1 scfgm gmep:2821 gmcp:2651 gmsi:2751
f:2726 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2726 p:1 scfgm gmep:2821 gmcp:2652 gmsi:2752
f:2727 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2727 p:1 scfgm gmep:2821 gmcp:2653 gmsi:2753
f:2728 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2728 p:1 scfgm gmep:2821 gmcp:2654 gmsi:2754
f:2729 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2729 p:1 scfgm gmep:2821 gmcp:2655 gmsi:2755
f:2730 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2730 p:1 scfgm gmep:2821 gmcp:2656 gmsi:2756
f:2731 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2731 p:1 scfgm gmep:2821 gmcp:2657 gmsi:2757
f:2732 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2732 p:1 scfgm gmep:2821 gmcp:2658 gmsi:2758
f:2733 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2733 p:1 scfgm gmep:2821 gmcp:2659 gmsi:2759
f:2734 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2734 p:1 scfgm gmep:2821 gmcp:2660 gmsi:2760
f:2735 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2735 p:1 scfgm gmep:2821 gmcp:2661 gmsi:2761
f:2736 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2736 p:1 scfgm gmep:2821 gmcp:2662 gmsi:2762
f:2737 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2737 p:1 scfgm gmep:2821 gmcp:2663 gmsi:2763
f:2738 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2738 p:1 scfgm gmep:2821 gmcp:2664 gmsi:2764
f:2739 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2739 p:1 scfgm gmep:2821 gmcp:2665 gmsi:2765
f:2740 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2740 p:1 scfgm gmep:2821 gmcp:2666 gmsi:2766
f:2741 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2741 p:1 scfgm gmep:2821 gmcp:2667 gmsi:2767
f:2742 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2742 p:1 scfgm gmep:2821 gmcp:2668 gmsi:2768
f:2743 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2743 p:1 scfgm gmep:2821 gmcp:2669 gmsi:2769
f:2744 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2744 p:1 scfgm gmep:2821 gmcp:2670 gmsi:2770
f:2745 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2745 p:1 scfgm gmep:2821 gmcp:2671 gmsi:2771
f:2746 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2746 p:1 scfgm gmep:2821 gmcp:2672 gmsi:2772
f:2747 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2747 p:1 scfgm gmep:2821 gmcp:2673 gmsi:2773
f:2748 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2748 p:1 scfgm gmep:2821 gmcp:2674 gmsi:2774
f:2749 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2749 p:1 scfgm gmep:2821 gmcp:2675 gmsi:2775
f:2750 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2750 p:1 scfgm gmep:2821 gmcp:2676 gmsi:2776
f:2751 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2751 p:1 scfgm gmep:2821 gmcp:2676 gmsi:2776
f:2752 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2752 p:1 scfgm gmep:2821 gmcp:2677 gmsi:2777
f:2753 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2753 p:1 scfgm gmep:2821 gmcp:2678 gmsi:2778
f:2754 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2754 p:1 scfgm gmep:2821 gmcp:2679 gmsi:2779
f:2755 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2755 p:1 scfgm gmep:2821 gmcp:2680 gmsi:2780
f:2756 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2756 p:1 scfgm gmep:2821 gmcp:2681 gmsi:2781
f:2757 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2757 p:1 scfgm gmep:2821 gmcp:2682 gmsi:2782
f:2758 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2758 p:1 scfgm gmep:2821 gmcp:2683 gmsi:2783
f:2759 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2759 p:1 scfgm gmep:2821 gmcp:2684 gmsi:2784
f:2760 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2760 p:1 scfgm gmep:2821 gmcp:2685 gmsi:2785
f:2761 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2761 p:1 scfgm gmep:2821 gmcp:2686 gmsi:2786
f:2762 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2762 p:1 scfgm gmep:2821 gmcp:2687 gmsi:2787
f:2763 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2763 p:1 scfgm gmep:2821 gmcp:2688 gmsi:2788
f:2764 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2764 p:1 scfgm gmep:2821 gmcp:2689 gmsi:2789
f:2765 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2765 p:1 scfgm gmep:2821 gmcp:2690 gmsi:2790
f:2766 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2766 p:1 scfgm gmep:2821 gmcp:2691 gmsi:2791
f:2767 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2767 p:1 scfgm gmep:2821 gmcp:2692 gmsi:2792
f:2768 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2768 p:1 scfgm gmep:2821 gmcp:2693 gmsi:2793
f:2769 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2769 p:1 scfgm gmep:2821 gmcp:2694 gmsi:2794
f:2770 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2770 p:1 scfgm gmep:2821 gmcp:2695 gmsi:2795
f:2771 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2771 p:1 scfgm gmep:2821 gmcp:2696 gmsi:2796
f:2772 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2772 p:1 scfgm gmep:2821 gmcp:2697 gmsi:2797
f:2773 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2773 p:1 scfgm gmep:2821 gmcp:2698 gmsi:2798
f:2774 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2774 p:1 scfgm gmep:2821 gmcp:2699 gmsi:2799
f:2775 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2775 p:1 scfgm gmep:2821 gmcp:2700 gmsi:2800
f:2776 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2776 p:1 scfgm gmep:2821 gmcp:2700 gmsi:2800
f:2777 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2777 p:1 scfgm gmep:2821 gmcp:2701 gmsi:2801
f:2778 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2778 p:1 scfgm gmep:2821 gmcp:2702 gmsi:2802
f:2779 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2779 p:1 scfgm gmep:2821 gmcp:2703 gmsi:2803
f:2780 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2780 p:1 scfgm gmep:2821 gmcp:2704 gmsi:2804
f:2781 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2781 p:1 scfgm gmep:2821 gmcp:2705 gmsi:2805
f:2782 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2782 p:1 scfgm gmep:2821 gmcp:2706 gmsi:2806
f:2783 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2783 p:1 scfgm gmep:2821 gmcp:2707 gmsi:2807
f:2784 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2784 p:1 scfgm gmep:2821 gmcp:2708 gmsi:2808
f:2785 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2785 p:1 scfgm gmep:2821 gmcp:2709 gmsi:2809
f:2786 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2786 p:1 scfgm gmep:2821 gmcp:2710 gmsi:2810
f:2787 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2787 p:1 scfgm gmep:2821 gmcp:2711 gmsi:2811
f:2788 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2788 p:1 scfgm gmep:2821 gmcp:2712 gmsi:2812
f:2789 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2789 p:1 scfgm gmep:2821 gmcp:2713 gmsi:2813
f:2790 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2790 p:1 scfgm gmep:2821 gmcp:2714 gmsi:2814
f:2791 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2791 p:1 scfgm gmep:2821 gmcp:2715 gmsi:2815
f:2792 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2792 p:1 scfgm gmep:2821 gmcp:2716 gmsi:2816
f:2793 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2793 p:1 scfgm gmep:2821 gmcp:2717 gmsi:2817
f:2794 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2794 p:1 scfgm gmep:2821 gmcp:2718 gmsi:2818
f:2795 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2795 p:1 scfgm gmep:2821 gmcp:2719 gmsi:2819
f:2796 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2796 p:1 scfgm gmep:2821 gmcp:2720 gmsi:2820
f:2797 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2797 p:1 scfgm gmep:2821 gmcp:2721 gmsi:2820
f:2798 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2798 p:1 scfgm gmep:2821 gmcp:2722 gmsi:2820
f:2799 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2799 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2800 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2800 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2801 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2801 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2802 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2802 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2803 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2803 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2804 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2804 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2805 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2805 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2806 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2806 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2807 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2807 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2808 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2808 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2809 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2809 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2810 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2810 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2811 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2811 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2812 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2812 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2813 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2813 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2814 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2814 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2815 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2815 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2816 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2816 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2817 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2817 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2818 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2818 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2819 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2819 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2820 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2820 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2821 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2821 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2822 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2822 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2823 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2823 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2824 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2824 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2825 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2825 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2826 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2826 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2827 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2827 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2828 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2828 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2829 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2829 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2830 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2830 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2831 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2831 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2832 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2832 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2833 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2833 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2834 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2834 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2835 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2835 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2836 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2836 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2837 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2837 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2838 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2838 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2839 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2839 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2840 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2840 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2841 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723
f:2841 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2842 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2723





working:
f:2699 p:1 scfgm gmep:2821 gmcp:2625 gmsi:2820
f:2700 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2700 p:1 scfgm gmep:2821 gmcp:2626 gmsi:2820
f:2701 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2701 p:1 scfgm gmep:2821 gmcp:2627 gmsi:2820
f:2702 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2702 p:1 scfgm gmep:2821 gmcp:2628 gmsi:2820
f:2703 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2703 p:1 scfgm gmep:2821 gmcp:2629 gmsi:2820
f:2704 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2704 p:1 scfgm gmep:2821 gmcp:2630 gmsi:2820
f:2705 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2705 p:1 scfgm gmep:2821 gmcp:2631 gmsi:2820
f:2706 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2706 p:1 scfgm gmep:2821 gmcp:2632 gmsi:2820
f:2707 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2707 p:1 scfgm gmep:2821 gmcp:2633 gmsi:2820
f:2708 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2708 p:1 scfgm gmep:2821 gmcp:2634 gmsi:2820
f:2709 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2709 p:1 scfgm gmep:2821 gmcp:2635 gmsi:2820
f:2710 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2710 p:1 scfgm gmep:2821 gmcp:2636 gmsi:2820
f:2711 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2711 p:1 scfgm gmep:2821 gmcp:2637 gmsi:2820
f:2712 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2712 p:1 scfgm gmep:2821 gmcp:2638 gmsi:2820
f:2713 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2713 p:1 scfgm gmep:2821 gmcp:2639 gmsi:2820
f:2714 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2714 p:1 scfgm gmep:2821 gmcp:2640 gmsi:2820
f:2715 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2715 p:1 scfgm gmep:2821 gmcp:2641 gmsi:2820
f:2716 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2716 p:1 scfgm gmep:2821 gmcp:2642 gmsi:2820
f:2717 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2717 p:1 scfgm gmep:2821 gmcp:2643 gmsi:2820
f:2718 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2718 p:1 scfgm gmep:2821 gmcp:2644 gmsi:2820
f:2719 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2719 p:1 scfgm gmep:2821 gmcp:2645 gmsi:2820
f:2720 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2720 p:1 scfgm gmep:2821 gmcp:2646 gmsi:2820
f:2721 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2721 p:1 scfgm gmep:2821 gmcp:2647 gmsi:2820
f:2722 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2722 p:1 scfgm gmep:2821 gmcp:2648 gmsi:2820
f:2723 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2723 p:1 scfgm gmep:2821 gmcp:2649 gmsi:2820
f:2724 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2724 p:1 scfgm gmep:2821 gmcp:2650 gmsi:2820
f:2725 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2725 p:1 scfgm gmep:2821 gmcp:2651 gmsi:2820
f:2726 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2726 p:1 scfgm gmep:2821 gmcp:2652 gmsi:2820
f:2727 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2727 p:1 scfgm gmep:2821 gmcp:2653 gmsi:2820
f:2728 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2728 p:1 scfgm gmep:2821 gmcp:2654 gmsi:2820
f:2729 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2729 p:1 scfgm gmep:2821 gmcp:2655 gmsi:2820
f:2730 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2730 p:1 scfgm gmep:2821 gmcp:2656 gmsi:2820
f:2731 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2731 p:1 scfgm gmep:2821 gmcp:2657 gmsi:2820
f:2732 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2732 p:1 scfgm gmep:2821 gmcp:2658 gmsi:2820
f:2733 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2733 p:1 scfgm gmep:2821 gmcp:2659 gmsi:2820
f:2734 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2734 p:1 scfgm gmep:2821 gmcp:2660 gmsi:2820
f:2735 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2735 p:1 scfgm gmep:2821 gmcp:2661 gmsi:2820
f:2736 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2736 p:1 scfgm gmep:2821 gmcp:2662 gmsi:2820
f:2737 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2737 p:1 scfgm gmep:2821 gmcp:2663 gmsi:2820
f:2738 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2738 p:1 scfgm gmep:2821 gmcp:2664 gmsi:2820
f:2739 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2739 p:1 scfgm gmep:2821 gmcp:2665 gmsi:2820
f:2740 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2740 p:1 scfgm gmep:2821 gmcp:2666 gmsi:2820
f:2741 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2741 p:1 scfgm gmep:2821 gmcp:2667 gmsi:2820
f:2742 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2742 p:1 scfgm gmep:2821 gmcp:2668 gmsi:2820
f:2743 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2743 p:1 scfgm gmep:2821 gmcp:2669 gmsi:2820
f:2744 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2744 p:1 scfgm gmep:2821 gmcp:2670 gmsi:2820
f:2745 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2745 p:1 scfgm gmep:2821 gmcp:2671 gmsi:2820
f:2746 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2746 p:1 scfgm gmep:2821 gmcp:2672 gmsi:2820
f:2747 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2747 p:1 scfgm gmep:2821 gmcp:2673 gmsi:2820
f:2748 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2748 p:1 scfgm gmep:2821 gmcp:2674 gmsi:2820
f:2749 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2749 p:1 scfgm gmep:2821 gmcp:2675 gmsi:2820
f:2750 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2750 p:1 scfgm gmep:2821 gmcp:2676 gmsi:2820
f:2751 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2751 p:1 scfgm gmep:2821 gmcp:2676 gmsi:2820
f:2752 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2752 p:1 scfgm gmep:2821 gmcp:2677 gmsi:2820
f:2753 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2753 p:1 scfgm gmep:2821 gmcp:2678 gmsi:2820
f:2754 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2754 p:1 scfgm gmep:2821 gmcp:2679 gmsi:2820
f:2755 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2755 p:1 scfgm gmep:2821 gmcp:2680 gmsi:2820
f:2756 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2756 p:1 scfgm gmep:2821 gmcp:2681 gmsi:2820
f:2757 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2757 p:1 scfgm gmep:2821 gmcp:2682 gmsi:2820
f:2758 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2758 p:1 scfgm gmep:2821 gmcp:2683 gmsi:2820
f:2759 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2759 p:1 scfgm gmep:2821 gmcp:2684 gmsi:2820
f:2760 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2760 p:1 scfgm gmep:2821 gmcp:2685 gmsi:2820
f:2761 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2761 p:1 scfgm gmep:2821 gmcp:2686 gmsi:2820
f:2762 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2762 p:1 scfgm gmep:2821 gmcp:2687 gmsi:2820
f:2763 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2763 p:1 scfgm gmep:2821 gmcp:2688 gmsi:2820
f:2764 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2764 p:1 scfgm gmep:2821 gmcp:2689 gmsi:2820
f:2765 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2765 p:1 scfgm gmep:2821 gmcp:2690 gmsi:2820
f:2766 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2766 p:1 scfgm gmep:2821 gmcp:2691 gmsi:2820
f:2767 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2767 p:1 scfgm gmep:2821 gmcp:2692 gmsi:2820
f:2768 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2768 p:1 scfgm gmep:2821 gmcp:2693 gmsi:2820
f:2769 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2769 p:1 scfgm gmep:2821 gmcp:2694 gmsi:2820
f:2770 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2770 p:1 scfgm gmep:2821 gmcp:2695 gmsi:2820
f:2771 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2771 p:1 scfgm gmep:2821 gmcp:2696 gmsi:2820
f:2772 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2772 p:1 scfgm gmep:2821 gmcp:2697 gmsi:2820
f:2773 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2773 p:1 scfgm gmep:2821 gmcp:2698 gmsi:2820
f:2774 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2774 p:1 scfgm gmep:2821 gmcp:2699 gmsi:2820
f:2775 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2775 p:1 scfgm gmep:2821 gmcp:2700 gmsi:2820
f:2776 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2776 p:1 scfgm gmep:2821 gmcp:2700 gmsi:2820
f:2777 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2777 p:1 scfgm gmep:2821 gmcp:2701 gmsi:2820
f:2778 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2778 p:1 scfgm gmep:2821 gmcp:2702 gmsi:2820
f:2779 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2779 p:1 scfgm gmep:2821 gmcp:2703 gmsi:2820
f:2780 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2780 p:1 scfgm gmep:2821 gmcp:2704 gmsi:2820
f:2781 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2781 p:1 scfgm gmep:2821 gmcp:2705 gmsi:2820
f:2782 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2782 p:1 scfgm gmep:2821 gmcp:2706 gmsi:2820
f:2783 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2783 p:1 scfgm gmep:2821 gmcp:2707 gmsi:2820
f:2784 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2784 p:1 scfgm gmep:2821 gmcp:2708 gmsi:2820
f:2785 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2785 p:1 scfgm gmep:2821 gmcp:2709 gmsi:2820
f:2786 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2786 p:1 scfgm gmep:2821 gmcp:2710 gmsi:2820
f:2787 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2787 p:1 scfgm gmep:2821 gmcp:2711 gmsi:2820
f:2788 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2788 p:1 scfgm gmep:2821 gmcp:2712 gmsi:2820
f:2789 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2789 p:1 scfgm gmep:2821 gmcp:2713 gmsi:2820
f:2790 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2790 p:1 scfgm gmep:2821 gmcp:2714 gmsi:2820
f:2791 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2791 p:1 scfgm gmep:2821 gmcp:2715 gmsi:2820
f:2792 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2792 p:1 scfgm gmep:2821 gmcp:2716 gmsi:2820
f:2793 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2793 p:1 scfgm gmep:2821 gmcp:2717 gmsi:2820
f:2794 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2794 p:1 scfgm gmep:2821 gmcp:2718 gmsi:2820
f:2795 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2795 p:1 scfgm gmep:2821 gmcp:2719 gmsi:2820
f:2796 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2796 p:1 scfgm gmep:2821 gmcp:2720 gmsi:2820
f:2797 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2797 p:1 scfgm gmep:2821 gmcp:2721 gmsi:2820
f:2798 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2798 p:1 scfgm gmep:2821 gmcp:2722 gmsi:2820
f:2799 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2799 p:1 scfgm gmep:2821 gmcp:2723 gmsi:2820
f:2800 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2800 p:1 scfgm gmep:2821 gmcp:2724 gmsi:2820
f:2801 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2801 p:1 scfgm gmep:2821 gmcp:2725 gmsi:2820
f:2802 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2802 p:1 scfgm gmep:2821 gmcp:2726 gmsi:2820
f:2803 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2803 p:1 scfgm gmep:2821 gmcp:2727 gmsi:2820
f:2804 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2804 p:1 scfgm gmep:2821 gmcp:2728 gmsi:2820
f:2805 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2805 p:1 scfgm gmep:2821 gmcp:2729 gmsi:2820
f:2806 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2806 p:1 scfgm gmep:2821 gmcp:2730 gmsi:2820
f:2807 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2807 p:1 scfgm gmep:2821 gmcp:2731 gmsi:2820
f:2808 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2808 p:1 scfgm gmep:2821 gmcp:2732 gmsi:2820
f:2809 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2809 p:1 scfgm gmep:2821 gmcp:2733 gmsi:2820
f:2810 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2810 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2811 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2811 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2812 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2812 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2813 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2813 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2814 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2814 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2815 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2815 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2816 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2816 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2817 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2817 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2818 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2818 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2819 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2819 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2820 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2820 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2821 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2821 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2822 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2822 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2823 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2823 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2824 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2824 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2825 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2825 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2826 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2826 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2827 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2827 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2828 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2828 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2829 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2829 p:1 scfgm gmep:2821 gmcp:2734 gmsi:2820
f:2830 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2830 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2831 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2831 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2832 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2832 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2833 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2833 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2834 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2834 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2835 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2835 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2836 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2836 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2837 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2837 p:1 scfgm gmep:2821 gmcp:2735 gmsi:2820
f:2838 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2838 p:1 scfgm gmep:2821 gmcp:2736 gmsi:2820
f:2839 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2839 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2840 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2840 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2841 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2841 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2842 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2842 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2843 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2843 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2844 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2844 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2845 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2845 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2846 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2846 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2847 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2847 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2848 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2848 p:1 scfgm gmep:2821 gmcp:2737 gmsi:2820
f:2849 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2849 p:1 scfgm gmep:2821 gmcp:2738 gmsi:2820
f:2850 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2850 p:1 scfgm gmep:2821 gmcp:2738 gmsi:2820
f:2851 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2851 p:1 scfgm gmep:2821 gmcp:2738 gmsi:2820
f:2852 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2852 p:1 scfgm gmep:2821 gmcp:2738 gmsi:2820
f:2853 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2853 p:1 scfgm gmep:2821 gmcp:2738 gmsi:2820
f:2854 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2854 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2855 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2855 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2856 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2856 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2857 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2857 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2858 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2858 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2859 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2859 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2860 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2860 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2861 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2861 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2862 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2862 p:1 scfgm gmep:2821 gmcp:2739 gmsi:2820
f:2863 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2863 p:1 scfgm gmep:2821 gmcp:2740 gmsi:2820
f:2864 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2864 p:1 scfgm gmep:2821 gmcp:2740 gmsi:2820
f:2865 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2865 p:1 scfgm gmep:2821 gmcp:2740 gmsi:2820
f:2866 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2866 p:1 scfgm gmep:2821 gmcp:2740 gmsi:2820
f:2867 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2867 p:1 scfgm gmep:2821 gmcp:2740 gmsi:2820
f:2868 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2868 p:1 scfgm gmep:2821 gmcp:2741 gmsi:2820
f:2869 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2869 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2870 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2870 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2871 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2871 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2872 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2872 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2873 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2873 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2874 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2874 p:1 scfgm gmep:2821 gmcp:2742 gmsi:2820
f:2875 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2875 p:1 scfgm gmep:2821 gmcp:2743 gmsi:2820
f:2876 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2876 p:1 scfgm gmep:2821 gmcp:2743 gmsi:2820
f:2877 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2877 p:1 scfgm gmep:2821 gmcp:2743 gmsi:2820
f:2878 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2878 p:1 scfgm gmep:2821 gmcp:2743 gmsi:2820
f:2879 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2879 p:1 scfgm gmep:2821 gmcp:2744 gmsi:2820
f:2880 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2880 p:1 scfgm gmep:2821 gmcp:2744 gmsi:2820
f:2881 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2881 p:1 scfgm gmep:2821 gmcp:2744 gmsi:2820
f:2882 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2882 p:1 scfgm gmep:2821 gmcp:2744 gmsi:2820
f:2883 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2883 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2884 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2884 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2885 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2885 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2886 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2886 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2887 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2887 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2888 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2888 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2889 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2889 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2890 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2890 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2891 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2891 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2892 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2892 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2893 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2893 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2894 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2894 p:1 scfgm gmep:2821 gmcp:2745 gmsi:2820
f:2895 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2895 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2896 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2896 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2897 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2897 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2898 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2898 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2899 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2899 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2900 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2900 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2901 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2901 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2902 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2902 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2903 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2903 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2904 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2904 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2905 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2905 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2906 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2906 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2907 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2907 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2908 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2908 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2909 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2909 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820
f:2910 p:0 scfgm gmep:2821 gmcp:2623 gmsi:2820
f:2910 p:1 scfgm gmep:2821 gmcp:2746 gmsi:2820







I think I am getting it now...

gmcp is different for each player

it is the index of the last game move used to set the player controls

it could possibly be valid if we were saving it for each player instead of common

no, even that is flawed...






I think I want to redo the methods I use to set controls and process game moves from the game moves array..

for starters, there are 2 methods..

void set_controls_from_game_move(int p)
- called once per frame per player
- looks gme with greatest mwPS.frame_num that is <= current mwPS.frame_num


void proc_game_move(void)
- called once per frame
- only concerned with exact frame matches


- I cannot guarantee that the game_moves array has all mwPS.frame_num in order

- I don't want to search the entire game_moves array every time

Most of the time I start the search at the end, the most recent entry.
The only exception would be rungame, where the current_pos is less than the end..


In trying to refine the search start and end...
In all modes, except for rungame, set it at the end..

To make it work in rungame:
keep game_move_current_pos, but make it so that when any game_move_entry is used to set player's controls only update game_move_current_pos if it is greater


Do I really need to search back like this?

What if they are out of order?



After being away for a while and thinking about it, I think I understand it now.

Write up a thorough description of how game moves are read from the game moves array and applied.

How many types of games are there where stuff is being read from game moves array?
Single Player
Server
Rungame

Client does not read from game moves array any more...

You can tell what mode you are in by the control method of player 0, which always exists.

0 Single Player
3 Server
1 Rungame

For modes 0 and 3, search back from end (game_move_entry_pos) until move that matches player and is not in the future

For mode 1











------------------

wait...I am trybing to do something better am I not?


I propose a single search back through the game moves array for all players and special game moves.

First I will need to determine the search start and end.

Start:
Same as the other...gmep in mode 0 and 3...gmcp+100 in mode 1

End:
when frames of gm are 100 less than current frame




what to do when a match is found?

apply special moves only when exact match is found
apply game moves only when exact match is found (otherwise don't touch controls)


this will be a big change from clearing and finding most recent from current mwPS.frame_num back and applying


make a function like this to replace both

modifiy current_pos to never go back...

I did this and it works for all modes so far:

// this function processes all entries in the game_moves array that match current mwPS.frame_num
void proc_game_moves_array(void)
{
   int start_index = game_move_current_pos + 100;
   if (start_index > game_move_entry_pos-1) start_index = game_move_entry_pos-1;

   int end_index = game_move_current_pos - 100;
   if (end_index < 0) end_index = 0;

   for (int x=start_index; x>=end_index; x--)  // search backwards from start_index to end_index
   {
      if (game_moves[x][0] == mwPS.frame_num) // found frame number that matches current frame
      {
         if (x > game_move_current_pos) game_move_current_pos = x; // index of last used gm - keep this at the most recent one, never go back
         switch (game_moves[x][1])
         {
            case 1: proc_player_active_game_move(x); break;
            case 2: proc_player_inactive_game_move(x); break;
            case 3: proc_player_client_join_game_move(x); break;
            case 4: proc_player_client_quit_game_move(x); break;
            case 5: set_controls_from_comp_move(game_moves[x][2], game_moves[x][3]); break;
         }
      }
   }
}


is is called from proc_controllers() like this...

proc_player_input(ret);
if (!ima_client) proc_game_moves_array();  // run once per frame to process game_moves_array (except client)

and also in

void loop_frame(void)
{
   proc_game_moves_array();



document what you are removing:

void loop_frame(void)
{
   proc_game_moves_array();

//   proc_game_move();

   if (players[0].level_done_mode) proc_level_done_mode();

//   for (int p=0; p<NUM_PLAYERS; p++)
//      if (players[p].active) // cycle all active players
//         set_controls_from_game_move(p); // common for all players

   move_frame();
   mwPS.frame_num++;
}





void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5)) // only allow player input in these modes
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
               }
            }
         }
         if (players[p].control_method == 1) rungame_key_check(p, ret); // run game from file
         if (players[p].control_method == 3) server_local_control(p);
         if (players[p].control_method == 4) client_local_control(p);


//         // what is this check for ?
//         // only set controls if actually playing the game, not in level_done_mode
//         if (players[0].level_done_mode == 0)
//         {
//            // local client is an exception that sets controls directly
//          if (players[p].control_method != 4) set_controls_from_game_move(p); // common for all control methods except local client
//         }
      }
}

int proc_controllers()
{
   int ret=0, menu_timer_block=1;
   mI.key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work properly
   key_pressed_ASCII = 0;


   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_block = 0;
            else ret = proc_events(ev, ret);
         }
      }
      function_key_check();
      if (game_exit) // if not called from game only do key check for active local player
      {
          clear_controls(active_local_player);
          set_controls_from_player_key_check(active_local_player);
      }
      else // game is in progress
      {
         menu_timer_block = 0;
         proc_player_input(ret);
         if (!ima_client) proc_game_moves_array();  // run once per frame to process game_moves_array (except client)

//         if (!ima_client) proc_game_move();  // run once per frame to process system messages from game_move (client should never have system messages)
      }
   }
   return ret;
}



//
//void proc_game_move(void)
//{
//   // this function looks in the game_moves array for an exact mwPS.frame_num match
//   // this only processes system moves, not regular game_moves
//   // its likely that no exact mwPS.frame_num match will be found and nothing will be done
//   // if multiple frame_nums match they all will be processed
//
//   int ll;
//   if (players[0].control_method == 1) ll = 0; // run game needs to look back to the start
//   else ll = game_move_entry_pos - 100; // every other mode can just look back 100
//   if (ll < 0) ll = 0; // don't look back past zero!
//
//   for (int x=game_move_entry_pos; x>=ll; x--)  // look back for mwPS.frame_num
//   {
//      if (game_moves[x][0] == mwPS.frame_num)
//      {
//         switch (game_moves[x][1])
//         {
//            case 1: proc_player_active_game_move(x); break;
//            case 2: proc_player_inactive_game_move(x); break;
//            case 3: proc_player_client_join_game_move(x); break;
//            case 4: proc_player_client_quit_game_move(x); break;
//         }
//      }
//   }
//}
//
//
//void set_controls_from_game_move(int p)
//{
//   // search back from game_move_entry_pos until first 'move' type entry that matches player and is not in the future
//   int gme_search_index = game_move_entry_pos - 1;
//
//   // in rungame mode game_move_entry_pos is always at the end of the already filled array
//   // it can take a long time to search backwards through the entire array, so set the search position 100 moves in the future
//
//   if (players[p].control_method == 1)
//   {
//      gme_search_index = game_move_current_pos + 100;
//      if (gme_search_index > game_move_entry_pos-1) gme_search_index = game_move_entry_pos-1;
//   }
//
//
////   sprintf(msg, "f:%d p:%d scfgm gmep:%d gmcp:%d gmsi:%d", mwPS.frame_num, p, game_move_entry_pos, game_move_current_pos, gme_search_index);
////   add_log_entry2(10, p, msg);
////
////   printf("%s\n", msg);
//
//   int found = 0;
//   for (int g=gme_search_index; g>0; g--)  // look back from entry pos
//      if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
//         if (game_moves[g][0] <= mwPS.frame_num) // check to make sure its not in the future
//         {
//            set_controls_from_comp_move(p, game_moves[g][3]);
//
//
//            if (g > game_move_current_pos) game_move_current_pos = g; // // for savegame running only - keep this at the most recent one, never go back
//
////            game_move_current_pos = g; // for savegame running only
//
//            g = 0; // break out of loop
//            found = 1;
//         }
//   if (!found) clear_controls(p); // if no match found (no move entry for player in entire game move array)
//
//   // in run game mode and past the end of the file
//   if ((players[p].control_method == 1) && (mwPS.frame_num > demo_mode_last_frame)) clear_controls(p);
//
//   // do not allow any controls in this mode
//   if (players[0].level_done_mode) clear_controls(p);
//
//
//}



wow, this really simplified things...

lets try a really long muliplayer with many clients doing different things...

lev 36 8P 1178s

player 7 was kind of weird and slow jj all others were fine
when game ended with level done and all acked the game crashed hard and no logs or savegame were stored.
also on the ending zoom into the level, p2 (ubuntu) was the only one that grew instead of shrinking

test a much shorter example of level done...
tried 2 and 3 player games with ubuntu and all level done seems to work fine...???


now what?  harder tests??






find out how I can do more in common with all these 3 methods


if (players[p].control_method == 0) // local single player control
{
   if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5)) // only allow player input in these modes
   {
      set_comp_move_from_player_key_check(p);
      if (players1[p].comp_move != players1[p].old_comp_move)
      {
         players1[p].old_comp_move = players1[p].comp_move;
         add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
      }
   }
}





void server_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if (players1[p].fake_keypress_mode) players1[p].comp_move = rand() % 64;

   if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5))  // only allow player input in these modes
   {
      if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
      {
         players1[p].old_comp_move = players1[p].comp_move;
         add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);
      }
   }
}


void client_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if (players1[p].fake_keypress_mode) players1[p].comp_move = rand() % 64;

   if (players1[p].old_comp_move != players1[p].comp_move)  // player's controls have changed
   {
      players1[p].old_comp_move = players1[p].comp_move;

      if (players[0].level_done_mode == 0) set_controls_from_comp_move(p, players1[p].comp_move);
      else clear_controls(p);

      if (players[p].menu) game_exit = 1;

      if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5))
      {
         Packet("cdat");
         PacketPut1ByteInt(p);
         PacketPut4ByteInt(mwPS.frame_num);
         PacketPut1ByteInt(players1[p].comp_move);
         ClientSend(packetbuffer, packetsize);

         players1[p].client_cdat_packets_tx++;
         sprintf(msg,"tx cdat - move:%d\n", players1[p].comp_move);
         if (L_LOGGING_NETPLAY_cdat) add_log_entry2(35, p, msg);
      }
   }
}




this is what I came up with to replace all that


void proc_player_input(int ret)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         int cm = players[p].control_method;
         if (cm == 1) rungame_key_check(p, ret); // run game from file
         if ((cm == 0) || (cm == 3) || (cm == 4)) // single player, server, client
         {
            if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5)) // only allow player input in these modes
            {
               if (players1[p].fake_keypress_mode) players1[p].comp_move = rand() % 64;
               else set_comp_move_from_player_key_check(p);
               if (players1[p].old_comp_move != players1[p].comp_move)  // player's controls have changed
               {
                  players1[p].old_comp_move = players1[p].comp_move;

                  // in single player and server mode, add to game moves array
                  if ((cm == 0) || (cm == 3)) add_game_move(mwPS.frame_num, 5, p, players1[p].comp_move);

                  // in client mode, send cdat packet, and apply move directly to controls
                  if (cm == 3)
                  {
                     Packet("cdat");
                     PacketPut1ByteInt(p);
                     PacketPut4ByteInt(mwPS.frame_num);
                     PacketPut1ByteInt(players1[p].comp_move);
                     ClientSend(packetbuffer, packetsize);

                     if (players[0].level_done_mode == 0) set_controls_from_comp_move(p, players1[p].comp_move);
                     else clear_controls(p);

                     if (players[p].menu) game_exit = 1;

                     players1[p].client_cdat_packets_tx++;
                     sprintf(msg,"tx cdat - move:%d\n", players1[p].comp_move);
                     if (L_LOGGING_NETPLAY_cdat) add_log_entry2(35, p, msg);

                  }
               }
            }
         }
      }
}

wow, even less lines of code!!


now, do some more tests


don't forget to do a push later....



did an 8 player game lots of fake key...no errors but did not end where I thought it should...p1 exited when I played it but on replay 4 enemies were still alive

also after game ends enemies were still moving??


20221220 22:00 too tired...go to bed after a push...test tomorrow....

20221221 6:30 -35 outside...I plan to stay home and program all day


what happens when server rewinds then plays back and does not find exact frame match in gm?
it keeps current controls which may not be the right ones...
each player could save last gm index used to apply controls
then if that occurs in the future, due to rewind, then the player will need to look back further
no....
that new player struct variable will be rewound also as well as the controls
....so...because the controls are being rewound, there actually should be no problem....

unless...what about when base is lost and we have to restore from zero?
will that make any difference?

if I have any problem, why don't I just open the start and end wide open?
am I prematurely optimizing?

worst case I have close to 1 million game move entries
I will only do one pass per frame, not like before when I did one per player per frame...






why does the game still move after level_done?

tried some simple examples and they freeze like expected




add more logging...like in proc_game_moves_array

need a new type..use 40...


make it so that I can log in rungame mode also...

where do I do that?

comment out the erase_log here:

            if (options_menu_sel == 13) // run game
            {
               if (load_gm("-"))
               {
                  game_loop(9); // demo game

                  // reset player data
                  for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
                  players[0].active = 1;
                  active_local_player = 0;
                  load_config(); // restore player color from config file
                  //erase_log();
               }
            }


make it so that pm -f starts game in file select for run game...done

remove some RELEASE tags...done...


logging for rungame

add tag 40 in log file viewer done...
I want to know what the max search needed before I found a match..



more testing...

3P lev 150 fake key , played back quite differently...

removed the reduced game move search and still played back differently...

stared at the code for a while and nothing jumps out...

what about the search back thing I used to do?

server always has a state copy to go back to when rewinding, can never be overwritten
gets the controls for that state, then plays forward...


how does it normally work? move then frame inc? compare with loop_frame
normal:
move, then call to proc_frame_delay that incs mwPS.frame_num

loop_frame
move then manually inc mwPS.frame_num

added int last_gm_index to player1




made a bunch of changes and did a test that seemed to work...

I wish I knew what changes made it work...

l 150 3P fk
[1918][1188]
p1 exit

test more
l 150 3P fk
p1 exit
[2379][1448]
did not end up the same...

so what ever the problem is, I have not fixed it by the changes I have made



whenever a rewind happens corrections get applied

this is probably normal...
game moves are arriving too late to be processed with exact matches??
but the server applies them when rewind happens??
no, the server applies them with the normal game move array function

- 282 rewind and apply all moves
- 283 correction from gm with frame 282
- 284 correction from gm with frame 283
- 285 rewind and apply all moves

Is this correct?

will this play back the same??
no, when it is getting corrected the changes are occuring a frame late...
...but when it is rewound and replayed that should be the same as the demo play...right?

the only thing this look back for game moves is doing is modifying the server state (incorrectly) with late client input
but this should not matter because the rewind should fix that


where in the loop is the server doing the rewind?

server_control();                       <-- rewind and send stdf
proc_controllers();                     <-- proc game_move
move_frame();
if (proc_frame_delay()) draw_frame();   <-- inc mwPS.frame_num


what if the server is sending stuff based on a fresh frame num that nothing has happened for yet?

I am a little scared to change the order of things...

what seems most logical?

- get all input


- move all things (unless time for a rewind, then rewind and move all things)

- server send and rewind

- draw, pause and inc frame


this looks like I would do better making the server receive at the top of the loop (or async)

then local input

then rewind, move, send

then pause and draw and inc frame


is this important enough to change??

easy...

make the server receive loop seperate and call it at the top.



wow, why is this so tough??

what it all comes down to is that what the server puts into the game_moves array cannot be played back to get the same result
why? if I knew that...


at the beginning of send stdf

move has just been completed for the current frame

then stdf which does rewind

then draw frame which incs frame num


the rewind sets the frame back to the start

then calls loop frame which does the move, then incs mwPS.frame_num
this means that when it ends up on the same frame num as it starts, it has not actually done the move for that frame...

this seems very much like what the probem is...

how to fix...

do one extra then dec mwPS.frame_num ?


         while (mwPS.frame_num <= saved_current_frame_num) loop_frame(); // fast forward



      }
      mwPS.frame_num--;

      printf("rw2:%d\n", mwPS.frame_num);




this did not magically fix everything...


I am pretty sure that this is how it should be...just look at the previous reason



could it be that on the server, if cdats come late they are not played with rewind, but in demo mode they are....

that sounds likely...

on the server, if you get a cdat earlier than the last rewind, don't apply it...
no late but many right on time???


what is the timing for this

rx cdat puts in game move array

proc_controllers() does proc game moves array

then move_frame

then server rewinds...


move frame:58-------------
move frame:59-------------
move frame:60-------------
rw1:60 57
move frame:57-------------
move frame:58-------------
move frame:59-------------
move frame:60-------------
rw2:60 57

move frame:61-------------
move frame:62-------------
move frame:63-------------
rw1:63 60
move frame:60-------------
move frame:61-------------
move frame:62-------------
move frame:63-------------
rw2:63 60

move frame:64-------------
move frame:65-------------
move frame:66-------------
rw1:66 63
move frame:63-------------
move frame:64-------------
move frame:65-------------
move frame:66-------------
rw2:66 63

move frame:67-------------



time to run down hall
7s single player
5s server

8s single player
6s server
rungame 8s

why is server faster?


move frame:0-------------
0 rewind to:0
saved server state:0

move frame:1-------------
move frame:2-------------
move frame:3-------------
3 rewind to:0
loaded server state:0
move frame:0-------------
move frame:1-------------
move frame:2-------------
move frame:3-------------
saved server state:3

move frame:4-------------
move frame:5-------------
move frame:6-------------
6 rewind to:3
loaded server state:3
move frame:3-------------
move frame:4-------------
move frame:5-------------
move frame:6-------------
saved server state:6

move frame:7-------------
move frame:8-------------
move frame:9-------------
9 rewind to:6
loaded server state:6
move frame:6-------------
move frame:7-------------
move frame:8-------------
move frame:9-------------
saved server state:9

I think I am doing double moves

rewind to state 3, then do state 3 again...

not what I want..

when frame 3 is saved move has been done, then I load it and do move 3 again...



loaded server state:48
move frame:49-------------
move frame:50-------------
move frame:51-------------
saved server state:51

move frame:52-------------
move frame:53-------------
move frame:54-------------
54 rewind to:51
loaded server state:51
move frame:52-------------
move frame:53-------------
move frame:54-------------
saved server state:54

move frame:55-------------
move frame:56-------------
move frame:57-------------
57 rewind to:54
loaded server state:54
move frame:55-------------
move frame:56-------------
move frame:57-------------
saved server state:57


ok maybe that has been fixed...it seems to work...

clean up the code...

moved mwPS.frame_num++ to the start of loop_frame

removed inc, dec and tests from rewind

seems to work..





69 rewind to:66
loaded server state:66
move frame:67-------------
move frame:68-------------
move frame:69-------------
saved server state:69

move frame:70-------------
move frame:71-------------
move frame:72-------------
72 rewind to:69
loaded server state:69
move frame:70-------------
move frame:71-------------
move frame:72-------------
saved server state:72

move frame:73-------------
move frame:74-------------
move frame:75-------------
75 rewind to:72
loaded server state:72
move frame:73-------------
move frame:74-------------
move frame:75-------------
saved server state:75

move frame:76-------------
move frame:77-------------
move frame:78-------------
78 rewind to:75
loaded server state:75
move frame:76-------------


does not play back exactly still...


move frame:895-------------
move frame:896-------------
move frame:897-------------
897 rewind to:894
loaded server state:894
move frame:895-------------
move frame:896-------------
move frame:897-------------
saved server state:897

[898]late cdat dropped p:2 c:896  state:897-
move frame:898-------------
move frame:899-------------
move frame:900-------------
900 rewind to:897
loaded server state:897
move frame:898-------------
move frame:899-------------
move frame:900-------------
saved server state:900

move frame:901-------------
move frame:902-------------
move frame:903-------------
903 rewind to:900
loaded server state:900
move frame:901-------------
move frame:902-------------
move frame:903-------------
saved server state:903

move frame:904-------------
move frame:905-------------
move frame:906-------------
906 rewind to:903
loaded server state:903
move frame:904-------------
move frame:905-------------
move frame:906-------------
saved server state:906

move frame:907-------------
move frame:908-------------
move frame:909-------------
909 rewind to:906
loaded server state:906
move frame:907-------------
move frame:908-------------
move frame:909-------------
saved server state:909

move frame:910-------------
move frame:911-------------
move frame:912-------------
912 rewind to:909
loaded server state:909
move frame:910-------------
move frame:911-------------
move frame:912-------------
saved server state:912

[913]late cdat dropped p:2 c:911  state:912-
move frame:913-------------
move frame:914-------------
move frame:915-------------
915 rewind to:912
loaded server state:912
move frame:913-------------
move frame:914-------------
move frame:915-------------
saved server state:915



increased rejection of late cdats


move frame:1501-------------
[1502]late cdat dropped p:2 c:1500  state:1500-
move frame:1502-------------
move frame:1503-------------
1503 rewind to:1500
loaded server state:1500
move frame:1501-------------
move frame:1502-------------
move frame:1503-------------
saved server state:1503

move frame:1504-------------
[1505]late cdat dropped p:2 c:1503  state:1503-
move frame:1505-------------
move frame:1506-------------
1506 rewind to:1503
loaded server state:1503
move frame:1504-------------
move frame:1505-------------
move frame:1506-------------
saved server state:1506

move frame:1507-------------
[1508]late cdat dropped p:2 c:1506  state:1506-
move frame:1508-------------
move frame:1509-------------
1509 rewind to:1506
loaded server state:1506
move frame:1507-------------
move frame:1508-------------
move frame:1509-------------
saved server state:1509

[1510]late cdat dropped p:2 c:1508  state:1509-
move frame:1510-------------
[1511]late cdat dropped p:2 c:1509  state:1509-
move frame:1511-------------
move frame:1512-------------
1512 rewind to:1509
loaded server state:1509
move frame:1510-------------
move frame:1511-------------
move frame:1512-------------

the stdf frame has already had controls and moves applied
if we get moves for that frame, they are too late

they happen most often right after stdf has been saved.

so now try a big test...

What is funny is that I never even noticed all these errors.
The clients got whatever state the server told them and ran with that.
All these bugs I have been fighting have to do with the server state being different between when the server was running and later when playing back the game moves array...


It looks like it is working...

First of all I need to bring back late cdat errors..
server keeps track for each client
players1[p].late_cdats;

the problem I have now is that I have a lot of late cdats and the clients quite often make moves that do not get through to the server

why is this??

what can I do?

I can decrease the stdf freq...most misses occur right after a state is received

i can rewind more, but that would require that I take an earlier stdf snapshot...
what would that require?


the basic algorithm is
-rewind, apply missed moves, replay to now, send dif


20s 2P with client fk
stdf freq   late
3           226
4           170
5           120
6           100

rewinding more requires that I have a server state from then
why can't I do that?

would that require more states?

rolling states?


100 go back 8 frames and replay

92
93
94
95
96 when you get to -4 frames save a state, this is now the oldest state
97
98
99
100


101
102
103
104 go back 8 frames and replay

96
97
98
99
100 when you get to -4 frame save a state
101
102
103
104

105
106
107
108






stdf freq = 4

only one stdf state

when time to send stdf

rewind 8

replay 4

save new state

replay 4

send stdf



this could work....

then don't reject late unless how old??


start stdf send when mwPS.frame_num = srv_stdf_state_frame_num + 6;

rewind to srv_stdf_state_frame_num

play 3 frames

make a new srv_stdf_state

play 3 frames to current

send stdf


it looks like I will need 2 server states
1 from 3 frames ago and one from now

the one from 3 frames ago is the one I will use to rewind next time
the one from now is the one I will send to clients

changed back to array of 4 for both

lets make 0 the most current (highest mwPS.frame_num) and 1 the older one




void server_send_stdf(void)
{

   if (mwPS.frame_num == 0)
   {
      game_vars_to_state(srv_stdf_state[1]);
      srv_stdf_state_frame_num[1] = mwPS.frame_num;
      printf("saved server state[1]:%d\n\n", mwPS.frame_num);
   }


   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_stdf_state_frame_num[1] + 6)
   {
      printf("\n%d rewind to:%d\n", mwPS.frame_num, srv_stdf_state_frame_num[1]);

      // rewind and fast forward from last stdf state to apply missed game moves received late

      // int saved_current_frame_num = mwPS.frame_num; // save old current frame

      mwPS.frame_num = srv_stdf_state_frame_num[1]; // rewind frame num
      state_to_game_vars(srv_stdf_state[1]);   // rewind state

      printf("loaded server state[1]:%d\n", mwPS.frame_num);

      loop_frame();
      loop_frame();
      loop_frame();

      game_vars_to_state(srv_stdf_state[1]);
      srv_stdf_state_frame_num[1] = mwPS.frame_num;
      printf("saved server state[1]:%d\n", mwPS.frame_num);

      loop_frame();
      loop_frame();
      loop_frame();

      // rewind and replay is done, now save this state as a base for next time

      game_vars_to_state(srv_stdf_state[0]);
      srv_stdf_state_frame_num[0] = mwPS.frame_num;

      printf("saved server state[0]:%d\n\n", mwPS.frame_num);

      // send dif based on this state to all clients
      for (int p=1; p<NUM_PLAYERS; p++)
         if ((players[p].control_method == 2) || (players[p].control_method == 8)) server_send_stdf(p);



   }
}

no changes to clients, only server

holy shit, it works!


909 rewind to:903
loaded server state[1]:903
move frame:904-------------
move frame:905-------------
move frame:906-------------
saved server state[1]:906
move frame:907-------------
move frame:908-------------
move frame:909-------------
saved server state[0]:909

move frame:910-------------
move frame:911-------------
move frame:912-------------

912 rewind to:906
loaded server state[1]:906
move frame:907-------------
move frame:908-------------
move frame:909-------------
saved server state[1]:909
move frame:910-------------
move frame:911-------------
move frame:912-------------
saved server state[0]:912

move frame:913-------------
move frame:914-------------
move frame:915-------------

915 rewind to:909
loaded server state[1]:909
move frame:910-------------
move frame:911-------------
move frame:912-------------
saved server state[1]:912
move frame:913-------------
move frame:914-------------
move frame:915-------------

it seems to be able to play back also

this works fucking awesome rewind 4 skip 2...

after all of this stuff and now its working so good...yay!


what if I entered server players controls immed, just like client
they can be corrected later..seems to work...


the look back part in proc_game_moves never seems to find any differences

lets remove it and save a copy here just in case



// this function processes all entries in the game_moves array that match current mwPS.frame_num
void proc_game_moves_array(void)
{
   // search entire range
   int start_index = game_move_entry_pos-1;
   int end_index = 0;

   // reduce search range
//   start_index = game_move_current_pos + 100;
//   if (start_index > game_move_entry_pos-1) start_index = game_move_entry_pos-1;
//
//   end_index = game_move_current_pos - 100;
//   if (end_index < 0) end_index = 0;

//   sprintf(msg, "game_move - gmep:%d gmcp:%d si:%d ei:%d\n", game_move_entry_pos, game_move_current_pos, start_index, end_index);
//   if (L_LOGGING_NETPLAY_cdat) add_log_entry2(40, 0, msg);


// for each active player record the index of the game move that:
// has the max frame number that is not greater than the current frame num

   for (int p=0; p<NUM_PLAYERS; p++)
      if (players[p].active)
      {
         players1[p].last_gm_index = -1;
         players1[p].last_gm_frame_num = -1;
         players1[p].last_gm_comp_move = -1;
      }




   for (int x=start_index; x>=end_index; x--)  // search backwards from start_index to end_index
   {

      int f = game_moves[x][0]; // frame
      int t = game_moves[x][1]; // type
      int p = game_moves[x][2]; // player
      int c = game_moves[x][3]; // cm
      if ((f <= mwPS.frame_num) && (t == 5)) // frame in range and type game move
      {
         if (f > players1[p].last_gm_frame_num) // max mwPS.frame_num
         {
            players1[p].last_gm_frame_num = f;
            players1[p].last_gm_index = x;
            players1[p].last_gm_comp_move = c;
         }
      }

      if (game_moves[x][0] == mwPS.frame_num) // found frame number that matches current frame
      {
         if (x > game_move_current_pos) game_move_current_pos = x; // index of last used gm - keep this at the most recent one, never go back
         switch (game_moves[x][1])
         {
            case 1: proc_player_active_game_move(x); break;
            case 2: proc_player_inactive_game_move(x); break;
            case 3: proc_player_client_join_game_move(x); break;
            case 4: proc_player_client_quit_game_move(x); break;
            case 5: set_controls_from_comp_move(game_moves[x][2], game_moves[x][3]); break;
         }
      }
   }


   // if not match exact then set max for each player
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (players1[p].last_gm_index != -1))
      {
         // compare if we actually ever have a difference here
         // how do I get current gm from controls??
         int cm = get_comp_move_from_players_controls(p);
         if (cm != players1[p].last_gm_comp_move)
         {
            printf("game_move correction! p:%d f:%d gmfn:%d\n", p, mwPS.frame_num, players1[p].last_gm_frame_num);
         }

         set_controls_from_comp_move(p, players1[p].last_gm_comp_move);
      }
}


20221222 4:00AM

fixed a huge problem yesterday...

today:

I am looking at client. It seems really simple.
- receive and apply difs
- set controls locally and send cdats

One thing that occurs to me:

I do no checking of the destination frame of the difs.

In the old method, I would hold on to it until dst matched current mwPS.frame_num
but I seem to not check for that in this new method.

I just apply it as soon as I get it?
And I nevee check mwPS.frame_num?

What if I get it late or early?


right now i only call apply dif from rx stdf packet complete

i want to call it also from client_control

I want to add a check to see if the destinations match

done...

something really weird happened when level done occurred...

server froze but clients continued without server?


tried a much shorter test...
why does e6400 always lose server connection on level done...
e6430 error loading level 000?? should have been 151
server froze again...

timer seems to be incrementing, but no display

all players are inactive and have no control modes??

I think it happens on the first rewind...


it is because the initial state for server is made on frame 0 in void server_send_stdf(void)
this works for the level thet the server starts on, but after level_done, the first frame to that function is frame 1...

where else could I put this that makes sense?
in proc_start_mode..done

what about reset_states...no


cleaning up proc_start_mode
I broke it so that server will not even start...

player array is still getting killed by rewind????
initial state is not being saved...fixed...

do I need to put game move player 0 active at the start of all games, no, but that way I could save the color...
try it...

works in single player...
now restore color from config file after demo mode...already done

test multiple..good

p0 white
p1 lt blue
p2 green


redo txt gm...done

make start gm use val instead of p...

this will break all my existing demos....

I can manually fix them...

fix where it is entered....done

fix display in save txt...done

fix where it is used...
run demo...done

redo all gms....done


what if I make it so that dropping a gm file on the executable opens and runs it

or make it so that the extension is registered to do that

first of all what does dropping do?  show argv and c

dropping on pm.exe starts pm but it can't find any fonts or bitmaps
printf("Current Directory:%s\n", al_get_current_directory());
the problem is that it starts in the directory of the dropped file, not the executable..
when I put it in the same directory as the executable it is passed as an argument with the full path

I have success!

I can now set the association to open .gm files with pm.exe

when pm.exe is run with one argument
- first it compares to all the flags possible
- then it tries to convert to an integer level
- then it tris to run as a demo

in initial setup I check path to executable and if is not current path I change cuurent path to path to executable.


ALLEGRO_PATH *ep = al_get_standard_path(ALLEGRO_EXENAME_PATH);
al_set_path_filename(ep, NULL);
if (!al_change_directory(al_path_cstr(ep, ALLEGRO_NATIVE_PATH_SEP))) printf("Error Changing Current Directory!\n");
printf("Current Directory:%s\n", al_get_current_directory());
al_destroy_path(ep);


I would like to move the command line argv stuff into its own file, main is getting big..
also the menu stuff for main maybe...
done

now I have:

z_game_menu.cpp - 470 lines with nothing but the game menu

z_args - 480 lines with all the command line args and test stuff

z_main.cpp - 800 lines
 - 480 variable declarations
 - 130 initial setup
 - 60 final wrap up
 - 10 main




----------------------------

do some tests...

multiplayer tests






how am I going to handle the new send stdf varaibles?

right now I:
rewind 4
replay 2
save state
replay 2
save state

the old variable stdf_freq is the distance between the 2 save states

you could do the initial rewind longer or shorter and that would not affect stdf freq...

make the loop_frame function take a variable for how many frames it loops...done


now at the top of stdf have some variables that control it:



stdf_freq (2-6) distance between states

rewind amount probably greater than stdf_freq..


this is the old way:

   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_stdf_state_frame_num[1] + 4)
   {


new way:
if (mwPS.frame_num == srv_stdf_state_frame_num[0] + stdf_freq)

rewind stdf_rewind

its like there is this window before and after, I dont think they need to be the same size.0

this seems to work pretty good:

int s1 = 1;
int s2 = stdf_freq; // 2 or 3 work good
int s3 = s1+s2;

// is it time to make a new dif and send to clients?
if (mwPS.frame_num == srv_stdf_state_frame_num[1] + s3)
{

   // rewind and fast forward from last stdf state to apply missed game moves received late
   mwPS.frame_num = srv_stdf_state_frame_num[1]; // rewind frame num
   state_to_game_vars(srv_stdf_state[1]);   // rewind state

   if (L_LOGGING_NETPLAY_stdf)
   {
     // printf("\n%d rewind to:%d\n", mwPS.frame_num, srv_stdf_state_frame_num[1]);
      sprintf(msg, "stdf rewind to:%d\n", srv_stdf_state_frame_num[1]);
      add_log_entry2(27, 0, msg);
   }

   loop_frame(s1);

   // save state[1] as a base for next rewind
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;

   if (L_LOGGING_NETPLAY_stdf)
   {
      //printf("saved server state[1]:%d\n", mwPS.frame_num);
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }

   loop_frame(s2);

   // save state[0] as a base for sending client difs
   game_vars_to_state(srv_stdf_state[0]);
   srv_stdf_state_frame_num[0] = mwPS.frame_num;





what about s1 = 0;


server does not even do the rewind loop


normal...

[27][0][0]stdf saved server state[1]:0
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                             LEVEL 4 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][0]stdf rewind to:0
[41][0][1]move frame:1
[27][0][1]stdf saved server state[1]:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[27][0][5]saved server state[0]:5
[41][0][5]move frame:5
[27][0][1]stdf rewind to:1
[41][0][2]move frame:2
[27][0][2]stdf saved server state[1]:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][6]saved server state[0]:6
[41][0][6]move frame:6
[27][0][2]stdf rewind to:2
[41][0][3]move frame:3
[27][0][3]stdf saved server state[1]:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[27][0][7]saved server state[0]:7
[41][0][7]move frame:7
[27][0][3]stdf rewind to:3
[41][0][4]move frame:4
[27][0][4]stdf saved server state[1]:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[41][0][8]move frame:8
[27][0][8]saved server state[0]:8
[41][0][8]move frame:8
[27][0][4]stdf rewind to:4
[41][0][5]move frame:5
[27][0][5]stdf saved server state[1]:5
[41][0][6]move frame:6
[41][0][7]move frame:7




[27][0][0]stdf saved server state[1]:0
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                             LEVEL 4 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[27][0][0]stdf rewind to:0
[27][0][0]stdf saved server state[1]:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][4]saved server state[0]:4
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[41][0][8]move frame:8
[41][0][9]move frame:9
[41][0][10]move frame:10
[41][0][11]move frame:11
[41][0][12]move frame:12
[41][0][13]move frame:13
[41][0][14]move frame:14


change it so that instead of comparing mwPS.frame_num to earliest
compare to most recent...

   // is it time to make a new dif and send to clients?

old:
   if (mwPS.frame_num == srv_stdf_state_frame_num[1] + s3)
   {

new:
   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_stdf_state_frame_num[0] + s2)
   {


this was really jumpy

[27][0][0]stdf saved server state[1]:0
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                             LEVEL 4 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[27][0][0]stdf rewind to:0
[41][0][1]move frame:1
[27][0][1]stdf saved server state[1]:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][4]saved server state[0]:4
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][1]stdf rewind to:1
[41][0][2]move frame:2
[27][0][2]stdf saved server state[1]:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[27][0][5]saved server state[0]:5
[41][0][5]move frame:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[27][0][2]stdf rewind to:2
[41][0][3]move frame:3
[27][0][3]stdf saved server state[1]:3

this does not look right...


what am I trying to do?

rewind 4 and save state1
this makes no sense...this earlier one has to move forward in time

my rewind is actually loading state1, then I am ff 0 and saving state1 again? It will never change...

go back and do som experiments to see what is really happening...


this is 1 3

play one frame

rewind 4
play 1 frame
save state 1
play 3 frame
save state 0


[27][0][0]stdf saved server state[1]:0
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3

[27][0][0]stdf rewind to:0
[41][0][1]move frame:1
[27][0][1]stdf saved server state[1]:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][4]saved server state[0]:4
[41][0][4]move frame:4

[27][0][1]stdf rewind to:1
[41][0][2]move frame:2
[27][0][2]stdf saved server state[1]:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[27][0][5]saved server state[0]:5
[41][0][5]move frame:5

[27][0][2]stdf rewind to:2
[41][0][3]move frame:3
[27][0][3]stdf saved server state[1]:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][6]saved server state[0]:6
[41][0][6]move frame:6

[27][0][3]stdf rewind to:3
[41][0][4]move frame:4
[27][0][4]stdf saved server state[1]:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[27][0][7]saved server state[0]:7
[41][0][7]move frame:7

[27][0][4]stdf rewind to:4
[41][0][5]move frame:5
[27][0][5]stdf saved server state[1]:5
[41][0][6]move frame:6
[41][0][7]move frame:7
[41][0][8]move frame:8
[27][0][8]saved server state[0]:8




this is 2 2

play two frames

rewind 4
play 2 frames
save state 1
play 2 frames
save state 0




[27][0][0]stdf saved server state[1]:0
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3

[27][0][0]stdf rewind to:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[27][0][2]stdf saved server state[1]:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][4]saved server state[0]:4

[41][0][4]move frame:4
[41][0][5]move frame:5

[27][0][2]stdf rewind to:2
[41][0][3]move frame:3
[41][0][4]move frame:4
[27][0][4]stdf saved server state[1]:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][6]saved server state[0]:6

[41][0][6]move frame:6
[41][0][7]move frame:7

[27][0][4]stdf rewind to:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][6]stdf saved server state[1]:6
[41][0][7]move frame:7
[41][0][8]move frame:8
[27][0][8]saved server state[0]:8





this is 3 1

play 3 frames

rewind 4
play 3 frames
save state 1
play 1 frames
save state 0

effective stdf_freq = 3


[27][0][0]stdf saved server state[1]:0
[41][0][0]move frame:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3

[27][0][0]stdf rewind to:0
[41][0][1]move frame:1
[41][0][2]move frame:2
[41][0][3]move frame:3
[27][0][3]stdf saved server state[1]:3
[41][0][4]move frame:4
[27][0][4]saved server state[0]:4

[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6

[27][0][3]stdf rewind to:3
[41][0][4]move frame:4
[41][0][5]move frame:5
[41][0][6]move frame:6
[27][0][6]stdf saved server state[1]:6
[41][0][7]move frame:7
[27][0][7]saved server state[0]:7

[41][0][7]move frame:7
[41][0][8]move frame:8
[41][0][9]move frame:9

[27][0][6]stdf rewind to:6
[41][0][7]move frame:7
[41][0][8]move frame:8
[41][0][9]move frame:9
[27][0][9]stdf saved server state[1]:9
[41][0][10]move frame:10




so lets try to describe this again, beacuse you obviously didn't quite get it last time

s1 = 2;
s2 = 2;
s3 = s1 + s2;

- state[1] is the earliest state the server has

- when current frame == state[1] + s3 do a new stdf
- rewind (load state[1])
- step s1 frames
- save a new state[1]
- step s2 frames to where you were before rewinding
- save state[0] and send to clients

- state[0] is only used to make and send difs to clients
- state[0] is most likely missing some player input


- every time a rewind is done
- the 1st frames played back will be the last chance ever to apply moves in those frames
- the 2nd frames will be speculative, a guess.

when new cdat arrive, if they are dated earlier than state[1] do not put them in gma


I am getting a litte confused about where in the loop the frame number is incremented

in the main loop after move is done, proc frame delay does it

if the ff loop it is done right after move....

I just want it to be consistant, I would like it to be the last thing done..
that is easy in the main loop, but when I am fast forwarding

where server_control intercepts the main loop, fn has been incremented, but no input or moves have happened yet

so when server rewinds, the original frame has not been processed yet.

when server saves a new state1 has that one been processed?

I'm getting bogged down...lets test...

-----------------------------------------------
2 1

8P fakekey level 4
approx 103k spike to 200 at join
quite a few late cdat (late c frame = state frame)???
doesn't play back right

if I split server rx to get cdats and send stdf to send on same frame then late cdats could be avoided...


2 2
8P fakekey level 4
approx 90k spike to 120 at join
occasional last cdat
doesn't play back right




---------------------

The next big thing I want to tackle is the order of things...

make it so that frame number inc is always last


input
including
server rx that might put things in gm for this frame

optional server rewind and dif send
if server rewind then it will stop just short so that move for this frame is done in regular way

set controls from gm for this frame

move objects

optional draw

frame inc



frame ff
set controls from gm for this frame
move objects
frame inc





first of all, make the server cdat rx loop the first thing that gets done every frame
or even better, async


in server control, the first thing done has always been to receive and process all waiting packets..
this is done on a frame_number that has not yet had the move applied

so any game moves that arrive on this frame could still get applied on this frame

but more importantly, the frame of state1 is what we are comparing to..
I need to know if state1 and its frame refer to a frame that has already had its moves applied...
I would say yes, that state has already had its moves applied

so when rewound to that state the very next thing that should happen is
immediatley set next frame
then process input, move and inc frame

that is why loop_frame() had the frame inc at the start

when loop_frame() is done, it leaves the game in the same state..current frame has been done...
then when doing the rest of the loop ...


what if I moved the server send dif to after the main loop has already processed the moves but has not yet inc frame yet

then when rewind is done, it will not have a move after

state1 will still be for a frame that has the moves applied already
rewind and replay will


in the main loop in server mode, the server will take care of the move
either just calling move, or rewinding...done...

broke up server rx and server_send_stdf


when sss is called, input and controls for the current frame have been done, but not move
if sss does nothing, the move in the main loop right after will do it then proc_frame_delay and frame inc..

if sss rewinds and replays it will do the move frame for the current frame
this is not optimal, because then I will need an exception for current frame..

what I really want rewind to do is leave the game loop in the exact condition it found it in...

so maybe it should be before the part where the controls are set for the current frame...


here is my loop, pretty much what I already had:

server rx that might put things in gm for this frame
optional server rewind and dif send
if server rewind then it will stop just short so that move for this frame is done in regular way

this part happens in main loop every time:

set controls from gm for this frame
move objects
optional draw
frame inc


all I need to do is make sure that if server rewinds, it leaves the state exactly like it was before
same frame number and no moves done for that frame


make the log entry for move frame
- recognized and hideable
- tell where they were called from
done


now lets run this, generate a log and see if its doing what I want it to do...

[27][0][0]stdf saved server state[1]:0
[41][0][0][0]move frame:0
[41][0][1][0]move frame:1
[41][0][2][0]move frame:2
[41][0][3][0]move frame:3
[41][0][4][0]move frame:4
[27][0][0]stdf rewind to:0
[41][0][0][1]move frame:0
[41][0][1][1]move frame:1
[41][0][2][1]move frame:2
[27][0][3]stdf saved server state[1]:3
[41][0][3][1]move frame:3
[41][0][4][1]move frame:4
[27][0][5]saved server state[0]:5
[41][0][5][0]move frame:5
[41][0][6][0]move frame:6
[41][0][7][0]move frame:7
[27][0][3]stdf rewind to:3
[41][0][3][1]move frame:3
[41][0][4][1]move frame:4
[41][0][5][1]move frame:5
[27][0][6]stdf saved server state[1]:6
[41][0][6][1]move frame:6
[41][0][7][1]move frame:7
[27][0][8]saved server state[0]:8
[41][0][8][0]move frame:8
[41][0][9][0]move frame:9
[41][0][10][0]move frame:10
[27][0][6]stdf rewind to:6
[41][0][6][1]move frame:6
[41][0][7][1]move frame:7
[41][0][8][1]move frame:8
[27][0][9]stdf saved server state[1]:9

when state1 is saved the frame number that points to means:
this is the initial conditions for this frame
controls and move still need to be done...


when loop_frame runs it prints the frame number that is being moved, then incs the frame num

after loop frame the state and frame num can be saved. this is the initial state for that frame


this looks like it works up to here.


now the next problem is that I want to do the most current move before I send stdf
but if I leave the original method ill have to hook into it later somehow

in rewind do the current frame
then mark somehow
so when I come back to loop, i skip move and dec frame

or

I could just set a flag and send dif after normal move...

yes, I like this better


break in up into two functions:

call this after move

if (flag)

server_send_stdf()
{
   makes state[0] based on now;
   sends to all active clients
}

server_rewind()
{


sets flag

}

-------------------

now I call server rewind in server control...every frame

if it actually does the rewind it sets players1[0].server_send_dif = 1;

then in the main loop, after the move..

if (players1[0].server_send_dif) server_send_stdf();

this makes state[0] and sends to all clients



now I just need to make sure that rewind stops right where it started

so one less move so that reg thing can move it...

[27][0][0]stdf saved server state[1]:0
[41][0][0]move[0] frame:0
[41][0][1]move[0] frame:1
[41][0][2]move[0] frame:2
[41][0][3]move[0] frame:3
[41][0][4]move[0] frame:4

[27][0][5]stdf rewind to:0
[41][0][0]move[1] frame:0
[41][0][1]move[1] frame:1
[41][0][2]move[1] frame:2
[27][0][3]stdf saved server state[1]:3
[41][0][3]move[1] frame:3
[41][0][4]move[1] frame:4
[41][0][5]move[0] frame:5
[27][0][5]saved server state[0]:[5] and sent to clients
[41][0][6]move[0] frame:6
[41][0][7]move[0] frame:7

[27][0][8]stdf rewind to:3
[41][0][3]move[1] frame:3
[41][0][4]move[1] frame:4
[41][0][5]move[1] frame:5
[27][0][6]stdf saved server state[1]:6
[41][0][6]move[1] frame:6
[41][0][7]move[1] frame:7
[41][0][8]move[0] frame:8
[27][0][8]saved server state[0]:[8] and sent to clients
[41][0][9]move[0] frame:9
[41][0][10]move[0] frame:10

[27][0][11]stdf rewind to:6
[41][0][6]move[1] frame:6
[41][0][7]move[1] frame:7
[41][0][8]move[1] frame:8
[27][0][9]stdf saved server state[1]:9
[41][0][9]move[1] frame:9
[41][0][10]move[1] frame:10
[41][0][11]move[0] frame:11

I think this looks like what I want

seems to play back correctly...


lev 4 8P fake key
420s
no level done
dif 3 2
played back flawlessly...

avg 70-80kbps max 100

a few late cdats
45 for p2 (e6400)
2 for p7

test again...
this time with a level_done...

lev 5 8P fake key
dif 3 2
played back perfect
still a few late cdats
p2 72 (e6400)
p1 2
120-150k fairly constant with lots of enemies



I am doing late cdat properly?

I can still apply them if I rx them on the same frame as state[1]
because that is the state at the start of that frame, not the end...

   if (cdat_frame_num <= srv_stdf_state_frame_num[1])
   {
      printf("[%d]late cdat dropped p:%d c:%d  state:%d  tally:%d\n", mwPS.frame_num, p, cdat_frame_num, srv_stdf_state_frame_num[1], players1[p].late_cdats);
      players1[p].late_cdats++;
   }
   else add_game_move(cdat_frame_num, 5, p, cm); // add to game_move array

changed to

   if (cdat_frame_num < srv_stdf_state_frame_num[1])



test again...

lev 12
700s
31k frames
212k game moves
plays back perfectly
don't know how many late cdats
8P fk 3 2
80k-100k spike 132

lev 13 8P level done start with fake key...
frame 1 250kbps then down to 60

why do I not have end of level stats when level done??
I have it for bad exit..

I also have it when any player quits??
so they all pile up at the end if server quits...


I need to fix this...


first, what happens when client quits in the middle of a game?
nothing on either client or server


void log_reason_for_client_quit(int p)
{
   char tmsg[80];
   sprintf(tmsg,"unknown");
   int r = players1[p].quit_reason;
   if (r == 64) sprintf(tmsg,"player pressed ESC or menu key");
   if (r == 70) sprintf(tmsg,"server drop (server sync > 100)");
   if (r == 71) sprintf(tmsg,"server drop (no sdak for 100 frames)");
   if (r == 74) sprintf(tmsg,"client never became active");
   if (r == 75) sprintf(tmsg,"client lost server connection");
   if (r == 80) sprintf(tmsg,"level done");
   if (r == 90) sprintf(tmsg,"local client quit");
   if (r == 91) sprintf(tmsg,"local server quit");
   if (r == 92) sprintf(tmsg,"remote server quit");

   if (r == 93) sprintf(tmsg,"remote client quit");

   sprintf(msg,"reason for quit...........[%s]", tmsg);
   add_log_entry_position_text(22, p, 76, 10, msg, "|", " ");
}

lets just worry about server...

when server quits make sure we have eols for all clients..done
when client quits (on server show eol then)..done but it shows in log multiple times due to rewind...
make client show late_cdat stats...done
now make sure next level works...done

now what the hell else was I doing??


im am using 3 2

try 2 1

especially see how aiming rockets looks

level 12 8P fakekey
mostly 120 to 150k max 230

server eol stats
max tx frame 20k
avg tx frame 2.4k
total tx 93M
max tx packet per frame = 23
max tx packet per sec = 284

242k moves
38k frames
961s
16m
only e6400 had more than a few lates

played great

could not get purple coin in area that said kill all enemies to go down here.
there were 6 enemies left and they were all unkillable cloners

the block that was blocking looked empty on server, but was not on clients
is was solid on all.


will it play back, it went good until enemies got down to 6 then the block opens and the player went down
this did not happen when playing the original.
approx 540

is there something about rewinding that breaks that??
trigger does set event when switching off..
and it stores that state in its own data

so when it is rewound it should have that state about the previous frame
then in this frame that condition is changed...

it should still play out the same...

maybe it has to do with server setting controls in addition to adding to game move...
probably not....but walk through it..

set directly happens immediately before reading from game moves array
it really shouldn't matter but I commented it out anyway...

look at trigger code...

it could very well be trigger_array
- its is not synced to clients
- it might not like being rewound

when rewinding it does not revert to previous states...

that is most likely the culprit...

how big is it and can I add it to the state?

int pm_event[1000];


what the hell...

try testing on a level that makes heavy use of triggers, especially toggle...
tried the trigger level and in server mode it definitley happens..


then add it to the state...

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

I have patched it in and it looks like it is working....




--------------------------

I want to try this on the internet



set up a server using my home network..


try to connect with laptop tethered to phone


70.75.228.155:7878

can ping from laptop tethered to phone


how do know if I am pinging the router or something behind it..


how much space do I have?
char m_serveraddress[256] = "192.168.1.2";



25148



Open firewall ports in Windows 10
You can manually permit a program to access the internet by opening a firewall port. You will need to know what port it uses and the protocol to make this work.

    Navigate to Control Panel, System and Security and Windows Firewall.
    Select Advanced settings and highlight Inbound Rules in the left pane.
    Right click Inbound Rules and select New Rule.
    Add the port you need to open and click Next.
    Add the protocol (TCP or UDP) and the port number into the next window and click Next.
    Select Allow the connection in the next window and hit Next.
    Select the network type as you see fit and click Next.
    Name the rule something meaningful and click Finish.

You have now opened a firewall port in Windows 10!



I think I am having trouble opening the port on my computer...

try ubuntu...



run server on a pc in my home network

on router make a rule
192.168.1.123:25148 UDP

open firewall on computer for port 25148


test with

https://canyouseeme.org/

or

https://www.yougetsignal.com/tools/open-ports/

they always fail


on client set server address to 70.75.228.155:25148
try to run game
fails when cant get connection
client can ping 70.75.228.155


try scat

192.168.1.131:25149

ufw is not running

sudo ufw allow from any to any port 25149 proto udp


set this up on router as
25149





25148 times out_func
25149 connection refused


when I disable the rule for 192.168.1.131:25149 on my router
connection timed out:

with the rule I get:
connection refused

this was tested on m36, on the same subnet..
when I tried through different connection, it timed out always


20221224




Hey Bill,

I was wondering if you could help me with this networking thing for my game.

Mostly just figuring out how to get it to work over the internet.
It works fine over a LAN. The protocol used is UDP.

The server does not need any information about the clients.
The clients need to know the IP (or hostname) of the server.
I start the server and it listens for connections.
When the server gets one, now it knows how to send to that client.
After that is established, I can exchange packets.

So now I am trying to get it to work over the internet.

I am running the server from my home internet connection.
My external IP is 70.75.228.155
I chose port 25148 to use, as it doesn't seem to be used by others.
The local IP of the server is 192.168.1.123

In my router I set up a port forwarding rule like this:
service type: TCP/UDP
external port: 25148
internal port: 25148
internal IP address: 192.168.1.123

in windows firewall I set up a rule like this:

Protocol and Ports:
protocol:UDP
local port: 25148
remote port: 25148

Scope:
Local IP adresses: any
Remote IP addresses: any

Advanced:
Profiles: all (domain, private, public)
Interface types: (all)
Edge traversal: Allow edge traversal

Programs and services:
Programs: All programs that meet the specified conditions


The client I am trying to connect to tethered to my phone so it has a different internet connection.

On the client game, I set the server ip to be 70.75.228.155:25148
But it never gets a connection.

I cannot ping 70.75.228.155 from the client, and when I test for open ports:
https://www.yougetsignal.com/tools/open-ports/
70.75.228.155:25148 it says that port is closed

I cannot ping 70.75.228.155, but when I enable remote management on my router and test for open ports:
https://www.yougetsignal.com/tools/open-ports/
70.75.228.155:8443 that port is open
So I am pretty sure it is getting as far as the router

I have a second server set up in my house:
running ubuntu 20.04 desktop with ufw disabled
local IP 192.168.1.131

In my router I set up a port forwarding rule like this:
service type: TCP/UDP
external port: 25149
internal port: 25149
internal IP address: 192.168.1.131

when I test for open ports from the client:
https://www.yougetsignal.com/tools/open-ports/
70.75.228.155:25149 it says that port is closed

tried turning off the firewall on client, no change



it looks like port 24785 is used internally by libnet??

Network initialized - channel mode (UDP)
Server initialized
Server opened channel for `192.168.1.105:24785'
Server opened channel for `192.168.1.125:24785'
Server opened channel for `192.168.1.105:24785'

when I try to connect locally with any other port it is refused

now I get the server saying

Server opened channel for `174.90.223.220:24786'
Server opened channel for `174.90.223.220:24786'

when trying to connect from outside client

is there a range I should be using?

why is the IP not local....beacuse it is the remote...duh
why is the port one off

this is the router log:
[LAN access from remote] from 174.90.223.80:24786 to 192.168.1.123:24785, Saturday, Dec 24,2022 11:10:26

why does the port sent show 86??

show on client...

NET_CHANNEL *chan;
chan = net_openchannel (driver, binding);
printf ("Local address of channel: %s\n", net_getlocaladdress (chan));

client shows 785..
but server opens channel for 786...

I don't get it

on router open a range 785-788 done

make an outgoing rule on server..done

So much has happend on the server:

It listened and got a packet(1234)
Then it created a channel and sent a reply

one problem is that it did it 42 times for remote..

that is because remote sent it 42 times...

need longer time out...

   int tries = 40;          // number of times to try
   float try_delay = 0.02; // delay between tries


slowed it way down but still get no response

possibilities:
- doesn't get off server
- doesn't pass router
- doesn't get through client

how can i test any of those?

packet inspection? wireshark to the rescue

22639	419.029865	174.90.223.80	192.168.1.36	UDP	60	24786 → 24785 Len=4
22640	419.047713	192.168.1.36	174.90.223.80	UDP	47	64554 → 24786 Len=5

this is where the 1234 packet is rx'd and the 5678 reply is tx'd
this does not tell me if it is getting out of this machine though

what does a local join look like?
34	3.433074	192.168.1.102	192.168.1.36	UDP	60	24785 → 24785 Len=4
35	3.450449	192.168.1.36	192.168.1.102	UDP	47	62779 → 24785 Len=5

wireshark on client

I see 3 tries, 4s apart
192.168.76.248 70.75.228.155 UDP 24785 - 24785 Len=4

but no responses...




what now??
can I make a box with 2 ethernet ports to capture stuff??

how about explicitly making an outbound rule on server?


looks wide open on server, how about client?

could it just be that the internet I am getting by tethering to my phone is the issue?


I wish I had another connection...
ask a neighbor for wifi password?
try it with radio connection at work?
put a test radio on my house??



something else:

why does server send out on 786?
because that is what it was rx'd on

this could be the problem why the remote machine never sees it...wrong port...

when server gets the initial packet, it is rx'd with 786

when wireshark sees the packet go out on client it has 785

does the router fuck with it??

what else could be doing it??






I want to redo how client waits for response

      if ((packetsize = ClientReceive(packetbuffer)) && (PacketRead("stdf"))) done = client_process_stdf_packet();



is this how you reply??

         char bufr[32] = "5678";
         net_send (ClientChannel[ClientNum], bufr, strlen (bufr) + 1);





this is how its sent...
      Packet("1234");
      ClientSend(packetbuffer, packetsize);


where does server get who from?

   while((packetsize = ServerReceive(packetbuffer, &who)))
   {
      if(PacketRead("cdat")) server_proc_cdat_packet();
      if(PacketRead("stak")) server_proc_stak_packet();
      if(PacketRead("cjon")) server_proc_cjon_packet(who);
   }



not saved in player struct until sjon sent (because we don't know what player to use until then)




now that I've added some more code to display things, lets try it again...

server:
win 10
local IP 192.168.1.36 (static on router)
UDP protocol

external IP: 70.75.228.155

port forwarding on router:
external start port 24785-24786
internal start port 24785-24786
internal IP address: 192.168.1.36

remove all rules related to pm in windows firewall
run server and windows prompts to allow
choose private and public and click OK
2 inbound rules are created, UDP and TCP
all ports open
edge traversal, defer to user

now do a test with LAN and write down all you can

Server mode started
Server hostname:    [m36]
Level:              [2]
Network initialized - channel mode (UDP)
Server initialized
Server recieved initial packet from '192.168.1.124:24785'
Server opened channel for `192.168.1.124:24785'
Server replied with 5678
ClientNum:1
Shutting down the server
savegame/game_exit_20221224-211503-lev2.txt - saved
logs/20221224-211503-[2][m36].txt saved

Wireshark
No.	Time	      Source	      Destination	   Protocol	Length	Info
100	9.747916	   192.168.1.124	192.168.1.36	UDP	   60	      24785 → 24785 Len=4
101	9.758532	   192.168.1.36	192.168.1.124	UDP	   47	      63959 → 24785 Len=5
103	9.948899	   192.168.1.124	192.168.1.36	UDP	   63	      24785 → 63959 Len=21
104	9.957735	   192.168.1.36	192.168.1.124	UDP	   63	      63959 → 24785 Len=21
105	9.959553	   192.168.1.36	192.168.1.124	UDP	   1064  	63959 → 24785 Len=1022
106	9.959562	   192.168.1.36	192.168.1.124	UDP	   1064  	63959 → 24785 Len=1022
107	9.959570	   192.168.1.36	192.168.1.124	UDP	   180   	63959 → 24785 Len=138
108	10.008408	192.168.1.36	192.168.1.124	UDP	   1064  	63959 → 24785 Len=1022
109	10.008417	192.168.1.36	192.168.1.124	UDP	   1064  	63959 → 24785 Len=1022
110	10.008423	192.168.1.36	192.168.1.124	UDP	   176   	63959 → 24785 Len=134
111	10.059410	192.168.1.36	192.168.1.124	UDP	   1064	   63959 → 24785 Len=1022
112	10.059418	192.168.1.36	192.168.1.124	UDP	   1064  	63959 → 24785 Len=1022
113	10.059425	192.168.1.36	192.168.1.124	UDP	   189   	63959 → 24785 Len=147



C:\Users\m\Desktop\pm_client24>pm -c
Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 1920x1080
Date and time: 2022-12-24  21:15:06
Local address of channel:24785
Client network initialized: server[m36] (UDP)
ClientCheckResponse 1
Sent initial packet to server, waiting for reply..got response: 192.168.1.36:63959
Got reply from server
Client mode started on host:[e6430]
logs/20221224-211510-[2][e6430].txt saved
savegame/bad_exit_20221224-211510-lev2.txt - saved
C:\Users\m\Desktop\pm_client24>

Wireshark
No.	Time		   Source		   Destination	   Protocol Length	Info
262	34.202677	192.168.1.124	192.168.1.36	UDP	   46	      24785 ? 24785 Len=4
263	34.213413	192.168.1.36	192.168.1.124	UDP   	60	      63959 ? 24785 Len=5
265	34.403684	192.168.1.124	192.168.1.36	UDP   	63	      24785 ? 63959 Len=21
266	34.413532	192.168.1.36	192.168.1.124	UDP   	63	      63959 ? 24785 Len=21
267	34.414530	192.168.1.36	192.168.1.124	UDP   	1064	   63959 ? 24785 Len=1022
268	34.414531	192.168.1.36	192.168.1.124	UDP   	1064	   63959 ? 24785 Len=1022
269	34.414532	192.168.1.36	192.168.1.124	UDP   	180	   63959 ? 24785 Len=138
270	34.463333	192.168.1.36	192.168.1.124	UDP   	1064	   63959 ? 24785 Len=1022




Now do the same thing on WAN...

server same

client win10
tethered to phone
client set server IP: 70.75.228.155

firewall rules deleted
new copy of game (pm5)

Server mode started
Server hostname:    [m36]
Level:              [2]
Network initialized - channel mode (UDP)
Server initialized
Server recieved initial packet from '174.90.223.196:24786'
Server opened channel for `174.90.223.196:24786'
Server replied with 5678
ClientNum:1
Server recieved initial packet from '174.90.223.196:24786'
Server opened channel for `174.90.223.196:24786'
Server replied with 5678
ClientNum:2
Shutting down the server
logs/20221224-214504-[2][m36].txt saved
savegame/bad_exit_20221224-214504-lev2.txt - saved

C:\pm>

No.	Time	      Source	      Destination	   Protocol	Length	Info
99	   10.640402	174.90.223.196	192.168.1.36	UDP	   60	      24786 → 24785 Len=4
100	10.648038	192.168.1.36	174.90.223.196	UDP   	47	      52592 → 24786 Len=5
120	14.854957	174.90.223.196	192.168.1.36	UDP   	60	      24786 → 24785 Len=4
121	14.873167	192.168.1.36	174.90.223.196	UDP   	47	      52593 → 24786 Len=5

C:\Users\Service2\Desktop\pm5>pm -c

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 1366x768
Local address of channel:24785
Client network initialized: server[70.75.228.155] (UDP)
ClientCheckResponse 1
Sent initial packet to server, waiting for reply..........no response
ClientCheckResponse 2
Sent initial packet to server, waiting for reply..........no response
Did not get reply from server

C:\Users\Service2\Desktop\pm5>

No.	Time	      Source	      Destination	   Protocol	Length	Info
5	   15.024284	192.168.76.248	70.75.228.155	UDP	   46	      24785 → 24785 Len=4
7	   19.037409	192.168.76.248	70.75.228.155	UDP	   46	      24785 → 24785 Len=4


Analysis:
client sent with port 24785 for both src and dest

server received with destination 24785 but src of 24786, so when it replies it never gets there??

maybe I need to set the local port somewhere..


search libnet for 24785.....

it is the a default port but can be overridden

can make the server use one port and the client use another??


Found this on the internet:

When you connect out from a device which is behind a NAT system like a home modem.
You have no control of the port that will be used for the outbound connection to the Internet.
However many of these devices allocate ports using specific patterns. For example, incremental numbers.

so my router could be adding 1 to it



https://bford.info/pub/net/p2pnat/

Peer-to-Peer Communication Across Network Address Translators

Of the various flavors of NAT, the most common type is traditional or outbound NAT,
which provides an asymmetric bridge between a private network and a public network.

Outbound NAT by default allows only outbound sessions to traverse the NAT: incoming packets
are dropped unless the NAT identifies them as being part of an existing session initiated from within the private network.

Outbound NAT conflicts with peer-to-peer protocols because when both peers desiring to communicate are “behind”
(on the private network side of) two different NATs, whichever peer tries to initiate a session, the other peer's NAT rejects it.
NAT traversal entails making P2P sessions look like “outbound” sessions to both NATs.

my router is probably blocking the returning packets...


well this sucks...

what if I have a server on the internet without NAT? no router...

P2P connections seem like they are quite a hassle to work with...


maybe I could have a server on the internet that does nothing but help set up these connections...

tried to setup port triggering
service user:any
service type:UDP
triggering port 24785

inbound connection
type:udp
start port 24785
end port 24785

when I tried this nothing happened on server, like the packet never got there...

when I went back to the port forwarding, at least the server got the packet...

try this...


tried to setup port triggering
service user:any
service type:UDP
triggering port 24785

inbound connection
type:udp
start port 24785
end port 24786

no combination works:
trigger 85, 86



try all this again, but restart server for every try

pf 24785       - server gets msg
pf 24785-24786 - server gets msg
pf 24786       - no msg

pt 24785 24785-24785
pt 24785 24785-24786

pt 24786 24785-24786



I want to go to work, set up a computer as a server on its own connection

not router or anything like that and do some tests...


What I need is:
work laptop and phone for the client..

pick a 4230 to use as the server and leave there...


I set up a server up in the lab at work....
96.45.13.235

tried to connect with work laptop tethered to phone
server got connection from: 174.90.223.196:24786 and replied
nothing ever made it back to the client

then I tried conncting work laptop to EID_guest
server got connection from: 96.45.0.24:24785 and replied
nothing ever made it back to the client


so I gave up and went home..

tried a client at home and success!!!

C:\pm>pm

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Date and time: 2022-12-25  23:13:06
Local address of channel:24785
Client network initialized: server[96.45.13.235] (UDP)
ClientCheckResponse 1
Sent initial packet to server, waiting for reply..got response: 96.45.13.235:58136
Got reply from server
Client mode started on host:[m36]
savegame/level_done_20221225-231341-lev150.txt - saved
logs/20221225-231341-[150][m36].txt saved
savegame/game_exit_20221225-231430-lev151.txt - saved
logs/20221225-231430-[151][m36].txt saved

This is officially the first time Purple Martians has ever worked through the internet!

Merry xmas to me!

I have the server playing the loop 150, 151, 152, 150

The game is not working very well from the perspective of the client.
Laggy input, player position jumping around, breakable blocks in the middle disappearing where it makes no sense..
All the data that I need is on the server...

random blocks could very well be that I need to clear bullet at next level....
I do clear the bullets, but I make server's initial state before that...fixed...



how about I try 2 clients at home?

that would require that each one has their own port, would it not??

I still have the port triggering rule set up on the router...
pt 24786 24785-24786
what if I delete it?

It still seems to work, even with no rules on the router..

no port forwarding and no port triggering
upnp in enabled but nothing shows up in the mapping table

each client that connects has a different port number

so how can I make this work....
I really want to hook up a test radio on my house....

get small tripod and something to weight it down, 3GHz 450b and ethernet cable run into garage....

or 3GHz panel...


what have I learned?

client is simple to make work, server, less so...

turned off upnp just to see if shit still works....

it seems to work even with upnp off...could be just still working from before...
turn it back on for now and test later when kids are not awake...


20221226 11:42 AM

I now have an EID internet connection in the garage.

96.45.15.176 when connected to m36

lets test!!!

It works quite well, no lag like last night...


what else can I monitor?

here is one annoying thing
on client, if move is late and dropped..
well suppose client presses and holds RIGHT.
It does not make it to the server so it never takes effect.
but the client is still holding RIGHT and not moving...


what can I adjust of my two rewind timer?

s1 how often to send
s2 how long to wait for late cdats

Im not 100% sure I have this right...

what are my settings now? 2 1

that is about as fast as I can make it...

lets try 2 2

no late cdats

I really want some way to measure what effect these have

I want to understand the tradeoffs of adjusting each either way...



But right now 2 2 seems to work great...

lets test with more clients

5 clients

very playable

max 240k

seemed like there were a lot of base resets??

I would like to track that...I am...its called base resets and it is actually shown on grid...
why are they happening?

client has not acknowledged last stdf before it gets another one?
try increasing s1...

3 2

base resets are way better
bandwidth is also a lot better, like around 40-50.

So if I reduce stdf freq (s1) I will get more base resets, because client does not have time to respond before new stdf arrives and base is lost.

What are the drawbacks of increasing s1?

I would guess that more time passes in predictive mode and the corrections are more severe and noticeable...
lets try with 4 2

it seems mopre jumpy
now 35-40k

what if I made it dynamically adjustable?
count how many base resets last second and adjust...
min 2 max 6?

can I make it manualy adjustable while the game is running?
the worst it could do it cause base reset when it is changing...

first thing I need to do is assign it a variable...

let do that for s1 and s2

put them in player1
where do I initialize them...

init_server



then try to adjust while game running...



is there a way of assiging a number to base reset, instead of hit miss??
server only knows when client replies with actual acked base state
and server discovers it does not have that anymore

srv_stdf_state[0] is made at the end of rewind, but never used...
the dif is made from the current game_vars


when s1 = 1; the game does not work...
when started at 1 I get a lot of resets

when started at >1 then lowered to 1 while running, client loses conection

I don't think it should ever be 1, 2 is the absolute minimum and 3 would probaly be most common

set at 3 for now and move on to adjusting s2..

if I lower s2 to 1 game freezes badly



the game seems to work fine, but the correction of predicted motions make it look like players are jumping around

in LAN mode, they were probably a lot closer in sync, now with some delay they are not??


should I go to the trouble of making the network stuff asyncronous?
How would I even go about doing that?

super fast loop

on a timer (40 fps)

when timer fires move frame

if frame has moved try to draw, unless no time...



------------------------------------------------------------------------------------------------------------------------------
The way I do my main loop and process events is quite unorthodox and convoluted and there might be a better way to do it....

I don't think I ever block in my game, every loop has a call to proc_controllers.

That way I get to process any events..

What I want to do is process the network stack asyncronously.
As fast as possible I want to check for incoming packets and process them instantly.
Not have to wait for the next cycle (at 40fps)

I want to be able to do a true ping test at full speed.
I want to be able to use a much higher resolution to sync the timers of clients..

Otherwise the way it is works fine for most of the things it does.
cdats get sent the very instant we detect control changes
stdf's get sent on the exact frame they are created on
stak's get sent immediatley after receiving stdf's

the server checks for cdat's received immediately before it needs to use them
clients check for stdf packets at the last possible instant before they could possibly use them

how about a thread on the server that does nothing but listen and instantly reply to ping...












ALLEGRO_THREAD *thread; //global


thread = al_create_thread(thread_func, NULL);
al_start_thread(thread);


al_join_thread(thread, NULL);
al_destroy_thread(thread);


static void *thread_func(ALLEGRO_THREAD *thr, void *arg)
{
   int done = 0;

   (void)thr;

   while (!done)
   {

      while((packetsize = ServerReceive(packetbuffer, &who)))
      {
         printf("Packet rx on frame:%d\n", mwPS.frame_num);
         if(PacketRead("cdat")) server_proc_cdat_packet();
         if(PacketRead("stak")) server_proc_stak_packet();
         if(PacketRead("cjon")) server_proc_cjon_packet(who);
      }
   }
   return NULL;
}





al_run_detached_thread(thread_func, NULL);

static void *thread_func(void *arg)
{
   while (ima_server)
   {
      int who;
      while((packetsize = ServerReceive(packetbuffer, &who)))
      {
         printf("Packet rx on frame:%d\n", mwPS.frame_num);

         if(PacketRead("cdat")) server_proc_cdat_packet();
         if(PacketRead("stak")) server_proc_stak_packet();
         if(PacketRead("cjon")) server_proc_cjon_packet(who);
      }
   }
   return NULL;
}


I think this is slurping up all packets and will probably interfere with ServerListen....

is there a way to only touch types of packets I am interested in??


what does ServerReceive do different from net_receive()
what is address vs who?

net_receive is passed a channel
if that channel has data, address is set...
do I care about address?

server receive polls all clients and if they have data, returns with the client num that has data...

all that who is, is client num...

where is players.who set??

I cant use server_receiev until that client has been created...

it will not even check for data for that client_num because it doesnt exist yet...

glad I got that figured out...


why does this system die after 26s??

26x40 = 1000 frames??

this time is happened 18s in
server dropped client for last sdak (stak?) rx'd > 100


server also stopped receiving cdats around the same time....


tested again

3796 was the last frame that my rx thread processed...

goddamn it, what if packets are received in the middle of a rewind??


they will have weird frame numbers...

why did I want to do this again?
only for a better return ping number and better sync...

revert back...

can I create 2 channels?


I want a fast as possible packet exchange...

try the thread on the client...

only one packet stdf....

but there is a time when I block waiting for it..

also sjon...

this all seems like a lot of work for small returns...

Clean up the code where server and clients set stuff up...done..

test TCP..seems to work fine on lan...and wan...


-------------------------------------------------------


method for setting s1
start at 3
on server, measure total client resets for 4 seconds
if zero try to reduce
if greater than 10, increase

min:2
max:8?


method for setting s2:
start at 2
on server measure total client late cdats dropped for 4 seconds
if zero 4 try to reduce
if greater than 10, increase

min:2
max:4?

only lower every 4 seconds if perfect
raise if threshold is reached before that

reset counters every 4 sec



try a really busy level...


It seems way more jumpy over WAN...

could it have to do with the timing...
sync 2-3 always on WAN
fairly stable 1 on LAN


how is it set again?
client adjusts so that they get state just when they need it....

this means client is slightly behind server

when lag is increased client will be even further behind


what if we adjust to get it one frame before it is needed

not sure about this....but lets try...not good...i need better timers...


can I use threads?



here is the problem...

any variables the thread touches need to be locked....


maybe I can just have my packet thread read packets and dump them into arrays to be processed later....
except for the very time sensitive obnes that I want to process immediatley...



what is the max packets per frame I want to be able to handle?

lets shoot high with 200..


in the packet processing loop I need to lock this structure
then in the other loop when I process it I also need to lock the structure


what will this gain me...

at any time packets can be received, except when the packet buffer is being read by rest of the code...


-----------------------------------------------
can I make a separate connection used only for this fast ping?


separate copnnection run in its own thread...

server initiates

client rx and tx in a fast loop

server rx's in a fast loop

compare timers


how to setup a second UDP connection



20221227

Some thoughts for today...


I still want a high speed packet loop so I can implement a better packet timer and speed control

ways that I can implement the high speed packet loop:

- second channel or connection that I read in a different thread

- read channel in different thread and store received packets in custom structure for later use
i can date stamp them the instant they are received
I will need to lock the functions used to access this array to prevent race condtions


structure packet_buffer
int status (0 = empty, 1=used)
int packet_type (1 = cdat, 2=stdf...)
int timestamp
char data[1024]


fast packet loop will receive packets and put them in the first empty slot the packet buffer

in my normal thread I will consume them and mark them as empty

I will have an extract function that is threadsafe


I can implement all this before putting it in its own thread


extern struct packet_buffer packet_buffers[200];
struct packet_buffer
{
   int active:
   int type;
   int timestamp;
   int who;
   char data[1024];
};


make a function to initialize...


void init_packet_buffer(void)
{
   for (i=0; i<200; i++)
   {
      packet_buffer.active = 0;
      packet_buffer.type = 0;
      packet_buffer.timestamp = 0;
      packet_buffer.who = 0;
      packet_buffer.data[0] = 0;
   }
}





implement for server first:



I forgot, i broke shit by trying second channel

I removeing all the second channel stuff, I came across an important finding.....
it was still broken...


if (!(ListenChannel = net_openchannel(NetworkDriver, "")))
if (net_assigntarget(ListenChannel, ""))

these two calls need to be "" not NULL


then when I am adding client:

net_openchannel(NetworkDriver, NULL)))
this has to be NULL



      if ((packetsize) && (PacketRead("1234")))
      {
         sprintf(msg, "Server received initial 1234 packet from '%s'",address);
         printf("%s\n", msg);

         if (!(ClientChannel[ClientNum] = net_openchannel(NetworkDriver, NULL)))
         {
            sprintf(msg, "Error: failed to open channel for %s\n", address);
            printf("%s", msg);
            if (L_LOGGING_NETPLAY) add_log_entry2(10, 0, msg);
   			return;
         }
   		if (net_assigntarget (ClientChannel[ClientNum], address))





This seems to work up to here, lets do a quick documentation

------------------------------------------------------------------------
old:
------------------------------------------------------------------------
void server_control() // main server loop to process packet send and receive
{
   ServerListen(); // listen for new client connections
   int who;
   while((packetsize = ServerReceive(packetbuffer, &who)))
   {
      if(PacketRead("cdat")) server_proc_cdat_packet();
      if(PacketRead("stak")) server_proc_stak_packet();
      if(PacketRead("cjon")) server_proc_cjon_packet(who);
   }


------------------------------------------------------------------------
new:
------------------------------------------------------------------------
void server_control() // main server loop to process packet send and receive
{
   ServerListen(); // listen for new client connections

   server_fast_packet_loop();
   server_read_packet_buffer();


------------------------------------------------------------------------
in pm.h
------------------------------------------------------------------------
extern struct packet_buffer packet_buffers[200];
struct packet_buffer
{
   int active;
   int type;
   double timestamp;
   int who;
   int packetsize;
   char data[1024];
};

------------------------------------------------------------------------
init structure
------------------------------------------------------------------------
void init_packet_buffer(void)
{
   for (int i=0; i<200; i++)
   {
      packet_buffers[i].active = 0;
      packet_buffers[i].type = 0;
      packet_buffers[i].timestamp = 0;
      packet_buffers[i].who = 0;
      packet_buffers[i].packetsize = 0;
      packet_buffers[i].data[0] = 0;
   }
}

int ServerInitNetwork() // Initialize the server
{
   init_packet_buffer();


------------------------------------------------------------------------
void server_fast_packet_loop(void)
{
   int who;
   while((packetsize = ServerReceive(packetbuffer, &who)))
   {
      double timestamp = al_get_time();

      // get type
      int type = 0;
      if(PacketRead("cdat")) type = 1;
      if(PacketRead("stak")) type = 2;
      if(PacketRead("cjon")) type = 3;

      if (type)
      {
         for (int i=0; i<200; i++) // find empty
            if (!packet_buffers[i].active)
            {
               packet_buffers[i].active = 1;
               packet_buffers[i].type = type;
               packet_buffers[i].timestamp = timestamp;
               packet_buffers[i].who = who;
               packet_buffers[i].packetsize = packetsize;
               memcpy(packet_buffers[i].data, packetbuffer, 1024);
               break;
            }
      }
   }
}


void server_read_packet_buffer(void)
{
   // process all used
   for (int i=0; i<200; i++)
      if (packet_buffers[i].active)
      {
         memcpy(packetbuffer, packet_buffers[i].data, 1024);
         packetsize = packet_buffers[i].packetsize;
         set_packetpos(0);
         if(PacketRead("cdat")) server_proc_cdat_packet();
         if(PacketRead("stak")) server_proc_stak_packet();
         if(PacketRead("cjon")) server_proc_cjon_packet(packet_buffers[i].who);
         packet_buffers[i].active = 0;
      }
}



------------------------------------------------------------------------
this actually works...now lets see if I can do it in a thread....

it should be trivial to do in a thread, but how to protect against race conditions...

could it be as simple as:

global int rx_lock

when reading the packet_buffer in the the main loop, set rx_lock.

in the fast thread, only read the variable and do nothing if set...

try it...

extern int packet_rx_lock;


wait a sec, this will stop the fast loop from running when the main loop is reading from pb
but what about the read happening when the fast loop is running?
should this be a 2 way lock? each can lock...

void server_read_packet_buffer(void)
{
   if (!packet_rx_lock)
   {
      packet_rx_lock = 1;

      // process all used
      for (int i=0; i<200; i++)
         if (packet_buffers[i].active)
         {
            printf("read packet:%d  size:%d \n", i, packet_buffers[i].packetsize);

            memcpy(packetbuffer, packet_buffers[i].data, 1024);
            packetsize = packet_buffers[i].packetsize;
            set_packetpos(0);

            if(PacketRead("cdat")) server_proc_cdat_packet();
            if(PacketRead("stak")) server_proc_stak_packet();
            if(PacketRead("cjon")) server_proc_cjon_packet(packet_buffers[i].who);

            packet_buffers[i].active = 0;
         }
      packet_rx_lock = 0;
   }
}


now I am ready to try it in a thread....

al_run_detached_thread(thread_func, NULL);

static void *thread_func(void *arg)
{
   while (ima_server)
   {
      int who;
      while((packetsize = ServerReceive(packetbuffer, &who)))
      {
         printf("Packet rx on frame:%d\n", mwPS.frame_num);

         if(PacketRead("cdat")) server_proc_cdat_packet();
         if(PacketRead("stak")) server_proc_stak_packet();
         if(PacketRead("cjon")) server_proc_cjon_packet(who);
      }
   }
   return NULL;
}


server cannot set up connection in listen, probably because fast loop eats all the packets!!!

it shouldn't...fast calls ServerReceive which only gets packets from players that exist


//            if (PacketRead("1234")) // why the fuck this does not work?????

            if ((packetbuffer[0] == '1') && (packetbuffer[1] == '2') && (packetbuffer[2] == '3') && (packetbuffer[3] == '4'))    // printf("1!!!\n");
            {




now it looks like fast loop is hogging the lock, how about only lock when actually rx something?
ok done...

after becoming active, the server stops receiving stak from client
well they stop showing up in the logs anyway


tried again, they don't stop right away, client plays for a while then they stop showing up in log..

player active 213

last stak:365
player drop 465

also last cdat rx'd was also 365

it looks like the server just stopped receiving packets...


102 player active
155 last sdak

printf in fast loop has stoppped...


lets try to use an actual mutex instead of my variable

extern ALLEGRO_MUTEX *mutex;

mutex = al_create_mutex();

al_lock_mutex(mutex);

al_unlock_mutex(mutex);


that worked, but later the client segfaulted

is is because I am literally running the fast loop wide open??

i don't want to put a rest in there, but sometimes a print adds enough delay to make it work...

maybe instead of a thread, I could call it with a timer....

test...i think that is exactly true...



I don't have to lose everything I have done up to now...

just modify the main event loop

set up timer to call move and everything else..

generate events when the timer fires...


I could have it just call game_loop

game_loop could return instead of blocking..




the highest level loop...
{
   proc allegro events
   including input, display, timers

   if timer do stuff and optionally draw stuff
   under this would be all modes...menu, game, level_editor
   all these things would not block....they would return here

   if I have any things that I want to run at a different speed just put them on a timer...

}




what do I have now?

main
   game_menu
      game_loop
      edit_menu





start by creating a new file : main_loop.cpp


this will be the one thing that is called from main

within that, I will process the allegro event queue


I will have a timer for the game_loop and one for the menu_loop
or should I use the same one...

I could have it call a do_something, then that something could be one one many things
menu
game_loop
level_editor

each of those things will handle its own drawing, or skip if need be

will this actually make things simpler and easier?

i really want to get rid of the menu_timer block hack and waiting in proc frame delay
while (mwPS.frame_num > al_get_timer_count(fps_timer)); // delay if too far ahead so timer catches up


I think I should do it...


make a new struct to group a lot of globals..

maybe later...

// ------------------------------------------------
// ----------------- mouse and keys ---------------
// ------------------------------------------------

// serial key check
char skc[64];
int skc_index = 0;

bool mI.key[ALLEGRO_KEY_MAX];
int key_pressed_ASCII;

float mouse_loop_pause = 0;

int mI.mouse_x = 0;
int mI.mouse_y = 0;
int mouse_z = 0;
int mouse_dx = 0;
int mouse_dy = 0;
int mouse_dz = 0;
int mouse_b1 = 0;
int mouse_b2 = 0;
int mouse_b3 = 0;
int mouse_b4 = 0;

int KEY_F1_held = 0;
int KEY_F2_held = 0;
int KEY_F3_held = 0;
int KEY_F4_held = 0;
int KEY_F5_held = 0;
int KEY_F6_held = 0;
int KEY_F7_held = 0;
int KEY_F8_held = 0;
int KEY_F9_held = 0;
int KEY_F10_held = 0;
int KEY_F11_held = 0;
int KEY_F12_held = 0;
int KEY_PRTSCR_held = 0;


int KEY_UP_held = 0;
int KEY_DOWN_held = 0;
int KEY_LEFT_held = 0;
int KEY_RIGHT_held = 0;

// ------------------------------------------------
// ---------------- display -----------------------
// ------------------------------------------------

int desktop_width;
int desktop_height;


int disp_x_curr; // either wind in windowed mode or full fullscreen mode)
int disp_y_curr;
int disp_w_curr;
int disp_h_curr;

int disp_x_wind; // windowed
int disp_y_wind;
int disp_w_wind;
int disp_h_wind;

int disp_x_full; // fullscreen  (set to 0, 0, desktop_width, desktop_height and never change)
int disp_y_full;
int disp_w_full;
int disp_h_full;

int SCREEN_W;
int SCREEN_H;
int WX;
int WY;
int fullscreen = 1;
int display_adapter_num = 0;
float WX_shift_speed = 0;

// used to only redraw a region of background to increase fps
int level_display_region_x;
int level_display_region_y;
int level_display_region_w;
int level_display_region_h;

int display_transform_double = 1;
int saved_display_transform_double = -1;
int show_dtd = 0;



right now I want to get rid of the return value k of proc controller and make it a global

it is used for the ascii value of the last key pressed


I think I still want to keep proc_controllers...it has 191 references...
also, what the hell will I do when I want to wait for a key release?
maybe I could just use the goddamn events that do that exactly...no they don't...


maybe I could add something to my key array thing...

bool mI.key[ALLEGRO_KEY_MAX];


bool mI.key[ALLEGRO_KEY_MAX][4];

key[][0]; // current state of key
key[][1]; // previous state of key
key[][2]; // true if key was pressed in between last call and now
key[][3]; // true if key was released in between last call and now

now I can tell if held by 0 and 1 true


this is how I used to check for just pressed

if ((mI.key[ALLEGRO_KEY_F1]) && (!KEY_F1_held))
{
   KEY_F1_held = 1;
   // do stuff
}
if (!mI.key[ALLEGRO_KEY_F1]) KEY_F1_held = 0;



this is how I do it now

if (mI.key[ALLEGRO_KEY_F1][2])
{
   // do stuff
}


in the events, I just need to set current key state...is it cleared every time?? no
I need to check fro just pressed in sepeate loop

i've got this all wrong

my keypressed shit does not work like I thought it would

in events it is only processed when something changes
this is where I should be setting those values

for held, i need to do something outside the loop every frame...

void proc_keys_held(void)
{
   for (int k = ALLEGRO_KEY_A; k < ALLEGRO_KEY_MAX; k++)
   {
      if ((mI.key[k][0] == true) && (mI.key[k][1] == false)) mI.key[k][2] = true; // just pressed
      else mI.key[k][2] = false;

      if ((mI.key[k][0] == false) && (mI.key[k][1] == true)) mI.key[k][3] = true; // just released
      else mI.key[k][3] = false;

      mI.key[k][1] = mI.key[k][0]; // previous for next time
   }
}

when processing UP and DOWN events, i only set the one flag [0]

OK that is looking a lot better

does printscreen work?? yes...


now figure out k...its pretty rare...12 occurances



proc_controllers();
int k = key_pressed_ASCII;
they are 2 different things
the first one is the scan code....

lets see if I can convert all those to the second one...


find all the things that use k.

k comes from proc_events called once
then is passed through proc_controllers...
find calls to proc_controllers that use the return value

190 occurances
log 938 1541 2422
menu 1345 1443

edit server_name..its overwritten by key_pressed_ASCII a few lines later...remove and test....done..
edit lift_name...done but not tested

log 938
toggle players

      int k = proc_controllers();
      if ((k > 26) && (k < 35)) // numbers 0-7 toggle players
      {
         int p = k-27;

k   27-34
kpa 48-55

fix and test for all stuff in log...

      proc_controllers();
      int k = key_pressed_ASCII;
      if ((k > 47) && (k < 56)) // numbers 0-7 toggle players
      {
         int p = k-48;


      if ((k > 64) && (k < 91)) // letters toggle tags
      {


      if ((k > 96) && (k < 123)) // letters toggle tags
      {
         k-=32;
      }


      if ((k > 64) && (k < 27)) // letters toggle tags
      {
         k += 64; // convert to ascii
         //printf("%c\n", k);



make the player stuff also work with number pad

37 38 39 40 41 42 43 44


ESC does not seem to work in mode 3 in log file viewer??
does anything work in mode 3??

proc_contoller runs stuff many times while in menu timer block....
so the just pressed and just released are long gone...

i plan to get rid of that....
the problem is that I use it give a delay...

now I can get rid of k and ret....

there was alot of places that stupid ret, k value was passed around.
they are all gone now...


here is the next big thing I want to fix:

menu_timer_block....i hate it...

basically whenever proc_controllers() is called,
it does the event loop, including input..

then if not in a running game, blocks and loops, while running the event loop over and over...


I hate it so much!!

in my new loop I will do things differently, but how do I get there from here?


I already have 'game_exit'

use that to do 2 different loops

there are so many things that call proc_controllers, I want to migrate away before killing it completely..

keep the timer block, but do nothing in it...done...

now my key[][3] works!!!

down to 171 occurances of proc_controllers


I'm wondering if I could do the same for the mouse_buttons...

      if (mouse_b1)
      {
         while (mouse_b1) proc_controllers(); // wait for release

convert to:

if (mouse_b1[0]) // current
if (mouse_b1[1]) // previous
if (mouse_b1[2]) // just pressed
if (mouse_b1[3]) // just released

it should be quite doable...


I am down to 113 occurances of proc_controllers

I have got as far as menu.cpp




I really want to do the same for mouse...
old

int mouse_b1 = 0;
int mouse_b2 = 0;
int mouse_b3 = 0;
int mouse_b4 = 0;

new:

int mI.mouse_b[5][4] = { 0 };

5 because I want to call them by their original numbers


mouse_b1 102 occurances
mouse_b2 42 occurances
mouse_b3 12 occurances
mouse_b4 4 occurances


replace mouse_b1 with mI.mouse_b[1][0]
replace mouse_b2 with mI.mouse_b[2][0]


this all done...

now continue with key replacement

I have been through all occurances op mI.key[ and I think they are all fixed...


now back to proc_controllers
113

fuck it, ill come back later...



now what is next on the cleaning up of proc_controllers???


separate event queueu processing..


make two timers with events...


one for menu and one for game..



how fast does the menu normally run?? 125 fps?! wow



/* Do the main loop; until we're not done. */
while (!done) {

   do {
      ALLEGRO_EVENT event;
      al_wait_for_event(event_queue, &event);

      HandleEvent(event);
   } while (!al_is_event_queue_empty(event_queue));

   /* Check if the timer has ticked. */
   while (timer > 0) {
      --timer;
      Update();
      redraw = true;
   }
   if (redraw) {
      draw_framework();
      redraw = false;
   }
}



repeat {
  repeat {
   get event
   if timer event then update = true
  } until (queue is empty)
  if update {
   logic
   redraw
  }
}


I want my loop to look like this:

process_event_queue until empty

I will set up timers to trigger other things

then the rest of the loop is mostly.


if do_menu ...

if do_game ...

if do fast packet loop ...

also there I might want an overall meta state engine ytpe thing....
monitoring variables, handling changing states...


I think I am gettin closer....

make variables program_update..




I think I want a lot more states...


like

10 start new game
11 game running
12 next level
13 resume paused game
14 game exit

then it will be easier to move between states...

10 start new game usually goes to 11 next but could also go to game exit

11 game running is the only mode the timer event is actually setting update
11 can go to 12, 13, 14

try to start implementing this...



playable, but omg what a mess!!


20221208


The function 'proc_program_state()' is called every frame.

It handles the meta stuff.

If there is any special code that needs to be done for each program_mode, it will be done there.

If the program mode changes it is also handled there...

how is the program mode change handled?

another global called new_program_state

it can be set anywhere, but only takes effect when 'proc_program_state()' is called



next big thing....

do something about the frame_delay...right now it is commented out
when are frame numbers updated?

now that I time the main loop with the timer, am I off by one frame??

proc_frame_delay() increments mwPS.frame_num and runs update_animation
then determines whether or not to draw frame

move this all to loop for now....

now how can i tell if I need to skip drawing?

timer fires
move frame
mwPS.frame_num++


//      if (mwPS.frame_num <=  al_get_timer_count(fps_timer)) // skip drawing frame


//      {
//         draw_frame = 0;
//         players1[active_local_player].frames_skipped++;
//      }
//      else draw_frame = 1;
//      while (mwPS.frame_num > al_get_timer_count(fps_timer)); // delay if too far ahead so timer catches up




OK now I have decison to be made...
if the game cannot keep up, even with not drawing, what do I do??

correct the timer or correct the mwPS.frame_num...

correct the timer...and make a note, just like when skipping drawing...

added timer_adjust to player struct, just like frames_skipped

this was also in proc_frame_delay()

   if (al_get_timer_count(sec_timer) > 0)
   {
      al_set_timer_count(sec_timer, 0); // reset_second_timer
      actual_fps = mwPS.frame_num - last_fps_frame_num;
      last_fps_frame_num = mwPS.frame_num;
      frames_skipped_last_second = (players1[active_local_player].frames_skipped - last_frames_skipped);
      last_frames_skipped = players1[active_local_player].frames_skipped;
   }


also implement this:

add to player struct

frames_skipped_last_second
timer_reset_last_second

then add them just like the main ones.
ill need a tally too

   int frames_skipped;
   int frames_skipped_last_sec;
   int frames_skipped_last_sec_tally;

   int timer_adjust;
   int timer_adjust_last_sec;
   int timer_adjust_last_sec_tally;

players1[active_local_player].timer_adjust++;
players1[active_local_player].timer_adjust_last_sec_tally++;

then when sec timer fires, copy tally and reset...done

fix display...done
then remove all old methods..done


what about this?

      actual_fps = mwPS.frame_num - last_fps_frame_num;
      last_fps_frame_num = mwPS.frame_num;

put it in the same place...

now I am all done with proc_frame_delay()



next big thing...game_menu...

int zmenu(int menu_num, int menu_pos, int y)  // this menu function does not pass through, it waits for a selection and then exits

this will need to change to pass through, why? cause I want it to...

its only 130 lines...

why do I want to spend so much time fucking with this

patch it in existing to my new frame_work

program_mode 1 is game_menu..deal with it...


when selecting new game, set to 10


I need to rethink new_program_state....I have a logic error
if 0 do nothing..
if not 0 do the change and set to 0;

now how to quit playing game and go back to menu
where can I hook that in?

local player presses ESC
instead of entering game move, its hijacked...

hooked in it the right place and now it works...

Is there any state info that I need to keep for the menu?
I am calling it new every time now...

make sure resume works...

globals

play_level
start_level
resume_allowed
valid_level_loaded




every time game_menu is called it loads level...
make it so that only if resume_allowed..done

now make a way for that to happen...
13 resume paused game

OK that seems to be working properly


now what about stimp and stamp?

start and resume use stimp.
when changing to program_state 1 use stamp...works good...

what next??

demo
should get its own start up thing

14 start demo


demo mode exit...

save position in game menu
int current_menu_num = 7;
int current_menu_pos = 3;


do I need to save both?
the only thing I need on options menu is run demo
later....


replace some more game_loop calls...
when running from command line, it used to exit immediately..now it goes to menu...fix later

also does not work from demo mode...that assumes you can just call it and it will return to you...


can I more tightly integrate this into my new system?


mode 14 - run game, called from menu and returns to menu
mode 15 - run game, called from commandline and exits the program when done
mode 16 - run game, called from demo mode
this handles its own loading and running of levels

all of these will use mode 11 to actually run, but I need somewhere to hook into after they are done..
how about when in mode 11 you register the mode to go to next?

mode 11 could exit because:
local player quit
demo mode ended
level done
...


still thinking about how to apply this best?

have my own custom mode 11s for each?...no


all that is left is to do server and client....
then game loop will not be used at all
I'll still have to work the bugs out of the new system though


let go with 20 for server and 21 for client


client wont join...do I still have fast packet going?? yes...disabled

client can join!!! yayy!!!

now we can disable game_loop....done

proc_start_mode is called from level_done...need to do something about this...




next I want to implement a way to do something different when 11 ends



when 11 starts, register an exit code...


how do I signal that 11 is starting?

wherever I change game_state to 11 (all from other modes)
save something to hint at what to do when done..

like if it was started from client new game then do cleanup based on that
even more so:
client new game from menu
client new game command line

how do I signal that 11 is ending

this is what I wanted this whole state change thing to do...make it do it...


changing to 11 from many different places is handled by setting new_program_state

leaving 11 does not have a good solution yet...

I have been just setting new_program_state to 1 and going to the menu...

I should have some modes for the different reasons 11 is left.

mode 12 - level done
mode 13 - local single player quit


I still need to track where 11 was started from...
I could call it old_program_state...
0 = command_line
1 = menu
implement this for 10...done



I need to make an exhaustive list of everywhere that 11 could be quit...
I think searching for the old game_exit could do it...




make a state for level_done...

12 level_done

seem to work great in single player mode



moved almost everything out of old loop.cpp into main_loop.cpp
proc_frame_delay() is all that is left...

level_editor uses it in one place...how can I make level_editor do something different..

could I just wait on fps_timer event?


everything is gone from loop.cpp but I am keeping it around till I'm sure there is nothing left to copy

how can I use a timer in level editor??

I guess it doesn't matter if it blocks there...

added this line...
while (mwPS.frame_num > al_get_timer_count(fps_timer)); // delay if too far ahead so timer catches up

later I want to try to do it without blocking....

added check for level not found in a few places

if (!load_level(play_level, 0))
{
   new_program_state = 1;
   return;
}


demo mode...
test all
from menu good
from command line
pm -f good
from command line
pm garbage open file selector
file association open...good
note: can only stop demo with ESC...


actual demo mode...
needs work...
new_program_state = 14


demo_mode likes to be in charge..at the top of the loops...

it iterates all the demo_files then calls them pseudo randomly

how can I make it so that it can give of control and can be came back to??

it looks like a great number of the variables are global already....

why don't I do something like visual_level_select and only load the files once...


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
extern ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
extern int demo_played[100];
extern int num_demo_filenames;

extern int demo_mode_loaded;


extern int demo_mode_on;
extern int demo_mode_countdown;
extern int demo_mode_countdown_val;
extern int demo_mode_countdown_reset;
extern int demo_mode_enabled;
extern int demo_mode_last_frame;


make another old_program_state...2 = demo mode

then when done it will go back to 2

works but I need to find a way to cancel it..
level done should continue, otherwise go to 1..

level done does not do anything in demo mode...fixed

I think demo mode is working as intended
just that note about the keys...look in rungame keycheck...

also...what speed is the menu running at?

do I really need a separate timer?

anything calling proc_controllers is using menu_timer

lets make sure nothing in the game is...

client uses it twice
- once when waiting for sjon
- once when waiting for initial state

what control the speed of zmenu and animation? proc_controller()

so why does the menu scream by when game fps is high??
because the check in proc_controllers() is for ANY timer event...

now implement the saving of menu pos..done

sometimes menupos can be out of range now...fixed

then back to demo keys
key pressed ASCII cannot be used..
I read the event loop very fast.
keypressed on one frame then cleared the next
its not like everywhere else where I call proc_controllers
and kpa stays until I call it again..

give up on this method

why does the cancel only work the first time??..fixed...

I am completely happy with demo and run game

-----------------------------------------------------

next up will be to make sure everything works good on server and client

also to do a nice ESC exit from top menu

I think I have it...without fast exit to boot...

speedtest on and off...does nothing now that proc_frame_delay is gone...

do I even care??

I can just keep increasing fps and see what happens

if (speed_testing) // draw every frame no matter how fast or slow it is
also draw no frames // maybe 1 in 1000? and see how fast it is

omg!
I can draw one in 10,000 frames
and run it at 100,000 fps
only only get 10 adjusts per sec
...exactly how many times I draw!!

so the game logic can run at 100,000 fps...

what if I tried it on a complex level, 100 enemies, 500 items, 40 lifts, 8 players with fake key

I bet I could do a lot worse....

do that...

make a test level with 100 enemies and cloners to make more, 500 items, 40 lifts with 40 steps.
then get 8 players with fakekey and run it till just before 1,000,000 game moves
save that demo and it can be my stress test....


but really I am happy with how the changes are coming...I need to make server and client work...


20221228 10:00PM push...

to start with neither one can quit nicely

client...

where client sends cdat and applies controls directly menu key set game exit=1..changed to new_program_state =1
that worked perfectly...client exited to command prompt and sent message to server...
tried from menu and exited to menu very nice...
could not rejoin, error opening UDP..probably did not clean up like I should have...

get rid of 'int game_exit'...done

level done in netgame works like it should....



this is what used to be in loop.cpp I am getting rid of it......


// z_loop.cpp
#include "pm.h"
/*
int proc_frame_delay(void)
{
   int draw_frame = 0;
   mwPS.frame_num++;
   update_animation();
   if (al_get_timer_count(sec_timer) > 0)
   {
      al_set_timer_count(sec_timer, 0); // reset_second_timer
      actual_fps = mwPS.frame_num - last_fps_frame_num;
      last_fps_frame_num = mwPS.frame_num;
   }

//   printf("fn:%d timer:%d\n", mwPS.frame_num, al_get_timer_count(fps_timer));

//   if (speed_testing) // draw every frame no matter how fast or slow it is
//   {
//      draw_frame = 1;
//      al_set_timer_count(fps_timer, mwPS.frame_num);
//   }
//   else
//   {
//      if (mwPS.frame_num <=  al_get_timer_count(fps_timer)) // skip drawing frame
//      {
//         draw_frame = 0;
//         players1[active_local_player].frames_skipped++;
//      }
//      else draw_frame = 1;
//      while (mwPS.frame_num > al_get_timer_count(fps_timer)); // delay if too far ahead so timer catches up
//   }

   draw_frame = 1;
   return draw_frame;
}

*/

/*

// start modes:
// 1 single player new game
// 2 server new game
// 3 client new game
// 5 level done
// 7 resume single player
// 9 run demo mode
void proc_start_mode(int start_mode)
{
   stop_sound();

   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      stimp();
      set_frame_nums(mwPS.frame_num); // set fps_timer count to mwPS.frame_num
      return;
   }

   if (start_mode == 5) // level done - do clean up from previous level
   {
      if (L_LOGGING_NETPLAY) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (players[active_local_player].control_method == 1) // run demo mode saved game file
      {
         al_rest(1);
         game_exit = 1;// run game file play exits after level done
         return; // to exit immediately
      }

      if (ima_client) log_ending_stats(active_local_player);
      if (ima_server) log_ending_stats_server();

      if (ima_server) server_flush();
      if (ima_client) client_flush();

      blind_save_game_moves(1);
      save_log_file();
      play_level = next_level;
      players[0].level_done_mode = 0;

      if (0) // reset clients
      {
         if ((ima_client) || (ima_server))
         {
            for (int p=0; p<NUM_PLAYERS; p++)
            {
               // free all the used clients, so they can be re-assigned on the next level
               if (players[p].control_method == 9) players[p].control_method = 0;

               // set all clients inactive on server and client, to force them to re-chase and lock on the new level
               // if ((players[p].control_method == 2) || (players[p].control_method == 4)) players[p].active = 0;

            }
            // al_rest(1);
         }
      }

   }


   if (start_mode == 3) // client new game (this has to go before load level)
   {
      if (!client_init())
      {
         client_exit();
         game_exit = 1;
         return;
      }
   }

   // every mode after this should require load level so why don't I do it here at the top
   if (!load_level(play_level, 0))
   {
      game_exit = 1;
      return;
   }

   // reset players
   for (int p=0; p<NUM_PLAYERS; p++)
   {
      if (start_mode == 5) init_player(p, 2); // next level reset
      else                 init_player(p, 1); // full reset (start modes 1, 2, 3, 9)
      set_player_start_pos(p, 0);             // get starting position for all players, active or not
   }
   players[0].active = 1;


   if (start_mode == 9) // load and run demo
   {
      if (L_LOGGING_NETPLAY)
      {
         log_versions();
         sprintf(msg, "Demo mode started on level:%d", play_level);
         add_log_entry_header(10, 0, msg, 0);
      }
      players[0].control_method = 1; // rungame demo mode
   }
   else clear_game_moves(); // clear game moves array, except for demo mode


   set_frame_nums(0);
   reset_states();
   clear_bullets();
   clear_bmsg();
   clear_keys();
   clear_pm_events();


   if (start_mode == 2) // server new game
   {
      if (!server_init())
      {
         server_exit();
         game_exit = 1;
         return;
      }
   }

   if (ima_server) // set server initial state (for both 2-new game and 5-level done when server)
   {
      players[0].control_method = 3;
      game_vars_to_state(srv_stdf_state[1]);
      srv_stdf_state_frame_num[1] = mwPS.frame_num;
      if (L_LOGGING_NETPLAY_stdf)
      {
         //   printf("saved server state[1]:%d\n\n", mwPS.frame_num);
         sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
         add_log_entry2(27, 0, msg);
      }
   }

   if ((start_mode == 1) || (start_mode == 2) || (start_mode == 5)) // 1 single player new game, 2 server new game, 5 level done
   {
      add_game_move(0, 0, 0, play_level);       // [00] game_start

      // save colors in game moves array
      for (int p=0; p<NUM_PLAYERS; p++)
         if (players[p].active) add_game_move(0, 1, p, players[p].color); // [01] player_state and color
   }


   // only do fancy zoom into level if not in netgame
   if ((!ima_client) && (!ima_server)) stimp();


   if (L_LOGGING_NETPLAY)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }



   show_player_join_quit_timer = 0;
   start_music(0); // rewind and start theme
}

*/


/*

void game_loop(int start_mode)
{
   game_exit = 0;
   proc_start_mode(start_mode);
   while (!game_exit)
   {
      proc_scale_factor_change();
      proc_sound();

      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();
      if (players[0].level_done_mode) proc_level_done_mode();
      else move_frame(0);

      if (players1[0].server_send_dif) server_send_stdf();

      if (proc_frame_delay()) draw_frame();
   }
   if (ima_server) server_exit();
   if (ima_client) client_exit();
   stop_sound();
   stamp();
}
*/

put all the new stuff back in the original file 'z_loop.cpp'




OK back to client...
why can't it connect a second time?
if I quit the game, then I can...

server get the second request and replys
and as far as I can tell it looks exactly like the first

client times out waiting..

TCP works fine....

now I want to measure some ping times...

I can't have a second rx loop running fast....
both loops would interfere with each other...

I need to have only one rx loop and use my packet_buffer scheme

thie difference is I will be calling in faster, just not in its own thread...

make an structure of timestamps

extern struct timestamp timestamps[10000];
struct timestamp
{
   int frame0;
   int frame1;
   int frame2;
   int type;
   double timestamp0;
   double timestamp1;
   double timestamp2;
};



type
0 frame start
1 move start
2 move done
3 draw start
4 draw done

10 = cdat rx
11 = cjon tx
...
...


make a function to clear...

where? and where to call it?
top of server...call when starting 11...done

same for packet buffer..top of server called by init_network



make a function to add...

void add_timestamp(int type, int f1, int f2, double t1, double t2)
{
   if (timestamps_index < 9998)
   {
      timestamps[i].frame0 = mwPS.frame_num;
      timestamps[i].frame1 = f1;
      timestamps[i].frame2 = f2;
      timestamps[i].type   = type;
      timestamps[i].t0     = al_get_time();
      timestamps[i].t1     = t1;
      timestamps[i].t2     = t2;

      timestamps_index++;
   }
}





I have an ordering issue...

I want to measure draw time, but I also want to mark the time the frame started.....
the way it currently is...frame is incremented, then draw happens...

I would like the frame_inc to be the very last thing done...
just because that seems like the best way to order it...

is there anything in draw that cares about mwPS.frame_num?..probably no...




so I propose to change this:

if (proc_frame_skip()) draw_frame();
int proc_frame_skip(void)
{
   mwPS.frame_num++;
   update_animation();

   if (mwPS.frame_num < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      players1[active_local_player].frames_skipped_last_sec_tally++;
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}






to this:

if (proc_frame_skip()) draw_frame();

   mwPS.frame_num++;
   update_animation();

int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      players1[active_local_player].frames_skipped_last_sec_tally++;
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

looks simple enough, lets try it....





20 event timer processed

22 top of loop

99 last ts before frame_inc


in that 25000 us range I want to know when stuff happens

pick a start...

0 top of loop
99 just before frame inc


total range 0 to next 0
get a start point
get other values referenced to this start point....

show in text or draw rect...

function to get a single timpestamp...



so basically after a bunch of testing...

move takes around 10-20 us and draw takes 400-500.

lets say .5ms out of the 25ms period...lots of time....

I cant wait to profile what the server does with send stdf, especially to multiple clients...

can I store these?
calc every frame...
every 1s take max and averages

for now lets move on to the packet timing thing....


- server sends ping to client
- client replies
- server gets reply and measures stuff...


void server_control() // main server loop to process packet send and receive
{
   ServerListen(); // listen for new client connections

   if (mwPS.frame_num > 100)
   {
      if ((mwPS.frame_num % 80) == 0)
      {
         for (int p=1; p<NUM_PLAYERS; p++)
            if (players[p].control_method == 2)
            {
               Packet("ping");
               ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
            }
      }
   }


client recieves....

this means I am going to implement the same packet buffer things for the client....

It should be as common as possible....

use the same buffer struct, but will need different fast rx loop..



I really want to do away with the 2 blocks in client...



the first one, block until sjon rx.....

can't i just put it into a mode where all it does is wait for that?

what can I use for the mode?

control_method???
but the server will try to overwrite it....

what mode is it in already? none...
mode 2 but inactive???

suppose I set mode to be 7 - client waiting for sjon
then mode 6 - client waiting for initial stdf


find out what control_methods are currently used...
0 local
1 demo
2 remote
3 local server
4 local client

8 level done ack
9 used client

yes use 7 and 6 like you discussed

as soon as client sends cjon...
set control_method 7 and continue

until sjon is received client does not know what player number to use...so use 0 until then

so I will have player 0, active, and control method 7....???

I have the fast packet set up to process sjon also..

what about client in cm 7...



when client runs in mode 7 it immediatley tries to load level 0000 and fails...

what can I do to stop this?

I can use a different program_state?
not 11...

is that not what they were made for??

23 client wait for sjon
22 client wait for initial state

when starting client, start in state 24
init network
send cjon
go to state 23

state 23
wait for sjon
set up stuff
load level...etc


go to 22

state 22
load level abnd

wait for initial stdf

go to 21

the problem is the initial state will not match the current frame, which is zero....
I need to make an exception here

that seemed to do it....


now rid of any mention of blocking in client....done


where should I put the fast_packet stuff?

where should I put the timestamp stuff??

where should I call them from??

make it possible to abort client join sequence...

client does not stop when it gets no server response


________-------------------------------------------_______


this file is over 40K lines and 1M char...time to start a new one.....


20221228  ...done...
