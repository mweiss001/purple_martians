

------------------------------------------------
20180314 pi day

OK here I am converting to Allegro 5

imported the project from .dev into code::blocks

removed all e_ files and n_ files

in pm.h undefined sound DUMB netplay

now lets see if I can get it to compile...

first thing in that the new allegro headers cant be found:
fixed that..

fixed has been replaced with al_fixed???

when I'm doing things like this should I not do it for my entire project?

yes...

fixed -> al_fixed
BITMAP -> ALLEGRO_BITMAP
destroy_bitmap -> al_destroy_bitmap

DIALOG gone from 5
disable for now, maybe get EGG_DIALOG later

PALLETE ????? ditch it

END_OF_FUNCTION(inc_timer_passcount);

void inc_timer_passcount()
{
   timer_passcount++;
}
END_OF_FUNCTION(inc_timer_passcount);

void second_timer()
{
   fps = passcount - last_fps_passcount;
   last_fps_passcount = passcount;

   frames_skipped_last_second = (players1[active_local_player].frames_skipped - last_frames_skipped);
   last_frames_skipped = players1[active_local_player].frames_skipped;
}
END_OF_FUNCTION(second_timer);


   LOCK_VARIABLE(timer_passcount);
   LOCK_FUNCTION(inc_timer_passcount);

   LOCK_VARIABLE(fps);
   LOCK_VARIABLE(last_fps_passcount);

   // this is for the fps
   LOCK_FUNCTION(second_timer);
   install_int_ex(second_timer, BPS_TO_TIMER(1));



it looks like the old timers, called a function...
where the new ones generate an event


I only have 2 timers:
1 to count actual frames per second
1 to control the frame rate
both are only used in the game loop
I'm having trouble thinking why I want to do this with events...

one solution is to spawn another thread that does nothing but update passcount

or in my loop, at the frame delay I can wait until i get an event...

al_create_timer
ALLEGRO_TIMER *al_create_timer(double speed_secs)

Allocates and initializes a timer.
If successful, a pointer to a new timer object is returned, otherwise NULL is returned.
speed_secs is in seconds per "tick", and must be positive. The new timer is initially stopped.
Usage note: typical granularity is on the order of microseconds, but with some drivers might only be milliseconds.

See also: al_start_timer, al_destroy_timer

al_start_timer


al_get_timer_count
int64_t al_get_timer_count(const ALLEGRO_TIMER *timer)
Source Code

Return the timer's counter value. The timer can be started or stopped.

See also: al_set_timer_count

I think with this i don't need events at all



'fps_timer' will be the name of my new timer

ALLEGRO_TIMER * fps_timer = al_create_timer(0.025);


"timer_passcount" used to be the variable that got incremented in the
old timer loop.

now it will be al_get_timer_count(fps_timer);


void al_set_timer_speed(ALLEGRO_TIMER *timer, double new_speed_secs)
Set the timer's speed, i.e. the rate at which its counter will be incremented when it is started.
This can be done when the timer is started or stopped.
If the timer is currently running, it is made to look as though the speed change occurred precisely at the last tick.

void al_set_timer_count(ALLEGRO_TIMER *timer, int64_t new_count)
Set the timer's counter value. The timer can be started or stopped.
The count value may be positive or negative, but will always be incremented by +1 at each tick.


disable the fps per second one for now...
commented out in main



change the timer:

add global and extern in pm.h
ALLEGRO_TIMER * fps_timer ;

create timer in initial setup:
fps_timer = al_create_timer(1/fps_passcount_timer);


look for all mentions of timer_passcount and replace with al_get_timer_count(fps_timer);
or set...  done




sprintf() needed <stdio.h>?? why didn't it need it before??'


config is all fucked.. more more int float string, now its all string
will need to make convertors...atoi and itoa...etc


also I need to load the config file first...

where do I do these things in my program?

right after allegro_init

set_config_file("pm.cfg");


why don't I load it in initial setup
and destroy right after.

whenever I want to save a change i will need to load the file
make the change and save it.


i should have one function that saves everything to config
and also one that loads everything

what do i do about defaults??

make my own load data from config fucntion




----------
fixtoi --done
fixtof -- done
itofix - done
ftofix - done

rest all chnged to al_rest

al_create_bitmap done all



scrn.cpp
killed most of screen setup

just make a 800x600 window

global and externed
ALLEGRO_DISPLAY *display = NULL;


   display = al_create_display(640, 640);
   if(!display) {
      fprintf(stderr, "failed to create display!\n");
      return -1;
   }


blit( src, dst, 0, 0, dx, dy, src->w, src->h)	al_draw_bitmap( src, dx, dy, 0)
blit( src, dst, sx, sy, dx, dy, sw, sh)	al_draw_bitmap_region( src, sx, sy, sw, sh, dx, dy, 0)
blit


first set al_set_target_bitmap

screen_buffer will need to be replaced with the back buffer

what do i do with SCREEN_H and W??
global and extern SCREEN_H



al_get_display_width
int al_get_display_width(ALLEGRO_DISPLAY *display)
Source Code

Gets the width of the display. This is like SCREEN_W in Allegro 4.x.

See also: al_get_display_height

al_get_display_height
int al_get_display_height(ALLEGRO_DISPLAY *display)


made scrn.cpp compile by gutting it...


sound compiles...

player compiles


now i'm in menu how am i going to do key input??

void al_get_keyboard_state(ALLEGRO_KEYBOARD_STATE *ret_state)


// Returns whether or not a specified key is being pressed
bool key_pressed(int key)
{
   ALLEGRO_KEYBOARD_STATE s;
   al_get_keyboard_state(&s);
   return al_key_down(&s, key);
}
This was a function I wrote for Deluxe Pacman 2 to wait for a keypress or xxxx amount of milliseconds before continuing (this is the trimmed down version)...

#SelectExpand
  1// Waits a specified time (in ms, 1000=1s) for a key to be pressed.
  2// Will also respond if a mouse or joystick button is clicked.
  3// If the time passes before a key/mouse/joystick is pressed, the function returns
  4// If the time specified is zero, the function will wait indefinitely.
  5bool wait_for_keypress(double wait_time)
  6{
  7   double ts = al_get_time(); // time stamp
  8   double elapsed_time;
  9
 10   al_flush_event_queue(event_queue);
 11
 12   bool done = false;
 13
 14   // Wait until the specified time passes or a key is pressed.
 15   do {
 16      al_wait_for_event(event_queue, &event);
 17
 18      if(event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
 19         shut_down(); // free resources
 20         exit(0);
 21      }
 22
 23      else if(wait_time && event.type == ALLEGRO_EVENT_TIMER) {
 24         elapsed_time = al_get_time() - ts;
 25         if(elapsed_time >= wait_time) return false;
 26      }
 27
 28      // Wait for key to be pressed and released to continue
 29      else if(event.type == ALLEGRO_EVENT_KEY_UP) {
 30         if(event.keyboard.keycode == ALLEGRO_KEY_ESCAPE) return true;
 31         else done = true;
 32      }
 33
 34      // And if a key wasn't pressed, maybe a mouse button was...
 35      else if(event.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
 36         done = true;
 37      }
 38   }
 39   while(!done);
 40
 41   return false;
 42}
---


maybe I can register an event loop once in my program and then use it for menus
and whatever as well as the main game loop...


where am i??

either in menu or in loop


i got menu to compile

loop compiles..


now in lifts...
what am i going to do about color?

I'll make my own palette, with hookers and blackjack...

I can even still call it palette color...

all I need is the seed for each color...

make an array of colors:

ALLEGRO_COLOR palette_color[256];
palette_color[0]  = al_map_rgb(  0,   0,    0); // black
palette_color[1]  = al_map_rgb(191, 108,  232); // alt purple 1
palette_color[2]  = al_map_rgb(136,  32,  172); // alt purple 2
palette_color[3]  = al_map_rgb(60,  127,  255); // alt blue
palette_color[4]  = al_map_rgb(224,  28,   72); // alt red
palette_color[5]  = al_map_rgb(255,   0,  232); // pink
palette_color[6]  = al_map_rgb(255,  191, 127); // taan
palette_color[7]  = al_map_rgb(255,  127,   0); // orange
palette_color[8]  = al_map_rgb(127,    0, 255); // original purple
palette_color[9]  = al_map_rgb(  0,  255, 127); // alt green
palette_color[10] = al_map_rgb(255,    0,   0); // red
palette_color[11] = al_map_rgb(  0,  255,   0); // green
palette_color[12] = al_map_rgb(  0,    0, 255); // blue
palette_color[13] = al_map_rgb(  0,  255, 255); // lt blue
palette_color[14] = al_map_rgb(255,  255,   0); // yellow
palette_color[15] = al_map_rgb(255,  255, 255); // white

for (int x=1; x<16; x++)
{
   int c = (x+1)*16 - 1;
   palette_color[x*16]  = al_map_rgb(c, c, c);
}

this is my old fade proc

         int x;
         int cn = b1_color;
         float ns = 15;
         for (x=0; x<ns; x++)
         {
            pallete[cn+(x*16)].r = (unsigned char) ( pallete[cn].r * (1 - (x/ns)) );
            pallete[cn+(x*16)].g = (unsigned char) ( pallete[cn].g * (1 - (x/ns)) );
            pallete[cn+(x*16)].b = (unsigned char) ( pallete[cn].b * (1 - (x/ns)) );
         }



it seems to work good..

i just had a thought...
all this stuff I have always been doing with the way i set up my palette...
its just basically an alpha channel...
by adding 16 to the color i decrease the alpha because that s how i set up my palette


im just testing things in mtest for now...

so far I have

load sprit
drawing primitives
made my own palettte
textout

I really need to figure out keyboard input


make an event loop...done...

it looks like the example i followed show an easy way to re-implement the old key[KEY_*] fucntionality

first of all i need to create key[256] with names for all the actual keys

i want to reuse as much as possible....

al5 aleady has somthing like this...ALLEGRO_KEY_*

looks like I can already if I use
bool pressed_keys[ALLEGRO_KEY_MAX];
pressed_keys[key_code] = true;


---------------
create my own array like:

bool key[ALLEGRO_KEY_MAX];

now in my event loop get key downs and up events, run function to set my array

the only thing i won't be able to do is while(key[KEY_ESC]);

unless i process in that loop..

am i getting lost here??

what do I need to do to make my menu work

make an event loop in initial setup..
register screen and keyboard events
poll it in the menu

ok im ready to go back to the game....

lift color is what I was working on

add primitives to game

patch my colors into the game...done


lifts now compiles


can i do a global replace for textout??

al_draw_text(font, color, x, y, ALLEGRO_ALIGN_CENTRE, msg);

i might need to specify a display or bitmap..

items compiles

fnx compiles

file compiles by commenting everything out...

emove compiles


on to control

I have to do something about keyboard input...

- set up event loop and hook keyboard up to it

process the event queue in proc_controls...

i want a non blocking way to look for events...

control done...

bullets done

yfilecom..done

now.. remove all other files from project and try to compile...


got as far as trying to start a game...


i can run the game..with lots of problems..

rotation of bitmaps..

players bitmap not filled
filled but need top change colors

control does not works.fixed

items do not show...fixed

make scaler work...


make function keys work...
re-enable function keys
scaler works
speed no

up screen res to 1024 768 for now


make lift prox rect work
mostly done..just need to patch in vertical name when rtext is fixed

do the transparency of player properly

where should I do transparency?

when I created the bitmaps on load??

does it make any sense to keep color 0 in there??



convert mask to alpha at bitmap load and also when making player bitmaps

now do door bitmaps...done...


now fix item draw.

door done..

now key in ans..


what is left to do for item draw:
key in final seq...
stretch draw for bombs


now make enemy draw better...

I fixed the rotating conversion from fixed to float

I am having trouble converting my rotations
what point do i pivot on??

it was as simple as setting the center pivot point to 10,10
and then offsetting the pos x and y by 10

works for player too...!!

i want to get speed working again.. and top display..
ok done...

time for a backup and work...


20180316 7:45

seems like I'm skipping a lot of frames...

rocket draw...fixed

removing blocks with key or breakable leaves lines..fixed

bullets alpha looks good...

block walker block to show...done



frame and title to show frame...done

that is using the backbuffer, instead of screen buffer
i think I should do this in all cases anyway
its an extra layer of complexitry to do both..

frame during game...done
this uses the screen buffer

run the menu using proc controls..done

still needs some work...




game seems to run slow...
can i run it wide open

like in speed test...

still only get like 20 fps

make the fps skipped per sec and actual

how??


create a second timer
check it in proc frame delay



looks like draw item and set draw item shape are high up on the profiler list...

also _mcount private??


i get 22-23 fps
with item_draw_disabled I can get 29-30 fps


everything seems slow...


20 fps base

- get new background 28
- draw items 28
- both 38

also
- draw enemy 56
- draw lift 56
- draw player

no dif

draw pbullets is really bad... why???
no its not that...
that was just the last thing i disabled

with all these disabled i get 170fps

         // these all draw on level_buffer
//         get_new_background();


//         draw_lifts();
//         draw_items();
//         draw_enemy();
//         draw_ebullets();
//         draw_pbullets();
//         draw_screen_msg();
//         draw_players();


as soon as any one of them is enabled it drops to 50


all those functions have in common is:
al_set_target_bitmap(level_buffer);


set this:
al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);

made things a lot faster...

now...


base 32
no item draw 52
no enemy draw 90
all others but get background no change
get background (all disabled) 256


I guess i was mistaken about memory_bitmaps
with allegro 5 they are slow, and video bitmaps are the way to go...


next, why is draw items so slow...

-------------

my bitmap are created with 4 byte per pixel and 32 bits per format

lets try to half that...


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA); ..fails
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works





base 40 fps with get_new_background only


al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
90

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
94

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
102



base 22 fps all

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
32

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
28

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34



draw items does a weird thing were it gets the bitmap to draw in dtemp
if i disable that it gets faster...






tried creating display with windowed, resizeable window no fps diff

fullscreen window went from 32fps to 28
screen size went from 1024x768 to 2048x1152

actual full screen was about the same..


fixed item draw to not use dtemp

new base 1024x768 windows all on
52 fps

enemy draws with dtemp too...fixed
new base 1024x768 windows all on
80 fps


draw enemy is completely done

draw items need to have stretch implemented...
for bombs and moving keys


i think draw items is done, but i would like to simplify it...
rot is used by key and rocket only...
stretch is used by key only, and maybe explosion??
key uses 11 for scale 10 for rot (/10)
rocket uses 10 for rot
lit bomb uses 10 for scale ()/ 100)
if I change:
lit bomb to use 11 to scale..
and make all these / 100
other items uses 11 and 10...
leave this for now




item draw and enemy draw are done, game runs at good speed

let make the menu better...

keys left and right need holdoff...
how about if menu is started with those keys pressed, wait for release...


menu and start screen are all fixed..

lets do the health display and progress bar...done

now free men...done

now frame..done

now small text on door bitmaps...


im going to make or use two bitmaps to do this...

1014 in.
1015 out.

do this when creating door bitmaps
small text for doors is done


now how about controller setup

maybe i should do the save config first...


201801318 5:00 I did a lot yesterday...


today I want to:
finish cfg file
controller setup
remove use of screen buffer in game and switch to backbuffer
sound
help

add to all error msg, native dialog pop up

test keys is done
most of controls is done, still left
key names...done

joystick..


use the same key struct as keys

in controll set the appropriate key...


its looking good,


only works for first joystick right now...

i'm not sure how to do more..

the joystick struct does not correspond to id..
leave it for now
edgar reynaldo posted a solution...

code is good now...








lets do some sound...


scalers were from 0-9

a typical example for bullet is:

(180 * se_scaler)/9

(180/255)  = .71 * (float) se_scaler / 9


sounds are coming along nicely..

i need a way to stop them, especially fuse hiss...

// this plays pm.xm just fine...time to kill DUMB!!!!

   temp_song_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
   al_attach_audio_stream_to_mixer(temp_song_stream, al_get_default_mixer());

nowhere in the sources is dumb found!!!

make a seperate mixer for se and st and make it work with scalers

do i need sound on/off???

just patch it in the mixer somehow


im having hard time with config files


make load do nothing but get values and test limits

then call save to set menu's and whatever else

save also called when program changes values


done....



remove use of screen buffer in game and switch to backbuffer


mostly done, do the rest as it get uncommented


i want to fix mtextout done
bottom message and level done is good...

now I want to fix tsw()...done



rtextout done...
screen message done...
join_quit_done...



20180318..got a lot done today....


20180319



native error messages..done

screen change by dragging...done, it was easy...
hot key for full screen F12..done..

changing volume when sound off causes crash..fixed
fps to show up on menu to start...fixed

next to do...

file selectors
help
graphical level select
mdw_logo and splash screen
new menu for all of my option that need setting

20180319 0650


stimp and stamp done


change proc_controls to return int
0 normal return
not 0 = scan code of keypress

mdw logo is done... looks a little thin...

i could spend a lot of time making the logo look awesome...

i would like to make the thickness automatic based on the size...
i would like to do some fading with real colors instead of palette..

done

now patch in the splash screen toggle...

do i have to reload everthing from config?  why not??

mdw_logo and splash screen done...

menu redraws map every frame
this takes time.

when on options menu is not drawn and mdw_ans run much faster...

could i also re-purpose proc_controllers() to do delay?
i could think of my proc_controllers() as my event loop processor...

maybe later...


20180320 6:50

next to do:
help
graphical level select
new menu for all of my option that need setting



20180321 6:55

native file select working...
paths were a bitch.. lots of conversions and checks
full path is used, might break run game from command line...
demo mode has been fixed also

bug in changing scale, leaves artifacts if smaller than entire screen.
fixed, in get new background, clear to color after setting backbuffer..

bug: demo mode can be cancelled with any key except ESC, just starts new demo
run game can be cancelled with any key, make it just esc..fixed
demo timeout not reset..done

figure out how to use code blocks to make a nice backup solution..

20180321 1200

next to do:
help
graphical level select
new menu for all of my option that need setting
timer to make menus run at same speed

help is coming along nicely...
help is completley done...20180321 16:45


next to do:
graphical level select
new menu for all of my options that need setting
timer to make menus run at same speed
some way of saving the screen size...
netplay
overlay screens


20180322 6:50
graphical level select is done..., but...
doesn't work with mouse...never did anyway only keys
cant handle screen size change..fixed
used global Redraw...


20180322 10:00

next to do:
timer to make menus run at same speed
new menu for all of my options that need setting
some way of saving the screen size...
netplay
overlay screens


timer to make menus run at same speed
should I block in proc_controllers() ???
yes but only for menu..

menu timer things is working good now...

next
overlay screens
netplay
new method for all of my options that need setting
some way of saving the screen size...



network


libnet.h
where should i put it? in my local stuff?? why not..seem to work

zlib was found without me doing anything...
comes with mingw..
version 1.2.11, January 15th, 2017

everything compiles because I have NETPLAY undefined....
now I have tons...
replace allegro error with m_err

now everything compiles, i just need the library...

C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a

link with:
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libwsock32.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libz.a

compiles and links...

need to fix the timer adjust in client...done...

now I need to fix many, many text lines in overlay...done...

now lunch and some real work...
12:40

hooked up the mouse to the event loop...
used it to make adjust spline work...






tested netplay with i990 server and old version 6 on m7667...worked perfectly..



tried to compile on i990 and dir struct if different
mingw is in C:\al5


i like my i990 version better
codeblocks, mingw and allegro are all in c:\AL5

C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a


actually i can do better than that:

C:\al5\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw32\i686-w64-mingw32\lib\libnet.a


compiles on both machines goodly now...



net game works between 2 a5 games

save and load server_ip to cfg file...done


now add screen stuff to logging...


what is screen stuff going to look like now?

same:
sx, sy
scale_factor
show_splash_screen


add:
window x pos, y pos
full_screen


lose
gfx_card
color_depth??
auto_full_screen


-----
done...now save and load them in config..done


now make them work...

what comes first?
init screen or get config?? fixed..

reads on init just fine

save on change

Question about ALLEGRO_FULLSCREEN_WINDOW

I am trying to save the window size and position, so that it will
persist when the game is started again.

Mostly everything is working good, except for a few minor things:

Here is what works:

- I create a display with a certain width and height
- then I let the user resize and move the window
- I save the display size and position in my config file
- It comes back perfectly the next time the game is run


Here is what doesn't:

When I switch to ALLEGRO_FULLSCREEN_WINDOW and back,
the window uses the values that were used to create the display
not the window size that it previously was

I can store my changed position, and then when I change back
- restore the position (easy)
- resize the display (takes a whole other resize)

What I would really like to do, is be able to modify the values
in the display structure, so that switching back, goes to the values
that were there before I switched into ALLEGRO_FULLSCREEN_WINDOW,
and not the ones used when creating the display.


From the manual:

"The passed width and height are only used if the window is switched
out of fullscreen mode later but will be ignored initially."


I suppose I could just destroy and re-create the display, but that
seems like a bit of overkill.


Does anyone have any advice on how I can achieve what I'm trying to do here?


---------------

I have a thought...

instead of changing to fullscreen using the screen thingy
i could just resize it my self to max size...


// moved all the screen change code to one place


variables

display position (relative to desktop)

disp_x_curr (either wind in windowed mode or 0 in fullscreen mode)
disp_y_curr

disp_x_wind (use when restoring from fullscreen)
disp_y_wind

disp_w_curr (either wind or full)
disp_w_wind
disp_w_full



it seems to work, but still takes a while to resize...

now i need a reliable way to get the desktop width and height

how about I create a fullscreen window, grab the w and h then switch out and resize


also my window keeps creeping up....fixed


how can i make reloading bitmaps faster...

store them in memory??

ok


first load puts them in both

next loads from mem to vid...


---------------------------
20180324 0500

cleaned up the screen code a lot
made separate functions to show flags, option, etc..

created temp memory bitmap for reloading..

fill them at creation

sprit player door
doesnt seem any faster

what if i make them all sub_bitmaps and just restore the parent??

first make a video and memory bitmap to store the tiles 640 x 640
then create memory bitmaps with clone_bitmap

seems much faster...

now players and doors...


first....

create them and save them to disk as bitmaps.. just like tiles

what size...


players 19 x 16 = 380 x 320

doors 16 x 8 x 2 = 320 x 320

doors 8 x 32 or (160 x 640)



looking good...

permanently save IN OUT to tilemap..

can I save tilemap??

haven't since a4
done..
my saves now are 24bit bmp and are 3x the old size of 8 bit...


shit is super fast now...



bugs:

resizing display in help, need to reset last line...done

coming out of help, need to redraw menu map
if in game exit, screen change has to recreate the level buffer too.
it should be doing that already...
draw_level..but blocks are gone????
only if screen changed during help...
what does load level do that i don't do...
cant tell...
i know that the bitmaps are getting reloaded...
initl2000 is getting called
l2000 is blank, but why????
at the end of help the target bitmap is cleared....!!!!!
fixed

help screen bitmaps are gone when resized
used global Redraw to fix this...

rtext for lifts..done in game..maybe some in level editor i'll get later

save scaler when changed, i think it is...done

create cfg file if none exists...done



-----------------------------
20180324 0936

coming along real good now...

new to do:
do something with screen size menu thing...not needed

save game...

method to change options...
try menu??

splash_screen_on...dont save the current value
make another called splash_screen_done for current stuff

extern int show_splash_screen;
extern int splash_screen_done;
done..........

bug, when on options menu, change screen then go back to main menu
stuff is getting drawn on level buffer, no l2000
i could make l2000 set cabk buffer back...
but shouldn't other make sure its drawing on right thing??
done.. at start of menu, set target...





ALLEGRO_MENU *menu = al_create_menu();
ALLEGRO_MENU *file_menu = al_create_menu();
al_append_menu_item(file_menu, "Exit", FILE_EXIT_ID, 0, NULL, NULL);
al_append_menu_item(menu, "File", 0, 0, NULL, file_menu);
al_set_display_menu(display, menu);

al_register_event_source(queue, al_get_default_menu_event_source());
al_wait_for_event(queue, &event);

if (event.type == ALLEGRO_EVENT_MENU_CLICK) {
   if (event.user.data1 == FILE_EXIT_ID) {
      exit_program();
   }
}

I have set everything in the menu that I can...
basically only bools...

I would really like to set:
server IP, fuck it, do it from commandline...

works great, except i get random hard crashes...

bug; clear keys at level done

music loop only plays once



lets try it on more machines...

XP???
the procedure entry point _time32 could not be located in the
dynamic link library msvcrt.dll

10...works good...
still get crashes from options menu toggle....


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...

key shifts....



make it so that you can't put the window off the screen

fix the fake keypress mode...

make overlay have an opaque background...done


make it so that you can't put the window off the screen
only on first start...
only in windowed...
done


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...


make run game work from command line..done

finish active player list on run game overlay..done


key shifts done
done for level inc dec
done for speed inc dec
what else is there?? ...log file viewer

blind_save_game_moves(1);
done
now text version...done
now we just need the file selector version :()
done


random hard crashes after using menu toggles
fixed by not creating second display


save_log_file();
log_file_viewer
done
20180324 1039

i have got a lot done today...!!


bug; clear keys at level done
added clear key array to start mode

map..done


screenshot.. done but PRINTSCREEN does not work. had to use PAUSE
fixed

I have been thinking overnight....

I have a couple of big issues...
- speed up the game so it doesn't skip frames
- fix the bug I'm still having about wrong player input...






lets look at the bitmaps i'm using...



first of all the display

display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
---------------------------------

the important stuff is:

ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_COLOR_SIZE:32
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888

now let look at some bitmaps i create like l2000 and level_buffer


pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


lets try creating a display with ALLEGRO_OPENGL
crashed...
ALLEGRO_OPENGL_3_0 starts but both that and ALLEGRO_DIRECT3D_INTERNAL
are listed...

abandon this for now


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE)

desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:5
ALLEGRO_GREEN_SIZE:6
ALLEGRO_BLUE_SIZE:5
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:11
ALLEGRO_GREEN_SHIFT:5
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:16
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


the bitmaps don't seem to have changed..
the game seems to run faster


can i do a 24??


desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
ALLEGRO_FRAMELESS
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP

exactly the same as 32 bit


OK go back to 16 and lets look at bitmaps


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_ARGB_8888


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
fails to create


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_RGB_565
works but has no alpha...duh!

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA)
fails to create

what if i made l2000 and level buffer 16 with no alpha

that seems to work...

lets test and see the dif..

display 16 or 32
l2000 and level_buffer 16 no alpha


fullscreen 2048x1152
d32 l32  (55-60fps)
d16 l32  (55-60fps)
d16 l16  (58-62fps) slightly better


what is the bottleneck?

is is the huge l2000 to level_buffer each frame??


what if I made that only do a region??
let try and see if it gets faster...

//   al_draw_bitmap(l2000, 0, 0, 0);
   al_draw_bitmap_region(l2000, 0, 0, 1000, 1000, 0, 0, 0);

that got way faster...like 100-110

lets only do it for the section that maps to the screen...



what are SH, SW, WX, WY?

WY, WY are global but are used in
seem to be used only in stimp, stamp, and get_new_screen_buffer

SW, SH
used locally in set_scale_factor, get_new_screen_buffer, stimp and stamp


make global to tell what region on l2000 is currently being shown

call them:

int level_display_region_x;
int level_display_region_y;
int level_display_region_w;
int level_display_region_h;

that seems to be a lot faster

map on menu is messed

set in stimp and stamp

no, unless in a game do it all..

use game_exit?? yes

this all seems great and seem a lot faster

lets test...



speed test
ill need to redo it...
i should just run it wide open and manually adjust the screen to start...

nv59 starts out fullscreen 1600x1200 at >100fps then drops to less than 40 in 15s
sometimes jumps to 80


nv59 sp  w 200 drops to 100
nv59 sp  f 80 drops to 35

nv59 demo w 60 drops to 35
nv59 demo f 20

i990 sp   600w 100f
i990 demo 180w 72f

m7667 can do 386 fps in a window!!! and 200 fullscreen

eid can do 800 in windows and 400 fullscreen

demo mode why slower???

disabled all screen overlays, should not be that..
disabled rungame_key_check()
changed proc_game_move() look back thing
all no diff

going back...

I have a new idea about speed test.

run game, or demo and record fps every second

then adjust screen resolution on the fly...

make a pretty graph...


name and screen resolution in screen title...done

make get new background get a little larger..done
what order is stuff drawn in??


log file viewer file select
make a new file... zlog.cpp
do it....done....


redraw map when leaving controller menu
test keys...fixed...


bomb's explosion animation seq is too low, center it better
looks good to me...








level_editor

bring in the files...e_editor

coming along goodly....


status window creates new bitmap every time its drawn
make it draw itself every time...
now dont need code to draw its bmp or even its bitmap...


status and select window are now perfect...
1 day later even more perfect...
removed all bitmaps they draw on.
only one function for each, draw and process
disable resizing of blocks and special sub windows


moving on...


pop up menu is transparent..make background opaque...done


next...zoom full screen...

looking good...
i can copy and paste

file stuff disabled for now

screen size change messes with text button positions

clear disabled until erase lifts brought back..done

blocks on off not updating fsel?? looks good now...


new backup

20180328 0700




should I make my own file select dialog?
I hate the way the native windows one looks...

i would have to implement a list box...

what if I just make a wrapper for the gui so i can call it in one line_draw_modelike I used to:

      FILE *filepntr;
      extern char sel_filename[500];
      sprintf(sel_filename, "sel\\");
      if (file_select_ex("Save Selection", sel_filename, "sel", 500, 0, 0))
      {
         filepntr = fopen(sel_filename,"w");




re_implement file_select_ex as
mw_file_select(const char * title, char * filename, const char * ext, ALLEGRO_COLOR col);

works great, add option save  and force extension..done..

i could re-do my file access to use the allegro methods...maybe when I've got too much time on my hands...


re do it for rungame save...no that has a special case where i only need the filename and I add my own extensions .gm and .txt

OK whats left in zoom full screen???

random...done

brf...done...

look like zoom fullscreen is totally done..

so is everything in e_editor...

next ...

viewers...will be huge...

but first:

status and select window positions when screen changes

where does db and lefsm get changed when screen size changes??
all done in set map var...

after screen resize items and enemies are gone?
try draw big..


backup...
20180329-0700



object viewer is looking very good
map move too...



--------------------
20180330 0700

item viewer
creators
pop message editor
save and load
all done

next big thing...lifts


lifts is all done except for text...

replace all alert with native msg...


//      gui_fg_color = palette_color[14];  gui_bg_color = palette_color[14+224];
//      alert("Error creating lift step:", (char)NULL, "40 steps is the maximum", "OK", (char)NULL, (char)NULL, (char)NULL);
//      gui_fg_color = palette_color[9]; gui_bg_color = palette_color[0];

         al_show_native_message_box(display,
               "Error", "No creator exists for the current item type",
               "Copy from an existing item of that type, or get one from the selection window",
                NULL, ALLEGRO_MESSAGEBOX_ERROR);




now alert3

if (alert("Move the key's", "block range also?","","Move", "Leave", 'M', 'L')==1)

if (al_show_native_message_box(display,
               "Move?", "Move the key's", "block range also?",
                NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION );


if (al_show_native_message_box(display,
            "Move?", "Move the key's block range also?", NULL, NULL,
             ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)




level viewer is mostly done...

it used a trick where the grid was not redrawn

in order to make it work now, i'll need a temp bitmap
what size...?? 1000 x 1000

e_lev is all done:

next to do:

text input for lift...


glt is totally done too...


the only files that are not back in the project are:
e_bitmap
e_guifnx
and they will probably not come back....
pde is mostly disabled too...



kill all scrn_buffer...
153 refs...
all done except for some unused re-size code in special
also fix all clips..



draw pop message on item viewer leaves artifacts
but only when switching from one message to another
why does it not redraw then?
as far as i can tell, it should redraw every frame..

it was because draw pop message set target to something else


sproingy adjust...done
crosshairs line 16 inside rect
928 for highlighted rect
text entry box done!!!


help quits to far..trap esc or mouseb...done

make screen adjust work with level editor and les
looks good in zfs, obj and lift viewers...

make les adjustable in le done

used F2, same as speed testing in game

I need a variable to tell me if i'm in the level editor

level_editor_running done

mouse off map in main editor...done





lots done over long weekeknd

new backup...
20180401 1025

mouse shown during game and menu screens...done
make save level have filename automatically filled in...done



I am new to the whole blender thing and have spent many hours trying
to figure out what I though would be a simple task.

I am trying to draw a bitmap onto the backbuffer and blend it with the
backbuffer.

This code from the examples works great:

al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

But my source bitmap has an alpha channel, and I can't figure out how
to get that respected...no matter how many different combination I try
I always get the zero pixels blended also.

I have tried al_set_separate_blender with many different combinations
and gotten nowhere.

I have read the docuemntation many times, and looked at other explanations
of blending of the web.  But I can't seem to make it work.


<code>
// this draws a background of colored squares
   ALLEGRO_COLOR c[5];
   c[0] = al_map_rgb(255, 0, 0);
   c[1] = al_map_rgb(0, 255, 0);
   c[2] = al_map_rgb(0, 0, 255);
   c[3] = al_map_rgb(255, 255, 255);
   c[4] = al_map_rgb(0, 0, 0);

   al_set_target_backbuffer(display);
   al_flip_display();
   al_clear_to_color(al_map_rgb(0,0,0));

   int ci = 0;
   for (int y=0; y<10; y++)
      for (int x=0; x<10; x++)
      {
         al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, c[ci]);
         if (++ci>2) ci = 0;
      }



// this is the bitmap I am drawing
   sprintf(msg, "Test") ;
   int sw = strlen(msg) * 8;
   ALLEGRO_BITMAP *temp = al_create_bitmap(sw, 8);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));
   al_draw_text(font, ci[3], sw/2, 0, ALLEGRO_ALIGN_CENTRE, msg);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0));


// here is where I have tried just about every blender combination I can think of

   al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
   al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);



// this is where i actually draw  it
   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temp, sw/2, 4, 88, 48, 4, 4, 0, 0);
   al_flip_display();
   al_destroy_bitmap(temp);

</code>


When I don't specify any blender I get a nice masked text over background.

When I try this:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

I get a nice blended source and dest, just like what I wanted,
except the alpha is not respected and I get a rectangle around the text.


I tried:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0));
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 1));
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
but they all made no difference.

I tried:
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);

al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_ZERO);

plus many more combinations, but I can never get the alpha mask to work...

Can anyone with more experience with blenders help me?

Do I somehow have to do this with 2 steps?

My overall goal is simply to have a partially transparent bitmap superimposed over
another bitmap (the backbuffer), (kind like a water mark), but I want it masked so the
zero pixels are not blended with the background.




pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565




looking at different fonts..

great vibes is a free calligraphic font I might use for logo
by typesetit
licensed under OFL

I should make my own larger text display function

it purpose to display very large text based on screen and font size
one and two line versions



for a few days now I have been working with ttf

I have a nice new script font I'm using for ichael avid eiss

It's called 'Great Vibes'
by: typesetit
license: OFL

I also like:
SaucerBB.ttf
but it only free for non-commercial use..
It looks good as my main logo..


I have replaced mtextout() with a similar function
mtextout() was slow, so the new one uses pre-draw bitmaps
for ichael avid eiss
seems a lot faster...

I moved all code for logo and splash screen to its own file: zlogo.cpp

I think I am finally happy with the beginning splash screen

now I want to redo demo mode...

its too slow to draw the large text every frame
I could make another temp bitmap like the others...done...

what am i doing?

I am spending a lot of time making fonts and stuff look pretty...

when will it end???

to do:
-width of splines smooth change
-splash screen to not flash when quitting
-new title with new font

all this is done

predefined enemies editor..done


map not redrawn completely,
probably due to not drawing all of level buffer...
yes...lets disable map
just at the function key level...





orthographic stretch during game, and or menu screens
move to F11
choose another key for controller test exit other than F11
auto choose ortho based on screen size
maybe I could make othro strecth CTRL SHIFT F12
done...


now make les auto chosen based on screen size...

where??
init screen
also screen change

make a seperate function

set_display_transform_double()


how?


rebuild bitmaps does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;
   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


init screen does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;


   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


why dont i put that in set_les


need a function to set ortho
called by init and change

make set_les do auto


rebuild does
set ortho

init does:
auto_set_les();
set_ortho();

change does:
auto_set_les();
rebuild
( set_ortho(); is done in rebuild bitmaps)

F12 does
rebuild

this works...

now to auto set
never auto choose 3

SCREEN_W > 1024 les = 2

looks good in game, but level editor??

does scale change with les??

it should...done
but when its saved with a different les???
its good


demo mode
resize
fullscreen...
goes really slow and no title..
2 resizes...
only in demo mode
fixed..font not destroyed before recreate



do I need to load fonts at 400??
what does 200 look like?
"saucer"
used for:
main tile Purple Martains
main title created by
menu title
level done
demo mode
240 is good enough

"a charming font"
used for ichael avid eiss
240 is good


locked exit to show number left


bottom display to not conflict with frame display (mostly in demo mode)
moved up BORDER_WIDTH



m7667 resize ok but going in or out of fullscreen causes exit when client
do I still have F12 exit key in client??
yes in 4 places...change to F11 for now
done....



client quits game, but freezes locally..
walk me through the sequence of client quitting
client presses ESC
client local control gets comp move of 127 and sends cdat to server
server add to game move array
in add game move special move exit is entered instead of escape
player state change to incative
in proc game move for local client become inactive...
this is the problem:
while (key[ALLEGRO_KEY_ESCAPE]); // wait for release, but send cdat first
do i even need this???


no mouse for options menu..fixed
restore full screen mode when leaving options toggles..done


log file viewer les...done




level viewer won't load good
keeps saying cant find file...400 times
fixed...



simplify num_enemy
int num_enemy in main in pm.h
counted in game in enemy collision
counted in level editor in sort_enemy
only only enemy_data now, no duplicate in lev

same for items..done



start level editor from command line
les is bad fixed


make my own option setting screens with my own sliders and buttons

netgame server text
deathmatch_pbullets_damage slider

I could do it with the menus that I have now..
make netgame menu...done
call it from old menu toggles..
done...
now implement the toggles
in config load set the menu values...done
edit and change with menu
this is all done....yay!!!
now if I do logging I can kill the stupid toggle menu...
done....!!!!
kill it!!!!

number pad keys to work in help...done

fix logo in help..done

when ortho changes
help divider lines off screen...fixed

close holes in menu
-bitmap editor is all that is left
do I still have release in pm.h??

Random mode in zfs
menu in editor
fake keypress mode
copy files to clients
packet test
log file viewer
temp test -g
record video
debug overlay for client and server






---------------------------------------------------------
should I make my background totally black?
---------------------------------------------------------
modify shapes 0-32 to remove really light pixels?
how could i do this??
save_sprit() is still there just commented out
load, modify, save...done


---------------------------------------------------------
what if my whole drawing routine is too complicated
---------------------------------------------------------
right now:
I have l2000 with all the blocks and lift lines drawn
every frame I start with this and copy it to level buffer
then all objectrs draw on the level buffer
then i take a screen sized region of the level buffer and copy it to the backbuffer
then I draw overlay on that
then finally I flip display

how many target bitmap changes: 2
switch to level buffer
and get new background
draw on level buffer
switch to screen buffer

how could i make it easier??

draw background directly on backbuffer from memory bitmaps
draw objects directly on backbuffer
draw overlay
flip

or...

draw background directly on backbuffer from l2000 (just like get new screen buffer)
draw objects directly on backbuffer (just need to change offsets)
draw overlay (same)
flip

test this and see if its faster...
made 1 change in get_new_screen_buffer()

i just realized, i have scaling going on too
i cant just switch from drawing on level buffer which is unscaled
to screen buffer, which is...fuck it, i'm not doing this




speed testing...

while speed testing use number keys to disable stuff to see the
performance hit

get_new background
screen meassges
bottom messages

show fps independent of overlay

wow, i got somewhere!
I found that bottom msg slows stuff down...
on nv59 it down a lot....


make the keys active at any time, not just speed test
show when something is disabled only

test big netgame...


it gets a lot faster when screen and bottom msg are disabled..

I should see if there is some way to optimize them..

like not using temp bitmaps...
like not drawing as many of them..
player health screen messages could be only for local player not all

basically i dont want to switch my target bitmap during game loop
and all of my fancy text routine do that...

what about screen overlay? should be just straight text...yes
what about percent bar?? no switch...its good

move show_player_join_quit to loop for disabling...
if (show_player_join_quit_timer) show_player_join_quit();
done

disable by default: 3 4 5 ...done

test some more...

what if i evened out frame skip
like every other farem, or every 3 or 4 frame...etc
why?  if one frame is slow wont they all be??


what if i made the fancy text drawing stuff off when frames skipped?

profile the text drawing stuff...
in game loop make a function that draw 100 rtext things to screen every drame

change health display to show +H or -H
use regular text

found a very small font called: pixel gosub
"Pixel Sagas" and "Neale Davidson" may be used interchangeably in this agreement. These all refer to the intellectual and legal property of Neale Davidson.
Usage
Pixel Saga's Shareware Fonts are free to use for personal, non-commercial purposes. No payment is necessary to use Pixel Saga's Freeware Fonts for personal use, and there is no limit to the amount of prints, pages, or other medium to be produced using them. However, you cannot offer the font for commercial sale, or offer for direct download. The inclusion of the font name and/or site URL in the credits or documentation when it is used is appreciated, but this is not mandatory.

is is otf but loads fine
i load with size 7
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", 7, ALLEGRO_TTF_MONOCHROME);
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", -8, ALLEGRO_TTF_MONOCHROME);
these both look good
its looks like 3x5 on the screen

ok now I never need screen message...


how about bottom display
i like how it looks...
but so what?, if its slow it needs to go...
fixed...

in draw player health display all is good...

in bottom message all is good

screen message, disabled

all that's left is join_quit..lets leave it

lifts use rtextout_centre()...
but only in vertical mode
its rare enough i'm going to leave it for now

speed seems good now across all clients except nv59
but nv59 has always had issues...

what if i did nv59 in a desktop screen size
less than the huge 1600x1200 i have been using??





---------------------------------------------------------
hysteresis window does not work
---------------------------------------------------------
always stuck to lower right corner
WX and WY needed to persist
made it a global again
bug happened after I made it local..



---------------------------------------------------------
------------------------ linux --------------------------
---------------------------------------------------------

got it to compile and run..

complains it can't create built in font

also can't load a4.tga

gcc version 5.4.0
allegro version 5.2.5??

i'm editting in 2 places at once
thats a recipe for disaster...

edit only on linux for now

the second crash was that I couldn't create a 16 bit display
fixed that...

splash screen has no large Purple Martians but has created by??
same font??
logo works
crashes a soon as splash screen done..

i'm running into max bitmap size

it says it 2048

when I create the title its close...

2090 one time
2034 another timeval
why the fuck is it different???

I don't know...

I would like the title as high a resoultion as i can...

'Purple Martians!' is 14 char

take max bitmap size and divide by 16

2048/16 = 128

8192/16 = 512


changed the load font function to create saucer font by
max bitmap / 16

also changed load built in font to try a4_font.bmp if it fails

left achafont at 240...
what's its max length?  'ichael' 6 char

2048/6 = 341
8192/6 = 1365
just leave at 240 for now...looks good...


as far as the display bit depth, i'll try 16 "SUGGEST"
works on linux just fine, gets 32 bit...


on linux the built in font seems to work now that I have a display...


its really slow

linux:
32 bit
opengl
render method: 2
max bitmap size: 2048
support seperate alpha: no

win:
16 or 32 bit
D3D
render method: 0
max bitmap size: 8192
support seperate alpha: yes


no matter what I disable, linux runs at 60fps

2 things..

downgrade allegro to 5.2.4..done
get gcc-7..done
rebuild allegro with gcc-7...

that made exactly no difference...


I tried opengl on windows and I got exactly 60fps also...

its the exact same as the desktop refresh rate..
I changed the desktop to 40 and my game followed...

try open gl 3

sudo apt-get install mesa-utils

glxinfo | grep "render string"


open_gl
seems to wait for vertical retrace before doing al_flip_display()

u swap method:0 same as w

w render method:0
w vsync:0

u render method = 2
u vsync:0

none of this works...
vblank_mode=0  (from command line)

GLX_EXT_swap_control
GLX_MESA_swap_control

moving on......

l seems to not change screen zize nicely..
in control...make sure all resize event are received before actually resizing

when switching away from fullscreen mode
sizes all look good, but still fullscreen??

in linux i try to set to fullscreen but get slightly less???


on the plus side, it looks like everything else is working good in linux

all that i need to figure out is the open gl stuff
with fullscreen, resizing, ortho, les, etc...


init screen
fullscreen:0 les:1
x:  10 y:  10 w: 800 h: 600 - curr
x:  10 y:  10 w: 800 h: 600 - wind
x:  10 y:  10 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
----------------------------------
Display change
x:  43 y:  47 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  43 y:  47 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:   0 y:   0 w: 800 h: 600 fs:1
changed to fullscreen
fullscreen:1 les:2
x:   0 y:   0 w:1280 h:1024 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 640 h: 512 - scrn
Display change
x:   0 y:   0 w: 640 h: 512 fs:0
changed away from fullscreen
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  35 y:  18 w: 800 h: 600 - curr
x:  35 y:  18 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w:1245 h:1006 fs:0
window resized
fullscreen:0 les:2
x:  35 y:  18 w:1245 h:1006 - curr
x:  35 y:  18 w:1245 h:1006 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 622 h: 503 - scrn


what if I tried ALLEGRO_FULLSCREEN_WINDOW....



this could be happening:

fullscreen mode is set
linux change to slightly less than fullscreen
my proc_screen_change() has no case to deal with this...

I should update the full screen sizes




ripped out all the custom fullscreen window shit
now it works good in win and lin except for
lin background wrong size??

fullscreen and back OK, only when resize...


l2000 get drawn wrong after resize and I don't know why
code is just about identical...

when I am setting ortho, I need to make sure i'm setting it for the backbuffer...problem solved


the good thing is that almost everything else works great..


lin window moves down 21 pixels, every time fs on/off







---------------------------------------------------------
------------------------ Static Linking------------------
---------------------------------------------------------
why?
so i dont have to distribute dlls with my project?

my method now (dynamic)

link with allegro_monolith-5.2

I need to distribute with executable:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

my exectutable is (3,209K)

total: 20,089K

what do I need to do static linking?

build allegro with static linking



From Neil:
https://www.allegro.cc/forums/thread/617338
In Code::Blocks, I use "allegro_monolith-static".

For my linked libs, I have (copy and pasted from my codeblocks project file). Maybe this will help...

<Linker>
   <Add option="-m32" />
   <Add option="-static" />
   <Add option="-static-libgcc" />
   <Add library="mingw32" />
   <Add library="dumb" />
   <Add library="FLAC" />
   <Add library="vorbisfile" />
   <Add library="vorbis" />
   <Add library="freetype" />
   <Add library="ogg" />
   <Add library="physfs" />
   <Add library="png16" />
   <Add library="zlibstatic" />
   <Add library="gdiplus" />
   <Add library="uuid" />
   <Add library="kernel32" />
   <Add library="winmm" />
   <Add library="psapi" />
   <Add library="opengl32" />
   <Add library="glu32" />
   <Add library="user32" />
   <Add library="comdlg32" />
   <Add library="gdi32" />
   <Add library="shell32" />
   <Add library="ole32" />
   <Add library="advapi32" />
   <Add library="ws2_32" />
   <Add library="shlwapi" />
   <Add library="dsound" />
   <Add library="jpeg" />
   <Add library="opusfile" />
   <Add library="opus" />
</Linker>

From wiki:
https://wiki.allegro.cc/index.php?title=Windows,_Code::Blocks_and_Allegro_5

-lallegro_monolith-debug-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlibstatic
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-static-libstdc++
-static-libgcc


compile allegro with shared off


this is my cobeblock project file:

<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="default">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-pg" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add library="C:/mingw32/lib/liballegro_monolith.dll.a" />
			<Add library="C:/mingw32/lib/libnet.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libwsock32.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libz.a" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>


static version   liballegro_monolith-static.a

dynamic version  liballegro_monolith.dll.a

in build options tried moving from lefthand side with full path
to right hand side like this:

old:
C:\mingw32\lib\liballegro_monolith.dll.a
C:\mingw32\lib\libnet.a
C:\mingw32\i686-w64-mingw32\lib\libz.a
C:\mingw32\i686-w64-mingw32\lib\libwsock32.a
new:
-lallegro_monolith.dll
-lnet
-lzlib
-lwsock32
worked...




<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="dynamic">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-lallegro_monolith.dll" />
					<Add option="-lnet" />
					<Add option="-lzlib" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
			<Target title="static">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
					<Add option="-lallegro_monolith-static" />
					<Add option="-ljpeg" />
					<Add option="-ldumb" />
					<Add option="-lFLAC" />
					<Add option="-lfreetype" />
					<Add option="-lvorbisfile" />
					<Add option="-lvorbis" />
					<Add option="-logg" />
					<Add option="-lphysfs" />
					<Add option="-lpng16" />
					<Add option="-lzlib" />
					<Add option="-ldsound" />
					<Add option="-lgdiplus" />
					<Add option="-luuid" />
					<Add option="-lkernel32" />
					<Add option="-lwinmm" />
					<Add option="-lpsapi" />
					<Add option="-lopengl32" />
					<Add option="-lglu32" />
					<Add option="-luser32" />
					<Add option="-lcomdlg32" />
					<Add option="-lgdi32" />
					<Add option="-lshell32" />
					<Add option="-lole32" />
					<Add option="-ladvapi32" />
					<Add option="-lws2_32" />
					<Add option="-lshlwapi" />
					<Add option="-lnet" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-Wall" />
			<Add option="-pg" />
			<Add option="-Og" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>







Having trouble with static linking

I am new to static linking, have always used dynamic with no problem.
Thought I'd try it.

 - First of all, what are the advantages of static vs dynamic?

 - Second, what extra files do I need to include with my game?

With dynamic it seems I need:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

I don't know what static will require as I havent been able to get it working yet.


I am using:

mingw-w64
Version:7.2.0
Architecture:i686
Threads:posix
Exception:dwarf
Build revison:1

Allegro 5.2.4 (from source)

Code::Blocks 17.12


I built both the dynamic and static monolith debug release versions of allegro

The only thing I did different for static was uncheck the SHARED flag in CMake

I changed the linker library list from:
-lallegro_monolith.dll
-lzlib
-lnet
-lwsock32

to:
-lallegro_monolith-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlib
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-lnet
-lwsock32

I also set these compiler flags:
Static libgcc [-static-libgcc]
Static libstdc++ [-static-libstdc++]
Static linking [-static]



My project compiles, links and runs fine with dynamic linking.
But I am getting linker errors when I try static.

There seem to be 2 things linker can't find:

fixed point routines in fmaths.inl:
C:\mingw32\include\allegro5\inline\fmaths.inl|46|undefined reference to `_imp__al_fixtorad_r'|

and opus stuff:
C:\devel\Allegro5\addons\acodec\opus.c|102|undefined reference to `op_free'|


I am lost here.  I don't know how to fix these errors.
I barely understand how I got this far...


Any advice on static vs dynamic as it applies to Allegro would be greatly appreciated.

Do I even want or need to do this?
Should I just use dynamic and not worry about static?

I needed to compile with -DALLEGRO_STATICLINK


now everything is in the executable...
pm.exe 17,084K and needs nothing else

later i may try to trim out things i dont need...


level editor les
main is good in les=1
but zfs and viewers don;t get there until i cycle with F12
probably set map var...
actually instead of running ortho, run rebuild_bitmaps()..fixed


---------------------------------------------------------
bug pop-up message viewer on linux has extra blank line at end
---------------------------------------------------------

I looked at the string and there is an extra 13 at the end
but only on linux????

I changed to read files in binary mode and it seem to work the same in both now...
no it doesn't....

what the hell is going on??

in windows \n is 10 and \r is 13

it look like my file reading stuff uses \n (10) as a seperator

for messages why don't i just leave 126 as my newline

lets revert back...done

went back to opening in 'r' mode
now i dont do any messing with converting, i just leave 126 as my newline
works same in linux, but now I get ^ at end of text

when I load text, ignore 13...

this seems to work now...


lets look at the editor..its good too...

this is all done



when players health is clamped past 100 it generates a - health display
fixed....







i'm losing keypresses
like F12 key up...
in control i'm trying to filter multiple resize events
is it needed in linux...yes..

redid the control loop, seems to work good now...



can't quit demo mode
fixed



icons...

what does allegro say...

in windows I have one for the window and in the taskbar

I made a file called icon.rc
#include <windows.h>
allegro_icon  ICON  bitmaps/pm.ico
added it to my project and that's literally all it took!!!

what about linux...

the function:
al_x_set_initial_icon(tmp);
is supposed to be called before you create the display
need to include:
#define ALLEGRO_UNSTABLE
#include <allegro5/allegro_x.h>
and the fucntion will not be found on a windows system
but after all that it doesn't seem to do anything...
I made a pm.desktop file in ubuntu
you can specify an icon in that..
not sure how usefull that will be...





after playing a netgame for 3 level dones
server player is getting random moves..

this bug is hard to reproduce...


could it be something to do with re-joining after level done??


reproduced on 8  player game after a loooooooonnnnnggg time
level 12 about 50 frames in


i had logging on!!!

server log file:20180418-165728.txt
17,746 KB
313400 lines
16897 frames
/ 40 = 422 seconds
/60 = 7 minutes

log file starts at level 5
and ends on level 5 7 minutes later...
wtf??
where are the rest of my logs!!!?????

does the passcount not reset??

--------------------------

level 14 approx 100 sec or 4000 frames

20180418-185448
5,501KB
98,894 lines
4830 frames

looks like there were only 6 players that joined
player 7 did not
i have stats for player 7 at the end but no name at the top...weird

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 y510
p5 eid
p6 e6410
p7 m-4230-3


could be my log file viewer....tis...
fixed that, now I have all 7 clients

moving on...

cant see anything on the server that would explain it

looked on client nv59, but its lin and even though i copied
i had old version cause its not compiled...

i'll need to look on a windows machine..
looked on pfv...found nothing
looked on y510...found nothing

looked on e6430:
file: 20180418-185448
it looks like a server file...wtf

----------------------------------------------------------

try to reproduce again


did it again...
level 14 100 frames in
when i took player nv59 off F1 mode
20180419-043626

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 eid
p5 e6410
p6 m-4230-3
p7 y510


notes:
end of level player array on nv59
server is mode 9??
at start server is mode 2
looks like they are all like that...


p0 i990
p1 nv59 ns
p2 pfv ns
p3 e6430 ns
p4 eid ns
p5 e6410 ns
p6 m-4230-3 ns
p7 y510 ns

none are pretending to be server...

what now??

is the corruption on the server and just propogated backtop the clients?
i'm thinking thats the case...
because if it wasn't i would be getting lots of stdf corrections
and i'm not

what can i do now??

look more closely at when cdats are rx'd

nv59
got game move on 2556 from server frame 2557
that i am pretty sure he did not send a cdat for...
actually thats not true...



------------------------------------

did it again

this time all players were acting weird even after i stopped f1 modes

lev 14 frame 42-50 on pfv was where i first noticed it...
20180419-060449

nv59 log
no moves received from server that were not sent by cdat
looks like f1 fake mode was stopped at frame 921

then manual keys pressed at
1022
1031

that does not match up with what i saw...
i get no game moves received for player 1 from 925 to 1022
then 5 manaul move from 1022 to 1098
then nothing until
5 manual moves from 1272 to 1285
then nothing until 8000 with fake mode again
ended with 12 stdf corrections

i got nothing....
why is it so fucky??

should i look in game moves??
compare server and client?

not until moves gets to 16000 or so on level 14


got another
level 14 around 40-50
look in game moves

on m-4230-3 at frame 1576 stopped f1 mode
then only got a few manual keys
1607
1651
1689
1710
1734
1783
so there should be no player 1 entries in game move after that
i don't see any on the server's game move





tried again this time only level 13 then 14

did not happen until 180 sec into game

what is getting counted up to???

game moves look identical

is it because how i am reading from the game moves array....

how can i check this...


what reads the game move array...

proc_game_move()
run once per frame
uses to iterate and or search



and this is run once per frame for each player

// common for all players;  get controls from game_move
int found = 0;
for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
   if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
      if (game_moves[g][0] <= passcount) // check to make sure its not in the future
      {
         found = 1;
         set_controls_from_comp_move(g);
         game_move_current_pos = g; // for savegame running only
         g = 0; // break out of loop
      }
if (!found) clear_keys(p); // if no match found


game_move_entry_pos


there is a global, and there is also one in players1 struct

53 matches in total..

i should un ambiguate this....

int game_move_entry_pos; (global variable)
- used to keep track of the entry point of the game move array

when a new game move is put in the array this is used
there should only be one way a new game move gets put in the array
add_game_move()
server calls it 6 time..
loop calls it twice when loading annd starting a new level
control call it twice
once for level done
once in single player local control

int game_move_entry_pos; (global variable)
- also used as a start point when reverse searching game_move array
like in proc_game_move() and when player gets move from game array

when do i reset it..


I THINK I FOUND SOMETHING!!!


if (start_mode != 2) // skip this when start_mode == 2 ; run game
{
   // reset game_move array
   for (int x=0; x<10000; x++)
      for (int y=0; y<4; y++)
         game_moves[x][y] = 0;
   game_move_entry_pos = 0;


i am only erasing the first 10,000 entries.....
its actually 1,000,000 now

10,000 / (7 moves per frame * 40 frames per second)
= 35 seconds

1,000,000 / (7 moves per frame * 40 frames per second)
= 58 minutes (at max keypresses per second)

log file name to have level and hostname..done

client log file to have full player array at end...done

start of log file after level done to have header with
hostname and player array..done

change game move logging (which is client only)
tag the logged move with the player it is for...
right now its tagged with the active local player...



what is client sync error that keeps showing up on clients?
when a client gets game moves with passcounts in the past
that will never be processed
its bad, but stdf will fix it..
lets not have that show, except in debug overlay..done



---------------------------------------------------------
in order for save game to play back correctly
they need to have the same values for pbullets, etc...
---------------------------------------------------------
save as 3 ints at start of gm
restore after by loading config
modified gm and txt save
modified gm load..
modified existing demos
added 1 5 1...
in demo mode and run game restore after...done
this should be done



make some automated post build setup stuff...

make a folder called pm_win_release

can i do it from the command line..
all i really want to do is copy stuff...

made a windows batch file that does what i want....

to make a windows release...

set version number in code and in help file
define pm_release

compile the project with win_static_release build target
run the batch file
zip and rename

how can I static build in linux
too complicated...

compile
run bash file
compress

make some more stand alone text files, like
setting up dev env on win and lin



death animation??
enemies have them, why not for player??

editing timeset with gimp

image->configure grid
view-> show grid
view-> snap to grid
view-> snap to canvas edges

file->overwrite (save back in same format)

to make a proper death animation seq
it will have to be for each player's color ....

what if I just do a shrink, rotate, and draw item disapear ans...

where would I do this??

at the end of player move, do the shrink and rotate
in draw_player() superimpose the item disapear thingy
done...



files still not added (probably never...)
- e_bitmap
- e_guifnx

I just realize I have no way of setting blocks drawable
copying and moving blocks
or doing anything with animation sequences

I could probably make some of e_bitmap work...

like select bitmap and animation sequence..

i made select bitmap and animiation work
but no link to them...

make select bitmap, coopy bitmap accsesiable from animation

also add save...

done...now link to it in editor...done



re-write help file
font and credits..done
screen mode..done
in game function keys..done
commandline..done
history update..done
installing..done
linux..done
add pixel_sub font credits..done



---------------------------------------------------------
what are my difs that happen every frame??
---------------------------------------------------------
tested and found a dif when other player joined and color was updated
also got archwag: type 3 difs
Ei[][1]  off by 5
Ei[][5]  off by 5
Efi[][0] // once  (x)
Efi[][1] // many  (y)
its usually this pair
Ei[][5]  off by 5
Efi[][1] off by .5, 1 , 3...

played a huge long netgame and they don't happen every frame...
actually quite infrequently....





add source available on request...
license: none
just a copyright notice...


what version number? 7.0


trying other linux os's
linuxmint-18.3-cinnamon-64bit.iso

missing: libopenal.so.1

copied from m-4230j

what if i recompile allegro on m-4320
to disallow open al
and redo all that...
or I could just distribute libopenal.so.1...
I recompiled the game so I don;t need the file now.

title on main menu screen is cut off when text is too wide?
only on cinnamon mint??

has max size as 8192
and is creating same size as other one

4865 violet missing V and !
4888 mauve  missing !
4767 bluey  missing !
6777 reddy  missing !
4219 pink   good
4335 taan   missing !
5213 orange missing O and !
5136 purple missing P and !
5088 forest missing F and !
4089 red    good
4874 green  missing !
4444 blue   missing !
4462 aqua   missing !
5164 yellow missing Y and !
4600 white  missing !

fixed by changing size of title bitmap..
old was max bitmap / 16
new is max bitmasp / 20

now mint works great....



updated windows version to 7.01, now with demo files!!!

updated linux version to 7.01,
now updated allegro libary that dosent require png support...


help screens width when changing les..fixed

fixed final_wrapup()
now hopefully wont die as much in linux


make the releases...
put on allegro.cc...
...
profit?


new license (zlib)

change help.. done

add license.txt.. done

make 7.03 release for win and lin...done



crashes on exit in win 10

try removing all bitmap destrying in final wrapup

also remove:
al_destroy_event_queue(event_queue);
al_destroy_display(display);

also remove complile optimizations


seems crash free on win 10 exit now...
linux version exits good too...
lets make release version 7.04


rename save and run game...
to what?
save demo
run demo

the best way to do that is to use the logging options
because as soon as a level ends, its too late to save it anymore
what if i remove save game completely?
its only use is when you stop a game mid-level and want to save...
just rename them for now..




When archwag y speed is set to 9 (max) they fall through floors...

found the bug!!

Ei[EN][5] +=5; // gravity

// this line is wrong!!!!
if (Ei[EN][5] < -160) Ei[EN][5] = -160; // terminal velocity

//fixed
if (Ei[EN][5] > 160) Ei[EN][5] = 160; // terminal velocity


now are all my demos going to be fucked?  probably any that used archwag...

dl_01 (pretty short anyway) kill it
dl_02 (pretty short anyway) kill it

dl_13 no archwag, good keep
dl_14 still good keep
dl_15 doesnt look good kill it

24 has a million arch wags, needs to be redone
26 doesn't work
27 bad
29 bad

30 good
33 good

zm21...bad  :(


after all these are the one I can keep


redid some demo levels, now I have:
13
14
20
23
24
26
30
33


new default keys:
arrows, x, z

p0_up_key=84
p0_down_key=85
p0_left_key=82
p0_right_key=83
p0_jump_key=24
p0_fire_key=26
p0_menu_key=59


20180508
copy in zfs has rect 1 block to big in x and y...fixed

20180508
adding new enemies erases last...wtf
only after copy paste enemies in zfs??
i broke something in level 42
now any enemy that I add either from draw_item copy paste or selection window
erases the last enemy...why??
bug in code in editor line 1160
should be:
int c = get_empty_enemy(); // get a place to put it
not:
int c = get_empty_item(); // get a place to put it
bug first appeared 20180401
fixed...



Make a way to do "new level" in level editor

right now what I do is:
- load level (optional)
- save level (and choose filename that doesn't exist yet)
- go to zoom full screen
- select entire level
- click clear

add a menu item 'new level'
- prompts you for a filename to save
- clears level and saves as new filename

made the menu item

made erase_level_data() a seperate function and call from
load_level() and initial_setup()

now it goes like this...

if (al_show_native_message_box(display, "New Level", "Clicking OK will create a new blank level", NULL, NULL, ALLEGRO_MESSAGEBOX_OK_CANCEL) == 1)
{
   zero_level_data();
   draw_big(1);
   update_editor_background();
   al_flip_display();
   save();
}
load_level(level_num, 0); // blind load

seems to work just like I want...call it done


make a function that serially reads keys to call debug functions..

while game running:
STON  speed test on
STOFF speed test OFF

while level_editor_running:
SPLADJ  spline adjust
SPLTEST spline test

while not game running
LOGVIEW run the logfile viewer


if ima_client
FAKEKEY toggle

does it work with CAPS?? ..NO

done...


new level does not blank the number of lifts...fixed

new level has bad pmsg data
fixed method of declaring pmsg pointer and freeing and setting to NULL


Should I make pmsg not have clear center?? yes...


i messed with pmsg and now I get crashes and I'm not sure why

this was the code used to erase level data..

if (item[c][0] == 10) free (pmsg[c]);
i didn't like it because it didn't reset the pointer to NULL

I replaced it with:
if (pmsg[c] != NULL)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}

and then just:
free (pmsg[c]);
pmsg[c] = NULL;

because if it's NULL, free() should not do anything

I get random crashes and I don't like it, so I went back to the original plus this:

if (item[c][0] == 10)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}



trakbot initial direction button works, but the rotated display in enemy viewer is wrong...fixed

sel outline rect too small when at rl edges..fixed

make my webpage part of the sources

re-arrange levels and move less fun ones to the end...

I want to have a very solid set of levels with no duds

these are lame and should be segregated...

5
6
7
8
9
10
11
12
15
16
18
19
40

what if I had an overiding script that chose the order of levels...

start by moving lame ones to 50++


did a lot of that...

need to make the demo's line up


what if I gave all my levels names like anything.pml

then I made an array of playable levels
that would end my renaming bullshit



hard code into the program:
for each:

filenames
title
description


make a playlist of levels

int level_playlist[400]

this gets iterated through when playing
and is used by visual_level_select()

level_num is an index into this

how about do this, but still use numbers for levels

menu item "level set"
LEVEL SET:TRAINER
LEVEL SET:MAIN
LEVEL SET:EXTRA
LEVEL SET:ALL



This is what I actually did.

I made 3 levels that I call trainers and moved them to 90, 91, 92

I made a warp there and back from level 1

I think it works good enough...

made some more changes to the levels and then are looking good.

1 - trainer select
2-24 main levels
50-64 extra levels
90-93 training levels

20180514 new commit

auto create dir sel, like logs...done


sometimes I see trails in level_buffer when stimp/stamp or screen change
hard to reproduce..
re-did get new background to do full or region only
did a redraw at start of stamp
also slowed down stimp and stamp to make more visible
trails during stamp are good


when stimp and game zoom shows lots of the level, it doesn't line up

its like stimp and stamp expect the game position to be more left than it is




stimp and stamp have code with hystersis window like get_new_screen_buffer()

make that common??


what is found out by either function?
in get new background: WX, WY, SW, SH, sbx, sby, sbw, sbh


in stimp and stamp I just patched in an offest like this:

   // offset if entire level is smaller than screen
   int sbw = SCREEN_W-bw*2;
   int sbh = SCREEN_H-bw*2;

   // how big is the entire level after scale factor is applied?
   extern float scale_factor_current;
   int sls = (int) ((float)2000 * scale_factor_current); // sls = scaled level size

   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      px_final += a/2;

   }
   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      py_final += a/2;
   }

works now...

cursor height in text editor

draw lift..good
server name good
p message..fixed



fix demos

old demos from version 7.04


9
10
12
13
14
16
17
zm_11 chopped to 200s or 8000 frames

---done

commit done
made an old style backu too...

when run demo stimp of wrong level..fixed
cleaned up function prototypes
20180517 commit

working on cleaning up pm.h

pm.h has all function definitions listed by files
and sorted through

next I should work on global variables... I have a lot of them...


the beginning of main, where they are declared,
should mirror pm.h where they are externed

also remove lots of not used ones

also move all declarations from other source files to main

I have 500 lines of extern variables!!!

tmty
tmtx
position of text above the map on menu screen_msg
used in draw_level
set in set_map_var

I also have:
menu_map_x
menu_map_y
menu_map_size

I should use these get the text position and then get rid of tmtx and tmty
step 1
use them in draw level
now search and get rid of  tmtx and tmty done...


now how about md
used only to to make mx
mx is used a lot
made md local to set map var
md is gone now, local only to set_map_var

int map_double; // level editor map double
not used, removed...

tmy is the top_menu y_pos

always set to 10, never anything else
used to set mx = tmy + 130;
make that constant..
tmy is gone...

float steps is gone...

mx, my
what are they used for?
mx is used a lot locally
replace with smx if locally used
down to 89
turns out almost all my and my were local...
i kept a lot of them, just killed the extern ones
mx and my are not global anymore...

txc is used for the center of the right hand side panel in level editor...keep

that has cleaned up lots...

what is next?

group globals by function and make sure main and pm follow same format...

make item_name and enemy_name the same

both


menu_setup for game in zmenu

text_setup for level editor in e_menu

make them common...

both use global_string[9]

le uses 5 and 9
gm uses 3, 4, 7, 8, 9

make le use 6 instead of 9..done
move code from ts to ms done
remove e_menu.cpp from project...done
make enemy_name like item_name
replace ei_type_desc with enemy_name
6 used for lift pop up menu?? need to move editor menu to 2?
done...



4:30 AM

main
300 sorted
200 not

pm
550 sorted
200 not

5:30
400 sorted
100 not

pm
625 sorted
125 not

wx and wy are used 34 times
mostly as the origin block on the main level editor..


6:40
main 20 not sorted
pm same...

20180518 commit...

level_header is used in filecom only
uses only 3, 4, 5 for num item, enemy, lifts
made local

I am finished cleaning up pm.h

now I have approx 350 globals, but they are all grouped by function
and match the declarations in main

code stats:
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)


put log file viewer in logging menu..done

what if I add PG_UP and PG_DOWN to menu?
I would make navigating long menus easier.....done

text center in level editor is not right...
moved where txc is set to after where db in set..fixed

title obj for item not centered..fixed

raise text in color select 1 pixel...done

show door type button better...only show in title at full size..done

I think I'm ready for a new version release

I should make a checklist of all I need to do:

- make sure version string is incremented at start of initial setup
- change version in help file

- make sure linux version works

something (i'm looking at you git) changed the linux line endings to windows
op win
pml lin
lin_make_release win
readme_linux lin

log file viewer crashes hard on linux
never even runs...
didn't crash the 2nd or 3rd time...
PDE text for Trakbot says wall climber
too many lines for switch and flapper door
fixed PDE text...
need to make it look good on linux with line endings...done

compile lin version and make tar.gz
compile win version and make zip

upload to itch.io




- define RELEASE in pm.h






------------------------
20180523

Refactoring....


I need to sort out how the three tile bitmaps get load and such.....

right now its spread across too many places....done

now all 3 are load and initialy created in load sprit
only load sprit is called from main

recreate bitmaps destroys all sub bitmaps ane re-creates...


why is tilemap created in load_sprit, but ptilemap and dttilemap are not ???

this is a mess and should be straightened out...

make tilemap, ptilemap and dtilemap local to load sprit only.
all they do is create the M_ versions that need to be global...or do they??

fix this...



-------------------------------------------------------------------------------
these bitmaps are created when 'create_bmp()' is called from 'init_screen()'
this is the only time that 'create_bmp()' is called...

tilemap = al_create_bitmap(640, 640);
ptilemap = al_create_bitmap(380,320);
dtilemap = al_create_bitmap(160,640);

level_background = al_create_bitmap(2000,2000);
level_buffer = al_create_bitmap(2000,2000);

M_tilemap = al_create_bitmap(640,640);
M_ptilemap = al_create_bitmap(380,320);
M_dtilemap = al_create_bitmap(160,640);



-------------------------------------------------------------------------
in 'rebuild_bitmaps()'
M_tilemaps are drawn to tilemaps
sub_bitmaps are created / recreated from tilemaps


-------------------------------------------------------------------------
in 'load_sprit()'
tilemaps are loaded from file
M_tilemaps are created from tilemaps
rebuild_bitmaps()' is called



fill_door_bitmap() and fill_player_bitmap() are not called
so I commented them out


to do:

make load_sprit not create local copy of tilemap....done
make load_sprit only load M_, then call rebuild_bitmaps();

I tried to load M_ directly, but for some reason,
I need to load as video bitmap then convert alpha and store in M_


I would like to rename:

l2000 to level_background..done
memory_bitmap to tile...done
player_bitmap to player_tile...done
door_bitmap to door_tile..done

rename load and save sprit to load and save tiles..done





what is not used:

void test_window_size_and_pos(void) // never used...move to old...

// only declared and externed, never used.. removed
int disp_x_full = 0;
int disp_y_full = 0;
int disp_w_full;
int disp_h_full;

// last screen pos, to tell if it changed -- does not need to be global!!
int l_spx;
int l_spy;

what is saved to config:
disp_x_wind
disp_y_wind
disp_w_wind
disp_h_wind
fullscreen


renamed les to display_transform_double...done

renamed set_ortho() to set_display_transform()..done

after death, trails show on undrawn level background..fixed


----------------------------

Do I have to re-create all my tile sub bitmaps every time I rebuild bitmaps?
No, if I just reload the parent bitmaps the subs do NOT need to be re-created...done




trimmed down the number of calls to rebuild_bitmaps()

actually its called a lot more often that than.... why???
3 time in proc screen change

1 time in filecom after load_tiles


2 times in menu...at start and end of menu right after auto_set_display_transform_double

1 time in control after F12 to set display_transform_double


1 time in bitmap in animation at start when display_transform_double set to 1

2 time in editor at start and end of help when display_transform_double changed

? can I just add it to auto_set_display_transform_double()

? make manual set version and set it there too??


try to change the one in control...
replaced  rebuild_bitmaps();
with:
set_display_transform();
set_map_var();

bitmap..removed

add to end of auto set:
set_display_transform
set_map_var
done

find all call to this and remove rebuild_bitmaps...done
help x 2

now after all that: rebuild_bitmaps() is called only from proc_screen_change


-----------------------------------------------

do I need 'speed' to be seperate from passcount_timer_fps?

rename speed in the game to frame_speed for now, so I can tell it apart from the 150 mentions of speed

found 21 refs to 'frame_speed'
found 13 refs to 'passcount_timer_fps'

why do they need to be different?

what if I replaced all passcount_timer_fps with frame_speed??

done...

now remove:
void set_passcount_timer_fps(int x)

32 refs to frame_speed

should be done....

hopefully it didn't break anything....

-----------

sound...

why do I have lit_item and fuse_loop_playing?

do I need both??



lit_item
- set to zero in proc_sound
- set to one in proc lit rocket and bomb

used by proc_sound to continue fuse hiss...

code stats: 0524
36 files
19393  code only
 5368  empty lines
 3726  comment lines
 3376  code and comment
31863  total


-----------------

increment passcount in proc_frame_delay(), not update_animation()..done
here is how it moved in the game loop:
proc_controllers();
player_move();
proc_player_carry();
update_animation();  <- from here
enemy_move();
enemy_collision();
proc_ebullets();
proc_pbullets();
proc_player_health();
proc_sound();
proc_frame_delay();  <- to here

hope this doesn't break anything!

Rename passcount to frame_num...done

rename event to game_event...done




in proc_controller()

change
if (key[ALLEGRO_KEY_PRINTSCREEN]) key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work
to
key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work

also this line:

if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
looks like its in the wrong spot

orig:

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

fixed:


   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

now menu's seem to run a lot faster...fixed

make screenshots folder auto created...done
fix screenshot to use actual screen size instead of ortho doubled...done

make it so demo counter will not run when game is paused
cause when it does, paused game is lost...done

changed logo drawing to use max x or y scale instead of hypot for thickness

-------
fixed linux line ending on text files
removed license.md
edited license.txt and readme.md







i want to simplify the 2 variables used for menu timer wait in proc_controllers()

right now I use done and menu timer wait

done is used 3 time; menu_timer_wait is used 2 times

code before changes...


int proc_controllers()
{
   int ret = 0;
   int done = 0;
   int menu_timer_wait = 1;

   key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
          if (menu_timer_wait) done = 0;
      }




new version:

menu_timer_block only and used in three places...much better

int proc_controllers()
{
   int ret = 0;
   int menu_timer_block = 1;

   key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work properly
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_block = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
      }
      else // game is in progress
      {
         menu_timer_block = 0;






web docs:
rename events
or move out input to its own file..done
input to have key, mouse, joystick and game moves array...done


---------------
found a better way to get rid of warning like:
warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]|

previously i change all the time i called a funtion with a literal string from:
Packet("sdak");
to:
Packet((char *)"sdak");

but bamcaig said that wasn't actually correct

now I am going to redo them all by changing the function from:
void Packet(char *id) {
to:
void Packet(const char *id) {

that is the correct way.

I just changed 20 instances of Packet()
moving on...
20 x Packet()
12 PacketRead()
4 title()
30 help()
23 getxy()
5 getbox()
1 get_item()
2 ClientInit()
30 add_log_entry_centered_text()
94 add_log_entry_position_text()

all done....


what if I sort out the names for packet add and read

new...

void PacketPut1ByteInt(int b)
void PacketPut2ByteInt(int b)
void PacketPut3ByteInt(int b)
void PacketPut4ByteInt(int b)

int PacketGet1ByteInt(void)
int PacketGet2ByteInt(void)
int PacketGet3ByteInt(void)
int PacketGet4ByteInt(void)


void PacketPut1ByteInt(int b) replace 32
int PacketGet1ByteInt(void) replaced 22

void PacketPut2ByteInt(int b) replaced 3
int PacketGet2ByteInt(void) replaced 3

void PacketPut3ByteInt(int b) replaced 0
int PacketGet3ByteInt(void) replaced 0

void PacketPut4ByteInt(int b) replaced 26
int PacketGet4ByteInt(void) replaced 18


2 byte is only used for:
- play level in SJON and CJON
- specialized packet testing

I could remove the tests I put in for player num matching who...nah leave it...



what site did i use for my flowchart?



where is server_sync used..


client and server

in player1 struct


overlay
client while waiting for sync
client bottom overlay
server per client


I want to make them unique..

on client server_sync is used for display only and for adjust timer

rename that one to client_sync

add new var in player struct:client_sync
should be done....


next:

   int c_sync;
   int c_sync_min;
   int c_sync_err;

how about:

client_game_move_sync;
client_game_move_sync_min;
client_game_move_sync_err;

and

server_game_move_sync;
server_game_move_sync_min;
server_game_move_sync_err;



change client first....
make new var...
clear in player
fix in client
fix in overlay
fix in log
done

change server next....
make new var...
clear in player
fix in server
fix in overlay
done

still seems to work

























rename state correction stuff


stdf is the name of the buffer used by client to build chfd from packetsize
I could call it client_state_buffer

the array used to track if all the pieces have arrived: chdf_pieces
rename to client_state_buffer_pieces

client1_chdf is the clients base state
rename to client_state_base

client1_chdf_id is the frame num of the clients base state
rename to client_state_base_frame_num


old:
extern char chdf[STATE_SIZE];          // for client chdf building
extern int chdf_pieces[16];
extern char clientl_chdf[STATE_SIZE];  // last ack state for diffing
extern int clientl_chdf_id;            // frame_num id

new:
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // frame_num id

chdf to client_state_buffer..done
chdf_pieces to client_state_buffer_pieces..done
clientl_chdf to client_state_base..done
clientl_chdf_id to client_state_base_frame_num


old:
extern char dif[STATE_SIZE];
extern int dif_id[2]; //   (0 = src, 1 = dst)

new:
extern char client_dif[STATE_SIZE];
extern int client_dif_src;
extern int client_dif_dst;

server also uses dif....
client only uses dif_id

ok do this instead:
new:
extern int dif_src;
extern int dif_dst;

leave dif alone

dif_id[0] to dif_src..done
dif_id[1] to dif_dst..done



old:
// server chdf
extern char client_chdf[8][2][STATE_SIZE];
extern int client_chdf_id[8][2]; // frame_num id

new:
extern char srv_client_state[8][2][STATE_SIZE];
extern int  srv_client_state_frame_num[8][2];

client_chdf to srv_client_state..done
client_chdf_id to srv_client_state_frame_num..done


final variable list:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2]; // frame_num id

// local client's states
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // frame_num id

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;  // client only
extern int dif_dst;  // client only


now I need to come up with a different term for the variables that make up a state

I have funtions called:
void chnk_to_state(char* b);
void state_to_chunk(char* b);

but what I used to be call state needs a new name: game_vars

new names:
void state_to_game_vars(char* b);
void game_vars_to_state(char* b);

chnk_to_state to state_to_game_vars..done
state_to_chunk to game_vars_to_state..done

these are good:
void reset_states(void);
void game_vars_to_state(char * b);
void state_to_game_vars(char * b);


these should all have chunk changed to state:
void get_chunk_dif(char *a, char *b, char *c, int size); // server only
void apply_chunk_dif(char *a, char *c, int size); // client only
void show_chunk_dif(char *a, char *b); // client only
done...


now the packet names....

chdf and chak

stdf and stak

did a global replace of chdf to stdf -- hundreds... hope it didn't break to much...

now chak to stak..done..only a few

lets see how broken it is....
I still seem able to play a 2 player game...

well now that everything has been renamed, lets move on with the documenting....

------------------------------
bug
-----------------------------

end of level on netgame???

seem to have trouble joining on new level...

client keeps getting difd from 0-20, 0-25 etc
but its base is 2 so it cant apply them

finally at frame 120, client resets base to 0 and applies dif

but its too late beacuse the server has already dropped the client
for no sdat_rx for 100 frames



when does base reset to zero? never mind


also client is approx 10 frames behind client
this is why chdf is never applied
client does not receive any sdat until 108
the moves it gets are the server drop moves!!

what controls when server send sync sdat?


if I press keys on the server after level done and force sdats to be sent, join works
if not, it times out


why is server not sending sync sdat's???


try removing else....that fixed it...
it was never doing the second block because the first one was true (client need more data)
but the first one was not sending more data beacuse of the duplicate blocker

void server_send_sdat(void)
{
   for (int p=1; p<NUM_PLAYERS; p++)
      if (players[p].control_method == 2)
      {
         if (players1[p].game_move_entry_pos < game_move_entry_pos) // client needs more data
         {
            int start_entry = players1[p].game_move_entry_pos;
            int end_entry = game_move_entry_pos;
            int num_entries = end_entry - start_entry;
            if (num_entries > 100) num_entries = 100;

            // to prevent multiple resends of exact same data
            if ((players1[p].server_last_sdat_sent_start != start_entry) || // different start pos
               (players1[p].server_last_sdat_sent_num != num_entries))      // different num entries
            {
               players1[p].server_last_sdat_sent_start = start_entry;
               players1[p].server_last_sdat_sent_num = num_entries;
               players1[p].server_last_sdat_sent_frame_num = frame_num;

               Packet("sdat");
               PacketPut1ByteInt(p);
               PacketPut4ByteInt(frame_num);
               PacketPut4ByteInt(start_entry);
               PacketPut1ByteInt(num_entries);

               for (int x=start_entry; x<start_entry + num_entries; x++)
               {
                  PacketPut4ByteInt(game_moves[x][0]); // frame_num
                  PacketPut1ByteInt(game_moves[x][1]); // type
                  PacketPut1ByteInt(game_moves[x][2]); // data 1
                  PacketPut1ByteInt(game_moves[x][3]); // data 2
               }
               ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

               if (L_LOGGING_NETPLAY_sdat)
               {
                  #ifdef LOGGING_NETPLAY_sdat
                  sprintf(msg,"tx sdat p:%d [strt:%d num:%d]\n", p, start_entry, num_entries);
                  add_log_entry2(37, p, msg);
                  #endif
               }
            }
         }


         else if (frame_num > players1[p].server_last_sdat_sent_frame_num + 19) // send even if no data, every 20 frames for sync
         {
            players1[p].server_last_sdat_sent_frame_num = frame_num;
            int start_entry = players1[p].game_move_entry_pos;

            Packet("sdat");
            PacketPut1ByteInt(p);
            PacketPut4ByteInt(frame_num);
            PacketPut4ByteInt(start_entry);
            PacketPut1ByteInt(0);
            ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

            if (L_LOGGING_NETPLAY_sdat)
            {
               #ifdef LOGGING_NETPLAY_sdat
               sprintf(msg,"tx sdat p:%d [strt:%d num:%d] (sync only)\n", p, start_entry, 0);
               add_log_entry2(37, p, msg);
               #endif
            }
         }
      }
}



--------------------------------------
end of bug


what if I remove the code that checks if packet are from who they are supposed to be?
that was never an issue...


old:

      if(PacketRead("serr"))
      {
         int sp = PacketGet1ByteInt();
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx serr player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            if (serr_type == 1) // error type (1 = cdat late)

            players1[p].serr_c_sync_err = serr_c_sync_err;
            players1[p].serr_display_timer = 120;

            sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
            if (L_LOGGING_NETPLAY_cdat)
            {
               #ifdef LOGGING_NETPLAY_cdat
               add_log_entry2(35, p, msg);
               #endif
            }
         }
      }


                  Packet("serr"); // server error
                  PacketPut1ByteInt(p);
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);




new:

      if(PacketRead("serr"))
      {
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (serr_type == 1) // error type (1 = cdat late)

         players1[p].serr_c_sync_err = serr_c_sync_err;
         players1[p].serr_display_timer = 120;

         sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
         if (L_LOGGING_NETPLAY_cdat)
         {
            #ifdef LOGGING_NETPLAY_cdat
            add_log_entry2(35, p, msg);
            #endif
         }
      }





                  Packet("serr"); // server error
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);









old:

      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sp = PacketGet1ByteInt();
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx sdat player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

            // this used to be a function , client timer adjust
            players1[p].client_sync = sdat_frame_num - frame_num;
            int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;



new:
      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

         // this used to be a function , client timer adjust
         players1[p].client_sync = sdat_frame_num - frame_num;
         int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;










old:

int process_stdf_packet(void)
{
   int retval = 0;
   int p = PacketGet1ByteInt();
   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   if (p != active_local_player)
   {
      sprintf(msg, "ERROR! rx stdf player:[%d] does not match local player:[%d]\n", p, active_local_player);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
   }
   else
   {
       memcpy(client_state_buffer + stdf_sb, packetbuffer+23, stdf_sz);  // put the data in the buffer












new:


int process_stdf_packet(void)
{
   int retval = 0;
   int p = active_local_player;

   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   memcpy(client_state_buffer + stdf_sb, packetbuffer+22, stdf_sz);  // put the data in the buffer








removed these from server:

void proc_server_check(void)
{
   for (int p1=1; p1<NUM_PLAYERS; p1++)
      for (int p2=1; p2<NUM_PLAYERS; p2++)
         if (p1 != p2)
         {
            int p1w = players1[p1].who;
            int p2w = players1[p2].who;
            if ((p1w != 99) && (p2w != 99))
               if (p1w == p2w) // we have a duplicate
               {
                  // do something here
                  sprintf(msg, "ERROR! duplicate whos for player:[%d] and player:[%d]\n", p1, p2);
                  printf("%s", msg);
                  #ifdef LOGGING_NETPLAY
                  add_log_entry2(10, 0, msg);
                  #endif
               }
         }
}


// check to see if this packet is from who its supposed to be and is valid
int check_packet_who(int p, int who, int type)
{
   if (players[p].control_method != 2)
   {
      //check if the player we received data for is an active client
      //sprintf(msg, "ERROR! rx cdat for player[%d].control__method[%d] != 2\n", p, players[p].control_method);
      //printf("%s", msg);
      //#ifdef LOGGING_NETPLAY
      //add_log_entry2(10, p, msg);
      //#endif
      return 0;
   }
   if ((players1[p].who != who) && (players1[p].who != 99))
   {
      char tmsg[80];
      if (type == 1) sprintf(tmsg, "cdat");
      if (type == 2) sprintf(tmsg, "sdak");
      if (type == 3) sprintf(tmsg, "stak");

      sprintf(msg, "ERROR! rx %s player[%d].who[%d] does not match packet who[%d]\n", tmsg, p, players1[p].who, who);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
      return 0;
   }
   return 1;
}


done.....

does it still work??...yes



warps on netgame???

warp starts next level immediately
client does not even join
but then client times out and quits

is the whole level done thing too complicated?


added global int next_level

added
play_level = next_level;
in proc_level_done()

added
next_level = play_level + 1;
in item exit collision


changed warp from:
play_level = item[x][8];
start_mode = 1;

to:
next_level = item[x][8];
level_done = 1;
game_event(4, itx, ity, 0, 0, 0, 0);

now warp should be exactly like exit except for the next level




-------------------------------------

dif is not really used by server, it just uses a local variable of the same name...

i propose more renaming:

old:

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;           // client only
extern int dif_dst;           // client only


new:
extern char client_state_dif[STATE_SIZE];
extern int client_state_dif_src;
extern int client_state_dif_dst;

---------------------------------------------------

ok now final looks like:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

// local client's states
extern char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
extern int  client_state_buffer_pieces[16];   // to mark packet pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state
extern int  client_state_base_frame_num;      // last ack state frame_num
extern char client_state_dif[STATE_SIZE];     // uncompressed dif
extern int  client_state_dif_src;             // uncompressed dif src frame_num
extern int  client_state_dif_dst;             // uncompressed dif dst frame_num




------------------------------------

why do I use:
7 x memmove
7 x memset
27 x memcpy

---------------

working on join...

i want to move client_block_until_good_stdf_received(void)
to right after block for SJON rx

removed from main clinet loop:
if (frame_num == 0) client_block_until_good_stdf_received();

added right after SJON rx:
client_block_until_good_stdf_received();

done and works, even after level done

but don't I need to call it in client loop for level done rejoin?

I guess not....
client and server should have just both loaded new level, no need to wait for state.

i'll leave it in for now, so it gets called from both places













i want to clean up the init code for client, its kinda like spaghetti...
could be a lot clearer....



now:

client_init
  - client_init_driver()
  - client_init_join()
     - send CJON
     - block wait for SJON
     - client_block_until_good_stdf_received()
        - block for good state





what if I flatten it all out


client_init
  - client_init_driver()
  - send CJON
  - block wait for SJON
  - block for good state





did a lot of cleaning up the client init stuff

now:

client_init
  -ClientInit
  -check for reply
  - client_init_join()




  moved check for reply to ClientInit
rename ClientInit to ClientInitNetwork()


now:

client_init
  -ClientInitNetwork()
  -client_init_join()


much better....

rename ServerInit to ServerInitNetwork() also...

renamed server and client exit also
now called after every call to server init (3 times each in main)


client exit takes care of resetting player stuff like:

   ima_client = 0;
   players[0].active = 1; // local_control
   active_local_player = 0;


no need to do it anywhere else, like if join fails...

change init_player(p,1)

to set inactive, not active....

client_init_join() is looking good

void client_block_until_good_stdf_received(void) is looking good.

its been coming along nicely......



redo where server chooses new client color...

   int color = req_color;  // try to use requested color, unless already used by another player
            int color_used;
            do
            {
               color_used = 0;
               for (int q=0; q<NUM_PLAYERS; q++)
                  if ((players[q].active) || (players[q].control_method == 9) || (players[q].control_method == 2))
                     if (color == players[q].color)
                     {
                        if (++color > 15) color = 1;
                        color_used = 1;
                      }
            } while (color_used);


make a function called:

int is_player_color_used(int color);


int is_player_color_used(int color)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) || (players[p].control_method == 9) || (players[p].control_method == 2))
         if (color == players[p].color) return 1;
   return 0;
}

   // try to use requested color, unless already used by another player
   while (is_player_color_used(color)) if (++color > 15) color = 1;

hell also fix why color and bitmap index are off by 1
shifted all my player bitmaps up one in tilemap
lose bitmap, only use color...
its in player1 struct whicg I dont want to mess with the size of
i'll just rename it there to find all refs then change them to use color instead
done...

now only color, no bitmap index...yay!!!


int who is a static int in server loop...

should I make it a global? no

who uses it?

CJON yes
stak no
sdak no
cdat no




rename a bunch of client and server functions...

move packet processing to one function for each packet type..


should I remove #ifdefs for logging...yes...


one file at a time..

client...done

bandwidth???
// gets the values in send and rx functions
#ifdef NETPLAY_bandwidth_tracking

leave bandwidth for now, do all others


server...done

now search for

#define LOGGING..done
#define LOGGING_NETPLAY..done
#define LOGGING_NETPLAY_JOIN..done
#define LOGGING_NETPLAY_client_timer_adjust..done
#define LOGGING_NETPLAY_cdat..done
#define LOGGING_NETPLAY_game_move..done
#define LOGGING_NETPLAY_sdat..done
#define LOGGING_NETPLAY_sdak..done
#define LOGGING_NETPLAY_stdf..done
#define LOGGING_NETPLAY_stdf_all_packets..done
#define LOGGING_NETPLAY_stdf_when_to_apply..done
#define LOGGING_NETPLAY_show_dif1..done
#define LOGGING_NETPLAY_show_dif2..done
#define LOGGING_NETPLAY_bandwidth.. only one in void process_bandwidth_counters(int p)..done

kill all these defines....done

// not this one
#define NETPLAY_bandwidth_tracking.. 6 in packet tx and rx fnx and  process_bandwidth_counters(int p)



still seems to work...


----------------------
20180518 code stats:
----------------------
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)

----------------------
20180605 code stats:
----------------------
39 files
18830  code only
 5177  empty lines
 3253  comment lines
 3333  code and comment
30393  total

25416 total - empty
22163 total - (empty + comment only)




main

NET_CONN *ListenConn = NULL;                         // listening connection
NET_CONN *ClientConn[MAX_CLIENTS] = {NULL, };        // array of connections for each client

NET_CHANNEL *ListenChannel = NULL;                   // listen channel
NET_CHANNEL *ClientChannel[MAX_CLIENTS] = {NULL, };  // array of channels for each client

int ClientNum = 0;

NET_CONN *ServerConn = NULL;
NET_CHANNEL *ServerChannel;


pm.h

// libnet client
#define MAX_CLIENTS 32
extern int ClientNum;

// libnet client TCP
extern NET_CONN *ListenConn;
extern NET_CONN *ClientConn[MAX_CLIENTS];

// libnet client UDP
extern NET_CHANNEL *ListenChannel;
extern NET_CHANNEL *ClientChannel[MAX_CLIENTS];

// libnet server TCP
extern NET_CONN *ServerConn;
// libnet server UDP
extern NET_CHANNEL *ServerChannel;

fixed this to only be in n_server and n_clinet
they are never refernced oytside these files...done




all the times when I am trying to break out of a loop with F11 or ESC I need to call proc_controllers()

I can only think of 2 times...
when client blocks waiting for SJON
when client blocks waiting for initial state

done....



make a way to have only one copy of the lhs panel with all the links..

what if I make my own tag that does nothing but mark where this is
then I can search and replace in files for anything in between these tags...

<mdw_lhs_nav>   </mdw_lhs_nav>

what language should I use to do this?
perl?

activeperl 5.24.3

# this updates the left hand side navigation panel in all html files in the current directory

# get the new text
open(MDATA, "<lhs_nav.html");
my $b = do {local $/; <MDATA>};

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   # print $file . "\n";

   # open the file to replace text in
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # replace the text
   $a =~ s/<mdw_lhs_nav>(.*)<\/mdw_lhs_nav>/<mdw_lhs_nav>$b<\/mdw_lhs_nav>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}












make an automated way to make a link list at the top of every file
like each header <mh7>
will have an anchor tag and be in a list at the top of the file

I will need to redo all of my mh7's as anchors


make a script to show all mh7 tags by filename...


this is how I do it in index.html:
<a name="description"></a>
<br><mh6>Description:</mh6>

then a link to that looks like this:
<a href="index.html#description" target="_top">Description</a>

this is how it looks in the other files:
<br><mh7>Overview</mh7>


change mh6 to mh7
the only place mh6 is used is in index...change them all...
done and removed mh6 from css

now only mh7...



now I have a list of mh7 tags in each file...


i should change each tag to a common format:

<mh7>Overview<a name="Overview"></a></mh7>

test this...

do it like this instead:
<br><a name="Overview"></a><mh7>Overview</mh7>

Yes...do them all like this...

can I automatically do it???


still not sure...

I want the whole thing wrapped in a unique tag

why? I dont plan on modifying it, just making auto TOC from it

can I use spaces in my names??yes


manually make them all look like this:
The name exactly the same as the anchor

<a name="Features"></a>
<mh7>Features</mh7>

do it in index first...
works good there.

copy all back to main dir on desktop...

now manually edit all mh7 tags...

do this in main dir...

blank.html - none

-----------------
display.html..done
-----------------
Global variables
Creating the Display
Process Screen Change
Display Transform Double
Detecting Window Move

-----------------
events.html..done
-----------------
Overview
Processing the event queue
Processing events
Handling multiple resize events

-----------------
game_moves_array.html..done
-----------------
Overview
The Game Moves Array
Netgame
Special Game Moves

-----------------
index.html..done
-----------------
Description
Demo Video
Features
Created by
Created with
License
Supported Systems
External Links
Older Versions
History

-----------------
input.html..done
-----------------
Overview
Keyboard Input
PRINTSCREEN hack
Mouse Input
Joystick Input
Bindings vs Controls

-----------------
level_array.html..done
-----------------
Overview
Drawing the Level Array
Rebuilding level_background
Drawing Sequence in the Game Loop
Get New Background
Get New Screen Buffer
Scale Factor

-----------------
lhs_nav.html
-----------------

-----------------
logo.html..done
-----------------
Demo Video
Overview
Splines
Setup of points on the grid

-----------------
netgame_config.html..done
-----------------
Overview
Settings you probably shouldn't change!

-----------------
netgame_join.html..done
-----------------
Overview
Client sends CJON
Server receives CJON and replies with SJON
Client blocks until it receives SJON
Client blocks until it gets initial state from server
Client chase and lock
Packets used for join

-----------------
netgame_main.html..done
-----------------
Overview
Game Move Sync
Client sends control change
Server receives control change
Server sends game move data to clients
Client receives game move data from server
Timing
Control lead frames
Player numbers
Player's control methods
Level Done

-----------------
netgame_packets.html..done
-----------------
Overview

-----------------
netgame_state.html..done
-----------------
Overview
Game state variables
Global variables for state correction
How a client gets a new state from the server
How a client applies the new state
How the server sends a new state dif to a client
Packets used for state correction

-----------------
netgame_status.html..done
-----------------
Overview
server_sync
client_sync
server_game_moves_sync
client_game_moves_sync

-----------------
sound.html..done
-----------------
Overview
Sound Setup
Mixer Volume Controls
Theme Music
Sound Effects
Sample Delay
Processing the Hiss Sound

-----------------
tiles.html..done
-----------------
Overview
Creating Tile Bitmaps
Loading Tile Bitmaps
Rebuilding Tile Bitmaps

-----------------
timers.html..done
-----------------
Overview
Menu Timer (mnu_timer)
Second Timer (sec_timer)
Frames per Second Timer (fps_timer)
Speed adjust during netgame


now that all of this is done I can get back to making my toc's



perl script: make_toc.pl

# makes a toc using <mh7> tags
# inserts the toc between <mdw_file_toc> tags

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   print "\nfile:$file\n";
   print "---------------------------------\n";

   # open the file
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # find <mh7> tags
   my @matches;
   push @matches, $1 while $a =~ /.*(<mh7>.*<\/mh7>)/g;

   # multi line toc we are going to insert
   my @toc;

   foreach (@matches)
   {
      #print $_ . "\n";

	  # strip tags
	  $_ =~  /<mh7>(.*)<\/mh7>/;
      $_ = $1;
      print $_ . "\n";

      # add single line in toc
      $toci = "<a href=\"$file\#$_\" target=\"_top\">$_</a>\n";
	  push @toc, $toci;
   }
   #print @toc;

   # replace the toc between <mdw_file_toc> tags
   $a =~ s/<mdw_file_toc>(.*)<\/mdw_file_toc>/<mdw_file_toc> @toc<\/mdw_file_toc>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}


tag in source files...

<mh3><hr></mh3>
<mh8>Tiles</mh8>
<mh3><hr><mdw_file_toc> </mdw_file_toc><hr></mh3>


display.html..done
events.html..done
game_moves_array.html..done
index.html..not done
input.html..done
level_array.html..done
logo.html..done
netgame_config.html..done
netgame_join.html..done
netgame_main.html..done
netgame_packets.html..done
netgame_state.html..done
netgame_status.html..done
sound.html..done
tiles.html..done
timers.html..done

wow, all of this stuff is looking good...




find all css tags and remove unused

header_main..removed...
mh12 removed
mh2 removed
mh4 removed
mh5 removed

mh3 - body text (368)
mh7 - section title (178)
mh8 - file title (34)

mh10 - by: Michael David Weiss (2)
mh11 - Purple Martians title only (68)
mh12 - Technical Code Description only (32)

me1 - secondary header used in netgame config and netgame status

pk0 - packets
pk1 - packets






I want to simplify this:

The offsets from 6,7 are not necessary

old:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points are relative to outer arm 0 positon
   points[0][2] = points[0][6] + 85;
   points[0][3] = points[0][7] + 107;
   points[0][4] = points[0][6] + 95;
   points[0][5] = points[0][7] + 31;

   // inner arm is relative to outer arm
   points[2][0] = points[0][6] + 30;
   points[2][1] = points[0][7] + 30;
   points[2][2] = points[0][6] + 77;
   points[2][3] = points[0][7] + 32;
   points[2][4] = points[0][6] + 93;
   points[2][5] = points[0][7] + 53;
   points[2][6] = points[0][6] + 109;
   points[2][7] = points[0][7] + 69;


new:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points
   points[0][2] = -115;
   points[0][3] = -93;
   points[0][4] = -105;
   points[0][5] = -169;

   // inner arm
   points[2][0] = -170;
   points[2][1] = -170;
   points[2][2] = -123;
   points[2][3] = -68;
   points[2][4] = -107;
   points[2][5] = -147;
   points[2][6] = -91;
   points[2][7] = -131;



looking in game moves thingy
do I make a clear distinction between keys and controls??
I have a function called clear_keys(), that actually clears controls
renamed clear_keys() to clear_controls()
void set_comp_move_from_controls(int p)...never used. delete




web game move array is looking really good...


why do I use:
7 x memmove
7 x memset
27 x memcpy
replaced memmove with memcpy...


0 x memmove
7 x memset
32 x memcpy

1 - client reads stdf and put data in buffer
1 - server builds stdf packet

1 - server updates client's base state

7 - game_vars_to_state(char * b)
7 - state_to_game_vars(char * b)

14 - show_state_dif(char *a, char *b)

1 - add_log_entry2(int type, int player, const char *txt)



Can this be made simpler?

   // check to see if frame_nums match and its time to apply dif
   if (frame_num == client_state_dif_dst) // current frame_num is dif destination
   {
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         // if server has sent dif from src == 0, reset our base to 0
         if (client_state_dif_src == 0)
         {
            memset(client_state_base, 0, STATE_SIZE);
            client_state_base_frame_num = 0;
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
         }
         else
         {
            sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
         }
      }
      if (client_state_base_frame_num == client_state_dif_src)  // stored base state matches dif source
      {


how about this?

   // check to see if frame_nums match and its time to apply dif
   if (frame_num == client_state_dif_dst) // current frame_num is dif destination
   {
      // if server has sent dif from src == 0, reset our base to 0
      if (client_state_dif_src == 0)
      {
         memset(client_state_base, 0, STATE_SIZE);
         client_state_base_frame_num = 0;
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
      }
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
      }
      else // stored base state matches dif source
      {


simplify this:

   if (start_mode < 3) // normal or run game
   {
      frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


   if (start_mode == 3) // new level after level done
   {
      stamp();
      frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


done:

   if (start_mode == 3) stamp(); // new level after level done

	frame_num = 0;
	if (!load_level(play_level,0))
	{
		game_exit = 1;
		resume_allowed = 0;
	}



run demo mode does not use stored player color...

probably because color won't get set if player is already active....

fixed...
now restore saved color after demo play...
where??

demo play can end where?

level done
esc pressed..

how about when called from menu...done
and when called from demo mode...done





sort out init_player()

type 1 - all
type 2 - level done
type 3 - netgame join




8 calls

initial_setup()
calls 1 for every player

load_gm()
calls 1 for every player

proc_start_mode()
calls 2 for every player

client_init_join() after SJON rx'd
calls 1 for every player


server_exit()
calls 3 for every player ???? why??


server_init()
calls 1 for player 0


server_join
calls 1 for new player slot before tx SJON

proc_player_state_game_move()
calls 3 when new demo mode player comes active




there are a lot of things going on here....

make init_player call itself...


make some more specific calls

like 23 = clear bandwidth counters..done



game_move_entry_pos..used only by server....
don't clear on netplay join??..dont think it matters



i think I can get rid of 2 and 3 specifics...done

   if (t == 2) // level done
   {
      players1[p].game_move_entry_pos = 0; // server only  ( for client game_move data sync )
      players1[p].server_last_sdat_sent_frame_num = 0; // only server uses it, to keep track of when last sdat was sent to client
   }

   if (t == 3) // netplay join
   {
      players1[p].server_last_sdak_rx_frame_num = frame_num + 200;
   }

now change the 2 calls to 3 to 2's..done




looks a lot cleaner now...hope it all still works....


i should set control_method to 0 in init 1



demo mode won't quit with any key...

esc just starts new demo...



make a new list of where I call init_player()

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;



when client rx SJON
-------------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[cp].control_method = 4;
ima_client = 1;
active_local_player = cp;
players[cp].color = color;
players1[cp].game_move_entry_pos = server_game_move_entry_pos;



server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this




this one was probably an issue so i removed it:
proc_player_state_game_move(int x)
----------------------------------
// player becomes active
if ((players[p].active == 0) && (val > 0) && (val < 16))
{
	init_player(p, 1);
	players[p].active = 1;
	players[p].color = val;
	players1[p].join_frame = frame_num;



proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


demo_mode()
-----------
after pm_main is done:

// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 1;
active_local_player = 0;




in netgame client only stays alive for approx 5 sec or 200 frames after lock

can do next level good, but then 5s into next level same...

demo seems to exit good now...


-----------

when client quits...player lost server connection

this was missing:
void client_process_sdat_packet(void)
{
   players1[p].client_last_sdat_rx_frame_num = frame_num;

seems to work good now...


there are 3 places after run game where stuff is reset...can i make it one place?
actually only 2...commandline line immediatley exits
easier to make them the same...done


when new players come active in demo mode they don't start at the right position

how about when they come active at all...

when is 'get_player_start_pos()' called? 3 times:

in load level for player 0 only

after death

init player mode 2 (after level done)

--------------------


remove from init player mode 2 (after level done)

add to when they come players come active


----------------------------------------------------------
Make a new list of when set_player_start_pos called
----------------------------------------------------------
3 times
- load level for all players
- when player comes active
- after death


----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;




server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;

server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;




server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


not sure about this one:

its run every time start_mode loads a level
- new game
- level done
- NOT run game


i agree its not needed for run game, because load_gm took care of that

what does new game set up before start mode?? nothing

i should bring back start_mode 3


redo start modes....         start_mode = 1;
         game_exit = 0;

1 = new game (single player) do init 1
2 = level done (do init 2)


3 = new game (client

9 = file play

done...

now make start mode 1 clear everything

I can't beacuse it is called by single player start as well as server and client




proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);



------------------------------------------------------------------
major refactor...
------------------------------------------------------------------


I want to have more of my start up code in pm_main.


change its name to game_loop

make it take a variable..start_mode

make it set game_exit = 0 on entry



make it so that all the times its called for each mode, the code is common

make it so that more of my player setup is doen there.




how many modes can it be started in??


1 single player new game
2 server new game
3 client new game
5 level done
7 resume single player
9 run demo mode

also make some common exit code




list where called:
-demo mode

game menu x 6
-new
-resume
-server
-client
-after level editor
-run demo


command line x 7
- client 1 arg
- server 1 arg
- client 2 arg
- server 2 arg

- immed run 1 arg
- immed run 2 arg

- run demo



---------------------------------------------------------

game_exit = 0 set in game_loop start
rename pm_main to game_loop and pass it start_mode
then in turn pass start mode to proc_start_mode()

I can make start mode totally local to game_loop, but how will I deal with level_done setting it??

for now just set global to passed...

void game_loop(int passed_start_mode)
{
   start_mode = passed_start_mode;
   game_exit = 0;

this is all because of proc_level_done which also sets start_mode

game_loop()
   proc_controllers()
      proc_game_move()
         proc_level_done()

ill fix this later....

next move this to proc_start_mode()


   if (start_mode == 2) // server
   {
      if (!server_init())
      {
         server_exit();
         game_exit = 0;
      }
   }

   if (start_mode == 3) // client
   {
      if (!client_init())
      {
         client_exit();
         game_exit = 0;
      }
   }


make common exit code after

void game_loop(int passed_start_mode)
{
   while (!game_exit) // game loop
   {
   }

   // common exit stuff...
   if (ima_server) server_exit();
   if (ima_client) client_exit();
}



-------------------------------------------------------
now client init is only called once in start mode...
now client exit is called only 2 times...
once if client init fails
once at end of game loop if ima_client

same for server...


test...join good.


server can't re-start...failed to open listening channel....


is something setting ima_server to 0 before game_loop ends??

yes...proc_game_move when player goes inactive..
remove all stuff from there that messes with client or server player stuff
do it at end of game_loop()

done...

when client is waiting to join set level display to start pos...


moved player init to proc_start_mode common like this:

   if (start_mode == 5) // start new level after level done
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
   }
   else // 1, 2, 3, 9 - full player data reset
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
   }


then removed from:
client init()
server_init()
load_gm()


----------
test
single player good
client join good

client needs to set player pos while waiting to join...fixed
in load_level() set all players pos not just 0

client seems to take longer to join now...



----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


proc_start_mode()
------------------
if (start_mode == 5) // start new level after level done
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
}
else // 1, 2, 3, 9 - full player data reset
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
	players[0].active = 1;
}


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;

server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file

I am pretty confident about this....

----------------------------------------------------------------------------------

start_mode...

start_mode when calling game_loop only need to be processed the first time
EXCEPT for level done...

why not just make an exception for that...

make level_done have a new value of 2...

in game_loop:

if (level_done == 2) proc_start_mode(5);

before game_loop while

start_mode is no longer global and has a very small scope



---------------------------------
list of all level_done references
---------------------------------

in start_mode common set to 0

in item collision door and warp, set to 1

in single player control:
if (level_done == 1) add_game_move(frame_num, 6, 0, 0);

in server_local_control(int p)
if (level_done == 1) add_game_move(fn, 6, 0, 0);

in proc_level_done()
level_done = 2;

in game_loop()
if (level_done == 2) proc_start_mode(5);


----------------------------------------
list of all places resume_allowed is set
----------------------------------------

only 2 places set to 0
- level is loaded
- start level changes

only one place set to 1
- exit game in single player mode

-----------------------------------------------------------

demo mode wont quit...
esc just starts new demo

fixed start mode resetting control_method 1
remove setting control_method 1 in load_gm...now just done in start mode


-----------------------------------------------
List of at all the places control_method is set
-----------------------------------------------

zplayer.cpp sets it  1 time
---------------------------
init_player (full mode)
players[p].control_method = 0;


zclient.cpp sets it 5 times
---------------------------
when SJON rx
players[cp].control_method = 4;

4 times for check dif


zserver.cpp sets it 2 times
---------------------------
in server_init
players[0].control_method = 3; // server_local_control
ima_server = 1;

when setting up new client
players[cn].control_method = 2; //server client view only

zcontrol.cpp sets it 2 times
----------------------------
when player comes active:
if ((ima_server) || (ima_client))
   if (p != active_local_player) players[p].control_method = 2;
// if player 0 is file play all added players will be too
if (players[0].control_method == 1) players[p].control_method = 1;

when remote client goes inactive:
players[p].control_method = 9; // prevent re-use of this player number in this level


zloop.cpp sets it 2 times
-------------------------
after level done free used clients
if (players[p].control_method == 9) players[p].control_method = 0;

in proc_start_mode()
if (start_mode == 9) players[0].control_method = 1;




fixed bug in load gm that was only erasing 10,000 game moves instead of 1,000,000
look at all references to game_moves
made a common clear_game_moves()
made a define for GAME_MOVES_SIZE 1000000



old:

   if (--players1[p].made_active_holdoff < 0) players1[p].made_active_holdoff = 0;
   if ((!players1[p].made_active_holdoff) && (players[p].active == 0) && (players[p].control_method == 2) && (players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      players1[p].made_active_holdoff = 6;
      add_game_move(frame_num + 4, 1, p, players[p].color);
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }


new:

if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
{
   if (players1[p].made_active_holdoff) players1[p].made_active_holdoff--;
   else if ((players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      add_game_move(frame_num + 4, 1, p, players[p].color);
      players1[p].made_active_holdoff = 6;
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }
}




-------------------------------------------------------------
I should straighten out what happens when a player quits...
-------------------------------------------------------------

it all starts when a player presses the menu key or escape...

all modes:

set_comp_move_from_player_key_check(p);

// if menu key ignore everything else and set to 127
if (key[players1[p].menu_key])  cm = 127;
if (key[ALLEGRO_KEY_ESCAPE])    cm = 127;


when this comp_move is sent to add_game_move(frame_num, 5, p, players1[p].comp_move);

it is converted to a special player state move:

if ((type == 5) && (data2 == 127)) // change menu key to player state inactive special move
{
	game_moves[game_move_entry_pos][0] = frame;
	game_moves[game_move_entry_pos][1] = 1;     // type 1; player state
	game_moves[game_move_entry_pos][2] = data1; // player num
	game_moves[game_move_entry_pos][3] = 64;    // inactive
	game_move_entry_pos++;
	return; // to exit immediately
}


single player adds to local game moves array

in proc game move:
if (players[p].control_method == 0)
{
	game_exit = 1;
	resume_allowed = 1;
}


client sends raw move (5, 127) to server
server has special case to set frame to future (frame + 2)
server adds it with add_game_move() where it is converted to player state

server has a special case that just adds 2 to the frame number
   // this special case here is to fix bug that occurs when server_lead_frames > 0, and quit move doesn't get synced back to the client
   if (cm == 127) // client quit
   {
      add_game_move(fn+2, 5, p, cm);  // put in future
      sprintf(tmsg2,"<-- player:%d quit\n", p);
   }
   else
   {
      if (c_sync >= 0) add_game_move(fn, 5, p, cm); // add to game_move array


server drops client in proc_game_move() like this:
         // remote player quit
         if (players[p].control_method == 2)
         {
            players[p].active = 0;
            players[p].control_method = 9; // prevent re-use of this player number in this level
            players1[p].who = 99;

            // only makes sense to show this if not local player
            show_player_join_quit_timer = 60;
            show_player_join_quit_player = p;
            show_player_join_quit_jq = 0;
         }
other clients drop this client in the same way



client drops itself in proc_game_move() like this:
         // local client player quit
         if (players[p].control_method == 4)
         {
            if (val == 64) players1[p].quit_reason = 90;
            game_exit = 1;
            if (L_LOGGING_NETPLAY)
            {
               sprintf(msg,"Local Client(%s) quit the game.",local_hostname);
               add_log_entry_header(10, p, msg, 1);
               log_ending_stats();
            }
         }



what if I add to the frame number in add_game_move()??
then I can remove exception in server rx cdat

it will add for all modes, but that should be OK...

do it...done...still works...


what happens with player drop?
client...
quits the whole damn game with fast exit()!
that's too severe...what else can I do?

set game_exit = 1?

before that I want other client and server to know whats happening
or should I let the server take care of that??

well, if I've lost server connection, it doesn't make sense to send something to the server...

lets just set game_exit = 1 and:
players1[p].quit_reason = 75;
log_ending_stats();

the code at the end of game loop will clean up for me...

server:


void server_proc_player_drop(void)
{
   // check to see if we need to drop clients
   for (int p=1; p<NUM_PLAYERS; p++)   // server only; skip p[0]
      if (players[p].control_method == 2)
      {
         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", frame_num, players1[p].server_sync, p);
            add_game_move(frame_num + 4, 1, p, 71); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
         if (players1[p].server_last_sdak_rx_frame_num + 100 < frame_num)
         {
            //printf("[%4d][%4d] drop p:%d \n", frame_num, players1[p].server_last_sdak_rx_frame_num, p);
            add_game_move(frame_num + 4, 1, p, 71); // make client inactive (reason no sdak for 100 frames)

            sprintf(msg,"Server dropped player:%d (last sdat rx > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
      }
}

---------------------------------------
how does quit reason work?
---------------------------------------

in the player struct we have: players1[p].quit_reason

void log_reason_for_client_quit(int p)
{
   char tmsg[80];
   sprintf(tmsg,"unknown");
   int r = players1[p].quit_reason;
   if (r == 64) sprintf(tmsg,"player quit game with ESC");
   if (r == 70) sprintf(tmsg,"server drop (server sync > 100)");
   if (r == 71) sprintf(tmsg,"server drop (no sdak for 100 frames)");
   if (r == 74) sprintf(tmsg,"client never became active");
   if (r == 75) sprintf(tmsg,"client lost server connection");
   if (r == 80) sprintf(tmsg,"level done");
   if (r == 90) sprintf(tmsg,"local client quit");
   if (r == 91) sprintf(tmsg,"local server quit");
   if (r == 92) sprintf(tmsg,"remote server quit");
   sprintf(msg,"reason for quit...........[%s]", tmsg);
   add_log_entry_position_text(22, 0, 76, 10, msg, "|", " ");
}



when client drops due to lost server connection:
players1[p].quit_reason = 75;
log_ending_stats();




in proc_game_move() when the special game move player state is read,
if (val > 63) it a player drop and val is quit reason


when players quit with esc reason is set to 64
this is done in add_game_move() and is common to all...

when players are dropped by server it is set to 70 for sync and 71 for sdak


proc_game_move() reads the special game move player state and if inactive:
by default sets:  players1[p].quit_reason = val;
at this point it could be 64, 70, 71

then can set these modes:

74 player never became active
90 local client quit the game
91 local server quit the game
92 remote server ended the game

at the end on set inactive:

         if (players1[p].quit_reason == 70) log_ending_stats();
         if (players1[p].quit_reason == 71) log_ending_stats();
         if (players1[p].quit_reason == 74) log_ending_stats();
         if (players1[p].quit_reason == 90) log_ending_stats();
         if (players1[p].quit_reason == 91) log_ending_stats_server();
         if (players1[p].quit_reason == 92) log_ending_stats();

---------------------------------
where is log_ending_stats called?
---------------------------------
4 main places:

proc_game_move() - player inactive
client drop
level done
fast_exit()



made a lot of changes...need to test...something do not seem right....


-----------------------------------------------------------
client init code no line endings in log...fixed
-----------------------------------------------------------

-----------------------------------------------------------
show dif local and server reversed??
-----------------------------------------------------------
void show_state_dif(char *a, char *b)

// make copy of current state
char tmp[STATE_SIZE];
game_vars_to_state(tmp);

// compare copy to modified base state
if (memcmp(tmp, client_state_base, STATE_SIZE))
{
   dif_corr = 1;
   players1[p].dif_corr++;
   sprintf(tmsg, "corrections applied - total corrections:%d", players1[p].dif_corr);
   show_state_dif(tmp, client_state_base); // show dif


looks like a is local b is server

then c1 = a, c2 = b


then here its printed in reverse....

sprintf(msg, "player[%d].active  server:[%d] local:[%d]\n", p, c1_players[p].active, c2_players[p].active );


where would it be easiest to change?

show_state_dif(client_state_base, tmp); // show dif

done.....
-----------------------------------------------------------


-----------------------------------------------------------
when demo runs it leaves log file entries ..done
added erase_log(void);
at end of demo mode and run demo
-----------------------------------------------------------

-----------------------------------------------------------
log player array uses player num for each player..fixe to only use 0 ...done
-----------------------------------------------------------

-----------------------------------------------------------
players colors in log file viewer are bad...
try to get them from the logs
also set them in player init...
too hard, just set them when getting data at start of log file viewer..done
-----------------------------------------------------------








-----------------------------------------------------------
no logging when player come active???
what if client comes active because of stdf instead of game move??
-----------------------------------------------------------


250 server got join
371 server says player locked

492 server says player locked
496 server says player became active


on client
nothing around 371
at frame 500 stdf from 495 to 500 sets player active...


what does game moves say:

server:
-------------
number of entries 1473
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][ 375]-------------PLAYER 1 ACTIVE (color:11)--
[  1][ 496]-------------PLAYER 1 ACTIVE (color:11)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]

client:
-------------
number of entries 1470
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:4)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:10)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  3][ 507][1][ 4]  [    ][    ][    ][UP][     ][    ]



why is client missing those....

why is server missing start...

why does client have stuff that server does not??



old:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 3) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }

new:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 2) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }



this would explain why client had start info but server did not
also client had higher game move pos so it wouldn't enter new moves....

try this all again...seems to work a lost better now...

-----------------------------------------------------------
-----------------------------------------------------------


4 player works with ubuntu as one of them....

can I speed up chase and lock?

do I need the <2 > -4 things still?




--------------------------------------------------------------
when client joins, after getting initial state,

gets 14 more stdf until caught up and can acknowledge??

why cant we acknowledge first one??


looks like the first dif received was not applied
base was zero, but current did not match??
current = 0
should force...

does this happen every time? yes...

fixed that on client by setting frame_num after initial stdf rx, but before dif applied...

now:

dif gets applied on client and clients sends sdak on frame 142

server does not rx until frame 163
by then server has sent many more stdf's and fails to set new base for client

why is client 20 frames behind??

client gets first timer adjust at 162 with first sdat rx and is already 20 frames behind
server sends it at 142


is client timer slow until first adjust?? no

does start mode write over my start frame stuff?? no



-----------
new data

client fps = 40
client gets all 4 pieces of stdf (0-150)
client applies dif and sets frame_nums to 150

[client frame 150]
recieves all 4 peices of same stdf again
receives sdat from 154 and sets timer to 43
receives 2 4 peices of next stdf (0-155)
applies dif (0-150) again


[client frame 151]
client timer = 43
receives sdat from 174 and sets timer to 62

[client frame 153]
gets complete dif from (0-175)

[client frame 157]
receives sdat from 178 and sets timer to 60

[client frame 161]
gets complete dif from (0-180)

[client frame 163]
receives sdat from 182 and sets timer to 58




------------------

does it do the level load??

client init

load level

game loop start

client blocks for initial state

client chase



-------------
new data

[client frame 121]
client gets all 4 pieces of stdf (0-121)
client applies dif and sets frame_nums to 121

[client frame 122]

receives sdat from 125 and sets timer to 42
client gets all 4 pieces of stdf (0-125)

receives sdat from 129 and sets timer to 46
client gets first 2 pieces of stdf (0-130)

receives sdat from 145 and sets timer to 62
client gets first 3 pieces of stdf (0-145)



what if i flush the client rx buffer after good state rx'd? no dif
try setting stdf freq to 80...no dif


still cant figure out why client is 20 frames behind...



I put some time calls in client code and I dont see any delays....
do the same for server...





server send initial state on server frame 144 clock 6785

client gets it at clock 1350 and sets frame 144 to equal clock 1352

client gets sdat on frame 145 clock 1371 from server frame 166

server's clock was 7335 when it sent sdat 166



time dif at initial state rx:
server sent:6785
client rx: 1350
------------------
           5435



time dif at first sdat packet
server sent:7335
client rx: 1371
------------------
           5964



5964-5435 = 529ms / 25ms per frame = 21 frames



server:
166-144 = 22 frame * 25ms = 550ms
6785 + 550 = 7335
server checks out good


client:





tried TCP also

started at 10 sync then went down for 10 frames to 8
then got 9 sdats in one frame and went to 29



--------------------
just a thought...what if I did the chase part first?
then when that was good, just blast a state through
after rx sjon client starts in mode 2 inactive and uses sdats to chase and lock
--------------------------------------


20180616

all that I am doing here is to discover the 20 frame half second pause between
getting initial state and getting first sdat..

on the server I show a time stamp at the start of every server_control()
and make sure they agree...


server
------
frame 214
8507 server tx sjon
8507 server tx sdat

then every 25ms clock is working good

server sends another sdat every frame for sync

frame 236
9058
finally rx sdak and stak


client
------
first clock is 1146 after level start
1147 waiting for game state
1150 214 frame_num updated
1166 215 rx sdat and already 20 frames late

need more clocks on client...

client send cjon
client rx sjon


i think i found my delay.....

771 client tx cjon 771
803 client rx sjon 803
1313 after level start


705 tx cjon
746 rx sjon
768 after clear game moves array

stimp() takes 400 frames......

remove for netgame...

client for sure but also server for level done so just do both...

606 client tx cjon
624 client rx sjon
646 after clear game moves array
721 after load level

--------------------------------------------
just a thought....
I would love to do without load level for client joining and just let the initial state do it...
what is missing??
lift step data
bullets (not loaded with level anyway)

i load the level, but when I get initial state I overwrite almost everything

ok if add list steps, what else should I do??, bullets??
remove unused in player...

how big is lift steps?? 25600

lets just leave it for now...

--------------------------------------------

remove clocks...done

what if I made timer adjust twice as much adjust?

old
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - frame_num;
   int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));

new
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - frame_num;
   int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames)*2;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));




---------------------------------------------------------
just a thought

proc_controllers()

acts differently when in menu vs game

this is controlled by game_exit

what if I just passed something to proc_controllers()
run one way if in game, another for menu, another for key only...
maybe later.....


---------------------------------------------------------


restore all things...
- stdf_freq
- sync_freq


what about server send sync...

can i fine tune it for each player?

like if they have high server sync, send more often??


2 is normal (1 + server_lead_frames)

add to player struct:
int server_sdat_sync_freq;
by default set to 0;

0  every frame
1  every other frame
20 every 20 frames

adjust when setting sync, when rx'ing sdaks

done....


sometimes client gets ahead of server before rx first sync
then client can get a pile of sync sdat's and adjust timer for each one
but only the last one matters...

remove client_flush...

can i combine rx sdat and timer to one log line...done

set stdf_freq to 10


what if i hold off sending more stdf's after initial, until locked?
or until initial has been ack'd and new base set?


simplify this complicated mess....


         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         do
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
         } while ((players[p].control_method != 2) && (not_found < 8));
         if (not_found == 8) p = 0;   // if no clients found set to 0 so no send will happen
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send



         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         int loop_done = 0;
         while (!loop_done)
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
            if ((players[p].active) && (players[p].control_method == 2)) loop_done = 1;
            if (not_found > 8) // no clients found
            {
               loop_done = 1;
               p = 0; set to 0 so no send will happen
            }
         }
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send




run a test with 3 clients..all good

its important to flush client and server at level done and wait after...
not sure why...


----------------------------------------------------------------
if client does not get reply from server game starts anyway..fixed
----------------------------------------------------------------


----------------------------------------------------------------
when starting log file viewer with pm -lr, if no log files exits badly..fixed
----------------------------------------------------------------


----------------------------------------------------------------
don't save any log file unless in netgame mode..done
remove L_LOGGING and replace with L_LOGGING_NETPLAY...done
remove L_LOGGING_NETPLAY_timeradjust..done
move version and allegro version logging to client and server init..done
----------------------------------------------------------------


----------------------------------------------------------------
make server sdat log look like client sdat..done
----------------------------------------------------------------

----------------------------------------------------------------
reset ortho double when leaving log file viewer..done
can't set ortho in log file viewer..done
----------------------------------------------------------------

----------------------------------------------------------------
client has both ending stats....fixed....
----------------------------------------------------------------


ran 8 player game with no problems.....


lost y510 on level 5
reason: server drop (no sdak rx for 100 frames)
only active for 4 frames
first and only thing server received was stak on frame 247..really late


lost 4230j on level 6
reason: server drop (no sdak rx for 100 frames)


----------------------------------------
fix get all keys for linux..done
----------------------------------------

spent 6 hours making the graph for log file viewer look great...




in what nested way are these called??

all from game loop:
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();


int player_drop_item(int p);
3 x
1 x in player carry when item dropped
2 x item collision door entry


void draw_pop_message(int c);
1 x in draw_item

void draw_door(int c, int x, int y);
1 x in draw_item

void do_bomb_damage(int i);
1 x proc_lit_bomb();

void remove_block(int x, int y);
3 x
2 x proc_item_move(); key
1 x 1 x proc_lit_bomb();


--------how can i simplify these 6 calls from game loop?
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();

to compare, enemy has 3
enemy_move();
enemy_collision();
draw_enemy();


how are they iterated?

proc_item_collision();
500 items then 8 players

proc_item_move();
500 items

proc_lit_bomb();
500 items

proc_lit_rocket();
500 items

proc_player_carry();
8 players


I want to call:
proc_lit_bomb();
proc_lit_rocket();
from
proc_item_move();
done....now its only 4

proc_item_collision();
proc_item_move();
proc_player_carry();
draw_items();

can I move player carry somewhere??

add code in main player code to reset scale and rot if not in paused 2 or rocket
what if I just reset it by default and let someething change it if it needs to...
cant make that work..just reset after door move done and when drop rocket...

also when rocket explodes...
when rocket explodes it turns into a lit bomb
when lit bomb explodes force drop, reset scale and rot there... seems to work



now I want to patch this into main player move

void proc_player_carry(void)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (players[p].carry_item))
         if (!players[p].paused || (players[p].paused && players[p].paused_type == 2))// player is carrying item
         {
            int pc = players[p].carry_item-1; // number of item
            if (item[pc][0] != 98)            // not lit rocket
            {
               // set item position relative to player that's carrying it
               itemf[pc][1] = players[p].PY - al_itofix(2);
               if (!players[p].left_right) itemf[pc][0] = players[p].PX - al_itofix(15);
               if (players[p].left_right) itemf[pc][0] = players[p].PX + al_itofix(15);
            }
            if (!players[p].fire) // drop
            {
               if (player_drop_item(p) < 6)
               {
                  if (item[pc][0] != 98)            // not lit rocket
                  {
                     itemf[pc][2] = players[p].xinc;  // inherit the players momentum
                     itemf[pc][3] = players[p].yinc;
                     if (players[p].up)    itemf[pc][3] -= al_itofix(6); // throw item upwards
                     if (players[p].left)  itemf[pc][2] -= al_itofix(2); // throw item left
                     if (players[p].right) itemf[pc][2] += al_itofix(2); // throw item right
                  }
                  else // drop a rocket
                  {
                     players[p].draw_rot = al_itofix(0);
                     players[p].draw_scale = al_itofix(1);
                  }
               }
            }
         }
}

void proc_player_carry(int p)

done...


rot not fixed after death



lets rename zemove to zenemy..done

lets move all file stuff to zfile and lose yfilecom..done

lets put underscores in all z files..done




---------------------------------------------------------
what happens if a client gets a dif with the wrong base from the server?
a log entry is created, but no other handling is done...
this can't be an issue cause it works, I'm just curious....

when could this happen?
client updates base, but ack never makes it back to server...

then server will keep sending difs with new dest, but same src that client does not have
client will never ack, cause they have wrong base

how about if client gets wrong base, it acks with correct base?

this cant be done in apply because it checks every frame and will often have base

do it when the full packet is rx and decompressed...at that point the src better match...

maybe it can be done in apply, but only on the frame where dest = frame
yes, that should work...

its just re-sending the ack, that for some reason the server does not have
then the server will detect the mismatch and reset base to 0



      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);

         // send ack to server with correct acknowledged base state
         Packet("stak");
         PacketPut1ByteInt(p);
         PacketPut1ByteInt(0);
         PacketPut4ByteInt(client_state_base_frame_num);
         ClientSend(packetbuffer, packetsize);
      }


done.....
---------------------------------------------------------







next..how f'd are the collision checks

proc_item_collision();
500 items - 8 players


proc_enemy_collision();
100 enemies - 50 pbullets
            - 8 players


ebullets
50 ebullets - 8 players

pbullets
50 pbullets - 8 players



I could straighten this out by:
put both bullet checks and item in player

I'm already iterating players...


what needs collision checks?
player - pbullets
       - ebullets
       - enemies
       - items

enemy - pbullets

what if I make the functions like:

proc_player_item_collision(int p)



made all item collision for specific types into their own functions...

               switch (item[x][0]) // item type
               {
                  case 1: proc_door_collision(p, x); break;
                  case 2: proc_bonus_collision(p, x); break;
                  case 3: proc_exit_collision(p, x); break;
                  case 4: proc_key_collision(p, x); break;
                  case 6: proc_freeman_collision(p, x); break;
                  case 7: proc_mine_collision(p, x); break;
                  case 8: proc_bomb_collision(p, x); break;
                  case 10: item[x][6] = item[x][7]; break; // set pop-up message timer
                  case 11: proc_rocket_collision(p, x); break;
                  case 12: proc_warp_collision(p, x); break;
                  case 14: proc_switch_collision(p, x); break;
                  case 15: proc_sproingy_collision(p, x); break;
               }
            } // end of player collision with active item


now I want to call item collison from player_move

where should I do the collision detection?

this means that the order of things in the game loop will change...

old:

      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_collision();
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();
      proc_player_move();
      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();

new:
      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();

      proc_player_move();
      proc_item_collision();

      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();



done

now I call
proc_item_collision(p);
from player_move

collision detection takes place in proc_item_collision(p);

that looks good, now what else?

move ebullet collision to player also
done
proc_ebullet_collision(p);

now enemy collision with player..

         int i = players[p].carry_item-1; // number of item

ok now I have moved all to player move....
player - pbullets
       - ebullets
       - enemies
       - items

the only collision I have left is
enemy to pbullet


got rid of the global EN in z_enemy
now what about EXint and EYint??..done

also rearrage game loop stuff

move some things out of player_move to simplify...looks good

need to test....

of all the things I don't do when paused, i maybe should proc player carry?? so i can carry through doors?

bounds check to be its own funtion...


streamline the 4 player collisions in player move

one function to do all the collision checks, then only call:
proc_item_collision(p, c);
when an actual collision has take place

items:
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
            if ( (players[p].PX  > itemf[x][0] - f16 ) &&
                 (players[p].PX  < itemf[x][0] + f16 ) &&
                 (players[p].PY  > itemf[x][1] - f16 ) &&
                 (players[p].PY  < itemf[x][1] + f16 ) )
            {



enemies:
void proc_enemy_collision_with_player(int p)
{
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if enemy active and not deathcount
      {
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;

         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2)) Ei[e][22] = p+1; // player collision

      }
   }
}


void proc_pbullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (pbullet[b][0])  // if bullet not active skip to next one
      {
         // check for player collisions
         if (deathmatch_pbullets)
         {
            int px = al_fixtoi(players[p].PX);
            int py = al_fixtoi(players[p].PY);
            int bx = pbullet[b][2];
            int by = pbullet[b][3];
            if ((bx > px - 10) && (bx < px + 10) && (by > py - 10) && (by < py + 10))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet



void proc_ebullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (e_bullet_active[b])  // if bullet not active skip to next one
      {

         // player position
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         // check for collision with player
         if ((x > px-ax) && (x < px+ax) && (y > py-ay) && (y < py+ay))









void proc_player_collisions(int p)
{

   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // player position
   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;

   // pbullets
   if (deathmatch_pbullets)
   {
      for (int b=0; b<50; b++)
         if (pbullet[b][0])  // if active
         {
            al_fixed bx1 = al_itofix(pbullet[b][2]) - f10;
            al_fixed bx2 = al_itofix(pbullet[b][2]) + f10;
            al_fixed by1 = al_itofix(pbullet[b][3]) - f10;
            al_fixed by2 = al_itofix(pbullet[b][3]) + f10;
            if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet
               // do something
            }
         }
   }

   // ebullets
   for (int b=0; b<50; b++)
      if (e_bullet_active[b])  // if active
      {
         // new collision box is based on bullet speed and has both x and z component
         al_fixed ax = abs(e_bullet_fxinc[b]);      // enemy_bullet_collision_window x
         al_fixed ay = abs(e_bullet_fyinc[b]);      // enemy_bullet_collision_window y

         // enforce some minimums
         if (ax < al_itofix(4)) ax = al_itofix(4);
         if (ay < al_itofix(4)) ay = al_itofix(4);

         al_fixed bx1 = e_bullet_fx[b] - ax;
         al_fixed bx2 = e_bullet_fx[b] + ax;
         al_fixed by1 = e_bullet_fy[b] - ay;
         al_fixed by2 = e_bullet_fy[b] + ay;

         if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
         {
            // do something
         }
      }

   // enemies
   for (int e=0; e<100; e++)
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2))
         {
            Ei[e][22] = p+1; // player collision
         }
      }

   // items
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;

         if ((px > ix1) && (px < ix2) && (py > iy1) && (py < iy2))
         {
            // do something
         }
      }
}


----------------


I've made a lot of changes


now I need to do a thorough testing....

20180618

ride rocket
drop rocket
ride rocket till it explodes rarely doesnt reset player size and rot

where do i reset player size and rot?
now only one place...by default in move_player
after not paused, because I dont want to mess with paused
before rocket beacuse rocket will set it..
seems simpler and seems to work

ride lifts up and down don't line up good with lift floor
switched move lifts to before move_player

bombs...


ride rocket
drop rocket
ride rocket till it explodes
multiple player ride rocket
shoot while riding rocket
get hit with bullet while riding rocket

player item collison when riding rocket

ride rocket through door




doesnt drop rocket

according to door entry, items should be dropped if move type != -2
and rocket is set to -1

does it pick it up again really quick?

when riding rocket, i don't check for collisions?? no, i still do..

what do I want to happen?
when player riding rocket and hits door, drop rocket and travel through door

what actually happens?
nothing

player collision works for other items when riding rocket

when entering door rocket is dropped, but then picked up again right away...

both happen when processing item collision...

first door drops, then rocket pickes up...

how about if you drop an item one frame, you cant pick up until next frame...
sounds convoluted, is there an easier way??

its an exception for door entry only so things dropped stay dropped

why does re-picking up the rocket cancel door entry??
i dont know         int i = players[p].carry_item-1; // number of item


i think the door does the instant move for the player
but then the rocket moves it back

the players position for collision only happens before the iteration so when its is updated
its not used for further collsion checking

fixing this could fix it all and more...

done, now all collisions for player use actually players1.PX and PY so if
something in the collisions changes them, the next collisions will use the updated values


need to remove some test print code....



working on ride rocket through door
- only make sense if door if instant move
- can set to instant if auto and riding rocket



- will need to make rocket able to have carry through door flag set


looks like all rockets are set to -1, but code in slider buttons only does 0 and 1

do rockets need to be set to -1?

when touched they are changed to item 98
also if 0 or 1 set to -1
if -2 leave at -2

use glt to make all -1 rockets into 1
leave all 0

actually wouldn't it make more sense for rockets to be -2, -1, 0  ??

1 makes no sense for a rocket...

do it..

in glt set all 1 to -1...done
pde done...
sliders done...

looks like I have the ride rocket through door thing working....

what about carrying items through door?

if not -2 item is left behind

else appears at end after door move
works good, just looks funny when item is left behind during move then appears at end..

what if in paused mode, if carrying, do special draw for item carried??
at the very minimum, dont draw...
how can i set an item to not draw?

unused variables 2 for draw type
how about 1=drawn 0=not

later, this is so minor, add to wish list
------------------



------------------------------------------------
exit level in single player mode is broken

follow it through...

exit or warp sets level_done = 1;
move_player -> item collision...


single player local control adds game move..
proc game move sets to 2

they are in the wrong order in game loop.

before the level_done == 2 check is done, move player sets it back to one...
what's the solution?

make 2 variables? or change order?
level_done_trig
level_done_proc

done...now single and netgame level done are working good..

------------------------------------------------

what else to test??


----------------------

working on bomb explosion stuff.....

redrew the explosion sprites...

changed to have multiple times when the do bomb damage happens, as the explosion grows and moves


what are you trying to do for bomb?



make the blast area more dynamic, circular would be awesome!!

draw a better animation sequence with more shapes for explosion and make it more round



make the block removal work on every frame of explosion so it grows




made a function to show and remove blocks in the blast radius
for now everything else is commented out

fine tune the size and radius of the blast...ok i like it....

now what??

make the explosion shape match...


what if I do scale all by myself and not pass it with 10
yes, 10 is used by other items for different things...









----------------------------------------------------------------
re-did bottom msg to use al_map_rgb() instead of palette color indexes

thinking about how to do stretched text fast without changing target bitmaps

what if I make an array of bitmaps to hold each text line..
the only time I need to change target bitmap, will be when I enter a new one.
I'll do a simple copy of pointers to slide new bitmaps.
Then when I draw all the bitmaps, I can scale them then.

what is the max length in text of a bmsg?? at least 40 lest do 50

height = 8; width = 400; number = 20;

ALLEGRO_BITMAP bmsg_bmp[20];

this code is bad, it just copies pointers:
for (int c=19; c>0; c--)
  bmsg_bmp[c] = bmsg_bmp[c-1];

keep all the bitmaps in the original array and copy to temp array

done...

bottom message has been fixed and looks great
----------------------------------------------------------------








----------------------------------------------------------------
why are num_shapes for animation seq one less than actual??
----------------------------------------------------------------
i don't know... i don't want to change it in case it breaks other stuff, ill just work around it



I am quite happy with the block destruction

now enemies...happy with that...

now players...only do damage once....


its coming along very nicely...





do bomb damge is gone and have been replaced with:

bomb_blocks(c, 2);
bomb_enemies(c, 2);
bomb_players(c, 2);

these are called every frame when in explosion mode.
blocks and enemies destroy every frame, but players only when item[][8] == 1


these are all called in the draw code also:
            bomb_blocks(c, 1); // mark blocks that will be destroyed
            bomb_enemies(c, 1); // mark enemies that will be destroyed
            bomb_players(c, 1);

but with mode 1 that only marks...

cant make it common because...
- i don't want anything but drawing in the draw stuff
- i dont want any drawing in the non-drawing stuff

I'm about out of time for today, but the next things to do are:

make the markings flash based on mod passcount....

fix the fuse burning thing...
i'll probably go to another type of ans, like the original
and make a stopwatch with drawing primitives....


send ratio to 3 bomb_  functions as float int f
no, send range as int..done

well I now have all the bomb stuff looking good

make bomb range a circle in level editor..done

sticky bombs??

when a rocket turns into a bomb do I stop it?, i do now!!

mark player in bomb range with amount of health lost


make a new int in player struct about potential bomb damage

show with health display...i'm prety happy about how it looks now

bomb crosshairs draw when black..fixed


game_events...

remove all calls to 6 and 7 H- and H+
add to individula calls..

mines...done

11 you got shot...




----------------------------------------


i need to redo collisions...

make an easy way to test.....

player vs player bullets....

shoot a player bullet +80 x with no velocity...

make temp player move to move in x or y

ok thats good...

i'm getting lost in collision stuff


very high level stuff..
everything move then check collisions
how is it now

move_players() that call player collisions after move for each player
move enemies that call collision then move for each enemy

do i really need to do the stretch thing for bullet collisions??


first problem to solve, player bullets with players use 10's
then see how the collisons look...seems good...

now see how far away the initial bullet position is
it is zero'd with player

i do one move before leaving bullet creation, then the initial position is better

but by the time it draws its made a second move

move_player creates bullet
then collision
then bullet move
then bullet draw

so why doesn't just doing one initial move work
it does, but doesnt look good...

how am i going fix this

move the bullet moves to before player move in loop...
test...seems good....

suicide pblullets works good now...

bottom messages need to be re-written to use player name or number

use:
z1 for player number
z2 for item or enemy number
z3 ...
z4 for damage



void game_event(int ev, int x, int y, int z1, int z2, int z3, int z4)

case 10:
game_event(10, 0, 0, p, i, 0, item[i][8]);
sprintf(msg, "Player %d hit a mine! Health -%d", z1, z4); new_bmsg(msg); break;

case 11:
game_event(11, 0, 0, p, e_type, 0, damage);
sprintf(msg, "Player %d got shot by %s! Health -%d", z1, enemy_name[z2], z4); new_bmsg(msg); break;

case 12:
game_event(12, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
sprintf(msg, "Player %d hit by %s! Health -%d", z1, enemy_name[Ei[z2][0]], z4)


use Ei[e][26] to track what player killed the enemy..done

is there any way I can mark what player activated a bomb or rocket?
or better yet what player carried it last...

use 13....

set when lit in bomb or rocket..done

use when killing enemy

i think its good!!

now make it so that the last player that touched it gets the credit

fix sound events...done


after extensive changing, bottom messages are looking good.
still to do...

show when player damages another player with bomb

now I show when player takes explosion damage, just need to add from what player

add when player explodes themselves..done

removed screen messages to extra code file...







---------------------------------------------------------
player lags on fast rockets...fixed
---------------------------------------------------------
where is the code that binds them..

its in player move -> void proc_player_riding_rocket(int p)

then item move happens, then draw...

can I bind them in item move??

      // if player riding, bind player to rocket
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }








---------------------------------------------------------
sticky bombs..done
---------------------------------------------------------

what do I need to do to make this a thing?


re-use regular bomb, just modify move code...

for now do it on regular bomb, then later add new move type...

if not being carried, look to see if walls are close, if yes then set xinc, yinc to zero

make a funtion to do that

int is_item_stuck_to wall(int i)
{
   int x = al_fixtoi(itemf[i][0]);
   int y = al_fixtoi(itemf[i][1]);

   if ((is_left_solid(x,y, 0) || (is_right_solid(x,y, 0) ||
       (is_down_solid(x,y, 0) || (is_up_solid(x,y, 0) )

       return 1;

   return 0;
}


i'm ready to make a certain type of bomb

i plan to overload the already overloaded move_type of item

no just use 11 and make a new pde type

no add slider to existing and custom draw code tile 440..done

need to test how it works with lifts..seem to ignore them quite nicely except for regular ride...


---------------------------------------------------------
remote detonation of bombs
---------------------------------------------------------
this will differ from regular bombs in that the timer is replaced by a remote detonator.

whatever player triggers the bomb will always have the trigger.

should save the player num in the item, so a player can have many items triggered

can I reuse existing bomb?

what if I make another mode, mode 3

then when that is done move to mode 2 explosion like normal

can I use 12 for remote/timer?? yes...

make slider..done

when touch first time set mode 3 if 12...done

now add code in proc_lit_bomb()

use 13 to mark player that trigger it

that was easy!!

next make a different bitmap to show the remote detonator.

maybe draw a line to the player

as it is now, another player can steal the trigger by moving the bomb

i want to draw dynamite! 3 red sticks...
with a timer if appropriate, or a red button

537 - 539

looking good...

change color of remote line to gray..done

make editor set the correct initial shape..done

make bottom msg display correctly..done

test multiplayer..work exactly as i thought
players can steal bomb from other players by grabbing the bomb
then the remote belongs to them
it has no effect trying to grab the remote

test carrying remote through doors...good
can't drop it if you wanted to

test carrying bombs through doors...
works fine with remote..

what about a regular bomb?

what happens if it explodes while in door travel??
item is left behind in door travel until travel is complete
player is invincible in door travel


--------------------------------------------

rename and move stuff in editor...

to start with, move the three things that edit text to z_menu

// e_nlv.h
void edit_server_name(void);
int edit_lift_name(int lift, int step_ty, int bts);

// e_nev.h
void show_cursor(char *f, int cursor_pos, int xpos_c, int ypos, int cursor_color, int restore, int rot);
int edit_pmsg_text(int c, int new_msg);

removed global fst[80];

lift name good...
server name good...
pmsg good

fix pm.h..done


rename e_editor to e_editor_main

make e_editor_zfs
put all zfs and sel there...

move from main to zfs...done


these files are good and don't need anything:
bitmap
glt
pde (pde_editor)
special (could use a better name) (object_selection_and_status_windows?) (pde_sel_window)
combine pde...done
sliders
lev (could use a better name) visual level thingy

e_nlv change name to e_lift (has only lift stuff)

these are what really need arranging:

nev
item

fnx

make a new file e_object_viewer



--------------------------------------------
not that long ago I could carry items through moveable doors and it would show...
--------------------------------------------

I must have broke it in my rearrangment of player move..
added player carry at the end of paused mode door travel
now it works like it used to, but...
if drop during travel item goes back to door entry place..why??
because item was inheriting player's momentum in drop item...fixed
now what happens with bomb...

when dropping item in solid blocks...
player drop when checking for stuck, will move it left or right until not stuck
not for bomb, because wall stuck is not done for bomb...

what about rockets??
rocket never travel through doors.
if carry through door is set, rocket will do instant no matter what door is set to..

if not ride through door and fire is pressed, on exit player will snap to riding rocket again...
force drop on entry for this case...

on door entry, every item with carry through flag is dropped:
// check to see if player is carrying an item without the carry through door flag set
if (item[ci][3] != -2)  player_drop_item(p);

so why does rocket act different??

its not getting dropped on door entry
in the long list of item collisions, door is dropping, but then rocket as later item is picking up..
in item collision check for inactive player...done and fixed..



--------------------------------------------------
Rules for items, rockets, doors, bombs.
--------------------------------------------------

- when players are in door move they are invincible


- players can carry items through doors, if the items's carry_through_door flag is set

- if the flag is not set the item is dropped on door entry


- the only things a player can do when in door move is
- drop an item
- trigger a bomb

- if the item is dropped in solid blocks, it will move left or right until free.


- if a bomb is dropped in solid blocks it will stay where it was dropped

- a bomb can expode while in door travel, no player damage, player is paused, invincible


- rockets can be ridden through doors if the ride_through_door flag is set

- rockets will never do door move, they are forced to instant


- doors can be carried through other doors if the flag is set

- doors cannot be carried through themselves






---------------------------------------------------------
cant throw sticky bomb upwards when standing on ground, it gets stuck to ground...fixed
---------------------------------------------------------
// prevent sticky bombs from sticking to the ground when throwing upwards
if ((item[i][0] == 99) && (item[i][11]) && (players[p].up)) itemf[i][1] -= al_itofix(2);





---------------------------------------------------------
flapper uses passount mod for flap...
can i make them all custom based on flap speed?
---------------------------------------------------------

right now I have a counter in the enemy ints that goes from 0-22
and does something for each integer case..

I could convert it to a float and increment it a float ammount each time
then have all my cases based on percentages of the float...

I would need 2 floats (fixed), the counter and the inc
I will make the counter constant and the inc variable
called flap speed...
user will set 0.5 to 8
constant will be from 0-100

Efi[][9] flap speed counter
Efi[][10] flap speed inc


working good...

next thing...

with different flap speeds, the flap y inc is added a different amount of times

so the same flap yinc will have different effect with different flap speeds...

should be easy to make this constant

also maybe show in level editor how much flap yinc is...


the number of times flap is called is

50/flap inc


each time 3 * r * flap yinc..

so max swing = (50/item[i][9]) * 3 * item[i][8]

i want to change 8 to the max + or - amount that flap does...
mark it in editor, then make it happen in code


yflap is now a float from 0 to 4
i will change it to 0-400 and it could be an int...

Efi[][8] can still have a calculated value based on the rest...


target is flap height (Ei[][21])

adjust yflap (Efi[][8]) to make that happen...

equation:

Ei[][21] = (50/Ei[i][9]) * Ei[i][8]

Ei[i][8] = Ei[][21] / (50/Ei[i][9])


----------------

its looking good, but the 2 halves are not symetrical...
they drift...
seek was evening it out, but with seek disabled, drift is totally visible

to fix this i need to make both halves the same

they both need to start at 0
right now the second one starts at f-50

how about if i detect when > 50 and set to 50 exacltly

that seems to do it...


360 base

max 453
min 209

360 - 453 = -93
360 - 209 = 151


is it beacuse I start at 0 which is in the middle of a move
when I should start at 25 or 75 which is a zero point...

what if I rearrange my two halves:

0 to -1 and back to 0

0 to +1 and back to 0

also try a trig function


i am always adding the ammount, but they add up
i need to remove the last add then add a new one...


remove 3

put only flap in 3, then apply




applying the huge amount every time...
if it collides then the huge ammount is taken back..
this is not good...

calculate the difference between last and current...
apply and check for only that...

every time f = 0 save y pos in Ei[][14] for drawing only



can i use trakbot collisons for flapper? yes...

i think flappers are done...

they can still look bad at extreme values, like flap speed < 1 or > 5



-----------------------------------------------------------
make multiple player starts...
-----------------------------------------------------------

could be invisible if only one player...

how will i implement this...


marks starts with number..

0 is primary and all levels must have one

1 and higher are secondary...

if netgame show all
if single player only show 0

when players start if player is > 0 look for second start


how to map...


if st = 1 all players get 0

if st = 2
p0 0
p1 1
p2 0
p3 1


if st = 3
p0 0
p1 1
p2 2
p3 0
p4 1
p5 2
p6 0
p7 1


if st = 4
p0 0
p1 1
p2 2
p3 3
p4 0
p5 1
p6 2
p7 3

1st - count number of starts
2nd - player_num % ns = start


test this
   int p[8] = {0};
   for (int ns=1; ns<9; ns++)
   {
      printf("ns = %d\n", ns);
      for (int q=0; q<8; q++) p[q] = q % ns;
      for (int q=0; q<8; q++) printf("p:%d s:%d\n", q, p[q]);
   }
works

now make code in editor work...
item[][7] start index

now make code in game work...

void set_player_start_pos(int p)

it seems to work...

now how to make it safer..
in editor, enforce that:
- starts must not have duplicate indexes
- starts must have consectutive numbers

- at least one start must exist
- no more than 8 starts exist

in create start, make the new start one plus the old one

when changing start number...

how about on save flag if error and let user fix manually...



for the most part I want start blocks to not even be noticed and have the old behaviour
they are only used rarely when multiple starts are desired


one idea would be to have 2 creators, one for the main start and one for secondary starts
secondary starts would have a different shape

when running the main one it will:
-erase any other index 0
-make a new index 0
-ignore any secondary

when running the secondary one
-find the next position
-enter there



for now mark them with a number...

when level is loaded, save number of starts as global...
when drawing starts only mark with number if more than 1...

do this in level check which is called when level is saved...
or loaded...done...

this will be good enough for now..

- when using the start creator all other starts are erased (no change)
- to make secondary start copy, paste, and change index
- start checks are in place on level save and load
- index numbers are shown when start is drawn only if more than one start
- in sort_item() (editor only) number of starts is updated
- secondary starts only affect when other players join




--------------------------------------------------------------
remote lasts through death, and can trigger remote while death paused..fixed
--------------------------------------------------------------
to fix this make player lose any remotes when dead
bomb will go back to having remote...
OR....bomb could explode!!!
where does player die??
in proc player paused == 1


--------------------------------------------------------------
make block walker and archwag share common code...done
--------------------------------------------------------------
--------------------------------------------------------------
same as bouncer and cannon..done
--------------------------------------------------------------




--------------------------------------------------------------
clean up enemy drawing modes...block walker...done
--------------------------------------------------------------
all have only 2...

where is Ei[e][4] used?

anywhere in draw code??
no..

trakbot uses it for fall count...

removed from archwag and walker...
cleaned up comments related to Ei[][4]...


---------------------------------------------------------
I've somehow inroduced a bug
cloner creator is all screwy
makes a block walker??
podzilla creator makes a cloner??
those are the only 2 things made with creators...
fixed bug in int get_empty_enemy(int type)
done
---------------------------------------------------------




---------------------------------------------------------
cloners to have nicer drawing stuff, like a better shape, boxes around areas, etc
---------------------------------------------------------

what if I draw lines on level background, like lift_lines?

made a new ans 104 for cloner...


split between draw code and move code
I can draw the tiny old status bar in draw

i can set a shape in move...working on getting it looking good...


move the drawing code to draw from lift lines..

make it flash when cloning...

it seems to take too long when cloning instantly

32 frames is almost 1 second

changed to 8 and it looks better

there are times when you dont want the trigger box shown...
like when it is very huge

make a flag to turn it off in cloner...
all three or just trigger...

or trigger and source dest boxes...

done, used Ei[][4] for both...

now make clone happen on earlier count

cloner is coming along nicely

death ans..done

shape in level editor

make creator set
231 - 550

do glt to fix all cloners...
new shape 550 in 1
new draw type 0 in 2
done

-------------------------------------------------------------------
after changing flapper stuff all existing flappers do not work...
-------------------------------------------------------------------

flap speed and flap height

better defaults are:
x 2.7
xa .2

y 2
fs 3
fh 30
hap 60


Ei[][20] height above player
Ei[][21] flap height

Efi[][5] max x speed
Efi[][6] x accel
Efi[][10] flap speed inc


player lit a rocket bottom message on level wiuth no rockets, only flappers, sproingies..fixed

editor pop menu does not scroll up, goes off bottom of level...fixed




---------------------------------------------------------
i miss the first few frame becuae of stimp...
reset frame_nums at end of stimp...fixed
---------------------------------------------------------


---------------------------------------------------------
sometimes when riding rockets, you let go of one and grab another
but you snap to the last one and are drawn there, but you control the new one???
---------------------------------------------------------
problem was in proc_lit_item

      // if any players are riding this rocket, bind then to rocket's position
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (players[p].carry_item) && (players[p].carry_item == i+1 ))
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }

//      // if player riding, bind player to rocket
//      for (int p=0; p<NUM_PLAYERS; p++)
//         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
//         {
//            players[p].PX = itemf[i][0];
//            players[p].PY = itemf[i][1];
//         }



---------------------------------------------------------
when pressed up against a breakable block you shoot through it...fixed
---------------------------------------------------------
only facing right...
added this line to buillet code..
if (players[p].left_right) pbullet[b][4]--;



---------------------------------------------------------
flapper twitches when seek yinc is more than flap yinc??
---------------------------------------------------------

they fight each other...

should i seperate them??



right now I use Ei[14] for base for drawing only


pick a fixed and use it for base y

base_y will only be affected my seek yinc

Efi[e][11] will have base_y

need to set to same as [1] in level editor for initial...
or I could set it to a negative value, to signal emove stuff to set it to 1
for now if zero set to 1


i'm getting lost...
if i cant describe it in words how can i hope to fix it?

y position of flapper...
stored in Efi[][1]

affected by seek yinc and flap

flap needs to have memory of last flap, so it can convert to yinc


i think the two can be added and then checked and applied

but what about when flap goes up and seek goes down??
funny oscillations, that's what....


------------
tried...

make a variable for base_y set only by seek and that got weird...

---------------
could I avoid this by choosing only good values for seek_yinc and flap_height??



what looks bad:

-----------------------
seek_yinc = 2
flap_speed = .5
flap height = 100
when passing through height above player position,
there is a quite noticeable stutter as seek flips from -2 to 2
max flap_yinc = 3.5

----------------------
seek_yinc = 2
flap_speed = 1.0
flap height = 100
when passing through height above player position,
stutter is not as noticeable
beacause flap yinc is bigger in relation to seek_yinc
max flap_yinc = 7


I can avoid this by making sure max_flap is at least 4 times higher than seek

how about if I scale seek based on how far away it it..

more than 100 = full
< 100
get a ratio (100 - df)

implemented this and the above problem is fixed....






block #18 = ladder

make a function to detect if player in touching ladder block...done

add variable to player struct on_ladder...
added to main player struct..took place of old bitmap_index


can get off of ladder by moving away from detection area
except if moving up at top of ladder then I want player to just stop there...


player should be able to shoot if on ladder..done

player should be able to jump off ladder..done

player needs wall collision detection while on ladder..done
player can now navigate single block openings well while on ladder


add to move code if player moves up past top of ladder to just stop moving up
so that player does not fall off ladder...done


jump sets on_ladder to 0
jump only if up is not pressed


when players grabs ladder, need to make sure player is not embedded in wall
or else up and down will not work..
only when grabbing ladder when moving left or right...done



player should have different shape seq when on ladder


I think ladder is done except for new animation seq for ladder move



now what about rope?
block #19 = rope

snap to 0 position when on rope
can only move left and right
can't jump
can't shoot??
can carry
only way to leave rope is down or move off ends of rope left or right



ropes and ladders seem to be working fine, but now I will need
to spend some time doing nice animation sequences


what happens when player is shot?  do they fall off rope or ladder?

what does recoil do to them??
adds to xinc and yinc, then that takes effect when player leaves rope or ladder


how about don't do any recoil when on ladder or rope...




new player shapes.....

1 for jumping

2 for rope
2 for ladder

what process do I have to go through to add them?


brought back from the dead
void fill_player_tile(void)

call it from load tiles instead of other code...

make sure it works...yes it does

it needs these tiles from main tile set:

368-373 (look up)
400-405 (regular)
432-437 (look down)
755 (bullet)

made some changes to main tile set
now players down shapes are 432-437

i want to add 5 more shapes for each player color

438 jump
528-529 rope
560-561 ladder

increase array...

it was already
ALLEGRO_BITMAP *player_tile[16][32] = {NULL};

increase ptilemaps

old was 380x320
new 480 x 320


am i really done with ladder and ropes??


what about jumping on top of ladder?


normally I can jump any time while on ladder
I will not be on ladder after jump
but then I can grab it again with up

i disabled jump while up is pressed to prevent faster ladder climb



fixed this with a few techniques:

- changed order to process jump first and dont do any up if jump pressed

that still speeded up jump held while climbing
because for one frame when not on ladder yinc moved player 6.6
then next frame grabbed ladder again and moved at 3...

so i keep the saem yinc but offest y pos by 2.6...

   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
   }fix all refs to draw item of trakbot...
old 192
new 384

   else
   {
      if (players[p].up)   players[p].PY -=   is_up_solidfm(players[p].PX, players[p].PY, m, 0);
   }


this looks good and works....


---------------------------------------------
fix all refs to draw item of trakbot...done
---------------------------------------------
old 192
new 384


---------------------------------------------
player should be able to throw items down as well as up...done
---------------------------------------------
i did that but terminal velocity of items is only 3 and .1 for gravity
compare to player with terminal velocity of 7.8 and gravity of .6 or .2 for slow


---------------------------------------------
legend boxes flashing are still not seen sometimes...done
---------------------------------------------
use slash marking??
done for cloner, podzilla and key block range




---------------------------------------------
bug in item var 3 move type...done:
---------------------------------------------

   if (bn == 26)
   {
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");
   }


   if (bn == 2)
   {
      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] == -1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");
   }


all items use 2 or 26

non carryable (use type 2)
key
free man

carryable


rocket needs custom button 93

      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] ==  1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");



      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");



rocket are created with -1 carry??? is this needed??
no, set to 1 by default.. when lit if 0 or 1 they get changed to -1 carry
unless -2 then they stay -2...

need to glt and set all -1 to 1...done




go through all levels

see if cloners need boxes.. up to 100
fix flappers..up to 100


make a level with a huge cannon, like a boss level....done 330

make a level to test if you can chain throwing sproingies..done 331
hell you can do it with a single sproingy
just let go before the top of the jump while holding down so it doesnt get thrown up by inheriting players yinc
then fall on it again while holding fire and jump

reset vls end level before release..not sure what this is...
visual_level_select...to make the extra levels not shown...


20220305

I am back after a few years absense....

Figured out the new dev environment, for windows anyway, linux later


I will put some useful info in the HOWTO dir...I guess I can out everything except the github password with the project...


make level editor use display_transform_double = 2; in 4K done..looks better


make demo mode take 30s instead of 10
don't do demo mode if paused in a level
done



why does cloner show both shapes...fixed

smooth cloner animation sequence 7 steps
did a lot of cleaning up an refactoring cloner trigger stuff and mode stuff,
removed the mode controlling the red green flashes when cloning
now mode is only for telling if in trigger box last frame

what happened to:
sticky bombs?
remote bombs?
the new way of showing circular bomb damage?


they are not there in the official 7.05 release

but they are in the one from sources....

ladders, ropes?

I would like to add for rockets, a line to show where they will go and what blocks they will destroy..done
make the rocket line thing more accurate by moving exactly like real rocket does..done


lets start making some cool levels...
start at level 300


document the dev setup again, especially libnet
done and put in project files

figure out how to do github and add to docs in project...done
password and token saved in truecrypt vault like all my other passwords

document how to edit tileset with gimp and add to docs...done

made 2 new shapes for cloner and made new ans 107 with 9 shapes
added to code and it looks good



where is that randomizing thing I used for groups of enemies?
is it part of glt?? no it is in zoom full screen
press r and selection will be randomized
added to docs



what does start index do?

if multiple starts with multiple start indexes and multiple player start

they get different starts



what if I made an option that cloners could be invincible?
and then I would not have to protect them with layers of blocks
looking for an open variable...cloner is really busy
how about Ei[][30] deathloop count...i mean he should never die right??

ok lets do it

cloners now have the option to be invincible!!


document how to view netgame stats in game...done

make rocket guideline not blink like explosion...
if rocket is going slow enough the guide lines do not show...fixed




how about showing when a object is about to expire
a very small number that shows how many seconds left
if (item[i][14]) al_draw_textf(f3, palette_color[15], x+10, y-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (item[i][14] - 10) / 40);

done...it was one line

now do the same for enemies ..done

if (Ei[e][27]) al_draw_textf(f3, palette_color[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);












the linux version has screen problems too
when going into fullscreen mode, it is the same size as the window before


where is this in code??

-------------------------------------------------------------
z_control.cpp -- function:function_key_check() -- line 500
-------------------------------------------------------------
if (fullscreen) proc_screen_change(  disp_w_wind,    disp_h_wind, disp_x_wind, disp_y_wind, 0);
else            proc_screen_change(desktop_width, desktop_height,           0,           0, 1);


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 980
-------------------------------------------------------------
if (!fullscreen) // detect if window was moved
{
   int x, y;
   al_get_window_position(display, &x, &y);
   if ((x != disp_x_curr) || (y != disp_y_curr))
   proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
}


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 999
-------------------------------------------------------------
if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
{
   // check to see if we have more resize events piling up
   ALLEGRO_EVENT ev2;
   while (al_get_next_event(event_queue, &ev2))
   {
      if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
      else ret = proc_events(ev2, ret);
   }
   proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
}

-------------------------------------------------------------
z_screen.cpp -- function:proc_screen_change() -- lien 300 999
-------------------------------------------------------------

void proc_screen_change(int new_sw, int new_sh, int new_sx, int new_sy, int new_fs)




This is on windows and works just fine

changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn


This is linux:

Display change
x:1688 y: 842 w: 693 h: 450 fs:0  old
x:1689 y: 868 w: 693 h: 450 fs:0  new   <-------[why does it do this change? +1x +26y]



Display change
x:1689 y: 868 w: 693 h: 450 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1689 y: 868 w: 693 h: 450 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn      <--------- all good to here

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:   0 y:   0 w:3840 h:2160 fs:1  new   <-------[why does it do this change? no change]

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1689 y: 868 w: 693 h: 450 fs:0  new
changing away from fullscreen
x:1689 y: 868 w: 693 h: 450 disp_
x:1689 y: 868 w: 693 h: 450 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1689 y: 868 w:3840 h:2160 - curr         <---------right here wtf changed it
x:1689 y: 868 w: 693 h: 450 - wind
x:1690 y: 894 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:1689 y: 868 w:3840 h:2160 fs:0  old  <-------[why does it do this change? +1x +26y]
x:1690 y: 894 w:3840 h:2160 fs:0  new




win

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1094 y: 184 w:1644 h:1482 - disp
0:   0 0:   0 w: 822 h: 741 - scrn


lin

--------detected move or resize
x:1093 y: 158 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - disp

Display change
x:1093 y: 158 w:1644 h:1482 fs:0  old
x:1094 y: 184 w:1644 h:1482 fs:0  new <-------[why does it do this change? +1x +26y]

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:  37 y:  26 w:3840 h:2160 - curr  <-------[why does it do this change? +37x +26y]
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:  37 y:  26 w:3840 h:2160 fs:1  new


--------detected move or resize <------------x 60
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1095 y: 210 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:1094 y: 184 w:3840 h:2160 - curr
x:1095 y: 210 w:3840 h:2160 - disp

Display change
x:1094 y: 184 w:3840 h:2160 fs:0  old
x:1095 y: 210 w:3840 h:2160 fs:0  new
^[


i dont get it....is lin moving my window???

can I just force it to be what I want??
keep my own variables for screen x, y, w h??

never overwrite them by reading them...
just compare them to actual..

what do I have now?

extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // either wind in windowed mode or full fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

im going to add:

extern int disp_x_full; // fullscreen (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;




what if I change my code so that all the screen change stuff just changes variables
then once per cycle, if the variables don't match the actual, then process the changes


I have a conflict...

I changed

I have a function that checks if the window has moved by comparing actual to what is stored in curr
if it is different the function assumes that the user moved the window and updates curr

I also have a function that check if the size and position are different from what is in curr and assumes the system fucked it up
and restores it

these are at odds with each other...


what are the things that can change display?
F12
resize event
move detection...





I was having strange issues with fullscreen to windowed and then I discovered it matter the order of:

   al_resize_display(display, disp_w_curr, disp_h_curr);
   al_set_display_flag(display, ALLEGRO_FULLSCREEN_WINDOW, fullscreen);
   al_set_window_position(display, disp_x_curr, disp_y_curr); // make sure to set position last!!!



now in lin I get this weird ness





Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

resize final
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 843 y: 236 w:3840 h:2160
wind - x: 843 y: 236 w:3840 h:2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

We got a window resize event while in fullscreen...this is unexpected
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x: 843 y: 236 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

move
disp - x: 843 y: 236 w:3840 h:2160









omfg I think it is almost 100% working.....in linux too

same as win....


how about the only time I care about window position is when entering full screen mode or exiting the program
other than that I don't care about constantly monitoring it
seems to work good


resize event in linux seem to alway return x=1 y=26...why????

ignore x and y....not as nice in windows...

maybe the problem is the number of resize events I am getting...show them...

maybe the problem I have is that I should not be setting the display x, y, w, h

just read them....


the only time I want to set them is coming back from fullscreen to windowed...

that was is...it was all so simple...i spent days trying to figure that out....


clean up...

old code from control to stop pile up of events....not needed



if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) show_event(ev);
void show_event(ALLEGRO_EVENT e)
{
   int x = e.display.x;
   int y = e.display.y;
   int w = e.display.width;
   int h = e.display.height;

   printf("\nEV-raw-resize event---  x:%d y:%d w:%d h:%d\n", x, y, w, h);
}


            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_display_change();
            }
            else ret = proc_events(ev, ret);


new code
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) proc_display_change();


20220311
I can now truly say that is done and cleaned up and works great
it is a lot simpler code too.....

checked in

now I want to figure out what is causing the freeze on exit.....

in linux version exiting the game freezes the terminal
CTRL-ALT-END if game has focus or CTRL-C in terminal it spawns

look like I am not shutting down things individually...
I am just calling al_uninstall_system();

put some logging code around it, then try adding all individual ones...


al_destroy_display(*display);

in what order are they created?

first

al_init();

al_create_event_queue();


display = al_create_display(disp_w_wind, disp_h_wind);//

al_register_event_source(event_queue, al_get_display_event_source(display));

al_init_native_dialog_addon())


al_init_primitives_addon())
al_init_font_addon())
al_init_ttf_addon())
al_install_keyboard())
al_register_event_source(event_queue, al_get_keyboard_event_source());
al_install_mouse())
al_register_event_source(event_queue, al_get_mouse_event_source());
al_install_joystick())
al_register_event_source(event_queue, al_get_joystick_event_source());
al_init_image_addon())
   fps_timer = al_create_timer(1/(float)frame_speed);
   sec_timer = al_create_timer(1);
   mnu_timer = al_create_timer(.01);

   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mnu_timer));

   // start timers
   al_start_timer(fps_timer);
   al_start_timer(sec_timer);
   al_start_timer(mnu_timer);

   load_sound();

how can I get a debugger working?

installed gdb

re-compiled  allegro with debug
compiled with debug info
linked with -g

ran gdb ./pm

then run

when it crashed CTRL-C then:



^[[A^[[A
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409
(gdb) where
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409





in events.c

void al_destroy_event_queue(ALLEGRO_EVENT_QUEUE *queue)
{
   printf("deq 1\n");
   ASSERT(queue);
   printf("deq 2\n");
   _al_unregister_destructor(_al_dtor_list, queue->dtor_item);
   /* Unregister any event sources registered with this queue.  */
   while (_al_vector_is_nonempty(&queue->sources)) {
      ALLEGRO_EVENT_SOURCE **slot = _al_vector_ref_back(&queue->sources);
      al_unregister_event_source(queue, *slot);
   }
   printf("deq 3\n");
   ASSERT(_al_vector_is_empty(&queue->sources));
   _al_vector_free(&queue->sources);
   printf("deq 4\n");
   ASSERT(queue->events_head == queue->events_tail);
   _al_vector_free(&queue->events);
   printf("deq 5\n");
   _al_cond_destroy(&queue->cond);
   printf("deq 6\n");
   _al_mutex_destroy(&queue->mutex);
   printf("deq 7\n");
   al_free(queue);
   printf("deq 8\n");
}


Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160
al_uninstall_audio()
al_destroy_font()
al_shutdown_ttf_addon()
al_shutdown_font_addon()
al_shutdown_image_addon()
al_shutdown_native_dialog_addon()
al_shutdown_primitives_addon()
al_unregister_event_source(event_queue, al_get_keyboard_event_source())
al_uninstall_keyboard()
al_unregister_event_source(event_queue, al_get_mouse_event_source())
al_uninstall_mouse()
al_unregister_event_source(event_queue, al_get_joystick_event_source())
al_uninstall_joystick()
al_unregister_event_source(event_queue, al_get_timer_event_source(mnu_timer));
al_unregister_event_source(event_queue, al_get_display_event_source(display))
al_destroy_display()
al_destroy_event_queue(event_queue)
deq 1
deq 2
deq 3
deq 4
deq 5
deq 6
deq 7
deq 8

Before al_uninstall_system()
deq 1
deq 2
deq 3
deq 4
deq 5


now find:

_al_cond_destroy(&queue->cond);

I got lost here...


level where you fall all the time...the bottom of the screen is just doors that teleport you to the top
then some semi-solid vertical screens that cannons shoot at you through
and a rare rocket that you can ride through them....done

when player is riding a rocket they can pass through semi solid left and right....not so much a bug as a feature......!


------------------------------------------
new bug
------------------------------------------
when player is in key block range being removed weird things happen
it only happens when the key is in the middle of the block range
and the distance from key to center of block range = 0

But it always gets fixes when player leaves block range??

i think what matters is that the player is still touching the key, not in block range...test this
i think it is...also blocks don't get destroyed
the problem was that even though the key was moving, the player was still triggering a collision with it
fixed

show OS type on startup

save window x, y when exiting (only saves when resized or switching fullscreen)...done



I think I have all the debugging enabled:

Allegro:
-DCMAKE_BUILD_TYPE = {Debug | Release | RelWithDebInfo}
I used Debug

remade the library...
make
sudo make install

In the game:
compiler options: -Wall -g
link with -lallegro_monolith_debug

I ran gdb again and bt and where did not show anything new

I ran 'info threads' and 'thread apply all bt'

I got a lot more output, but nothing I can make sense of:


$ gdb ./pm
GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./pm...
(gdb) run
Starting program: /home/m/Desktop/pm_client22/pm
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff4ca7700 (LWP 728683)]

Purple Martians Version 7.10
Allegro Version: 5.2.8.0
[Detaching after vfork from child process 728684]
System ID: Xglx
Desktop Resolution: 3840x2160
[New Thread 0x7fffebe03700 (LWP 728688)]
[New Thread 0x7fffe3fff700 (LWP 728689)]
[New Thread 0x7fffeb602700 (LWP 728690)]
[New Thread 0x7fffeae01700 (LWP 728691)]
[New Thread 0x7fffe9d42700 (LWP 728692)]
[New Thread 0x7fffe9541700 (LWP 728693)]
[New Thread 0x7fffe8b96700 (LWP 728694)]
[New Thread 0x7fffe37fe700 (LWP 728695)]
[New Thread 0x7fffe2f67700 (LWP 728696)]
[New Thread 0x7fffe2766700 (LWP 728697)]
[New Thread 0x7fffe1f65700 (LWP 728698)]
[New Thread 0x7fffe1764700 (LWP 728699)]
deq 1
deq 2
deq 3
deq 4
deq 5
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) where
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep ()
   from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep () from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) thread apply all bt

Thread 14 (Thread 0x7fffe1764700 (LWP 728699) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x7fffa4000be0, mutex=0x7fffa4000bb0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e22c4f in al_wait_for_event (queue=0x7fffa4000b60, ret_event=0x7fffe1763820) at /home/m/Desktop/allegro5/src/events.c:435
#3  0x00007ffff7f396b0 in _al_kcm_feed_stream (self=0x555563568700, vstream=0x5555639d0900) at /home/m/Desktop/allegro5/addons/audio/kcm_stream.c:697
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x555563568700, _outer=0x555563568700) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x555563568700) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 13 (Thread 0x7fffe1f65700 (LWP 728698) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff744eda8 in pa_threaded_mainloop_wait () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7470a78 in pa_simple_write () at /lib/x86_64-linux-gnu/libpulse-simple.so.0
#3  0x00007ffff7f3d5c9 in pulseaudio_update (self=0x55556387d1d0, data=0x55556388dfd0) at /home/m/Desktop/allegro5/addons/audio/pulseaudio.c:212
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x55556387d1d0, _outer=0x55556387d1d0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x55556387d1d0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 12 (Thread 0x7fffe2766700 (LWP 728697) "threaded-ml"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff744e632 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7440079 in pa_mainloop_poll () at /lib/x86_64-linux-gnu/libpulse.so.0
#3  0x00007ffff74406ff in pa_mainloop_iterate () at /lib/x86_64-linux-gnu/libpulse.so.0
#4  0x00007ffff74407b0 in pa_mainloop_run () at /lib/x86_64-linux-gnu/libpulse.so.0
#5  0x00007ffff744e709 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#6  0x00007ffff625be08 in  () at /usr/lib/x86_64-linux-gnu/pulseaudio/libpulsecommon-14.2.so
#7  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#8  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 11 (Thread 0x7fffe2f67700 (LWP 728696) "pm"):
#0  0x00007ffff7b22c61 in clock_nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7b28443 in nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#2  0x00007ffff7ed3e79 in _al_unix_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/unix/utime.c:68
#3  0x00007ffff7e33803 in al_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/system.c:520
#4  0x00007ffff7e34c37 in timer_thread_proc (self=0x5555635fbea0, unused=0x0) at /home/m/Desktop/allegro5/src/timernu.c:94
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635fbea0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 10 (Thread 0x7fffe37fe700 (LWP 728695) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed2d8f in fd_watch_thread_func (self=0x7ffff7fa9d80 <fd_watch_thread>, unused=0x0) at /home/m/Desktop/allegro5/src/unix/ufdwatch.c:89
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x7ffff7fa9d80 <fd_watch_thread>) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 9 (Thread 0x7fffe8b96700 (LWP 728694) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e3492e in al_wait_cond (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/src/threads.c:380
#3  0x00007ffff7ee8c8d in hotplug_proc (thread=0x5555635709e0, data=0x0) at /home/m/Desktop/allegro5/src/linux/ljoynu.c:658
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x5555635709e0, _outer=0x5555635709e0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635709e0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 8 (Thread 0x7fffe9541700 (LWP 728693) "gdbus"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee40b in g_main_loop_run () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff5cdfa36 in  () at /lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 7 (Thread 0x7fffe9d42700 (LWP 728692) "gmain"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee1cf in g_main_context_iteration () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff65ee221 in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 6 (Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
--Type <RET> for more, q to quit, c to continue without paging--c
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 5 (Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 4 (Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 3 (Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 2 (Thread 0x7ffff4ca7700 (LWP 728683) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed9b9a in _al_xwin_background_thread (self=0x5555632e13f8, arg=0x5555632e1390) at /home/m/Desktop/allegro5/src/x/xevents.c:243
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555632e13f8) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 1 (Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"):
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60) at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0) at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8) at /home/m/Desktop/pm_client22/src/z_main.cpp:1421




what about files: there are 4 things: pm:disk$0 to 3
do I leave any file pointers open?
config uses allegro built in functions to access...they all look good

log?
        filepntr = fopen(filename,"w");
         fprintf(filepntr, "%s", log_msg);
         fclose(filepntr);
         printf("%s saved \n", filename);

others, help, pde, sprit...all look good



there is also pulseaudio and kcm_stream...what the hell are those???


I rebuilt allegro from git source and redid the make file
only chose Debug and Want Monolith

same crap...


what about a simpler program...like display test....


exits fine....

do I keep adding things and see if I can make it die?
or should I work with pm and remove things??

removed sound and it works!!

why do I not have sound stuff in my cleanup...i do..there is nothing for acodec addon..

most likely I am not destroying the xm stream....

         pm_theme_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
         if (pm_theme_stream == NULL) m_err("Error loading snd/pm.xm\n");

         al_set_audio_stream_playmode(pm_theme_stream, ALLEGRO_PLAYMODE_LOOP);
         al_set_audio_stream_playing(pm_theme_stream, 0);
         al_attach_audio_stream_to_mixer(pm_theme_stream, st_mixer);

         void al_destroy_audio_stream(ALLEGRO_AUDIO_STREAM *stream)

that was the solution...one simple line added to final wrapup
done 20220311



---------------------------------------
bug
------------------------------------------

When you pause and resume a single player game
sometimes it quits to the menu after a while....yes, i can reproduce it
play level for 5 sec the quit to menu, the resume
timer has reset to zero, player has left the game message appears right away
then 5 seconds in the game quits back to menu

where?


zcontrol at the end...

     for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active) // cycle all active players
            {
               if (players[p].control_method == 0) // local single player control
               {
                  if (level_done_trig) add_game_move(frame_num, 6, 0, 0); // insert level done into game move
                  set_comp_move_from_player_key_check(p); // but don't set controls !!!
                  if (players1[p].comp_move != players1[p].old_comp_move)
                  {
                     players1[p].old_comp_move = players1[p].comp_move;
                     add_game_move(frame_num, 5, p, players1[p].comp_move);
                  }
               }
               if (players[p].control_method == 1) rungame_key_check(p, ret); // run game from file
               if (players[p].control_method == 3) server_local_control(p);
               if (players[p].control_method == 4) client_local_control(p);
               set_controls_from_game_move(p); // common for all players
            }   // end of active player iterate
         proc_game_move();  // run once per frame to process system messages from game_move







in saved game...

passcount is reset and player inactive is entered

figured it out...done

the code is rather complex....


---------------------------------------
fixed the code so it compiles without any dumb string errors
---------------------------------------

-----------------------------
bug --  warning in linux about
-------------------------------
||=== Build: ldm in pm (compiler: GNU GCC Compiler) ===|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp||In function void new_bmsg(const char*, int, int, int):|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp|519|warning: sprintf argument 3 overlaps destination object b_msg [-Wrestrict]|
/home/m/Desktop/pm_client22/src/pm.h|173|note: destination object referenced by restrict-qualified argument 1 was declared here|
||=== Build finished: 0 error(s), 1 warning(s) (0 minute(s), 0 second(s)) ===|


      // slide_bmsg
      for (int c=39; c>0; c--)
         sprintf(b_msg[c], "%s", b_msg[c-1]);


first of all, why don't I see bmsg? 2 different types probaly took out to make faster
this is the fix...
      // slide_bmsg
      for (int c=39; c>0; c--)
         strcpy(b_msg[c], b_msg[c-1]);

done


-------------------
bug something screwy when exiting game in fullscreen mode on linux
when you come back, you come back with fullscreen, but windowed size???
-------------------------------

cleaned up init_display
forced w and h for fullscreen
did ack_resize after
seems to be fixed now...


I have a bit of a tricky math problem and I was wondering if anyone could provide insight.

Its about trigonometry and systems of equations.

This is all in 2D.

It is trivial to have an enemy shoot a bullet at the player. Simple trig.

But I want to have an enemy shoot a bullet, not at where the player is, but where they will be.
(assuming the player does not change velocity or direction)


My inputs are:
the player's position: px, py
the player's movement: pxinc, pyinc

the origin of the bullet: bx, by
the speed of the bullet: bspeed

What I want for an output is the angle of the bullet to ensure a collision
(or bxinc, byinc which I could calculate from angle)

Every method I can think of involves brute force, iterating through angles until I find a solution

There must be an more elegant solution.

I am trying to think of it as where two lines intersect...
But each line has a different velocity, so the line length are related to time...and speed?

Can any of you smart people help point me in the right direction?



You need to find out at what time(t) will they collide.

Basic position function: S(t) = S(0) + v(t) * t + 1/2 * a(t) * t^2

S(0) = starting position
v(t) = velocity at time t (constant in your case)
a(t) = acceleration at time t (zero if velocity is constant)
t = time

S(t) = S(0) + v(t)t

Can be broken into x,y components:
Sx(t) = Sx(0) + v(t)t
Sy(t) = Sy(0) + v(t)t

What are the player's and bullet's positions?

Player:
Px(t) = px + pxinc * t
Py(t) = py + pyinc * t

Bullet:
Bx(t) = bx + bxinc * t
By(t) = by + byinc * t

this creates a triangle
613141

You can either use x or y

Px(t) = Bx(t) or Py(t) = By(t)

px + pxinc*t = bx + bxinc*t
px - bx = pxinc*t + bxinc*t
px - bx = t(pxinc - bxinc)
t = (px - bx)/(pxinc - bxinc)

You can use original formula to then solve for x and y of final position:
x(t) = px + pxinc*t = bx + bxinc*t
y(t) = py + pyinc*t = by + byinc*t

float findPosition(float &x, float &y,
                  float px, float py, float pxinc, float pyinc,
                  float bx, float by, float bxinc, float byinc)
{
    float t = (px - bx)/(pxinc - bxinc);


    x = px + pxinc * t;
    y = py + pyinc * t;

    return t;
}

It's a mess. Hopefully I didn't miss anything.

Thank you for that. I am working on implementing it.
Time was the key. At what time will they collide?

UPDATE

Unfortunately I was unable to make your method work.

All I have for b is initial position and speed.
I do not have bxinc or byinc or the angle.
That is what I am trying to find.

The way I figured out how to do it was:

iterate on frame (time period) in a loop

for each frame find
- where we guess the player will be
- the distance from that position to the bullet origin
- find out how far the bullet could travel in the same amount of time

When those distances are equal (or close) that is where the will collide.
From the frame number that occurred at, I get the players position
That is where I shoot the bullet.
#SelectExpand
  1void fire_enemy_bulletb(int EN, int bullet_ans, int p)
  2{
  3   al_fixed bx = Efi[EN][0];
  4   al_fixed by = Efi[EN][1];
  5   al_fixed bspeed = Efi[EN][7];
  6
  7   al_fixed px = players[p].PX;
  8   al_fixed py = players[p].PY;
  9   al_fixed pxi = players[p].xinc;
 10   al_fixed pyi = players[p].yinc;
 11
 12   for (int i=1; i<100; i++)
 13   {
 14      px+=pxi;
 15      py+=pyi;
 16
 17      // calc distance from player's new pos to bullet origin
 18      al_fixed xlen = px - bx;  // get the x distance between enemy and player
 19      al_fixed ylen = py - by;  // get the y distance between enemy and player
 20      al_fixed hy_dist = al_fixhypot(xlen, ylen);   // hypotenuse distance
 21
 22      // get distance that bullet would travel in same amount of time
 23      al_fixed bd = bspeed * i;
 24
 25      // if they are close enough pull the trigger
 26      al_fixed bdif = hy_dist-bd;
 27
 28      al_fixed ltol = al_ftofix(-5);
 29      al_fixed utol = al_ftofix(5);
 30
 31      if ((bdif < utol) && (bdif > ltol))
 32      {
 33         i = 100; // break out of loop
 34
 35         al_fixed speed = Efi[EN][7];                     // speed
 36         al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
 37
 38         al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
 39         al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc
 40
 41         for (int z=0; z<50; z++)  // find empty e_bullet
 42            if (!e_bullet_active[z])
 43            {
 44               e_bullet_active[z] = 1;
 45               e_bullet_shape[z] = 1000 + bullet_ans;
 46               e_bullet_fx[z] = Efi[EN][0];
 47               e_bullet_fy[z] = Efi[EN][1];
 48               e_bullet_fxinc[z] = xinc;
 49               e_bullet_fyinc[z] = yinc;
 50               z=50;
 51            }
 52      }
 53   }
 54}

This actually works, but I am sure there is a much better way of doing it.



The closet I can come up with a formula is:

when these two things are equal:

bullet_distance = player_distance_from_bullet_origin

bullet_distance = (bullet_speed * t)


player_distance_from_bullet_origin_x = (px + (pxinx * t) - bx)
player_distance_from_bullet_origin_y = (py + (pyinx * t) - by)

then I need to do the hypot to get actual distance












what if I use my method but seek better?

like start with 10 frames at a time until I pass the limit
then reverse direction 1 frame to pass again
then reverse again and do .1




changed player move so that when player is riding a rocket, player's xinc and yinc are the same as the rocket
they used to be set to zero.
I needed to do that so that the bullets can seek in on the player using xinc, yinc

what enemies use that function? fire_enemy_bulleta()
flapper
trakbot
podzilla
canon

wow!



put this into equation editor
https://www.hostmath.com/

bulletvelocity * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

bspeed * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

px + (pxinc*t)
py + (pyinc*t)

\sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }





UPDATE

This is the equation I have come up with:

https://www.allegro.cc/files/attachment/613142

Now the fun part!

Solve for t.

My skills are not up to the task...

20220317
I am happy with my method for now...
I want to bench mark in a level with 100 cannons and see if it slows down...
not at all...
what is I patch this in for all enemies that use it...done




I had a method where I just increased time until I found a close enough solution.
That took a lot of iterations.
And if I wanted it more accurate, I would have to step time even slower, which meant even more iterations

I found a method where I search for t in large steps.
Then when I overshoot it, I reverse direction and decrease the step size...
I keep doing this until I get close enough.
This greatly reduces the ammount of values of t I need to test.

<code>
al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;

   int tries = 0;
   int done = 0;
   while (!done)
   {
      t+=tinc;
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 100) done = 1; // break out in case something goes wrong
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);
}
<\code>

However I consider this entire approach an inlegant brute force method.

I can't help but think there is a better way of doing this.

My whole approach can be condensed to:

Find the time when the player's future position has an equal distance to the bullet origin as the time the bullet will travel in the same amount of time.

Then it is trivial to get the player's future x and y position from the time.

I came up with an equation to describe that, but I don't know if it is possible to isolate t on one side (solve for t)











bug  -- does level actually run while stimp is happening??
did I just change this recently?

when I run the screen overlay frame skip always happens during stimp

change the order of these things:

old
   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

new
   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

also this:

old
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      set_frame_nums(frame_num); // set fps_timer count to frame_num
      stimp();
      return;
   }

new
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      stimp();
      set_frame_nums(frame_num); // set fps_timer count to frame_num
      return;
   }

that seems to work better












Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.

I'm going to work on finding angle from t. My approach would be to set a time (like say a few seconds) and then find the angle necessary to hit that time.


Edgar's method works great

   float bx = Efi[EN][0];
   float by = Efi[EN][1];
   float bv = Efi[EN][7];

   float px  = players[p].PX;
   float py  = players[p].PY;
   float pvx = players[p].xinc;
   float pvy = players[p].yinc;

   float A = (pvx*pvx) + (pvy*pvy) - (bv*bv);
   float B = 2*(px*pvx) + 2*(py*pvy) -2*(bx*pvx) -2*(by*pvy);
   float C = (px*px) + (bx*bx) + (py*py) + (by*by) - 2*(bx*px) -2*(by*py);
   float t = ( -B - sqrt((B*B) - 4*(A*C)) ) / (2 * A);

   al_fixed px1 = px + al_fixmul(pvx, al_ftofix(t)); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pvy, al_ftofix(t));
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

I don't know how he came up with that equation though

his explanation starts with that














I came up with a quadratic but not quite the same as ER's. It cuts down on the maths chores if you set the origin to be where the bullet starts, and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t). Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations - now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t. There are 2 solutions usually and you have to take the bigger (I don't know why or what the other one means!)

When you have t then work out dx = x + pxinc*t and dy = y + pyinc*t (displacement to where the ship will be)
then bxinc = dx/sqrt(dx*dx+dy*dy)*bspeed and byinc = dy/sqrt(dx*dx+dy*dy)*bspeed


#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>
#include <math.h>
#include <random>

#define W 800
#define H 600

static const float bullet_speed = 5.0f;

struct thing {
  float x;
  float y;
  float dx;
  float dy;
  float radius;
  ALLEGRO_COLOR color;
  float speed;
  bool active;
  thing(ALLEGRO_COLOR c, float r, float s)
      : color(c), radius(r), speed(s), active(true) {}
  void move() {
    if (active) {
      x += dx;
      y += dy;
      while (x < 0.0f)
        x += float(W);
      while (x >= float(W))
        x -= float(W);
      while (y < 0.0f)
        y += float(H);
      while (y >= float(H))
        y -= float(H);
    }
  }
  void draw() {
    if (active)
      al_draw_circle(x, y, radius, color, 1.0f);
  }
  void setup() {
    static std::minstd_rand engine;
    double theta;
    x = std::uniform_real_distribution<float>(0.0f, float(W))(engine);
    y = std::uniform_real_distribution<float>(0.0f, float(H))(engine);
    theta = std::uniform_real_distribution<>(-1.0, 1.0)(engine);
    switch (std::uniform_int_distribution<>(0, 3)(engine)) {
    case 0: // top
      theta += M_PI / 2.0;
      y = 20.0f;
      break;
    case 1: // right
      theta += M_PI;
      x = float(W - 20);
      break;
    case 2: // bottom
      theta -= M_PI / 2.0;
      y = float(H - 20);
      break;
    case 3:  // left
    default: // can't happen
      x = 20.0f;
      break;
    }
    dx = float(cos(theta)) * speed;
    dy = float(sin(theta)) * speed;
    active = true;
  }
};

thing fire(const thing &from, const thing &to) {
  float x = to.x - from.x;
  float y = to.y - from.y;
  float r2 = x * x + y * y;

  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  float A = to.dx * to.dx + to.dy * to.dy - bullet_speed * bullet_speed;
  float B = x * to.dx + y * to.dy;
  float rt = B * B - A * r2;
  if (rt >= 0.0f) {
    float t1 = (sqrt(rt) - B) / A;
    float t2 = (-sqrt(rt) - B) / A;
    float t = std::max(t1, t2);
    float vx = x + to.dx * t;
    float vy = y + to.dy * t;
    float v = sqrt(vx * vx + vy * vy) / bullet_speed;
    bullet.dx = vx / v;
    bullet.dy = vy / v;
    bullet.x = from.x;
    bullet.y = from.y;
  } else {
    // Bullet can't reach the target
    bullet.active = false;
  }
  return bullet;
}
bool collide(const thing &a, const thing &b) {
  float r2 = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
  return r2 < a.radius + b.radius;
}

int main(int, char *[]) {
  al_init();
  al_init_primitives_addon();
  ALLEGRO_DISPLAY *display = al_create_display(W, H);
  ALLEGRO_TIMER *timer = al_create_timer(1.0 / 30.0);
  ALLEGRO_EVENT_QUEUE *queue = al_create_event_queue();
  al_register_event_source(queue, al_get_display_event_source(display));
  al_register_event_source(queue, al_get_timer_event_source(timer));
  bool running = true;
  bool advance = true;
  thing ship(al_map_rgb(255, 128, 128), 10.0f, 1.0f);
  thing ufo(al_map_rgb(128, 255, 128), 10.0f, 2.0f);
  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  ship.setup();
  ufo.setup();
  bullet.active = false;
  al_start_timer(timer);
  while (running) {
    ALLEGRO_EVENT event;
    al_wait_for_event(queue, nullptr);
    while (al_get_next_event(queue, &event)) {
      if (event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
        running = false;
      } else if (event.type == ALLEGRO_EVENT_TIMER) {
        advance = true;
      }
      if (advance) {
        al_clear_to_color(al_map_rgb(0, 0, 0));
        ufo.draw();
        bullet.draw();
        ship.draw();
        al_flip_display();
        ufo.move();
        bullet.move();
        ship.move();
        if (!bullet.active) {
          bullet = fire(ufo, ship);
        } else {
          if (collide(bullet, ship)) {
            ship.active = bullet.active = false;
          }
        }
        if (!ship.active)
          ship.setup();
      }
    }
  }
  return 0;
}




I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.



bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

what???

square LHS of 1...(bxinc*t)^2 is that the same same bxinc^2*t^2...yes

try it out
3^2 * 4^2 = 9 * 16 = 144
(3*4)^2 = 12^2 = 144
yes....i'm good with that...so now I am at


(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2


And I need to expand that...


This method works too...


Clean up how it was derived:

From Peter Hull

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.

(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2














The better solution

After asking for help on the allegro.cc forums I was shown a much better method.

Edgar Reynaldo showed me a quadratic equation to solve for t.

Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.



Peter Hull showed me a similar method with slightly simpler math.

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.




(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2

I tried to covert this to fixed but A B and C are huge:

A:-85899345920.000000
B:1909319532544.000000
C:97443614031872.000000

they totally overflow fixed...so I guess I am stuck with float for now

I am removing all the old code and pasting it here:



al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulletaa(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed initial_distance = al_fixhypot((px-bx), (py-by));    // initial distance
   printf("\ninitial distance:%f\n", al_fixtof(initial_distance));

   al_fixed t = al_fixdiv(initial_distance, bspeed);         // start time


   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   //al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;


   int tries = 0;
   int done = 0;
   while (!done)
   {

      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      // if (( bdif < al_ftofix(.0001)) && (bdif > al_ftofix(-.0001))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 50) done = 1; // break out in case something goes wrong
      t+=tinc;
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

   printf("number of tries:%d\n", tries);

// show where the target position is
   tx1 = al_fixtoi(px1);
   ty1 = al_fixtoi(py1);
   ttc1 = 15;
   //ttfloat1 = al_fixtof(bdif);
   ttfloat1 = (float) tries;


}


/*
void fire_enemy_bulletabf(int EN, int bullet_ans, int p) // the original method of stepping time
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed t = al_itofix(0);     // start time
   al_fixed tinc = al_itofix(1);  // time step
   al_fixed bdif = al_itofix(0);

   for (t=al_itofix(0); t < al_itofix(1000); t+=tinc)
   {
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(5)) && (bdif > al_itofix(-5))) // is the difference with the threshold?
      {
         al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
         al_fixed py1 = py + al_fixmul(pyi, t);

         fire_enemy_bulletz(EN, bullet_ans, px1, py1);

         t = al_itofix(1000); // break out of loop
      }
   }
}


void old_fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed xlen = players[p].PX - Efi[EN][0];   // get the x distance between enemy and player
   al_fixed ylen = players[p].PY - Efi[EN][1];   // get the y distance between enemy and player
   al_fixed hy_dist =  al_fixhypot(xlen, ylen);     // hypotenuse distance
   al_fixed speed = Efi[EN][7];                  // speed
   al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
   al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
   al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc

   for (int z=0; z<50; z++)  // find empty e_bullet
      if (!e_bullet_active[z])
      {
         e_bullet_active[z] = 1;
         e_bullet_shape[z] = 1000 + bullet_ans;
         e_bullet_fx[z] = Efi[EN][0];
         e_bullet_fy[z] = Efi[EN][1];
         e_bullet_fxinc[z] = xinc;
         e_bullet_fyinc[z] = yinc;
         z=50;
      }
}



------------------------------------------------------
figure out how to do a windows release

run the batch file...

that seemed to work

published a new release 7.1.1-win on github


make my doc pages point at main page






BUG--------------------------------------------------------------------

level 62 jumping from top of ladder warps through solid block to the left???

test on level 329
immediately above ladder have a semi solid block
jump off the ladder while holding up

When player is climbing ladder they are blocked by semi-solid above
If they then jump everything works fine.
But if they hold [UP] and jump they try to grab ladder again and trigger
code that happens only when player is first grabbing ladder


I think its because ladder up moves don't recognize semi-solid because they use the new is_solid_fm type.
There is code about when a player get on a ladder initially that checks to see if the player is embedded in a wall.
This is getting triggered by the semi solid and pushing the player left until they are free.

show ladders that could be grabbed

on ladder, up pressed, jump pressed



trace what happens the instant jump is pressed while on ladder

move player() calls
proc_player_ladder() which calls
proc_player_ladder_move()

where this happens:


   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
      return;
   }


what the hell is this line?

if (players[p].up) players[p].PY += al_ftofix(2.6);

if up then move the player down??

this is how I fixed it:
   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      players[p].yinc = al_ftofix(-6.6); // initial_jump_velocity;
      players[p].PY += players[p].yinc;  // make the first move here
      return;
   }

fixed the bug...as long as it doesn't cause any unforseen complictaions it is fixed


increase archwagon bullet prox upper limit from 600 to 2000...done...



-----------------------------------------------
Bug
----------------------------------------------------
small letters to show how much health you lost on player, -20 shows as -2
only for mines...how do they work again?

void proc_mine_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(item[i][8]) / 10;
   game_event(50, 0, 0, p, i, 0, item[i][8]);
}

with enemies they have a hold off before they can damage the player again

         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount


should I change mines to be like enemies? with a hold off?

leave it...not really a bug



show all pop-messages at once to assist with aligning in level editor....done





when duplicate bmsgs occur, edit the last one and add x2 x3 etc to it....

not that simple

// make new structure to hold all of the data
I could keep it forever like a log file

only show the last 20 or so as bmsg
and consolidate like types

which ones repeat??

mines
exit when not allowed



right now all the variable that are used are:

char b_msg[40][80];
int bottom_msg=0;


I propose a simple solution of an array of structs



extern struct bmsg bmsgs[100];

struct bmsg
{
   char txt[80];
   int ev
   int frame
   int p1
   int p2
};


there are bitmaps that go with each one too???

ALLEGRO_BITMAP *bmsg_bmp[20] = {NULL};
ALLEGRO_BITMAP *bmsg_bmp2[20] = {NULL};
int bmsg_index = 0;

what is index used for??
so that I don't have to redraw all the text bitmaps
I just use a circular index

this looks way to hard...I just want to cut down on a lot of duplicates

if I stored just ev and player....


I should make a function that build the bmsg bitmap
instead of going back and replacing text with coloured text, do it the first time.

what would the function look like?

it would go somewhere between event and where event calls add_bmgs

why don't I just make event pass everything to add_bmg and do it there?

done...

next... draw uncentered while building colored line then center it after...

make a temp bitmap for that...
400x8

now I need to keep track of how wide the bitmap is so I can center it


keep the text in bmsg for now, if for no other reason than to compare for doubles

do all the real drawing in second part...









player collison with enemy
Ei[e][22] = p+1;

player collison with bullet:
only has e_type

   int e_type = 0;
   switch (e_bullet_shape[b])
   {
      case 488:   e_type = 3;  damage = 5;  break; // arrow
      case 489:   e_type = 3;  damage = 5;  break; // arrow
      case 1055:  e_type = 6;  damage = 7;  break; // cannon ball
      case 1020:  e_type = 8;  damage = 9;  break; // yellow things
      case 1054:  e_type = 7;  damage = 10; break; // green ball
      case 1062:  e_type = 12; damage = 8;  break; // flapper thing
   }

   game_event(43, 0, 0, p, e_type, 0, damage);

so in bmsg I will ne tp convert e number to etype for enemy collisions..



I'm getting a lot of these done, but I want to get rid of the whole text thing..


the only thing I have it for now is to see if I have duplicates

I want to make an array of 100 events

game_event_array[100][8]

0 - frame
1 - ev
2 - x
3 - y
4 - z1
5 - z2
6 - z3
7 - z4

whenever I get an event:

only for certain types that retrigger a lot
- like mines
- like exits

I check to see if there are any others exactly the same in the last 40 frames (1 second)
if there are, I toss it and modifiy the last

or i could only do it for a problematic few that keep retriggering

game_event_retrigger_holdoff[10][1]

when I get an exit event stick the retrigger time in this array

I have removed all traced of the old text bmsg...except for the char arrays


now all that is left is to devise the retrigger block method to prevent duplicates

game_event_retrigger_holdoff[10][1]

   if (ev == 3) // exit
   {
      if (game_event_retrigger_holdoff[1] < frame_num)  game_event_retrigger_holdoff[1] = frame_num + 60;
      else ev = 0;
   }

   if (ev == 50) // mine
   {
      if (game_event_retrigger_holdoff[2] < frame_num)  game_event_retrigger_holdoff[2] = frame_num + 20;
      else ev = 0;
   }

done...

this all looks good... I need to test all the messages

tested all but squished and stuck


make some nice looking icons that work in 8x8...maybe


maybe I could document this fully and try to encapsulate the vaiarble and function so they are not global
- at many place in the code game_event() is called
- then after that it is all handled by a few function


add some more messages, like:

player joins and quits...done

heath bonus pickups





make an array of bitmaps loaded from disk called

bmsg_icon[64]

that has 64 8x8 tiles used for drawing on bmsgs

figure out which ones I need

make a custom function to scale and save them

then edit by hand to make them look nice

once exported and touched up, never overwite them!!


step 1, collect all the shapes I will possible need


leave out player...looks good enough when just normal 20->8 with shape 1

all enemies(8)
free man
all bonus fruit, flower and diamond

exit and exit with lock

mine

rocket
bomb
bomb with det
bomb with no det
det

4 switch
4 key

done...


now get good starting values



wait....this whole thing is fucky...

when I draw scaled 20 to 8 to display it looks perfect

when I draw 20 to8 to a bitmap then to screen, it looks really bad

?????? !!!!! ??????

what if i do the whole bmg line 20 pixels high, then shrink it only when final drawing it???


What will I do about text?? double it to 16 high and leave a 2 pixel buffer above and below...



increased size of:

bmsg_bmp[x] = al_create_bitmap(800, 20); from 400, 8


made it work with bmg lines that are 20 pixels high and look great

what a lot of wasted time with shrinking 20x20 tiles to 8x8 tiles
they look really bad when another bitmap is the destination, but great when the display is...why?

It looks really good now...and its a lot simpler

still to do...
show mine..
show free man
show health bonus
done

now with much nicer (and simpler) bmsg

that was a couple of days spent working on bmsg...



why don't I practice cleaning up the sources a bit by making
game_event its own source file and header
only source files that call functions from it will need to include it
create z_gameevent.cpp and game_

gave up and reverted... there is a huge tangled mess of intertwined dependencies...
I would still like to do this...but its a huge task......

I wish I could start small, like with something like sound



get a spring sound from zapsplat

https://www.zapsplat.com/
make a free account...
mweiss001
mweiss001@gmail.com zaiden

upgraded to gold for 4GBP recurring monthly but i'll just cancel
now I don't have to give credits...





should you grab ropes by default?
only drop if you press down?
it seems really hard to stay on them....

changed ropes to grab automatically, you don't need to press up

anytime you are within reach of a rope you will automatically grab it

this caused issues about not being able to press down to fall off a rope
you would just grab it again immediately

added code to where pressing down made you fall off rope to add 4 to PY so he would actually fall

maybe I should make it only if you are falling that you automatically grab rope
and any other time you need to press up...done
I like how this works!!!

change order of w and h in zfs...done

co-located doors bug
I tried to make a linked chain of doors, one exit landing right on another entrance,
but I could never enter the second door...fixed

old:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {
      players[p].marked_door = i;

      if (item[i][8]) // do nothing if exit only
      {
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door


new:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {

      if (item[i][8]) // do nothing if exit only
      {
         players[p].marked_door = i;
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door





fixed a bug in this function...
when displaying percentages near zero it did not look perfect
the white frame was overwriting the start...

old: al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
new: al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
all that for one pixel!

void draw_percent_bar(int cx, int y, int width, int height, int percent)
{
   int x = cx - width/2; // get x from center
   al_draw_filled_rectangle(x+0.5f, y+0.5f, x + width+0.5f, y + height+0.5f, palette_color[10]); //  all red to start
   if (percent > 0)
   {
      int w2 = (int) (width * ((float)percent/100)); // how much green
      al_draw_filled_rectangle(x+0.5f, y+0.5f, x + w2+0.5f, y + height+0.5f, palette_color[11]); //  green
   }
// al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
   al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
}

























I could make the item 'mine' have a larger rectangular area

I could make other items like that too...like one that kills enemies...

I have wanted to do these rectangular areas for years, I just never thought to make them part of an item...

omg...I was think of making them stationary, but what if I made their position slave to another object, like a lift??!!


start by making a new item..


added one in PDE..

type 20, temp holder bitmap 889

added one to level...

added its name in menu setup:  strcpy (item_name[20],"Minefield");

incresed size of:
int item_num_of_type[20];
int item_first_num[20];
char item_name[20][40];

to

int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];


set all to 200 for testing...

item[][6] = minefield x (int) (2000)
item[][7] = minefield y (int) (2000)
item[][8] = minefield w (int) (2000)
item[][9] = minefield h (int) (2000)


make it show...

void draw_minefield(int i)
{
   float x1 = item[i][6];
   float y1 = item[i][7];
   float x2 = x1 + item[i][8];
   float y2 = y1 + item[i][9];
   rectangle_with_diagonal_lines(x1, y1, x2, y2, 10, 10, 10);
}


check collision...

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_item_collision(p, x);
      }
      if (item[x][0] == 20) // check for minefield collision
      {
         al_fixed ix1 = al_itofix(item[x][6]);
         al_fixed iy1 = al_itofix(item[x][7]);
         al_fixed ix2 = ix1 + al_itofix(item[x][8]);
         al_fixed iy2 = iy1 + al_itofix(item[x][9]);
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_minefield_collision(p, x);
      }
   }


void proc_minefield_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(1);
}

it works!!!!


make an editor so you can adjust x, y, w, y

new button in sliders:

if (bn == 84) sprintf(smsg, "Get New Minefield Rectangle");

if (bn == 84)
   if (getbox( "Minefield Range", 2, 4, num) == 1)
   {
      if (--bx2 < bx1) bx2++;
      if (--by2 < by1) by2++;
      item[num][6] = bx1*20;
      item[num][7] = by1*20;
      item[num][8] = (bx2 - bx1)*20;
      item[num][9] = (by2 - by1)*20;
      Redraw = 1;
   }

in object viewer:

case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
break;


it works!!!

now what?

it would be nice to adjust with map...
but I can easily make it work without that....

- can I kill the item? // probably won't do this... no other item supports getting killed

- hide the main icon

- make it cycle on and off?

- make it turn on when touched, turn off when touched?

- link it's position to a lift?


lets pick an int for mode...
item [][10] == mode
mode == 0 // always on

lets pick an int for damage
item [][11] == health dec (/100)

what variables does that leave me?
12 and 13 only


mode 1:
become active when touched
timer value = 13;
timer counter = 12;


mode 2:
become inactive when touched
timer value = 13;
timer counter = 12;


implement 11 health dec...

if (bn == 81) item[num][11] = (int)f;              // minefield damage

if (bn == 81) sprintf(smsg, "Damage:%d", item[num][11]);

case 81: sul=1000;  sll=0;   sinc=10; sdx=item[num][11];           break;  // minefield damage


case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
   mdw_slider(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 81, num, type, obt, 0, 12, 15, 15, 1,0,0,0); a++;  // damage
break;

void proc_minefield_collision(int p, int i)
{
   al_fixed d = al_itofix(item[i][11]) / 100;
   int id = al_fixtoi(d);

   players[p].LIFE -= d;
   game_event(50, 0, 0, p, i, 0, id);
}

done and works great!!

getting new rectangle make it one block smaller at lr corner..done

heath event of zero shows green...made it blue, but still need to address this

inc should be 1 not 10...done

implement mode 1 and 2.....


I would love to have 2 rectangles, one for the trigger and one for the damage...
however I do not have enough integers

unless I do something tricky

is item[][2] really not used by anything??

if I ignore these I could get 2 more here:
item[][14] = time to live
item[][15] = tag with cloner item id

basically if I want 2 boxes i will need 8 variables....

what if I used an enemy to make this whole thing work?
they have a lot more variables to work with...
plus, I could kill them if I wanted!!



snap decision...lets do that....

I can still keep the item version...maybe use it for simpler ones...



[10]--field-----------------------------------------------------------------------------

Ei[][0] = 10;
Ei[][1] = 476; // bitmap
Ei[][2] = 0;   // draw mode (v and h flips)

//Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)
Ei[][5]  mode

Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2

Ei[][15] = 200; field box x
Ei[][16] = 200;  field box y
Ei[][17] = 200;  field box w
Ei[][18] = 200;  field box h

Efi[][4] = 2.3;  // life dec
Efi[][12] = 1.0; // scale
Efi[][14] = 0.0; // rot

made an enemy like this in PDE...done and added to level...

add enemy to lists...done
strcpy (enemy_name[10], "Field");


add code to draw...very similar to cloner...done

if (Ei[e][0] == 10) // field
{
   // trigger box
   float tx1 = (float)Ei[e][11]*20;
   float ty1 = (float)Ei[e][12]*20;
   float tx2 = (float)Ei[e][13]*20+20;
   float ty2 = (float)Ei[e][14]*20+20;
   int tc1 = 14 + 128; // trigger box color

   // field
   float sx1 = (float)Ei[e][15];
   float sy1 = (float)Ei[e][16];
   float sx2 = sx1 + (float)Ei[e][17];
   float sy2 = sy1 + (float)Ei[e][18];
   int sc1 = 11 + 128; // field box color

   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box
   rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
}

add code to take damage....done...
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((players[p].PX > ex1) && (players[p].PX < ex2)
          && (players[p].PY > ey1) && (players[p].PY < ey2)) Ei[e][22] = p+1;
      }


      if (Ei[e][0] == 10) // check for field collision
      {
         al_fixed ix1 = al_itofix(Ei[e][15]);
         al_fixed iy1 = al_itofix(Ei[e][16]);

         al_fixed ix2 = ix1 + al_itofix(Ei[e][17]);
         al_fixed iy2 = iy1 + al_itofix(Ei[e][18]);

         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_field_collision(p, e);
      }
   }

void proc_field_collision(int p, int x)
{
   players[p].LIFE -= Efi[x][4];
   game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
}


add code to adjust boxes...hopefully its close to cloner...

if (bn == 85) sprintf(smsg, "Get New Field Rectangle");
if (bn == 86) sprintf(smsg, "Get New Field Trigger Box");

if (bn == 85)
   if (getbox("Get New Field ", 3, 10, num))
   {
      Ei[num][15] = bx1*20;
      Ei[num][16] = by1*20;
      Ei[num][17] = (bx2-bx1)*20;
      Ei[num][18] = (by2-by1)*20;
      Redraw = 1;
   }

if (bn == 86)
   if (getbox("Get New Field Trigger Box", 3, 10, num))
   {
      Ei[num][11] = bx1*20;
      Ei[num][12] = by1*20;
      Ei[num][13] = (bx2-bx1)*20;
      Ei[num][14] = (by2-by1)*20;
      Redraw = 1;
   }


perfect...now I can edit both boxes...now for map move...





if ((obt == 3) && (type == 10)) // field boxes
{
   // field trigger box coordinates
   int x1 = Ei[num][11]/20;
   int y1 = Ei[num][12]/20;
   int x2 = x1 + Ei[num][13]/20 -1;
   int y2 = y1 + Ei[num][14]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_ftb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, palette_color[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_ftb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, palette_color[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }

   // field damage box coordinates
   x1 = Ei[num][15]/20;
   y1 = Ei[num][16]/20;
   x2 = x1 + Ei[num][17]/20 -1;
   y2 = y1 + Ei[num][18]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_fdb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, palette_color[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_fdb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, palette_color[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }
}


if (mouse_on_tb_ul) // move trigger box from ul
{
   // get the width and height
   int w = Ei[num][13] - Ei[num][11];
   int h = Ei[num][14] - Ei[num][12];
   // set new position
   Ei[num][11] = mx;
   Ei[num][12] = my;
   Ei[num][13] = mx + w;
   Ei[num][14] = my + h;
}
if (mouse_on_ftb_ul) // move field trigger box from ul
{
   Ei[num][11] = mx*20;
   Ei[num][12] = my*20;
}
if (mouse_on_fdb_ul) // move field damage box from ul
{
   Ei[num][15] = mx*20;
   Ei[num][16] = my*20;
}
if (mouse_on_tb_lr)  // resize trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < Ei[num][11]) mx = Ei[num][11];
   if (my < Ei[num][12]) my = Ei[num][12];
   // set new postion
   Ei[num][13] = mx;
   Ei[num][14] = my;
}

if (mouse_on_ftb_lr) // resize field trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][11]/20)) mx = (Ei[num][11]/20)+1;
   if (my < (Ei[num][12]/20)) my = (Ei[num][12]/20)+1;
   Ei[num][13] = mx*20 - Ei[num][11];
   Ei[num][14] = my*20 - Ei[num][12];
}

if (mouse_on_fdb_lr) // resize field damage box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][15]/20)) mx = (Ei[num][15]/20)+1;
   if (my < (Ei[num][16]/20)) my = (Ei[num][16]/20)+1;
   Ei[num][17] = mx*20 - Ei[num][15];
   Ei[num][18] = my*20 - Ei[num][16];
}


map works......

now detect trigger collision also....done

if (Ei[e][0] == 10) // check for field collision
{
   // trigger field
   al_fixed ix1 = al_itofix(Ei[e][11]);
   al_fixed iy1 = al_itofix(Ei[e][12]);
   al_fixed ix2 = ix1 + al_itofix(Ei[e][13]);
   al_fixed iy2 = iy1 + al_itofix(Ei[e][14]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 0);

   // damage field
   ix1 = al_itofix(Ei[e][15]);
   iy1 = al_itofix(Ei[e][16]);
   ix2 = ix1 + al_itofix(Ei[e][17]);
   iy2 = iy1 + al_itofix(Ei[e][18]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 1);
}


void proc_field_collision(int p, int x, int b)
{
   if (b == 0) // trigger field
   {

   }
   if (b == 1) // damage field
   {
      players[p].LIFE -= Efi[x][4];
      game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
   }
}


now add slider to adjust the amount of damage....done...reused the same one as all other enemies
...does it also work for the main enemy?...no...collision box..set to 10 and still no..

I don't have and specific code to handle this type of enemy....


added this line to move_enemies()
case 10:  enemy_field(e);  break;


void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
}


now I can take damage from enemy and kill it, but it doesn't die nicely

added to enemy_killed()


case 10: // field
   na = Ei[e][3] = 105;  // new ans
   dl = Ei[e][30] = 40; // death_loop_wait; set delay
   Ei[e][24] = 934+(ht-1)*32; // shape
   Efi[e][11] = al_ftofix(.98); // scale multiplier
   Efi[e][13] = al_ftofix(306/dl); // rot inc
   zz[0][na] = zz[5][na]; // set shape
   zz[1][na] = 0;         // point to zero
   zz[2][na] = frame_num; // set counter
   zz[3][na] = dl / zz[4][na]; // set ans timer
break;

change this at end of enemy killed to include type 10
// almost all do this but not enough to do by default
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12 )
{
   if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
   if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
   Ei[e][0] = 99; // set type to death loop
}


OK now that works, but later, I'll need to make it look nice
for now if I don't want to be able to shoot it, set collision box to 0
...can still kill with bomb...





now lets implement some modes....

0 = static, damage always

1 = no damage until triggered, then timer runs

2 = damage until triggered, then none while timer runs

what are my variables for mode, timer and timer count?

Ei[][5] = mode;
Ei[][6] = timer_value;
Ei[][7] = timer_count;

Ei[][8] = damage; // currently in damage mode




set up buttons for these...

if (bn == 87) // field mode
{
   if (Ei[num][5] == 0) sprintf(smsg, "Damage Always");
   if (Ei[num][5] == 1) sprintf(smsg, "No Damage Until Triggered");
   if (Ei[num][5] == 2) sprintf(smsg, "Damage Until Triggered");
}

if (bn == 87)
{
   Ei[num][5]++;
   if (Ei[num][5] > 2) Ei[num][5] = 0;
}

if (bn == 82) Ei[num][6] = (int)f;        // field timer
if (bn == 82) sprintf(smsg, "Field Timer:%d", Ei[num][6]);
case 82: sul=1000;  sll=10;  sinc=1; sdx=Ei[num][6];           break;  // field timer

now lets actually write some code to process this


void draw_enemy_field(int e)
{
   float tx1 = (float)Ei[e][11]; // trigger
   float ty1 = (float)Ei[e][12];
   float tx2 = tx1 + (float)Ei[e][13];
   float ty2 = ty1 + (float)Ei[e][14];
   int tc1 = 14 + 128; // trigger box color
   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box

   if (Ei[e][8]) // currently in damage mode
   {
      float sx1 = (float)Ei[e][15]; // field
      float sy1 = (float)Ei[e][16];
      float sx2 = sx1 + (float)Ei[e][17];
      float sy2 = sy1 + (float)Ei[e][18];
      int sc1 = 11 + 128; // field box color
      rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
   }
}

void proc_field_collision(int p, int e, int b)
{
   if (b == 0) // trigger field
   {
      Ei[e][7] = Ei[e][6]; // reset timer
   }
   if (b == 1) // damage field
   {
      if (Ei[e][8]) // currently in damage mode
      {
         players[p].LIFE -= Efi[e][4];
         game_event(50, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
      }
   }
}

void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer
   int damage = 0;
   if (Ei[e][5] == 0) damage = 1;                       // damage always
   if ((Ei[e][5] == 1) && (Ei[e][7] > 0)) damage = 1;   // damage when timer is running (no damage until triggered)
   if ((Ei[e][5] == 2) && (Ei[e][7] == 0)) damage = 1;  // damage unless timer running  (damage when triggered)
   Ei[e][8] = damage;  // field is currently in damage mode
}


this is all working good...

now some minor bug fixes...

cant see the field in obj viewer

also what color should they be??
trigger yellow
field red

OK that looks good...now make field always show in level editor
what is that global? level_editor_running


looking good...now figure out how to tell when timer is running...done
show small number counting down second above the enemy..

test if I can use this at the bottom of a pit that kills you instantly...
not unless I set the damage higher...set to 100

move rect to be red...done
hide trigger if not used...done


I want to try slaving it to a lift...just the damage field..always on for now
mode = 3; works as proof on concept...

can we make the field kill enemies

right now I think all my collisions are with player...
I only really care if things collide with players....??

where will I do the collision detection?

I propose to make a new collision detection based on what collides with fields

Then I can do players, enemies, items...


made void proc_field_collisions(void);
and added it to loop....


seems to be working good...

items...done...


wow!!!

now I need to be able to set this in the field somehow....









lets just list a bunch of possible types here:


always on, invisible invulnerable enemy
always on, enemy can be killed


type 3 - always on, following lift

type 4 - shooting enemy toggles field

have a bunch of toggles for enemy shape
- hidden, invulnerable
- shown, killable
- shown, shooting toggles


lets implement hit type
Ei[e][4]

0 normal (can kill)
1 invulnerable
2 toggle also need mode == 4

its better to do this with modes...

pick which modes are invincible...choose a variable also used for death ans...will never be used for this



mode 4 toggle
don't show trigger or allow timer to run
maybe I could make my own bullet handler so it doesn't eat the bullet???

5 trigger be time based only...on time off time...

6 timed like 1 but triggered with shot
7 timed like 2 but triggered with shot

8 timed like 2 but triggered with enemy collision
8 timed like 2 but triggered with enemy collision

immdiate when in zone



I've got to use some more variables
dig into the fixed...

on  count
off count

runs with timer only



lets start with what triggers it:
---------------------------------
player in trigger zone
enemy in trigger zone
player shoots enemy
player touches enemy
strictly timer based on and off

then what happens next:
-----------------------
zone on with timer
zone off with timer

toggle

immediate on or off


then what does it affect:
-------------------------
players
enemies
items

optionally
------------------
move with lift


how many modes do I have that work?

-------------------
5-0 - normal
4-0 - normal
always on
not invulnerable
--------------------
5-1 - off until triggered, then timer runs
4-0 (0 normal, 1 invul, 3 add time)

not invulnerable
--------------------
2 - on until triggered, then timer runs
not invulnerable
--------------------
3 - alway on, follows lift
not invulnerable
--------------------


lets get some nicer drawing for the stuff


spike pit...
flames...
acid...


20220327 new day
did a lot yesterday
kind of ran out of steam after 12 hours
today I am going to bring it on home...complete a lot of this.

I want to start by implementing what objects are affected by the field

use a single int and also use it for invul


bit 1 player
bit 2 enemy
bit 3 item
bit 4 invuln


typedef union
{
 uint8_t     all_flags;      /* Allows us to refer to the flags 'en masse' */
 struct
 {
  uint8_t foo : 1,        /* Explanation of foo */
          bar : 1,        /* Explanation of bar */
          spare5 : 1,     /* Unused */
          spare4 : 1,     /* Unused */
          spare3 : 1,     /* Unused */
          spare2 : 1,     /* Unused */
          spare1 : 1,     /* Unused */
          spare0 : 1;     /* Unused */
 };
} EX_FLAGS;

static EX_FLAGS    Flags;  /* Allocation for the Flags */

Flags.all_flags = 0U; /* Clear all flags */

...

Flags.bar = 1U; /* Set the bar flag */

-----------------------------------------------------------

if(x & 0x01){} // tests if bit 0 is set using bitwise AND
x ^= 0x02;     // toggles bit 1 (0 based) using bitwise XOR
x |= 0x10;     // sets bit 4 (0 based) using bitwise OR

-----------------------------------------------------------


/* Each of these preprocessor directives defines a single bit,
   corresponding to one button on the controller.
   Button order matches that of the Nintendo Entertainment System. */
#define KEY_RIGHT  0b00000001
#define KEY_LEFT   0b00000010
#define KEY_DOWN   0b00000100
#define KEY_UP     0b00001000
#define KEY_START  0b00010000
#define KEY_SELECT 0b00100000
#define KEY_B      0b01000000
#define KEY_A      0b10000000

int gameControllerStatus = 0;

/* Sets the gameControllerStatus using OR */
void KeyPressed( int key ) { gameControllerStatus |= key; }

/* Clears the gameControllerStatus  using AND and ~ (binary NOT)*/
void KeyReleased( int key ) { gameControllerStatus &= ~key; }

/* Tests whether a bit is set using AND */
int IsPressed( int key ) { return gameControllerStatus & key; }

---------------------------------------------------------------------------

lets call Ei[e][3] flags

make 4 button to set player, enemy, items, invul

if (bn == 89) // field affects player flag
{
   if (Ei[num][3] & 0b00000001) sprintf(smsg, "Affects Players");
   else sprintf(smsg, "Does Not Affect Players");
}
if (bn == 90) // field affects enemy flag
{
   if (Ei[num][3] & 0b00000010) sprintf(smsg, "Affects Enemies");
   else sprintf(smsg, "Does Not Affect Enemies");
}
if (bn == 91) // field affects item flag
{
   if (Ei[num][3] & 0b00000100) sprintf(smsg, "Affects Items");
   else sprintf(smsg, "Does Not Affect Items");
}
if (bn == 92) // field enemy invulnerable flag
{
   if (Ei[num][3] & 0b00001000) sprintf(smsg, "Invulnerable");
   else sprintf(smsg, "Not Invulnerable");
}

if (bn == 89) Ei[num][3] ^= 0b00000001; // bitwise OR
if (bn == 90) Ei[num][3] ^= 0b00000010; // bitwise OR
if (bn == 91) Ei[num][3] ^= 0b00000100; // bitwise OR
if (bn == 92) Ei[num][3] ^= 0b00001000; // bitwise OR

int cdp = ((Ei[e][8]) && (Ei[e][3] & 0b00000001)); // damage active and player flag
int cde = ((Ei[e][8]) && (Ei[e][3] & 0b00000010)); // damage active and enemy flag
int cdi = ((Ei[e][8]) && (Ei[e][3] & 0b00000100)); // damage active and item flag


lets add to this trigger:

trigger field player
trigger field enemy
trigger shoot enemy
trigger timer

remove Ei[][4]...done

if toggle is set, inv should be too, unless you want one toggle then enemy dies...


if toggle is set and in mode 1 or 2 they will override....

how about mode 0 is default and if you dont want any changes just implement with flags

mode 3 is now toggle
when setting that mode, automatically set the toggle flag and unset the inv flag

make a button to set initially on or off..



can i use another flag bit for damage on?  this will be the ninth bit...try it...I think I can...it seems to work...

now I got rid of Ei[][8] for damage currently on and replaced it with another flag...

should I set up some nice defines for these??

#define PM_ENEMY_FIELD_AFFECTS_PLAYER 0b000000001
#define PM_ENEMY_FIELD_AFFECTS_ENEMY  0b000000010
#define PM_ENEMY_FIELD_AFFECTS_ITEM   0b000000100
#define PM_ENEMY_FIELD_INVULNERABLE   0b000001000
#define PM_ENEMY_FIELD_TRIGGER_PLAYER 0b000010000
#define PM_ENEMY_FIELD_TRIGGER_ENEMY  0b000100000
#define PM_ENEMY_FIELD_BULLET_TOGGLE  0b001000000
#define PM_ENEMY_FIELD_TRIGGER_TIMER  0b010000000
#define PM_ENEMY_FIELD_CURRENT_DAMAGE 0b100000000


done....



when setting mode 3 (toggle), automatically set the toggle flag and unset the inv flag
in sliders...done

player should never take damage from cloner, but I can't set the collison box to zero because it's used by bullets

in void proc_player_collisions(int p)

changed this line
for (int e=0; e<100; e++)
{
// if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
   if ((Ei[e][0]) && (Ei[e][0] != 99) && (Ei[e][0] != 10) // if active and not deathcount or field
done...
make collison box a little more forgiving maybe 12 or 14 instead of 10... change PDE to 12...can still edit manually...done


bullet is back to getting eaten....fix and maybe make it a flag....

in proc_enemy_collision_with_pbullet(int e)

if ((Ei[e][0] == 10) && (Ei[e][5] == 4)) // don't kill bullet used to toggle field
{
}
else pbullet[c][0] = 0;       // bullet dies

if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE)) // don't kill bullet used to toggle field
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

done and works...

test the collision areas of fields, they are a little off...changed the offset in collison detection...done

old:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]);
 al_fixed tfy1 = al_itofix(Ei[e][12]);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]);
 al_fixed dfy1 = al_itofix(Ei[e][16]);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);


new:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]-10);
 al_fixed tfy1 = al_itofix(Ei[e][12]-10);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]-10);
 al_fixed dfy1 = al_itofix(Ei[e][16]-10);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);



when setting mode = 0
clear bullet toggle flag...done

don't reset inv flag

now what?

make new shapes including hidden...

make a shape that has a hole for the timer count!!


made default from PDE have damage on and mode 0 and draw mode 1

I won't enforce it, but it makes sense to have hidden and inv both set

if hidden, I should still show it in level editor...

if on off switches make then change...done

make button for initial setting on/off in toggle mode...done

make a slider for choosing lift number...and a place to store it...
Ei[][21]

it follows lift just great...I can even center it nicely
maybe make a flag for centering later


now it is always on...I want to change this...

turned it off....

bullet toggle works good...

in level editor, show the field centered on the lift....
how about actually set it when lift is changed with slider....

I should make a function to do this...done


now can we do the timers while in lift mode?

no.. timers only work when mode == 1 or 2

maybe I could make lifts separate from mode...
I would need to use an int for the lift number

I could also potentially move the trigger box with another lift...whooa!!

can timer and toggle co-exist right now??

no, because the timer forces it on or off


I think if I remove lift from mode then I can have modes realted to trigger only...like


then I can have a separate int for the lift stuff
I could jam 4 things in there

1 bit field follow lift
7 bits lift number

1 bit trigger follow lift
7 bits lift number

or I can add a few more flags to 3 and use 2 ints for lifts


I will also need two more variables for the second timer

Ei[][5]  mode
Ei[][6]  timer1 value
Ei[][7]  timer1 count
Ei[][8]  timer2 value
Ei[][9]  timer2 count

let's re-arrange the modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

no lift...move in to flag and lift numbers in:
Ei[][19]
Ei[][20]

what am I using 21 for?? lift number! perfect!

OK lets do this...
start with lift flags

#define PM_ENEMY_FIELD_LIFT_SETS_FLD  0b0000010000000000
#define PM_ENEMY_FIELD_LIFT_SETS_TRG  0b0000100000000000

Ei[][20] // trig lift
Ei[][21] // field lift

sliders...done

patched that all in nicely...

now rearrange modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

screw it, im leaving toggle out, it does nothing...

0 on
1 on till trigger
2 on when trigger
3 double timer trigger

NO! I need a mode that is not a timer, so timers wont fuck over toggle

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger


good so far....now implement double timer...

make slider to adjust

Ei[][8]  timer2 value



why do I have 2 timers?

would it not be simpler to run one from value to zero then reset...and have a midpoint where the damage flips??
lets just call timer 2 the flip point

that works great.

hide timer numbers in modes 0 and 1

in mode 3 do a modified count down for each stage...done





I would say that most of the basic funtionality has been implemented...
now for some polish and testing...



naming

enemy is called Field
is has a
Damage Field
Trigger Field
make this naming consistant

at the top should be the stuff related to the enemy
inv and shape

then the stuff related to the Damage Field

get new...etc

the viewer page looks good...

it all looks good...
not implemented:
anything except player triggering
unused flag trigger timer


I want to make a test level to show this off....

bugs

when creating, a creator might be nice..done
or take me to the edit page right away
of just make the lr trigger not exactly the ul damage!!..this is done...

remove old simpe PDE for field...
remove old item field thing...done

when invisible, its kinda hard to find in level editor...fixed

death sequence needs something more than just copying cloner

make some better shapes for damage fields...

how will I show different draw types
use an int? patched it in..

Its use as an item killer is nice too... I can make a screen that items can't go through

to kill items nicely, have the killing screen ignore things in the death phase...done
redraw attached to lift when stuff moves in level editor....done
make boxes snap to 20 grid..not a problem unless attached to lift...done


I want to make field able to kill enemy and player bullets also....done!!!
when checking collisions, I realized I can also have bullets affect trigger!!!

make damage field able to be invisible...done

also add display options for trigger field use Ei[][10]... done for now only default and none


20220328 6:20 AM
wow this is coming along so great......time for a push


lets try some other things that can trigger...

enemy
item
enemy bullet
player bullet

right now trigger only makes sense in mode 2 and 3
and then timers run...

can it be instant by setting timer to 0?
0 and 1 never work, 2 works...why??

moved dec counter to last thing in enemy proc...now 1 works

patch in trigger sources...
did a bunch of re-arranging flags and slider button toggles

now make the new trigger source functionality work....done

why does a new filed have damage of 0?...done

fix display of damage to only 2 decimals...done

why is bullet getting eaten in mode 1?


in void proc_enemy_collision_with_pbullet(int e)
old:
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
new
if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field



Change the wording of MODE.
ON until triggereg
OFF until triggered

Make Mode capitalized


I want to make a toggle mode based on field...
but how will i make it work?...I'll need a hold off
when something first enters

detect if nothing is in trigger box
then if next frame something is in then trigger

then wait until it is empty again before allowing another trigger
I'll need something to keep track of how it was the last frame

I could use a flag...

each frame:
if not set from last frame...
and set this frame...toggle trigger fires

use 2 flags...

start of frame clear current
when checking collisions if any trigger, set current trigger
after checking collisions if not last the yes this then fire toggle
set last to current for next time...

I have been doing the triggers wrongs
collisions with damage need to afect specific things
but collisions with triggers?
who cares where they came from?
all that matters is that a trigger happened

new flags

#define PM_ENEMY_FIELD_TRIGGER_CURR  0b1000000000000000
#define PM_ENEMY_FIELD_TRIGGER_LAST  0b1000000000000000

at the start of the enemy proc loop CURR is cleared
if any trigger collisions, CURR is set

at the end of the collision checks...

if CURR is set: proc things that happen when something is in trigger box
if CURR is set and PREV is clear: process things that only happen when initiallt triggered

set PREV to CURR


what if I remove all toggle by shooting actual enemy...might make things easier....
once I get the trigger toggle stuff working I'll look at it...

I'm ready to do it

there is custom code in

void proc_enemy_collision_with_pbullet(int e)

for when a bullet hits the field enemy...
i am going to try to take it out completely
I still want the enemy to be invincible...but I can just set collision box to zero....
wait....

just leave code there so pbullets completely ignore field enemy
then I should just make it always invincible...
use the enemy tile stuff just for counter and progress bar....
I can get collision box for something else too maybe....

old:

   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2)))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has

//            if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

      if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
      {
      }
      else pbullet[c][0] = 0;       // bullet dies

   }

new:
   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2) && (Ei[e][0] != 10))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has
      pbullet[c][0] = 0;       // bullet dies
   }


I can go back one higher to the function that call this:

old:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if (Ei[e][0] < 50) proc_enemy_collision_with_pbullet(e);

         // check for time to live
         int ttl = Ei[e][27];

new:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if ((Ei[e][0] < 50) && (Ei[e][0] != 10)) proc_enemy_collision_with_pbullet(e);



now it does not even detect bullet, but I kept the invincible code because of bombs
if I removed that, nothing could ever kill it

this whole thing that every enemy has....

   if (Ei[e][31]) // hit
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_INVULNERABLE)) // invulnerable flag not set
      {
         enemy_killed(e);
         return; // don't do anything else past here
      }
   }
   enemy_player_hit_proc(e);

void enemy_player_hit_proc(int e)
{
   if (--Ei[e][23]<0) // hit player retrigger
   {
      if (Ei[e][22]) // player hit!
      {
         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount
      }
   }
  else Ei[e][22] = 0;
}

I'm going to remove all this...

then I will get back 22 and 23

edit this to ignore fields

void bomb_enemies(int i, int t, int dr, al_fixed x, al_fixed y)
{
   for (int e=0; e<100 ; e++) // enemies in damage window?
      if ((Ei[e][0]) && (Ei[e][0] != 10))
      {
//         al_fixed dist = al_fixhypot( (Efi[e][0] - itemf[i][0]), (Efi[e][1] - itemf[i][1]) );
         al_fixed dist = al_fixhypot( (Efi[e][0] - x), (Efi[e][1] - y));
         if (dist < al_itofix(dr))
         {
            if (t == 1) bomb_crosshairs(10 + al_fixtof(Efi[e][0]), 10 + al_fixtof(Efi[e][1]));
            if (t == 2)
            {
               Ei[e][31] = 2; // set bomb hit
               Ei[e][26] = item[i][13];  // player that did bomb
            }
         }
      }
}


now I have reclaimed a lot more ints....

bottom line:
field is now invincible, nothing, not bombs or bullets can kill it
it should not interact with player at all...

that makes things a lot simpler and I have freed up all these variables

Ei[][22] =                 player hit
Ei[][23] =                 player hit retrigger
Ei[][24] =                 health bonus shape
Ei[][25] =                 health bonus amount
Ei[][26] =                 used to tell what player killed enemy
Ei[][27] = time to live
Ei[][28] =                 cloner create id
Ei[][29] =                 collision box size
Ei[][30] =                 death loop count
Ei[][31] =                 flag that this enemy got shot with bullet


now I need to make the toggle mode in obj viewer show all the trigger stuff


For timed on and off, make custom button that say time on and time off.

also make initial time [7] adjustable for synchronization...

which is which???
total time...6
on time 8
initial time 7



I think I am abandoning drawing with tile stuff, maybe just a place holder

I want to implement a draw mode for the main shape

like show the number and progress bar in different ways

my main function is very small now



void enemy_field(int e)
{
   int mode = Ei[e][5];
   int trig_toggle = 0;

   Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_CURR;  // clear current trigger flag
   detect_field_collisions();
   if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) // is current trigger flag set?
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_PREV)) trig_toggle = 1; // if triggered this frame and not triggered last frame, set trigger toggle
      Ei[e][3] |=  PM_ENEMY_FIELD_TRIGGER_PREV; // set previous trigger for next frame
   }
   else Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_PREV; // clear previous trigger for next frame

   if (mode == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE; // in mode 0, always set damage flag

   if ((mode == 1) && (trig_toggle)) Ei[e][3] ^= PM_ENEMY_FIELD_CURRENT_DAMAGE; // toggle current damage flag

   if (mode == 2) // damage unless timer running  (no damage when triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 3) // damage when timer is running (no damage until triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] > 0)  Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 4) // timed on and off
   {
      // timer will run outside this function always, but in this mode, when it gets to zero, we will reset it
      if (Ei[e][7] == 0) Ei[e][7] = Ei[e][6];
      if (Ei[e][7] < Ei[e][8]) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else                     Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;  // set damage off
   }

   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_FLD) set_field_location_from_lift(e, 0, 0);
   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_TRG) set_field_location_from_lift(e, 1, 0);

   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer

}



what is still left to do?

get some draw modes for the main enemy

probably never show the shape when game is running

what do I want to do with the main bitmap Ei[][1]?

leave it blank and use another var for draw mode??
or customize the drawing routines so that field always draws itself...yes do that...

void draw_enemies(void)
{
   al_set_target_bitmap(level_buffer);
   for (int e=0; e<100; e++)
      if (Ei[e][0])  // if enemy active
      {
         if (Ei[e][0] == 10) draw_enemy_field(e); // field - do not draw anything here for field, let draw_enemy_field() do it all
         else
         {
             int EXint = al_fixtoi(Efi[e][0]);
             int EYint = al_fixtoi(Efi[e][1]);
             int flags = 0;
             if (Ei[e][2] == 0) flags = ALLEGRO_FLIP_HORIZONTAL;
             if (Ei[e][2] == 1) flags = 0;
             if (Ei[e][2] == 2) flags = ALLEGRO_FLIP_VERTICAL;
             if (Ei[e][2] == 3) flags = ALLEGRO_FLIP_VERTICAL & ALLEGRO_FLIP_HORIZONTAL;
             int tn = Ei[e][1];

             float rot = al_fixtof(al_fixmul(Efi[e][14], al_fixtorad_r));
             float sc = al_fixtof(Efi[e][12]);
             al_draw_scaled_rotated_bitmap(tile[tn], 10, 10, EXint+10, EYint+10, sc, sc, rot, flags);

             // if enemy is expiring show how many seconds it has left
             if (Ei[e][27]) al_draw_textf(f3, palette_color[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);
         }



do this is my draw code..

if (level_editor_running) al_draw_bitmap(tile[476], ex, ey, 0);


OK all that is done...

now I have freed up

Ei[][1]
Ei[][2]
Ei[][27]

I have so many free variables now at the expense of..
invulnerable
can't hit player
can't get hit players, bullets or bombs
no regular display, all custom
no time to live

use Ei[][2] for enemy draw mode
how I will draw stuff

0 = draw nothing
1 = small text counter
2 = large text counter
3 = small progress bar
4 = large progress bar
done...

in creator
make field initially on
remove collision box
done....


should I make them show all the time, or only when timer is running?
numbers...only when running
percent bars..always

make it so that when I copy and paste, the boxes are offset also, like cloner boxes....
done with regular copy and zfs copy.....

then test all type 3....all looks good!!!!

now apply all that to the timed mode...done...

wow that was easy.....



What do I have left?

I think all the functionality is there, maybe just some nice drawing code stuff for fields...

Oh yeah and also how the field attach to lifts

right now they just center

in the x axis:
center , right or left

in the y axis
center, right of left

6 flags....9 combinations

no...do it this way
XC
XF
XL

if c=1 ignore the rest
if c=0 four possibilities
fx1 = lx1
fx1 = lx2
fx2 = lx1
fx2 = lx2

XC XF XL
0  0  0 Field X1 = Lift X1
0  0  1 Field X1 = Lift X2
0  1  0 Field X2 = Lift X1
0  1  1 Field X2 = Lift X2
1  x  x Centered

so now there are 5 setting for x and 5 for y for a total of 25 combinations
I like that a lot better than 9

I have all the stuff done for allignment of fields to lifts

removed the flags for invuln, toggle and eat bullet

link the creator back in for the viewer button...done

after creating field, open the viewer...

unless create is called from the viewer already....

how can I tell if the viewer is running? ... another global...
or I can hook it from what called it...




PDE special calls create_obj
in PDE I am hooking in the viewer after...

obj viewer create button calls create_obj

those are the only 2 places...

why am I hooking in in PDE?
that is too far up the chain

hook in in craete OBJ that is common, or even better in the actual creators...

this works, but what happens in recursion as the viewer calls another viewer after creating...
when escaping out you go bakc through the nested viewer...I can live with it...

what about cancelling in the middle of creating? works great

what about pmsg?...patched in obj viewer at the end of create..done...

what about game_events caused by enemies getting killed by fields...
right now it says player killed with bullet...


in enemy killed this is called:
game_event(62, 0, 0, Ei[e][26], e, 0, 0);
where is 26 set?
and this
int ht = Ei[e][31]; // hit type

make a custom event...

still needs to be called from enemy_killed()

   if (type == 1) // enemy
   {
         Ei[x][31] = 1;           // flag that this enemy got shot with bullet
         Ei[x][26] = p;           // number of player's bullet that hit enemy
   }

lets try
         Ei[x][31] = 3;           // flag that this enemy got killed by a field
         Ei[x][26] = x;           // number of field


int ht = Ei[e][31]; // hit type
int hb; // health bonus
if (ht == 1) hb = 1; // bullet
if (ht == 2) hb = 2; // explosion
if (ht == 1) hb = 1; // field

// almost all do this but not enough to do by default
int a = Ei[e][0];
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12)
{
   Efi[e][4] = al_itofix(0);  // cant hurt anymore
   Ei[e][25]*=hb; // health bonus

}
switch (Ei[e][0])
{
   case 3: // archwagon
      na = Ei[e][3] = 34;  // new ans
      dl = Ei[e][30] = 20; // death_loop_wait; set delay
      Ei[e][24] = 929+(hb-1)*32; // shape
      Efi[e][11] = al_ftofix(1.08); // scale multiplier

if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);

done... enemy killed by field!

what does player damage from field look like??
player hit a mine

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(50, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
   }

make new game_event
game_event(58, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
customize the message by the draw type of the field
default = "was hurt by a damage field"
others "was hurt by a spiked floor"
I can get that info from the field number in the event...

done...

this is one of those that keep retriggering

in the retrigger code.. everytime one is skipped, tally the damage...



where can I check it?

something that happens every frame...
proc_frame_delay()

I need to do this for every player, don't I??

what if I keep track of that in the player struct?

damage tally, holdoff till display event...

or I could do a damage holdoff in the player...so that he doesn't take damage every frame...
enemies have a player damage holdoff built into them...
yes...once an enemy hurts any player, they cannot hurt any player for 60 frames...
this is kind naive, but it works good enough...


add something to struct player1, not synced....


float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;




done
in events

   if (ev == 57) // damage field raw
   {
      int p = z1;
      int e = z2;
      float damage = al_fixtof(Efi[z2][4]

      if (player1[p].field_damage_holdoff < frame_num) // triggered and not in holdoff
      {
         player1[p].field_damage_holdoff = frame_num + 20; // set holdoff
         player1[p].field_damage_tally = damage; // init tally with current damage
         ev = 0; // don't let this event do anything
      }

      if (player1[p].field_damage_holdoff > frame_num) // triggered and in holdoff
      {
         player1[p].field_damage_tally += damage; // inc tally with current damage
         ev = 0; // don't let this event do anything
      }
   }

in void proc_player_health(int p)





These are the pieces that make this work:


added to struct player1 (not synced)

float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;

the event that draws:

if (ev == 58) // player took damage from a field
{
   custom_drawn = 1;
   int damage = (int) players1[z1].field_damage_tally;
   int e = players1[z1].field_damage_enemy_number;
   int type = Ei[e][19];

   if (type == 1) bmsg_length += bmsg_show_text(" was hurt by spikey floor ", 15, bmsg_length);
   else           bmsg_length += bmsg_show_text(" was hurt by a damage field ", 15, bmsg_length);
   bmsg_length += bmsg_show_health(-damage, bmsg_length);
}

the event that tallies:

if (ev == 57) // damage field raw
{
   int p = z1;
   int e = z2;
   float damage = al_fixtof(Efi[z2][4]);
   players1[p].field_damage_enemy_number = e;

   if (players1[p].field_damage_holdoff < frame_num) // triggered and not in holdoff
   {
      players1[p].field_damage_holdoff = frame_num + 20; // set holdoff
      players1[p].field_damage_tally = damage; // init tally with current damage
      ev = 0; // don't let this event do anything
   }

   if (players1[p].field_damage_holdoff > frame_num) // triggered and in holdoff
   {
      players1[p].field_damage_tally += damage; // inc tally with current damage
      ev = 0; // don't let this event do anything
   }
}

where event 58 is triggered:

void proc_player_health(int p)
{
   if (players1[p].field_damage_holdoff == frame_num) game_event(58, 0, 0, p, 0, 0, 0);

where event 57 is triggered:

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(57, 0, 0, x, e, 0, 0);
   }

It seems to be working...
make the sound effect happen on 57 so there is not delay...done...



huge idea here........

what if I seperate triggers and actions?


right now triggers and actions are a one to one relationship

what if it could be many to one, or one to many, or many to many?

the possibilites would increase exponentially.


how about for each field enemy....

add the ability to set the trigger to another field enemy

then it could look it up with flags

I will need to add a flag for toggle...
right now toggle is only calculated internally

I will need to make sure these damn links do not get broken when resorting

is that the only change I need? to make the trigger source able to be set to another field?
what if I want multiple triggers for one source?


what if I set input for each field and output for each trigger

then I can do:
many to one (input for each damage field) and
one to many (output for each trigger)...NO this will not work...just one to many





I would need some kind of event mapper from sources to actions

I think this is the way to go...it will be complicated but worth it

let try to plan this out:

create a link

create a event

named?

thingy till I get something better

when triggered set 'action 1'

action[1000]

if triggered set action[x] = 1;

then have a function to do the mapping

like

if (action[1]) action[23] = 1;

field enemies can have:
trigger action that they will set when triggered and damage action when they receive a trigger


the table of rules would look like

index action1 action2 proc
0       1      250    set
1       2      200    clear
2       4      100    toggle

the action list would be just one int, set or clear

fields could output three actions:
one for on/off
one for toggle (off to on)
one for toggle (on to off)

I would have to manually set these in the field trigger and the field damage
then I would need to create the links in the link table...

this sounds complicated...

all these events can be blank for now unless needed....

I am thinking of case when one field's timer ends and it triggers another field's timer to start....

like I said...complicated

triggers for trigger fields:

object in field
object just entered field
object just left field

number of objects in field > num
number of objects in field < num
number of objects in field == num

all these but only when they first occured
number of objects in field > num
number of objects in field < num
number of objects in field == num

triggers for damage fields
depends on type

inputs
none for always on and timed on and off
toggle would only get the ones when they first occured
timer modes would get the perstant ones

outputs
none for always on
for the other ones send a trigger when they change
and also have the ability to constantly send when on or off

I can also make a new thing that sets blocks on or off, based on triggers

after seeing all this, do you still want to proceed?

I think so...

Maybe I can make triggers items...but why, because I have lots of them...

I could make keys respond of actions, or send them..
I can make switches do the same..
Also I can make switches have an area of effect, like keys...

I also want to make blocks that stop bullet, or not, players, items, etc...

I think this action or event thing will be the heart of some great new things...

I need to plan it carefully...

each action will simply be an indexed entry in the action table.

int pm_event[1000][4];

pm_event[1000][0] - action ID
pm_event[1000][1] - clear, set, toggle off, toggle on (0, 1, 2, 3)
pm_event[1000][2] - type of initiator
pm_event[1000][3] - ID of initiator


the mapping table will look like this:

int pm_event_map[1000][3];

pm_event_map[1000][0] - source pm_event
pm_event_map[1000][1] - target pm_event
pm_event_map[1000][2] - action (0 = copy) others could be set->clear, clear->set ...

this looks like a good start...I'm scared of all this work...

when I implement this, don't kill the existing stuff...in case I give up and go back....






