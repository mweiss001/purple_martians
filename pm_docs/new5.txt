

------------------------------------------------
20180314 pi day

OK here I am converting to Allegro 5

imported the project from .dev into code::blocks

removed all e_ files and n_ files

in pm.h undefined sound DUMB netplay

now lets see if I can get it to compile...

first thing in that the new allegro headers cant be found:
fixed that..

fixed has been replaced with al_fixed???

when I'm doing things like this should I not do it for my entire project?

yes...

fixed -> al_fixed
BITMAP -> ALLEGRO_BITMAP
destroy_bitmap -> al_destroy_bitmap

DIALOG gone from 5
disable for now, maybe get EGG_DIALOG later

PALLETE ????? ditch it

END_OF_FUNCTION(inc_timer_passcount);

void inc_timer_passcount()
{
   timer_passcount++;
}
END_OF_FUNCTION(inc_timer_passcount);

void second_timer()
{
   fps = passcount - last_fps_passcount;
   last_fps_passcount = passcount;

   frames_skipped_last_second = (players1[active_local_player].frames_skipped - last_frames_skipped);
   last_frames_skipped = players1[active_local_player].frames_skipped;
}
END_OF_FUNCTION(second_timer);


   LOCK_VARIABLE(timer_passcount);
   LOCK_FUNCTION(inc_timer_passcount);

   LOCK_VARIABLE(fps);
   LOCK_VARIABLE(last_fps_passcount);

   // this is for the fps
   LOCK_FUNCTION(second_timer);
   install_int_ex(second_timer, BPS_TO_TIMER(1));



it looks like the old timers, called a function...
where the new ones generate an event


I only have 2 timers:
1 to count actual frames per second
1 to control the frame rate
both are only used in the game loop
I'm having trouble thinking why I want to do this with events...

one solution is to spawn another thread that does nothing but update passcount

or in my loop, at the frame delay I can wait until i get an event...

al_create_timer
ALLEGRO_TIMER *al_create_timer(double speed_secs)

Allocates and initializes a timer.
If successful, a pointer to a new timer object is returned, otherwise NULL is returned.
speed_secs is in seconds per "tick", and must be positive. The new timer is initially stopped.
Usage note: typical granularity is on the order of microseconds, but with some drivers might only be milliseconds.

See also: al_start_timer, al_destroy_timer

al_start_timer


al_get_timer_count
int64_t al_get_timer_count(const ALLEGRO_TIMER *timer)
Source Code

Return the timer's counter value. The timer can be started or stopped.

See also: al_set_timer_count

I think with this i don't need events at all



'fps_timer' will be the name of my new timer

ALLEGRO_TIMER * fps_timer = al_create_timer(0.025);


"timer_passcount" used to be the variable that got incremented in the
old timer loop.

now it will be al_get_timer_count(fps_timer);


void al_set_timer_speed(ALLEGRO_TIMER *timer, double new_speed_secs)
Set the timer's speed, i.e. the rate at which its counter will be incremented when it is started.
This can be done when the timer is started or stopped.
If the timer is currently running, it is made to look as though the speed change occurred precisely at the last tick.

void al_set_timer_count(ALLEGRO_TIMER *timer, int64_t new_count)
Set the timer's counter value. The timer can be started or stopped.
The count value may be positive or negative, but will always be incremented by +1 at each tick.


disable the fps per second one for now...
commented out in main



change the timer:

add global and extern in pm.h
ALLEGRO_TIMER * fps_timer ;

create timer in initial setup:
fps_timer = al_create_timer(1/fps_passcount_timer);


look for all mentions of timer_passcount and replace with al_get_timer_count(fps_timer);
or set...  done




sprintf() needed <stdio.h>?? why didn't it need it before??'


config is all fucked.. more more int float string, now its all string
will need to make convertors...atoi and itoa...etc


also I need to load the config file first...

where do I do these things in my program?

right after allegro_init

set_config_file("pm.cfg");


why don't I load it in initial setup
and destroy right after.

whenever I want to save a change i will need to load the file
make the change and save it.


i should have one function that saves everything to config
and also one that loads everything

what do i do about defaults??

make my own load data from config fucntion




----------
fixtoi --done
fixtof -- done
itofix - done
ftofix - done

rest all chnged to al_rest

al_create_bitmap done all



scrn.cpp
killed most of screen setup

just make a 800x600 window

global and externed
ALLEGRO_DISPLAY *display = NULL;


   display = al_create_display(640, 640);
   if(!display) {
      fprintf(stderr, "failed to create display!\n");
      return -1;
   }


blit( src, dst, 0, 0, dx, dy, src->w, src->h)	al_draw_bitmap( src, dx, dy, 0)
blit( src, dst, sx, sy, dx, dy, sw, sh)	al_draw_bitmap_region( src, sx, sy, sw, sh, dx, dy, 0)
blit


first set al_set_target_bitmap

screen_buffer will need to be replaced with the back buffer

what do i do with SCREEN_H and W??
global and extern SCREEN_H



al_get_display_width
int al_get_display_width(ALLEGRO_DISPLAY *display)
Source Code

Gets the width of the display. This is like SCREEN_W in Allegro 4.x.

See also: al_get_display_height

al_get_display_height
int al_get_display_height(ALLEGRO_DISPLAY *display)


made scrn.cpp compile by gutting it...


sound compiles...

player compiles


now i'm in menu how am i going to do key input??

void al_get_keyboard_state(ALLEGRO_KEYBOARD_STATE *ret_state)


// Returns whether or not a specified key is being pressed
bool key_pressed(int key)
{
   ALLEGRO_KEYBOARD_STATE s;
   al_get_keyboard_state(&s);
   return al_key_down(&s, key);
}
This was a function I wrote for Deluxe Pacman 2 to wait for a keypress or xxxx amount of milliseconds before continuing (this is the trimmed down version)...

#SelectExpand
  1// Waits a specified time (in ms, 1000=1s) for a key to be pressed.
  2// Will also respond if a mouse or joystick button is clicked.
  3// If the time passes before a key/mouse/joystick is pressed, the function returns
  4// If the time specified is zero, the function will wait indefinitely.
  5bool wait_for_keypress(double wait_time)
  6{
  7   double ts = al_get_time(); // time stamp
  8   double elapsed_time;
  9
 10   al_flush_event_queue(event_queue);
 11
 12   bool done = false;
 13
 14   // Wait until the specified time passes or a key is pressed.
 15   do {
 16      al_wait_for_event(event_queue, &event);
 17
 18      if(event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
 19         shut_down(); // free resources
 20         exit(0);
 21      }
 22
 23      else if(wait_time && event.type == ALLEGRO_EVENT_TIMER) {
 24         elapsed_time = al_get_time() - ts;
 25         if(elapsed_time >= wait_time) return false;
 26      }
 27
 28      // Wait for key to be pressed and released to continue
 29      else if(event.type == ALLEGRO_EVENT_KEY_UP) {
 30         if(event.keyboard.keycode == ALLEGRO_KEY_ESCAPE) return true;
 31         else done = true;
 32      }
 33
 34      // And if a key wasn't pressed, maybe a mouse button was...
 35      else if(event.type == ALLEGRO_EVENT_MOUSE_BUTTON_UP) {
 36         done = true;
 37      }
 38   }
 39   while(!done);
 40
 41   return false;
 42}
---


maybe I can register an event loop once in my program and then use it for menus
and whatever as well as the main game loop...


where am i??

either in menu or in loop


i got menu to compile

loop compiles..


now in lifts...
what am i going to do about color?

I'll make my own palette, with hookers and blackjack...

I can even still call it palette color...

all I need is the seed for each color...

make an array of colors:

ALLEGRO_COLOR palette_color[256];
palette_color[0]  = al_map_rgb(  0,   0,    0); // black
palette_color[1]  = al_map_rgb(191, 108,  232); // alt purple 1
palette_color[2]  = al_map_rgb(136,  32,  172); // alt purple 2
palette_color[3]  = al_map_rgb(60,  127,  255); // alt blue
palette_color[4]  = al_map_rgb(224,  28,   72); // alt red
palette_color[5]  = al_map_rgb(255,   0,  232); // pink
palette_color[6]  = al_map_rgb(255,  191, 127); // taan
palette_color[7]  = al_map_rgb(255,  127,   0); // orange
palette_color[8]  = al_map_rgb(127,    0, 255); // original purple
palette_color[9]  = al_map_rgb(  0,  255, 127); // alt green
palette_color[10] = al_map_rgb(255,    0,   0); // red
palette_color[11] = al_map_rgb(  0,  255,   0); // green
palette_color[12] = al_map_rgb(  0,    0, 255); // blue
palette_color[13] = al_map_rgb(  0,  255, 255); // lt blue
palette_color[14] = al_map_rgb(255,  255,   0); // yellow
palette_color[15] = al_map_rgb(255,  255, 255); // white

for (int x=1; x<16; x++)
{
   int c = (x+1)*16 - 1;
   palette_color[x*16]  = al_map_rgb(c, c, c);
}

this is my old fade proc

         int x;
         int cn = b1_color;
         float ns = 15;
         for (x=0; x<ns; x++)
         {
            pallete[cn+(x*16)].r = (unsigned char) ( pallete[cn].r * (1 - (x/ns)) );
            pallete[cn+(x*16)].g = (unsigned char) ( pallete[cn].g * (1 - (x/ns)) );
            pallete[cn+(x*16)].b = (unsigned char) ( pallete[cn].b * (1 - (x/ns)) );
         }



it seems to work good..

i just had a thought...
all this stuff I have always been doing with the way i set up my palette...
its just basically an alpha channel...
by adding 16 to the color i decrease the alpha because that s how i set up my palette


im just testing things in mtest for now...

so far I have

load sprit
drawing primitives
made my own palettte
textout

I really need to figure out keyboard input


make an event loop...done...

it looks like the example i followed show an easy way to re-implement the old key[KEY_*] fucntionality

first of all i need to create key[256] with names for all the actual keys

i want to reuse as much as possible....

al5 aleady has somthing like this...ALLEGRO_KEY_*

looks like I can already if I use
bool pressed_keys[ALLEGRO_KEY_MAX];
pressed_keys[key_code] = true;


---------------
create my own array like:

bool key[ALLEGRO_KEY_MAX];

now in my event loop get key downs and up events, run function to set my array

the only thing i won't be able to do is while(key[KEY_ESC]);

unless i process in that loop..

am i getting lost here??

what do I need to do to make my menu work

make an event loop in initial setup..
register screen and keyboard events
poll it in the menu

ok im ready to go back to the game....

lift color is what I was working on

add primitives to game

patch my colors into the game...done


lifts now compiles


can i do a global replace for textout??

al_draw_text(font, color, x, y, ALLEGRO_ALIGN_CENTRE, msg);

i might need to specify a display or bitmap..

items compiles

fnx compiles

file compiles by commenting everything out...

emove compiles


on to control

I have to do something about keyboard input...

- set up event loop and hook keyboard up to it

process the event queue in proc_controls...

i want a non blocking way to look for events...

control done...

bullets done

yfilecom..done

now.. remove all other files from project and try to compile...


got as far as trying to start a game...


i can run the game..with lots of problems..

rotation of bitmaps..

players bitmap not filled
filled but need top change colors

control does not works.fixed

items do not show...fixed

make scaler work...


make function keys work...
re-enable function keys
scaler works
speed no

up screen res to 1024 768 for now


make lift prox rect work
mostly done..just need to patch in vertical name when rtext is fixed

do the transparency of player properly

where should I do transparency?

when I created the bitmaps on load??

does it make any sense to keep color 0 in there??



convert mask to alpha at bitmap load and also when making player bitmaps

now do door bitmaps...done...


now fix item draw.

door done..

now key in ans..


what is left to do for item draw:
key in final seq...
stretch draw for bombs


now make enemy draw better...

I fixed the rotating conversion from fixed to float

I am having trouble converting my rotations
what point do i pivot on??

it was as simple as setting the center pivot point to 10,10
and then offsetting the pos x and y by 10

works for player too...!!

i want to get speed working again.. and top display..
ok done...

time for a backup and work...


20180316 7:45

seems like I'm skipping a lot of frames...

rocket draw...fixed

removing blocks with key or breakable leaves lines..fixed

bullets alpha looks good...

block walker block to show...done



frame and title to show frame...done

that is using the backbuffer, instead of screen buffer
i think I should do this in all cases anyway
its an extra layer of complexitry to do both..

frame during game...done
this uses the screen buffer

run the menu using proc controls..done

still needs some work...




game seems to run slow...
can i run it wide open

like in speed test...

still only get like 20 fps

make the fps skipped per sec and actual

how??


create a second timer
check it in proc frame delay



looks like draw item and set draw item shape are high up on the profiler list...

also _mcount private??


i get 22-23 fps
with item_draw_disabled I can get 29-30 fps


everything seems slow...


20 fps base

- get new background 28
- draw items 28
- both 38

also
- draw enemy 56
- draw lift 56
- draw player

no dif

draw pbullets is really bad... why???
no its not that...
that was just the last thing i disabled

with all these disabled i get 170fps

         // these all draw on level_buffer
//         get_new_background();


//         draw_lifts();
//         draw_items();
//         draw_enemy();
//         draw_ebullets();
//         draw_pbullets();
//         draw_screen_msg();
//         draw_players();


as soon as any one of them is enabled it drops to 50


all those functions have in common is:
al_set_target_bitmap(level_buffer);


set this:
al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);

made things a lot faster...

now...


base 32
no item draw 52
no enemy draw 90
all others but get background no change
get background (all disabled) 256


I guess i was mistaken about memory_bitmaps
with allegro 5 they are slow, and video bitmaps are the way to go...


next, why is draw items so slow...

-------------

my bitmap are created with 4 byte per pixel and 32 bits per format

lets try to half that...


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA); ..fails
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works





base 40 fps with get_new_background only


al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
90

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
94

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
102



base 22 fps all

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
32

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
28

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34

al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE);
al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA); ..works
34



draw items does a weird thing were it gets the bitmap to draw in dtemp
if i disable that it gets faster...






tried creating display with windowed, resizeable window no fps diff

fullscreen window went from 32fps to 28
screen size went from 1024x768 to 2048x1152

actual full screen was about the same..


fixed item draw to not use dtemp

new base 1024x768 windows all on
52 fps

enemy draws with dtemp too...fixed
new base 1024x768 windows all on
80 fps


draw enemy is completely done

draw items need to have stretch implemented...
for bombs and moving keys


i think draw items is done, but i would like to simplify it...
rot is used by key and rocket only...
stretch is used by key only, and maybe explosion??
key uses 11 for scale 10 for rot (/10)
rocket uses 10 for rot
lit bomb uses 10 for scale ()/ 100)
if I change:
lit bomb to use 11 to scale..
and make all these / 100
other items uses 11 and 10...
leave this for now




item draw and enemy draw are done, game runs at good speed

let make the menu better...

keys left and right need holdoff...
how about if menu is started with those keys pressed, wait for release...


menu and start screen are all fixed..

lets do the health display and progress bar...done

now free men...done

now frame..done

now small text on door bitmaps...


im going to make or use two bitmaps to do this...

1014 in.
1015 out.

do this when creating door bitmaps
small text for doors is done


now how about controller setup

maybe i should do the save config first...


201801318 5:00 I did a lot yesterday...


today I want to:
finish cfg file
controller setup
remove use of screen buffer in game and switch to backbuffer
sound
help

add to all error msg, native dialog pop up

test keys is done
most of controls is done, still left
key names...done

joystick..


use the same key struct as keys

in controll set the appropriate key...


its looking good,


only works for first joystick right now...

i'm not sure how to do more..

the joystick struct does not correspond to id..
leave it for now
edgar reynaldo posted a solution...

code is good now...








lets do some sound...


scalers were from 0-9

a typical example for bullet is:

(180 * se_scaler)/9

(180/255)  = .71 * (float) se_scaler / 9


sounds are coming along nicely..

i need a way to stop them, especially fuse hiss...

// this plays pm.xm just fine...time to kill DUMB!!!!

   temp_song_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
   al_attach_audio_stream_to_mixer(temp_song_stream, al_get_default_mixer());

nowhere in the sources is dumb found!!!

make a seperate mixer for se and st and make it work with scalers

do i need sound on/off???

just patch it in the mixer somehow


im having hard time with config files


make load do nothing but get values and test limits

then call save to set menu's and whatever else

save also called when program changes values


done....



remove use of screen buffer in game and switch to backbuffer


mostly done, do the rest as it get uncommented


i want to fix mtextout done
bottom message and level done is good...

now I want to fix tsw()...done



rtextout done...
screen message done...
join_quit_done...



20180318..got a lot done today....


20180319



native error messages..done

screen change by dragging...done, it was easy...
hot key for full screen F12..done..

changing volume when sound off causes crash..fixed
fps to show up on menu to start...fixed

next to do...

file selectors
help
graphical level select
mdw_logo and splash screen
new menu for all of my option that need setting

20180319 0650


stimp and stamp done


change proc_controls to return int
0 normal return
not 0 = scan code of keypress

mdw logo is done... looks a little thin...

i could spend a lot of time making the logo look awesome...

i would like to make the thickness automatic based on the size...
i would like to do some fading with real colors instead of palette..

done

now patch in the splash screen toggle...

do i have to reload everthing from config?  why not??

mdw_logo and splash screen done...

menu redraws map every frame
this takes time.

when on options menu is not drawn and mdw_ans run much faster...

could i also re-purpose proc_controllers() to do delay?
i could think of my proc_controllers() as my event loop processor...

maybe later...


20180320 6:50

next to do:
help
graphical level select
new menu for all of my option that need setting



20180321 6:55

native file select working...
paths were a bitch.. lots of conversions and checks
full path is used, might break run game from command line...
demo mode has been fixed also

bug in changing scale, leaves artifacts if smaller than entire screen.
fixed, in get new background, clear to color after setting backbuffer..

bug: demo mode can be cancelled with any key except ESC, just starts new demo
run game can be cancelled with any key, make it just esc..fixed
demo timeout not reset..done

figure out how to use code blocks to make a nice backup solution..

20180321 1200

next to do:
help
graphical level select
new menu for all of my option that need setting
timer to make menus run at same speed

help is coming along nicely...
help is completley done...20180321 16:45


next to do:
graphical level select
new menu for all of my options that need setting
timer to make menus run at same speed
some way of saving the screen size...
netplay
overlay screens


20180322 6:50
graphical level select is done..., but...
doesn't work with mouse...never did anyway only keys
cant handle screen size change..fixed
used global Redraw...


20180322 10:00

next to do:
timer to make menus run at same speed
new menu for all of my options that need setting
some way of saving the screen size...
netplay
overlay screens


timer to make menus run at same speed
should I block in proc_controllers() ???
yes but only for menu..

menu timer things is working good now...

next
overlay screens
netplay
new method for all of my options that need setting
some way of saving the screen size...



network


libnet.h
where should i put it? in my local stuff?? why not..seem to work

zlib was found without me doing anything...
comes with mingw..
version 1.2.11, January 15th, 2017

everything compiles because I have NETPLAY undefined....
now I have tons...
replace allegro error with m_err

now everything compiles, i just need the library...

C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a

link with:
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libwsock32.a
C:\Program Files (x86)\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libz.a

compiles and links...

need to fix the timer adjust in client...done...

now I need to fix many, many text lines in overlay...done...

now lunch and some real work...
12:40

hooked up the mouse to the event loop...
used it to make adjust spline work...






tested netplay with i990 server and old version 6 on m7667...worked perfectly..



tried to compile on i990 and dir struct if different
mingw is in C:\al5


i like my i990 version better
codeblocks, mingw and allegro are all in c:\AL5

C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw-w64\i686-7.2.0-posix-dwarf-rt_v5-rev1\mingw32\i686-w64-mingw32\lib\libnet.a


actually i can do better than that:

C:\al5\mingw32\i686-w64-mingw32\include\libnet.h
C:\al5\mingw32\i686-w64-mingw32\lib\libnet.a


compiles on both machines goodly now...



net game works between 2 a5 games

save and load server_ip to cfg file...done


now add screen stuff to logging...


what is screen stuff going to look like now?

same:
sx, sy
scale_factor
show_splash_screen


add:
window x pos, y pos
full_screen


lose
gfx_card
color_depth??
auto_full_screen


-----
done...now save and load them in config..done


now make them work...

what comes first?
init screen or get config?? fixed..

reads on init just fine

save on change

Question about ALLEGRO_FULLSCREEN_WINDOW

I am trying to save the window size and position, so that it will
persist when the game is started again.

Mostly everything is working good, except for a few minor things:

Here is what works:

- I create a display with a certain width and height
- then I let the user resize and move the window
- I save the display size and position in my config file
- It comes back perfectly the next time the game is run


Here is what doesn't:

When I switch to ALLEGRO_FULLSCREEN_WINDOW and back,
the window uses the values that were used to create the display
not the window size that it previously was

I can store my changed position, and then when I change back
- restore the position (easy)
- resize the display (takes a whole other resize)

What I would really like to do, is be able to modify the values
in the display structure, so that switching back, goes to the values
that were there before I switched into ALLEGRO_FULLSCREEN_WINDOW,
and not the ones used when creating the display.


From the manual:

"The passed width and height are only used if the window is switched
out of fullscreen mode later but will be ignored initially."


I suppose I could just destroy and re-create the display, but that
seems like a bit of overkill.


Does anyone have any advice on how I can achieve what I'm trying to do here?


---------------

I have a thought...

instead of changing to fullscreen using the screen thingy
i could just resize it my self to max size...


// moved all the screen change code to one place


variables

display position (relative to desktop)

disp_x_curr (either wind in windowed mode or 0 in fullscreen mode)
disp_y_curr

disp_x_wind (use when restoring from fullscreen)
disp_y_wind

disp_w_curr (either wind or full)
disp_w_wind
disp_w_full



it seems to work, but still takes a while to resize...

now i need a reliable way to get the desktop width and height

how about I create a fullscreen window, grab the w and h then switch out and resize


also my window keeps creeping up....fixed


how can i make reloading bitmaps faster...

store them in memory??

ok


first load puts them in both

next loads from mem to vid...


---------------------------
20180324 0500

cleaned up the screen code a lot
made separate functions to show flags, option, etc..

created temp memory bitmap for reloading..

fill them at creation

sprit player door
doesnt seem any faster

what if i make them all sub_bitmaps and just restore the parent??

first make a video and memory bitmap to store the tiles 640 x 640
then create memory bitmaps with clone_bitmap

seems much faster...

now players and doors...


first....

create them and save them to disk as bitmaps.. just like tiles

what size...


players 19 x 16 = 380 x 320

doors 16 x 8 x 2 = 320 x 320

doors 8 x 32 or (160 x 640)



looking good...

permanently save IN OUT to tilemap..

can I save tilemap??

haven't since a4
done..
my saves now are 24bit bmp and are 3x the old size of 8 bit...


shit is super fast now...



bugs:

resizing display in help, need to reset last line...done

coming out of help, need to redraw menu map
if in game exit, screen change has to recreate the level buffer too.
it should be doing that already...
draw_level..but blocks are gone????
only if screen changed during help...
what does load level do that i don't do...
cant tell...
i know that the bitmaps are getting reloaded...
initl2000 is getting called
l2000 is blank, but why????
at the end of help the target bitmap is cleared....!!!!!
fixed

help screen bitmaps are gone when resized
used global Redraw to fix this...

rtext for lifts..done in game..maybe some in level editor i'll get later

save scaler when changed, i think it is...done

create cfg file if none exists...done



-----------------------------
20180324 0936

coming along real good now...

new to do:
do something with screen size menu thing...not needed

save game...

method to change options...
try menu??

splash_screen_on...dont save the current value
make another called splash_screen_done for current stuff

extern int show_splash_screen;
extern int splash_screen_done;
done..........

bug, when on options menu, change screen then go back to main menu
stuff is getting drawn on level buffer, no l2000
i could make l2000 set cabk buffer back...
but shouldn't other make sure its drawing on right thing??
done.. at start of menu, set target...





ALLEGRO_MENU *menu = al_create_menu();
ALLEGRO_MENU *file_menu = al_create_menu();
al_append_menu_item(file_menu, "Exit", FILE_EXIT_ID, 0, NULL, NULL);
al_append_menu_item(menu, "File", 0, 0, NULL, file_menu);
al_set_display_menu(display, menu);

al_register_event_source(queue, al_get_default_menu_event_source());
al_wait_for_event(queue, &event);

if (event.type == ALLEGRO_EVENT_MENU_CLICK) {
   if (event.user.data1 == FILE_EXIT_ID) {
      exit_program();
   }
}

I have set everything in the menu that I can...
basically only bools...

I would really like to set:
server IP, fuck it, do it from commandline...

works great, except i get random hard crashes...

bug; clear keys at level done

music loop only plays once



lets try it on more machines...

XP???
the procedure entry point _time32 could not be located in the
dynamic link library msvcrt.dll

10...works good...
still get crashes from options menu toggle....


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...

key shifts....



make it so that you can't put the window off the screen

fix the fake keypress mode...

make overlay have an opaque background...done


make it so that you can't put the window off the screen
only on first start...
only in windowed...
done


i see lots of frames skipped but doesnt show on client
need to fix that..shows on overlay...


make run game work from command line..done

finish active player list on run game overlay..done


key shifts done
done for level inc dec
done for speed inc dec
what else is there?? ...log file viewer

blind_save_game_moves(1);
done
now text version...done
now we just need the file selector version :()
done


random hard crashes after using menu toggles
fixed by not creating second display


save_log_file();
log_file_viewer
done
20180324 1039

i have got a lot done today...!!


bug; clear keys at level done
added clear key array to start mode

map..done


screenshot.. done but PRINTSCREEN does not work. had to use PAUSE
fixed

I have been thinking overnight....

I have a couple of big issues...
- speed up the game so it doesn't skip frames
- fix the bug I'm still having about wrong player input...






lets look at the bitmaps i'm using...



first of all the display

display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
---------------------------------

the important stuff is:

ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_COLOR_SIZE:32
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888

now let look at some bitmaps i create like l2000 and level_buffer


pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


lets try creating a display with ALLEGRO_OPENGL
crashed...
ALLEGRO_OPENGL_3_0 starts but both that and ALLEGRO_DIRECT3D_INTERNAL
are listed...

abandon this for now


al_set_new_display_option(ALLEGRO_COLOR_SIZE, 16, ALLEGRO_REQUIRE)

desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
display options
ALLEGRO_RED_SIZE:5
ALLEGRO_GREEN_SIZE:6
ALLEGRO_BLUE_SIZE:5
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:11
ALLEGRO_GREEN_SHIFT:5
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:16
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP
---------------------------------


the bitmaps don't seem to have changed..
the game seems to run faster


can i do a 24??


desktop w:2048 h:1152
display flags:
ALLEGRO_WINDOWED
ALLEGRO_DIRECT3D_INTERNAL
ALLEGRO_RESIZABLE
ALLEGRO_FRAMELESS
display options
ALLEGRO_RED_SIZE:8
ALLEGRO_GREEN_SIZE:8
ALLEGRO_BLUE_SIZE:8
ALLEGRO_ALPHA_SIZE:0
ALLEGRO_RED_SHIFT:16
ALLEGRO_GREEN_SHIFT:8
ALLEGRO_BLUE_SHIFT:0
ALLEGRO_ALPHA_SHIFT:0
ALLEGRO_ACC_RED_SIZE:0
ALLEGRO_ACC_GREEN_SIZE:0
ALLEGRO_ACC_BLUE_SIZE:0
ALLEGRO_ACC_ALPHA_SIZE:0
ALLEGRO_STEREO:0
ALLEGRO_AUX_BUFFERS:0
ALLEGRO_COLOR_SIZE:32
ALLEGRO_DEPTH_SIZE:0
ALLEGRO_STENCIL_SIZE:0
ALLEGRO_SAMPLE_BUFFERS:0
ALLEGRO_SAMPLES:0
ALLEGRO_RENDER_METHOD:0
ALLEGRO_FLOAT_COLOR:0
ALLEGRO_FLOAT_DEPTH:0
ALLEGRO_SINGLE_BUFFER:0
ALLEGRO_SWAP_METHOD:0
ALLEGRO_COMPATIBLE_DISPLAY:1
ALLEGRO_UPDATE_DISPLAY_REGION:0
ALLEGRO_VSYNC:0
ALLEGRO_MAX_BITMAP_SIZE:8192
ALLEGRO_SUPPORT_NPOT_BITMAP:1
ALLEGRO_SUPPORT_SEPARATE_ALPHA:1
ALLEGRO_AUTO_CONVERT_BITMAPS:1
ALLEGRO_SUPPORTED_ORIENTATIONS:0
ALLEGRO_OPENGL_MAJOR_VERSION:0
ALLEGRO_OPENGL_MINOR_VERSION:0
ALLEGRO_DISPLAY_OPTIONS_COUNT:0
pixel format:ALLEGRO_PIXEL_FORMAT_XRGB_8888
ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN
refresh rate:0
tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE
M_tilemap
pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
bitmap flags:
ALLEGRO_MEMORY_BITMAP

exactly the same as 32 bit


OK go back to 16 and lets look at bitmaps


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_ARGB_8888


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
fails to create


al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA)
gets: ALLEGRO_PIXEL_FORMAT_RGB_565
works but has no alpha...duh!

al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA)
fails to create

what if i made l2000 and level buffer 16 with no alpha

that seems to work...

lets test and see the dif..

display 16 or 32
l2000 and level_buffer 16 no alpha


fullscreen 2048x1152
d32 l32  (55-60fps)
d16 l32  (55-60fps)
d16 l16  (58-62fps) slightly better


what is the bottleneck?

is is the huge l2000 to level_buffer each frame??


what if I made that only do a region??
let try and see if it gets faster...

//   al_draw_bitmap(l2000, 0, 0, 0);
   al_draw_bitmap_region(l2000, 0, 0, 1000, 1000, 0, 0, 0);

that got way faster...like 100-110

lets only do it for the section that maps to the screen...



what are SH, SW, WX, WY?

WY, WY are global but are used in
seem to be used only in stimp, stamp, and get_new_screen_buffer

SW, SH
used locally in set_scale_factor, get_new_screen_buffer, stimp and stamp


make global to tell what region on l2000 is currently being shown

call them:

int level_display_region_x;
int level_display_region_y;
int level_display_region_w;
int level_display_region_h;

that seems to be a lot faster

map on menu is messed

set in stimp and stamp

no, unless in a game do it all..

use game_exit?? yes

this all seems great and seem a lot faster

lets test...



speed test
ill need to redo it...
i should just run it wide open and manually adjust the screen to start...

nv59 starts out fullscreen 1600x1200 at >100fps then drops to less than 40 in 15s
sometimes jumps to 80


nv59 sp  w 200 drops to 100
nv59 sp  f 80 drops to 35

nv59 demo w 60 drops to 35
nv59 demo f 20

i990 sp   600w 100f
i990 demo 180w 72f

m7667 can do 386 fps in a window!!! and 200 fullscreen

eid can do 800 in windows and 400 fullscreen

demo mode why slower???

disabled all screen overlays, should not be that..
disabled rungame_key_check()
changed proc_game_move() look back thing
all no diff

going back...

I have a new idea about speed test.

run game, or demo and record fps every second

then adjust screen resolution on the fly...

make a pretty graph...


name and screen resolution in screen title...done

make get new background get a little larger..done
what order is stuff drawn in??


log file viewer file select
make a new file... zlog.cpp
do it....done....


redraw map when leaving controller menu
test keys...fixed...


bomb's explosion animation seq is too low, center it better
looks good to me...








level_editor

bring in the files...e_editor

coming along goodly....


status window creates new bitmap every time its drawn
make it draw itself every time...
now dont need code to draw its bmp or even its bitmap...


status and select window are now perfect...
1 day later even more perfect...
removed all bitmaps they draw on.
only one function for each, draw and process
disable resizing of blocks and special sub windows


moving on...


pop up menu is transparent..make background opaque...done


next...zoom full screen...

looking good...
i can copy and paste

file stuff disabled for now

screen size change messes with text button positions

clear disabled until erase lifts brought back..done

blocks on off not updating fsel?? looks good now...


new backup

20180328 0700




should I make my own file select dialog?
I hate the way the native windows one looks...

i would have to implement a list box...

what if I just make a wrapper for the gui so i can call it in one line_draw_modelike I used to:

      FILE *filepntr;
      extern char sel_filename[500];
      sprintf(sel_filename, "sel\\");
      if (file_select_ex("Save Selection", sel_filename, "sel", 500, 0, 0))
      {
         filepntr = fopen(sel_filename,"w");




re_implement file_select_ex as
mw_file_select(const char * title, char * filename, const char * ext, ALLEGRO_COLOR col);

works great, add option save  and force extension..done..

i could re-do my file access to use the allegro methods...maybe when I've got too much time on my hands...


re do it for rungame save...no that has a special case where i only need the filename and I add my own extensions .gm and .txt

OK whats left in zoom full screen???

random...done

brf...done...

look like zoom fullscreen is totally done..

so is everything in e_editor...

next ...

viewers...will be huge...

but first:

status and select window positions when screen changes

where does db and lefsm get changed when screen size changes??
all done in set map var...

after screen resize items and enemies are gone?
try draw big..


backup...
20180329-0700



object viewer is looking very good
map move too...



--------------------
20180330 0700

item viewer
creators
pop message editor
save and load
all done

next big thing...lifts


lifts is all done except for text...

replace all alert with native msg...


//      gui_fg_color = palette_color[14];  gui_bg_color = palette_color[14+224];
//      alert("Error creating lift step:", (char)NULL, "40 steps is the maximum", "OK", (char)NULL, (char)NULL, (char)NULL);
//      gui_fg_color = palette_color[9]; gui_bg_color = palette_color[0];

         al_show_native_message_box(display,
               "Error", "No creator exists for the current item type",
               "Copy from an existing item of that type, or get one from the selection window",
                NULL, ALLEGRO_MESSAGEBOX_ERROR);




now alert3

if (alert("Move the key's", "block range also?","","Move", "Leave", 'M', 'L')==1)

if (al_show_native_message_box(display,
               "Move?", "Move the key's", "block range also?",
                NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION );


if (al_show_native_message_box(display,
            "Move?", "Move the key's block range also?", NULL, NULL,
             ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)




level viewer is mostly done...

it used a trick where the grid was not redrawn

in order to make it work now, i'll need a temp bitmap
what size...?? 1000 x 1000

e_lev is all done:

next to do:

text input for lift...


glt is totally done too...


the only files that are not back in the project are:
e_bitmap
e_guifnx
and they will probably not come back....
pde is mostly disabled too...



kill all scrn_buffer...
153 refs...
all done except for some unused re-size code in special
also fix all clips..



draw pop message on item viewer leaves artifacts
but only when switching from one message to another
why does it not redraw then?
as far as i can tell, it should redraw every frame..

it was because draw pop message set target to something else


sproingy adjust...done
crosshairs line 16 inside rect
928 for highlighted rect
text entry box done!!!


help quits to far..trap esc or mouseb...done

make screen adjust work with level editor and les
looks good in zfs, obj and lift viewers...

make les adjustable in le done

used F2, same as speed testing in game

I need a variable to tell me if i'm in the level editor

level_editor_running done

mouse off map in main editor...done





lots done over long weekeknd

new backup...
20180401 1025

mouse shown during game and menu screens...done
make save level have filename automatically filled in...done



I am new to the whole blender thing and have spent many hours trying
to figure out what I though would be a simple task.

I am trying to draw a bitmap onto the backbuffer and blend it with the
backbuffer.

This code from the examples works great:

al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

But my source bitmap has an alpha channel, and I can't figure out how
to get that respected...no matter how many different combination I try
I always get the zero pixels blended also.

I have tried al_set_separate_blender with many different combinations
and gotten nowhere.

I have read the docuemntation many times, and looked at other explanations
of blending of the web.  But I can't seem to make it work.


<code>
// this draws a background of colored squares
   ALLEGRO_COLOR c[5];
   c[0] = al_map_rgb(255, 0, 0);
   c[1] = al_map_rgb(0, 255, 0);
   c[2] = al_map_rgb(0, 0, 255);
   c[3] = al_map_rgb(255, 255, 255);
   c[4] = al_map_rgb(0, 0, 0);

   al_set_target_backbuffer(display);
   al_flip_display();
   al_clear_to_color(al_map_rgb(0,0,0));

   int ci = 0;
   for (int y=0; y<10; y++)
      for (int x=0; x<10; x++)
      {
         al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, c[ci]);
         if (++ci>2) ci = 0;
      }



// this is the bitmap I am drawing
   sprintf(msg, "Test") ;
   int sw = strlen(msg) * 8;
   ALLEGRO_BITMAP *temp = al_create_bitmap(sw, 8);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));
   al_draw_text(font, ci[3], sw/2, 0, ALLEGRO_ALIGN_CENTRE, msg);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0));


// here is where I have tried just about every blender combination I can think of

   al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
   al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);



// this is where i actually draw  it
   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temp, sw/2, 4, 88, 48, 4, 4, 0, 0);
   al_flip_display();
   al_destroy_bitmap(temp);

</code>


When I don't specify any blender I get a nice masked text over background.

When I try this:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0.5));
al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);

I get a nice blended source and dest, just like what I wanted,
except the alpha is not respected and I get a rectangle around the text.


I tried:
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 0));
al_set_blend_color(al_map_rgba_f(0.5, 0.5, 0.5, 1));
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
but they all made no difference.

I tried:
al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);

al_set_blend_color(al_map_rgb_f(0.5, 0.5, 0.5));
al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR, ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_ZERO);

plus many more combinations, but I can never get the alpha mask to work...

Can anyone with more experience with blenders help me?

Do I somehow have to do this with 2 steps?

My overall goal is simply to have a partially transparent bitmap superimposed over
another bitmap (the backbuffer), (kind like a water mark), but I want it masked so the
zero pixels are not blended with the background.




pixel format:ALLEGRO_PIXEL_FORMAT_ARGB_8888
pixel format:ALLEGRO_PIXEL_FORMAT_RGB_565




looking at different fonts..

great vibes is a free calligraphic font I might use for logo
by typesetit
licensed under OFL

I should make my own larger text display function

it purpose to display very large text based on screen and font size
one and two line versions



for a few days now I have been working with ttf

I have a nice new script font I'm using for ichael avid eiss

It's called 'Great Vibes'
by: typesetit
license: OFL

I also like:
SaucerBB.ttf
but it only free for non-commercial use..
It looks good as my main logo..


I have replaced mtextout() with a similar function
mtextout() was slow, so the new one uses pre-draw bitmaps
for ichael avid eiss
seems a lot faster...

I moved all code for logo and splash screen to its own file: zlogo.cpp

I think I am finally happy with the beginning splash screen

now I want to redo demo mode...

its too slow to draw the large text every frame
I could make another temp bitmap like the others...done...

what am i doing?

I am spending a lot of time making fonts and stuff look pretty...

when will it end???

to do:
-width of splines smooth change
-splash screen to not flash when quitting
-new title with new font

all this is done

predefined enemies editor..done


map not redrawn completely,
probably due to not drawing all of level buffer...
yes...lets disable map
just at the function key level...





orthographic stretch during game, and or menu screens
move to F11
choose another key for controller test exit other than F11
auto choose ortho based on screen size
maybe I could make othro strecth CTRL SHIFT F12
done...


now make les auto chosen based on screen size...

where??
init screen
also screen change

make a seperate function

set_display_transform_double()


how?


rebuild bitmaps does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;
   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


init screen does this:

   SCREEN_W = disp_w_curr/les;
   SCREEN_H = disp_h_curr/les;


   ALLEGRO_TRANSFORM trans;
   al_identity_transform(&trans);
   al_orthographic_transform(&trans, 0, 0, -1.0, disp_w_curr/les, disp_h_curr/les, 1.0);
   al_use_projection_transform(&trans);


why dont i put that in set_les


need a function to set ortho
called by init and change

make set_les do auto


rebuild does
set ortho

init does:
auto_set_les();
set_ortho();

change does:
auto_set_les();
rebuild
( set_ortho(); is done in rebuild bitmaps)

F12 does
rebuild

this works...

now to auto set
never auto choose 3

SCREEN_W > 1024 les = 2

looks good in game, but level editor??

does scale change with les??

it should...done
but when its saved with a different les???
its good


demo mode
resize
fullscreen...
goes really slow and no title..
2 resizes...
only in demo mode
fixed..font not destroyed before recreate



do I need to load fonts at 400??
what does 200 look like?
"saucer"
used for:
main tile Purple Martains
main title created by
menu title
level done
demo mode
240 is good enough

"a charming font"
used for ichael avid eiss
240 is good


locked exit to show number left


bottom display to not conflict with frame display (mostly in demo mode)
moved up BORDER_WIDTH



m7667 resize ok but going in or out of fullscreen causes exit when client
do I still have F12 exit key in client??
yes in 4 places...change to F11 for now
done....



client quits game, but freezes locally..
walk me through the sequence of client quitting
client presses ESC
client local control gets comp move of 127 and sends cdat to server
server add to game move array
in add game move special move exit is entered instead of escape
player state change to incative
in proc game move for local client become inactive...
this is the problem:
while (key[ALLEGRO_KEY_ESCAPE]); // wait for release, but send cdat first
do i even need this???


no mouse for options menu..fixed
restore full screen mode when leaving options toggles..done


log file viewer les...done




level viewer won't load good
keeps saying cant find file...400 times
fixed...



simplify num_enemy
int num_enemy in main in pm.h
counted in game in enemy collision
counted in level editor in sort_enemy
only only enemy_data now, no duplicate in lev

same for items..done



start level editor from command line
les is bad fixed


make my own option setting screens with my own sliders and buttons

netgame server text
deathmatch_pbullets_damage slider

I could do it with the menus that I have now..
make netgame menu...done
call it from old menu toggles..
done...
now implement the toggles
in config load set the menu values...done
edit and change with menu
this is all done....yay!!!
now if I do logging I can kill the stupid toggle menu...
done....!!!!
kill it!!!!

number pad keys to work in help...done

fix logo in help..done

when ortho changes
help divider lines off screen...fixed

close holes in menu
-bitmap editor is all that is left
do I still have release in pm.h??

Random mode in zfs
menu in editor
fake keypress mode
copy files to clients
packet test
log file viewer
temp test -g
record video
debug overlay for client and server






---------------------------------------------------------
should I make my background totally black?
---------------------------------------------------------
modify shapes 0-32 to remove really light pixels?
how could i do this??
save_sprit() is still there just commented out
load, modify, save...done


---------------------------------------------------------
what if my whole drawing routine is too complicated
---------------------------------------------------------
right now:
I have l2000 with all the blocks and lift lines drawn
every frame I start with this and copy it to level buffer
then all objectrs draw on the level buffer
then i take a screen sized region of the level buffer and copy it to the backbuffer
then I draw overlay on that
then finally I flip display

how many target bitmap changes: 2
switch to level buffer
and get new background
draw on level buffer
switch to screen buffer

how could i make it easier??

draw background directly on backbuffer from memory bitmaps
draw objects directly on backbuffer
draw overlay
flip

or...

draw background directly on backbuffer from l2000 (just like get new screen buffer)
draw objects directly on backbuffer (just need to change offsets)
draw overlay (same)
flip

test this and see if its faster...
made 1 change in get_new_screen_buffer()

i just realized, i have scaling going on too
i cant just switch from drawing on level buffer which is unscaled
to screen buffer, which is...fuck it, i'm not doing this




speed testing...

while speed testing use number keys to disable stuff to see the
performance hit

get_new background
screen meassges
bottom messages

show fps independent of overlay

wow, i got somewhere!
I found that bottom msg slows stuff down...
on nv59 it down a lot....


make the keys active at any time, not just speed test
show when something is disabled only

test big netgame...


it gets a lot faster when screen and bottom msg are disabled..

I should see if there is some way to optimize them..

like not using temp bitmaps...
like not drawing as many of them..
player health screen messages could be only for local player not all

basically i dont want to switch my target bitmap during game loop
and all of my fancy text routine do that...

what about screen overlay? should be just straight text...yes
what about percent bar?? no switch...its good

move show_player_join_quit to loop for disabling...
if (show_player_join_quit_timer) show_player_join_quit();
done

disable by default: 3 4 5 ...done

test some more...

what if i evened out frame skip
like every other farem, or every 3 or 4 frame...etc
why?  if one frame is slow wont they all be??


what if i made the fancy text drawing stuff off when frames skipped?

profile the text drawing stuff...
in game loop make a function that draw 100 rtext things to screen every drame

change health display to show +H or -H
use regular text

found a very small font called: pixel gosub
"Pixel Sagas" and "Neale Davidson" may be used interchangeably in this agreement. These all refer to the intellectual and legal property of Neale Davidson.
Usage
Pixel Saga's Shareware Fonts are free to use for personal, non-commercial purposes. No payment is necessary to use Pixel Saga's Freeware Fonts for personal use, and there is no limit to the amount of prints, pages, or other medium to be produced using them. However, you cannot offer the font for commercial sale, or offer for direct download. The inclusion of the font name and/or site URL in the credits or documentation when it is used is appreciated, but this is not mandatory.

is is otf but loads fine
i load with size 7
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", 7, ALLEGRO_TTF_MONOCHROME);
f3 = al_load_ttf_font("bitmaps/PixelGosub.otf", -8, ALLEGRO_TTF_MONOCHROME);
these both look good
its looks like 3x5 on the screen

ok now I never need screen message...


how about bottom display
i like how it looks...
but so what?, if its slow it needs to go...
fixed...

in draw player health display all is good...

in bottom message all is good

screen message, disabled

all that's left is join_quit..lets leave it

lifts use rtextout_centre()...
but only in vertical mode
its rare enough i'm going to leave it for now

speed seems good now across all clients except nv59
but nv59 has always had issues...

what if i did nv59 in a desktop screen size
less than the huge 1600x1200 i have been using??





---------------------------------------------------------
hysteresis window does not work
---------------------------------------------------------
always stuck to lower right corner
WX and WY needed to persist
made it a global again
bug happened after I made it local..



---------------------------------------------------------
------------------------ linux --------------------------
---------------------------------------------------------

got it to compile and run..

complains it can't create built in font

also can't load a4.tga

gcc version 5.4.0
allegro version 5.2.5??

i'm editting in 2 places at once
thats a recipe for disaster...

edit only on linux for now

the second crash was that I couldn't create a 16 bit display
fixed that...

splash screen has no large Purple Martians but has created by??
same font??
logo works
crashes a soon as splash screen done..

i'm running into max bitmap size

it says it 2048

when I create the title its close...

2090 one time
2034 another timeval
why the fuck is it different???

I don't know...

I would like the title as high a resoultion as i can...

'Purple Martians!' is 14 char

take max bitmap size and divide by 16

2048/16 = 128

8192/16 = 512


changed the load font function to create saucer font by
max bitmap / 16

also changed load built in font to try a4_font.bmp if it fails

left achafont at 240...
what's its max length?  'ichael' 6 char

2048/6 = 341
8192/6 = 1365
just leave at 240 for now...looks good...


as far as the display bit depth, i'll try 16 "SUGGEST"
works on linux just fine, gets 32 bit...


on linux the built in font seems to work now that I have a display...


its really slow

linux:
32 bit
opengl
render method: 2
max bitmap size: 2048
support seperate alpha: no

win:
16 or 32 bit
D3D
render method: 0
max bitmap size: 8192
support seperate alpha: yes


no matter what I disable, linux runs at 60fps

2 things..

downgrade allegro to 5.2.4..done
get gcc-7..done
rebuild allegro with gcc-7...

that made exactly no difference...


I tried opengl on windows and I got exactly 60fps also...

its the exact same as the desktop refresh rate..
I changed the desktop to 40 and my game followed...

try open gl 3

sudo apt-get install mesa-utils

glxinfo | grep "render string"


open_gl
seems to wait for vertical retrace before doing al_flip_display()

u swap method:0 same as w

w render method:0
w vsync:0

u render method = 2
u vsync:0

none of this works...
vblank_mode=0  (from command line)

GLX_EXT_swap_control
GLX_MESA_swap_control

moving on......

l seems to not change screen zize nicely..
in control...make sure all resize event are received before actually resizing

when switching away from fullscreen mode
sizes all look good, but still fullscreen??

in linux i try to set to fullscreen but get slightly less???


on the plus side, it looks like everything else is working good in linux

all that i need to figure out is the open gl stuff
with fullscreen, resizing, ortho, les, etc...


init screen
fullscreen:0 les:1
x:  10 y:  10 w: 800 h: 600 - curr
x:  10 y:  10 w: 800 h: 600 - wind
x:  10 y:  10 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
----------------------------------
Display change
x:  43 y:  47 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  43 y:  47 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:   0 y:   0 w: 800 h: 600 fs:1
changed to fullscreen
fullscreen:1 les:2
x:   0 y:   0 w:1280 h:1024 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 640 h: 512 - scrn
Display change
x:   0 y:   0 w: 640 h: 512 fs:0
changed away from fullscreen
fullscreen:0 les:1
x:  43 y:  47 w: 800 h: 600 - curr
x:  43 y:  47 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w: 800 h: 600 fs:0
window moved
fullscreen:0 les:1
x:  35 y:  18 w: 800 h: 600 - curr
x:  35 y:  18 w: 800 h: 600 - wind
x:  35 y:  18 w: 800 h: 600 - disp
0:   0 0:   0 w: 800 h: 600 - scrn
Display change
x:  35 y:  18 w:1245 h:1006 fs:0
window resized
fullscreen:0 les:2
x:  35 y:  18 w:1245 h:1006 - curr
x:  35 y:  18 w:1245 h:1006 - wind
x:  35 y:  18 w:1245 h:1006 - disp
0:   0 0:   0 w: 622 h: 503 - scrn


what if I tried ALLEGRO_FULLSCREEN_WINDOW....



this could be happening:

fullscreen mode is set
linux change to slightly less than fullscreen
my proc_screen_change() has no case to deal with this...

I should update the full screen sizes




ripped out all the custom fullscreen window shit
now it works good in win and lin except for
lin background wrong size??

fullscreen and back OK, only when resize...


l2000 get drawn wrong after resize and I don't know why
code is just about identical...

when I am setting ortho, I need to make sure i'm setting it for the backbuffer...problem solved


the good thing is that almost everything else works great..


lin window moves down 21 pixels, every time fs on/off







---------------------------------------------------------
------------------------ Static Linking------------------
---------------------------------------------------------
why?
so i dont have to distribute dlls with my project?

my method now (dynamic)

link with allegro_monolith-5.2

I need to distribute with executable:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

my exectutable is (3,209K)

total: 20,089K

what do I need to do static linking?

build allegro with static linking



From Neil:
https://www.allegro.cc/forums/thread/617338
In Code::Blocks, I use "allegro_monolith-static".

For my linked libs, I have (copy and pasted from my codeblocks project file). Maybe this will help...

<Linker>
   <Add option="-m32" />
   <Add option="-static" />
   <Add option="-static-libgcc" />
   <Add library="mingw32" />
   <Add library="dumb" />
   <Add library="FLAC" />
   <Add library="vorbisfile" />
   <Add library="vorbis" />
   <Add library="freetype" />
   <Add library="ogg" />
   <Add library="physfs" />
   <Add library="png16" />
   <Add library="zlibstatic" />
   <Add library="gdiplus" />
   <Add library="uuid" />
   <Add library="kernel32" />
   <Add library="winmm" />
   <Add library="psapi" />
   <Add library="opengl32" />
   <Add library="glu32" />
   <Add library="user32" />
   <Add library="comdlg32" />
   <Add library="gdi32" />
   <Add library="shell32" />
   <Add library="ole32" />
   <Add library="advapi32" />
   <Add library="ws2_32" />
   <Add library="shlwapi" />
   <Add library="dsound" />
   <Add library="jpeg" />
   <Add library="opusfile" />
   <Add library="opus" />
</Linker>

From wiki:
https://wiki.allegro.cc/index.php?title=Windows,_Code::Blocks_and_Allegro_5

-lallegro_monolith-debug-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlibstatic
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-static-libstdc++
-static-libgcc


compile allegro with shared off


this is my cobeblock project file:

<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="default">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-pg" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add library="C:/mingw32/lib/liballegro_monolith.dll.a" />
			<Add library="C:/mingw32/lib/libnet.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libwsock32.a" />
			<Add library="C:/mingw32/i686-w64-mingw32/lib/libz.a" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>


static version   liballegro_monolith-static.a

dynamic version  liballegro_monolith.dll.a

in build options tried moving from lefthand side with full path
to right hand side like this:

old:
C:\mingw32\lib\liballegro_monolith.dll.a
C:\mingw32\lib\libnet.a
C:\mingw32\i686-w64-mingw32\lib\libz.a
C:\mingw32\i686-w64-mingw32\lib\libwsock32.a
new:
-lallegro_monolith.dll
-lnet
-lzlib
-lwsock32
worked...




<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<CodeBlocks_project_file>
	<FileVersion major="1" minor="6" />
	<Project>
		<Option title="pm" />
		<Option pch_mode="2" />
		<Option compiler="gcc" />
		<Build>
			<Target title="dynamic">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-lallegro_monolith.dll" />
					<Add option="-lnet" />
					<Add option="-lzlib" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
			<Target title="static">
				<Option output="pm" prefix_auto="1" extension_auto="1" />
				<Option object_output="o" />
				<Option type="1" />
				<Option compiler="gcc" />
				<Compiler>
					<Add option="-Wall" />
					<Add option="-pg" />
					<Add option="-Og" />
					<Add option="-g" />
				</Compiler>
				<Linker>
					<Add option="-pg -lgmon" />
					<Add option="-static-libstdc++" />
					<Add option="-static-libgcc" />
					<Add option="-static" />
					<Add option="-lallegro_monolith-static" />
					<Add option="-ljpeg" />
					<Add option="-ldumb" />
					<Add option="-lFLAC" />
					<Add option="-lfreetype" />
					<Add option="-lvorbisfile" />
					<Add option="-lvorbis" />
					<Add option="-logg" />
					<Add option="-lphysfs" />
					<Add option="-lpng16" />
					<Add option="-lzlib" />
					<Add option="-ldsound" />
					<Add option="-lgdiplus" />
					<Add option="-luuid" />
					<Add option="-lkernel32" />
					<Add option="-lwinmm" />
					<Add option="-lpsapi" />
					<Add option="-lopengl32" />
					<Add option="-lglu32" />
					<Add option="-luser32" />
					<Add option="-lcomdlg32" />
					<Add option="-lgdi32" />
					<Add option="-lshell32" />
					<Add option="-lole32" />
					<Add option="-ladvapi32" />
					<Add option="-lws2_32" />
					<Add option="-lshlwapi" />
					<Add option="-lnet" />
					<Add option="-lwsock32" />
				</Linker>
			</Target>
		</Build>
		<Compiler>
			<Add option="-Wall" />
			<Add option="-pg" />
			<Add option="-Og" />
			<Add option="-g" />
			<Add directory="C:/mingw32/include" />
		</Compiler>
		<Linker>
			<Add option="-pg -lgmon" />
			<Add directory="C:/al5/allegro-i686-w64-mingw32-gcc-7.2.0-posix-dwarf-dynamic-5.2.4.1/allegro/lib" />
		</Linker>
		<Unit filename="docs/new5.txt" />
		<Unit filename="docs/new5_todo.txt" />
		<Unit filename="src/e_editor.cpp" />
		<Unit filename="src/e_fnx.cpp" />
		<Unit filename="src/e_glt.cpp" />
		<Unit filename="src/e_item.cpp" />
		<Unit filename="src/e_lev.cpp" />
		<Unit filename="src/e_menu.cpp" />
		<Unit filename="src/e_nev.cpp" />
		<Unit filename="src/e_nlv.cpp" />
		<Unit filename="src/e_pde.cpp" />
		<Unit filename="src/e_sel.cpp" />
		<Unit filename="src/e_sliders.cpp" />
		<Unit filename="src/e_special.cpp" />
		<Unit filename="src/n_client.cpp" />
		<Unit filename="src/n_client.h" />
		<Unit filename="src/n_network.cpp" />
		<Unit filename="src/n_network.h" />
		<Unit filename="src/n_packet.cpp" />
		<Unit filename="src/n_packet.h" />
		<Unit filename="src/n_server.cpp" />
		<Unit filename="src/n_server.h" />
		<Unit filename="src/pm.h" />
		<Unit filename="src/yfilecom.cpp" />
		<Unit filename="src/zbullets.cpp" />
		<Unit filename="src/zcontrol.cpp" />
		<Unit filename="src/zemove.cpp" />
		<Unit filename="src/zfile.cpp" />
		<Unit filename="src/zfnx.cpp" />
		<Unit filename="src/zitem.cpp" />
		<Unit filename="src/zlifts.cpp" />
		<Unit filename="src/zlog.cpp" />
		<Unit filename="src/zlogo.cpp" />
		<Unit filename="src/zloop.cpp" />
		<Unit filename="src/zmain.cpp" />
		<Unit filename="src/zmenu.cpp" />
		<Unit filename="src/zplayer.cpp" />
		<Unit filename="src/zscrn.cpp" />
		<Unit filename="src/zsound.cpp" />
		<Extensions>
			<code_completion />
			<envvars />
			<debugger />
		</Extensions>
	</Project>
</CodeBlocks_project_file>







Having trouble with static linking

I am new to static linking, have always used dynamic with no problem.
Thought I'd try it.

 - First of all, what are the advantages of static vs dynamic?

 - Second, what extra files do I need to include with my game?

With dynamic it seems I need:
allegro_monolith-5.2.dll (15,218K)
libgcc_s_dw2-1.dll (112K)
libstdc++-6.dll (1,504K)
libwinpthread-1.dll (46K)

I don't know what static will require as I havent been able to get it working yet.


I am using:

mingw-w64
Version:7.2.0
Architecture:i686
Threads:posix
Exception:dwarf
Build revison:1

Allegro 5.2.4 (from source)

Code::Blocks 17.12


I built both the dynamic and static monolith debug release versions of allegro

The only thing I did different for static was uncheck the SHARED flag in CMake

I changed the linker library list from:
-lallegro_monolith.dll
-lzlib
-lnet
-lwsock32

to:
-lallegro_monolith-static
-ljpeg
-ldumb
-lFLAC
-lfreetype
-lvorbisfile
-lvorbis
-logg
-lphysfs
-lpng16
-lzlib
-ldsound
-lgdiplus
-luuid
-lkernel32
-lwinmm
-lpsapi
-lopengl32
-lglu32
-luser32
-lcomdlg32
-lgdi32
-lshell32
-lole32
-ladvapi32
-lws2_32
-lshlwapi
-lnet
-lwsock32

I also set these compiler flags:
Static libgcc [-static-libgcc]
Static libstdc++ [-static-libstdc++]
Static linking [-static]



My project compiles, links and runs fine with dynamic linking.
But I am getting linker errors when I try static.

There seem to be 2 things linker can't find:

fixed point routines in fmaths.inl:
C:\mingw32\include\allegro5\inline\fmaths.inl|46|undefined reference to `_imp__al_fixtorad_r'|

and opus stuff:
C:\devel\Allegro5\addons\acodec\opus.c|102|undefined reference to `op_free'|


I am lost here.  I don't know how to fix these errors.
I barely understand how I got this far...


Any advice on static vs dynamic as it applies to Allegro would be greatly appreciated.

Do I even want or need to do this?
Should I just use dynamic and not worry about static?

I needed to compile with -DALLEGRO_STATICLINK


now everything is in the executable...
pm.exe 17,084K and needs nothing else

later i may try to trim out things i dont need...


level editor les
main is good in les=1
but zfs and viewers don;t get there until i cycle with F12
probably set map var...
actually instead of running ortho, run rebuild_bitmaps()..fixed


---------------------------------------------------------
bug pop-up message viewer on linux has extra blank line at end
---------------------------------------------------------

I looked at the string and there is an extra 13 at the end
but only on linux????

I changed to read files in binary mode and it seem to work the same in both now...
no it doesn't....

what the hell is going on??

in windows \n is 10 and \r is 13

it look like my file reading stuff uses \n (10) as a seperator

for messages why don't i just leave 126 as my newline

lets revert back...done

went back to opening in 'r' mode
now i dont do any messing with converting, i just leave 126 as my newline
works same in linux, but now I get ^ at end of text

when I load text, ignore 13...

this seems to work now...


lets look at the editor..its good too...

this is all done



when players health is clamped past 100 it generates a - health display
fixed....







i'm losing keypresses
like F12 key up...
in control i'm trying to filter multiple resize events
is it needed in linux...yes..

redid the control loop, seems to work good now...



can't quit demo mode
fixed



icons...

what does allegro say...

in windows I have one for the window and in the taskbar

I made a file called icon.rc
#include <windows.h>
allegro_icon  ICON  bitmaps/pm.ico
added it to my project and that's literally all it took!!!

what about linux...

the function:
al_x_set_initial_icon(tmp);
is supposed to be called before you create the display
need to include:
#define ALLEGRO_UNSTABLE
#include <allegro5/allegro_x.h>
and the fucntion will not be found on a windows system
but after all that it doesn't seem to do anything...
I made a pm.desktop file in ubuntu
you can specify an icon in that..
not sure how usefull that will be...





after playing a netgame for 3 level dones
server player is getting random moves..

this bug is hard to reproduce...


could it be something to do with re-joining after level done??


reproduced on 8  player game after a loooooooonnnnnggg time
level 12 about 50 frames in


i had logging on!!!

server log file:20180418-165728.txt
17,746 KB
313400 lines
16897 frames
/ 40 = 422 seconds
/60 = 7 minutes

log file starts at level 5
and ends on level 5 7 minutes later...
wtf??
where are the rest of my logs!!!?????

does the passcount not reset??

--------------------------

level 14 approx 100 sec or 4000 frames

20180418-185448
5,501KB
98,894 lines
4830 frames

looks like there were only 6 players that joined
player 7 did not
i have stats for player 7 at the end but no name at the top...weird

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 y510
p5 eid
p6 e6410
p7 m-4230-3


could be my log file viewer....tis...
fixed that, now I have all 7 clients

moving on...

cant see anything on the server that would explain it

looked on client nv59, but its lin and even though i copied
i had old version cause its not compiled...

i'll need to look on a windows machine..
looked on pfv...found nothing
looked on y510...found nothing

looked on e6430:
file: 20180418-185448
it looks like a server file...wtf

----------------------------------------------------------

try to reproduce again


did it again...
level 14 100 frames in
when i took player nv59 off F1 mode
20180419-043626

p0 i990
p1 nv59
p2 pfv
p3 e6430
p4 eid
p5 e6410
p6 m-4230-3
p7 y510


notes:
end of level player array on nv59
server is mode 9??
at start server is mode 2
looks like they are all like that...


p0 i990
p1 nv59 ns
p2 pfv ns
p3 e6430 ns
p4 eid ns
p5 e6410 ns
p6 m-4230-3 ns
p7 y510 ns

none are pretending to be server...

what now??

is the corruption on the server and just propogated backtop the clients?
i'm thinking thats the case...
because if it wasn't i would be getting lots of stdf corrections
and i'm not

what can i do now??

look more closely at when cdats are rx'd

nv59
got game move on 2556 from server frame 2557
that i am pretty sure he did not send a cdat for...
actually thats not true...



------------------------------------

did it again

this time all players were acting weird even after i stopped f1 modes

lev 14 frame 42-50 on pfv was where i first noticed it...
20180419-060449

nv59 log
no moves received from server that were not sent by cdat
looks like f1 fake mode was stopped at frame 921

then manual keys pressed at
1022
1031

that does not match up with what i saw...
i get no game moves received for player 1 from 925 to 1022
then 5 manaul move from 1022 to 1098
then nothing until
5 manual moves from 1272 to 1285
then nothing until 8000 with fake mode again
ended with 12 stdf corrections

i got nothing....
why is it so fucky??

should i look in game moves??
compare server and client?

not until moves gets to 16000 or so on level 14


got another
level 14 around 40-50
look in game moves

on m-4230-3 at frame 1576 stopped f1 mode
then only got a few manual keys
1607
1651
1689
1710
1734
1783
so there should be no player 1 entries in game move after that
i don't see any on the server's game move





tried again this time only level 13 then 14

did not happen until 180 sec into game

what is getting counted up to???

game moves look identical

is it because how i am reading from the game moves array....

how can i check this...


what reads the game move array...

proc_game_move()
run once per frame
uses to iterate and or search



and this is run once per frame for each player

// common for all players;  get controls from game_move
int found = 0;
for (int g=game_move_entry_pos; g>0; g--)  // look back from entry pos
   if ((game_moves[g][1] == 5) && (game_moves[g][2] == p)) // find first that matches type and p
      if (game_moves[g][0] <= passcount) // check to make sure its not in the future
      {
         found = 1;
         set_controls_from_comp_move(g);
         game_move_current_pos = g; // for savegame running only
         g = 0; // break out of loop
      }
if (!found) clear_keys(p); // if no match found


game_move_entry_pos


there is a global, and there is also one in players1 struct

53 matches in total..

i should un ambiguate this....

int game_move_entry_pos; (global variable)
- used to keep track of the entry point of the game move array

when a new game move is put in the array this is used
there should only be one way a new game move gets put in the array
add_game_move()
server calls it 6 time..
loop calls it twice when loading annd starting a new level
control call it twice
once for level done
once in single player local control

int game_move_entry_pos; (global variable)
- also used as a start point when reverse searching game_move array
like in proc_game_move() and when player gets move from game array

when do i reset it..


I THINK I FOUND SOMETHING!!!


if (start_mode != 2) // skip this when start_mode == 2 ; run game
{
   // reset game_move array
   for (int x=0; x<10000; x++)
      for (int y=0; y<4; y++)
         game_moves[x][y] = 0;
   game_move_entry_pos = 0;


i am only erasing the first 10,000 entries.....
its actually 1,000,000 now

10,000 / (7 moves per frame * 40 frames per second)
= 35 seconds

1,000,000 / (7 moves per frame * 40 frames per second)
= 58 minutes (at max keypresses per second)

log file name to have level and hostname..done

client log file to have full player array at end...done

start of log file after level done to have header with
hostname and player array..done

change game move logging (which is client only)
tag the logged move with the player it is for...
right now its tagged with the active local player...



what is client sync error that keeps showing up on clients?
when a client gets game moves with passcounts in the past
that will never be processed
its bad, but stdf will fix it..
lets not have that show, except in debug overlay..done



---------------------------------------------------------
in order for save game to play back correctly
they need to have the same values for pbullets, etc...
---------------------------------------------------------
save as 3 ints at start of gm
restore after by loading config
modified gm and txt save
modified gm load..
modified existing demos
added 1 5 1...
in demo mode and run game restore after...done
this should be done



make some automated post build setup stuff...

make a folder called pm_win_release

can i do it from the command line..
all i really want to do is copy stuff...

made a windows batch file that does what i want....

to make a windows release...

set version number in code and in help file
define pm_release

compile the project with win_static_release build target
run the batch file
zip and rename

how can I static build in linux
too complicated...

compile
run bash file
compress

make some more stand alone text files, like
setting up dev env on win and lin



death animation??
enemies have them, why not for player??

editing timeset with gimp

image->configure grid
view-> show grid
view-> snap to grid
view-> snap to canvas edges

file->overwrite (save back in same format)

to make a proper death animation seq
it will have to be for each player's color ....

what if I just do a shrink, rotate, and draw item disapear ans...

where would I do this??

at the end of player move, do the shrink and rotate
in draw_player() superimpose the item disapear thingy
done...



files still not added (probably never...)
- e_bitmap
- e_guifnx

I just realize I have no way of setting blocks drawable
copying and moving blocks
or doing anything with animation sequences

I could probably make some of e_bitmap work...

like select bitmap and animation sequence..

i made select bitmap and animiation work
but no link to them...

make select bitmap, coopy bitmap accsesiable from animation

also add save...

done...now link to it in editor...done



re-write help file
font and credits..done
screen mode..done
in game function keys..done
commandline..done
history update..done
installing..done
linux..done
add pixel_sub font credits..done



---------------------------------------------------------
what are my difs that happen every frame??
---------------------------------------------------------
tested and found a dif when other player joined and color was updated
also got archwag: type 3 difs
Ei[][1]  off by 5
Ei[][5]  off by 5
Efi[][0] // once  (x)
Efi[][1] // many  (y)
its usually this pair
Ei[][5]  off by 5
Efi[][1] off by .5, 1 , 3...

played a huge long netgame and they don't happen every frame...
actually quite infrequently....





add source available on request...
license: none
just a copyright notice...


what version number? 7.0


trying other linux os's
linuxmint-18.3-cinnamon-64bit.iso

missing: libopenal.so.1

copied from m-4230j

what if i recompile allegro on m-4320
to disallow open al
and redo all that...
or I could just distribute libopenal.so.1...
I recompiled the game so I don;t need the file now.

title on main menu screen is cut off when text is too wide?
only on cinnamon mint??

has max size as 8192
and is creating same size as other one

4865 violet missing V and !
4888 mauve  missing !
4767 bluey  missing !
6777 reddy  missing !
4219 pink   good
4335 taan   missing !
5213 orange missing O and !
5136 purple missing P and !
5088 forest missing F and !
4089 red    good
4874 green  missing !
4444 blue   missing !
4462 aqua   missing !
5164 yellow missing Y and !
4600 white  missing !

fixed by changing size of title bitmap..
old was max bitmap / 16
new is max bitmasp / 20

now mint works great....



updated windows version to 7.01, now with demo files!!!

updated linux version to 7.01,
now updated allegro libary that dosent require png support...


help screens width when changing les..fixed

fixed final_wrapup()
now hopefully wont die as much in linux


make the releases...
put on allegro.cc...
...
profit?


new license (zlib)

change help.. done

add license.txt.. done

make 7.03 release for win and lin...done



crashes on exit in win 10

try removing all bitmap destrying in final wrapup

also remove:
al_destroy_event_queue(event_queue);
al_destroy_display(display);

also remove complile optimizations


seems crash free on win 10 exit now...
linux version exits good too...
lets make release version 7.04


rename save and run game...
to what?
save demo
run demo

the best way to do that is to use the logging options
because as soon as a level ends, its too late to save it anymore
what if i remove save game completely?
its only use is when you stop a game mid-level and want to save...
just rename them for now..




When archwag y speed is set to 9 (max) they fall through floors...

found the bug!!

Ei[EN][5] +=5; // gravity

// this line is wrong!!!!
if (Ei[EN][5] < -160) Ei[EN][5] = -160; // terminal velocity

//fixed
if (Ei[EN][5] > 160) Ei[EN][5] = 160; // terminal velocity


now are all my demos going to be fucked?  probably any that used archwag...

dl_01 (pretty short anyway) kill it
dl_02 (pretty short anyway) kill it

dl_13 no archwag, good keep
dl_14 still good keep
dl_15 doesnt look good kill it

24 has a million arch wags, needs to be redone
26 doesn't work
27 bad
29 bad

30 good
33 good

zm21...bad  :(


after all these are the one I can keep


redid some demo levels, now I have:
13
14
20
23
24
26
30
33


new default keys:
arrows, x, z

p0_up_key=84
p0_down_key=85
p0_left_key=82
p0_right_key=83
p0_jump_key=24
p0_fire_key=26
p0_menu_key=59


20180508
copy in zfs has rect 1 block to big in x and y...fixed

20180508
adding new enemies erases last...wtf
only after copy paste enemies in zfs??
i broke something in level 42
now any enemy that I add either from draw_item copy paste or selection window
erases the last enemy...why??
bug in code in editor line 1160
should be:
int c = get_empty_enemy(); // get a place to put it
not:
int c = get_empty_item(); // get a place to put it
bug first appeared 20180401
fixed...



Make a way to do "new level" in level editor

right now what I do is:
- load level (optional)
- save level (and choose filename that doesn't exist yet)
- go to zoom full screen
- select entire level
- click clear

add a menu item 'new level'
- prompts you for a filename to save
- clears level and saves as new filename

made the menu item

made erase_level_data() a seperate function and call from
load_level() and initial_setup()

now it goes like this...

if (al_show_native_message_box(display, "New Level", "Clicking OK will create a new blank level", NULL, NULL, ALLEGRO_MESSAGEBOX_OK_CANCEL) == 1)
{
   zero_level_data();
   draw_big(1);
   update_editor_background();
   al_flip_display();
   save();
}
load_level(level_num, 0); // blind load

seems to work just like I want...call it done


make a function that serially reads keys to call debug functions..

while game running:
STON  speed test on
STOFF speed test OFF

while level_editor_running:
SPLADJ  spline adjust
SPLTEST spline test

while not game running
LOGVIEW run the logfile viewer


if ima_client
FAKEKEY toggle

does it work with CAPS?? ..NO

done...


new level does not blank the number of lifts...fixed

new level has bad pmsg data
fixed method of declaring pmsg pointer and freeing and setting to NULL


Should I make pmsg not have clear center?? yes...


i messed with pmsg and now I get crashes and I'm not sure why

this was the code used to erase level data..

if (item[c][0] == 10) free (pmsg[c]);
i didn't like it because it didn't reset the pointer to NULL

I replaced it with:
if (pmsg[c] != NULL)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}

and then just:
free (pmsg[c]);
pmsg[c] = NULL;

because if it's NULL, free() should not do anything

I get random crashes and I don't like it, so I went back to the original plus this:

if (item[c][0] == 10)
{
   free (pmsg[c]);
   pmsg[c] = NULL;
}



trakbot initial direction button works, but the rotated display in enemy viewer is wrong...fixed

sel outline rect too small when at rl edges..fixed

make my webpage part of the sources

re-arrange levels and move less fun ones to the end...

I want to have a very solid set of levels with no duds

these are lame and should be segregated...

5
6
7
8
9
10
11
12
15
16
18
19
40

what if I had an overiding script that chose the order of levels...

start by moving lame ones to 50++


did a lot of that...

need to make the demo's line up


what if I gave all my levels names like anything.pml

then I made an array of playable levels
that would end my renaming bullshit



hard code into the program:
for each:

filenames
title
description


make a playlist of levels

int level_playlist[400]

this gets iterated through when playing
and is used by visual_level_select()

level_num is an index into this

how about do this, but still use numbers for levels

menu item "level set"
LEVEL SET:TRAINER
LEVEL SET:MAIN
LEVEL SET:EXTRA
LEVEL SET:ALL



This is what I actually did.

I made 3 levels that I call trainers and moved them to 90, 91, 92

I made a warp there and back from level 1

I think it works good enough...

made some more changes to the levels and then are looking good.

1 - trainer select
2-24 main levels
50-64 extra levels
90-93 training levels

20180514 new commit

auto create dir sel, like logs...done


sometimes I see trails in level_buffer when stimp/stamp or screen change
hard to reproduce..
re-did get new background to do full or region only
did a redraw at start of stamp
also slowed down stimp and stamp to make more visible
trails during stamp are good


when stimp and game zoom shows lots of the level, it doesn't line up

its like stimp and stamp expect the game position to be more left than it is




stimp and stamp have code with hystersis window like get_new_screen_buffer()

make that common??


what is found out by either function?
in get new background: WX, WY, SW, SH, sbx, sby, sbw, sbh


in stimp and stamp I just patched in an offest like this:

   // offset if entire level is smaller than screen
   int sbw = SCREEN_W-bw*2;
   int sbh = SCREEN_H-bw*2;

   // how big is the entire level after scale factor is applied?
   extern float scale_factor_current;
   int sls = (int) ((float)2000 * scale_factor_current); // sls = scaled level size

   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      px_final += a/2;

   }
   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      py_final += a/2;
   }

works now...

cursor height in text editor

draw lift..good
server name good
p message..fixed



fix demos

old demos from version 7.04


9
10
12
13
14
16
17
zm_11 chopped to 200s or 8000 frames

---done

commit done
made an old style backu too...

when run demo stimp of wrong level..fixed
cleaned up function prototypes
20180517 commit

working on cleaning up pm.h

pm.h has all function definitions listed by files
and sorted through

next I should work on global variables... I have a lot of them...


the beginning of main, where they are declared,
should mirror pm.h where they are externed

also remove lots of not used ones

also move all declarations from other source files to main

I have 500 lines of extern variables!!!

tmty
tmtx
position of text above the map on menu screen_msg
used in draw_level
set in set_map_var

I also have:
menu_map_x
menu_map_y
menu_map_size

I should use these get the text position and then get rid of tmtx and tmty
step 1
use them in draw level
now search and get rid of  tmtx and tmty done...


now how about md
used only to to make mx
mx is used a lot
made md local to set map var
md is gone now, local only to set_map_var

int map_double; // level editor map double
not used, removed...

tmy is the top_menu y_pos

always set to 10, never anything else
used to set mx = tmy + 130;
make that constant..
tmy is gone...

float steps is gone...

mx, my
what are they used for?
mx is used a lot locally
replace with smx if locally used
down to 89
turns out almost all my and my were local...
i kept a lot of them, just killed the extern ones
mx and my are not global anymore...

txc is used for the center of the right hand side panel in level editor...keep

that has cleaned up lots...

what is next?

group globals by function and make sure main and pm follow same format...

make item_name and enemy_name the same

both


menu_setup for game in zmenu

text_setup for level editor in e_menu

make them common...

both use global_string[9]

le uses 5 and 9
gm uses 3, 4, 7, 8, 9

make le use 6 instead of 9..done
move code from ts to ms done
remove e_menu.cpp from project...done
make enemy_name like item_name
replace ei_type_desc with enemy_name
6 used for lift pop up menu?? need to move editor menu to 2?
done...



4:30 AM

main
300 sorted
200 not

pm
550 sorted
200 not

5:30
400 sorted
100 not

pm
625 sorted
125 not

wx and wy are used 34 times
mostly as the origin block on the main level editor..


6:40
main 20 not sorted
pm same...

20180518 commit...

level_header is used in filecom only
uses only 3, 4, 5 for num item, enemy, lifts
made local

I am finished cleaning up pm.h

now I have approx 350 globals, but they are all grouped by function
and match the declarations in main

code stats:
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)


put log file viewer in logging menu..done

what if I add PG_UP and PG_DOWN to menu?
I would make navigating long menus easier.....done

text center in level editor is not right...
moved where txc is set to after where db in set..fixed

title obj for item not centered..fixed

raise text in color select 1 pixel...done

show door type button better...only show in title at full size..done

I think I'm ready for a new version release

I should make a checklist of all I need to do:

- make sure version string is incremented at start of initial setup
- change version in help file

- make sure linux version works

something (i'm looking at you git) changed the linux line endings to windows
op win
pml lin
lin_make_release win
readme_linux lin

log file viewer crashes hard on linux
never even runs...
didn't crash the 2nd or 3rd time...
PDE text for Trakbot says wall climber
too many lines for switch and flapper door
fixed PDE text...
need to make it look good on linux with line endings...done

compile lin version and make tar.gz
compile win version and make zip

upload to itch.io




- define RELEASE in pm.h






------------------------
20180523

Refactoring....


I need to sort out how the three tile bitmaps get load and such.....

right now its spread across too many places....done

now all 3 are load and initialy created in load sprit
only load sprit is called from main

recreate bitmaps destroys all sub bitmaps ane re-creates...


why is tilemap created in load_sprit, but ptilemap and dttilemap are not ???

this is a mess and should be straightened out...

make tilemap, ptilemap and dtilemap local to load sprit only.
all they do is create the M_ versions that need to be global...or do they??

fix this...



-------------------------------------------------------------------------------
these bitmaps are created when 'create_bmp()' is called from 'init_screen()'
this is the only time that 'create_bmp()' is called...

tilemap = al_create_bitmap(640, 640);
ptilemap = al_create_bitmap(380,320);
dtilemap = al_create_bitmap(160,640);

level_background = al_create_bitmap(2000,2000);
level_buffer = al_create_bitmap(2000,2000);

M_tilemap = al_create_bitmap(640,640);
M_ptilemap = al_create_bitmap(380,320);
M_dtilemap = al_create_bitmap(160,640);



-------------------------------------------------------------------------
in 'rebuild_bitmaps()'
M_tilemaps are drawn to tilemaps
sub_bitmaps are created / recreated from tilemaps


-------------------------------------------------------------------------
in 'load_sprit()'
tilemaps are loaded from file
M_tilemaps are created from tilemaps
rebuild_bitmaps()' is called



fill_door_bitmap() and fill_player_bitmap() are not called
so I commented them out


to do:

make load_sprit not create local copy of tilemap....done
make load_sprit only load M_, then call rebuild_bitmaps();

I tried to load M_ directly, but for some reason,
I need to load as video bitmap then convert alpha and store in M_


I would like to rename:

l2000 to level_background..done
memory_bitmap to tile...done
player_bitmap to player_tile...done
door_bitmap to door_tile..done

rename load and save sprit to load and save tiles..done





what is not used:

void test_window_size_and_pos(void) // never used...move to old...

// only declared and externed, never used.. removed
int disp_x_full = 0;
int disp_y_full = 0;
int disp_w_full;
int disp_h_full;

// last screen pos, to tell if it changed -- does not need to be global!!
int l_spx;
int l_spy;

what is saved to config:
disp_x_wind
disp_y_wind
disp_w_wind
disp_h_wind
fullscreen


renamed les to display_transform_double...done

renamed set_ortho() to set_display_transform()..done

after death, trails show on undrawn level background..fixed


----------------------------

Do I have to re-create all my tile sub bitmaps every time I rebuild bitmaps?
No, if I just reload the parent bitmaps the subs do NOT need to be re-created...done




trimmed down the number of calls to rebuild_bitmaps()

actually its called a lot more often that than.... why???
3 time in proc screen change

1 time in filecom after load_tiles


2 times in menu...at start and end of menu right after auto_set_display_transform_double

1 time in control after F12 to set display_transform_double


1 time in bitmap in animation at start when display_transform_double set to 1

2 time in editor at start and end of help when display_transform_double changed

? can I just add it to auto_set_display_transform_double()

? make manual set version and set it there too??


try to change the one in control...
replaced  rebuild_bitmaps();
with:
set_display_transform();
set_map_var();

bitmap..removed

add to end of auto set:
set_display_transform
set_map_var
done

find all call to this and remove rebuild_bitmaps...done
help x 2

now after all that: rebuild_bitmaps() is called only from proc_screen_change


-----------------------------------------------

do I need 'speed' to be seperate from passcount_timer_fps?

rename speed in the game to frame_speed for now, so I can tell it apart from the 150 mentions of speed

found 21 refs to 'frame_speed'
found 13 refs to 'passcount_timer_fps'

why do they need to be different?

what if I replaced all passcount_timer_fps with frame_speed??

done...

now remove:
void set_passcount_timer_fps(int x)

32 refs to frame_speed

should be done....

hopefully it didn't break anything....

-----------

sound...

why do I have lit_item and fuse_loop_playing?

do I need both??



lit_item
- set to zero in proc_sound
- set to one in proc lit rocket and bomb

used by proc_sound to continue fuse hiss...

code stats: 0524
36 files
19393  code only
 5368  empty lines
 3726  comment lines
 3376  code and comment
31863  total


-----------------

increment passcount in proc_frame_delay(), not update_animation()..done
here is how it moved in the game loop:
proc_controllers();
player_move();
proc_player_carry();
update_animation();  <- from here
enemy_move();
enemy_collision();
proc_ebullets();
proc_pbullets();
proc_player_health();
proc_sound();
proc_frame_delay();  <- to here

hope this doesn't break anything!

Rename passcount to frame_num...done

rename event to game_event...done




in proc_controller()

change
if (key[ALLEGRO_KEY_PRINTSCREEN]) key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work
to
key[ALLEGRO_KEY_PRINTSCREEN] = 0; // special exception to make PRINTSCREEN work

also this line:

if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
looks like its in the wrong spot

orig:

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

fixed:


   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }

now menu's seem to run a lot faster...fixed

make screenshots folder auto created...done
fix screenshot to use actual screen size instead of ortho doubled...done

make it so demo counter will not run when game is paused
cause when it does, paused game is lost...done

changed logo drawing to use max x or y scale instead of hypot for thickness

-------
fixed linux line ending on text files
removed license.md
edited license.txt and readme.md







i want to simplify the 2 variables used for menu timer wait in proc_controllers()

right now I use done and menu timer wait

done is used 3 time; menu_timer_wait is used 2 times

code before changes...


int proc_controllers()
{
   int ret = 0;
   int done = 0;
   int menu_timer_wait = 1;

   key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (!done)
   {
      done = 1; // default
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_wait = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
          if (menu_timer_wait) done = 0;
      }




new version:

menu_timer_block only and used in three places...much better

int proc_controllers()
{
   int ret = 0;
   int menu_timer_block = 1;

   key[ALLEGRO_KEY_PRINTSCREEN] = 0; // hack to make PRINTSCREEN key work properly
   Key_pressed_ASCII = 0;

   if (!fullscreen) // detect if window was moved
   {
      int x, y;
      al_get_window_position(display, &x, &y);
      if ((x != disp_x_curr) || (y != disp_y_curr))
      proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
   }

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if (ev.type == ALLEGRO_EVENT_TIMER) menu_timer_block = 0;
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
            }
            else ret = proc_events(ev, ret);
         }
      }
      if (game_exit) // if called from menu only do key check for active local player
      {
          clear_keys(active_local_player);
          player_key_check(active_local_player);
          function_key_check();
      }
      else // game is in progress
      {
         menu_timer_block = 0;






web docs:
rename events
or move out input to its own file..done
input to have key, mouse, joystick and game moves array...done


---------------
found a better way to get rid of warning like:
warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]|

previously i change all the time i called a funtion with a literal string from:
Packet("sdak");
to:
Packet((char *)"sdak");

but bamcaig said that wasn't actually correct

now I am going to redo them all by changing the function from:
void Packet(char *id) {
to:
void Packet(const char *id) {

that is the correct way.

I just changed 20 instances of Packet()
moving on...
20 x Packet()
12 PacketRead()
4 title()
30 help()
23 getxy()
5 getbox()
1 get_item()
2 ClientInit()
30 add_log_entry_centered_text()
94 add_log_entry_position_text()

all done....


what if I sort out the names for packet add and read

new...

void PacketPut1ByteInt(int b)
void PacketPut2ByteInt(int b)
void PacketPut3ByteInt(int b)
void PacketPut4ByteInt(int b)

int PacketGet1ByteInt(void)
int PacketGet2ByteInt(void)
int PacketGet3ByteInt(void)
int PacketGet4ByteInt(void)


void PacketPut1ByteInt(int b) replace 32
int PacketGet1ByteInt(void) replaced 22

void PacketPut2ByteInt(int b) replaced 3
int PacketGet2ByteInt(void) replaced 3

void PacketPut3ByteInt(int b) replaced 0
int PacketGet3ByteInt(void) replaced 0

void PacketPut4ByteInt(int b) replaced 26
int PacketGet4ByteInt(void) replaced 18


2 byte is only used for:
- play level in SJON and CJON
- specialized packet testing

I could remove the tests I put in for player num matching who...nah leave it...



what site did i use for my flowchart?



where is server_sync used..


client and server

in player1 struct


overlay
client while waiting for sync
client bottom overlay
server per client


I want to make them unique..

on client server_sync is used for display only and for adjust timer

rename that one to client_sync

add new var in player struct:client_sync
should be done....


next:

   int c_sync;
   int c_sync_min;
   int c_sync_err;

how about:

client_game_move_sync;
client_game_move_sync_min;
client_game_move_sync_err;

and

server_game_move_sync;
server_game_move_sync_min;
server_game_move_sync_err;



change client first....
make new var...
clear in player
fix in client
fix in overlay
fix in log
done

change server next....
make new var...
clear in player
fix in server
fix in overlay
done

still seems to work

























rename state correction stuff


stdf is the name of the buffer used by client to build chfd from packetsize
I could call it client_state_buffer

the array used to track if all the pieces have arrived: chdf_pieces
rename to client_state_buffer_pieces

client1_chdf is the clients base state
rename to client_state_base

client1_chdf_id is the frame num of the clients base state
rename to client_state_base_frame_num


old:
extern char chdf[STATE_SIZE];          // for client chdf building
extern int chdf_pieces[16];
extern char clientl_chdf[STATE_SIZE];  // last ack state for diffing
extern int clientl_chdf_id;            // frame_num id

new:
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // frame_num id

chdf to client_state_buffer..done
chdf_pieces to client_state_buffer_pieces..done
clientl_chdf to client_state_base..done
clientl_chdf_id to client_state_base_frame_num


old:
extern char dif[STATE_SIZE];
extern int dif_id[2]; //   (0 = src, 1 = dst)

new:
extern char client_dif[STATE_SIZE];
extern int client_dif_src;
extern int client_dif_dst;

server also uses dif....
client only uses dif_id

ok do this instead:
new:
extern int dif_src;
extern int dif_dst;

leave dif alone

dif_id[0] to dif_src..done
dif_id[1] to dif_dst..done



old:
// server chdf
extern char client_chdf[8][2][STATE_SIZE];
extern int client_chdf_id[8][2]; // frame_num id

new:
extern char srv_client_state[8][2][STATE_SIZE];
extern int  srv_client_state_frame_num[8][2];

client_chdf to srv_client_state..done
client_chdf_id to srv_client_state_frame_num..done


final variable list:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2]; // frame_num id

// local client's states
extern char client_state_buffer[STATE_SIZE];  // for client chdf building
extern int  client_state_buffer_pieces[16];   // to mark pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state for diffing
extern int  client_state_base_frame_num;      // frame_num id

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;  // client only
extern int dif_dst;  // client only


now I need to come up with a different term for the variables that make up a state

I have funtions called:
void chnk_to_state(char* b);
void state_to_chunk(char* b);

but what I used to be call state needs a new name: game_vars

new names:
void state_to_game_vars(char* b);
void game_vars_to_state(char* b);

chnk_to_state to state_to_game_vars..done
state_to_chunk to game_vars_to_state..done

these are good:
void reset_states(void);
void game_vars_to_state(char * b);
void state_to_game_vars(char * b);


these should all have chunk changed to state:
void get_chunk_dif(char *a, char *b, char *c, int size); // server only
void apply_chunk_dif(char *a, char *c, int size); // client only
void show_chunk_dif(char *a, char *b); // client only
done...


now the packet names....

chdf and chak

stdf and stak

did a global replace of chdf to stdf -- hundreds... hope it didn't break to much...

now chak to stak..done..only a few

lets see how broken it is....
I still seem able to play a 2 player game...

well now that everything has been renamed, lets move on with the documenting....

------------------------------
bug
-----------------------------

end of level on netgame???

seem to have trouble joining on new level...

client keeps getting difd from 0-20, 0-25 etc
but its base is 2 so it cant apply them

finally at frame 120, client resets base to 0 and applies dif

but its too late beacuse the server has already dropped the client
for no sdat_rx for 100 frames



when does base reset to zero? never mind


also client is approx 10 frames behind client
this is why chdf is never applied
client does not receive any sdat until 108
the moves it gets are the server drop moves!!

what controls when server send sync sdat?


if I press keys on the server after level done and force sdats to be sent, join works
if not, it times out


why is server not sending sync sdat's???


try removing else....that fixed it...
it was never doing the second block because the first one was true (client need more data)
but the first one was not sending more data beacuse of the duplicate blocker

void server_send_sdat(void)
{
   for (int p=1; p<NUM_PLAYERS; p++)
      if (players[p].control_method == 2)
      {
         if (players1[p].game_move_entry_pos < game_move_entry_pos) // client needs more data
         {
            int start_entry = players1[p].game_move_entry_pos;
            int end_entry = game_move_entry_pos;
            int num_entries = end_entry - start_entry;
            if (num_entries > 100) num_entries = 100;

            // to prevent multiple resends of exact same data
            if ((players1[p].server_last_sdat_sent_start != start_entry) || // different start pos
               (players1[p].server_last_sdat_sent_num != num_entries))      // different num entries
            {
               players1[p].server_last_sdat_sent_start = start_entry;
               players1[p].server_last_sdat_sent_num = num_entries;
               players1[p].server_last_sdat_sent_frame_num = frame_num;

               Packet("sdat");
               PacketPut1ByteInt(p);
               PacketPut4ByteInt(frame_num);
               PacketPut4ByteInt(start_entry);
               PacketPut1ByteInt(num_entries);

               for (int x=start_entry; x<start_entry + num_entries; x++)
               {
                  PacketPut4ByteInt(game_moves[x][0]); // frame_num
                  PacketPut1ByteInt(game_moves[x][1]); // type
                  PacketPut1ByteInt(game_moves[x][2]); // data 1
                  PacketPut1ByteInt(game_moves[x][3]); // data 2
               }
               ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

               if (L_LOGGING_NETPLAY_sdat)
               {
                  #ifdef LOGGING_NETPLAY_sdat
                  sprintf(msg,"tx sdat p:%d [strt:%d num:%d]\n", p, start_entry, num_entries);
                  add_log_entry2(37, p, msg);
                  #endif
               }
            }
         }


         else if (frame_num > players1[p].server_last_sdat_sent_frame_num + 19) // send even if no data, every 20 frames for sync
         {
            players1[p].server_last_sdat_sent_frame_num = frame_num;
            int start_entry = players1[p].game_move_entry_pos;

            Packet("sdat");
            PacketPut1ByteInt(p);
            PacketPut4ByteInt(frame_num);
            PacketPut4ByteInt(start_entry);
            PacketPut1ByteInt(0);
            ServerSendTo(packetbuffer, packetsize, players1[p].who, p);

            if (L_LOGGING_NETPLAY_sdat)
            {
               #ifdef LOGGING_NETPLAY_sdat
               sprintf(msg,"tx sdat p:%d [strt:%d num:%d] (sync only)\n", p, start_entry, 0);
               add_log_entry2(37, p, msg);
               #endif
            }
         }
      }
}



--------------------------------------
end of bug


what if I remove the code that checks if packet are from who they are supposed to be?
that was never an issue...


old:

      if(PacketRead("serr"))
      {
         int sp = PacketGet1ByteInt();
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx serr player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            if (serr_type == 1) // error type (1 = cdat late)

            players1[p].serr_c_sync_err = serr_c_sync_err;
            players1[p].serr_display_timer = 120;

            sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
            if (L_LOGGING_NETPLAY_cdat)
            {
               #ifdef LOGGING_NETPLAY_cdat
               add_log_entry2(35, p, msg);
               #endif
            }
         }
      }


                  Packet("serr"); // server error
                  PacketPut1ByteInt(p);
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);




new:

      if(PacketRead("serr"))
      {
         int serr_type = PacketGet1ByteInt();
         int serr_frame_num = PacketGet4ByteInt();
         int serr_c_sync = PacketGet4ByteInt();
         int serr_c_sync_err = PacketGet4ByteInt();

         if (serr_type == 1) // error type (1 = cdat late)

         players1[p].serr_c_sync_err = serr_c_sync_err;
         players1[p].serr_display_timer = 120;

         sprintf(msg,"Error: server dropped cdat s_pc:%d  s_csync:%d  tot_err:%d\n", serr_frame_num, serr_c_sync, serr_c_sync_err);
         if (L_LOGGING_NETPLAY_cdat)
         {
            #ifdef LOGGING_NETPLAY_cdat
            add_log_entry2(35, p, msg);
            #endif
         }
      }





                  Packet("serr"); // server error
                  PacketPut1ByteInt(1); // error type 1
                  PacketPut4ByteInt(frame_num);
                  PacketPut4ByteInt(c_sync);
                  PacketPut4ByteInt(players1[p].server_game_move_sync_err);
                  ServerSendTo(packetbuffer, packetsize, who, p);









old:

      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sp = PacketGet1ByteInt();
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         if (sp != p)
         {
            sprintf(msg, "ERROR! rx sdat player:[%d] does not match local player:[%d]\n", sp, p);
            printf("%s", msg);
            #ifdef LOGGING_NETPLAY
            add_log_entry2(10, p, msg);
            #endif
         }
         else
         {
            players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

            // this used to be a function , client timer adjust
            players1[p].client_sync = sdat_frame_num - frame_num;
            int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;



new:
      if(PacketRead("sdat"))
      {
         char tmsg[20];
         int sdat_frame_num = PacketGet4ByteInt();
         int start_entry = PacketGet4ByteInt();
         int num_entries = PacketGet1ByteInt();

         players1[p].client_sdat_packets_rx++; // total sdat packets rx'd

         // this used to be a function , client timer adjust
         players1[p].client_sync = sdat_frame_num - frame_num;
         int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;










old:

int process_stdf_packet(void)
{
   int retval = 0;
   int p = PacketGet1ByteInt();
   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   if (p != active_local_player)
   {
      sprintf(msg, "ERROR! rx stdf player:[%d] does not match local player:[%d]\n", p, active_local_player);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
   }
   else
   {
       memcpy(client_state_buffer + stdf_sb, packetbuffer+23, stdf_sz);  // put the data in the buffer












new:


int process_stdf_packet(void)
{
   int retval = 0;
   int p = active_local_player;

   int stdf_src_frame_num = PacketGet4ByteInt();
   int stdf_dst_frame_num = PacketGet4ByteInt();
   int stdf_seq = PacketGet1ByteInt();
   int stdf_max_seq = PacketGet1ByteInt();
   int stdf_sb = PacketGet4ByteInt();
   int stdf_sz = PacketGet4ByteInt();

   memcpy(client_state_buffer + stdf_sb, packetbuffer+22, stdf_sz);  // put the data in the buffer








removed these from server:

void proc_server_check(void)
{
   for (int p1=1; p1<NUM_PLAYERS; p1++)
      for (int p2=1; p2<NUM_PLAYERS; p2++)
         if (p1 != p2)
         {
            int p1w = players1[p1].who;
            int p2w = players1[p2].who;
            if ((p1w != 99) && (p2w != 99))
               if (p1w == p2w) // we have a duplicate
               {
                  // do something here
                  sprintf(msg, "ERROR! duplicate whos for player:[%d] and player:[%d]\n", p1, p2);
                  printf("%s", msg);
                  #ifdef LOGGING_NETPLAY
                  add_log_entry2(10, 0, msg);
                  #endif
               }
         }
}


// check to see if this packet is from who its supposed to be and is valid
int check_packet_who(int p, int who, int type)
{
   if (players[p].control_method != 2)
   {
      //check if the player we received data for is an active client
      //sprintf(msg, "ERROR! rx cdat for player[%d].control__method[%d] != 2\n", p, players[p].control_method);
      //printf("%s", msg);
      //#ifdef LOGGING_NETPLAY
      //add_log_entry2(10, p, msg);
      //#endif
      return 0;
   }
   if ((players1[p].who != who) && (players1[p].who != 99))
   {
      char tmsg[80];
      if (type == 1) sprintf(tmsg, "cdat");
      if (type == 2) sprintf(tmsg, "sdak");
      if (type == 3) sprintf(tmsg, "stak");

      sprintf(msg, "ERROR! rx %s player[%d].who[%d] does not match packet who[%d]\n", tmsg, p, players1[p].who, who);
      printf("%s", msg);
      #ifdef LOGGING_NETPLAY
      add_log_entry2(10, p, msg);
      #endif
      return 0;
   }
   return 1;
}


done.....

does it still work??...yes



warps on netgame???

warp starts next level immediately
client does not even join
but then client times out and quits

is the whole level done thing too complicated?


added global int next_level

added
play_level = next_level;
in proc_level_done()

added
next_level = play_level + 1;
in item exit collision


changed warp from:
play_level = item[x][8];
start_mode = 1;

to:
next_level = item[x][8];
level_done = 1;
game_event(4, itx, ity, 0, 0, 0, 0);

now warp should be exactly like exit except for the next level




-------------------------------------

dif is not really used by server, it just uses a local variable of the same name...

i propose more renaming:

old:

extern char dif[STATE_SIZE];  // used by client and server
extern int dif_src;           // client only
extern int dif_dst;           // client only


new:
extern char client_state_dif[STATE_SIZE];
extern int client_state_dif_src;
extern int client_state_dif_dst;

---------------------------------------------------

ok now final looks like:

#define STATE_SIZE 104640
// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

// local client's states
extern char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
extern int  client_state_buffer_pieces[16];   // to mark packet pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state
extern int  client_state_base_frame_num;      // last ack state frame_num
extern char client_state_dif[STATE_SIZE];     // uncompressed dif
extern int  client_state_dif_src;             // uncompressed dif src frame_num
extern int  client_state_dif_dst;             // uncompressed dif dst frame_num




------------------------------------

why do I use:
7 x memmove
7 x memset
27 x memcpy

---------------

working on join...

i want to move client_block_until_good_stdf_received(void)
to right after block for SJON rx

removed from main clinet loop:
if (frame_num == 0) client_block_until_good_stdf_received();

added right after SJON rx:
client_block_until_good_stdf_received();

done and works, even after level done

but don't I need to call it in client loop for level done rejoin?

I guess not....
client and server should have just both loaded new level, no need to wait for state.

i'll leave it in for now, so it gets called from both places













i want to clean up the init code for client, its kinda like spaghetti...
could be a lot clearer....



now:

client_init
  - client_init_driver()
  - client_init_join()
     - send CJON
     - block wait for SJON
     - client_block_until_good_stdf_received()
        - block for good state





what if I flatten it all out


client_init
  - client_init_driver()
  - send CJON
  - block wait for SJON
  - block for good state





did a lot of cleaning up the client init stuff

now:

client_init
  -ClientInit
  -check for reply
  - client_init_join()




  moved check for reply to ClientInit
rename ClientInit to ClientInitNetwork()


now:

client_init
  -ClientInitNetwork()
  -client_init_join()


much better....

rename ServerInit to ServerInitNetwork() also...

renamed server and client exit also
now called after every call to server init (3 times each in main)


client exit takes care of resetting player stuff like:

   ima_client = 0;
   players[0].active = 1; // local_control
   active_local_player = 0;


no need to do it anywhere else, like if join fails...

change init_player(p,1)

to set inactive, not active....

client_init_join() is looking good

void client_block_until_good_stdf_received(void) is looking good.

its been coming along nicely......



redo where server chooses new client color...

   int color = req_color;  // try to use requested color, unless already used by another player
            int color_used;
            do
            {
               color_used = 0;
               for (int q=0; q<NUM_PLAYERS; q++)
                  if ((players[q].active) || (players[q].control_method == 9) || (players[q].control_method == 2))
                     if (color == players[q].color)
                     {
                        if (++color > 15) color = 1;
                        color_used = 1;
                      }
            } while (color_used);


make a function called:

int is_player_color_used(int color);


int is_player_color_used(int color)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) || (players[p].control_method == 9) || (players[p].control_method == 2))
         if (color == players[p].color) return 1;
   return 0;
}

   // try to use requested color, unless already used by another player
   while (is_player_color_used(color)) if (++color > 15) color = 1;

hell also fix why color and bitmap index are off by 1
shifted all my player bitmaps up one in tilemap
lose bitmap, only use color...
its in player1 struct whicg I dont want to mess with the size of
i'll just rename it there to find all refs then change them to use color instead
done...

now only color, no bitmap index...yay!!!


int who is a static int in server loop...

should I make it a global? no

who uses it?

CJON yes
stak no
sdak no
cdat no




rename a bunch of client and server functions...

move packet processing to one function for each packet type..


should I remove #ifdefs for logging...yes...


one file at a time..

client...done

bandwidth???
// gets the values in send and rx functions
#ifdef NETPLAY_bandwidth_tracking

leave bandwidth for now, do all others


server...done

now search for

#define LOGGING..done
#define LOGGING_NETPLAY..done
#define LOGGING_NETPLAY_JOIN..done
#define LOGGING_NETPLAY_client_timer_adjust..done
#define LOGGING_NETPLAY_cdat..done
#define LOGGING_NETPLAY_game_move..done
#define LOGGING_NETPLAY_sdat..done
#define LOGGING_NETPLAY_sdak..done
#define LOGGING_NETPLAY_stdf..done
#define LOGGING_NETPLAY_stdf_all_packets..done
#define LOGGING_NETPLAY_stdf_when_to_apply..done
#define LOGGING_NETPLAY_show_dif1..done
#define LOGGING_NETPLAY_show_dif2..done
#define LOGGING_NETPLAY_bandwidth.. only one in void process_bandwidth_counters(int p)..done

kill all these defines....done

// not this one
#define NETPLAY_bandwidth_tracking.. 6 in packet tx and rx fnx and  process_bandwidth_counters(int p)



still seems to work...


----------------------
20180518 code stats:
----------------------
35 files
19826  code only
 5574  empty lines
 3905  comment lines
 3397  code and comment
32702  total

27128 total - empty
23233 total - (empty + comment only)

----------------------
20180605 code stats:
----------------------
39 files
18830  code only
 5177  empty lines
 3253  comment lines
 3333  code and comment
30393  total

25416 total - empty
22163 total - (empty + comment only)




main

NET_CONN *ListenConn = NULL;                         // listening connection
NET_CONN *ClientConn[MAX_CLIENTS] = {NULL, };        // array of connections for each client

NET_CHANNEL *ListenChannel = NULL;                   // listen channel
NET_CHANNEL *ClientChannel[MAX_CLIENTS] = {NULL, };  // array of channels for each client

int ClientNum = 0;

NET_CONN *ServerConn = NULL;
NET_CHANNEL *ServerChannel;


pm.h

// libnet client
#define MAX_CLIENTS 32
extern int ClientNum;

// libnet client TCP
extern NET_CONN *ListenConn;
extern NET_CONN *ClientConn[MAX_CLIENTS];

// libnet client UDP
extern NET_CHANNEL *ListenChannel;
extern NET_CHANNEL *ClientChannel[MAX_CLIENTS];

// libnet server TCP
extern NET_CONN *ServerConn;
// libnet server UDP
extern NET_CHANNEL *ServerChannel;

fixed this to only be in n_server and n_clinet
they are never refernced oytside these files...done




all the times when I am trying to break out of a loop with F11 or ESC I need to call proc_controllers()

I can only think of 2 times...
when client blocks waiting for SJON
when client blocks waiting for initial state

done....



make a way to have only one copy of the lhs panel with all the links..

what if I make my own tag that does nothing but mark where this is
then I can search and replace in files for anything in between these tags...

<mdw_lhs_nav>   </mdw_lhs_nav>

what language should I use to do this?
perl?

activeperl 5.24.3

# this updates the left hand side navigation panel in all html files in the current directory

# get the new text
open(MDATA, "<lhs_nav.html");
my $b = do {local $/; <MDATA>};

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   # print $file . "\n";

   # open the file to replace text in
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # replace the text
   $a =~ s/<mdw_lhs_nav>(.*)<\/mdw_lhs_nav>/<mdw_lhs_nav>$b<\/mdw_lhs_nav>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}












make an automated way to make a link list at the top of every file
like each header <mh7>
will have an anchor tag and be in a list at the top of the file

I will need to redo all of my mh7's as anchors


make a script to show all mh7 tags by filename...


this is how I do it in index.html:
<a name="description"></a>
<br><mh6>Description:</mh6>

then a link to that looks like this:
<a href="index.html#description" target="_top">Description</a>

this is how it looks in the other files:
<br><mh7>Overview</mh7>


change mh6 to mh7
the only place mh6 is used is in index...change them all...
done and removed mh6 from css

now only mh7...



now I have a list of mh7 tags in each file...


i should change each tag to a common format:

<mh7>Overview<a name="Overview"></a></mh7>

test this...

do it like this instead:
<br><a name="Overview"></a><mh7>Overview</mh7>

Yes...do them all like this...

can I automatically do it???


still not sure...

I want the whole thing wrapped in a unique tag

why? I dont plan on modifying it, just making auto TOC from it

can I use spaces in my names??yes


manually make them all look like this:
The name exactly the same as the anchor

<a name="Features"></a>
<mh7>Features</mh7>

do it in index first...
works good there.

copy all back to main dir on desktop...

now manually edit all mh7 tags...

do this in main dir...

blank.html - none

-----------------
display.html..done
-----------------
Global variables
Creating the Display
Process Screen Change
Display Transform Double
Detecting Window Move

-----------------
events.html..done
-----------------
Overview
Processing the event queue
Processing events
Handling multiple resize events

-----------------
game_moves_array.html..done
-----------------
Overview
The Game Moves Array
Netgame
Special Game Moves

-----------------
index.html..done
-----------------
Description
Demo Video
Features
Created by
Created with
License
Supported Systems
External Links
Older Versions
History

-----------------
input.html..done
-----------------
Overview
Keyboard Input
PRINTSCREEN hack
Mouse Input
Joystick Input
Bindings vs Controls

-----------------
level_array.html..done
-----------------
Overview
Drawing the Level Array
Rebuilding level_background
Drawing Sequence in the Game Loop
Get New Background
Get New Screen Buffer
Scale Factor

-----------------
lhs_nav.html
-----------------

-----------------
logo.html..done
-----------------
Demo Video
Overview
Splines
Setup of points on the grid

-----------------
netgame_config.html..done
-----------------
Overview
Settings you probably shouldn't change!

-----------------
netgame_join.html..done
-----------------
Overview
Client sends CJON
Server receives CJON and replies with SJON
Client blocks until it receives SJON
Client blocks until it gets initial state from server
Client chase and lock
Packets used for join

-----------------
netgame_main.html..done
-----------------
Overview
Game Move Sync
Client sends control change
Server receives control change
Server sends game move data to clients
Client receives game move data from server
Timing
Control lead frames
Player numbers
Player's control methods
Level Done

-----------------
netgame_packets.html..done
-----------------
Overview

-----------------
netgame_state.html..done
-----------------
Overview
Game state variables
Global variables for state correction
How a client gets a new state from the server
How a client applies the new state
How the server sends a new state dif to a client
Packets used for state correction

-----------------
netgame_status.html..done
-----------------
Overview
server_sync
client_sync
server_game_moves_sync
client_game_moves_sync

-----------------
sound.html..done
-----------------
Overview
Sound Setup
Mixer Volume Controls
Theme Music
Sound Effects
Sample Delay
Processing the Hiss Sound

-----------------
tiles.html..done
-----------------
Overview
Creating Tile Bitmaps
Loading Tile Bitmaps
Rebuilding Tile Bitmaps

-----------------
timers.html..done
-----------------
Overview
Menu Timer (mnu_timer)
Second Timer (sec_timer)
Frames per Second Timer (fps_timer)
Speed adjust during netgame


now that all of this is done I can get back to making my toc's



perl script: make_toc.pl

# makes a toc using <mh7> tags
# inserts the toc between <mdw_file_toc> tags

# iterate all .html files
@files = <*.html>;
foreach $file (@files)
{
   print "\nfile:$file\n";
   print "---------------------------------\n";

   # open the file
   open(DATA, "<", $file);
   my $a = do {local $/; <DATA>};

   # find <mh7> tags
   my @matches;
   push @matches, $1 while $a =~ /.*(<mh7>.*<\/mh7>)/g;

   # multi line toc we are going to insert
   my @toc;

   foreach (@matches)
   {
      #print $_ . "\n";

	  # strip tags
	  $_ =~  /<mh7>(.*)<\/mh7>/;
      $_ = $1;
      print $_ . "\n";

      # add single line in toc
      $toci = "<a href=\"$file\#$_\" target=\"_top\">$_</a>\n";
	  push @toc, $toci;
   }
   #print @toc;

   # replace the toc between <mdw_file_toc> tags
   $a =~ s/<mdw_file_toc>(.*)<\/mdw_file_toc>/<mdw_file_toc> @toc<\/mdw_file_toc>/s;

   # save the changes to file
   open(DATA, ">", $file);
   print(DATA $a);
}


tag in source files...

<mh3><hr></mh3>
<mh8>Tiles</mh8>
<mh3><hr><mdw_file_toc> </mdw_file_toc><hr></mh3>


display.html..done
events.html..done
game_moves_array.html..done
index.html..not done
input.html..done
level_array.html..done
logo.html..done
netgame_config.html..done
netgame_join.html..done
netgame_main.html..done
netgame_packets.html..done
netgame_state.html..done
netgame_status.html..done
sound.html..done
tiles.html..done
timers.html..done

wow, all of this stuff is looking good...




find all css tags and remove unused

header_main..removed...
mh12 removed
mh2 removed
mh4 removed
mh5 removed

mh3 - body text (368)
mh7 - section title (178)
mh8 - file title (34)

mh10 - by: Michael David Weiss (2)
mh11 - Purple Martians title only (68)
mh12 - Technical Code Description only (32)

me1 - secondary header used in netgame config and netgame status

pk0 - packets
pk1 - packets






I want to simplify this:

The offsets from 6,7 are not necessary

old:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points are relative to outer arm 0 positon
   points[0][2] = points[0][6] + 85;
   points[0][3] = points[0][7] + 107;
   points[0][4] = points[0][6] + 95;
   points[0][5] = points[0][7] + 31;

   // inner arm is relative to outer arm
   points[2][0] = points[0][6] + 30;
   points[2][1] = points[0][7] + 30;
   points[2][2] = points[0][6] + 77;
   points[2][3] = points[0][7] + 32;
   points[2][4] = points[0][6] + 93;
   points[2][5] = points[0][7] + 53;
   points[2][6] = points[0][6] + 109;
   points[2][7] = points[0][7] + 69;


new:
   // outer arms start and end pos are all fixed
   points[0][0] = -200;
   points[0][1] = 0;
   points[0][6] = -200;
   points[0][7] = -200;

   points[1][0] = 0;
   points[1][1] = 0;
   points[1][6] = 0;
   points[1][7] = -200;

   points[6][0] = 0;
   points[6][1] = 0;
   points[6][6] = 0;
   points[6][7] = 200;

   points[7][0] = 200;
   points[7][1] = 0;
   points[7][6] = 200;
   points[7][7] = 200;

   // outer arm 0 control points
   points[0][2] = -115;
   points[0][3] = -93;
   points[0][4] = -105;
   points[0][5] = -169;

   // inner arm
   points[2][0] = -170;
   points[2][1] = -170;
   points[2][2] = -123;
   points[2][3] = -68;
   points[2][4] = -107;
   points[2][5] = -147;
   points[2][6] = -91;
   points[2][7] = -131;



looking in game moves thingy
do I make a clear distinction between keys and controls??
I have a function called clear_keys(), that actually clears controls
renamed clear_keys() to clear_controls()
void set_comp_move_from_controls(int p)...never used. delete




web game move array is looking really good...


why do I use:
7 x memmove
7 x memset
27 x memcpy
replaced memmove with memcpy...


0 x memmove
7 x memset
32 x memcpy

1 - client reads stdf and put data in buffer
1 - server builds stdf packet

1 - server updates client's base state

7 - game_vars_to_state(char * b)
7 - state_to_game_vars(char * b)

14 - show_state_dif(char *a, char *b)

1 - add_log_entry2(int type, int player, const char *txt)



Can this be made simpler?

   // check to see if frame_nums match and its time to apply dif
   if (frame_num == client_state_dif_dst) // current frame_num is dif destination
   {
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         // if server has sent dif from src == 0, reset our base to 0
         if (client_state_dif_src == 0)
         {
            memset(client_state_base, 0, STATE_SIZE);
            client_state_base_frame_num = 0;
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
         }
         else
         {
            sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
            if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
         }
      }
      if (client_state_base_frame_num == client_state_dif_src)  // stored base state matches dif source
      {


how about this?

   // check to see if frame_nums match and its time to apply dif
   if (frame_num == client_state_dif_dst) // current frame_num is dif destination
   {
      // if server has sent dif from src == 0, reset our base to 0
      if (client_state_dif_src == 0)
      {
         memset(client_state_base, 0, STATE_SIZE);
         client_state_base_frame_num = 0;
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, "Resetting client base state to zero\n");
      }
      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "!! stdf cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);
      }
      else // stored base state matches dif source
      {


simplify this:

   if (start_mode < 3) // normal or run game
   {
      frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


   if (start_mode == 3) // new level after level done
   {
      stamp();
      frame_num = 0;
      if (!load_level(play_level,0))
      {
         game_exit = 1;
         resume_allowed = 0;
      }
   }


done:

   if (start_mode == 3) stamp(); // new level after level done

	frame_num = 0;
	if (!load_level(play_level,0))
	{
		game_exit = 1;
		resume_allowed = 0;
	}



run demo mode does not use stored player color...

probably because color won't get set if player is already active....

fixed...
now restore saved color after demo play...
where??

demo play can end where?

level done
esc pressed..

how about when called from menu...done
and when called from demo mode...done





sort out init_player()

type 1 - all
type 2 - level done
type 3 - netgame join




8 calls

initial_setup()
calls 1 for every player

load_gm()
calls 1 for every player

proc_start_mode()
calls 2 for every player

client_init_join() after SJON rx'd
calls 1 for every player


server_exit()
calls 3 for every player ???? why??


server_init()
calls 1 for player 0


server_join
calls 1 for new player slot before tx SJON

proc_player_state_game_move()
calls 3 when new demo mode player comes active




there are a lot of things going on here....

make init_player call itself...


make some more specific calls

like 23 = clear bandwidth counters..done



game_move_entry_pos..used only by server....
don't clear on netplay join??..dont think it matters



i think I can get rid of 2 and 3 specifics...done

   if (t == 2) // level done
   {
      players1[p].game_move_entry_pos = 0; // server only  ( for client game_move data sync )
      players1[p].server_last_sdat_sent_frame_num = 0; // only server uses it, to keep track of when last sdat was sent to client
   }

   if (t == 3) // netplay join
   {
      players1[p].server_last_sdak_rx_frame_num = frame_num + 200;
   }

now change the 2 calls to 3 to 2's..done




looks a lot cleaner now...hope it all still works....


i should set control_method to 0 in init 1



demo mode won't quit with any key...

esc just starts new demo...



make a new list of where I call init_player()

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;



when client rx SJON
-------------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[cp].control_method = 4;
ima_client = 1;
active_local_player = cp;
players[cp].color = color;
players1[cp].game_move_entry_pos = server_game_move_entry_pos;



server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this




this one was probably an issue so i removed it:
proc_player_state_game_move(int x)
----------------------------------
// player becomes active
if ((players[p].active == 0) && (val > 0) && (val < 16))
{
	init_player(p, 1);
	players[p].active = 1;
	players[p].color = val;
	players1[p].join_frame = frame_num;



proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


demo_mode()
-----------
after pm_main is done:

// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 1;
active_local_player = 0;




in netgame client only stays alive for approx 5 sec or 200 frames after lock

can do next level good, but then 5s into next level same...

demo seems to exit good now...


-----------

when client quits...player lost server connection

this was missing:
void client_process_sdat_packet(void)
{
   players1[p].client_last_sdat_rx_frame_num = frame_num;

seems to work good now...


there are 3 places after run game where stuff is reset...can i make it one place?
actually only 2...commandline line immediatley exits
easier to make them the same...done


when new players come active in demo mode they don't start at the right position

how about when they come active at all...

when is 'get_player_start_pos()' called? 3 times:

in load level for player 0 only

after death

init player mode 2 (after level done)

--------------------


remove from init player mode 2 (after level done)

add to when they come players come active


----------------------------------------------------------
Make a new list of when set_player_start_pos called
----------------------------------------------------------
3 times
- load level for all players
- when player comes active
- after death


----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;




server init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
players[0].control_method = 3; // server_local_control
ima_server = 1;

server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client init()
-------------
// initialize all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;




server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


load_gm()
---------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].control_method = 1;


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


not sure about this one:

its run every time start_mode loads a level
- new game
- level done
- NOT run game


i agree its not needed for run game, because load_gm took care of that

what does new game set up before start mode?? nothing

i should bring back start_mode 3


redo start modes....         start_mode = 1;
         game_exit = 0;

1 = new game (single player) do init 1
2 = level done (do init 2)


3 = new game (client

9 = file play

done...

now make start mode 1 clear everything

I can't beacuse it is called by single player start as well as server and client




proc_start_mode()
-----------------
if (start_mode == 1) // skip this for run demo game
{
   // reset player data
   for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);



------------------------------------------------------------------
major refactor...
------------------------------------------------------------------


I want to have more of my start up code in pm_main.


change its name to game_loop

make it take a variable..start_mode

make it set game_exit = 0 on entry



make it so that all the times its called for each mode, the code is common

make it so that more of my player setup is doen there.




how many modes can it be started in??


1 single player new game
2 server new game
3 client new game
5 level done
7 resume single player
9 run demo mode

also make some common exit code




list where called:
-demo mode

game menu x 6
-new
-resume
-server
-client
-after level editor
-run demo


command line x 7
- client 1 arg
- server 1 arg
- client 2 arg
- server 2 arg

- immed run 1 arg
- immed run 2 arg

- run demo



---------------------------------------------------------

game_exit = 0 set in game_loop start
rename pm_main to game_loop and pass it start_mode
then in turn pass start mode to proc_start_mode()

I can make start mode totally local to game_loop, but how will I deal with level_done setting it??

for now just set global to passed...

void game_loop(int passed_start_mode)
{
   start_mode = passed_start_mode;
   game_exit = 0;

this is all because of proc_level_done which also sets start_mode

game_loop()
   proc_controllers()
      proc_game_move()
         proc_level_done()

ill fix this later....

next move this to proc_start_mode()


   if (start_mode == 2) // server
   {
      if (!server_init())
      {
         server_exit();
         game_exit = 0;
      }
   }

   if (start_mode == 3) // client
   {
      if (!client_init())
      {
         client_exit();
         game_exit = 0;
      }
   }


make common exit code after

void game_loop(int passed_start_mode)
{
   while (!game_exit) // game loop
   {
   }

   // common exit stuff...
   if (ima_server) server_exit();
   if (ima_client) client_exit();
}



-------------------------------------------------------
now client init is only called once in start mode...
now client exit is called only 2 times...
once if client init fails
once at end of game loop if ima_client

same for server...


test...join good.


server can't re-start...failed to open listening channel....


is something setting ima_server to 0 before game_loop ends??

yes...proc_game_move when player goes inactive..
remove all stuff from there that messes with client or server player stuff
do it at end of game_loop()

done...

when client is waiting to join set level display to start pos...


moved player init to proc_start_mode common like this:

   if (start_mode == 5) // start new level after level done
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
   }
   else // 1, 2, 3, 9 - full player data reset
   {
      for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
   }


then removed from:
client init()
server_init()
load_gm()


----------
test
single player good
client join good

client needs to set player pos while waiting to join...fixed
in load_level() set all players pos not just 0

client seems to take longer to join now...



----------------------------------------------------------
make a new list of where I call init_player()
----------------------------------------------------------

initial_setup()
---------------
// init all players
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;


proc_start_mode()
------------------
if (start_mode == 5) // start new level after level done
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 2);
}
else // 1, 2, 3, 9 - full player data reset
{
	for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
	players[0].active = 1;
}


server exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;

client_exit()
-------------
// reset player data
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1; // local_control
active_local_player = 0;

server finds new player slot after rx CJON
------------------------------------------
init_player(cn, 1);
players[cn].color = color;
players[cn].control_method = 2; //server client view only
players1[cn].who = who;
players1[cn].server_last_sdak_rx_frame_num = frame_num + 200;
players1[cn].game_move_entry_pos = game_move_entry_pos; // so server wont try to sync any moves less than this


after run demo game from menu
----------------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file


demo_mode() on exiting
----------------------
for (int p=0; p<NUM_PLAYERS; p++) init_player(p, 1);
players[0].active = 1;
active_local_player = 0;
get_config_values(); // restore player color from config file

I am pretty confident about this....

----------------------------------------------------------------------------------

start_mode...

start_mode when calling game_loop only need to be processed the first time
EXCEPT for level done...

why not just make an exception for that...

make level_done have a new value of 2...

in game_loop:

if (level_done == 2) proc_start_mode(5);

before game_loop while

start_mode is no longer global and has a very small scope



---------------------------------
list of all level_done references
---------------------------------

in start_mode common set to 0

in item collision door and warp, set to 1

in single player control:
if (level_done == 1) add_game_move(frame_num, 6, 0, 0);

in server_local_control(int p)
if (level_done == 1) add_game_move(fn, 6, 0, 0);

in proc_level_done()
level_done = 2;

in game_loop()
if (level_done == 2) proc_start_mode(5);


----------------------------------------
list of all places resume_allowed is set
----------------------------------------

only 2 places set to 0
- level is loaded
- start level changes

only one place set to 1
- exit game in single player mode

-----------------------------------------------------------

demo mode wont quit...
esc just starts new demo

fixed start mode resetting control_method 1
remove setting control_method 1 in load_gm...now just done in start mode


-----------------------------------------------
List of at all the places control_method is set
-----------------------------------------------

zplayer.cpp sets it  1 time
---------------------------
init_player (full mode)
players[p].control_method = 0;


zclient.cpp sets it 5 times
---------------------------
when SJON rx
players[cp].control_method = 4;

4 times for check dif


zserver.cpp sets it 2 times
---------------------------
in server_init
players[0].control_method = 3; // server_local_control
ima_server = 1;

when setting up new client
players[cn].control_method = 2; //server client view only

zcontrol.cpp sets it 2 times
----------------------------
when player comes active:
if ((ima_server) || (ima_client))
   if (p != active_local_player) players[p].control_method = 2;
// if player 0 is file play all added players will be too
if (players[0].control_method == 1) players[p].control_method = 1;

when remote client goes inactive:
players[p].control_method = 9; // prevent re-use of this player number in this level


zloop.cpp sets it 2 times
-------------------------
after level done free used clients
if (players[p].control_method == 9) players[p].control_method = 0;

in proc_start_mode()
if (start_mode == 9) players[0].control_method = 1;




fixed bug in load gm that was only erasing 10,000 game moves instead of 1,000,000
look at all references to game_moves
made a common clear_game_moves()
made a define for GAME_MOVES_SIZE 1000000



old:

   if (--players1[p].made_active_holdoff < 0) players1[p].made_active_holdoff = 0;
   if ((!players1[p].made_active_holdoff) && (players[p].active == 0) && (players[p].control_method == 2) && (players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      players1[p].made_active_holdoff = 6;
      add_game_move(frame_num + 4, 1, p, players[p].color);
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }


new:

if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
{
   if (players1[p].made_active_holdoff) players1[p].made_active_holdoff--;
   else if ((players1[p].server_sync < 4) && (players1[p].server_sync > -2))
   {
      add_game_move(frame_num + 4, 1, p, players[p].color);
      players1[p].made_active_holdoff = 6;
      sprintf(msg,"Player:%d has locked and will become active in 4 frames!\n", p);
      if (L_LOGGING_NETPLAY_JOIN) add_log_entry2(11, p, msg);
   }
}




-------------------------------------------------------------
I should straighten out what happens when a player quits...
-------------------------------------------------------------

it all starts when a player presses the menu key or escape...

all modes:

set_comp_move_from_player_key_check(p);

// if menu key ignore everything else and set to 127
if (key[players1[p].menu_key])  cm = 127;
if (key[ALLEGRO_KEY_ESCAPE])    cm = 127;


when this comp_move is sent to add_game_move(frame_num, 5, p, players1[p].comp_move);

it is converted to a special player state move:

if ((type == 5) && (data2 == 127)) // change menu key to player state inactive special move
{
	game_moves[game_move_entry_pos][0] = frame;
	game_moves[game_move_entry_pos][1] = 1;     // type 1; player state
	game_moves[game_move_entry_pos][2] = data1; // player num
	game_moves[game_move_entry_pos][3] = 64;    // inactive
	game_move_entry_pos++;
	return; // to exit immediately
}


single player adds to local game moves array

in proc game move:
if (players[p].control_method == 0)
{
	game_exit = 1;
	resume_allowed = 1;
}


client sends raw move (5, 127) to server
server has special case to set frame to future (frame + 2)
server adds it with add_game_move() where it is converted to player state

server has a special case that just adds 2 to the frame number
   // this special case here is to fix bug that occurs when server_lead_frames > 0, and quit move doesn't get synced back to the client
   if (cm == 127) // client quit
   {
      add_game_move(fn+2, 5, p, cm);  // put in future
      sprintf(tmsg2,"<-- player:%d quit\n", p);
   }
   else
   {
      if (c_sync >= 0) add_game_move(fn, 5, p, cm); // add to game_move array


server drops client in proc_game_move() like this:
         // remote player quit
         if (players[p].control_method == 2)
         {
            players[p].active = 0;
            players[p].control_method = 9; // prevent re-use of this player number in this level
            players1[p].who = 99;

            // only makes sense to show this if not local player
            show_player_join_quit_timer = 60;
            show_player_join_quit_player = p;
            show_player_join_quit_jq = 0;
         }
other clients drop this client in the same way



client drops itself in proc_game_move() like this:
         // local client player quit
         if (players[p].control_method == 4)
         {
            if (val == 64) players1[p].quit_reason = 90;
            game_exit = 1;
            if (L_LOGGING_NETPLAY)
            {
               sprintf(msg,"Local Client(%s) quit the game.",local_hostname);
               add_log_entry_header(10, p, msg, 1);
               log_ending_stats();
            }
         }



what if I add to the frame number in add_game_move()??
then I can remove exception in server rx cdat

it will add for all modes, but that should be OK...

do it...done...still works...


what happens with player drop?
client...
quits the whole damn game with fast exit()!
that's too severe...what else can I do?

set game_exit = 1?

before that I want other client and server to know whats happening
or should I let the server take care of that??

well, if I've lost server connection, it doesn't make sense to send something to the server...

lets just set game_exit = 1 and:
players1[p].quit_reason = 75;
log_ending_stats();

the code at the end of game loop will clean up for me...

server:


void server_proc_player_drop(void)
{
   // check to see if we need to drop clients
   for (int p=1; p<NUM_PLAYERS; p++)   // server only; skip p[0]
      if (players[p].control_method == 2)
      {
         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", frame_num, players1[p].server_sync, p);
            add_game_move(frame_num + 4, 1, p, 71); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
         if (players1[p].server_last_sdak_rx_frame_num + 100 < frame_num)
         {
            //printf("[%4d][%4d] drop p:%d \n", frame_num, players1[p].server_last_sdak_rx_frame_num, p);
            add_game_move(frame_num + 4, 1, p, 71); // make client inactive (reason no sdak for 100 frames)

            sprintf(msg,"Server dropped player:%d (last sdat rx > 100)", p);
            if (L_LOGGING_NETPLAY) add_log_entry_header(10, p, msg, 1);
         }
      }
}

---------------------------------------
how does quit reason work?
---------------------------------------

in the player struct we have: players1[p].quit_reason

void log_reason_for_client_quit(int p)
{
   char tmsg[80];
   sprintf(tmsg,"unknown");
   int r = players1[p].quit_reason;
   if (r == 64) sprintf(tmsg,"player quit game with ESC");
   if (r == 70) sprintf(tmsg,"server drop (server sync > 100)");
   if (r == 71) sprintf(tmsg,"server drop (no sdak for 100 frames)");
   if (r == 74) sprintf(tmsg,"client never became active");
   if (r == 75) sprintf(tmsg,"client lost server connection");
   if (r == 80) sprintf(tmsg,"level done");
   if (r == 90) sprintf(tmsg,"local client quit");
   if (r == 91) sprintf(tmsg,"local server quit");
   if (r == 92) sprintf(tmsg,"remote server quit");
   sprintf(msg,"reason for quit...........[%s]", tmsg);
   add_log_entry_position_text(22, 0, 76, 10, msg, "|", " ");
}



when client drops due to lost server connection:
players1[p].quit_reason = 75;
log_ending_stats();




in proc_game_move() when the special game move player state is read,
if (val > 63) it a player drop and val is quit reason


when players quit with esc reason is set to 64
this is done in add_game_move() and is common to all...

when players are dropped by server it is set to 70 for sync and 71 for sdak


proc_game_move() reads the special game move player state and if inactive:
by default sets:  players1[p].quit_reason = val;
at this point it could be 64, 70, 71

then can set these modes:

74 player never became active
90 local client quit the game
91 local server quit the game
92 remote server ended the game

at the end on set inactive:

         if (players1[p].quit_reason == 70) log_ending_stats();
         if (players1[p].quit_reason == 71) log_ending_stats();
         if (players1[p].quit_reason == 74) log_ending_stats();
         if (players1[p].quit_reason == 90) log_ending_stats();
         if (players1[p].quit_reason == 91) log_ending_stats_server();
         if (players1[p].quit_reason == 92) log_ending_stats();

---------------------------------
where is log_ending_stats called?
---------------------------------
4 main places:

proc_game_move() - player inactive
client drop
level done
fast_exit()



made a lot of changes...need to test...something do not seem right....


-----------------------------------------------------------
client init code no line endings in log...fixed
-----------------------------------------------------------

-----------------------------------------------------------
show dif local and server reversed??
-----------------------------------------------------------
void show_state_dif(char *a, char *b)

// make copy of current state
char tmp[STATE_SIZE];
game_vars_to_state(tmp);

// compare copy to modified base state
if (memcmp(tmp, client_state_base, STATE_SIZE))
{
   dif_corr = 1;
   players1[p].dif_corr++;
   sprintf(tmsg, "corrections applied - total corrections:%d", players1[p].dif_corr);
   show_state_dif(tmp, client_state_base); // show dif


looks like a is local b is server

then c1 = a, c2 = b


then here its printed in reverse....

sprintf(msg, "player[%d].active  server:[%d] local:[%d]\n", p, c1_players[p].active, c2_players[p].active );


where would it be easiest to change?

show_state_dif(client_state_base, tmp); // show dif

done.....
-----------------------------------------------------------


-----------------------------------------------------------
when demo runs it leaves log file entries ..done
added erase_log(void);
at end of demo mode and run demo
-----------------------------------------------------------

-----------------------------------------------------------
log player array uses player num for each player..fixe to only use 0 ...done
-----------------------------------------------------------

-----------------------------------------------------------
players colors in log file viewer are bad...
try to get them from the logs
also set them in player init...
too hard, just set them when getting data at start of log file viewer..done
-----------------------------------------------------------








-----------------------------------------------------------
no logging when player come active???
what if client comes active because of stdf instead of game move??
-----------------------------------------------------------


250 server got join
371 server says player locked

492 server says player locked
496 server says player became active


on client
nothing around 371
at frame 500 stdf from 495 to 500 sets player active...


what does game moves say:

server:
-------------
number of entries 1473
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][ 375]-------------PLAYER 1 ACTIVE (color:11)--
[  1][ 496]-------------PLAYER 1 ACTIVE (color:11)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]

client:
-------------
number of entries 1470
deathmatch_pbullets 1
deathmatch_pbullets_damage 5
suicide_pbullets 1
[ gm][  pc][p][cm]
[  0][   0]-------------START (level:4)-------------
[  1][   0]-------------PLAYER 0 ACTIVE (color:10)--
[  2][ 503][1][ 1]  [    ][    ][    ][  ][     ][LEFT]
[  3][ 507][1][ 4]  [    ][    ][    ][UP][     ][    ]



why is client missing those....

why is server missing start...

why does client have stuff that server does not??



old:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 3) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }

new:
   // add initial level info to game_moves array
   // only for modes:
   // 1 single player new game
   // 2 server new game
   // 5 with !ima_client
   // don't do it for client (never enter any game moves on client)
   // don't do for demo
   // don't do for resume
   if ( (start_mode == 1) || (start_mode == 2) || ((start_mode == 5) && (!ima_client)) )
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }



this would explain why client had start info but server did not
also client had higher game move pos so it wouldn't enter new moves....

try this all again...seems to work a lost better now...

-----------------------------------------------------------
-----------------------------------------------------------


4 player works with ubuntu as one of them....

can I speed up chase and lock?

do I need the <2 > -4 things still?




--------------------------------------------------------------
when client joins, after getting initial state,

gets 14 more stdf until caught up and can acknowledge??

why cant we acknowledge first one??


looks like the first dif received was not applied
base was zero, but current did not match??
current = 0
should force...

does this happen every time? yes...

fixed that on client by setting frame_num after initial stdf rx, but before dif applied...

now:

dif gets applied on client and clients sends sdak on frame 142

server does not rx until frame 163
by then server has sent many more stdf's and fails to set new base for client

why is client 20 frames behind??

client gets first timer adjust at 162 with first sdat rx and is already 20 frames behind
server sends it at 142


is client timer slow until first adjust?? no

does start mode write over my start frame stuff?? no



-----------
new data

client fps = 40
client gets all 4 pieces of stdf (0-150)
client applies dif and sets frame_nums to 150

[client frame 150]
recieves all 4 peices of same stdf again
receives sdat from 154 and sets timer to 43
receives 2 4 peices of next stdf (0-155)
applies dif (0-150) again


[client frame 151]
client timer = 43
receives sdat from 174 and sets timer to 62

[client frame 153]
gets complete dif from (0-175)

[client frame 157]
receives sdat from 178 and sets timer to 60

[client frame 161]
gets complete dif from (0-180)

[client frame 163]
receives sdat from 182 and sets timer to 58




------------------

does it do the level load??

client init

load level

game loop start

client blocks for initial state

client chase



-------------
new data

[client frame 121]
client gets all 4 pieces of stdf (0-121)
client applies dif and sets frame_nums to 121

[client frame 122]

receives sdat from 125 and sets timer to 42
client gets all 4 pieces of stdf (0-125)

receives sdat from 129 and sets timer to 46
client gets first 2 pieces of stdf (0-130)

receives sdat from 145 and sets timer to 62
client gets first 3 pieces of stdf (0-145)



what if i flush the client rx buffer after good state rx'd? no dif
try setting stdf freq to 80...no dif


still cant figure out why client is 20 frames behind...



I put some time calls in client code and I dont see any delays....
do the same for server...





server send initial state on server frame 144 clock 6785

client gets it at clock 1350 and sets frame 144 to equal clock 1352

client gets sdat on frame 145 clock 1371 from server frame 166

server's clock was 7335 when it sent sdat 166



time dif at initial state rx:
server sent:6785
client rx: 1350
------------------
           5435



time dif at first sdat packet
server sent:7335
client rx: 1371
------------------
           5964



5964-5435 = 529ms / 25ms per frame = 21 frames



server:
166-144 = 22 frame * 25ms = 550ms
6785 + 550 = 7335
server checks out good


client:





tried TCP also

started at 10 sync then went down for 10 frames to 8
then got 9 sdats in one frame and went to 29



--------------------
just a thought...what if I did the chase part first?
then when that was good, just blast a state through
after rx sjon client starts in mode 2 inactive and uses sdats to chase and lock
--------------------------------------


20180616

all that I am doing here is to discover the 20 frame half second pause between
getting initial state and getting first sdat..

on the server I show a time stamp at the start of every server_control()
and make sure they agree...


server
------
frame 214
8507 server tx sjon
8507 server tx sdat

then every 25ms clock is working good

server sends another sdat every frame for sync

frame 236
9058
finally rx sdak and stak


client
------
first clock is 1146 after level start
1147 waiting for game state
1150 214 frame_num updated
1166 215 rx sdat and already 20 frames late

need more clocks on client...

client send cjon
client rx sjon


i think i found my delay.....

771 client tx cjon 771
803 client rx sjon 803
1313 after level start


705 tx cjon
746 rx sjon
768 after clear game moves array

stimp() takes 400 frames......

remove for netgame...

client for sure but also server for level done so just do both...

606 client tx cjon
624 client rx sjon
646 after clear game moves array
721 after load level

--------------------------------------------
just a thought....
I would love to do without load level for client joining and just let the initial state do it...
what is missing??
lift step data
bullets (not loaded with level anyway)

i load the level, but when I get initial state I overwrite almost everything

ok if add list steps, what else should I do??, bullets??
remove unused in player...

how big is lift steps?? 25600

lets just leave it for now...

--------------------------------------------

remove clocks...done

what if I made timer adjust twice as much adjust?

old
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - frame_num;
   int fps_chase = frame_speed + players1[p].client_sync - server_lead_frames;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));

new
   // client timer adjust
   players1[p].client_sync = sdat_frame_num - frame_num;
   int fps_chase = frame_speed + (players1[p].client_sync - server_lead_frames)*2;
   if (fps_chase < 4) fps_chase = 4; // never let this go negative
   al_set_timer_speed(fps_timer, ( 1 / (float) fps_chase));




---------------------------------------------------------
just a thought

proc_controllers()

acts differently when in menu vs game

this is controlled by game_exit

what if I just passed something to proc_controllers()
run one way if in game, another for menu, another for key only...
maybe later.....


---------------------------------------------------------


restore all things...
- stdf_freq
- sync_freq


what about server send sync...

can i fine tune it for each player?

like if they have high server sync, send more often??


2 is normal (1 + server_lead_frames)

add to player struct:
int server_sdat_sync_freq;
by default set to 0;

0  every frame
1  every other frame
20 every 20 frames

adjust when setting sync, when rx'ing sdaks

done....


sometimes client gets ahead of server before rx first sync
then client can get a pile of sync sdat's and adjust timer for each one
but only the last one matters...

remove client_flush...

can i combine rx sdat and timer to one log line...done

set stdf_freq to 10


what if i hold off sending more stdf's after initial, until locked?
or until initial has been ack'd and new base set?


simplify this complicated mess....


         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         do
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
         } while ((players[p].control_method != 2) && (not_found < 8));
         if (not_found == 8) p = 0;   // if no clients found set to 0 so no send will happen
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send



         int p = players1[0].n_stdf; // get last player we sent to
         int not_found = 0;
         int loop_done = 0;
         while (!loop_done)
         {
            if (++p > 7) p = 1; // only look at 1-7
            not_found++;
            if ((players[p].active) && (players[p].control_method == 2)) loop_done = 1;
            if (not_found > 8) // no clients found
            {
               loop_done = 1;
               p = 0; set to 0 so no send will happen
            }
         }
         players1[0].n_stdf = p;      // set last player we sent to
         if (p) server_send_stdf(p);  // send




run a test with 3 clients..all good

its important to flush client and server at level done and wait after...
not sure why...


----------------------------------------------------------------
if client does not get reply from server game starts anyway..fixed
----------------------------------------------------------------


----------------------------------------------------------------
when starting log file viewer with pm -lr, if no log files exits badly..fixed
----------------------------------------------------------------


----------------------------------------------------------------
don't save any log file unless in netgame mode..done
remove L_LOGGING and replace with L_LOGGING_NETPLAY...done
remove L_LOGGING_NETPLAY_timeradjust..done
move version and allegro version logging to client and server init..done
----------------------------------------------------------------


----------------------------------------------------------------
make server sdat log look like client sdat..done
----------------------------------------------------------------

----------------------------------------------------------------
reset ortho double when leaving log file viewer..done
can't set ortho in log file viewer..done
----------------------------------------------------------------

----------------------------------------------------------------
client has both ending stats....fixed....
----------------------------------------------------------------


ran 8 player game with no problems.....


lost y510 on level 5
reason: server drop (no sdak rx for 100 frames)
only active for 4 frames
first and only thing server received was stak on frame 247..really late


lost 4230j on level 6
reason: server drop (no sdak rx for 100 frames)


----------------------------------------
fix get all keys for linux..done
----------------------------------------

spent 6 hours making the graph for log file viewer look great...




in what nested way are these called??

all from game loop:
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();


int player_drop_item(int p);
3 x
1 x in player carry when item dropped
2 x item collision door entry


void draw_pop_message(int c);
1 x in draw_item

void draw_door(int c, int x, int y);
1 x in draw_item

void do_bomb_damage(int i);
1 x proc_lit_bomb();

void remove_block(int x, int y);
3 x
2 x proc_item_move(); key
1 x 1 x proc_lit_bomb();


--------how can i simplify these 6 calls from game loop?
proc_item_collision();
proc_item_move();
proc_lit_bomb();
proc_lit_rocket();
proc_player_carry();
draw_items();

to compare, enemy has 3
enemy_move();
enemy_collision();
draw_enemy();


how are they iterated?

proc_item_collision();
500 items then 8 players

proc_item_move();
500 items

proc_lit_bomb();
500 items

proc_lit_rocket();
500 items

proc_player_carry();
8 players


I want to call:
proc_lit_bomb();
proc_lit_rocket();
from
proc_item_move();
done....now its only 4

proc_item_collision();
proc_item_move();
proc_player_carry();
draw_items();

can I move player carry somewhere??

add code in main player code to reset scale and rot if not in paused 2 or rocket
what if I just reset it by default and let someething change it if it needs to...
cant make that work..just reset after door move done and when drop rocket...

also when rocket explodes...
when rocket explodes it turns into a lit bomb
when lit bomb explodes force drop, reset scale and rot there... seems to work



now I want to patch this into main player move

void proc_player_carry(void)
{
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (players[p].carry_item))
         if (!players[p].paused || (players[p].paused && players[p].paused_type == 2))// player is carrying item
         {
            int pc = players[p].carry_item-1; // number of item
            if (item[pc][0] != 98)            // not lit rocket
            {
               // set item position relative to player that's carrying it
               itemf[pc][1] = players[p].PY - al_itofix(2);
               if (!players[p].left_right) itemf[pc][0] = players[p].PX - al_itofix(15);
               if (players[p].left_right) itemf[pc][0] = players[p].PX + al_itofix(15);
            }
            if (!players[p].fire) // drop
            {
               if (player_drop_item(p) < 6)
               {
                  if (item[pc][0] != 98)            // not lit rocket
                  {
                     itemf[pc][2] = players[p].xinc;  // inherit the players momentum
                     itemf[pc][3] = players[p].yinc;
                     if (players[p].up)    itemf[pc][3] -= al_itofix(6); // throw item upwards
                     if (players[p].left)  itemf[pc][2] -= al_itofix(2); // throw item left
                     if (players[p].right) itemf[pc][2] += al_itofix(2); // throw item right
                  }
                  else // drop a rocket
                  {
                     players[p].draw_rot = al_itofix(0);
                     players[p].draw_scale = al_itofix(1);
                  }
               }
            }
         }
}

void proc_player_carry(int p)

done...


rot not fixed after death



lets rename zemove to zenemy..done

lets move all file stuff to zfile and lose yfilecom..done

lets put underscores in all z files..done




---------------------------------------------------------
what happens if a client gets a dif with the wrong base from the server?
a log entry is created, but no other handling is done...
this can't be an issue cause it works, I'm just curious....

when could this happen?
client updates base, but ack never makes it back to server...

then server will keep sending difs with new dest, but same src that client does not have
client will never ack, cause they have wrong base

how about if client gets wrong base, it acks with correct base?

this cant be done in apply because it checks every frame and will often have base

do it when the full packet is rx and decompressed...at that point the src better match...

maybe it can be done in apply, but only on the frame where dest = frame
yes, that should work...

its just re-sending the ack, that for some reason the server does not have
then the server will detect the mismatch and reset base to 0



      if (client_state_base_frame_num != client_state_dif_src)  // stored base state does NOT match dif source
      {
         sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
         if (L_LOGGING_NETPLAY_stdf) add_log_entry2(27, p, msg);

         // send ack to server with correct acknowledged base state
         Packet("stak");
         PacketPut1ByteInt(p);
         PacketPut1ByteInt(0);
         PacketPut4ByteInt(client_state_base_frame_num);
         ClientSend(packetbuffer, packetsize);
      }


done.....
---------------------------------------------------------







next..how f'd are the collision checks

proc_item_collision();
500 items - 8 players


proc_enemy_collision();
100 enemies - 50 pbullets
            - 8 players


ebullets
50 ebullets - 8 players

pbullets
50 pbullets - 8 players



I could straighten this out by:
put both bullet checks and item in player

I'm already iterating players...


what needs collision checks?
player - pbullets
       - ebullets
       - enemies
       - items

enemy - pbullets

what if I make the functions like:

proc_player_item_collision(int p)



made all item collision for specific types into their own functions...

               switch (item[x][0]) // item type
               {
                  case 1: proc_door_collision(p, x); break;
                  case 2: proc_bonus_collision(p, x); break;
                  case 3: proc_exit_collision(p, x); break;
                  case 4: proc_key_collision(p, x); break;
                  case 6: proc_freeman_collision(p, x); break;
                  case 7: proc_mine_collision(p, x); break;
                  case 8: proc_bomb_collision(p, x); break;
                  case 10: item[x][6] = item[x][7]; break; // set pop-up message timer
                  case 11: proc_rocket_collision(p, x); break;
                  case 12: proc_warp_collision(p, x); break;
                  case 14: proc_switch_collision(p, x); break;
                  case 15: proc_sproingy_collision(p, x); break;
               }
            } // end of player collision with active item


now I want to call item collison from player_move

where should I do the collision detection?

this means that the order of things in the game loop will change...

old:

      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_collision();
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();
      proc_player_move();
      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();

new:
      if (level_done == 2) proc_start_mode(5);
      proc_scale_factor_change();
      proc_lift_move(0);
      proc_item_move();
      if (ima_server) server_control();
      if (ima_client) client_control();

      proc_controllers();

      proc_player_move();
      proc_item_collision();

      proc_enemy_move();
      proc_enemy_collision();
      proc_ebullets();
      proc_pbullets();
      proc_player_health();
      proc_sound();
      proc_frame_delay();



done

now I call
proc_item_collision(p);
from player_move

collision detection takes place in proc_item_collision(p);

that looks good, now what else?

move ebullet collision to player also
done
proc_ebullet_collision(p);

now enemy collision with player..

         int i = players[p].carry_item-1; // number of item

ok now I have moved all to player move....
player - pbullets
       - ebullets
       - enemies
       - items

the only collision I have left is
enemy to pbullet


got rid of the global EN in z_enemy
now what about EXint and EYint??..done

also rearrage game loop stuff

move some things out of player_move to simplify...looks good

need to test....

of all the things I don't do when paused, i maybe should proc player carry?? so i can carry through doors?

bounds check to be its own funtion...


streamline the 4 player collisions in player move

one function to do all the collision checks, then only call:
proc_item_collision(p, c);
when an actual collision has take place

items:
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
            if ( (players[p].PX  > itemf[x][0] - f16 ) &&
                 (players[p].PX  < itemf[x][0] + f16 ) &&
                 (players[p].PY  > itemf[x][1] - f16 ) &&
                 (players[p].PY  < itemf[x][1] + f16 ) )
            {



enemies:
void proc_enemy_collision_with_player(int p)
{
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if enemy active and not deathcount
      {
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;

         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2)) Ei[e][22] = p+1; // player collision

      }
   }
}


void proc_pbullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (pbullet[b][0])  // if bullet not active skip to next one
      {
         // check for player collisions
         if (deathmatch_pbullets)
         {
            int px = al_fixtoi(players[p].PX);
            int py = al_fixtoi(players[p].PY);
            int bx = pbullet[b][2];
            int by = pbullet[b][3];
            if ((bx > px - 10) && (bx < px + 10) && (by > py - 10) && (by < py + 10))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet



void proc_ebullet_collision(int p)
{
   for (int b=0; b<50; b++)
      if (e_bullet_active[b])  // if bullet not active skip to next one
      {

         // player position
         al_fixed px = players[p].PX;
         al_fixed py = players[p].PY;

         // check for collision with player
         if ((x > px-ax) && (x < px+ax) && (y > py-ay) && (y < py+ay))









void proc_player_collisions(int p)
{

   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // player position
   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;

   // pbullets
   if (deathmatch_pbullets)
   {
      for (int b=0; b<50; b++)
         if (pbullet[b][0])  // if active
         {
            al_fixed bx1 = al_itofix(pbullet[b][2]) - f10;
            al_fixed bx2 = al_itofix(pbullet[b][2]) + f10;
            al_fixed by1 = al_itofix(pbullet[b][3]) - f10;
            al_fixed by2 = al_itofix(pbullet[b][3]) + f10;
            if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
            {
               int pb = pbullet[b][1]; // the player that fired this bullet
               // do something
            }
         }
   }

   // ebullets
   for (int b=0; b<50; b++)
      if (e_bullet_active[b])  // if active
      {
         // new collision box is based on bullet speed and has both x and z component
         al_fixed ax = abs(e_bullet_fxinc[b]);      // enemy_bullet_collision_window x
         al_fixed ay = abs(e_bullet_fyinc[b]);      // enemy_bullet_collision_window y

         // enforce some minimums
         if (ax < al_itofix(4)) ax = al_itofix(4);
         if (ay < al_itofix(4)) ay = al_itofix(4);

         al_fixed bx1 = e_bullet_fx[b] - ax;
         al_fixed bx2 = e_bullet_fx[b] + ax;
         al_fixed by1 = e_bullet_fy[b] - ay;
         al_fixed by2 = e_bullet_fy[b] + ay;

         if ((px > bx1) && (px < bx2) && (py > by1) && (py < by2))
         {
            // do something
         }
      }

   // enemies
   for (int e=0; e<100; e++)
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((px > ex1) && (px < ex2) && (py > ey1) && (py < ey2))
         {
            Ei[e][22] = p+1; // player collision
         }
      }

   // items
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;

         if ((px > ix1) && (px < ix2) && (py > iy1) && (py < iy2))
         {
            // do something
         }
      }
}


----------------


I've made a lot of changes


now I need to do a thorough testing....

20180618

ride rocket
drop rocket
ride rocket till it explodes rarely doesnt reset player size and rot

where do i reset player size and rot?
now only one place...by default in move_player
after not paused, because I dont want to mess with paused
before rocket beacuse rocket will set it..
seems simpler and seems to work

ride lifts up and down don't line up good with lift floor
switched move lifts to before move_player

bombs...


ride rocket
drop rocket
ride rocket till it explodes
multiple player ride rocket
shoot while riding rocket
get hit with bullet while riding rocket

player item collison when riding rocket

ride rocket through door




doesnt drop rocket

according to door entry, items should be dropped if move type != -2
and rocket is set to -1

does it pick it up again really quick?

when riding rocket, i don't check for collisions?? no, i still do..

what do I want to happen?
when player riding rocket and hits door, drop rocket and travel through door

what actually happens?
nothing

player collision works for other items when riding rocket

when entering door rocket is dropped, but then picked up again right away...

both happen when processing item collision...

first door drops, then rocket pickes up...

how about if you drop an item one frame, you cant pick up until next frame...
sounds convoluted, is there an easier way??

its an exception for door entry only so things dropped stay dropped

why does re-picking up the rocket cancel door entry??
i dont know         int i = players[p].carry_item-1; // number of item


i think the door does the instant move for the player
but then the rocket moves it back

the players position for collision only happens before the iteration so when its is updated
its not used for further collsion checking

fixing this could fix it all and more...

done, now all collisions for player use actually players1.PX and PY so if
something in the collisions changes them, the next collisions will use the updated values


need to remove some test print code....



working on ride rocket through door
- only make sense if door if instant move
- can set to instant if auto and riding rocket



- will need to make rocket able to have carry through door flag set


looks like all rockets are set to -1, but code in slider buttons only does 0 and 1

do rockets need to be set to -1?

when touched they are changed to item 98
also if 0 or 1 set to -1
if -2 leave at -2

use glt to make all -1 rockets into 1
leave all 0

actually wouldn't it make more sense for rockets to be -2, -1, 0  ??

1 makes no sense for a rocket...

do it..

in glt set all 1 to -1...done
pde done...
sliders done...

looks like I have the ride rocket through door thing working....

what about carrying items through door?

if not -2 item is left behind

else appears at end after door move
works good, just looks funny when item is left behind during move then appears at end..

what if in paused mode, if carrying, do special draw for item carried??
at the very minimum, dont draw...
how can i set an item to not draw?

unused variables 2 for draw type
how about 1=drawn 0=not

later, this is so minor, add to wish list
------------------



------------------------------------------------
exit level in single player mode is broken

follow it through...

exit or warp sets level_done = 1;
move_player -> item collision...


single player local control adds game move..
proc game move sets to 2

they are in the wrong order in game loop.

before the level_done == 2 check is done, move player sets it back to one...
what's the solution?

make 2 variables? or change order?
level_done_trig
level_done_proc

done...now single and netgame level done are working good..

------------------------------------------------

what else to test??


----------------------

working on bomb explosion stuff.....

redrew the explosion sprites...

changed to have multiple times when the do bomb damage happens, as the explosion grows and moves


what are you trying to do for bomb?



make the blast area more dynamic, circular would be awesome!!

draw a better animation sequence with more shapes for explosion and make it more round



make the block removal work on every frame of explosion so it grows




made a function to show and remove blocks in the blast radius
for now everything else is commented out

fine tune the size and radius of the blast...ok i like it....

now what??

make the explosion shape match...


what if I do scale all by myself and not pass it with 10
yes, 10 is used by other items for different things...









----------------------------------------------------------------
re-did bottom msg to use al_map_rgb() instead of palette color indexes

thinking about how to do stretched text fast without changing target bitmaps

what if I make an array of bitmaps to hold each text line..
the only time I need to change target bitmap, will be when I enter a new one.
I'll do a simple copy of pointers to slide new bitmaps.
Then when I draw all the bitmaps, I can scale them then.

what is the max length in text of a bmsg?? at least 40 lest do 50

height = 8; width = 400; number = 20;

ALLEGRO_BITMAP bmsg_bmp[20];

this code is bad, it just copies pointers:
for (int c=19; c>0; c--)
  bmsg_bmp[c] = bmsg_bmp[c-1];

keep all the bitmaps in the original array and copy to temp array

done...

bottom message has been fixed and looks great
----------------------------------------------------------------








----------------------------------------------------------------
why are num_shapes for animation seq one less than actual??
----------------------------------------------------------------
i don't know... i don't want to change it in case it breaks other stuff, ill just work around it



I am quite happy with the block destruction

now enemies...happy with that...

now players...only do damage once....


its coming along very nicely...





do bomb damge is gone and have been replaced with:

bomb_blocks(c, 2);
bomb_enemies(c, 2);
bomb_players(c, 2);

these are called every frame when in explosion mode.
blocks and enemies destroy every frame, but players only when item[][8] == 1


these are all called in the draw code also:
            bomb_blocks(c, 1); // mark blocks that will be destroyed
            bomb_enemies(c, 1); // mark enemies that will be destroyed
            bomb_players(c, 1);

but with mode 1 that only marks...

cant make it common because...
- i don't want anything but drawing in the draw stuff
- i dont want any drawing in the non-drawing stuff

I'm about out of time for today, but the next things to do are:

make the markings flash based on mod passcount....

fix the fuse burning thing...
i'll probably go to another type of ans, like the original
and make a stopwatch with drawing primitives....


send ratio to 3 bomb_  functions as float int f
no, send range as int..done

well I now have all the bomb stuff looking good

make bomb range a circle in level editor..done

sticky bombs??

when a rocket turns into a bomb do I stop it?, i do now!!

mark player in bomb range with amount of health lost


make a new int in player struct about potential bomb damage

show with health display...i'm prety happy about how it looks now

bomb crosshairs draw when black..fixed


game_events...

remove all calls to 6 and 7 H- and H+
add to individula calls..

mines...done

11 you got shot...




----------------------------------------


i need to redo collisions...

make an easy way to test.....

player vs player bullets....

shoot a player bullet +80 x with no velocity...

make temp player move to move in x or y

ok thats good...

i'm getting lost in collision stuff


very high level stuff..
everything move then check collisions
how is it now

move_players() that call player collisions after move for each player
move enemies that call collision then move for each enemy

do i really need to do the stretch thing for bullet collisions??


first problem to solve, player bullets with players use 10's
then see how the collisons look...seems good...

now see how far away the initial bullet position is
it is zero'd with player

i do one move before leaving bullet creation, then the initial position is better

but by the time it draws its made a second move

move_player creates bullet
then collision
then bullet move
then bullet draw

so why doesn't just doing one initial move work
it does, but doesnt look good...

how am i going fix this

move the bullet moves to before player move in loop...
test...seems good....

suicide pblullets works good now...

bottom messages need to be re-written to use player name or number

use:
z1 for player number
z2 for item or enemy number
z3 ...
z4 for damage



void game_event(int ev, int x, int y, int z1, int z2, int z3, int z4)

case 10:
game_event(10, 0, 0, p, i, 0, item[i][8]);
sprintf(msg, "Player %d hit a mine! Health -%d", z1, z4); new_bmsg(msg); break;

case 11:
game_event(11, 0, 0, p, e_type, 0, damage);
sprintf(msg, "Player %d got shot by %s! Health -%d", z1, enemy_name[z2], z4); new_bmsg(msg); break;

case 12:
game_event(12, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
sprintf(msg, "Player %d hit by %s! Health -%d", z1, enemy_name[Ei[z2][0]], z4)


use Ei[e][26] to track what player killed the enemy..done

is there any way I can mark what player activated a bomb or rocket?
or better yet what player carried it last...

use 13....

set when lit in bomb or rocket..done

use when killing enemy

i think its good!!

now make it so that the last player that touched it gets the credit

fix sound events...done


after extensive changing, bottom messages are looking good.
still to do...

show when player damages another player with bomb

now I show when player takes explosion damage, just need to add from what player

add when player explodes themselves..done

removed screen messages to extra code file...







---------------------------------------------------------
player lags on fast rockets...fixed
---------------------------------------------------------
where is the code that binds them..

its in player move -> void proc_player_riding_rocket(int p)

then item move happens, then draw...

can I bind them in item move??

      // if player riding, bind player to rocket
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }








---------------------------------------------------------
sticky bombs..done
---------------------------------------------------------

what do I need to do to make this a thing?


re-use regular bomb, just modify move code...

for now do it on regular bomb, then later add new move type...

if not being carried, look to see if walls are close, if yes then set xinc, yinc to zero

make a funtion to do that

int is_item_stuck_to wall(int i)
{
   int x = al_fixtoi(itemf[i][0]);
   int y = al_fixtoi(itemf[i][1]);

   if ((is_left_solid(x,y, 0) || (is_right_solid(x,y, 0) ||
       (is_down_solid(x,y, 0) || (is_up_solid(x,y, 0) )

       return 1;

   return 0;
}


i'm ready to make a certain type of bomb

i plan to overload the already overloaded move_type of item

no just use 11 and make a new pde type

no add slider to existing and custom draw code tile 440..done

need to test how it works with lifts..seem to ignore them quite nicely except for regular ride...


---------------------------------------------------------
remote detonation of bombs
---------------------------------------------------------
this will differ from regular bombs in that the timer is replaced by a remote detonator.

whatever player triggers the bomb will always have the trigger.

should save the player num in the item, so a player can have many items triggered

can I reuse existing bomb?

what if I make another mode, mode 3

then when that is done move to mode 2 explosion like normal

can I use 12 for remote/timer?? yes...

make slider..done

when touch first time set mode 3 if 12...done

now add code in proc_lit_bomb()

use 13 to mark player that trigger it

that was easy!!

next make a different bitmap to show the remote detonator.

maybe draw a line to the player

as it is now, another player can steal the trigger by moving the bomb

i want to draw dynamite! 3 red sticks...
with a timer if appropriate, or a red button

537 - 539

looking good...

change color of remote line to gray..done

make editor set the correct initial shape..done

make bottom msg display correctly..done

test multiplayer..work exactly as i thought
players can steal bomb from other players by grabbing the bomb
then the remote belongs to them
it has no effect trying to grab the remote

test carrying remote through doors...good
can't drop it if you wanted to

test carrying bombs through doors...
works fine with remote..

what about a regular bomb?

what happens if it explodes while in door travel??
item is left behind in door travel until travel is complete
player is invincible in door travel


--------------------------------------------

rename and move stuff in editor...

to start with, move the three things that edit text to z_menu

// e_nlv.h
void edit_server_name(void);
int edit_lift_name(int lift, int step_ty, int bts);

// e_nev.h
void show_cursor(char *f, int cursor_pos, int xpos_c, int ypos, int cursor_color, int restore, int rot);
int edit_pmsg_text(int c, int new_msg);

removed global fst[80];

lift name good...
server name good...
pmsg good

fix pm.h..done


rename e_editor to e_editor_main

make e_editor_zfs
put all zfs and sel there...

move from main to zfs...done


these files are good and don't need anything:
bitmap
glt
pde (pde_editor)
special (could use a better name) (object_selection_and_status_windows?) (pde_sel_window)
combine pde...done
sliders
lev (could use a better name) visual level thingy

e_nlv change name to e_lift (has only lift stuff)

these are what really need arranging:

nev
item

fnx

make a new file e_object_viewer



--------------------------------------------
not that long ago I could carry items through moveable doors and it would show...
--------------------------------------------

I must have broke it in my rearrangment of player move..
added player carry at the end of paused mode door travel
now it works like it used to, but...
if drop during travel item goes back to door entry place..why??
because item was inheriting player's momentum in drop item...fixed
now what happens with bomb...

when dropping item in solid blocks...
player drop when checking for stuck, will move it left or right until not stuck
not for bomb, because wall stuck is not done for bomb...

what about rockets??
rocket never travel through doors.
if carry through door is set, rocket will do instant no matter what door is set to..

if not ride through door and fire is pressed, on exit player will snap to riding rocket again...
force drop on entry for this case...

on door entry, every item with carry through flag is dropped:
// check to see if player is carrying an item without the carry through door flag set
if (item[ci][3] != -2)  player_drop_item(p);

so why does rocket act different??

its not getting dropped on door entry
in the long list of item collisions, door is dropping, but then rocket as later item is picking up..
in item collision check for inactive player...done and fixed..



--------------------------------------------------
Rules for items, rockets, doors, bombs.
--------------------------------------------------

- when players are in door move they are invincible


- players can carry items through doors, if the items's carry_through_door flag is set

- if the flag is not set the item is dropped on door entry


- the only things a player can do when in door move is
- drop an item
- trigger a bomb

- if the item is dropped in solid blocks, it will move left or right until free.


- if a bomb is dropped in solid blocks it will stay where it was dropped

- a bomb can expode while in door travel, no player damage, player is paused, invincible


- rockets can be ridden through doors if the ride_through_door flag is set

- rockets will never do door move, they are forced to instant


- doors can be carried through other doors if the flag is set

- doors cannot be carried through themselves






---------------------------------------------------------
cant throw sticky bomb upwards when standing on ground, it gets stuck to ground...fixed
---------------------------------------------------------
// prevent sticky bombs from sticking to the ground when throwing upwards
if ((item[i][0] == 99) && (item[i][11]) && (players[p].up)) itemf[i][1] -= al_itofix(2);





---------------------------------------------------------
flapper uses passount mod for flap...
can i make them all custom based on flap speed?
---------------------------------------------------------

right now I have a counter in the enemy ints that goes from 0-22
and does something for each integer case..

I could convert it to a float and increment it a float ammount each time
then have all my cases based on percentages of the float...

I would need 2 floats (fixed), the counter and the inc
I will make the counter constant and the inc variable
called flap speed...
user will set 0.5 to 8
constant will be from 0-100

Efi[][9] flap speed counter
Efi[][10] flap speed inc


working good...

next thing...

with different flap speeds, the flap y inc is added a different amount of times

so the same flap yinc will have different effect with different flap speeds...

should be easy to make this constant

also maybe show in level editor how much flap yinc is...


the number of times flap is called is

50/flap inc


each time 3 * r * flap yinc..

so max swing = (50/item[i][9]) * 3 * item[i][8]

i want to change 8 to the max + or - amount that flap does...
mark it in editor, then make it happen in code


yflap is now a float from 0 to 4
i will change it to 0-400 and it could be an int...

Efi[][8] can still have a calculated value based on the rest...


target is flap height (Ei[][21])

adjust yflap (Efi[][8]) to make that happen...

equation:

Ei[][21] = (50/Ei[i][9]) * Ei[i][8]

Ei[i][8] = Ei[][21] / (50/Ei[i][9])


----------------

its looking good, but the 2 halves are not symetrical...
they drift...
seek was evening it out, but with seek disabled, drift is totally visible

to fix this i need to make both halves the same

they both need to start at 0
right now the second one starts at f-50

how about if i detect when > 50 and set to 50 exacltly

that seems to do it...


360 base

max 453
min 209

360 - 453 = -93
360 - 209 = 151


is it beacuse I start at 0 which is in the middle of a move
when I should start at 25 or 75 which is a zero point...

what if I rearrange my two halves:

0 to -1 and back to 0

0 to +1 and back to 0

also try a trig function


i am always adding the ammount, but they add up
i need to remove the last add then add a new one...


remove 3

put only flap in 3, then apply




applying the huge amount every time...
if it collides then the huge ammount is taken back..
this is not good...

calculate the difference between last and current...
apply and check for only that...

every time f = 0 save y pos in Ei[][14] for drawing only



can i use trakbot collisons for flapper? yes...

i think flappers are done...

they can still look bad at extreme values, like flap speed < 1 or > 5



-----------------------------------------------------------
make multiple player starts...
-----------------------------------------------------------

could be invisible if only one player...

how will i implement this...


marks starts with number..

0 is primary and all levels must have one

1 and higher are secondary...

if netgame show all
if single player only show 0

when players start if player is > 0 look for second start


how to map...


if st = 1 all players get 0

if st = 2
p0 0
p1 1
p2 0
p3 1


if st = 3
p0 0
p1 1
p2 2
p3 0
p4 1
p5 2
p6 0
p7 1


if st = 4
p0 0
p1 1
p2 2
p3 3
p4 0
p5 1
p6 2
p7 3

1st - count number of starts
2nd - player_num % ns = start


test this
   int p[8] = {0};
   for (int ns=1; ns<9; ns++)
   {
      printf("ns = %d\n", ns);
      for (int q=0; q<8; q++) p[q] = q % ns;
      for (int q=0; q<8; q++) printf("p:%d s:%d\n", q, p[q]);
   }
works

now make code in editor work...
item[][7] start index

now make code in game work...

void set_player_start_pos(int p)

it seems to work...

now how to make it safer..
in editor, enforce that:
- starts must not have duplicate indexes
- starts must have consectutive numbers

- at least one start must exist
- no more than 8 starts exist

in create start, make the new start one plus the old one

when changing start number...

how about on save flag if error and let user fix manually...



for the most part I want start blocks to not even be noticed and have the old behaviour
they are only used rarely when multiple starts are desired


one idea would be to have 2 creators, one for the main start and one for secondary starts
secondary starts would have a different shape

when running the main one it will:
-erase any other index 0
-make a new index 0
-ignore any secondary

when running the secondary one
-find the next position
-enter there



for now mark them with a number...

when level is loaded, save number of starts as global...
when drawing starts only mark with number if more than 1...

do this in level check which is called when level is saved...
or loaded...done...

this will be good enough for now..

- when using the start creator all other starts are erased (no change)
- to make secondary start copy, paste, and change index
- start checks are in place on level save and load
- index numbers are shown when start is drawn only if more than one start
- in sort_item() (editor only) number of starts is updated
- secondary starts only affect when other players join




--------------------------------------------------------------
remote lasts through death, and can trigger remote while death paused..fixed
--------------------------------------------------------------
to fix this make player lose any remotes when dead
bomb will go back to having remote...
OR....bomb could explode!!!
where does player die??
in proc player paused == 1


--------------------------------------------------------------
make block walker and archwag share common code...done
--------------------------------------------------------------
--------------------------------------------------------------
same as bouncer and cannon..done
--------------------------------------------------------------




--------------------------------------------------------------
clean up enemy drawing modes...block walker...done
--------------------------------------------------------------
all have only 2...

where is Ei[e][4] used?

anywhere in draw code??
no..

trakbot uses it for fall count...

removed from archwag and walker...
cleaned up comments related to Ei[][4]...


---------------------------------------------------------
I've somehow inroduced a bug
cloner creator is all screwy
makes a block walker??
podzilla creator makes a cloner??
those are the only 2 things made with creators...
fixed bug in int get_empty_enemy(int type)
done
---------------------------------------------------------




---------------------------------------------------------
cloners to have nicer drawing stuff, like a better shape, boxes around areas, etc
---------------------------------------------------------

what if I draw lines on level background, like lift_lines?

made a new ans 104 for cloner...


split between draw code and move code
I can draw the tiny old status bar in draw

i can set a shape in move...working on getting it looking good...


move the drawing code to draw from lift lines..

make it flash when cloning...

it seems to take too long when cloning instantly

32 frames is almost 1 second

changed to 8 and it looks better

there are times when you dont want the trigger box shown...
like when it is very huge

make a flag to turn it off in cloner...
all three or just trigger...

or trigger and source dest boxes...

done, used Ei[][4] for both...

now make clone happen on earlier count

cloner is coming along nicely

death ans..done

shape in level editor

make creator set
231 - 550

do glt to fix all cloners...
new shape 550 in 1
new draw type 0 in 2
done

-------------------------------------------------------------------
after changing flapper stuff all existing flappers do not work...
-------------------------------------------------------------------

flap speed and flap height

better defaults are:
x 2.7
xa .2

y 2
fs 3
fh 30
hap 60


Ei[][20] height above player
Ei[][21] flap height

Efi[][5] max x speed
Efi[][6] x accel
Efi[][10] flap speed inc


player lit a rocket bottom message on level wiuth no rockets, only flappers, sproingies..fixed

editor pop menu does not scroll up, goes off bottom of level...fixed




---------------------------------------------------------
i miss the first few frame becuae of stimp...
reset frame_nums at end of stimp...fixed
---------------------------------------------------------


---------------------------------------------------------
sometimes when riding rockets, you let go of one and grab another
but you snap to the last one and are drawn there, but you control the new one???
---------------------------------------------------------
problem was in proc_lit_item

      // if any players are riding this rocket, bind then to rocket's position
      for (int p=0; p<NUM_PLAYERS; p++)
         if ( (players[p].active) && (!players[p].paused) && (players[p].carry_item) && (players[p].carry_item == i+1 ))
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];
         }

//      // if player riding, bind player to rocket
//      for (int p=0; p<NUM_PLAYERS; p++)
//         if ( (players[p].active) && (!players[p].paused) && (riding_rocket(p)) )
//         {
//            players[p].PX = itemf[i][0];
//            players[p].PY = itemf[i][1];
//         }



---------------------------------------------------------
when pressed up against a breakable block you shoot through it...fixed
---------------------------------------------------------
only facing right...
added this line to buillet code..
if (players[p].left_right) pbullet[b][4]--;



---------------------------------------------------------
flapper twitches when seek yinc is more than flap yinc??
---------------------------------------------------------

they fight each other...

should i seperate them??



right now I use Ei[14] for base for drawing only


pick a fixed and use it for base y

base_y will only be affected my seek yinc

Efi[e][11] will have base_y

need to set to same as [1] in level editor for initial...
or I could set it to a negative value, to signal emove stuff to set it to 1
for now if zero set to 1


i'm getting lost...
if i cant describe it in words how can i hope to fix it?

y position of flapper...
stored in Efi[][1]

affected by seek yinc and flap

flap needs to have memory of last flap, so it can convert to yinc


i think the two can be added and then checked and applied

but what about when flap goes up and seek goes down??
funny oscillations, that's what....


------------
tried...

make a variable for base_y set only by seek and that got weird...

---------------
could I avoid this by choosing only good values for seek_yinc and flap_height??



what looks bad:

-----------------------
seek_yinc = 2
flap_speed = .5
flap height = 100
when passing through height above player position,
there is a quite noticeable stutter as seek flips from -2 to 2
max flap_yinc = 3.5

----------------------
seek_yinc = 2
flap_speed = 1.0
flap height = 100
when passing through height above player position,
stutter is not as noticeable
beacause flap yinc is bigger in relation to seek_yinc
max flap_yinc = 7


I can avoid this by making sure max_flap is at least 4 times higher than seek

how about if I scale seek based on how far away it it..

more than 100 = full
< 100
get a ratio (100 - df)

implemented this and the above problem is fixed....






block #18 = ladder

make a function to detect if player in touching ladder block...done

add variable to player struct on_ladder...
added to main player struct..took place of old bitmap_index


can get off of ladder by moving away from detection area
except if moving up at top of ladder then I want player to just stop there...


player should be able to shoot if on ladder..done

player should be able to jump off ladder..done

player needs wall collision detection while on ladder..done
player can now navigate single block openings well while on ladder


add to move code if player moves up past top of ladder to just stop moving up
so that player does not fall off ladder...done


jump sets on_ladder to 0
jump only if up is not pressed


when players grabs ladder, need to make sure player is not embedded in wall
or else up and down will not work..
only when grabbing ladder when moving left or right...done



player should have different shape seq when on ladder


I think ladder is done except for new animation seq for ladder move



now what about rope?
block #19 = rope

snap to 0 position when on rope
can only move left and right
can't jump
can't shoot??
can carry
only way to leave rope is down or move off ends of rope left or right



ropes and ladders seem to be working fine, but now I will need
to spend some time doing nice animation sequences


what happens when player is shot?  do they fall off rope or ladder?

what does recoil do to them??
adds to xinc and yinc, then that takes effect when player leaves rope or ladder


how about don't do any recoil when on ladder or rope...




new player shapes.....

1 for jumping

2 for rope
2 for ladder

what process do I have to go through to add them?


brought back from the dead
void fill_player_tile(void)

call it from load tiles instead of other code...

make sure it works...yes it does

it needs these tiles from main tile set:

368-373 (look up)
400-405 (regular)
432-437 (look down)
755 (bullet)

made some changes to main tile set
now players down shapes are 432-437

i want to add 5 more shapes for each player color

438 jump
528-529 rope
560-561 ladder

increase array...

it was already
ALLEGRO_BITMAP *player_tile[16][32] = {NULL};

increase ptilemaps

old was 380x320
new 480 x 320


am i really done with ladder and ropes??


what about jumping on top of ladder?


normally I can jump any time while on ladder
I will not be on ladder after jump
but then I can grab it again with up

i disabled jump while up is pressed to prevent faster ladder climb



fixed this with a few techniques:

- changed order to process jump first and dont do any up if jump pressed

that still speeded up jump held while climbing
because for one frame when not on ladder yinc moved player 6.6
then next frame grabbed ladder again and moved at 3...

so i keep the saem yinc but offest y pos by 2.6...

   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
   }fix all refs to draw item of trakbot...
old 192
new 384

   else
   {
      if (players[p].up)   players[p].PY -=   is_up_solidfm(players[p].PX, players[p].PY, m, 0);
   }


this looks good and works....


---------------------------------------------
fix all refs to draw item of trakbot...done
---------------------------------------------
old 192
new 384


---------------------------------------------
player should be able to throw items down as well as up...done
---------------------------------------------
i did that but terminal velocity of items is only 3 and .1 for gravity
compare to player with terminal velocity of 7.8 and gravity of .6 or .2 for slow


---------------------------------------------
legend boxes flashing are still not seen sometimes...done
---------------------------------------------
use slash marking??
done for cloner, podzilla and key block range




---------------------------------------------
bug in item var 3 move type...done:
---------------------------------------------

   if (bn == 26)
   {
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");
   }


   if (bn == 2)
   {
      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] == -1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");
   }


all items use 2 or 26

non carryable (use type 2)
key
free man

carryable


rocket needs custom button 93

      if (item[num][3] ==  0) sprintf(smsg,  "    Stationary   ");
      if (item[num][3] ==  1) sprintf(smsg,  "       Fall      ");
      if (item[num][3] == -2) sprintf(smsg,  "Ride Through Door");



      if (item[num][3] ==  1) sprintf(smsg, "      Fall        ");
      if (item[num][3] ==  0) sprintf(smsg, "    Stationary    ");
      if (item[num][3] == -1) sprintf(smsg, "      Carry       ");
      if (item[num][3] == -2) sprintf(smsg, "Carry Through Door");



rocket are created with -1 carry??? is this needed??
no, set to 1 by default.. when lit if 0 or 1 they get changed to -1 carry
unless -2 then they stay -2...

need to glt and set all -1 to 1...done




go through all levels

see if cloners need boxes.. up to 100
fix flappers..up to 100


make a level with a huge cannon, like a boss level....done 330

make a level to test if you can chain throwing sproingies..done 331
hell you can do it with a single sproingy
just let go before the top of the jump while holding down so it doesnt get thrown up by inheriting players yinc
then fall on it again while holding fire and jump

reset vls end level before release..not sure what this is...
visual_level_select...to make the extra levels not shown...


20220305

I am back after a few years absense....

Figured out the new dev environment, for windows anyway, linux later


I will put some useful info in the HOWTO dir...I guess I can out everything except the github password with the project...


make level editor use display_transform_double = 2; in 4K done..looks better


make demo mode take 30s instead of 10
don't do demo mode if paused in a level
done



why does cloner show both shapes...fixed

smooth cloner animation sequence 7 steps
did a lot of cleaning up an refactoring cloner trigger stuff and mode stuff,
removed the mode controlling the red green flashes when cloning
now mode is only for telling if in trigger box last frame

what happened to:
sticky bombs?
remote bombs?
the new way of showing circular bomb damage?


they are not there in the official 7.05 release

but they are in the one from sources....

ladders, ropes?

I would like to add for rockets, a line to show where they will go and what blocks they will destroy..done
make the rocket line thing more accurate by moving exactly like real rocket does..done


lets start making some cool levels...
start at level 300


document the dev setup again, especially libnet
done and put in project files

figure out how to do github and add to docs in project...done
password and token saved in truecrypt vault like all my other passwords

document how to edit tileset with gimp and add to docs...done

made 2 new shapes for cloner and made new ans 107 with 9 shapes
added to code and it looks good



where is that randomizing thing I used for groups of enemies?
is it part of glt?? no it is in zoom full screen
press r and selection will be randomized
added to docs



what does start index do?

if multiple starts with multiple start indexes and multiple player start

they get different starts



what if I made an option that cloners could be invincible?
and then I would not have to protect them with layers of blocks
looking for an open variable...cloner is really busy
how about Ei[][30] deathloop count...i mean he should never die right??

ok lets do it

cloners now have the option to be invincible!!


document how to view netgame stats in game...done

make rocket guideline not blink like explosion...
if rocket is going slow enough the guide lines do not show...fixed




how about showing when a object is about to expire
a very small number that shows how many seconds left
if (item[i][14]) al_draw_textf(f3, palette_color[15], x+10, y-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (item[i][14] - 10) / 40);

done...it was one line

now do the same for enemies ..done

if (Ei[e][27]) al_draw_textf(f3, palette_color[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);












the linux version has screen problems too
when going into fullscreen mode, it is the same size as the window before


where is this in code??

-------------------------------------------------------------
z_control.cpp -- function:function_key_check() -- line 500
-------------------------------------------------------------
if (fullscreen) proc_screen_change(  disp_w_wind,    disp_h_wind, disp_x_wind, disp_y_wind, 0);
else            proc_screen_change(desktop_width, desktop_height,           0,           0, 1);


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 980
-------------------------------------------------------------
if (!fullscreen) // detect if window was moved
{
   int x, y;
   al_get_window_position(display, &x, &y);
   if ((x != disp_x_curr) || (y != disp_y_curr))
   proc_screen_change(disp_w_curr, disp_h_curr, x, y, fullscreen);
}


-------------------------------------------------------------
z_control.cpp -- function:proc_controllers() -- line 999
-------------------------------------------------------------
if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
{
   // check to see if we have more resize events piling up
   ALLEGRO_EVENT ev2;
   while (al_get_next_event(event_queue, &ev2))
   {
      if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
      else ret = proc_events(ev2, ret);
   }
   proc_screen_change(ev.display.width, ev.display.height, disp_x_curr, disp_y_curr, fullscreen);
}

-------------------------------------------------------------
z_screen.cpp -- function:proc_screen_change() -- lien 300 999
-------------------------------------------------------------

void proc_screen_change(int new_sw, int new_sh, int new_sx, int new_sy, int new_fs)




This is on windows and works just fine

changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1196 y: 224 w:2308 h:1587 - curr
x:1196 y: 224 w:2308 h:1587 - wind
x:1196 y: 224 w:2308 h:1587 - disp
0:   0 0:   0 w:1154 h: 793 - scrn


This is linux:

Display change
x:1688 y: 842 w: 693 h: 450 fs:0  old
x:1689 y: 868 w: 693 h: 450 fs:0  new   <-------[why does it do this change? +1x +26y]



Display change
x:1689 y: 868 w: 693 h: 450 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1689 y: 868 w: 693 h: 450 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn      <--------- all good to here

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:   0 y:   0 w:3840 h:2160 fs:1  new   <-------[why does it do this change? no change]

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1689 y: 868 w: 693 h: 450 fs:0  new
changing away from fullscreen
x:1689 y: 868 w: 693 h: 450 disp_
x:1689 y: 868 w: 693 h: 450 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1689 y: 868 w:3840 h:2160 - curr         <---------right here wtf changed it
x:1689 y: 868 w: 693 h: 450 - wind
x:1690 y: 894 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:1689 y: 868 w:3840 h:2160 fs:0  old  <-------[why does it do this change? +1x +26y]
x:1690 y: 894 w:3840 h:2160 fs:0  new




win

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:   0 y:   0 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn

Display change
x:   0 y:   0 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1094 y: 184 w:1644 h:1482 - disp
0:   0 0:   0 w: 822 h: 741 - scrn


lin

--------detected move or resize
x:1093 y: 158 w:1644 h:1482 - curr
x:1094 y: 184 w:1644 h:1482 - disp

Display change
x:1093 y: 158 w:1644 h:1482 fs:0  old
x:1094 y: 184 w:1644 h:1482 fs:0  new <-------[why does it do this change? +1x +26y]

Display change
x:1094 y: 184 w:1644 h:1482 fs:0  old
x:   0 y:   0 w:3840 h:2160 fs:1  new
changing to fullscreen
changed to fullscreen
fullscreen:1 display_transform_double:2
x:  37 y:  26 w:3840 h:2160 - curr  <-------[why does it do this change? +37x +26y]
x:1094 y: 184 w:1644 h:1482 - wind
x:   0 y:   0 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:  37 y:  26 w:3840 h:2160 fs:1  new


--------detected move or resize <------------x 60
x:  37 y:  26 w:3840 h:2160 - curr
x:   0 y:   0 w:3840 h:2160 - disp

Display change
x:  37 y:  26 w:3840 h:2160 fs:1  old
x:1094 y: 184 w:1644 h:1482 fs:0  new
changing away from fullscreen
x:1094 y: 184 w:1644 h:1482 disp_
x:1094 y: 184 w:1644 h:1482 disp_
changed away from fullscreen
fullscreen:0 display_transform_double:2
x:1094 y: 184 w:3840 h:2160 - curr
x:1094 y: 184 w:1644 h:1482 - wind
x:1095 y: 210 w:3840 h:2160 - disp
0:   0 0:   0 w:1920 h:1080 - scrn
--------detected move or resize
x:1094 y: 184 w:3840 h:2160 - curr
x:1095 y: 210 w:3840 h:2160 - disp

Display change
x:1094 y: 184 w:3840 h:2160 fs:0  old
x:1095 y: 210 w:3840 h:2160 fs:0  new
^[


i dont get it....is lin moving my window???

can I just force it to be what I want??
keep my own variables for screen x, y, w h??

never overwrite them by reading them...
just compare them to actual..

what do I have now?

extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // either wind in windowed mode or full fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

im going to add:

extern int disp_x_full; // fullscreen (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;




what if I change my code so that all the screen change stuff just changes variables
then once per cycle, if the variables don't match the actual, then process the changes


I have a conflict...

I changed

I have a function that checks if the window has moved by comparing actual to what is stored in curr
if it is different the function assumes that the user moved the window and updates curr

I also have a function that check if the size and position are different from what is in curr and assumes the system fucked it up
and restores it

these are at odds with each other...


what are the things that can change display?
F12
resize event
move detection...





I was having strange issues with fullscreen to windowed and then I discovered it matter the order of:

   al_resize_display(display, disp_w_curr, disp_h_curr);
   al_set_display_flag(display, ALLEGRO_FULLSCREEN_WINDOW, fullscreen);
   al_set_window_position(display, disp_x_curr, disp_y_curr); // make sure to set position last!!!



now in lin I get this weird ness





Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:2360 h:1124
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

process_screen_change end
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 842 y: 210 w:2360 h:1124
wind - x: 842 y: 210 w:2360 h:1124

resize final
disp - x: 842 y: 210 w:2360 h:1124
curr - x: 843 y: 236 w:3840 h:2160
wind - x: 843 y: 236 w:3840 h:2160

move
disp - x: 842 y: 210 w:2360 h:1124
----------------to fullscreen

enforce display difference
disp - x: 842 y: 210 w:2360 h:1124
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x:   0 y:   0 w:3840 h:2160
curr - x:   0 y:   0 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

We got a window resize event while in fullscreen...this is unexpected
--------------to windowed

enforce display difference
disp - x:   0 y:   0 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

process_screen_change end
disp - x: 843 y: 236 w:3840 h:2160
curr - x: 842 y: 210 w:3840 h:2160
wind - x: 842 y: 210 w:3840 h:2160

move
disp - x: 843 y: 236 w:3840 h:2160









omfg I think it is almost 100% working.....in linux too

same as win....


how about the only time I care about window position is when entering full screen mode or exiting the program
other than that I don't care about constantly monitoring it
seems to work good


resize event in linux seem to alway return x=1 y=26...why????

ignore x and y....not as nice in windows...

maybe the problem is the number of resize events I am getting...show them...

maybe the problem I have is that I should not be setting the display x, y, w, h

just read them....


the only time I want to set them is coming back from fullscreen to windowed...

that was is...it was all so simple...i spent days trying to figure that out....


clean up...

old code from control to stop pile up of events....not needed



if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) show_event(ev);
void show_event(ALLEGRO_EVENT e)
{
   int x = e.display.x;
   int y = e.display.y;
   int w = e.display.width;
   int h = e.display.height;

   printf("\nEV-raw-resize event---  x:%d y:%d w:%d h:%d\n", x, y, w, h);
}


            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE)
            {
               // check to see if we have more resize events piling up
               ALLEGRO_EVENT ev2;
               while (al_get_next_event(event_queue, &ev2))
               {
                  if (ev2.type == ALLEGRO_EVENT_DISPLAY_RESIZE) ev = ev2;
                  else ret = proc_events(ev2, ret);
               }
               proc_display_change();
            }
            else ret = proc_events(ev, ret);


new code
            if (ev.type == ALLEGRO_EVENT_DISPLAY_RESIZE) proc_display_change();


20220311
I can now truly say that is done and cleaned up and works great
it is a lot simpler code too.....

checked in

now I want to figure out what is causing the freeze on exit.....

in linux version exiting the game freezes the terminal
CTRL-ALT-END if game has focus or CTRL-C in terminal it spawns

look like I am not shutting down things individually...
I am just calling al_uninstall_system();

put some logging code around it, then try adding all individual ones...


al_destroy_display(*display);

in what order are they created?

first

al_init();

al_create_event_queue();


display = al_create_display(disp_w_wind, disp_h_wind);//

al_register_event_source(event_queue, al_get_display_event_source(display));

al_init_native_dialog_addon())


al_init_primitives_addon())
al_init_font_addon())
al_init_ttf_addon())
al_install_keyboard())
al_register_event_source(event_queue, al_get_keyboard_event_source());
al_install_mouse())
al_register_event_source(event_queue, al_get_mouse_event_source());
al_install_joystick())
al_register_event_source(event_queue, al_get_joystick_event_source());
al_init_image_addon())
   fps_timer = al_create_timer(1/(float)frame_speed);
   sec_timer = al_create_timer(1);
   mnu_timer = al_create_timer(.01);

   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mnu_timer));

   // start timers
   al_start_timer(fps_timer);
   al_start_timer(sec_timer);
   al_start_timer(mnu_timer);

   load_sound();

how can I get a debugger working?

installed gdb

re-compiled  allegro with debug
compiled with debug info
linked with -g

ran gdb ./pm

then run

when it crashed CTRL-C then:



^[[A^[[A
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409
(gdb) where
#0  0x00007ffff7e042a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7ebb43f in al_destroy_event_queue () at /lib/liballegro_monolith.so.5.2
#2  0x00007ffff7eba5dc in _al_run_destructors () at /lib/liballegro_monolith.so.5.2
#3  0x00007ffff7ec1a40 in al_uninstall_system () at /lib/liballegro_monolith.so.5.2
#4  0x00005555555c500e in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:572
#5  0x00005555555c6876 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1409





in events.c

void al_destroy_event_queue(ALLEGRO_EVENT_QUEUE *queue)
{
   printf("deq 1\n");
   ASSERT(queue);
   printf("deq 2\n");
   _al_unregister_destructor(_al_dtor_list, queue->dtor_item);
   /* Unregister any event sources registered with this queue.  */
   while (_al_vector_is_nonempty(&queue->sources)) {
      ALLEGRO_EVENT_SOURCE **slot = _al_vector_ref_back(&queue->sources);
      al_unregister_event_source(queue, *slot);
   }
   printf("deq 3\n");
   ASSERT(_al_vector_is_empty(&queue->sources));
   _al_vector_free(&queue->sources);
   printf("deq 4\n");
   ASSERT(queue->events_head == queue->events_tail);
   _al_vector_free(&queue->events);
   printf("deq 5\n");
   _al_cond_destroy(&queue->cond);
   printf("deq 6\n");
   _al_mutex_destroy(&queue->mutex);
   printf("deq 7\n");
   al_free(queue);
   printf("deq 8\n");
}


Purple Martians Version 7.10
Allegro Version: 5.2.8.0
Desktop Resolution: 3840x2160
al_uninstall_audio()
al_destroy_font()
al_shutdown_ttf_addon()
al_shutdown_font_addon()
al_shutdown_image_addon()
al_shutdown_native_dialog_addon()
al_shutdown_primitives_addon()
al_unregister_event_source(event_queue, al_get_keyboard_event_source())
al_uninstall_keyboard()
al_unregister_event_source(event_queue, al_get_mouse_event_source())
al_uninstall_mouse()
al_unregister_event_source(event_queue, al_get_joystick_event_source())
al_uninstall_joystick()
al_unregister_event_source(event_queue, al_get_timer_event_source(mnu_timer));
al_unregister_event_source(event_queue, al_get_display_event_source(display))
al_destroy_display()
al_destroy_event_queue(event_queue)
deq 1
deq 2
deq 3
deq 4
deq 5
deq 6
deq 7
deq 8

Before al_uninstall_system()
deq 1
deq 2
deq 3
deq 4
deq 5


now find:

_al_cond_destroy(&queue->cond);

I got lost here...


level where you fall all the time...the bottom of the screen is just doors that teleport you to the top
then some semi-solid vertical screens that cannons shoot at you through
and a rare rocket that you can ride through them....done

when player is riding a rocket they can pass through semi solid left and right....not so much a bug as a feature......!


------------------------------------------
new bug
------------------------------------------
when player is in key block range being removed weird things happen
it only happens when the key is in the middle of the block range
and the distance from key to center of block range = 0

But it always gets fixes when player leaves block range??

i think what matters is that the player is still touching the key, not in block range...test this
i think it is...also blocks don't get destroyed
the problem was that even though the key was moving, the player was still triggering a collision with it
fixed

show OS type on startup

save window x, y when exiting (only saves when resized or switching fullscreen)...done



I think I have all the debugging enabled:

Allegro:
-DCMAKE_BUILD_TYPE = {Debug | Release | RelWithDebInfo}
I used Debug

remade the library...
make
sudo make install

In the game:
compiler options: -Wall -g
link with -lallegro_monolith_debug

I ran gdb again and bt and where did not show anything new

I ran 'info threads' and 'thread apply all bt'

I got a lot more output, but nothing I can make sense of:


$ gdb ./pm
GNU gdb (Debian 10.1-1.7) 10.1.90.20210103-git
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./pm...
(gdb) run
Starting program: /home/m/Desktop/pm_client22/pm
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[New Thread 0x7ffff4ca7700 (LWP 728683)]

Purple Martians Version 7.10
Allegro Version: 5.2.8.0
[Detaching after vfork from child process 728684]
System ID: Xglx
Desktop Resolution: 3840x2160
[New Thread 0x7fffebe03700 (LWP 728688)]
[New Thread 0x7fffe3fff700 (LWP 728689)]
[New Thread 0x7fffeb602700 (LWP 728690)]
[New Thread 0x7fffeae01700 (LWP 728691)]
[New Thread 0x7fffe9d42700 (LWP 728692)]
[New Thread 0x7fffe9541700 (LWP 728693)]
[New Thread 0x7fffe8b96700 (LWP 728694)]
[New Thread 0x7fffe37fe700 (LWP 728695)]
[New Thread 0x7fffe2f67700 (LWP 728696)]
[New Thread 0x7fffe2766700 (LWP 728697)]
[New Thread 0x7fffe1f65700 (LWP 728698)]
[New Thread 0x7fffe1764700 (LWP 728699)]
deq 1
deq 2
deq 3
deq 4
deq 5
^C
Thread 1 "pm" received signal SIGINT, Interrupt.
0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) bt
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) where
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 ()
    at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0)
    at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60)
    at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0)
    at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8)
    at /home/m/Desktop/pm_client22/src/z_main.cpp:1421
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep ()
   from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll ()
   from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) info threads
  Id   Target Id                                        Frame
* 1    Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"          0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7ffff4ca7700 (LWP 728683) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  3    Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  5    Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"   0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  7    Thread 0x7fffe9d42700 (LWP 728692) "gmain"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  8    Thread 0x7fffe9541700 (LWP 728693) "gdbus"       0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  9    Thread 0x7fffe8b96700 (LWP 728694) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  10   Thread 0x7fffe37fe700 (LWP 728695) "pm"          0x00007ffff7b528b3 in select () from /lib/x86_64-linux-gnu/libc.so.6
  11   Thread 0x7fffe2f67700 (LWP 728696) "pm"          0x00007ffff7b22c61 in clock_nanosleep () from /lib/x86_64-linux-gnu/libc.so.6
  12   Thread 0x7fffe2766700 (LWP 728697) "threaded-ml" 0x00007ffff7b503ff in poll () from /lib/x86_64-linux-gnu/libc.so.6
  13   Thread 0x7fffe1f65700 (LWP 728698) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7fffe1764700 (LWP 728699) "pm"          0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
(gdb) thread apply all bt

Thread 14 (Thread 0x7fffe1764700 (LWP 728699) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x7fffa4000be0, mutex=0x7fffa4000bb0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e22c4f in al_wait_for_event (queue=0x7fffa4000b60, ret_event=0x7fffe1763820) at /home/m/Desktop/allegro5/src/events.c:435
#3  0x00007ffff7f396b0 in _al_kcm_feed_stream (self=0x555563568700, vstream=0x5555639d0900) at /home/m/Desktop/allegro5/addons/audio/kcm_stream.c:697
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x555563568700, _outer=0x555563568700) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x555563568700) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 13 (Thread 0x7fffe1f65700 (LWP 728698) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff744eda8 in pa_threaded_mainloop_wait () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7470a78 in pa_simple_write () at /lib/x86_64-linux-gnu/libpulse-simple.so.0
#3  0x00007ffff7f3d5c9 in pulseaudio_update (self=0x55556387d1d0, data=0x55556388dfd0) at /home/m/Desktop/allegro5/addons/audio/pulseaudio.c:212
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x55556387d1d0, _outer=0x55556387d1d0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x55556387d1d0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 12 (Thread 0x7fffe2766700 (LWP 728697) "threaded-ml"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff744e632 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#2  0x00007ffff7440079 in pa_mainloop_poll () at /lib/x86_64-linux-gnu/libpulse.so.0
#3  0x00007ffff74406ff in pa_mainloop_iterate () at /lib/x86_64-linux-gnu/libpulse.so.0
#4  0x00007ffff74407b0 in pa_mainloop_run () at /lib/x86_64-linux-gnu/libpulse.so.0
#5  0x00007ffff744e709 in  () at /lib/x86_64-linux-gnu/libpulse.so.0
#6  0x00007ffff625be08 in  () at /usr/lib/x86_64-linux-gnu/pulseaudio/libpulsecommon-14.2.so
#7  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#8  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 11 (Thread 0x7fffe2f67700 (LWP 728696) "pm"):
#0  0x00007ffff7b22c61 in clock_nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7b28443 in nanosleep () at /lib/x86_64-linux-gnu/libc.so.6
#2  0x00007ffff7ed3e79 in _al_unix_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/unix/utime.c:68
#3  0x00007ffff7e33803 in al_rest (seconds=0.0096502640000000039) at /home/m/Desktop/allegro5/src/system.c:520
#4  0x00007ffff7e34c37 in timer_thread_proc (self=0x5555635fbea0, unused=0x0) at /home/m/Desktop/allegro5/src/timernu.c:94
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635fbea0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 10 (Thread 0x7fffe37fe700 (LWP 728695) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed2d8f in fd_watch_thread_func (self=0x7ffff7fa9d80 <fd_watch_thread>, unused=0x0) at /home/m/Desktop/allegro5/src/unix/ufdwatch.c:89
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x7ffff7fa9d80 <fd_watch_thread>) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 9 (Thread 0x7fffe8b96700 (LWP 728694) "pm"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a52d in _al_cond_wait (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:81
#2  0x00007ffff7e3492e in al_wait_cond (cond=0x5555635fdeb0, mutex=0x555563590400) at /home/m/Desktop/allegro5/src/threads.c:380
#3  0x00007ffff7ee8c8d in hotplug_proc (thread=0x5555635709e0, data=0x0) at /home/m/Desktop/allegro5/src/linux/ljoynu.c:658
#4  0x00007ffff7e339ac in thread_func_trampoline (inner=0x5555635709e0, _outer=0x5555635709e0) at /home/m/Desktop/allegro5/src/threads.c:80
#5  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555635709e0) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#6  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#7  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 8 (Thread 0x7fffe9541700 (LWP 728693) "gdbus"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee40b in g_main_loop_run () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff5cdfa36 in  () at /lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 7 (Thread 0x7fffe9d42700 (LWP 728692) "gmain"):
#0  0x00007ffff7b503ff in poll () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff65ee0ae in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff65ee1cf in g_main_context_iteration () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff65ee221 in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff66170bd in  () at /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#6  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 6 (Thread 0x7fffeae01700 (LWP 728691) "pm:disk$3"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
--Type <RET> for more, q to quit, c to continue without paging--c
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 5 (Thread 0x7fffeb602700 (LWP 728690) "pm:disk$2"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 4 (Thread 0x7fffe3fff700 (LWP 728689) "pm:disk$1"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 3 (Thread 0x7fffebe03700 (LWP 728688) "pm:disk$0"):
#0  0x00007ffff7d757b2 in pthread_cond_wait@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff2e175db in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#2  0x00007ffff2e170a7 in  () at /usr/lib/x86_64-linux-gnu/dri/nouveau_dri.so
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 2 (Thread 0x7ffff4ca7700 (LWP 728683) "pm"):
#0  0x00007ffff7b528b3 in select () at /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007ffff7ed9b9a in _al_xwin_background_thread (self=0x5555632e13f8, arg=0x5555632e1390) at /home/m/Desktop/allegro5/src/x/xevents.c:243
#2  0x00007ffff7ed404c in thread_proc_trampoline (data=0x5555632e13f8) at /home/m/Desktop/allegro5/src/unix/uxthread.c:44
#3  0x00007ffff7d6eea7 in start_thread () at /lib/x86_64-linux-gnu/libpthread.so.0
#4  0x00007ffff7b5adef in clone () at /lib/x86_64-linux-gnu/libc.so.6

Thread 1 (Thread 0x7ffff4ca8cc0 (LWP 728679) "pm"):
#0  0x00007ffff7d752a1 in pthread_cond_destroy@@GLIBC_2.3.2 () at /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x00007ffff7e2a503 in _al_cond_destroy (cond=0x7fffa4000be0) at /home/m/Desktop/allegro5/include/allegro5/platform/aintuthr.h:76
#2  0x00007ffff7e22093 in al_destroy_event_queue (queue=0x7fffa4000b60) at /home/m/Desktop/allegro5/src/events.c:152
#3  0x00007ffff7e21791 in _al_run_destructors (dtors=0x5555632f48e0) at /home/m/Desktop/allegro5/src/dtor.c:120
#4  0x00007ffff7e32ec5 in al_uninstall_system () at /home/m/Desktop/allegro5/src/system.c:323
#5  0x00005555555c4f5a in final_wrapup() () at /home/m/Desktop/pm_client22/src/z_main.cpp:573
#6  0x00005555555c6888 in main(int, char**) (argument_count=1, argument_array=0x7fffffffe1b8) at /home/m/Desktop/pm_client22/src/z_main.cpp:1421




what about files: there are 4 things: pm:disk$0 to 3
do I leave any file pointers open?
config uses allegro built in functions to access...they all look good

log?
        filepntr = fopen(filename,"w");
         fprintf(filepntr, "%s", log_msg);
         fclose(filepntr);
         printf("%s saved \n", filename);

others, help, pde, sprit...all look good



there is also pulseaudio and kcm_stream...what the hell are those???


I rebuilt allegro from git source and redid the make file
only chose Debug and Want Monolith

same crap...


what about a simpler program...like display test....


exits fine....

do I keep adding things and see if I can make it die?
or should I work with pm and remove things??

removed sound and it works!!

why do I not have sound stuff in my cleanup...i do..there is nothing for acodec addon..

most likely I am not destroying the xm stream....

         pm_theme_stream = al_load_audio_stream("snd/pm.xm", 8, 1024);
         if (pm_theme_stream == NULL) m_err("Error loading snd/pm.xm\n");

         al_set_audio_stream_playmode(pm_theme_stream, ALLEGRO_PLAYMODE_LOOP);
         al_set_audio_stream_playing(pm_theme_stream, 0);
         al_attach_audio_stream_to_mixer(pm_theme_stream, st_mixer);

         void al_destroy_audio_stream(ALLEGRO_AUDIO_STREAM *stream)

that was the solution...one simple line added to final wrapup
done 20220311



---------------------------------------
bug
------------------------------------------

When you pause and resume a single player game
sometimes it quits to the menu after a while....yes, i can reproduce it
play level for 5 sec the quit to menu, the resume
timer has reset to zero, player has left the game message appears right away
then 5 seconds in the game quits back to menu

where?


zcontrol at the end...

     for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active) // cycle all active players
            {
               if (players[p].control_method == 0) // local single player control
               {
                  if (level_done_trig) add_game_move(frame_num, 6, 0, 0); // insert level done into game move
                  set_comp_move_from_player_key_check(p); // but don't set controls !!!
                  if (players1[p].comp_move != players1[p].old_comp_move)
                  {
                     players1[p].old_comp_move = players1[p].comp_move;
                     add_game_move(frame_num, 5, p, players1[p].comp_move);
                  }
               }
               if (players[p].control_method == 1) rungame_key_check(p, ret); // run game from file
               if (players[p].control_method == 3) server_local_control(p);
               if (players[p].control_method == 4) client_local_control(p);
               set_controls_from_game_move(p); // common for all players
            }   // end of active player iterate
         proc_game_move();  // run once per frame to process system messages from game_move







in saved game...

passcount is reset and player inactive is entered

figured it out...done

the code is rather complex....


---------------------------------------
fixed the code so it compiles without any dumb string errors
---------------------------------------

-----------------------------
bug --  warning in linux about
-------------------------------
||=== Build: ldm in pm (compiler: GNU GCC Compiler) ===|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp||In function void new_bmsg(const char*, int, int, int):|
/home/m/Desktop/pm_client22/src/z_screen_overlay.cpp|519|warning: sprintf argument 3 overlaps destination object b_msg [-Wrestrict]|
/home/m/Desktop/pm_client22/src/pm.h|173|note: destination object referenced by restrict-qualified argument 1 was declared here|
||=== Build finished: 0 error(s), 1 warning(s) (0 minute(s), 0 second(s)) ===|


      // slide_bmsg
      for (int c=39; c>0; c--)
         sprintf(b_msg[c], "%s", b_msg[c-1]);


first of all, why don't I see bmsg? 2 different types probaly took out to make faster
this is the fix...
      // slide_bmsg
      for (int c=39; c>0; c--)
         strcpy(b_msg[c], b_msg[c-1]);

done


-------------------
bug something screwy when exiting game in fullscreen mode on linux
when you come back, you come back with fullscreen, but windowed size???
-------------------------------

cleaned up init_display
forced w and h for fullscreen
did ack_resize after
seems to be fixed now...


I have a bit of a tricky math problem and I was wondering if anyone could provide insight.

Its about trigonometry and systems of equations.

This is all in 2D.

It is trivial to have an enemy shoot a bullet at the player. Simple trig.

But I want to have an enemy shoot a bullet, not at where the player is, but where they will be.
(assuming the player does not change velocity or direction)


My inputs are:
the player's position: px, py
the player's movement: pxinc, pyinc

the origin of the bullet: bx, by
the speed of the bullet: bspeed

What I want for an output is the angle of the bullet to ensure a collision
(or bxinc, byinc which I could calculate from angle)

Every method I can think of involves brute force, iterating through angles until I find a solution

There must be an more elegant solution.

I am trying to think of it as where two lines intersect...
But each line has a different velocity, so the line length are related to time...and speed?

Can any of you smart people help point me in the right direction?



You need to find out at what time(t) will they collide.

Basic position function: S(t) = S(0) + v(t) * t + 1/2 * a(t) * t^2

S(0) = starting position
v(t) = velocity at time t (constant in your case)
a(t) = acceleration at time t (zero if velocity is constant)
t = time

S(t) = S(0) + v(t)t

Can be broken into x,y components:
Sx(t) = Sx(0) + v(t)t
Sy(t) = Sy(0) + v(t)t

What are the player's and bullet's positions?

Player:
Px(t) = px + pxinc * t
Py(t) = py + pyinc * t

Bullet:
Bx(t) = bx + bxinc * t
By(t) = by + byinc * t

this creates a triangle
613141

You can either use x or y

Px(t) = Bx(t) or Py(t) = By(t)

px + pxinc*t = bx + bxinc*t
px - bx = pxinc*t + bxinc*t
px - bx = t(pxinc - bxinc)
t = (px - bx)/(pxinc - bxinc)

You can use original formula to then solve for x and y of final position:
x(t) = px + pxinc*t = bx + bxinc*t
y(t) = py + pyinc*t = by + byinc*t

float findPosition(float &x, float &y,
                  float px, float py, float pxinc, float pyinc,
                  float bx, float by, float bxinc, float byinc)
{
    float t = (px - bx)/(pxinc - bxinc);


    x = px + pxinc * t;
    y = py + pyinc * t;

    return t;
}

It's a mess. Hopefully I didn't miss anything.

Thank you for that. I am working on implementing it.
Time was the key. At what time will they collide?

UPDATE

Unfortunately I was unable to make your method work.

All I have for b is initial position and speed.
I do not have bxinc or byinc or the angle.
That is what I am trying to find.

The way I figured out how to do it was:

iterate on frame (time period) in a loop

for each frame find
- where we guess the player will be
- the distance from that position to the bullet origin
- find out how far the bullet could travel in the same amount of time

When those distances are equal (or close) that is where the will collide.
From the frame number that occurred at, I get the players position
That is where I shoot the bullet.
#SelectExpand
  1void fire_enemy_bulletb(int EN, int bullet_ans, int p)
  2{
  3   al_fixed bx = Efi[EN][0];
  4   al_fixed by = Efi[EN][1];
  5   al_fixed bspeed = Efi[EN][7];
  6
  7   al_fixed px = players[p].PX;
  8   al_fixed py = players[p].PY;
  9   al_fixed pxi = players[p].xinc;
 10   al_fixed pyi = players[p].yinc;
 11
 12   for (int i=1; i<100; i++)
 13   {
 14      px+=pxi;
 15      py+=pyi;
 16
 17      // calc distance from player's new pos to bullet origin
 18      al_fixed xlen = px - bx;  // get the x distance between enemy and player
 19      al_fixed ylen = py - by;  // get the y distance between enemy and player
 20      al_fixed hy_dist = al_fixhypot(xlen, ylen);   // hypotenuse distance
 21
 22      // get distance that bullet would travel in same amount of time
 23      al_fixed bd = bspeed * i;
 24
 25      // if they are close enough pull the trigger
 26      al_fixed bdif = hy_dist-bd;
 27
 28      al_fixed ltol = al_ftofix(-5);
 29      al_fixed utol = al_ftofix(5);
 30
 31      if ((bdif < utol) && (bdif > ltol))
 32      {
 33         i = 100; // break out of loop
 34
 35         al_fixed speed = Efi[EN][7];                     // speed
 36         al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
 37
 38         al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
 39         al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc
 40
 41         for (int z=0; z<50; z++)  // find empty e_bullet
 42            if (!e_bullet_active[z])
 43            {
 44               e_bullet_active[z] = 1;
 45               e_bullet_shape[z] = 1000 + bullet_ans;
 46               e_bullet_fx[z] = Efi[EN][0];
 47               e_bullet_fy[z] = Efi[EN][1];
 48               e_bullet_fxinc[z] = xinc;
 49               e_bullet_fyinc[z] = yinc;
 50               z=50;
 51            }
 52      }
 53   }
 54}

This actually works, but I am sure there is a much better way of doing it.



The closet I can come up with a formula is:

when these two things are equal:

bullet_distance = player_distance_from_bullet_origin

bullet_distance = (bullet_speed * t)


player_distance_from_bullet_origin_x = (px + (pxinx * t) - bx)
player_distance_from_bullet_origin_y = (py + (pyinx * t) - by)

then I need to do the hypot to get actual distance












what if I use my method but seek better?

like start with 10 frames at a time until I pass the limit
then reverse direction 1 frame to pass again
then reverse again and do .1




changed player move so that when player is riding a rocket, player's xinc and yinc are the same as the rocket
they used to be set to zero.
I needed to do that so that the bullets can seek in on the player using xinc, yinc

what enemies use that function? fire_enemy_bulleta()
flapper
trakbot
podzilla
canon

wow!



put this into equation editor
https://www.hostmath.com/

bulletvelocity * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

bspeed * t = \sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }

px + (pxinc*t)
py + (pyinc*t)

\sqrt{(px + (pxinc*t) - bx)^2 + (py + (pyinc*t)-by)^2 }





UPDATE

This is the equation I have come up with:

https://www.allegro.cc/files/attachment/613142

Now the fun part!

Solve for t.

My skills are not up to the task...

20220317
I am happy with my method for now...
I want to bench mark in a level with 100 cannons and see if it slows down...
not at all...
what is I patch this in for all enemies that use it...done




I had a method where I just increased time until I found a close enough solution.
That took a lot of iterations.
And if I wanted it more accurate, I would have to step time even slower, which meant even more iterations

I found a method where I search for t in large steps.
Then when I overshoot it, I reverse direction and decrease the step size...
I keep doing this until I get close enough.
This greatly reduces the ammount of values of t I need to test.

<code>
al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;

   int tries = 0;
   int done = 0;
   while (!done)
   {
      t+=tinc;
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 100) done = 1; // break out in case something goes wrong
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);
}
<\code>

However I consider this entire approach an inlegant brute force method.

I can't help but think there is a better way of doing this.

My whole approach can be condensed to:

Find the time when the player's future position has an equal distance to the bullet origin as the time the bullet will travel in the same amount of time.

Then it is trivial to get the player's future x and y position from the time.

I came up with an equation to describe that, but I don't know if it is possible to isolate t on one side (solve for t)











bug  -- does level actually run while stimp is happening??
did I just change this recently?

when I run the screen overlay frame skip always happens during stimp

change the order of these things:

old
   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

new
   if ((ima_client) || (ima_server))
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      if (L_LOGGING_NETPLAY) add_log_entry_header(10, 0, msg, 3);
   }
   else stimp();

   set_frame_nums(0);
   clear_bmsg();
   clear_bullets();
   clear_keys();
   show_player_join_quit_timer = 0;
   level_done_trig = 0;
   level_done_proc = 0;
   start_music(0); // rewind and start theme

also this:

old
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      set_frame_nums(frame_num); // set fps_timer count to frame_num
      stimp();
      return;
   }

new
   if (start_mode == 7) // resume single player game
   {
      start_music(1); // resume theme
      stimp();
      set_frame_nums(frame_num); // set fps_timer count to frame_num
      return;
   }

that seems to work better












Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.

I'm going to work on finding angle from t. My approach would be to set a time (like say a few seconds) and then find the angle necessary to hit that time.


Edgar's method works great

   float bx = Efi[EN][0];
   float by = Efi[EN][1];
   float bv = Efi[EN][7];

   float px  = players[p].PX;
   float py  = players[p].PY;
   float pvx = players[p].xinc;
   float pvy = players[p].yinc;

   float A = (pvx*pvx) + (pvy*pvy) - (bv*bv);
   float B = 2*(px*pvx) + 2*(py*pvy) -2*(bx*pvx) -2*(by*pvy);
   float C = (px*px) + (bx*bx) + (py*py) + (by*by) - 2*(bx*px) -2*(by*py);
   float t = ( -B - sqrt((B*B) - 4*(A*C)) ) / (2 * A);

   al_fixed px1 = px + al_fixmul(pvx, al_ftofix(t)); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pvy, al_ftofix(t));
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

I don't know how he came up with that equation though

his explanation starts with that














I came up with a quadratic but not quite the same as ER's. It cuts down on the maths chores if you set the origin to be where the bullet starts, and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t). Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations - now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t. There are 2 solutions usually and you have to take the bigger (I don't know why or what the other one means!)

When you have t then work out dx = x + pxinc*t and dy = y + pyinc*t (displacement to where the ship will be)
then bxinc = dx/sqrt(dx*dx+dy*dy)*bspeed and byinc = dy/sqrt(dx*dx+dy*dy)*bspeed


#include <allegro5/allegro.h>
#include <allegro5/allegro_primitives.h>
#include <math.h>
#include <random>

#define W 800
#define H 600

static const float bullet_speed = 5.0f;

struct thing {
  float x;
  float y;
  float dx;
  float dy;
  float radius;
  ALLEGRO_COLOR color;
  float speed;
  bool active;
  thing(ALLEGRO_COLOR c, float r, float s)
      : color(c), radius(r), speed(s), active(true) {}
  void move() {
    if (active) {
      x += dx;
      y += dy;
      while (x < 0.0f)
        x += float(W);
      while (x >= float(W))
        x -= float(W);
      while (y < 0.0f)
        y += float(H);
      while (y >= float(H))
        y -= float(H);
    }
  }
  void draw() {
    if (active)
      al_draw_circle(x, y, radius, color, 1.0f);
  }
  void setup() {
    static std::minstd_rand engine;
    double theta;
    x = std::uniform_real_distribution<float>(0.0f, float(W))(engine);
    y = std::uniform_real_distribution<float>(0.0f, float(H))(engine);
    theta = std::uniform_real_distribution<>(-1.0, 1.0)(engine);
    switch (std::uniform_int_distribution<>(0, 3)(engine)) {
    case 0: // top
      theta += M_PI / 2.0;
      y = 20.0f;
      break;
    case 1: // right
      theta += M_PI;
      x = float(W - 20);
      break;
    case 2: // bottom
      theta -= M_PI / 2.0;
      y = float(H - 20);
      break;
    case 3:  // left
    default: // can't happen
      x = 20.0f;
      break;
    }
    dx = float(cos(theta)) * speed;
    dy = float(sin(theta)) * speed;
    active = true;
  }
};

thing fire(const thing &from, const thing &to) {
  float x = to.x - from.x;
  float y = to.y - from.y;
  float r2 = x * x + y * y;

  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  float A = to.dx * to.dx + to.dy * to.dy - bullet_speed * bullet_speed;
  float B = x * to.dx + y * to.dy;
  float rt = B * B - A * r2;
  if (rt >= 0.0f) {
    float t1 = (sqrt(rt) - B) / A;
    float t2 = (-sqrt(rt) - B) / A;
    float t = std::max(t1, t2);
    float vx = x + to.dx * t;
    float vy = y + to.dy * t;
    float v = sqrt(vx * vx + vy * vy) / bullet_speed;
    bullet.dx = vx / v;
    bullet.dy = vy / v;
    bullet.x = from.x;
    bullet.y = from.y;
  } else {
    // Bullet can't reach the target
    bullet.active = false;
  }
  return bullet;
}
bool collide(const thing &a, const thing &b) {
  float r2 = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
  return r2 < a.radius + b.radius;
}

int main(int, char *[]) {
  al_init();
  al_init_primitives_addon();
  ALLEGRO_DISPLAY *display = al_create_display(W, H);
  ALLEGRO_TIMER *timer = al_create_timer(1.0 / 30.0);
  ALLEGRO_EVENT_QUEUE *queue = al_create_event_queue();
  al_register_event_source(queue, al_get_display_event_source(display));
  al_register_event_source(queue, al_get_timer_event_source(timer));
  bool running = true;
  bool advance = true;
  thing ship(al_map_rgb(255, 128, 128), 10.0f, 1.0f);
  thing ufo(al_map_rgb(128, 255, 128), 10.0f, 2.0f);
  thing bullet(al_map_rgb(128, 128, 128), 2.0f, 5.0f);
  ship.setup();
  ufo.setup();
  bullet.active = false;
  al_start_timer(timer);
  while (running) {
    ALLEGRO_EVENT event;
    al_wait_for_event(queue, nullptr);
    while (al_get_next_event(queue, &event)) {
      if (event.type == ALLEGRO_EVENT_DISPLAY_CLOSE) {
        running = false;
      } else if (event.type == ALLEGRO_EVENT_TIMER) {
        advance = true;
      }
      if (advance) {
        al_clear_to_color(al_map_rgb(0, 0, 0));
        ufo.draw();
        bullet.draw();
        ship.draw();
        al_flip_display();
        ufo.move();
        bullet.move();
        ship.move();
        if (!bullet.active) {
          bullet = fire(ufo, ship);
        } else {
          if (collide(bullet, ship)) {
            ship.active = bullet.active = false;
          }
        }
        if (!ship.active)
          ship.setup();
      }
    }
  }
  return 0;
}




I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.



bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

what???

square LHS of 1...(bxinc*t)^2 is that the same same bxinc^2*t^2...yes

try it out
3^2 * 4^2 = 9 * 16 = 144
(3*4)^2 = 12^2 = 144
yes....i'm good with that...so now I am at


(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2


And I need to expand that...


This method works too...


Clean up how it was derived:

From Peter Hull

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.

(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2














The better solution

After asking for help on the allegro.cc forums I was shown a much better method.

Edgar Reynaldo showed me a quadratic equation to solve for t.

Michael, assuming your theory and your math is correct, I solved for t. You'll still have to apply the quadratic equation to solve it though.

 t^2(pvx^2 + pvy^2 - bv^2)
+t^1(2pxpvx + 2pypvy - 2bxpvx - 2bypvy)
+t^0(px^2 + bx^2 + py^2 + by^2 - 2bxpx - 2bypy)

Just apply the quadratic equation now, and you have your values for t.



Peter Hull showed me a similar method with slightly simpler math.

I came up with a quadratic but not quite the same as ER's.
It cuts down on the maths chores if you set the origin to be where the bullet starts,
and have the player relative to that, ie. work with x = px - bx and y = py - by instead of (px,py) and (bx,by).

The position of the player at time t is (x + pxinc *t, y + pyinc * t) and the bullet is (bxinc*t, byinc*t).
Equate the x-coords and y-coords separately, that's three unknowns, bxinc, byinc and t, with two equations
now add third equation bxinc^2 + byinc^2 = bspeed^2.

bxinc*t = x + pxinc*t (1)
byinc*t = y + pyinc*t (2)
bxinc^2 + byinc^2 = bspeed^2 (3)

I found it easiest to rewrite (3) as
bxinc^2 * t^2 + byinc^2 * t^2 = bspeed^2 * t^2 (4)

Square (1) and (2), substitute them in the LHS of (4)
(x + pxinc*t)^2 + (y + pyinc*t)^2 = bspeed^2 * t^2

Now you can expand the brackets and it's a quadratic in t.




(x + pxinc*t)^2 = x^2 +2pxinctx + pxinct^2
(y + pyinc*t)^2 = y^2 +2pyincty + pyinct^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 = bspeed^2 * t^2

x^2 +2pxinctx + pxinct^2 + y^2 +2pyincty + pyinct^2 - (bspeed^2 * t^2) = 0

t^2 (pxinc^2 + pyinc^2 - bspeed^2)
t^1 (2pxincx + 2pyincy)
t^0 (x^2 + y^2)

A = pxinc^2 + pyinc^2 - bspeed^2
B = 2pxincx + 2pyincy
C = x^2 + y^2

re-written with the variable names I am familiar with:

A = pvx^2 + pvy^2 - bv^2
B = 2xpvx + 2ypvy
C = x^2 + y^2

I tried to covert this to fixed but A B and C are huge:

A:-85899345920.000000
B:1909319532544.000000
C:97443614031872.000000

they totally overflow fixed...so I guess I am stuck with float for now

I am removing all the old code and pasting it here:



al_fixed get_distance(al_fixed px, al_fixed py, al_fixed pxinc, al_fixed pyinc,
                       al_fixed bx, al_fixed by, al_fixed b_speed, al_fixed t)
{
   al_fixed px1 = px + al_fixmul(pxinc, t);                   // get the p position at time t
   al_fixed py1 = py + al_fixmul(pyinc, t);
   al_fixed p_distance_to_b = al_fixhypot(px1-bx, py1-by);    // distance from p to b
   al_fixed b_distance = al_fixmul(b_speed, t);               // how far will b travel in time t
   return (p_distance_to_b - b_distance);                     // difference between distances
}

void fire_enemy_bulletaa(int EN, int bullet_ans, int p)
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed initial_distance = al_fixhypot((px-bx), (py-by));    // initial distance
   printf("\ninitial distance:%f\n", al_fixtof(initial_distance));

   al_fixed t = al_fixdiv(initial_distance, bspeed);         // start time


   al_fixed f0 = al_itofix(0);    // the number zero in fixed format
   //al_fixed t = f0;               // start time
   al_fixed tinc = al_itofix(20); // initial time step
   al_fixed bdif = f0;


   int tries = 0;
   int done = 0;
   while (!done)
   {

      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(1)) && (bdif > al_itofix(-1))) done = 1; // is the difference with the threshold?

      // if (( bdif < al_ftofix(.0001)) && (bdif > al_ftofix(-.0001))) done = 1; // is the difference with the threshold?

      if (((tinc > f0) && (bdif < f0)) ||       // overshot while t increasing
          ((tinc < f0) && (bdif > f0)))         // overshot while t decreasing
         tinc = al_fixdiv(tinc, al_itofix(-2)); // half the increment and reverse direction

      if (tries++ > 50) done = 1; // break out in case something goes wrong
      t+=tinc;
   }
   al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
   al_fixed py1 = py + al_fixmul(pyi, t);
   fire_enemy_bulletz(EN, bullet_ans, px1, py1);

   printf("number of tries:%d\n", tries);

// show where the target position is
   tx1 = al_fixtoi(px1);
   ty1 = al_fixtoi(py1);
   ttc1 = 15;
   //ttfloat1 = al_fixtof(bdif);
   ttfloat1 = (float) tries;


}


/*
void fire_enemy_bulletabf(int EN, int bullet_ans, int p) // the original method of stepping time
{
   al_fixed bx = Efi[EN][0];
   al_fixed by = Efi[EN][1];
   al_fixed bspeed = Efi[EN][7];

   al_fixed px = players[p].PX;
   al_fixed py = players[p].PY;
   al_fixed pxi = players[p].xinc;
   al_fixed pyi = players[p].yinc;

   al_fixed t = al_itofix(0);     // start time
   al_fixed tinc = al_itofix(1);  // time step
   al_fixed bdif = al_itofix(0);

   for (t=al_itofix(0); t < al_itofix(1000); t+=tinc)
   {
      bdif = get_distance(px, py, pxi, pyi, bx, by, bspeed, t);
      printf("frame:%f bdif:%f\n", al_fixtof(t), al_fixtof(bdif));

      if (( bdif < al_itofix(5)) && (bdif > al_itofix(-5))) // is the difference with the threshold?
      {
         al_fixed px1 = px + al_fixmul(pxi, t); // get player target position based on t
         al_fixed py1 = py + al_fixmul(pyi, t);

         fire_enemy_bulletz(EN, bullet_ans, px1, py1);

         t = al_itofix(1000); // break out of loop
      }
   }
}


void old_fire_enemy_bulleta(int EN, int bullet_ans, int p)
{
   al_fixed xlen = players[p].PX - Efi[EN][0];   // get the x distance between enemy and player
   al_fixed ylen = players[p].PY - Efi[EN][1];   // get the y distance between enemy and player
   al_fixed hy_dist =  al_fixhypot(xlen, ylen);     // hypotenuse distance
   al_fixed speed = Efi[EN][7];                  // speed
   al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
   al_fixed xinc = al_fixdiv(xlen, scaler);        // calc xinc
   al_fixed yinc = al_fixdiv(ylen, scaler);        // calc yinc

   for (int z=0; z<50; z++)  // find empty e_bullet
      if (!e_bullet_active[z])
      {
         e_bullet_active[z] = 1;
         e_bullet_shape[z] = 1000 + bullet_ans;
         e_bullet_fx[z] = Efi[EN][0];
         e_bullet_fy[z] = Efi[EN][1];
         e_bullet_fxinc[z] = xinc;
         e_bullet_fyinc[z] = yinc;
         z=50;
      }
}



------------------------------------------------------
figure out how to do a windows release

run the batch file...

that seemed to work

published a new release 7.1.1-win on github


make my doc pages point at main page






BUG--------------------------------------------------------------------

level 62 jumping from top of ladder warps through solid block to the left???

test on level 329
immediately above ladder have a semi solid block
jump off the ladder while holding up

When player is climbing ladder they are blocked by semi-solid above
If they then jump everything works fine.
But if they hold [UP] and jump they try to grab ladder again and trigger
code that happens only when player is first grabbing ladder


I think its because ladder up moves don't recognize semi-solid because they use the new is_solid_fm type.
There is code about when a player get on a ladder initially that checks to see if the player is embedded in a wall.
This is getting triggered by the semi solid and pushing the player left until they are free.

show ladders that could be grabbed

on ladder, up pressed, jump pressed



trace what happens the instant jump is pressed while on ladder

move player() calls
proc_player_ladder() which calls
proc_player_ladder_move()

where this happens:


   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      al_fixed initial_jump_velocity = al_ftofix(6.6);
      if (players[p].up) players[p].PY += al_ftofix(2.6);
      players[p].yinc = -initial_jump_velocity;
      return;
   }


what the hell is this line?

if (players[p].up) players[p].PY += al_ftofix(2.6);

if up then move the player down??

this is how I fixed it:
   if (players[p].jump)
   {
      players[p].on_ladder = 0;
      players[p].yinc = al_ftofix(-6.6); // initial_jump_velocity;
      players[p].PY += players[p].yinc;  // make the first move here
      return;
   }

fixed the bug...as long as it doesn't cause any unforseen complictaions it is fixed


increase archwagon bullet prox upper limit from 600 to 2000...done...



-----------------------------------------------
Bug
----------------------------------------------------
small letters to show how much health you lost on player, -20 shows as -2
only for mines...how do they work again?

void proc_mine_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(item[i][8]) / 10;
   game_event(50, 0, 0, p, i, 0, item[i][8]);
}

with enemies they have a hold off before they can damage the player again

         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount


should I change mines to be like enemies? with a hold off?

leave it...not really a bug



show all pop-messages at once to assist with aligning in level editor....done





when duplicate bmsgs occur, edit the last one and add x2 x3 etc to it....

not that simple

// make new structure to hold all of the data
I could keep it forever like a log file

only show the last 20 or so as bmsg
and consolidate like types

which ones repeat??

mines
exit when not allowed



right now all the variable that are used are:

char b_msg[40][80];
int bottom_msg=0;


I propose a simple solution of an array of structs



extern struct bmsg bmsgs[100];

struct bmsg
{
   char txt[80];
   int ev
   int frame
   int p1
   int p2
};


there are bitmaps that go with each one too???

ALLEGRO_BITMAP *bmsg_bmp[20] = {NULL};
ALLEGRO_BITMAP *bmsg_bmp2[20] = {NULL};
int bmsg_index = 0;

what is index used for??
so that I don't have to redraw all the text bitmaps
I just use a circular index

this looks way to hard...I just want to cut down on a lot of duplicates

if I stored just ev and player....


I should make a function that build the bmsg bitmap
instead of going back and replacing text with coloured text, do it the first time.

what would the function look like?

it would go somewhere between event and where event calls add_bmgs

why don't I just make event pass everything to add_bmg and do it there?

done...

next... draw uncentered while building colored line then center it after...

make a temp bitmap for that...
400x8

now I need to keep track of how wide the bitmap is so I can center it


keep the text in bmsg for now, if for no other reason than to compare for doubles

do all the real drawing in second part...









player collison with enemy
Ei[e][22] = p+1;

player collison with bullet:
only has e_type

   int e_type = 0;
   switch (e_bullet_shape[b])
   {
      case 488:   e_type = 3;  damage = 5;  break; // arrow
      case 489:   e_type = 3;  damage = 5;  break; // arrow
      case 1055:  e_type = 6;  damage = 7;  break; // cannon ball
      case 1020:  e_type = 8;  damage = 9;  break; // yellow things
      case 1054:  e_type = 7;  damage = 10; break; // green ball
      case 1062:  e_type = 12; damage = 8;  break; // flapper thing
   }

   game_event(43, 0, 0, p, e_type, 0, damage);

so in bmsg I will ne tp convert e number to etype for enemy collisions..



I'm getting a lot of these done, but I want to get rid of the whole text thing..


the only thing I have it for now is to see if I have duplicates

I want to make an array of 100 events

game_event_array[100][8]

0 - frame
1 - ev
2 - x
3 - y
4 - z1
5 - z2
6 - z3
7 - z4

whenever I get an event:

only for certain types that retrigger a lot
- like mines
- like exits

I check to see if there are any others exactly the same in the last 40 frames (1 second)
if there are, I toss it and modifiy the last

or i could only do it for a problematic few that keep retriggering

game_event_retrigger_holdoff[10][1]

when I get an exit event stick the retrigger time in this array

I have removed all traced of the old text bmsg...except for the char arrays


now all that is left is to devise the retrigger block method to prevent duplicates

game_event_retrigger_holdoff[10][1]

   if (ev == 3) // exit
   {
      if (game_event_retrigger_holdoff[1] < frame_num)  game_event_retrigger_holdoff[1] = frame_num + 60;
      else ev = 0;
   }

   if (ev == 50) // mine
   {
      if (game_event_retrigger_holdoff[2] < frame_num)  game_event_retrigger_holdoff[2] = frame_num + 20;
      else ev = 0;
   }

done...

this all looks good... I need to test all the messages

tested all but squished and stuck


make some nice looking icons that work in 8x8...maybe


maybe I could document this fully and try to encapsulate the vaiarble and function so they are not global
- at many place in the code game_event() is called
- then after that it is all handled by a few function


add some more messages, like:

player joins and quits...done

heath bonus pickups





make an array of bitmaps loaded from disk called

bmsg_icon[64]

that has 64 8x8 tiles used for drawing on bmsgs

figure out which ones I need

make a custom function to scale and save them

then edit by hand to make them look nice

once exported and touched up, never overwite them!!


step 1, collect all the shapes I will possible need


leave out player...looks good enough when just normal 20->8 with shape 1

all enemies(8)
free man
all bonus fruit, flower and diamond

exit and exit with lock

mine

rocket
bomb
bomb with det
bomb with no det
det

4 switch
4 key

done...


now get good starting values



wait....this whole thing is fucky...

when I draw scaled 20 to 8 to display it looks perfect

when I draw 20 to8 to a bitmap then to screen, it looks really bad

?????? !!!!! ??????

what if i do the whole bmg line 20 pixels high, then shrink it only when final drawing it???


What will I do about text?? double it to 16 high and leave a 2 pixel buffer above and below...



increased size of:

bmsg_bmp[x] = al_create_bitmap(800, 20); from 400, 8


made it work with bmg lines that are 20 pixels high and look great

what a lot of wasted time with shrinking 20x20 tiles to 8x8 tiles
they look really bad when another bitmap is the destination, but great when the display is...why?

It looks really good now...and its a lot simpler

still to do...
show mine..
show free man
show health bonus
done

now with much nicer (and simpler) bmsg

that was a couple of days spent working on bmsg...



why don't I practice cleaning up the sources a bit by making
game_event its own source file and header
only source files that call functions from it will need to include it
create z_gameevent.cpp and game_

gave up and reverted... there is a huge tangled mess of intertwined dependencies...
I would still like to do this...but its a huge task......

I wish I could start small, like with something like sound



get a spring sound from zapsplat

https://www.zapsplat.com/
make a free account...
mweiss001
mweiss001@gmail.com zaiden

upgraded to gold for 4GBP recurring monthly but i'll just cancel
now I don't have to give credits...





should you grab ropes by default?
only drop if you press down?
it seems really hard to stay on them....

changed ropes to grab automatically, you don't need to press up

anytime you are within reach of a rope you will automatically grab it

this caused issues about not being able to press down to fall off a rope
you would just grab it again immediately

added code to where pressing down made you fall off rope to add 4 to PY so he would actually fall

maybe I should make it only if you are falling that you automatically grab rope
and any other time you need to press up...done
I like how this works!!!

change order of w and h in zfs...done

co-located doors bug
I tried to make a linked chain of doors, one exit landing right on another entrance,
but I could never enter the second door...fixed

old:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {
      players[p].marked_door = i;

      if (item[i][8]) // do nothing if exit only
      {
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door


new:

void proc_door_collision(int p, int i)
{
   if ((players[p].marked_door == -1)  // player has no marked door yet
     && (players[p].carry_item != i+1)) // player is not carrying this door
   {

      if (item[i][8]) // do nothing if exit only
      {
         players[p].marked_door = i;
         int do_entry = 0;
         if (item[i][11] == 0) do_entry = 1; // enter immed
         if (players[p].carry_item-1 != i) // cant trigger entry if carrying this door





fixed a bug in this function...
when displaying percentages near zero it did not look perfect
the white frame was overwriting the start...

old: al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
new: al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
all that for one pixel!

void draw_percent_bar(int cx, int y, int width, int height, int percent)
{
   int x = cx - width/2; // get x from center
   al_draw_filled_rectangle(x+0.5f, y+0.5f, x + width+0.5f, y + height+0.5f, palette_color[10]); //  all red to start
   if (percent > 0)
   {
      int w2 = (int) (width * ((float)percent/100)); // how much green
      al_draw_filled_rectangle(x+0.5f, y+0.5f, x + w2+0.5f, y + height+0.5f, palette_color[11]); //  green
   }
// al_draw_rectangle(x+0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
   al_draw_rectangle(x-0.5f, y+0.5f, x+width+0.5f, y+height+0.5f, palette_color[15], 1); //  white frame
}

























I could make the item 'mine' have a larger rectangular area

I could make other items like that too...like one that kills enemies...

I have wanted to do these rectangular areas for years, I just never thought to make them part of an item...

omg...I was think of making them stationary, but what if I made their position slave to another object, like a lift??!!


start by making a new item..


added one in PDE..

type 20, temp holder bitmap 889

added one to level...

added its name in menu setup:  strcpy (item_name[20],"Minefield");

incresed size of:
int item_num_of_type[20];
int item_first_num[20];
char item_name[20][40];

to

int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];


set all to 200 for testing...

item[][6] = minefield x (int) (2000)
item[][7] = minefield y (int) (2000)
item[][8] = minefield w (int) (2000)
item[][9] = minefield h (int) (2000)


make it show...

void draw_minefield(int i)
{
   float x1 = item[i][6];
   float y1 = item[i][7];
   float x2 = x1 + item[i][8];
   float y2 = y1 + item[i][9];
   rectangle_with_diagonal_lines(x1, y1, x2, y2, 10, 10, 10);
}


check collision...

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if (item[x][0])
      {
         al_fixed ix1 = itemf[x][0] - f16;
         al_fixed ix2 = itemf[x][0] + f16;
         al_fixed iy1 = itemf[x][1] - f16;
         al_fixed iy2 = itemf[x][1] + f16;
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_item_collision(p, x);
      }
      if (item[x][0] == 20) // check for minefield collision
      {
         al_fixed ix1 = al_itofix(item[x][6]);
         al_fixed iy1 = al_itofix(item[x][7]);
         al_fixed ix2 = ix1 + al_itofix(item[x][8]);
         al_fixed iy2 = iy1 + al_itofix(item[x][9]);
         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_minefield_collision(p, x);
      }
   }


void proc_minefield_collision(int p, int i)
{
   players[p].LIFE -= al_itofix(1);
}

it works!!!!


make an editor so you can adjust x, y, w, y

new button in sliders:

if (bn == 84) sprintf(smsg, "Get New Minefield Rectangle");

if (bn == 84)
   if (getbox( "Minefield Range", 2, 4, num) == 1)
   {
      if (--bx2 < bx1) bx2++;
      if (--by2 < by1) by2++;
      item[num][6] = bx1*20;
      item[num][7] = by1*20;
      item[num][8] = (bx2 - bx1)*20;
      item[num][9] = (by2 - by1)*20;
      Redraw = 1;
   }

in object viewer:

case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
break;


it works!!!

now what?

it would be nice to adjust with map...
but I can easily make it work without that....

- can I kill the item? // probably won't do this... no other item supports getting killed

- hide the main icon

- make it cycle on and off?

- make it turn on when touched, turn off when touched?

- link it's position to a lift?


lets pick an int for mode...
item [][10] == mode
mode == 0 // always on

lets pick an int for damage
item [][11] == health dec (/100)

what variables does that leave me?
12 and 13 only


mode 1:
become active when touched
timer value = 13;
timer counter = 12;


mode 2:
become inactive when touched
timer value = 13;
timer counter = 12;


implement 11 health dec...

if (bn == 81) item[num][11] = (int)f;              // minefield damage

if (bn == 81) sprintf(smsg, "Damage:%d", item[num][11]);

case 81: sul=1000;  sll=0;   sinc=10; sdx=item[num][11];           break;  // minefield damage


case 20: // minefield
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 84,  num, type, obt, 0, 10, 10,  0, 1,0,0,0); a++; // set new range
   mdw_slider(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 81, num, type, obt, 0, 12, 15, 15, 1,0,0,0); a++;  // damage
break;

void proc_minefield_collision(int p, int i)
{
   al_fixed d = al_itofix(item[i][11]) / 100;
   int id = al_fixtoi(d);

   players[p].LIFE -= d;
   game_event(50, 0, 0, p, i, 0, id);
}

done and works great!!

getting new rectangle make it one block smaller at lr corner..done

heath event of zero shows green...made it blue, but still need to address this

inc should be 1 not 10...done

implement mode 1 and 2.....


I would love to have 2 rectangles, one for the trigger and one for the damage...
however I do not have enough integers

unless I do something tricky

is item[][2] really not used by anything??

if I ignore these I could get 2 more here:
item[][14] = time to live
item[][15] = tag with cloner item id

basically if I want 2 boxes i will need 8 variables....

what if I used an enemy to make this whole thing work?
they have a lot more variables to work with...
plus, I could kill them if I wanted!!



snap decision...lets do that....

I can still keep the item version...maybe use it for simpler ones...



[10]--field-----------------------------------------------------------------------------

Ei[][0] = 10;
Ei[][1] = 476; // bitmap
Ei[][2] = 0;   // draw mode (v and h flips)

//Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)
Ei[][5]  mode

Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2

Ei[][15] = 200; field box x
Ei[][16] = 200;  field box y
Ei[][17] = 200;  field box w
Ei[][18] = 200;  field box h

Efi[][4] = 2.3;  // life dec
Efi[][12] = 1.0; // scale
Efi[][14] = 0.0; // rot

made an enemy like this in PDE...done and added to level...

add enemy to lists...done
strcpy (enemy_name[10], "Field");


add code to draw...very similar to cloner...done

if (Ei[e][0] == 10) // field
{
   // trigger box
   float tx1 = (float)Ei[e][11]*20;
   float ty1 = (float)Ei[e][12]*20;
   float tx2 = (float)Ei[e][13]*20+20;
   float ty2 = (float)Ei[e][14]*20+20;
   int tc1 = 14 + 128; // trigger box color

   // field
   float sx1 = (float)Ei[e][15];
   float sy1 = (float)Ei[e][16];
   float sx2 = sx1 + (float)Ei[e][17];
   float sy2 = sy1 + (float)Ei[e][18];
   int sc1 = 11 + 128; // field box color

   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box
   rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
}

add code to take damage....done...
   for (int e=0; e<100; e++)
   {
      if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
      {
         al_fixed b = al_itofix(Ei[e][29]); // collision box size
         al_fixed ex1 = Efi[e][0] - b;
         al_fixed ex2 = Efi[e][0] + b;
         al_fixed ey1 = Efi[e][1] - b;
         al_fixed ey2 = Efi[e][1] + b;
         if ((players[p].PX > ex1) && (players[p].PX < ex2)
          && (players[p].PY > ey1) && (players[p].PY < ey2)) Ei[e][22] = p+1;
      }


      if (Ei[e][0] == 10) // check for field collision
      {
         al_fixed ix1 = al_itofix(Ei[e][15]);
         al_fixed iy1 = al_itofix(Ei[e][16]);

         al_fixed ix2 = ix1 + al_itofix(Ei[e][17]);
         al_fixed iy2 = iy1 + al_itofix(Ei[e][18]);

         if ((players[p].PX > ix1) && (players[p].PX < ix2)
          && (players[p].PY > iy1) && (players[p].PY < iy2)
          && (!players[p].paused) ) proc_field_collision(p, e);
      }
   }

void proc_field_collision(int p, int x)
{
   players[p].LIFE -= Efi[x][4];
   game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
}


add code to adjust boxes...hopefully its close to cloner...

if (bn == 85) sprintf(smsg, "Get New Field Rectangle");
if (bn == 86) sprintf(smsg, "Get New Field Trigger Box");

if (bn == 85)
   if (getbox("Get New Field ", 3, 10, num))
   {
      Ei[num][15] = bx1*20;
      Ei[num][16] = by1*20;
      Ei[num][17] = (bx2-bx1)*20;
      Ei[num][18] = (by2-by1)*20;
      Redraw = 1;
   }

if (bn == 86)
   if (getbox("Get New Field Trigger Box", 3, 10, num))
   {
      Ei[num][11] = bx1*20;
      Ei[num][12] = by1*20;
      Ei[num][13] = (bx2-bx1)*20;
      Ei[num][14] = (by2-by1)*20;
      Redraw = 1;
   }


perfect...now I can edit both boxes...now for map move...





if ((obt == 3) && (type == 10)) // field boxes
{
   // field trigger box coordinates
   int x1 = Ei[num][11]/20;
   int y1 = Ei[num][12]/20;
   int x2 = x1 + Ei[num][13]/20 -1;
   int y2 = y1 + Ei[num][14]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_ftb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, palette_color[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_ftb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, palette_color[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }

   // field damage box coordinates
   x1 = Ei[num][15]/20;
   y1 = Ei[num][16]/20;
   x2 = x1 + Ei[num][17]/20 -1;
   y2 = y1 + Ei[num][18]/20 -1;
   if ((!mouse_on_extra) && (mx == x1) && (my == y1)) // upper left corner
   {
      mouse_on_fdb_ul = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x1*db, y1*db, x1*db+db, y1*db+db, palette_color[14], 1);                 // mark ul corner
      mouse_move = 1;
   }
   if ((!mouse_on_extra) && (mx == x2+1) && (my == y2+1))  // lower right corner
   {
      mouse_on_fdb_lr = 1;
      mouse_on_extra = 1;
      for (int a=0; a<4; a++)
         al_draw_rectangle(x1*db+a, y1*db+a, x2*db+db-a, y2*db+db-a, palette_color[14+a*64], 1); // mark entire trigger box
      al_draw_rectangle(x2*db, y2*db, x2*db+db, y2*db+db, palette_color[14], 1);                 // mark lr corner
      mouse_adj = 1;
   }
}


if (mouse_on_tb_ul) // move trigger box from ul
{
   // get the width and height
   int w = Ei[num][13] - Ei[num][11];
   int h = Ei[num][14] - Ei[num][12];
   // set new position
   Ei[num][11] = mx;
   Ei[num][12] = my;
   Ei[num][13] = mx + w;
   Ei[num][14] = my + h;
}
if (mouse_on_ftb_ul) // move field trigger box from ul
{
   Ei[num][11] = mx*20;
   Ei[num][12] = my*20;
}
if (mouse_on_fdb_ul) // move field damage box from ul
{
   Ei[num][15] = mx*20;
   Ei[num][16] = my*20;
}
if (mouse_on_tb_lr)  // resize trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < Ei[num][11]) mx = Ei[num][11];
   if (my < Ei[num][12]) my = Ei[num][12];
   // set new postion
   Ei[num][13] = mx;
   Ei[num][14] = my;
}

if (mouse_on_ftb_lr) // resize field trigger box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][11]/20)) mx = (Ei[num][11]/20)+1;
   if (my < (Ei[num][12]/20)) my = (Ei[num][12]/20)+1;
   Ei[num][13] = mx*20 - Ei[num][11];
   Ei[num][14] = my*20 - Ei[num][12];
}

if (mouse_on_fdb_lr) // resize field damage box from lr
{
   // prevent lr corner from being less than ul corner
   if (mx < (Ei[num][15]/20)) mx = (Ei[num][15]/20)+1;
   if (my < (Ei[num][16]/20)) my = (Ei[num][16]/20)+1;
   Ei[num][17] = mx*20 - Ei[num][15];
   Ei[num][18] = my*20 - Ei[num][16];
}


map works......

now detect trigger collision also....done

if (Ei[e][0] == 10) // check for field collision
{
   // trigger field
   al_fixed ix1 = al_itofix(Ei[e][11]);
   al_fixed iy1 = al_itofix(Ei[e][12]);
   al_fixed ix2 = ix1 + al_itofix(Ei[e][13]);
   al_fixed iy2 = iy1 + al_itofix(Ei[e][14]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 0);

   // damage field
   ix1 = al_itofix(Ei[e][15]);
   iy1 = al_itofix(Ei[e][16]);
   ix2 = ix1 + al_itofix(Ei[e][17]);
   iy2 = iy1 + al_itofix(Ei[e][18]);

   if ((players[p].PX > ix1) && (players[p].PX < ix2)
    && (players[p].PY > iy1) && (players[p].PY < iy2)
    && (!players[p].paused) ) proc_field_collision(p, e, 1);
}


void proc_field_collision(int p, int x, int b)
{
   if (b == 0) // trigger field
   {

   }
   if (b == 1) // damage field
   {
      players[p].LIFE -= Efi[x][4];
      game_event(50, 0, 0, p, x, 0, al_fixtoi(Efi[x][4]));
   }
}


now add slider to adjust the amount of damage....done...reused the same one as all other enemies
...does it also work for the main enemy?...no...collision box..set to 10 and still no..

I don't have any specific code to handle this type of enemy....


added this line to move_enemies()
case 10:  enemy_field(e);  break;


void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
}


now I can take damage from enemy and kill it, but it doesn't die nicely

added to enemy_killed()


case 10: // field
   na = Ei[e][3] = 105;  // new ans
   dl = Ei[e][30] = 40; // death_loop_wait; set delay
   Ei[e][24] = 934+(ht-1)*32; // shape
   Efi[e][11] = al_ftofix(.98); // scale multiplier
   Efi[e][13] = al_ftofix(306/dl); // rot inc
   zz[0][na] = zz[5][na]; // set shape
   zz[1][na] = 0;         // point to zero
   zz[2][na] = frame_num; // set counter
   zz[3][na] = dl / zz[4][na]; // set ans timer
break;

change this at end of enemy killed to include type 10
// almost all do this but not enough to do by default
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12 )
{
   if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
   if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
   Ei[e][0] = 99; // set type to death loop
}


OK now that works, but later, I'll need to make it look nice
for now if I don't want to be able to shoot it, set collision box to 0
...can still kill with bomb...





now lets implement some modes....

0 = static, damage always

1 = no damage until triggered, then timer runs

2 = damage until triggered, then none while timer runs

what are my variables for mode, timer and timer count?

Ei[][5] = mode;
Ei[][6] = timer_value;
Ei[][7] = timer_count;

Ei[][8] = damage; // currently in damage mode




set up buttons for these...

if (bn == 87) // field mode
{
   if (Ei[num][5] == 0) sprintf(smsg, "Damage Always");
   if (Ei[num][5] == 1) sprintf(smsg, "No Damage Until Triggered");
   if (Ei[num][5] == 2) sprintf(smsg, "Damage Until Triggered");
}

if (bn == 87)
{
   Ei[num][5]++;
   if (Ei[num][5] > 2) Ei[num][5] = 0;
}

if (bn == 82) Ei[num][6] = (int)f;        // field timer
if (bn == 82) sprintf(smsg, "Field Timer:%d", Ei[num][6]);
case 82: sul=1000;  sll=10;  sinc=1; sdx=Ei[num][6];           break;  // field timer

now lets actually write some code to process this


void draw_enemy_field(int e)
{
   float tx1 = (float)Ei[e][11]; // trigger
   float ty1 = (float)Ei[e][12];
   float tx2 = tx1 + (float)Ei[e][13];
   float ty2 = ty1 + (float)Ei[e][14];
   int tc1 = 14 + 128; // trigger box color
   rectangle_with_diagonal_lines(tx1, ty1, tx2, ty2, 8, tc1, tc1+64); // trigger box

   if (Ei[e][8]) // currently in damage mode
   {
      float sx1 = (float)Ei[e][15]; // field
      float sy1 = (float)Ei[e][16];
      float sx2 = sx1 + (float)Ei[e][17];
      float sy2 = sy1 + (float)Ei[e][18];
      int sc1 = 11 + 128; // field box color
      rectangle_with_diagonal_lines(sx1, sy1, sx2, sy2, 8, sc1, sc1+64); // field
   }
}

void proc_field_collision(int p, int e, int b)
{
   if (b == 0) // trigger field
   {
      Ei[e][7] = Ei[e][6]; // reset timer
   }
   if (b == 1) // damage field
   {
      if (Ei[e][8]) // currently in damage mode
      {
         players[p].LIFE -= Efi[e][4];
         game_event(50, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
      }
   }
}

void enemy_field(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return;
   }
   enemy_player_hit_proc(e);
   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer
   int damage = 0;
   if (Ei[e][5] == 0) damage = 1;                       // damage always
   if ((Ei[e][5] == 1) && (Ei[e][7] > 0)) damage = 1;   // damage when timer is running (no damage until triggered)
   if ((Ei[e][5] == 2) && (Ei[e][7] == 0)) damage = 1;  // damage unless timer running  (damage when triggered)
   Ei[e][8] = damage;  // field is currently in damage mode
}


this is all working good...

now some minor bug fixes...

cant see the field in obj viewer

also what color should they be??
trigger yellow
field red

OK that looks good...now make field always show in level editor
what is that global? level_editor_running


looking good...now figure out how to tell when timer is running...done
show small number counting down second above the enemy..

test if I can use this at the bottom of a pit that kills you instantly...
not unless I set the damage higher...set to 100

move rect to be red...done
hide trigger if not used...done


I want to try slaving it to a lift...just the damage field..always on for now
mode = 3; works as proof on concept...

can we make the field kill enemies

right now I think all my collisions are with player...
I only really care if things collide with players....??

where will I do the collision detection?

I propose to make a new collision detection based on what collides with fields

Then I can do players, enemies, items...


made void proc_field_collisions(void);
and added it to loop....


seems to be working good...

items...done...


wow!!!

now I need to be able to set this in the field somehow....









lets just list a bunch of possible types here:


always on, invisible invulnerable enemy
always on, enemy can be killed


type 3 - always on, following lift

type 4 - shooting enemy toggles field

have a bunch of toggles for enemy shape
- hidden, invulnerable
- shown, killable
- shown, shooting toggles


lets implement hit type
Ei[e][4]

0 normal (can kill)
1 invulnerable
2 toggle also need mode == 4

its better to do this with modes...

pick which modes are invincible...choose a variable also used for death ans...will never be used for this



mode 4 toggle
don't show trigger or allow timer to run
maybe I could make my own bullet handler so it doesn't eat the bullet???

5 trigger be time based only...on time off time...

6 timed like 1 but triggered with shot
7 timed like 2 but triggered with shot

8 timed like 2 but triggered with enemy collision
8 timed like 2 but triggered with enemy collision

immdiate when in zone



I've got to use some more variables
dig into the fixed...

on  count
off count

runs with timer only



lets start with what triggers it:
---------------------------------
player in trigger zone
enemy in trigger zone
player shoots enemy
player touches enemy
strictly timer based on and off

then what happens next:
-----------------------
zone on with timer
zone off with timer

toggle

immediate on or off


then what does it affect:
-------------------------
players
enemies
items

optionally
------------------
move with lift


how many modes do I have that work?

-------------------
5-0 - normal
4-0 - normal
always on
not invulnerable
--------------------
5-1 - off until triggered, then timer runs
4-0 (0 normal, 1 invul, 3 add time)

not invulnerable
--------------------
2 - on until triggered, then timer runs
not invulnerable
--------------------
3 - alway on, follows lift
not invulnerable
--------------------


lets get some nicer drawing for the stuff


spike pit...
flames...
acid...


20220327 new day
did a lot yesterday
kind of ran out of steam after 12 hours
today I am going to bring it on home...complete a lot of this.

I want to start by implementing what objects are affected by the field

use a single int and also use it for invul


bit 1 player
bit 2 enemy
bit 3 item
bit 4 invuln


typedef union
{
 uint8_t     all_flags;      /* Allows us to refer to the flags 'en masse' */
 struct
 {
  uint8_t foo : 1,        /* Explanation of foo */
          bar : 1,        /* Explanation of bar */
          spare5 : 1,     /* Unused */
          spare4 : 1,     /* Unused */
          spare3 : 1,     /* Unused */
          spare2 : 1,     /* Unused */
          spare1 : 1,     /* Unused */
          spare0 : 1;     /* Unused */
 };
} EX_FLAGS;

static EX_FLAGS    Flags;  /* Allocation for the Flags */

Flags.all_flags = 0U; /* Clear all flags */

...

Flags.bar = 1U; /* Set the bar flag */

-----------------------------------------------------------

if(x & 0x01){} // tests if bit 0 is set using bitwise AND
x ^= 0x02;     // toggles bit 1 (0 based) using bitwise XOR
x |= 0x10;     // sets bit 4 (0 based) using bitwise OR

-----------------------------------------------------------


/* Each of these preprocessor directives defines a single bit,
   corresponding to one button on the controller.
   Button order matches that of the Nintendo Entertainment System. */
#define KEY_RIGHT  0b00000001
#define KEY_LEFT   0b00000010
#define KEY_DOWN   0b00000100
#define KEY_UP     0b00001000
#define KEY_START  0b00010000
#define KEY_SELECT 0b00100000
#define KEY_B      0b01000000
#define KEY_A      0b10000000

int gameControllerStatus = 0;

/* Sets the gameControllerStatus using OR */
void KeyPressed( int key ) { gameControllerStatus |= key; }

/* Clears the gameControllerStatus  using AND and ~ (binary NOT)*/
void KeyReleased( int key ) { gameControllerStatus &= ~key; }

/* Tests whether a bit is set using AND */
int IsPressed( int key ) { return gameControllerStatus & key; }

---------------------------------------------------------------------------

lets call Ei[e][3] flags

make 4 button to set player, enemy, items, invul

if (bn == 89) // field affects player flag
{
   if (Ei[num][3] & 0b00000001) sprintf(smsg, "Affects Players");
   else sprintf(smsg, "Does Not Affect Players");
}
if (bn == 90) // field affects enemy flag
{
   if (Ei[num][3] & 0b00000010) sprintf(smsg, "Affects Enemies");
   else sprintf(smsg, "Does Not Affect Enemies");
}
if (bn == 91) // field affects item flag
{
   if (Ei[num][3] & 0b00000100) sprintf(smsg, "Affects Items");
   else sprintf(smsg, "Does Not Affect Items");
}
if (bn == 92) // field enemy invulnerable flag
{
   if (Ei[num][3] & 0b00001000) sprintf(smsg, "Invulnerable");
   else sprintf(smsg, "Not Invulnerable");
}

if (bn == 89) Ei[num][3] ^= 0b00000001; // bitwise OR
if (bn == 90) Ei[num][3] ^= 0b00000010; // bitwise OR
if (bn == 91) Ei[num][3] ^= 0b00000100; // bitwise OR
if (bn == 92) Ei[num][3] ^= 0b00001000; // bitwise OR

int cdp = ((Ei[e][8]) && (Ei[e][3] & 0b00000001)); // damage active and player flag
int cde = ((Ei[e][8]) && (Ei[e][3] & 0b00000010)); // damage active and enemy flag
int cdi = ((Ei[e][8]) && (Ei[e][3] & 0b00000100)); // damage active and item flag


lets add to this trigger:

trigger field player
trigger field enemy
trigger shoot enemy
trigger timer

remove Ei[][4]...done

if toggle is set, inv should be too, unless you want one toggle then enemy dies...


if toggle is set and in mode 1 or 2 they will override....

how about mode 0 is default and if you dont want any changes just implement with flags

mode 3 is now toggle
when setting that mode, automatically set the toggle flag and unset the inv flag

make a button to set initially on or off..



can i use another flag bit for damage on?  this will be the ninth bit...try it...I think I can...it seems to work...

now I got rid of Ei[][8] for damage currently on and replaced it with another flag...

should I set up some nice defines for these??

#define PM_ENEMY_FIELD_AFFECTS_PLAYER 0b000000001
#define PM_ENEMY_FIELD_AFFECTS_ENEMY  0b000000010
#define PM_ENEMY_FIELD_AFFECTS_ITEM   0b000000100
#define PM_ENEMY_FIELD_INVULNERABLE   0b000001000
#define PM_ENEMY_FIELD_TRIGGER_PLAYER 0b000010000
#define PM_ENEMY_FIELD_TRIGGER_ENEMY  0b000100000
#define PM_ENEMY_FIELD_BULLET_TOGGLE  0b001000000
#define PM_ENEMY_FIELD_TRIGGER_TIMER  0b010000000
#define PM_ENEMY_FIELD_CURRENT_DAMAGE 0b100000000


done....



when setting mode 3 (toggle), automatically set the toggle flag and unset the inv flag
in sliders...done

player should never take damage from cloner, but I can't set the collison box to zero because it's used by bullets

in void proc_player_collisions(int p)

changed this line
for (int e=0; e<100; e++)
{
// if ((Ei[e][0]) && (Ei[e][0] != 99)) // if active and not deathcount
   if ((Ei[e][0]) && (Ei[e][0] != 99) && (Ei[e][0] != 10) // if active and not deathcount or field
done...
make collison box a little more forgiving maybe 12 or 14 instead of 10... change PDE to 12...can still edit manually...done


bullet is back to getting eaten....fix and maybe make it a flag....

in proc_enemy_collision_with_pbullet(int e)

if ((Ei[e][0] == 10) && (Ei[e][5] == 4)) // don't kill bullet used to toggle field
{
}
else pbullet[c][0] = 0;       // bullet dies

if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE)) // don't kill bullet used to toggle field
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

done and works...

test the collision areas of fields, they are a little off...changed the offset in collison detection...done

old:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]);
 al_fixed tfy1 = al_itofix(Ei[e][12]);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]);
 al_fixed dfy1 = al_itofix(Ei[e][16]);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);


new:

 // trigger field
 al_fixed tfx1 = al_itofix(Ei[e][11]-10);
 al_fixed tfy1 = al_itofix(Ei[e][12]-10);
 al_fixed tfx2 = tfx1 + al_itofix(Ei[e][13]);
 al_fixed tfy2 = tfy1 + al_itofix(Ei[e][14]);

 // damage field
 al_fixed dfx1 = al_itofix(Ei[e][15]-10);
 al_fixed dfy1 = al_itofix(Ei[e][16]-10);
 al_fixed dfx2 = dfx1 + al_itofix(Ei[e][17]);
 al_fixed dfy2 = dfy1 + al_itofix(Ei[e][18]);



when setting mode = 0
clear bullet toggle flag...done

don't reset inv flag

now what?

make new shapes including hidden...

make a shape that has a hole for the timer count!!


made default from PDE have damage on and mode 0 and draw mode 1

I won't enforce it, but it makes sense to have hidden and inv both set

if hidden, I should still show it in level editor...

if on off switches make then change...done

make button for initial setting on/off in toggle mode...done

make a slider for choosing lift number...and a place to store it...
Ei[][21]

it follows lift just great...I can even center it nicely
maybe make a flag for centering later


now it is always on...I want to change this...

turned it off....

bullet toggle works good...

in level editor, show the field centered on the lift....
how about actually set it when lift is changed with slider....

I should make a function to do this...done


now can we do the timers while in lift mode?

no.. timers only work when mode == 1 or 2

maybe I could make lifts separate from mode...
I would need to use an int for the lift number

I could also potentially move the trigger box with another lift...whooa!!

can timer and toggle co-exist right now??

no, because the timer forces it on or off


I think if I remove lift from mode then I can have modes realted to trigger only...like


then I can have a separate int for the lift stuff
I could jam 4 things in there

1 bit field follow lift
7 bits lift number

1 bit trigger follow lift
7 bits lift number

or I can add a few more flags to 3 and use 2 ints for lifts


I will also need two more variables for the second timer

Ei[][5]  mode
Ei[][6]  timer1 value
Ei[][7]  timer1 count
Ei[][8]  timer2 value
Ei[][9]  timer2 count

let's re-arrange the modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

no lift...move in to flag and lift numbers in:
Ei[][19]
Ei[][20]

what am I using 21 for?? lift number! perfect!

OK lets do this...
start with lift flags

#define PM_ENEMY_FIELD_LIFT_SETS_FLD  0b0000010000000000
#define PM_ENEMY_FIELD_LIFT_SETS_TRG  0b0000100000000000

Ei[][20] // trig lift
Ei[][21] // field lift

sliders...done

patched that all in nicely...

now rearrange modes

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger

screw it, im leaving toggle out, it does nothing...

0 on
1 on till trigger
2 on when trigger
3 double timer trigger

NO! I need a mode that is not a timer, so timers wont fuck over toggle

0 on
1 toggle (does nothing)
2 on till trigger
3 on when trigger
4 double timer trigger


good so far....now implement double timer...

make slider to adjust

Ei[][8]  timer2 value



why do I have 2 timers?

would it not be simpler to run one from value to zero then reset...and have a midpoint where the damage flips??
lets just call timer 2 the flip point

that works great.

hide timer numbers in modes 0 and 1

in mode 3 do a modified count down for each stage...done





I would say that most of the basic funtionality has been implemented...
now for some polish and testing...



naming

enemy is called Field
is has a
Damage Field
Trigger Field
make this naming consistant

at the top should be the stuff related to the enemy
inv and shape

then the stuff related to the Damage Field

get new...etc

the viewer page looks good...

it all looks good...
not implemented:
anything except player triggering
unused flag trigger timer


I want to make a test level to show this off....

bugs

when creating, a creator might be nice..done
or take me to the edit page right away
of just make the lr trigger not exactly the ul damage!!..this is done...

remove old simpe PDE for field...
remove old item field thing...done

when invisible, its kinda hard to find in level editor...fixed

death sequence needs something more than just copying cloner

make some better shapes for damage fields...

how will I show different draw types
use an int? patched it in..

Its use as an item killer is nice too... I can make a screen that items can't go through

to kill items nicely, have the killing screen ignore things in the death phase...done
redraw attached to lift when stuff moves in level editor....done
make boxes snap to 20 grid..not a problem unless attached to lift...done


I want to make field able to kill enemy and player bullets also....done!!!
when checking collisions, I realized I can also have bullets affect trigger!!!

make damage field able to be invisible...done

also add display options for trigger field use Ei[][10]... done for now only default and none


20220328 6:20 AM
wow this is coming along so great......time for a push


lets try some other things that can trigger...

enemy
item
enemy bullet
player bullet

right now trigger only makes sense in mode 2 and 3
and then timers run...

can it be instant by setting timer to 0?
0 and 1 never work, 2 works...why??

moved dec counter to last thing in enemy proc...now 1 works

patch in trigger sources...
did a bunch of re-arranging flags and slider button toggles

now make the new trigger source functionality work....done

why does a new filed have damage of 0?...done

fix display of damage to only 2 decimals...done

why is bullet getting eaten in mode 1?


in void proc_enemy_collision_with_pbullet(int e)
old:
if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
new
if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field



Change the wording of MODE.
ON until triggereg
OFF until triggered

Make Mode capitalized


I want to make a toggle mode based on field...
but how will i make it work?...I'll need a hold off
when something first enters

detect if nothing is in trigger box
then if next frame something is in then trigger

then wait until it is empty again before allowing another trigger
I'll need something to keep track of how it was the last frame

I could use a flag...

each frame:
if not set from last frame...
and set this frame...toggle trigger fires

use 2 flags...

start of frame clear current
when checking collisions if any trigger, set current trigger
after checking collisions if not last the yes this then fire toggle
set last to current for next time...

I have been doing the triggers wrongs
collisions with damage need to afect specific things
but collisions with triggers?
who cares where they came from?
all that matters is that a trigger happened

new flags

#define PM_ENEMY_FIELD_TRIGGER_CURR  0b1000000000000000
#define PM_ENEMY_FIELD_TRIGGER_LAST  0b1000000000000000

at the start of the enemy proc loop CURR is cleared
if any trigger collisions, CURR is set

at the end of the collision checks...

if CURR is set: proc things that happen when something is in trigger box
if CURR is set and PREV is clear: process things that only happen when initiallt triggered

set PREV to CURR


what if I remove all toggle by shooting actual enemy...might make things easier....
once I get the trigger toggle stuff working I'll look at it...

I'm ready to do it

there is custom code in

void proc_enemy_collision_with_pbullet(int e)

for when a bullet hits the field enemy...
i am going to try to take it out completely
I still want the enemy to be invincible...but I can just set collision box to zero....
wait....

just leave code there so pbullets completely ignore field enemy
then I should just make it always invincible...
use the enemy tile stuff just for counter and progress bar....
I can get collision box for something else too maybe....

old:

   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2)))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has

//            if ((Ei[e][0] == 10) && (Ei[e][3] & PM_ENEMY_FIELD_BULLET_TOGGLE) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field

      if ((Ei[e][0] == 10) && (!(Ei[e][3] & PM_ENEMY_FIELD_BULLET_EATEN))) // don't kill bullet used to toggle field
      {
      }
      else pbullet[c][0] = 0;       // bullet dies

   }

new:
   if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2) && (Ei[e][0] != 10))
   {
      int p = pbullet[c][1];   // player number that shot bullet
      Ei[e][31] = 1;           // flag that this enemy got shot with bullet
      Ei[e][26] = p;           // number of player's bullet that hit enemy
      players[p].num_hits++;   // add to number of hits the player has
      pbullet[c][0] = 0;       // bullet dies
   }


I can go back one higher to the function that call this:

old:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if (Ei[e][0] < 50) proc_enemy_collision_with_pbullet(e);

         // check for time to live
         int ttl = Ei[e][27];

new:
void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies
         if ((Ei[e][0] < 50) && (Ei[e][0] != 10)) proc_enemy_collision_with_pbullet(e);



now it does not even detect bullet, but I kept the invincible code because of bombs
if I removed that, nothing could ever kill it

this whole thing that every enemy has....

   if (Ei[e][31]) // hit
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_INVULNERABLE)) // invulnerable flag not set
      {
         enemy_killed(e);
         return; // don't do anything else past here
      }
   }
   enemy_player_hit_proc(e);

void enemy_player_hit_proc(int e)
{
   if (--Ei[e][23]<0) // hit player retrigger
   {
      if (Ei[e][22]) // player hit!
      {
         int p = Ei[e][22]-1;
         players[p].LIFE -= Efi[e][4];

         game_event(44, 0, 0, p, e, 0, al_fixtoi(Efi[e][4]));
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount
      }
   }
  else Ei[e][22] = 0;
}

I'm going to remove all this...

then I will get back 22 and 23

edit this to ignore fields

void bomb_enemies(int i, int t, int dr, al_fixed x, al_fixed y)
{
   for (int e=0; e<100 ; e++) // enemies in damage window?
      if ((Ei[e][0]) && (Ei[e][0] != 10))
      {
//         al_fixed dist = al_fixhypot( (Efi[e][0] - itemf[i][0]), (Efi[e][1] - itemf[i][1]) );
         al_fixed dist = al_fixhypot( (Efi[e][0] - x), (Efi[e][1] - y));
         if (dist < al_itofix(dr))
         {
            if (t == 1) bomb_crosshairs(10 + al_fixtof(Efi[e][0]), 10 + al_fixtof(Efi[e][1]));
            if (t == 2)
            {
               Ei[e][31] = 2; // set bomb hit
               Ei[e][26] = item[i][13];  // player that did bomb
            }
         }
      }
}


now I have reclaimed a lot more ints....

bottom line:
field is now invincible, nothing, not bombs or bullets can kill it
it should not interact with player at all...

that makes things a lot simpler and I have freed up all these variables

Ei[][22] =                 player hit
Ei[][23] =                 player hit retrigger
Ei[][24] =                 health bonus shape
Ei[][25] =                 health bonus amount
Ei[][26] =                 used to tell what player killed enemy
Ei[][27] = time to live
Ei[][28] =                 cloner create id
Ei[][29] =                 collision box size
Ei[][30] =                 death loop count
Ei[][31] =                 flag that this enemy got shot with bullet


now I need to make the toggle mode in obj viewer show all the trigger stuff


For timed on and off, make custom button that say time on and time off.

also make initial time [7] adjustable for synchronization...

which is which???
total time...6
on time 8
initial time 7



I think I am abandoning drawing with tile stuff, maybe just a place holder

I want to implement a draw mode for the main shape

like show the number and progress bar in different ways

my main function is very small now



void enemy_field(int e)
{
   int mode = Ei[e][5];
   int trig_toggle = 0;

   Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_CURR;  // clear current trigger flag
   detect_field_collisions();
   if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) // is current trigger flag set?
   {
      if (!(Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_PREV)) trig_toggle = 1; // if triggered this frame and not triggered last frame, set trigger toggle
      Ei[e][3] |=  PM_ENEMY_FIELD_TRIGGER_PREV; // set previous trigger for next frame
   }
   else Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_PREV; // clear previous trigger for next frame

   if (mode == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE; // in mode 0, always set damage flag

   if ((mode == 1) && (trig_toggle)) Ei[e][3] ^= PM_ENEMY_FIELD_CURRENT_DAMAGE; // toggle current damage flag

   if (mode == 2) // damage unless timer running  (no damage when triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] == 0) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 3) // damage when timer is running (no damage until triggered)
   {
      if (Ei[e][3] & PM_ENEMY_FIELD_TRIGGER_CURR) Ei[e][7] = Ei[e][6];

      if (Ei[e][7] > 0)  Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;                // set damage off
   }

   if (mode == 4) // timed on and off
   {
      // timer will run outside this function always, but in this mode, when it gets to zero, we will reset it
      if (Ei[e][7] == 0) Ei[e][7] = Ei[e][6];
      if (Ei[e][7] < Ei[e][8]) Ei[e][3] |= PM_ENEMY_FIELD_CURRENT_DAMAGE;   // set damage on
      else                     Ei[e][3] &= ~PM_ENEMY_FIELD_CURRENT_DAMAGE;  // set damage off
   }

   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_FLD) set_field_location_from_lift(e, 0, 0);
   if (Ei[e][3] & PM_ENEMY_FIELD_LIFT_SETS_TRG) set_field_location_from_lift(e, 1, 0);

   if (--Ei[e][7] < 0) Ei[e][7] = 0; // always run timer

}



what is still left to do?

get some draw modes for the main enemy

probably never show the shape when game is running

what do I want to do with the main bitmap Ei[][1]?

leave it blank and use another var for draw mode??
or customize the drawing routines so that field always draws itself...yes do that...

void draw_enemies(void)
{
   al_set_target_bitmap(level_buffer);
   for (int e=0; e<100; e++)
      if (Ei[e][0])  // if enemy active
      {
         if (Ei[e][0] == 10) draw_enemy_field(e); // field - do not draw anything here for field, let draw_enemy_field() do it all
         else
         {
             int EXint = al_fixtoi(Efi[e][0]);
             int EYint = al_fixtoi(Efi[e][1]);
             int flags = 0;
             if (Ei[e][2] == 0) flags = ALLEGRO_FLIP_HORIZONTAL;
             if (Ei[e][2] == 1) flags = 0;
             if (Ei[e][2] == 2) flags = ALLEGRO_FLIP_VERTICAL;
             if (Ei[e][2] == 3) flags = ALLEGRO_FLIP_VERTICAL & ALLEGRO_FLIP_HORIZONTAL;
             int tn = Ei[e][1];

             float rot = al_fixtof(al_fixmul(Efi[e][14], al_fixtorad_r));
             float sc = al_fixtof(Efi[e][12]);
             al_draw_scaled_rotated_bitmap(tile[tn], 10, 10, EXint+10, EYint+10, sc, sc, rot, flags);

             // if enemy is expiring show how many seconds it has left
             if (Ei[e][27]) al_draw_textf(f3, palette_color[15], EXint+10, EYint-10, ALLEGRO_ALIGN_CENTER, "%d", 1 + (Ei[e][27] - 10) / 40);
         }



do this is my draw code..

if (level_editor_running) al_draw_bitmap(tile[476], ex, ey, 0);


OK all that is done...

now I have freed up

Ei[][1]
Ei[][2]
Ei[][27]

I have so many free variables now at the expense of..
invulnerable
can't hit player
can't get hit players, bullets or bombs
no regular display, all custom
no time to live

use Ei[][2] for enemy draw mode
how I will draw stuff

0 = draw nothing
1 = small text counter
2 = large text counter
3 = small progress bar
4 = large progress bar
done...

in creator
make field initially on
remove collision box
done....


should I make them show all the time, or only when timer is running?
numbers...only when running
percent bars..always

make it so that when I copy and paste, the boxes are offset also, like cloner boxes....
done with regular copy and zfs copy.....

then test all type 3....all looks good!!!!

now apply all that to the timed mode...done...

wow that was easy.....



What do I have left?

I think all the functionality is there, maybe just some nice drawing code stuff for fields...

Oh yeah and also how the field attach to lifts

right now they just center

in the x axis:
center , right or left

in the y axis
center, right of left

6 flags....9 combinations

no...do it this way
XC
XF
XL

if c=1 ignore the rest
if c=0 four possibilities
fx1 = lx1
fx1 = lx2
fx2 = lx1
fx2 = lx2

XC XF XL
0  0  0 Field X1 = Lift X1
0  0  1 Field X1 = Lift X2
0  1  0 Field X2 = Lift X1
0  1  1 Field X2 = Lift X2
1  x  x Centered

so now there are 5 setting for x and 5 for y for a total of 25 combinations
I like that a lot better than 9

I have all the stuff done for allignment of fields to lifts

removed the flags for invuln, toggle and eat bullet

link the creator back in for the viewer button...done

after creating field, open the viewer...

unless create is called from the viewer already....

how can I tell if the viewer is running? ... another global...
or I can hook it from what called it...




PDE special calls create_obj
in PDE I am hooking in the viewer after...

obj viewer create button calls create_obj

those are the only 2 places...

why am I hooking in in PDE?
that is too far up the chain

hook in in craete OBJ that is common, or even better in the actual creators...

this works, but what happens in recursion as the viewer calls another viewer after creating...
when escaping out you go bakc through the nested viewer...I can live with it...

what about cancelling in the middle of creating? works great

what about pmsg?...patched in obj viewer at the end of create..done...

what about game_events caused by enemies getting killed by fields...
right now it says player killed with bullet...


in enemy killed this is called:
game_event(62, 0, 0, Ei[e][26], e, 0, 0);
where is 26 set?
and this
int ht = Ei[e][31]; // hit type

make a custom event...

still needs to be called from enemy_killed()

   if (type == 1) // enemy
   {
         Ei[x][31] = 1;           // flag that this enemy got shot with bullet
         Ei[x][26] = p;           // number of player's bullet that hit enemy
   }

lets try
         Ei[x][31] = 3;           // flag that this enemy got killed by a field
         Ei[x][26] = x;           // number of field


int ht = Ei[e][31]; // hit type
int hb; // health bonus
if (ht == 1) hb = 1; // bullet
if (ht == 2) hb = 2; // explosion
if (ht == 1) hb = 1; // field

// almost all do this but not enough to do by default
int a = Ei[e][0];
if (a==3 || a==4 || a==6 || a==7 || a==8 || a==9 || a==12)
{
   Efi[e][4] = al_itofix(0);  // cant hurt anymore
   Ei[e][25]*=hb; // health bonus

}
switch (Ei[e][0])
{
   case 3: // archwagon
      na = Ei[e][3] = 34;  // new ans
      dl = Ei[e][30] = 20; // death_loop_wait; set delay
      Ei[e][24] = 929+(hb-1)*32; // shape
      Efi[e][11] = al_ftofix(1.08); // scale multiplier

if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);

done... enemy killed by field!

what does player damage from field look like??
player hit a mine

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(50, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
   }

make new game_event
game_event(58, 0, 0, x, e, 0, al_fixtoi(Efi[e][4]));
customize the message by the draw type of the field
default = "was hurt by a damage field"
others "was hurt by a spiked floor"
I can get that info from the field number in the event...

done...

this is one of those that keep retriggering

in the retrigger code.. everytime one is skipped, tally the damage...



where can I check it?

something that happens every frame...
proc_frame_delay()

I need to do this for every player, don't I??

what if I keep track of that in the player struct?

damage tally, holdoff till display event...

or I could do a damage holdoff in the player...so that he doesn't take damage every frame...
enemies have a player damage holdoff built into them...
yes...once an enemy hurts any player, they cannot hurt any player for 60 frames...
this is kind naive, but it works good enough...


add something to struct player1, not synced....


float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;




done
in events

   if (ev == 57) // damage field raw
   {
      int p = z1;
      int e = z2;
      float damage = al_fixtof(Efi[z2][4]

      if (player1[p].field_damage_holdoff < frame_num) // triggered and not in holdoff
      {
         player1[p].field_damage_holdoff = frame_num + 20; // set holdoff
         player1[p].field_damage_tally = damage; // init tally with current damage
         ev = 0; // don't let this event do anything
      }

      if (player1[p].field_damage_holdoff > frame_num) // triggered and in holdoff
      {
         player1[p].field_damage_tally += damage; // inc tally with current damage
         ev = 0; // don't let this event do anything
      }
   }

in void proc_player_health(int p)





These are the pieces that make this work:


added to struct player1 (not synced)

float field_damage_tally;
int field_damage_holdoff;
int field_damage_enemy_number;

the event that draws:

if (ev == 58) // player took damage from a field
{
   custom_drawn = 1;
   int damage = (int) players1[z1].field_damage_tally;
   int e = players1[z1].field_damage_enemy_number;
   int type = Ei[e][19];

   if (type == 1) bmsg_length += bmsg_show_text(" was hurt by spikey floor ", 15, bmsg_length);
   else           bmsg_length += bmsg_show_text(" was hurt by a damage field ", 15, bmsg_length);
   bmsg_length += bmsg_show_health(-damage, bmsg_length);
}

the event that tallies:

if (ev == 57) // damage field raw
{
   int p = z1;
   int e = z2;
   float damage = al_fixtof(Efi[z2][4]);
   players1[p].field_damage_enemy_number = e;

   if (players1[p].field_damage_holdoff < frame_num) // triggered and not in holdoff
   {
      players1[p].field_damage_holdoff = frame_num + 20; // set holdoff
      players1[p].field_damage_tally = damage; // init tally with current damage
      ev = 0; // don't let this event do anything
   }

   if (players1[p].field_damage_holdoff > frame_num) // triggered and in holdoff
   {
      players1[p].field_damage_tally += damage; // inc tally with current damage
      ev = 0; // don't let this event do anything
   }
}

where event 58 is triggered:

void proc_player_health(int p)
{
   if (players1[p].field_damage_holdoff == frame_num) game_event(58, 0, 0, p, 0, 0, 0);

where event 57 is triggered:

void proc_field_collision(int type, int x, int e)
{
   if (type == 0) // player
   {
      players[x].LIFE -= Efi[e][4];
      game_event(57, 0, 0, x, e, 0, 0);
   }

It seems to be working...
make the sound effect happen on 57 so there is not delay...done...



huge idea here........

what if I seperate triggers and actions?


right now triggers and actions are a one to one relationship

what if it could be many to one, or one to many, or many to many?

the possibilites would increase exponentially.


how about for each field enemy....

add the ability to set the trigger to another field enemy

then it could look it up with flags

I will need to add a flag for toggle...
right now toggle is only calculated internally

I will need to make sure these damn links do not get broken when resorting

is that the only change I need? to make the trigger source able to be set to another field?
what if I want multiple triggers for one source?


what if I set input for each field and output for each trigger

then I can do:
many to one (input for each damage field) and
one to many (output for each trigger)...NO this will not work...just one to many





I would need some kind of event mapper from sources to actions

I think this is the way to go...it will be complicated but worth it

let try to plan this out:

create a link

create a event

named?

thingy till I get something better

when triggered set 'action 1'

action[1000]

if triggered set action[x] = 1;

then have a function to do the mapping

like

if (action[1]) action[23] = 1;

field enemies can have:
trigger action that they will set when triggered and damage action when they receive a trigger


the table of rules would look like

index action1 action2 proc
0       1      250    set
1       2      200    clear
2       4      100    toggle

the action list would be just one int, set or clear

fields could output three actions:
one for on/off
one for toggle (off to on)
one for toggle (on to off)

I would have to manually set these in the field trigger and the field damage
then I would need to create the links in the link table...

this sounds complicated...

all these events can be blank for now unless needed....

I am thinking of case when one field's timer ends and it triggers another field's timer to start....

like I said...complicated

triggers for trigger fields:

object in field
object just entered field
object just left field

number of objects in field > num
number of objects in field < num
number of objects in field == num

all these but only when they first occured
number of objects in field > num
number of objects in field < num
number of objects in field == num

triggers for damage fields
depends on type

inputs
none for always on and timed on and off
toggle would only get the ones when they first occured
timer modes would get the perstant ones

outputs
none for always on
for the other ones send a trigger when they change
and also have the ability to constantly send when on or off

I can also make a new thing that sets blocks on or off, based on triggers

after seeing all this, do you still want to proceed?

I think so...

Maybe I can make triggers items...but why, because I have lots of them...

I could make keys respond of actions, or send them..
I can make switches do the same..
Also I can make switches have an area of effect, like keys...

I also want to make blocks that stop bullet, or not, players, items, etc...

I think this action or event thing will be the heart of some great new things...

I need to plan it carefully...

each action will simply be an indexed entry in the action table.

int pm_event[1000][4];

pm_event[1000][0] - action ID
pm_event[1000][1] - clear, set, toggle off, toggle on (0, 1, 2, 3)
pm_event[1000][2] - type of initiator
pm_event[1000][3] - ID of initiator


the mapping table will look like this:

int pm_event_map[1000][3];

pm_event_map[1000][0] - source pm_event
pm_event_map[1000][1] - target pm_event
pm_event_map[1000][2] - action (0 = copy) others could be set->clear, clear->set ...

this looks like a good start...I'm scared of all this work...

when I implement this, don't kill the existing stuff...in case I give up and go back....


I want to start by cretaing an item called trigger

that looks a lot like the trigger part of field

what variables do I need?



// common

item[][0] = 9 active and type
item[][1] = bitmap or ans
item[][2] = draw type (not used)
item[][3] = (0=stat, 1=fall, -1=carry, -2=carry through door -3=sticky)
item[][4] = x pos (int) (2000)
item[][5] = y pos (int) (2000)

item[][6]  = trigger field x (2000)
item[][7]  = trigger field y (2000)
item[][8]  = trigger field w (2000)
item[][9]  = trigger field x (2000)

item[][10] = trigger field lift
item[][11] = trigger draw type


what do I still need places for?
mode
action_id
action_id type static|toggle

I can probably get rid of 1, 2, 3
use 3 for flags

item[][14] = time to live
item[][15] = tag with cloner item id


#define PM_ITEM_TRIGGER_PLAYER   0b0000000000000001
#define PM_ITEM_TRIGGER_ENEMY    0b0000000000000010
#define PM_ITEM_TRIGGER_ITEM     0b0000000000000100
#define PM_ITEM_TRIGGER_PBUL     0b0000000000001000
#define PM_ITEM_TRIGGER_EBUL     0b0000000000010000
#define PM_ITEM_TRIGGER_CURR     0b0000000000100000
#define PM_ITEM_TRIGGER_PREV     0b0000000001000000
#define PM_ITEM_TRIGGER_TGON     0b0000000010000000
#define PM_ITEM_TRIGGER_TGOF     0b0000000100000000
#define PM_ITEM_TRIGGER_LIFT_ON  0b0000001000000000
#define PM_ITEM_TRIGGER_LIFT_XC  0b0000010000000000
#define PM_ITEM_TRIGGER_LIFT_XF  0b0000100000000000
#define PM_ITEM_TRIGGER_LIFT_XL  0b0001000000000000
#define PM_ITEM_TRIGGER_LIFT_YC  0b0010000000000000
#define PM_ITEM_TRIGGER_LIFT_YF  0b0100000000000000
#define PM_ITEM_TRIGGER_LIFT_YL  0b1000000000000000


what number am I going to use 9


start making it so that the draw, move, collison code, etc all ignores type 9...


where do I patch it in?

what gets called every frame for items...move item


move_items()
if (item[i][0] == 9) process_trigger(i);
else

draw_items()
if (item[i][0] == 9)
{
    draw_trigger(i);
    drawn = 1;
}

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if ((item[x][0]) && (item[x][0] != 9))


hopefully that should do....

now make one of these....

should I make a creator...yes


I can create, I can run viewer...
display show the rectangle...

next...

fix the create making rectangle too small in lr...done
allow me to change the rectange with a button...done
and on the map...done
with legend and all that shit...done

what am I going to use for flags item[][3]

now attach to lift...done

implement the filters and do the collision detection




need to implement collison checks


the field enemy iterated all enemies in the collison detection...WTF!!!

void move_enemies()
{
   num_enemy = 0; // count enemies
   for (int e=0; e<100; e++)
      if (Ei[e][0])
      {
         num_enemy++; // count enemies

         if (Ei[e][0] != 10) // skip all this for field
         {
             if (Ei[e][0] < 50) proc_enemy_collision_with_pbullet(e);

             // check for time to live
             int ttl = Ei[e][27];
             if (ttl)
             {
                if (ttl < 11)
                {
                   Ei[e][0] = 66;             // change to different type to prevent use
                   Efi[e][4] = al_itofix(0);  // cant hurt anymore
                   Ei[e][29] = 0;             // no collision box
                   int sq = 10-ttl;
                   Ei[e][1] = zz[5+sq][74];
                }
                if (ttl == 1) Ei[e][0] = 0; // kill instantly
                Ei[e][27]--;
             }

             // check for out of bounds
             if ((Efi[e][0] < al_itofix(0)) || (Efi[e][0] > al_itofix(1999))) Ei[e][0]=0;
             if ((Efi[e][1] < al_itofix(0)) || (Efi[e][1] > al_itofix(1999))) Ei[e][0]=0;
         }
         switch (Ei[e][0])
         {
            case 3:   enemy_archwagon(e);  break;
            case 4:   enemy_bouncer(e);  break;
            case 6:   enemy_cannon(e);  break;
            case 7:   enemy_podzilla(e);  break;
            case 8:   enemy_trakbot(e);  break;
            case 9:   enemy_cloner(e);  break;
            case 10:  enemy_field(e);  break;
            case 11:  enemy_block_walker(e);  break;
            case 12:  enemy_flapper(e);  break;


so enemy_field(e) is called once for each time 10 is found......

void enemy_field(int e)
{
   int mode = Ei[e][5];
   int trig_toggle = 0;

   Ei[e][3] &= ~PM_ENEMY_FIELD_TRIGGER_CURR;  // clear current trigger flag
   detect_field_collisions();
   if (Ei[e][3] & PM_ENEMY_FIELD_TRIG

which calls detect_field_collisions();

void detect_field_collisions(void)
{
   for (int e=0; e<100; e++)
      if (Ei[e][0] == 10)
      {
         int mode = Ei[e][5];
         int FLAGS = Ei[e][3];

which iterates all enemies................there...that is the WTF moment......
fix this later....









void process_trigger(int i)
{
   int FLAGS = item[i][3];
   if (FLAGS & PM_ITEM_TRIGGER_LIFT_ON) set_item_trigger_location_from_lift(i, 0);

   item[i][3] &= ~PM_ITEM_TRIGGER_TGON;  // clear Toggle ON  trigger flag
   item[i][3] &= ~PM_ITEM_TRIGGER_TGOF;  // clear Toggle OFF trigger flag
   item[i][3] &= ~PM_ITEM_TRIGGER_CURR;  // clear current    trigger flag

   detect_trigger_collisions(i);

   if ( (item[i][3] &  PM_ITEM_TRIGGER_CURR)    // is current trigger flag set?
   && (!(item[i][3] &  PM_ITEM_TRIGGER_PREV)))  // and previous trigger flag not set?
         item[i][3] |= PM_ITEM_TRIGGER_TGON;    // set trigger ON toggle


   if (!(item[i][3] &  PM_ITEM_TRIGGER_CURR)    // is current trigger flag not set?
   && ( (item[i][3] &  PM_ITEM_TRIGGER_PREV)))  // and previous trigger flag set?
         item[i][3] |= PM_ITEM_TRIGGER_TGOF;    // set trigger OFF toggle


   if   (item[i][3] &   PM_ITEM_TRIGGER_CURR)    // is current trigger flag set?
         item[i][3] |=  PM_ITEM_TRIGGER_PREV;    // set previous trigger flag

   if (!(item[i][3] &   PM_ITEM_TRIGGER_CURR))   // is current trigger flag not set?
         item[i][3] &= ~PM_ITEM_TRIGGER_PREV;    // clear previous trigger flag


   if (item[i][3] & PM_ITEM_TRIGGER_CURR) printf("%d - CURR\n", frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_PREV) printf("%d - PREV\n", frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_TGON) printf("%d - TGON\n", frame_num);
   if (item[i][3] & PM_ITEM_TRIGGER_TGOF) printf("%d - TGOF\n", frame_num);

   printf("\n");

}

this works exactly like I thought it would....




now I am thinking of 4 sliders:

ACTION send ON
ACTION send OFF
ACTION send TOGGLE ON
ACTION send TOGGLE OFF

each of which can be set to a number from 0-100 (or more)
if 0 they are disabled

right now I have all this done up to the point that I have 4 print statements where I would emit actions number some how

what next?

draw items still need to be implemented....


make something that accepts these?

make something that is triggered by these?


my action array can be nothing more than a singel row of ints


int act[100]

if I put 34 in like..

act[34] = 1;

then if anything is listening it will react...
after something reacts to it, that something should clear it...



then I can have one to many code there
if 34 then set 45, 46, 47 also

many to one can be achieved by setting multiple source to the same action #



the rule table is a double int...or triple

0   1
34  45

34 46

34 47

34 sets 45
45 clears 67


what if I made special items that did this?

source actions up to 4
34 45 33

main s1
an int before to say what affect

1 32 (must have 32)
0 44 (must not have 34)
2 or



target actions up to 4

34 67 88



this seems rather complicated

for now I would like to make a simple one

or modify one...


make a switch that take an action input

(am I calling it action? what about pm_event?)


20220330 8:30 PM



20220331 4:00AM

made a new shape for item trigger in level editor
made draw type work
changed creator defaults
re-arranged button and slider fuctions in sliders.cpp

I could make the draw type able to choose color for the grid

how many vars do I have left...lots...maybe later...

next is to create something that will accept a trigger

kind of like key and switch rolled into one...

'block manipulation' but come up with a better name....

strcpy (item_name[16],"Block Manip");

do all the same stuff as the other item to not draw it...etc...




where do I patch it in?

what gets called every frame for items...move item






move_items()
void move_items()
{
   for (int i=0; i<500; i++)
      if (item[i][0])
      {
         if      (item[i][0] == 9) process_trigger(i);
         else if (item[i][0] == 16) process_block_manip(i);
         else
         {

draw_items()
if (item[i][0] == 16)
{
    draw_block_manip(i);
    drawn = 1;
}

void proc_player_collisions(int p)
{
   al_fixed f10 = al_itofix(10);
   al_fixed f16 = al_itofix(16);

   // items
   players1[p].potential_bomb_damage = 0;
   players[p].marked_door = -1; // so player can touch only one door
   for (int x=0; x<500; x++)
   {
      if ((item[x][0]) && (item[x][0] != 9) && (item[x][0] != 16))



make a creator...done
make shape..done

viewer...done
map...done
buttons...


now how am I going to set this up?



item[][1] = pm_event_trigger

item[][2] = draw mode

item[][3] = mode




item[][10] block 1
item[][11] block 2

0 none
1 set all blocks to block1 (one time only)
2 change all block2 to block1 (one time only)
3 toggle block1 and block2


im at the point I need to create pm_event...


extern int pm_event[100];

where to clear it? in start level stuff...

I hooked in an event and it works!!! I am so excited!


got to go...

20220331 6:25 AM

at work...
20220331 8:20 AM

add sliders to trigger...done


this pm_event thing was very easy to implement, but the method I use is very naive..
problems:

one to many won't work because the receiver erases the pm_event
same with many to one??

what if I erase all events every loop, and not erase when received?
that could work...

then many input could read one output


I also have an issue of the ordering of things...right now input and output happen in any order...
depends on when each particular object is called..

If I erase at the start of every frame...an object could be listening for one that only occurs after it...
I don't have that problem with the other method...

I'm going to stick with this simple methods for now....
a solution could be special events the do the one to many or the many to one

clean up trigger obt viewer....done....

Set Events Always While On:
Set Events Always While Off:
Set Events When Switching On:
Set Events When Switching Off:

clean up Event Trigger in block manip...done...

make a nice block selection button...kind of like color select...
when you click it, you are prompted to select a block...done....

made the modes work...nice!!!

make block manip able to be hidden.....

make trigger and block manip draw modes able to be colored....

do trigger first then copy...
need a var for color...or use draw_mode...0 == hidden

color are implemented, but need to clean up in viewer...done


wow this shit looks good!!

what could I do to make it easier?

in viewer, show thing that have matching events....

in trigger, show block manip

in block manip, show triggers


where are they located?

sources:

trigger:
item[][11]
item[][12]
item[][13]
item[][14]

destinations:

block manip:
item[1]

what I did was...in bm show link to triggers

make copying and pasting linked thing easier

add the stuff to move the boxes in zfs copying
also in there if you find linked item when copying make a new link...this will be complicated..but not impossible...


now I really want to add another item called damage...just like the enemy...how many variables will I need?

I might just barely be able to squeeze it in....

item[][0]  = 17 - Block Damage
item[][1]  = event trigger
item[][2]  = damage draw type
item[][3]  = flags
item[][4]  = x pos (2000)
item[][5]  = y pos (2000)
item[][6]  = field x (2000)
item[][7]  = field y (2000)
item[][8]  = field w (2000)
item[][9]  = field x (2000)
item[][10] = lift number
item[][11] = mode
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val
item[][15] = damage




20220331 1:49

shut it down for a bit and do a push







20220331 5:00PM

make it so that when I move trigger and bm the box moves too...where is that????


in zfs
void save_selection(int save)

            if (item[b][0] == 4) // key
            {   // set new destination
               ft_item[c][6] = item[b][6] - stx;
               ft_item[c][7] = item[b][7] - sty;
               ft_item[c][8] = item[b][8] - stx;
               ft_item[c][9] = item[b][9] - sty;
            }


            if (item[b][0] == 9) // trigger
            {   // set new destination
               ft_item[c][6] = item[b][6] - stx*20;
               ft_item[c][7] = item[b][7] - sty*20;
            }



in

void do_fcopy(int qx1, int qy1)
{

                  if (item[c][0] == 9) // // move trigger rect
                  {
                     // apply offsets
                     item[c][6] += qx1*20;
                     item[c][7] += qy1*20;

                     //item[c][8] += qx1;
                     //item[c][9] += qy1;
/*
                     if (erase_out_of_bounds_secondary)
                     {
                        if (check_limit(item[c][6], 0, 99)) lim = 1;
                        if (check_limit(item[c][7], 0, 99)) lim = 1;
                        if (check_limit(item[c][8], 0, 99)) lim = 1;
                        if (check_limit(item[c][9], 0, 99)) lim = 1;
                     }
                     else // adjust if out of bounds
                     {
                        item[c][6] = enforce_limit(item[c][6], 0, 99);
                        item[c][7] = enforce_limit(item[c][7], 0, 99);
                        item[c][8] = enforce_limit(item[c][8], 0, 99);
                        item[c][9] = enforce_limit(item[c][9], 0, 99);
                     }
*/

                  }
i really should do some boundary checks...

now for the regular move from draw item...



               if (item[draw_item_num][0] == 9) // trigger
                  //if (al_show_native_message_box(display, "Move?", "Move the range also?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
                  {
                     item[c][6] = item[draw_item_num][6] + (x100*20) - item[draw_item_num][4]; // move x
                     item[c][7] = item[draw_item_num][7] + (y100*20) - item[draw_item_num][5];
                  }

               if (item[draw_item_num][0] == 16) // block manip
                  //if (al_show_native_message_box(display, "Move?", "Move the range also?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
                  {
                     item[c][6] = item[draw_item_num][6] + (x100*20) - item[draw_item_num][4]; // move x
                     item[c][7] = item[draw_item_num][7] + (y100*20) - item[draw_item_num][5];
                  }




this is all good now...
copying trigger and bm now move range relative to main item...


now can I do something magic about the links?

should I start making the damage item?

lots of it would be just copied from field enemy


make a creator...done
patch draw...done
patch move...done
player collision...done

title obj...done
map move...done

zfs copy...done
draw item copy...done

drawing mode...done
lift mode...done

next is mode and timers...

event slider...done

implement the flags for damage...slider done
do collisions.....done

current damage button...done

for player damage add a flag to make it instant death.....

sliders for timers...done
ttl is showing for bd...made code to ignore items 9, 16, 17...done

finish modes...done

do drawing timer counts....done...
I have no variables left...make 2 flags for 4 combos..what about off?
the less complicated way would be to use 4 flags, one for each...

#define PM_ITEM_DAMAGE_TIMR_SN  0b00010000000000000
#define PM_ITEM_DAMAGE_TIMR_BN  0b00100000000000000
#define PM_ITEM_DAMAGE_TIMR_SP  0b01000000000000000
#define PM_ITEM_DAMAGE_TIMR_BP  0b10000000000000000

made button and implemented....done

seems like all this is working...

still to do...

add player instant death option...flag and button...

make the viewer menu look good.....


20220401 6:20 AM  push....

10:30 AM

back...

add get new box button...


fix the bitmap shown for draw item and in viewers.........





Draw Trigger Field:ON
Draw Trigger Field:OFF
Trigger Field Color

Draw Block Manip Field:ON
Draw Block Manip Field:OFF
Block Manip Field Color


Damage Field Draw Type:

Draw Block Damage Field:OFF
Block Damage Field Color

timer display could have a divide by zero error
also set some times in creator

...need to prevent this...


I would like to set key to use the same block standard as trig, manip, damage
0-1999
x, y, w, h
then so much of the code can be re-used
also cloner and podzilla??

OK the viewer menus look pretty good now....

make sure you can't divide by zero when doing calcs before calling percent...done

fix the bitmap shown for draw item and in viewers...done


add player instant death option...flag and button...done

hook into game_event...done


figure out values for player damage....
now 0-99 / 100

(good at low range, needs more damege at high range)
at lowest (1) lose 1 health every 2 sec
at highest (99) lose 100 in 3 sec

try 0-1000 / 100
at 1000 running through a single block as fast as you can takes 50 health

lets go with 2000
when jumping up through a single block...20?
when jumping up on the fastest sproingy, you can easily go right through it witout getting hit...
that's just because you are moving so fast...nothing to do, just accept it...

make text line up on
player instant death 403
player damage 98
line up with all the affect lines...421-424
.............done....


what about the link lines when link is zero?
only on block manip is it shown...
fix it and make it work for block damage also...
what about trigger??

make a helper function...
pass it current item and have it show links...done


what if a make a button...create link...if I press it then I am prompted to choose an item to link to...

when I do it will search and make choose a unique event id to use...
as I am moving around the map to choose, it will show stuff about the items I am trying to link to...


make a function to find an unused pm_event.

search all items

how many?

100? changed to 1000

int get_unused_pm_event(void)
{
   int ev = 1; // don't ever use event 0
   int done = 0;
   while (!done)
   {
      int used = 0;
      for (int i=0; i<500; i++)
      {
         if (item[i][0] == 9)
         {
            if (item[i][11] == ev) used = 1;
            if (item[i][12] == ev) used = 1;
            if (item[i][13] == ev) used = 1;
            if (item[i][14] == ev) used = 1;
         }
         if ((item[i][0] == 16) && (item[i][1] == ev)) used = 1;
         if ((item[i][0] == 17) && (item[i][1] == ev)) used = 1;
      }
      if (!used) return ev;
      else if (++ev > 999) done = 1;
   }
   return 0; // only if no unused can be found
}


in zfs copy...only for items 16 and 17

if 16 or 17...

if exactly one linked item...and its a trigger...
make both items have a new unique link

give up...will not work...



how about the button on manip

right under link...
choose linked item....

there is some great code I can copy in door that does something very similar...

      if (bn == 4)
      {
         if (item[num][8] == 1) // Set Linked Item
         {
             int i = get_item("Select Another Door To Link To", 2, 1, num );
             if (i > -1) item[num][9] = i;
             Redraw = 1;
         }
      }



      if (bn == 320)
      {
         {
             int i = get_trigger_item("Select A Trigger To Link To", 2, 9, num );
             if (i > -1) item[num][1] = i;
             Redraw = 1;
         }
      }

I got it to work....


int get_trigger_item(const char *txt, int obj_type, int sub_type, int num )
{
   int itx, ity, dx, dy;
   int mouse_on_item = 0;
   int quit = 0;
   int ret_item = -1;

   while (mouse_b1) proc_controllers();      // wait for release

   int x2 = item[num][4]/20; // get the original item position
   int y2 = item[num][5]/20;




   while(!quit)
   {
      // show text line
      al_draw_text(font, palette_color[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, palette_color[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "with left mouse button");
      al_draw_text(font, palette_color[14], txc, 120, ALLEGRO_ALIGN_CENTER, "Cancel");
      al_draw_text(font, palette_color[9],  txc, 128, ALLEGRO_ALIGN_CENTER, "with right mouse button");

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));
      title_obj(obj_type, sub_type, num, 0, 15);

      proc_controllers();

      dx = mouse_x/db;
      dy = mouse_y/db;

      draw_bs(14);      // show bullseye map

      mouse_on_item = 0;

      if ((dx<100) && (dy<100))      // if mouse on map
         for (int x=0; x<500; x++)
            if (item[x][0] == 9)    // trigger only
            {
               itx = item[x][4]/20;
               ity = item[x][5]/20;
               if ((dx == itx) && (dy == ity))
               {
                  mouse_on_item = 1;
                  ret_item = x;
               }
            }

      itx = item[ret_item][4]/20;
      ity = item[ret_item][5]/20;

      crosshairs(0, 0, x2, y2, 13); // draw the original position
      if (mouse_on_item)
      {
         crosshairs(0, 0, itx, ity, 14); // draw the selected item position
         int o = db/2;
         al_draw_line(x2*db+o, y2*db+o, itx*db+o, ity*db+o, palette_color[14], 1);
         al_draw_textf(font, palette_color[15], txc, 180, ALLEGRO_ALIGN_CENTER, " Item:%d ", ret_item);
      }
      else
      {
         find_and_show_event_links(num); // assume for now that this just gets called with item type 16 and 17
      }






      while (mouse_b1)
      {
         proc_controllers();
         quit = 1;
      }
      while ((mouse_b2) || (key[ALLEGRO_KEY_ESCAPE]))
      {
         proc_controllers();
         quit =1;
         ret_item = -1;
      }
   } // end of while(!quit);
   if (!mouse_on_item) ret_item = -1;
   return ret_item;
}



if (bn == 320)
{
   int i = get_trigger_item("Select A Trigger To Link To", 2, 16, num );
   if (i > -1)
   {
      int ev = get_unused_pm_event();
      item[num][1] = ev;

      // which trigger should I link to? for now just pick 11, but later detect if I need to use toggle
      item[i][11] = ev;
   }
   Redraw = 1;
}


now I want to be able to pick the right trigger....


in bm if mode 3 then toggle

if item[][0] == 16) && item[][3] == 3 //toggle


      if (bn == 320)
      {
         int i = get_trigger_item("Select A Trigger To Link To", 2, 16, num );
         if (i > -1)
         {
            int ev = get_unused_pm_event();
            item[num][1] = ev;

            if (item[num][3] == 3) // mode 3 - toggle blocks
            {
               item[i][11] = 0;
               item[i][12] = 0;
               item[i][13] = ev;  // needs a toggle trigger
               item[i][14] = 0;
            }
            else
            {
               item[i][11] = ev;  // regular trigger
               item[i][12] = 0;
               item[i][13] = 0;
               item[i][14] = 0;
            }
         }
         Redraw = 1;
      }

even better....
now do the same for bd
if item[][0] == 17) && item[][11] == 1 //toggle
done...


its working good.....

im tired and need to go to bed...

20220401 9:21PM

make some things to show off the new stuff...


the floor that keeps growing as you get to the end

a spikey floor that is damaging if you don't keep jumping


a room that you can't exit until all enemies in the room are killed


I really want to have the copy paste thing make new links...

before the paste happens...

iterate everything that is going to be pasted....

if there any items that have links, put them in a list...

like...

int copy_link_tranform[500][4]

0 - source item number
1 - source item var
2 - source item ev
3 - new ev number



then after filling the list...
iterate the list
- find ev number
- does it exist in destination item array?
- if yes find new empty and set in dest
- iterate the rest of the list and see if any more are found with same source ev
- set then also

then when copying use the new number...

I need a place to put pm_event related funtions...
I like e_fnx....

lets do that...
then make a new funtion that determines in an event is used...

all the fucntions are now in e_fnx....

made these....

int is_pm_event_used(int ev)
{
   for (int i=0; i<500; i++)
   {
      if (item[i][0] == 9)
      {
         if (item[i][11] == ev) return 1;
         if (item[i][12] == ev) return 1;
         if (item[i][13] == ev) return 1;
         if (item[i][14] == ev) return 1;
      }
      if ((item[i][0] == 16) && (item[i][1] == ev)) return 1;
      if ((item[i][0] == 17) && (item[i][1] == ev)) return 1;
   }
   return 0;
}

int get_unused_pm_event(void)
{
   int ev = 1; // don't ever use event 0
   int done = 0;
   while (!done)
   {
      if (!is_pm_event_used(ev)) return ev;
      else if (++ev > 999) done = 1;
   }
   return 0; // only if no unused can be found
}



made int copy_link_tranform[500][4] global...
I have a few function that I want to manip it...

wait a tick...do I need to make it global? can I just pass the array ref to the calling function?
lets try it....

here is how to do it:

pass it like this clt
in function that gets it use clt[][4]

this is what I have so far...


// this section is to make any copied pm_event links have new unique pm_events and still linked properly
int clt[500][4] = { 0 };
int clt_last = 0; // index

for (b=0; b<500; b++)       // iterate items in selection
{
   if ((ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // manip or block
   {
      clt_last += add_item_link_translation(b, 1, ft_item[b][1], clt, clt_last);
   }

   if (item[b][0] == 9) // trigger
   {
      clt_last += add_item_link_translation(b, 11, ft_item[b][11], clt, clt_last);
      clt_last += add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
      clt_last += add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
      clt_last += add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
   }
}

int add_item_link_translation(int sel_item_num, int sel_item_var, int sel_item_ev, int clt[][4], int clt_last)
{
   if (sel_item_ev)
   {
      // check if this event already has a translation and get it if it does
      int ev2 = check_clt_for_event(sel_item_ev, clt, clt_last);

      if (ev2) // existing translation found
      {
         clt[clt_last][0] = sel_item_num;   // item # in selection
         clt[clt_last][1] = sel_item_var;   // item var #
         clt[clt_last][2] = sel_item_ev;    // original link
         clt[clt_last][3] = ev2; // new link

         printf("et %d %d %d %d\n", clt[clt_last][0], clt[clt_last][1], clt[clt_last][2], clt[clt_last][3]);

      }
      else // no existing translation found
      {
         ev2 = get_unused_pm_event_extended(clt, clt_last);
         clt[clt_last][0] = sel_item_num;   // item # in selection
         clt[clt_last][1] = sel_item_var;   // item var #
         clt[clt_last][2] = sel_item_ev;    // original link
         clt[clt_last][3] = ev2; // new link
         printf("ne %d %d %d %d\n", clt[clt_last][0], clt[clt_last][1], clt[clt_last][2], clt[clt_last][3]);
      }
   }
   else return 0; // nothing added
   return 1; // added
}



// does this copy item have an entry in the clt table?
for (int i=0; i<clt_last; i++)
   if (clt[i][0] == b) // found index of source item table
   {
      int var_index = clt[i][1]; // var #
      int ev2 = clt[1][3];       // new ev

      item[c][var_index] = ev2;
   }


I am missing an important step.....

the link translation table is being correctly built....

but when I go to appy it, all i have is the link to to sel_item...I need the link to the dest item...
need to add it to array... then set it when copying from sel to dest...
belay that...when I am doing it already, I have both source and dest...should work fine...(now that I fixed a bug!)
yup, it seems to work fine...

for the first set...

then the triggers don't seem to copy nice after that...they stick with the copy items...

it works fine when copying everything...found the bug!!!

back to making some really cool demo levels....

a spikey floor that is damaging if you don't keep jumping

bug, can set timer for bd but slider does not update....
104 and 103...fixed

bug instant death(403) affects timer draw mode(401)
same flag define!!



I made a really cool level...

Level 58

- floor that grows when you get to the end... or shoot bullet across it
- room that locks you in when you enter
- room that you need to kill all enemies before the wall will open
- spikey floor that retracts on a timer when you trigger it
- room that you are locked in until you lead an enemy into an area

This is really cool looking... This level is done...
Next, I will make more cool stuff, like....

Block toggle puzzle


bug if you escape out of block select it dies badly.....fixed

rectangle_with_diagonal_lines(x1, y1, x2, y2, 10, col, col+96);
draws 1 pixel up and to the left......fixed by adjusting the clipping rectangle

I want to check collisions, especially bullets...
there is one spot.....
when facing right and shooting up x=26 does not hit either block
when facing left  and shooting up x=93 does not hit either block
when shooting left and right y=49 does not hit either block
I think 1 pixel is close enough

i want to make bombs bigger than 800...lets try 1200...nice....

what else can I do to show off the new stuff?










can I do my own effect of a coing spinning...like logo...?


extend bonus item to include the new coins...


I could make key just emit event...then it would not draw nice...maybe I could...


pm_event logic...


make an item that does nothing but acts as a switch point for pm_events

have a group of AND inputs, OR INPUTS

and one on more outputs

how will it handle toggles?
will it erase pm_events every frame?
yes, if it uses or looks at them

right now I can't have a trigger affect muliple things because when it is used, it is deleted
right now I can have multiple trigger affecting the same thing, but...
one might overide the other
- toggle bad
- reset damage timer, ok


make a trigger item...count...
number of enemies > num
number of enemies < num
same for items and players





extend bonus to also include free man and coins....
maybe I can do my own rotate, like with logo...later


[2] - bonus

item[][6] bonus type
1 = health
2 = free man
3 = purple coin

item[][7] health bonus
item[][8] bullet bonus (ignored now)
item[][9] timer bonus  (ignored now)

now I need to run glt and set all bonus type 2 to have 6 = 1...
I have 330 bonus types and all have 7 set and nothing for 8 and 9...

set all to have type = 1...

fix in PDE...done


fix when flowers and diamonds are created....
at the very end of enemy death...done

now add free man...

all that matters is

item[][6] bonus type = 2

old:
item[][0] = 6
item[][1] = 1038
item[][2] = 1
item[][3] = 1

new:
item[][0] = 2
item[][1] = 1038
item[][2] = 1
item[][3] = 1
item[][6] = 2

done in PDE...

now do in glt...done, there are no item 6 any more...

where in code should I kill it...
item text in menu...

in e_items  remove 6 from testing good...

in z_items  removed:

//  if (c ==  6) sprintf(msg, "%d Free Men    ", item_num_of_type[c]);

void proc_freeman_collision(int p, int i)
{
   item[i][0] = 0;
   players[p].LIVES++;
   game_event(70, 0, 0, p, i, 0, 0);
}

case 6:  proc_freeman_collision(p, i);  break;

make purple coin...

new:
item[][0] = 2
item[][1] = 192
item[][2] = 0
item[][3] = 1
item[][6] = 3

OK it is done...I can easily add one to level and there is code to touch it...later patch in something usefull....

now I want to make key have the same type of field as 9, 16, 17....

this is a huge task....

6:42 AM

find the one place where the key removes blocks...done

void move_items()
{
   for (int i=0; i<500; i++)
      if (item[i][0])
      {

               if (item[i][11] == 0)
               {
                  // remove the key
                  item[i][0] = 0;
                  if (item[i][12]) // matching keyed blocks only
                  {
                     int key = item[i][1] - 1039;
                     for (int x = item[i][6]; x <= item[i][8]; x++)
                        for (int y = item[i][7]; y <= item[i][9]; y++)
                           if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
                              remove_block(x, y);
                  }
                  else // remove all blocks in range
                  {
                     for (int x = item[i][6]; x <= item[i][8]; x++)
                        for (int y = item[i][7]; y <= item[i][9]; y++)
                           remove_block(x, y);
                  }





key creator.....

         item[c][6] = bx1*20;
         item[c][7] = by1*20;
         item[c][8] = (bx2-bx1)*20;
         item[c][9] = (by2-by1)*20;

/*       item[c][6] = bx1;
         item[c][7] = by1;
         item[c][8] = bx2;
         item[c][9] = by2; */



create and test...does not work...
i think move key puts it off screen then it dies....

void proc_key_collision(int p, int i)
{
   if (item[i][11] == 0) // only collide if not already moving
   {

//      int x2 = (item[i][6] + item[i][8]) * 10;         // get the center of the block range
//      int y2 = (item[i][7] + item[i][9]) * 10;
      int x2 = (item[i][6] + item[i][8] / 2);         // get the center of the block range
      int y2 = (item[i][7] + item[i][9] / 2);

now it works!!!!

show in obj viewer nicely.....

            int x2 = item[num][6]/20 * db;
            int y2 = item[num][7]/20 * db;
            int x3 = x2 + (item[num][8]/20 + 1) * db;
            int y3 = y2 + (item[num][9]/20 + 1) * db;;
            int x4 = (x2+x3)/2;
            int y4 = (y2+y3)/2;


/*            int x2 = item[num][6] * db;
            int y2 = item[num][7] * db;
            int x3 = item[num][8] * db + db - 1;
            int y3 = item[num][9] * db + db - 1;;
            int x4 = (x2+x3)/2;
            int y4 = (y2+y3)/2; */



now map move thinks its one smaller than it is....
leave map move and fix the others....
just fix it
when creating save one bigger...done...now the only thing is to fix the block killer...done....


I think this all works now...


// remove the key
item[i][0] = 0;
if (item[i][12]) // matching keyed blocks only
{
   int key = item[i][1] - 1039;
   int x1 = item[i][6] / 20;
   int y1 = item[i][7] / 20;
   int x2 = (item[i][6] + item[i][8]) / 20;
   int y2 = (item[i][7] + item[i][9]) / 20;
   for (int x = x1; x < x2; x++)
      for (int y = y1; y < y2; y++)
         if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
            remove_block(x, y);
/*                     for (int x = item[i][6]; x <= item[i][8]; x++)
      for (int y = item[i][7]; y <= item[i][9]; y++)
         if ((l[x][y] == 188 + key) || (l[x][y] == 204 + key) || (l[x][y] == 220 + key))
            remove_block(x, y); */
}
else // remove all blocks in range
{
   int x1 = item[i][6] / 20;
   int y1 = item[i][7] / 20;
   int x2 = (item[i][6] + item[i][8]) / 20;
   int y2 = (item[i][7] + item[i][9]) / 20;
   for (int x = x1; x < x2; x++)
      for (int y = y1; y < y2; y++)
         remove_block(x, y);
/*                     for (int x = item[i][6]; x <= item[i][8]; x++)
      for (int y = item[i][7]; y <= item[i][9]; y++)
         remove_block(x, y); */
}

// creator
item[c][6] = bx1*20;
item[c][7] = by1*20;
item[c][8] = (bx2-bx1+1)*20;
item[c][9] = (by2-by1+1)*20;
/* item[c][6] = bx1;
item[c][7] = by1;
item[c][8] = bx2;
item[c][9] = by2; */

// title obj (same as 9, 17, 17)
int x2 = item[num][6]/20 * db;
int y2 = item[num][7]/20 * db;
int x3 = x2 + item[num][8]/20 * db - 1;
int y3 = y2 + item[num][9]/20 * db - 1;;
int x4 = (x2+x3)/2;
int y4 = (y2+y3)/2;


/*            int x2 = item[num][6] * db;
int y2 = item[num][7] * db;
int x3 = item[num][8] * db + db - 1;
int y3 = item[num][9] * db + db - 1;;
int x4 = (x2+x3)/2;
int y4 = (y2+y3)/2; */

map move is now the same as 9, 16, 17


am I ready to change all keys in glt????
test on level 62 only...

make a backup of the level folder...

do I have any new style keys?  kill them...done...

lets do glt on everything.....did 430 keys...test....seems to work

7:52 that only took 1:10...


I want a trigger draw type that obviously looks like you can shoot it

see if I can amke shapes for bonus look like they are rotating....
I'm thinking of using scale and flip...

do it for purple coins...


I have it done....

can I make it a nice function?

what do I need:

tile number
x and y ul corner
0 0 20 20 inputs

over all scale of output
how dim the back side is
how fast to turn



void spin_shape(int tn, int x, int y, int tsx, int tsy, int tsw, int tsh, float scale, float dim, int cycle)
{
   int cti = cycle; // how many frame a full spin takes

   float ct = (int)cti; //cycle time
   float ct1 = ct/4;    // 20
   float ct2 = ct/2;    // 40
   float ct3 = ct1*3;   // 60
   float ct4 = ct;      // 80

   int tm = frame_num % cti; // get a number from 0 to cti than increments every frame

   float tmr = (int) tm;

   float xs = 0;
   int flags = 0;


   // 80-60 = narrow to wide xs = 0 to 20 regular draw
   // 60-40 = wide to narrow xs = 20 to 0 regular draw

   // 40    = narrowest      xs = 0       flip draw from regular to reverse

   // 40-20 = narrow to wide xs = 0 to 20 reverse draw
   // 20-0  = wide to narrow xs = 20 to 0 reverse draw

   // 0     = narrowest      xs = 0       flip draw from reverse to regular


   if (tmr > ct2)
   {
      if (tmr>ct3) xs = ct4-tmr;  // 80-60 ---> 0-20
      else         xs = tmr-ct2;  // 60-40 ---> 20-0
   }
   else
   {
      if (tmr>ct1) xs = ct2-tmr;    // 40-20 ---> 0-20
      else xs = tmr;                // 20-0  ---> 20-0
      flags |= ALLEGRO_FLIP_HORIZONTAL;
   }

   // scale xs (if ct == 80 scale = 1)
   // or more accurately full width of tile (20) * 4
   float xscale = (tsw*4)/ct;
   xs *= xscale;

   float ys=tsh; // y scale is the same as the source height of the tile


   // optionally scale the entire thing
   xs *= scale;
   ys *= scale;

   // get draw offsets based on scale of final tile
   int xo = 10 - (xs/2); // x offset
   int yo = 10 - (ys/2); // x offset

   ALLEGRO_COLOR c2 = al_map_rgba_f(dim, dim, dim, 1.0); // show dimmer on back side

   if (flags == 0) al_draw_scaled_bitmap(       tile[tn],     tsx, tsy, tsw, tsh, x+xo, y+yo, xs, ys, flags);
   else            al_draw_tinted_scaled_bitmap(tile[tn], c2, tsx, tsy, tsw, tsh, x+xo, y+yo, xs, ys, flags);

}





in view object for does blast radius only show discreet (20) values?
this is how its drawn in title obj:
int bs = (item[num][7] / 20) * db;
what if i did this?
int bs = (item[num][7] * db) / 20;
that seems to have fixed it...



just for shits and giggles, how are pods trigger, cloners trigger source and set stored....

all are 0-99
only source and dest use w and h

pod
Ei[][11] = trigger box x1
Ei[][12] = trigger box x1
Ei[][13] = trigger box x2
Ei[][14] = trigger box y2

cloner
Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2

Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height

why doesn't cannon have a prox for bullet firing?

make circles have adjustments in map move...
only when that object is active...


try it for bomb...done for bomb and rocket.....






I have this idea for the tiles. Or more for the level array l[100][100].

I want to store more info in the ints that make up the array.


Right now I use special indexes to tell what kind of block it is.
I make no distinction between level drawing blocks and ones uses to draw items and enemies.

0-31  empty blocks
32-63 semi solid

>63 are full solid

64-95  bombable
96-127 breakable

I also have rope and ladder shapes that are empty, but have special properties...

What I want to do is use some of the higher bits for flags that implement these properties

the way I check if a block is solid right now is simply is:
if (tile>63)

the way I propose to do it is:
if (tile & PM_TILE_SOLID)

to get the actual tile index, I would just strip off the higher bits

right now I use 1024 tiles or 2^10 10 bits, that leaves 22

right now in level editor, I only show a subset of these blocks in the selection window

when loading I use swbl or somthing like that to determine which ones are in that group

I could do something similar to tag all the tiles when loading level editor

then fropm that point, once a blcock was placed in the level, it would have those flags..

they could be manipulated after being placed, like if I wanted to make a normally solid
block act as if it was empty to make a secret

then in the drawing code...

lets make some flags:


PM_TILE_SOLID_PLAY
PM_TILE_SOLID_ENMY
PM_TILE_SOLID_ITEM
PM_TILE_SOLID_EBUL
PM_TILE_SOLID_PBUL

PM_TILE_SEMISOLID_PLAY
PM_TILE_SEMISOLID_ENMY
PM_TILE_SEMISOLID_ITEM

PM_TILE_SOLID_EBUL
PM_TILE_SOLID_PBUL

PM_TILE_BOMBABLE

PM_TILE_BREAKABLE_PBUL
PM_TILE_BREAKABLE_EBUL

PM_TILE_LADDER_MOVE
PM_TILE_ROPE_MOVE

PM_TILE_SECRET (when touched by player it shows empty)

PM_TILE_SHOW_IN_SELECTION_WINDOW


Wow, I've used 16 already

I'm sure I'll think of others...

make a function to apply these to the entire tileset

view attributes in bitmap thingy....

Should I go even further and put block tiles in their own bmp file?

It would require a huge re-write....
block_tiles...
I can leave the main one (tiles)

and migrate all blocks to the new one...I can even keep the same positions to make migration easier...

step 1 - make a copy and rename it block_tiles...done

step 2 - load it and store it just like tiles..

step 3 - change all block tile drawing to use the new one...

added to main

ALLEGRO_BITMAP *tilemap = NULL;
ALLEGRO_BITMAP *btilemap = NULL;  <-------
ALLEGRO_BITMAP *ptilemap = NULL;
ALLEGRO_BITMAP *dtilemap = NULL;
ALLEGRO_BITMAP *M_tilemap = NULL;
ALLEGRO_BITMAP *M_btilemap = NULL; <-------
ALLEGRO_BITMAP *M_ptilemap = NULL;
ALLEGRO_BITMAP *M_dtilemap = NULL;

ALLEGRO_BITMAP *tile[NUM_SPRITES] = {NULL};
ALLEGRO_BITMAP *btile[NUM_SPRITES] = {NULL}; <-------


called from setup in main..





void create_bmp(void)
{
   // create tilemap bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);
   tilemap = al_create_bitmap(640, 640);
   btilemap = al_create_bitmap(640, 640);   <------------------
   ptilemap = al_create_bitmap(480,320);
   dtilemap = al_create_bitmap(160,640);
//   printf("tilemap\n");
//   show_pixel_format(al_get_bitmap_format(tilemap));
//   show_bitmap_flags(al_get_bitmap_flags(tilemap));


   // create memory bitmaps as temp storage for restoring tilemaps after screen change
   al_set_new_bitmap_flags(ALLEGRO_MEMORY_BITMAP);
   M_tilemap = al_create_bitmap(640,640);
   M_btilemap = al_create_bitmap(640,640);  <------------------
   M_ptilemap = al_create_bitmap(480,320);
   M_dtilemap = al_create_bitmap(160,640);
//   printf("M_tilemap\n");
//   show_pixel_format(al_get_bitmap_format(M_tilemap));
//   show_bitmap_flags(al_get_bitmap_flags(M_tilemap));



int load_tiles(void)
{
   int load_error = 0;

   // get main tiles
   tilemap = al_load_bitmap("bitmaps/tiles.bmp");
   if (!tilemap)
   {
      m_err("Can't load tiles from bitmaps/tiles.bmp");
      load_error = 1;
   }
   else
   {
      //printf("load good\n");
      al_convert_mask_to_alpha(tilemap, al_map_rgb(0, 0, 0)) ;
      al_set_target_bitmap(M_tilemap);
      al_draw_bitmap(tilemap, 0, 0, 0);
      for (int y=0; y<32; y++)
         for (int x=0; x<32; x++)
            tile[y*32 + x] = al_create_sub_bitmap(tilemap, x*20, y*20, 20, 20);
   }


void rebuild_bitmaps(void)
{
   //printf("rebuild bitmaps\n");

   // rebuild main tiles
   al_set_target_bitmap(tilemap);
   al_draw_bitmap(M_tilemap, 0, 0, 0);

   // rebuild block tiles
   al_set_target_bitmap(btilemap);
   al_draw_bitmap(M_btilemap, 0, 0, 0);

   // rebuild player tiles
   al_set_target_bitmap(ptilemap);
   al_draw_bitmap(M_ptilemap, 0, 0, 0);


use them to draw levelbackground.....

void init_level_background(void) // fill level_background with blocks and lift lines
{
   //printf("init_level_background\n");
   al_set_target_bitmap(level_background);
   al_clear_to_color(al_map_rgb(0,0,0));
   for (int x=0; x<100; x++)
      for (int y=0; y<100; y++)
      {
         int c = l[x][y];
         if (c < NUM_SPRITES)
            al_draw_bitmap(btile[c], x*20, y*20, 0);  <---------------
      }
   draw_lift_lines();
}


make a backup copy of tiles.bmp
draw all over blocks in original...
looks like they are working.....


use glt to find out what blocks are being used in what levels....


block:0 count:748538
block:7 count:459
block:8 count:493
block:9 count:145
block:10 count:234
block:11 count:47
block:12 count:38
block:13 count:4
block:14 count:133
block:15 count:37
block:16 count:112
block:17 count:4
block:18 count:883
block:19 count:706
block:32 count:3280
block:33 count:274
block:34 count:461
block:35 count:312
block:36 count:22
block:37 count:122
block:38 count:21
block:39 count:2
block:64 count:7265
block:65 count:71
block:66 count:141
block:96 count:10292
block:97 count:20
block:98 count:20
block:99 count:213
block:100 count:231
block:128 count:5808
block:129 count:5547
block:130 count:633
block:132 count:126
block:133 count:819
block:134 count:3695
block:135 count:1911
block:136 count:250
block:137 count:863
block:138 count:5568
block:139 count:3843
block:140 count:8389
block:141 count:7421
block:142 count:4715
block:143 count:2918
block:160 count:56
block:161 count:15
block:162 count:69
block:163 count:15
block:164 count:764
block:166 count:3309
block:172 count:249
block:173 count:486
block:174 count:411
block:175 count:361
block:177 count:946
block:178 count:5300
block:179 count:762
block:188 count:102
block:189 count:59
block:190 count:44
block:191 count:17
block:204 count:126
block:205 count:48
block:206 count:29
block:207 count:50
block:220 count:768
block:221 count:698
block:222 count:328
block:223 count:1134
block:576 count:680
block:577 count:683
block:578 count:717
block:579 count:719
block:580 count:12954
block:581 count:8
block:582 count:16830
block:584 count:243
block:585 count:116
block:586 count:240
block:587 count:146
block:588 count:250
block:589 count:124
block:590 count:260
block:591 count:221
block:592 count:92
block:608 count:136
block:609 count:108
block:610 count:110
block:611 count:138
block:612 count:2113
block:614 count:2294
block:616 count:44
block:617 count:40
block:618 count:41
block:619 count:51
block:620 count:79
block:621 count:37
block:622 count:80
block:623 count:57
block:624 count:49
block:625 count:77
block:640 count:40
block:641 count:54
block:642 count:41
block:643 count:41
block:644 count:258
block:645 count:257
block:646 count:543
block:647 count:490
block:656 count:2587
block:672 count:176
block:673 count:182
block:674 count:182
block:675 count:186
block:676 count:371
block:677 count:354
block:678 count:345
block:679 count:359
block:704 count:145
block:705 count:137
block:706 count:144
block:707 count:139

123 unique blocks

If I move some around in my new tile thingy, I will need to do glt for the translation...


what is next?

make level_editor selection thing use the new btiles...

selection window draws itself....

int process_select_window(int draw_only)


   // blocks top bar frame and text
   if (select_window_block_on)
   {
      al_draw_filled_rectangle(swx1, syb, swx2, syb+12, palette_color[9+192]);
      al_draw_rectangle(       swx1, syb, swx2, syb+12, palette_color[9], 1);
      al_draw_text(font, palette_color[9], swx1+2,  syb+2, 0, "Block Selection ");
      al_draw_text(font, palette_color[9], swx2-9,  syb+2, 0, "X");
      al_draw_text(font, palette_color[9], swx2-25, syb+2, 0, "-");
      al_draw_text(font, palette_color[9], swx2-41, syb+2, 0, "+");

      for (c=0; c<16*swnbl_cur; c++)
         al_draw_bitmap(btile[swbl[c][0]], swx1+(c-((c/16)*16) )*20+1, swy1+select_window_block_y+1+14+(c/16*20), 0 );   <-----------------
   }


now draw item and point item....



void show_draw_item_cursor(void)
{
   else switch (draw_item_type)
   {
      case 1: al_draw_bitmap(btile[draw_item_num], x, y, 0); break;  <-------------
      case 2: draw_item_shape(draw_item_num, x, y); break;



void draw_item_info(int x, int y, int color, int type, int num)
{
   int a, b;
   switch (type)
   {
      case 1:
         al_draw_bitmap(btile[num], x, y, 0);   <----------------
         al_draw_textf(font, palette_color[color], x+22, y+2, 0, "Block #%d",num);



OK I think everything now points at the new btiles.....


now what???

make a way of moving the tiles around and editing flags...

this will be saved just like the old swbl thing, but only for the new stuff...

First thing I should do is remove all the none block things from btiles...

I could do this automatically with a combo of glt and save bitmap....



int save_tiles(void)
{
   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(tile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tiles.bmp", temp);
   al_destroy_bitmap(temp);

   char sprit_filename[20] = "bitmaps/sprit001.pm";

   for (int c=0; c<NUM_ANS; c++)    // set all to initial
      if (zz[4][c] != 0)
      {
         zz[0][c]=zz[5][c];
         zz[1][c]=0;
         zz[2][c]=0;
      }
   filepntr = fopen( sprit_filename,"wb");
   for (int c=0; c<NUM_ANS; c++) // put animation sequences
      for (int y=0; y<20; y++)
      {
         int ho = (zz[y][c] / 256);
         int lo = zz[y][c] - (ho*256);
         fputc(ho, filepntr);
         fputc(lo, filepntr);
      }
   for (int c=0; c<NUM_SPRITES; c++)  // shape attributes sa[512][2]
      for (int y=0; y<2; y++)
         fputc(sa[c][y], filepntr);

   fclose(filepntr);
   return 0;
}


use just this.....


   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(btile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tempb_tiles.bmp", temp);
   al_destroy_bitmap(temp);



void remove_unused_tiles(void)
{
   for (int z=0; z<NUM_SPRITES; z++)
   {
      if (blt[z] == 0) // block is not used
      {
         al_set_target_bitmap(btile[z]);
         al_clear_to_color(al_map_rgb(0,0,0));
      }
   }

   ALLEGRO_BITMAP* temp = al_create_bitmap(640, 640);
   al_set_target_bitmap(temp);
   for (int y = 0; y < 32; y++)
      for (int x = 0; x < 32; x++)
         al_draw_bitmap(btile[y*32 + x], (x*20), (y*20), 0);

   al_save_bitmap("bitmaps/tempb_tiles.bmp", temp);
   al_destroy_bitmap(temp);

}


holy shit that worked!  block_tiles.bmp is so much cleaner now.....

now make the code to edit and set flags.... I will still use swbl I think....

sa[NUM_SPRITES][2]
sa[0] = locked
sa[1] = type
0 = empty
1 = block
2 = special

right now selection window only uses the ones marked B to fill swbl array

void set_swbl(void)
{
   int swbn = 0;
   // erase array
   for (int c=0; c<NUM_SPRITES; c++)
   {
      swbl[c][0] = 0;
      swbl[c][1] = 0;
   }
   for (int c=0; c<NUM_SPRITES; c++)
      if ((sa[c][0] == 1) && (sa[c][1] == 1)) // if block and locked
            swbl[swbn++][0] = c;   // put shape # in list and inc counter
   for (int c=0; c<NUM_SPRITES; c++)
      if ((sa[c][0] == 1) && (sa[c][1] == 0)) // if block and unlocked
            swbl[swbn++][0] = c;   // put shape # in list and inc counter

   swnbl = (swbn / 16) + 1;
   if (swnbl_cur == 0) swnbl_cur = swnbl; // initial only
}


I plan to use sa to store flags for each btile....

sa[][0] show in selection window (or maybe later to force order)
sa[][1] flags


#define PM_BTILE_SOLID_PLAY      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENMY      0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM      0b00000000000001000000000000000000
#define PM_BTILE_SOLID_EBUL      0b00000000000010000000000000000000
#define PM_BTILE_SOLID_PBUL      0b00000000000100000000000000000000
#define PM_BTILE_SEMISOLID_PLAY  0b00000000001000000000000000000000
#define PM_BTILE_SEMISOLID_ENMY  0b00000000010000000000000000000000
#define PM_BTILE_SEMISOLID_ITEM  0b00000000100000000000000000000000
#define PM_BTILE_BOMBABLE        0b00000001000000000000000000000000
#define PM_BTILE_BREAKABLE_PBUL  0b00000010000000000000000000000000
#define PM_BTILE_BREAKABLE_EBUL  0b00000100000000000000000000000000
#define PM_BTILE_LADDER_MOVE     0b00001000000000000000000000000000
#define PM_BTILE_ROPE_MOVE       0b00010000000000000000000000000000
#define PM_BTILE_SECRET          0b00100000000000000000000000000000
#define PM_BTILE_SHOW_SELECT_WIN 0b01000000000000000000000000000000



the main function is:

int animation_proc(void)
it calls:
select_bitmap_ans()
select_bitmap_proc()
copy_bitmap_proc()
save_tiles()





I want to make a new edit bitmap attributes....
maybe with a new sa[][] variable....
but the existing one is nicely saved to disk...

I also need a copy function...not only for in the same file, but from file to file....

Also make a function to test spinning tiles and set all the parameters for that...

for now change it so that sa[][1] controls whether or not to show in select window....
later I'll extend it to use an int to control position in that window

its coming along...


this function that I just did works great for setting sa[][1]

now I want to make a new function to set sa[][0] with flags...

have a list of all the flags...


when i save an int to file im only using putc so I only save 8 bits....

im going to try fwrite and fread...it looks like I might come out of the stone age!!!


int arr[3] = {101, 203, 303};

fwrite(arr, sizeof(arr), 1, fp);






change the save method...

old:


   char sprit_filename[20] = "bitmaps/sprit001.pm";
   FILE *filepntr = fopen( sprit_filename,"wb");
   for (int c=0; c<NUM_ANS; c++) // put animation sequences
      for (int y=0; y<20; y++)
      {
         int ho = (zz[y][c] / 256);
         int lo = zz[y][c] - (ho*256);
         fputc(ho, filepntr);
         fputc(lo, filepntr);
      }


   for (int c=0; c<NUM_SPRITES; c++)  // shape attributes sa[512][2]
      for (int y=0; y<2; y++)
         fputc(sa[c][y], filepntr);

   fclose(filepntr);


new write:
   FILE *fp = fopen("bitmaps/sprit001.pm", "wb");
   fwrite(zz, sizeof(zz), 1, fp);
   fwrite(sa, sizeof(sa), 1, fp);
   fclose(fp);

new read:
   FILE *fp = fopen("bitmaps/sprit001.pm", "rb");
   fread(zz, sizeof(zz), 1, fp);
   fread(sa, sizeof(sa), 1, fp);
   fclose(fp);

that is so much simpler....


If I'm planning on doing the same for l[100][100]
I'll need to to the same...
that will come later...

now sa[][1] is not used for showing in the select window...I have a flag for that....

Now I need to work on a better way of setting groups of tile flags



multiple selection could be one thing...



I could have a special list of settings that I apply to what I click on.
each flag could be force on, force off, or ignore
I will call it setting tool....


modes:

0 - change 1 tiles flags at a time
selection can be only one

1 -


I am so close, but I am so tired....

9:52pm 20220404


5:00 am 0405

do I really need single and multiple modes?
multiple mode works good with only one block selected...





now I want a function that marks blocks based on selected flags

each flag can be set, clear or don't care

each block will be marked if they match the criteria

then I want a section that I can use to set blocks
each flag can be marked set, clear or ignore...then I can apply this to selected blocks...


I also want to show the flags for the moused over tile...

all these things could be just colums on the one list of flags...





extend proc_controllers....

make 2 global ints that can be adjusted with arrows in proc control_lead_frames

int pct_x = 0;
int pct_y = 0;

that took minutes to do an will be so goddamn useful in aligning stuff and seeing how it looks...


I have the multiple secletion and mouse selection all lined up and looking good


rethink modes...

- When in multiple select any changes to the multiple selection affect all selected...
this is how it is already

- When only one tile is selected, make a mode that I can copy the flags to any other tile by just clicking b2...

"Copy flags from selected tile to other tiles"
b1 - set selected tile
b2 - copy flags from selected tile to clicked tile

"Change flags of all selected tiles"
b1 - drag and click to select rectangular area
click on the flag toggles to change


................this part is done...done good enough....


now I want to be able to move tiles around
from position to position within one file and from file to file....

master will be just like 32x32 then have a separate file that can only be copied from....



it works!

lest see if I can get one from a long time ago...


pm0_1 has no level editor..took a screenshot of the game, pasted into gimp and cropped to block boundary
exported as bmp.
in pm it came in at 2x size, but when I scaled it down it seemed to work

pm0_2 has level editor, there are 512 bitmaps 16 in a row and only 8 rows show on the screen at once...
4 screens would get them all...do it...


pm1 is very similar to pm0

pm2 has 512 bitmaps in 32x16

pm3 does not allow looking at bitmaps in level editor...only has block editor...

pm4 does the same...

I know how I can force it...I could edit pmhelp to show arbitrary shape, or I could do the same with a level....

anyways, I have some cool old tiles...

what else to do?

show where pasting
basically just show where pointer is in 32x32

this function to copy and move tiles is done and works great...

now what??

I should fix the save and load stuff..
mostly for level, but do it all while I'm at it...

I'll need to make backups of the levels...
and use glt to convert

first modify save...
then run glt
then modify load...


at the start of .pml is

level_header[20]
level_header[3] items
level_header[4] enemies
level_header[5] lifts

read and write mode is r and w

now all the levels are 122k
89 levels = 10.7M
old was 3.7M


modified the read also and it works...until I try to do something with pmsg....

how the hell does that work?

I think pmsg is just pointers....

look into it, this needs to be fixed...

old load:
pmsg[c] = (char*) malloc (strlen(buff)+1);
strcpy(pmsg[c], buff);


old save:
if (item[c][0] == 10) // pmsg
{
   y = 0;
   while (pmsg[c][y] != 0)
   {
      if (pmsg[c][y] == 13) fprintf(filepntr,"%c", 126);
      else fprintf(filepntr,"%c", pmsg[c][y]);
      y++ ;
   }
   fprintf(filepntr,"\n");
}


the reason for malloc was to save memory...
what if I just malloc'd a fixed amount in pmsg only if the corresponding item = 10
or I could extend pmsg to have a second variable for the length...

or I could simply write 500 lengths in the pml file while saving...yes...do this...


I need to save pl then save the string one at a time  if not len=0

I think I got it!!!!


lets go back and do it right...

this is the way....


save:

   // how many pmsg?
   int num_pmsg = 0;
   for (int i=0; i<500; i++)
      if (pmsg[i] != NULL) num_pmsg++;

   // make an array to store data about them
   int pl[num_pmsg][2] = {0};

   // fill the array
   int pl_indx = 0;
   for (int i=0; i<500; i++)
   {
      if (pmsg[i] != NULL)
      {
         pl[pl_indx][0] = i;               // pmsg index
         pl[pl_indx][1] = strlen(pmsg[i]); // length of pmsg
         pl_indx++;
      }
   }

   // write the num of pmsg
   fwrite(&num_pmsg, sizeof(int), 1, fp);

   // write the array
   fwrite(pl, sizeof(pl), 1, fp);

   // write the text of the pmsg's
   for (int c=0; c<num_pmsg; c++)
   {
      int pi = pl[c][0]; // pmsg index
      int ps = pl[c][1]; // pmsg length
      fwrite(pmsg[pi], ps, 1, fp);
   }

load:

   // read the number of pmsg's
   int num_pmsg = 0;
   fread(&num_pmsg, sizeof(num_pmsg), 1, fp);

   // make the array to store data about them
   int pl[num_pmsg][2] = {0};

   // read the array
   fread(pl, sizeof(pl), 1, fp);

   // read the strings
   for (int c=0; c<num_pmsg; c++)
   {
      int pi = pl[c][0]; // pmsg index
      int ps = pl[c][1]; // pmsg length
      pmsg[pi] = (char*) malloc (ps); // allocate
      fread(pmsg[pi], ps, 1, fp);     // read
   }




is there someplace I should be freeing all these??

in zero_level_data()

old
   for (int c=0; c<500; c++)  // items
   {
      if (item[c][0] == 10)
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }


new:
   for (int c=0; c<500; c++)  // items
   {
      if (pmsg[c])
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }


seems to work...

now some of the text is not coming out how I would like...

I used to do something different in linux to eat char 13 or soething like that...



old_save replaces 13 with 126 '~'

   if (item[c][0] == 10) // pmsg
   {
      y = 0;
      while (pmsg[c][y] != 0)
      {
         if (pmsg[c][y] == 13) fprintf(filepntr,"%c", 126);
         else fprintf(filepntr,"%c", pmsg[c][y]);
         y++ ;
      }
      fprintf(filepntr,"\n");


old_load ignores 13

   if (item[c][0] == 10) // get pmsg
   {
     loop = 0;
     ch = fgetc(filepntr);
     while((ch != '\n') && (ch != EOF))
     {
        if (ch != 13) // ignore and don't add if 13 ( needed for linux)
        {
           buff[loop] = ch;
           loop++;
        }
        ch = fgetc(filepntr);
     }
     buff[loop] = 0;
     pmsg[c] = (char*) malloc (strlen(buff)+1);
     strcpy(pmsg[c], buff);



what the hell? what am I going to do?

use glt to see how many I have....


it was a stupid off by one error

when I got the size of the string, I needed to add 1 to include the NULL terminator...

I only has to change one line....

old: pl[pl_indx][1] = strlen(pmsg[i]); // length of pmsg

new: pl[pl_indx][1] = strlen(pmsg[i]) + 1; // length of pmsg (don't forget about the NULL at the end)

mucho goodlier.....


I also want to implement a version for the pml file format.....
when loading level, check for version

keep old versions around so you can load older stuff...

don't even try to load unless you have a handler for that version...

I'm going to call the version I have now 1.0 (once I implement versioning)

The version previous to this will be 0.9

I should go back and see what older levels I have.....

make a search and load function.....

make something to detect...

20220406 12:03PM...push....


20220406 7:20 PM

file stuff is totally done....

removed old....


I should test this stuff in linux...
how do I boot from grub command line
kingston uefi boot to mx1 on mr5

lifts and pmsg seem to look good

linux version has problems with filename seperators in copy bitmap...
the load button works, but the title did not find the separator to remove path...not a big deal
fixed with allegro specific path stuff

the save button really messed up the tiles...all the tiles that were empty...the rest still look good...
did not clear to color...duh...try it now...works great

linux version randomly crashes...


20220407 5:00AM
did some more work on copy bitmap, looks better, added button to load edit_tile_attributes()

make switch and key use proper btiles instead of tiles...
did all in item file, block manip, keys, switch, bombs


10:00AM at work...

when choosing what item to pick up when there are multiple, choose bonus last...
this might be hard...
when choosing pick up an item, if player is already carrying, nothing is done...
I could make this work by:
if player is carrying bonus, and comes in contact with something that is not a bonus
automatically drop the bonus and carry the other item...


old:
// check if player can carry item
if ( (!players[p].carry_item)  // not carrying
  && (item[i][3] < 0)          // item is carryable
  && (players[p].fire) )       // fire pressed

new:

int already_carrying = 0;
if (players[p].carry_item) // already carrying item
{
   already_carrying = 1;
   if ((item[players[p].carry_item][0] == 10) && (item[i][0] != 10)) // carried item is bonus and new item is not bonus
      already_carrying = 0;
}

// check if player can carry item
if ( (!already_carrying)  // not carrying
  && (item[i][3] < 0)     // item is carryable
  && (players[p].fire) )  // fire pressed


what is the next step in l[100][100] stuff???

I'm at the point of doing something huge....

like changing all the values in level blocks...

in glt...

have a list of blocks that we will change

most are empty and have no change

0-31   empty
32-63  semisold
64-95  bombable
96-127 breakable

>127 solid

18 ladder
19 rope


next most common are solid and will get:
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

then semisolid...add to solid
#define PM_BTILE_SEMISOLID_PLAYER  0b00000000001000000000000000000000
#define PM_BTILE_SEMISOLID_ENEMY   0b00000000010000000000000000000000
#define PM_BTILE_SEMISOLID_ITEM    0b00000000100000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

#define PM_BTILE_BOMBABLE          0b00000001000000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000

#define PM_BTILE_BREAKABLE_PBUL    0b00000010000000000000000000000000
#define PM_BTILE_BREAKABLE_EBUL    0b00000100000000000000000000000000
#define PM_BTILE_SOLID_PLAYER      0b00000000000000010000000000000000
#define PM_BTILE_SOLID_ENEMY       0b00000000000000100000000000000000
#define PM_BTILE_SOLID_ITEM        0b00000000000001000000000000000000
#define PM_BTILE_SOLID_PBUL        0b00000000000010000000000000000000
#define PM_BTILE_SOLID_EBUL        0b00000000000100000000000000000000


#define PM_BTILE_LADDER_MOVE       0b00001000000000000000000000000000

#define PM_BTILE_ROPE_MOVE         0b00010000000000000000000000000000



for now just do solid blocks
empty will have no change

backup level folder...

make changes:

      // blocks
      for (y=0; y<100; y++)
         for (z=0; z<100; z++)
         {
            blt[l[y][z]]++; // inc block counter

            if (l[y][z] > 127) // solid block
            {
               l[y][z] |= PM_BTILE_SOLID_PLAYER;
               l[y][z] |= PM_BTILE_SOLID_ENEMY;
               l[y][z] |= PM_BTILE_SOLID_ITEM;
               l[y][z] |= PM_BTILE_SOLID_PBUL;
               l[y][z] |= PM_BTILE_SOLID_EBUL;
            }

         }


start trying to make this work in game....

the biggest thing will be masking the higher bits so I can draw....

then the collison detection...


tiles are 0-1023 or 2^9

l[][] & 0b00000000000000000000000111111111 // keep the lower 9 bits

l[][] & 1023 // keep the lower 9 bits



void init_level_background(void) // fill level_background with blocks and lift lines
{
   //printf("init_level_background\n");
   al_set_target_bitmap(level_background);
   al_clear_to_color(al_map_rgb(0,0,0));
   for (int x=0; x<100; x++)
      for (int y=0; y<100; y++)
      {
         int c = l[x][y] & 1023; <----------------works!!!!
         if (c < NUM_SPRITES)
            al_draw_bitmap(btile[c], x*20, y*20, 0);
      }
   draw_lift_lines();
}



now I am modifying the 4 directional checks.....
as prrof on concept it works, but its about to get a lot more complicated.....

everytime it is called, it now needs to ask who wants to know if I'm solid?

add another int to the parameters...
int type;
1 = player
2 = enemy
3 = item
4 - pbul
5 - ebul


then fix all the places that it is called....done...

bullets do their own collisons
ebullets done....later will need to be breakable here

if (d & PM_BTILE_SOLID_EBUL)  // bullet hit solid or breakable wall
{
   e_bullet_active[b] = 0;        // bullet dies
   if ((d > 95) && (d < 128))     // remove breakable wall
   {
      remove_block(xi, yi);
      draw_lift_lines();
   }
}


lets do breakable now...
add this to glt....

breakable and bombable done...

now what about semisolid
just add the 3 semisolid flags

there is only 2 places where I care if is_up_solid returns 2 and it would be the same if it returned zero....i think

made semi solid work, but just for player now...needs way more testing...

revert level and push...work calls....

2:00PM push

5:00PM

in glt I did ladders too, now everything is done there


make ladders and rope work...done

finish semisolid

the way semisolid works....
there is a custom handler for is_up_solid....
as one on the conditions it checks that semisolid is not set for the blocks it is checking

there is no return value of 2 if semi-solid...


semisolid looks good, but...

bullets do not go through

i should change the glt from:

if ((l[y][z] > 31) && (l[y][z] < 64)) // semi solid
{
   l[y][z] |= PM_BTILE_SOLID_PLAYER;
   l[y][z] |= PM_BTILE_SOLID_ENEMY;
   l[y][z] |= PM_BTILE_SOLID_ITEM;
   l[y][z] |= PM_BTILE_SOLID_PBUL;
   l[y][z] |= PM_BTILE_SOLID_EBUL;
   l[y][z] |= PM_BTILE_SEMISOLID_PLAYER;
   l[y][z] |= PM_BTILE_SEMISOLID_ENEMY;
   l[y][z] |= PM_BTILE_SEMISOLID_ITEM;
}

to:

if ((l[y][z] > 31) && (l[y][z] < 64)) // semi solid
{
   l[y][z] |= PM_BTILE_SOLID_PLAYER;
   l[y][z] |= PM_BTILE_SOLID_ENEMY;
   l[y][z] |= PM_BTILE_SOLID_ITEM;
   l[y][z] |= PM_BTILE_SEMISOLID_PLAYER;
   l[y][z] |= PM_BTILE_SEMISOLID_ENEMY;
   l[y][z] |= PM_BTILE_SEMISOLID_ITEM;
}



that seems to work....


now the big one...change mv's...
or I could make level editor not crash...

it was very easy...whenever I went to draw tile[num] i did tile{num&1023}

now I want to see the flags in a small window...

I just show them under the draw item and it works good...

workflow....

- copy block to draw item
- edit flags
- draw with it
...
profit?

shut it down at 10:00 PM could not keep my eyes open

20220408 5:00AM

What I need to do is do this right...
this flags menu thing needs to be its own official window

its working but could stand to be cleaned up....

push


8:00 AM

I can't believe how good this is working....

still to do....
make select window items apply sa when drawing them
how about when swbl is filled...

for (int c=0; c<NUM_SPRITES; c++)
   if (sa[c][0] & PM_BTILE_SHOW_SELECT_WIN)
      swbl[swbn++][0] |= sa[c][0];   // put shape # in list and inc counter

al_draw_bitmap(btile[swbl[c][0] & 1023], swx1+(c-((c/16)*16) )*20+1, swy1+select_window_block_y+1+14+(c/16*20), 0 );

current:
d = process_select_window(0);
if (d < 999) // block
{
   draw_item_num = d;
   draw_item_type = 1;
}
if (d >= 3000) // pd
{
   draw_item_num = d-3000;
   draw_item_type = 5;
}

999 or 1001 do nothing...
how do I fix this?
now

0-huge == block
< -1000 == pde copy type (add 2000 to get actual pde #)
-1 all other returns (doesnt do anything)

I can get stuff from select window and it seem to work good.

make it so that the select window flag is not shown...
(not that critical, will have no effect on level)

make the block range draw special shapes things work....done

show just tile number in pde block descrption...done


20220408 6:00PM

most of the integration of the new tiles are done...

i need to make mv things work...done...that was easy

bug... drawing tile zero in block draws not empty...fixed.....


keys don't work?? they do with erase all....fixed...

lets test and see what is broken...

keys shapes on key creator...

switches....looks like the 2 tiles that swap are hard coded into the switch item...
color   shape   10   11
purple  841     175  10
blue    809     174   9
green   745     172   7
red     777     713   8

kept that the same...just made some minor changes to the switch code...done...


h block walker...need to make solid...done...



now for block manip

set all to block

if empty no prob
if not then I need to set the appropriate flags...I could use the defaults from sa....
yes...do that...done
that is great.....

to compare to do this:
if ((l[x][y]&1023) == block1)

to set block using default flags, do this:              {
l[x][y] = block2 | sa[block1][0];

when selecting block for bm uses btiles not tiles....maybe even use swbl...only get tiles that are supposed to be blocks....
made a really nice bitmap chooser than uses swbl


I sometimes have trouble tracking down errant flags...
I want a way to detect this.
like maybe an overlay
choose a flag and see if it it set by marking any tile with that flag

or...

how about this...

check every entry in l[][] that does not match the default flags for the specific shape....

mark that tile....

toggle with a key in editor...

global value show_non_default_blocks = 0;


this works great...type sndb and serial key will turn it on....
them red x's show up on non default blocks....


its getting really late...like 11:49

all I can think of to do is make a simple flag viewer when mouse over pde blocks



push....

20220409 7:00AM

make the flag rectangles toggle off, most of the time regular block draw will be fine...done

make a simple and detailed description for view and draw item and pde blocks...done

hide the show select win flag..it is not needed...done

make the tile attribute thingy look better...done
buttons like copy bitmap...done...

block puzzle is broken, look again at what happens in block manip toggle...done

wow... I think it's all done....

I could remove old blocks from tiles.bmp...



rename the copy_tiles thing in the menu...

Block and Default Flag Editor






Commit message:

Tiles used for blocks now have their own file: block_tiles.bmp
There are 1024 tiles in a 32x32 grid, just like the regular tiles.bmp
They are loaded into btiles[1024] just like the other tiles use tiles[1024].
All tiles used to draw blocks now use btiles[] instead of tiles[]

Completely redid the block attribute method.
The old method used the tile number as an indicator of the block properties.
The new method uses bit flags stored in the same int as the tile number

Made some nice graphical tools to manipulate tiles and .bmp file and flags.

Added a new page to the html documentation 'block_flags.html'


12:02 pushed...

This is a huge chapter completed...

I want to make some test levels to show off...

sndb shows in game....fixed

sometimes I have a weird crashing error when save and exit from level editor

why does pmsg view show extra stuff?
'P' in level editor runs void show_all_pmsg(void)

this actually shows pmsg, not item 10

maybe they are not all NULL like they should be...

   for (int i=0; i<500; i++)
   {
      if (pmsg[i] != NULL)
      {
         int len = strlen(pmsg[i]);


lets force it...
trace it through its life

declaration:
char *pmsg[500] = { NULL };
extern char *pmsg[500];

in file

void zero_level_data(void)
{
   for (int c=0; c<500; c++)  // items
   {
      if (pmsg[c])
      {
         free (pmsg[c]);
         pmsg[c] = NULL;
      }
      for (int x=0; x<16; x++) item[c][x] = 0;
      for (int x=0; x<4; x++) itemf[c][x] = al_itofix(0);
   }
   sort_item();


I want to view after loading a file pmsg and item10.

its only this level that I am currently working on that has the problem

more pmsg's are being created than should be

Maybe it's been like this since I changed the file stuff...

how can I fix it?

band aid - find the extra's and kill them
what I should really do is find out why and where the problem is...


// load
int pc = 0;
int i10 = 0;
for (int i=0; i<500; i++)
{
   if (item[i][0] == 10) i10++;
   if (pmsg[i]) pc++;
}
if (i10 != pc) printf("lev:%d npm:%d  pc:%d  i10:%d\n", level_to_load, npm, pc, i10);


// save
// how many pmsg?
int num_pmsg = 0;
for (int i=0; i<500; i++)
   if (pmsg[i] != NULL)
   {
      if (item[i][0] == 10) num_pmsg++; // is there a corresponding item 10?
      else // found a pmsg with no item linked to it...wtf
      {
         printf("while saving level:%d -- found rogue pmsg[%d] with no corresponding item\n", level_to_save, i);
         pmsg[i] = NULL;          // set the pointer to NULL, don't worry about freeing
      }
   }



lev:56 npm:10  pc:10  i10:4
lev:56 npm:10  pc:10  i10:4
while saving level:56 -- found rogue pmsg[0] with no corresponding item
while saving level:56 -- found rogue pmsg[1] with no corresponding item
while saving level:56 -- found rogue pmsg[6] with no corresponding item
while saving level:56 -- found rogue pmsg[7] with no corresponding item
while saving level:56 -- found rogue pmsg[8] with no corresponding item
while saving level:56 -- found rogue pmsg[9] with no corresponding item

problem is fixed with a bandaid.....

I want to save status and select window positions...only move if off screen
also sbf and sndb

what are they?


this is called a lot...



with 1
in set map_var
start of edit_menu
twice when stat and sel winodw become active from menu

with 0
when moving windows
lets make all but map var 0







void check_s_window_pos(int reset_pos)
{
   int swx1 = status_window_x;
   int swy1 = status_window_y;
   int swh = status_window_h;
   int sww = status_window_w;
   int swx2 = swx1 + sww;
   int swy2 = swy1 + swh;
   if ((swx2 > SCREEN_W) || (swx1 < 0)) reset_pos = 1;
   if ((swy2 > SCREEN_H) || (swy1 < 0)) reset_pos = 1;

   swx1 = select_window_x;
   swy1 = select_window_y;
   swh = select_window_h;
   sww = select_window_w;
   swx2 = swx1 + sww;
   swy2 = swy1 + swh;
   if ((swx2 > SCREEN_W) || (swx1 < 0)) reset_pos = 1;
   if ((swy2 > SCREEN_H) || (swy1 < 0)) reset_pos = 1;

   if (reset_pos)
   {
//      status_window_x = SCREEN_W-(sww+10);
//      status_window_y = 10;
//
//      select_window_x = SCREEN_W-(sww+10);
//      select_window_y = status_window_y + status_window_h + 10;


      status_window_x = 10;
      status_window_y = 10;

      select_window_x = SCREEN_W-(sww+10);
      select_window_y = 10;

   }
}
added status_window_x and y to config.
made it so that it will never force...

done...

when drawing a block range, use the flags from the draw item block for all....done....




tested on MX linux, sometimes sigaborts double free detected..traced back to zero level data....



I fucking hate alloacting and freeing memory!!
how much fucking time have I wasted chasing down this shit!!


How can I do it differently?

what is the longest pmsg I have?


use glt....max is 299 from level 1...



what are my options?

worst case, 500 pmsg, 500 char each

250,000 bytes...nothing!!!!
wait.. that is 250,000 per level

100 levels...25M of text

pm.wav takes 30,000,000
tiles takes 1,200,000
l[100][100] takes 40,000

levels are around 120,000 this would increase their size by 200%
unless I just stored what is used...
Am it just trading one problem for another?

OK fuck it
what if I zip the files

just do it......

while doing it coexist with existing...

new var

char pmsgtext[500][500];




I've gone through file

make a copy of levels 90 files 10.5 M

change save routine....

run glt...

      for (int y=0; y<500; y++)
         if (pmsg[y]) strcpy(pmsgtext[y], pmsg[y] ) ;

change load routine....done

change draw routine in z_items...I can see them!!

new size 90 levels 31.8M

changed edit stuff in zmenu, successsdfully changed text, save and it worked.

file, item, menu is done...


editor is done...

editor_zfs does so funky shit saving and loaded selection...
there is a ft_pmsg....
lets just skip zfs for now....


there is not a single trace of pmsg in the fucking codebas anymore!!!! yay

still need to look into zfs ft_pmsg

maybe straighten up the save and load selection stuff....

look like I just need to shadow pmsgtext with ft_pmsgtext....

search for ft_pmsg, removed all traces

there is some weird code when saving ft...


//               while (ft_pmsg[c][y] != (char)NULL)
//               {
//                  if (ft_pmsg[c][y] == 13) fprintf(filepntr,"%c",126);
//                  else fprintf(filepntr,"%c",ft_pmsg[c][y]);
//                  y++ ;
//               }
//               fprintf(filepntr,"\n");

i'm going to leave it as long as I am not fwriting in bimary mode

sel only puts what is used
I can still probably make it work
save the items from 0 to last item
save pmsg from 0 to last item....
it's far to complex for such a minor thing


now how about that zlib level things?

this looks so simple...

fread(level_header, sizeof(level_header), 1, fp);
fread(l,            sizeof(l),            1, fp);
fread(item,         sizeof(item),         1, fp);
fread(Efi,          sizeof(Efi),          1, fp);
fread(Ei,           sizeof(Ei),           1, fp);
fread(lifts,        sizeof(lifts),        1, fp);
fread(lift_steps,   sizeof(lift_steps),   1, fp);
fread(pmsgtext,     sizeof(pmsgtext),     1, fp);


void game_vars_to_state(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(players); memcpy(b+offset, players, size);
   offset += size; size = sizeof(Ei);      memcpy(b+offset, Ei,      size);
   offset += size; size = sizeof(Efi);     memcpy(b+offset, Efi,     size);
   offset += size; size = sizeof(item);    memcpy(b+offset, item,    size);
   offset += size; size = sizeof(itemf);   memcpy(b+offset, itemf,   size);
   offset += size; size = sizeof(lifts);   memcpy(b+offset, lifts,   size);
   offset += size; size = sizeof(l);       memcpy(b+offset, l,       size);
}

void state_to_game_vars(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(players); memcpy(players, b+offset, size); offset += size;
   size = sizeof(Ei);      memcpy(Ei,      b+offset, size); offset += size;
   size = sizeof(Efi);     memcpy(Efi,     b+offset, size); offset += size;
   size = sizeof(item);    memcpy(item,    b+offset, size); offset += size;
   size = sizeof(itemf);   memcpy(itemf,   b+offset, size); offset += size;
   size = sizeof(lifts);   memcpy(lifts,   b+offset, size); offset += size;
   size = sizeof(l);       memcpy(l,       b+offset, size); offset += size;
}



I need to find the actual sizes....

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4000
lift_steps  : 25600
pmsgtext    :250000
-------------------
       total:370880


now I need to make at least to varaibles to store these.

one for the live and one for the extracted...but as soon as I am done with them I can free them...

// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];


#define PML_SIZE 370880
char pml[PML_SIZE];
char pmz[PML_SIZE];

void pml_to_var(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(level_header); memcpy(level_header, b+offset, size); offset += size;
   size = sizeof(l);            memcpy(l,            b+offset, size); offset += size;
   size = sizeof(item);         memcpy(item,         b+offset, size); offset += size;
   size = sizeof(Ei);           memcpy(Ei,           b+offset, size); offset += size;
   size = sizeof(Efi);          memcpy(Efi,          b+offset, size); offset += size;
   size = sizeof(lifts);        memcpy(lifts,        b+offset, size); offset += size;
   size = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, size); offset += size;
   size = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, size); offset += size;
}

void var_to_pml(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(level_header); memcpy(b+offset, level_header, size);
   offset += size; size = sizeof(l);            memcpy(b+offset, l,            size);
   offset += size; size = sizeof(item);         memcpy(b+offset, item,         size);
   offset += size; size = sizeof(Ei);           memcpy(b+offset, Ei,           size);
   offset += size; size = sizeof(Efi);          memcpy(b+offset, Efi,          size);
   offset += size; size = sizeof(lifts);        memcpy(b+offset, lifts,        size);
   offset += size; size = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   size);
   offset += size; size = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     size);
}

ready to test write...back up levels


// decompress client_state_buffer to client_state_dif
uncompress((Bytef*)client_state_dif, sizeof(client_state_dif), (Bytef*)client_state_buffer, sizeof(client_state_buffer));


char dif[STATE_SIZE];
char cmp[STATE_SIZE];

// compress dif to cmp
uLongf destLen= sizeof(cmp);
compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
int cp = destLen;


now 90 files take up 246K, that is less than 1%...omg....can I load?

load:
// read the compressed data
char cmp[PML_SIZE];
fread(cmp, sizeof(cmp), 1, fp);
fclose(fp);

// decompress cmp to pml
char pml[PML_SIZE];
uLongf destLen = sizeof(pml);
uncompress((Bytef*)pml, (uLongf*)&destLen, (Bytef*)cmp, sizeof(cmp));

pml_to_var(pml);

save:
// put variables in pml
char pml[PML_SIZE];
var_to_pml(pml);

// compress pml to cmp
char cmp[PML_SIZE];
uLongf destLen= sizeof(cmp);
compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), 5);
int cmp_size = destLen;

// write cmp to file
FILE *fp = fopen(level_filename,"wb");
fwrite(cmp, cmp_size, 1, fp);
fclose(fp);

total of all 90 levels
size compression level
 233K 9
 238K 8
 249K 7
 251K 6
 268K 5
 289K 4
 400K 3
 418K 2
 576K 1
3180K 0

 251K -1




20220410 8:00 AM

fixed a bug where items would not trigger...

I want to make block manip work with blocks that have flags

so I'm thinking of grabbing them from the actual level rather than the PDE thing
that way they have have all the benefits of flags...
like being able to just turn off a flag

Or I could go all out and make a flag manip item...
or i could extend bm to iunclude flags...
the easiest seems to be to choose the blocks from the level...

how will I do that?


            if (mode == 1) // set all blocks to block 1
            {
               l[x][y] = block1;
               al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
               al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
            }

            if (mode == 2) // set all block2 to block 1
            {
               if (l[x][y] == block2)
               {
                  l[x][y] = block1;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
               }
            }

            if (mode == 3) // toggle block1 and block 2
            {
               if (l[x][y] == block1)
               {
                  l[x][y] = block2;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block2&1023], x*20, y*20, 0 );
               }
               else if (l[x][y] == block2)
               {
                  l[x][y] = block1;
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block1&1023], x*20, y*20, 0 );
               }
            }


/* old way...uses only tile number, not tile and flags


            if (mode == 1) // set all blocks to block 1
            {
               l[x][y] = block1 | sa[block1][0]; // replace block (use default flags)
               al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
               al_draw_bitmap(btile[block1], x*20, y*20, 0 );
            }

            if (mode == 2) // set all block2 to block 1
            {
               if ((l[x][y]&1023) == block2)
               {
                  l[x][y] = block1 | sa[block1][0]; // replace block
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block1], x*20, y*20, 0 );
               }
            }

            if (mode == 3) // toggle block1 and block 2
            {
               if ((l[x][y]&1023) == block1)
               {
                  l[x][y] = block2 | sa[block2][0];
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block2], x*20, y*20, 0 );
               }
               else if ((l[x][y]&1023) == block2)
               {
                  l[x][y] = block1 | sa[block1][0];
                  al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                  al_draw_bitmap(btile[block1], x*20, y*20, 0 );
               }
            }



*/

OK that works....

now make the block selector a little nicer...done

now see what we have broken in all the block manips out there....

can I make the block number show better in slider?



52 good
56 good
58 good
59 good
70 good
71 good
314 has a lot, let try to set them with glt
315 has a lot too..

10 and 11

get tile appply default flags...
done....

how many tiles in all my levels have the PM_BTILE_SHOW_SELECT_WIN set?

I should check...looks like only level 59...

then remove
then make it so PDE does not keep it...


when void set_swbl(void) adds it to swbl, flag is not removed

when int process_select_window returns it, flag is not removed

lets nip in in the bud...

when its added to swbl...done

use glt to remove flag....done


moved set_swbl from being called every frame to start of edit menu..
also should do it when it might change like in set tile attributes...done

blank spaces in select window special items have funny tile..
need to make tile 0 in tiles, actually blank...


does the old animation editor stuff actually save and mess stuff up??



save_tiles()
saves the tiles.bmp
and
FILE *fp = fopen("bitmaps/sprit001.pm", "wb");
fwrite(zz, sizeof(zz), 1, fp);
fwrite(sa, sizeof(sa), 1, fp);
fclose(fp);

I have commented out both places that call this...

I should really diable a lot of this stuff...for safety...

I need to keep animation editor...

and copy bitmap could be nice for editing tiles.bmp

- make animation editor do only that and only save zz
but zz and sa are saved together...

make a save and load sprit functions...done

call load_sprit from load_tiles...done
remove saving sprits from saving tiles...done

there are still only two things that call save_tiles and they are both commented out...

the only thing that calls save_sprit is my new void edit_tile_attributes(void)

after i clean up animation it can call it too...

remove all traces of old attributes editor...
it was called int select_bitmap_proc() and has been moved to old_fnx...

animation_sequence_editor() is the new name...
it will call save sprit

            case 20: animation_sequence_editor(); break;
            case 21: copy_tiles(); break;
            case 22: copy_btiles(); break;
            case 23: edit_btile_attributes(); break;



this is all done...
next I need to make a save button for copy_tiles()...
this is the only things that calls save_tiles()...
done and works great...erased blocks from tiles.bmp..

you know...it would have been better to make a tile copier than works from any file to any file....
then I wouldn't have had to do this twice.....

save and load PDE....done....

int load_PDE()
{
   FILE *fp =fopen("bitmaps/pde.pm","rb");
   if (fp)
   {
      fread(PDEfx, sizeof(PDEfx), 1, fp);
      fread(PDEi,  sizeof(PDEi),  1, fp);
      fread(PDEt,  sizeof(PDEt),  1, fp);
      fclose(fp);
      return 1;
   }
   m_err("Error loading pde.pm");
   return 0;
}

void save_PDE()
{
   FILE *fp =fopen("bitmaps/pde.pm","wb");
   if (fp)
   {
      fwrite(PDEfx, sizeof(PDEfx), 1, fp);
      fwrite(PDEi,  sizeof(PDEi),  1, fp);
      fwrite(PDEt,  sizeof(PDEt),  1, fp);
      fclose(fp);
   }
   else m_err("Error saving pde.pm");
}

block number showing better in sliders for manip, now its just a huge number...done just &1023
manip creator to stay on viewer after create..done for manip dmg and trigger

make copy tiles work from any bitmap file to any other...done...that was easy
it is called copy tiles...
fix menu...done...
add gridlines...done
remove the other 2....done
add option to scale 2nd one...done

now the bitmap stuff is much more streamlined:

case 20: animation_sequence_editor(); break;
case 21: copy_tiles(); break;
case 22: edit_btile_attributes(); break;

save_tiles() is called by nothing...
save_btiles() is called by nothing...
move them both to old fnx

save_sprit() is called by:
edit_btile_attributes()
animation_sequence_editor()




make perl script to automatically iterate all cpp files and generate a list of function prototypes

also for all global variables make a list of what files and functions use them






improve lifts with more modes



what variables do I have?

its a struct...no room for expansion

al_fixed fx;
al_fixed fy;
al_fixed fxinc;
al_fixed fyinc;
int x1;
int y1;
int x2;
int y2;
int width;
int height;
int color;
int current_step;
int num_steps;
int limit_counter;
int limit_type;
char lift_name[40];
x2, y2
hell, even x1, y1
could be repurposed

I don't want to change the size because of netgame...but is that really such big deal?
lets see if I can just ignore the 4 ints, x1, y1, x2, y2...
what does lift move use??

this looks too hard

If I wanted to add something what would it look like?

int flags
int mode
int count
int val1

so 4 more ints?

what is the damage?


40 lifts x 4 ints x 4 bytes = 640 bytes

I would need to increase...

#define STATE_SIZE 104640 to #define STATE_SIZE 105280

this would not change at all....

void game_vars_to_state(char * b)
{
   int size = 0, offset = 0;
   offset += size; size = sizeof(players); memcpy(b+offset, players, size);
   offset += size; size = sizeof(Ei);      memcpy(b+offset, Ei,      size);
   offset += size; size = sizeof(Efi);     memcpy(b+offset, Efi,     size);
   offset += size; size = sizeof(item);    memcpy(b+offset, item,    size);
   offset += size; size = sizeof(itemf);   memcpy(b+offset, itemf,   size);
   offset += size; size = sizeof(lifts);   memcpy(b+offset, lifts,   size);
   offset += size; size = sizeof(l);       memcpy(b+offset, l,       size);
}

void state_to_game_vars(char * b)
{
   int size = 0, offset = 0;
   size = sizeof(players); memcpy(players, b+offset, size); offset += size;
   size = sizeof(Ei);      memcpy(Ei,      b+offset, size); offset += size;
   size = sizeof(Efi);     memcpy(Efi,     b+offset, size); offset += size;
   size = sizeof(item);    memcpy(item,    b+offset, size); offset += size;
   size = sizeof(itemf);   memcpy(itemf,   b+offset, size); offset += size;
   size = sizeof(lifts);   memcpy(lifts,   b+offset, size); offset += size;
   size = sizeof(l);       memcpy(l,       b+offset, size); offset += size;
}


i would need to iterate all the levels and save in the new type...
how the hell will I do that???


shadow the lift struct with something 16 bytes bigger

read into old, copy to new, save as new...



extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];
extern int num_lifts;
extern char lift_step_type_name[10][10];
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int val;
   int x;
   int y;
};

extern struct lift2 lifts2[NUM_LIFTS];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;

   int flags;
   int mode;
   int user1;
   int user2;

   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};




// copy lifts to temp structure to resize

for (int l=0; l<num_lifts; l++)
{
   lifts2[l].fx =            lifts[l].fx;
   lifts2[l].fy =            lifts[l].fy;
   lifts2[l].x1 =            lifts[l].x1;
   lifts2[l].y1 =            lifts[l].y1;
   lifts2[l].x2 =            lifts[l].x2;
   lifts2[l].y2 =            lifts[l].y2;
   lifts2[l].width =         lifts[l].width;
   lifts2[l].height =        lifts[l].height;
   lifts2[l].color =         lifts[l].color;
   lifts2[l].current_step =  lifts[l].current_step;
   lifts2[l].num_steps =     lifts[l].num_steps;
   lifts2[l].limit_counter = lifts[l].limit_counter;
   lifts2[l].limit_type =    lifts[l].limit_type;
   lifts2[l].flags = 0;
   lifts2[l].mode = 0;
   lifts2[l].val1 = 0;
   lifts2[l].val2 = 0;
   strcpy(lifts2[l].lift_name, lifts[l].lift_name);
}



void pml_to_var(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b)
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


I need to resize...


#define PML_SIZE 370880
#define PML_SIZE2 371520












------------------------------------------------------------------------------------------------------------------
step 0 -

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4000
lift_steps  : 25600
pmsgtext    :250000
       total:370880


level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2      :  4640
lift_steps  : 25600
pmsgtext    :250000
       total:371520


#define PML_SIZE 370880
#define PML_SIZE2 371520

------------------------------------------------------------------------------------------------------------------
step 1 - backup levels
------------------------------------------------------------------------------------------------------------------
step 2 - original load  new save
------------------------------------------------------------------------------------------------------------------

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // save
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


char cmp[PML_SIZE];
char pml[PML_SIZE];


struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

loads fine...
------------------------------------------------------------------------------------------------------------------
step 3
modify save and run glt


void var_to_pml(char * b) // save
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);       memcpy(b+offset, lifts2,       sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


int save_level(int level_to_save)
{
   level_check();

   for (int i=0; i<20; i++) level_header[i] = 0;

   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   level_header[5] = num_lifts;  // num of lifts

   make_filename(level_to_save);   // update filename

   // put variables in pml
   char pml[PML_SIZE2];
   var_to_pml(pml);

   // compress pml to cmp
   char cmp[PML_SIZE2];
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), -1);
   int cmp_size = destLen;

   // write cmp to file
   FILE *fp = fopen(level_filename,"wb");
   fwrite(cmp, cmp_size, 1, fp);
   fclose(fp);
   return 0;
}


      // copy lifts to temp structure to resize
      for (int l=0; l<num_lifts; l++)
      {
         lifts2[l].fx =            lifts[l].fx;
         lifts2[l].fy =            lifts[l].fy;
         lifts2[l].x1 =            lifts[l].x1;
         lifts2[l].y1 =            lifts[l].y1;
         lifts2[l].x2 =            lifts[l].x2;
         lifts2[l].y2 =            lifts[l].y2;
         lifts2[l].width =         lifts[l].width;
         lifts2[l].height =        lifts[l].height;
         lifts2[l].flags = 0;
         lifts2[l].mode = 0;
         lifts2[l].val1 = 0;
         lifts2[l].val2 = 0;
         lifts2[l].color =         lifts[l].color;
         lifts2[l].current_step =  lifts[l].current_step;
         lifts2[l].num_steps =     lifts[l].num_steps;
         lifts2[l].limit_counter = lifts[l].limit_counter;
         lifts2[l].limit_type =    lifts[l].limit_type;
         strcpy(lifts2[l].lift_name, lifts[l].lift_name);
      }



------------------------------------------------------------------------------------------------------------------
step 4


modify load

keep this the same

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}


PML_SIZE2 in 2 places
int load_level(int level_to_load, int display)
{
      // read the compressed data
      char cmp[PML_SIZE2];
      fread(cmp, sizeof(cmp), 1, fp);


modify lift to add 4 ints
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};


success!!!!!!!!
------------------------------------------------------------------------------------------------------------------

clean up the code...

increase the state size and test netplay.....
#define STATE_SIZE 104640 to #define STATE_SIZE 105280
netplay works fine....

made a function to display this:

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4640
lift_steps  : 25600
pmsgtext    :250000
------------:------
total       :371520

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  4640
l        : 40000
---------:------
total    :105280

now that I have 4 more variables in the lift struct, what am I going to do with them?

mode

0 = normal
the last lift step moves to the first at the speed defined in the first step....

1 = instant restart
after the last step, instantly warps to the first step

2 = prox reset
if the player is away from the lift (prox) for a certain time, the lift will reset






1 = one shot
moves to the last step and stays there, forever (this could be done with a prox=0 step)


4 = lift only moves when player is on it... this is probably better as a step...


I want to have some more step types defined also...
step type grow or shrink the lift size...

step type, wait for trigger!!!

   int type;
   int val;
   int x;
   int y;

           case 1: // move
               set_lift_xyinc(d, step);
            break;
            case 2: // wait time
               lifts[d].limit_type = 5; // wait time
               lifts[d].limit_counter = lift_steps[d][step].val; // limit
               lifts[d].fxinc= 0; // no xinc
               lifts[d].fyinc= 0; // no yinc
            break;
            case 3: // wait prox
               lifts[d].limit_type = 6; // wait prox
               lifts[d].limit_counter = lift_steps[d][step].val; // limit
               lifts[d].fxinc= 0; // no xinc
               lifts[d].fyinc= 0; // no yinc
            break;
            case 4: // move to step 0
               step = lifts[d].current_step = 0; // set step 0
               set_lift_xyinc(d, step);


type 5 - resize
val - time to complete
x - new width
y - new height

type 6 - wait for trigger
val - trigger event number


type 7 - move to pos only if player is on lift
val - speed
x
y

type 8 - reset if player off for more than time
val - speed
x
y




20220411 5:00 AM commit

load and save PDE now use binary mode
made a new universal copy tile routine than work from any file to any file
made a new tile select routine for block manip to choose from level block to include flags
cleaned up old bitmap and tile routine
increased lift struct size by 16 bytes for new features


OK lets get into lifts....

This could take some doing, but everything should be nicer when done

I've been thinking about increasing the size of lift steps also

It would be nice to have 2-4 more ints there

All I would need to increase is the level save size, just like I just did for main lift...

40 lifts x 40 steps x 4 ints x 4 bytes = 25600 bytes per level

the good thing is that they are not synced with netgame, they are static...



in lift editor fixed lift help button

added a button lift mode...

modes are
0 continuous loop
1 instant loop

that was very easy to implement...


next...


prox reset...works but lifts prox rect blinks in step 0.....


commit and get ready for work...

7:15 AM






8:50 PM

I thinks I know why it blinks...
it keeps resetting to step zero every frame...

how can I make it not?


set the time out to 80 when resetting?

detect when already in step 0 and stay there?

this type of lift really only makes sense if the first step is a prox anyway...



I had some new ideas today...

use raising damage feild attached to lift like a mario rising lava stage


make walls that chase you down a corridor

make player run a gauntlet of raising and lowering platforms



make the lifts possible to be invisible and have no effect on players, enemies, items, bullets, etc, just like fields


then I could have a moving damage damage field, or trigger!!!


20220412 5:00AM


I'm going to hold off on adding more ints to lift steps for now..
I'm not sure what I would do with them.

I can do a lot with that..

implement new step...change size


type 5 - warp to step 0
val - time to complete
x - new width
y - new height

type 6 - resize
val - time to complete
x - new width
y - new height

type 7 - wait for trigger
val - trigger event number


type 8 - move to pos only if player is on lift
val - speed
x
y


what do I have already


step type 1 - move
val = speed scaled by 10
x new position
y



----------------------

redoing the insert step stuff with new buttons...

it all sems to work but no new step are actually added....


make 3 new sliders for step 6


I think that this is too much for the limited variable that I have...

If I want to manipulate width and height at the same time as x and y I will need 4 more fixed in the main and 2 more for each step...


I could do my own kind of fixed by multipying a shifting a regular int...no


------------------------------------------------------------------------------------------------------------------
step 0 -

original:



Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4640
lift_steps  : 25600
pmsgtext    :250000
------------:------
total       :371520

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  4640
l        : 40000
---------:------
total    :105280



extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];
struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int val;
   int x;
   int y;
};


extern struct lift2 lifts2[NUM_LIFTS];
extern struct lift_step2 lift_steps2[NUM_LIFTS][40];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;

   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step2
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};


Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5280
lift_steps2  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts2    :  5280
l        : 40000
---------:------
total    :105920

#define PML_SIZE  371520
#define PML_SIZE2 384960

#define STATE_SIZE  105280
#define STATE_SIZE2 105920

------------------------------------------------------------------------------------------------------------------
step 1 - backup levels
------------------------------------------------------------------------------------------------------------------
step 2 - original load  new save
------------------------------------------------------------------------------------------------------------------

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps2);   memcpy(b+offset, lift_steps2,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}

char cmp[PML_SIZE];
char pml[PML_SIZE];


loads fine...
------------------------------------------------------------------------------------------------------------------
step 3
modify save and run glt

modify save and run glt

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps2);   memcpy(b+offset, lift_steps2,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}




int save_level(int level_to_save)
{
   level_check();

   for (int i=0; i<20; i++) level_header[i] = 0;

   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   level_header[5] = num_lifts;  // num of lifts

   make_filename(level_to_save);   // update filename

   // put variables in pml
   char pml[PML_SIZE2];
   var_to_pml(pml);

   // compress pml to cmp
   char cmp[PML_SIZE2];
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), -1);
   int cmp_size = destLen;

   // write cmp to file
   FILE *fp = fopen(level_filename,"wb");
   fwrite(cmp, cmp_size, 1, fp);
   fclose(fp);
   return 0;
}

// copy lifts to temp structure to resize
for (int l=0; l<num_lifts; l++)
{
   lifts2[l].fx =            lifts[l].fx;
   lifts2[l].fy =            lifts[l].fy;
   lifts2[l].fxinc =         lifts[l].fxinc;
   lifts2[l].fyinc =         lifts[l].fyinc;

   lifts2[l].fw =            al_itofix(lifts[l].width);
   lifts2[l].fh =            al_itofix(lifts[l].height);
   lifts2[l].fwinc =         al_itofix(0);
   lifts2[l].fhinc =         al_itofix(0);

   lifts2[l].x1 =            lifts[l].x1;
   lifts2[l].y1 =            lifts[l].y1;
   lifts2[l].x2 =            lifts[l].x2;
   lifts2[l].y2 =            lifts[l].y2;

   lifts2[l].width =         lifts[l].width;
   lifts2[l].height =        lifts[l].height;
   lifts2[l].flags = 0;
   lifts2[l].mode = 0;
   lifts2[l].val1 = 0;
   lifts2[l].val2 = 0;
   lifts2[l].color =         lifts[l].color;
   lifts2[l].current_step =  lifts[l].current_step;
   lifts2[l].num_steps =     lifts[l].num_steps;
   lifts2[l].limit_counter = lifts[l].limit_counter;
   lifts2[l].limit_type =    lifts[l].limit_type;
   strcpy(lifts2[l].lift_name, lifts[l].lift_name);

   for (int s=0; s<40; s++)
   {
      lift_steps2[l][s].type = lift_steps[l][s].type;
      lift_steps2[l][s].x    = lift_steps[l][s].x;
      lift_steps2[l][s].y    = lift_steps[l][s].y;
      lift_steps2[l][s].w    = 0;
      lift_steps2[l][s].h    = 0;
      lift_steps2[l][s].val  = lift_steps[l][s].val;

   }
}




------------------------------------------------------------------------------------------------------------------
step 4

modify load

keep this the same

void pml_to_var(char * b) // load
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}


PML_SIZE2 in 2 places
int load_level(int level_to_load, int display)
{
      // read the compressed data
      char cmp[PML_SIZE2];
      fread(cmp, sizeof(cmp), 1, fp);


modify lift and lift_steps

extern struct lift2 lifts2[NUM_LIFTS];
extern struct lift_step2 lift_steps2[NUM_LIFTS][40];
struct lift2
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;

   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step2
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};


success!!!!!!!!
------------------------------------------------------------------------------------------------------------------

clean up the code...


Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105920



-------------------------------------------------------
-------------------------------------------------------


OK, now that that is all done...lets make resize lift work

I think one of the problems is that we are storing height and width with a resolution of 20 pixels


how much of a major rewrite would it take to make it by the pixel...with a hard minimum?


lets do that first...could be huge....


use glt to change all height and width to *20.......

      // make height and width 0-1999 from 0-99
      for (int l=0; l<num_lifts; l++)
      {
         lifts[l].width *= 20;
         lifts[l].height *= 20;
      }
backup levels and do it...

most places use x2 snd y2, only move seems to set them...changed there...and lift lines...

sliders....done...


did a search for width and fixed mostly everything...broke all of the rotated text stuff though...commented out for now..


moving lift step on map needs fixing...done...

if item has focus cant go back to lift viewer...done....



creating new lift...default size...done

icon at the top of lift viewer...

do I even need draw lift mp? what uses it???

nothing in lifts anymore...


can player ride lifts??? yes...


the resize finally work, but it's rough.....

the lift line do not take into account the resize...
could call init_level_background() after resize, or I could just draw lines every frame...

also when resizing and player riding, they are pushed to one side....

that's it for today...

10:05 PM push

20220413 4:30 AM

lets figure out the deathmatch bullets thing...

it looks very straight forward...
void proc_pbullet_collision(int p, int b)
{
   players[p].LIFE -= al_itofix(deathmatch_pbullets_damage);

looks like I can't send a negative number with my packet routines...offset by 1000...fixed...


riding lift when width exanding pushed player to the right...width contracting is fine....
reset incs when move is done...fixed...


moving lift lines to draw each time works but does not look good....
what would be better is if the original one was smart enough to take into account the size changes....



nothing keeps track of initial lift size once it changes....
I should make step 0 keep that info....

should I just make move and resize the same type?
I can always set one or the other to do nothing....


I think I need to, because step 0 needs both...

w and h will no longer be set in lift, they will be set in step0


extend type 1
make the button a 4 way split...time(speed) get pos, w, h,


remove step type 6 resize...type 1 extended to do that also....


looks like its working good...

I need to do somthing about val...

for resize it makes sense, it is the total time
I will leave it like this

How can I set it like I used to with speed?

pick a speed value and it will calculate the time...

in the slider stuff, have another button called speed.
fill it with ditance/time
if you change it, the time button will change also...


how to calculate distance from this move step to the last move step
I have step and I know that it's a move step so I have x and y
search back from that step to find next move step.
if I go back from step 0 choose the move step

I have a function to do that now!!!!

2 buttons:

time
display: the actual val
range 1-1000
sets speed like this:
calc distance / time



speed
display =
calc distance / time

set from 1-50
sets time like this:
calc distance / speed

what if distance == 0?
speed will not be valid and will show 0...
time will still be valid...

for now I have just allowed the time button, but displayed the calculated speed

lift does not show up anymore in lift viewer, only on step 0
fixed....draw lift lines was resetting he lifts...

I want to make player move detection with lifts use the mv functions so that lifts can move faster and still detect collisions...

when creating lift make a sensible default size and copy it to each new step....done...


I have messed up all my lift speeds here...

I want to go back to the old way...



void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   lifts[d].limit_type = 7;   // move step countdown limit type 7

   // get the integer x and y distances between current pos and next step
   int xln = lifts[d].x1 - lift_steps[d][step].x;
   int yln = lifts[d].y1 - lift_steps[d][step].y;
   if ((xln == 0) && (yln == 0)) // no move needed
   {
      lifts[d].limit_counter = 1;
      lifts[d].fxinc = al_itofix(0);
      lifts[d].fyinc = al_itofix(0);
   }
   else
   {
      al_fixed xlen = al_itofix(xln);   // get the x distance
      al_fixed ylen = al_itofix(yln);   // get the y distance

      al_fixed hy_dist = al_fixhypot(xlen, ylen);     // hypotenuse distance
      al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;  // speed is stored scaled by 10

      al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
      al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
      al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc

      if (abs(xlen) > abs(ylen))  // xlen is longer so use this to set limit counter
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(xlen, xinc))); // steps = distance / increment

      if (abs(xlen) <= abs(ylen)) // ylen is longer or they are equal
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(ylen, yinc))); // steps = distance / increment

      lifts[d].fxinc = -xinc;
      lifts[d].fyinc = -yinc;
   }
}

this test proved I was doing an unecessary calcultion to get time, when in reality what I called scaler was time
I am going to keep the original method but simplify the code...

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   lifts[d].limit_type = 7;   // move step countdown limit type 7

   // get the integer x and y distances between current pos and next step
   int xln = lifts[d].x1 - lift_steps[d][step].x;
   int yln = lifts[d].y1 - lift_steps[d][step].y;
   if ((xln == 0) && (yln == 0)) // no move needed
   {
      lifts[d].limit_counter = 1;
      lifts[d].fxinc = al_itofix(0);
      lifts[d].fyinc = al_itofix(0);
   }
   else
   {
      al_fixed xlen = al_itofix(xln);   // get the x distance
      al_fixed ylen = al_itofix(yln);   // get the y distance

      al_fixed hy_dist = al_fixhypot(xlen, ylen);     // hypotenuse distance
      al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;  // speed is stored scaled by 10

      al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
      al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
      al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc

      if (abs(xlen) > abs(ylen))  // xlen is longer so use this to set limit counter
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(xlen, xinc))); // steps = distance / increment

      if (abs(xlen) <= abs(ylen)) // ylen is longer or they are equal
         lifts[d].limit_counter = al_fixtoi( abs( al_fixdiv(ylen, yinc))); // steps = distance / increment


      int lc = lifts[d].limit_counter;
      int sc = al_fixtoi(scaler);


      if (lc == sc) printf("sc:%4d lc:%4d\n", sc, lc);
      else          printf("sc:%4d lc:%4d  <----------\n", sc, lc);

      lifts[d].fxinc = -xinc;
      lifts[d].fyinc = -yinc;
   }
}



this is the final version:

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)


   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);   // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);   // y dif

   al_fixed hy_dist = al_fixhypot(xlen, ylen);                       // hypotenuse is distance
   al_fixed speed = al_itofix(lift_steps[d][step].val) / 10;         // speed is stored scaled by 10
   al_fixed move_time = al_fixdiv(hy_dist, speed);                   // get time (time = distance / speed)

   lifts[d].fxinc = al_fixdiv(xlen, move_time);                      // set xinc
   lifts[d].fyinc = al_fixdiv(ylen, move_time);                      // set yinc

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}

this was the old one that just used val as a straight timer
void set_lift_xyinc(int d, int step)
{
   al_fixed move_time = al_itofix(lift_steps[d][step].val*20);      // get move time

   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);  // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);  // y dif
   lifts[d].fxinc = al_fixdiv(xlen, move_time);                     // set xinc
   lifts[d].fyinc = al_fixdiv(ylen, move_time);                     // set yinc

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}





there...now that is reverted

do I need to worry about zero moves, will there be a div by zero error?



Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\pm>pm

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
xlen:-100.00 ylen:-640.00 hy:647.77 mt:66.10 fxinc:-1.51 fyinc:-9.68
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-80.00 ylen:400.00 hy:407.92 mt:370.84 fxinc:-0.22 fyinc:1.08
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97
xlen:0.00 ylen:0.00 hy:0.00 mt:0.00 fxinc:32768.00 fyinc:32768.00
xlen:20.00 ylen:120.00 hy:121.66 mt:15.21 fxinc:1.32 fyinc:7.89
xlen:-20.00 ylen:-120.00 hy:121.66 mt:60.83 fxinc:-0.33 fyinc:-1.97

C:\pm>
divide by zero did not seem to cause issues, but I made a check to avoid it anyway.

while doing that I stubled across a method to use val as straight time, if there is not x y move
then there can be a stationary resize that does not happen immediately...

if there is no xy move and no resize, the step will do nothing while the timer runs...

void set_lift_xyinc(int d, int step)
{
   //  used when switching to a new move step;
   //  sets xinc, yinc and num of frames for mode 7 (move)

   int val = lift_steps[d][step].val;

   al_fixed move_time = al_itofix(0);

   al_fixed xlen = al_itofix(lift_steps[d][step].x - lifts[d].x1);   // x dif
   al_fixed ylen = al_itofix(lift_steps[d][step].y - lifts[d].y1);   // y dif
   al_fixed hy_dist = al_fixhypot(xlen, ylen);                       // hypotenuse is distance

   if (hy_dist < al_itofix(1))        // no move
   {
      move_time = al_itofix(val);     // use val as straight timer
      lifts[d].fxinc = al_itofix(0);  // no xinc
      lifts[d].fyinc = al_itofix(0);  // no yinc
   }
   else // get time based on speed and distance
   {
      al_fixed speed = al_itofix(val) / 10;         // stored speed scaled by 10
      move_time = al_fixdiv(hy_dist, speed);        // get time (time = distance / speed)
      lifts[d].fxinc = al_fixdiv(xlen, move_time);  // set xinc
      lifts[d].fyinc = al_fixdiv(ylen, move_time);  // set yinc
   }

//   printf("xlen:%4d ylen:%4d hy:%4d mt:%4d fxinc:%4d fyinc:%4d\n",
  //         al_fixtoi(xlen), al_fixtoi(ylen), al_fixtoi(hy_dist), al_fixtoi(move_time), al_fixtoi(lifts[d].fxinc), al_fixtoi(lifts[d].fyinc));

   printf("xlen:%3.2f ylen:%3.2f hy:%3.2f mt:%3.2f fxinc:%3.2f fyinc:%3.2f\n",
           al_fixtof(xlen), al_fixtof(ylen), al_fixtof(hy_dist), al_fixtof(move_time), al_fixtof(lifts[d].fxinc), al_fixtof(lifts[d].fyinc));

   al_fixed wd = al_itofix(lift_steps[d][step].w - lifts[d].width);  // width dif
   al_fixed hd = al_itofix(lift_steps[d][step].h - lifts[d].height); // height dif
   lifts[d].fwinc = al_fixdiv(wd, move_time);                        // set winc
   lifts[d].fhinc = al_fixdiv(hd, move_time);                        // set hinc

   lifts[d].limit_counter = al_fixtoi(move_time);
   lifts[d].limit_type = 7;
}

Now I need to change the slider button back...done...

On the pop up menu for a step, add set wh to previous step..done.


I don't think I need a separate resize type step, I can do it all with type 1

I want to add a special end type step...instant jump to step 0 or move to step 0
It can be the same step, none of the variables are used..
make
val = 0 loop (old normal deafault)
val = 1 warp
val = 2 fade out??

then I don't really need to do that with mode....


I want to make a mode that if not in step 0 it will reset after player leaves.....

I want to make a move step that does not advance if player is not riding
It can also be used in conjuntion with the mode that resets after time...

then I can do things like falling platforms

extend step type 4...call it end

make type do 1 of 3 things...

0 move to step 0
1 warp to step 0
2 stay here forever

done....



bug, fix stuff in zfs for coying lift...since last variable increase....

from pm.h
extern int ft_lift[NUM_LIFTS][4];
extern int ft_ls[NUM_LIFTS][40][4];

increase steps to 6
extern int ft_lift[NUM_LIFTS][4];
extern int ft_ls[NUM_LIFTS][40][6];


what about lifts?

this is all I currently store:
ft_lift[c][0] = lifts[b].width;
ft_lift[c][1] = lifts[b].height;
ft_lift[c][2] = lifts[b].color;
ft_lift[c][3] = lifts[b].num_steps;

new list:
ft_lift[c][0] = lifts[b].mode
ft_lift[c][1] = lifts[b].flags;
ft_lift[c][2] = lifts[b].color;
ft_lift[c][3] = lifts[b].num_steps;
ft_lift[c][4] = lifts[b].val1;
ft_lift[c][5] = lifts[b].val2;

that should be all done....

test??...good.

bug: blocks don't show in zfs paste selection...done
bug: lifts show weird in xfs paste selection...done

bug: zfs copying start makes multiples with same start index...same as everywhere else...
how many times is level check called
once in load and once in save...all good here


--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
it blows my mind how many different time in code I draw lift...
I should have only one!!
how many times do I mess with rtext...it should be a flag
--------------------------------------------------------------------------------------



I already have mode 2 for reset when player leaves...but no settings
and I need to remove or diasble mode 1 beacuse steps now do it....

mode 2 is gone
now mode 1 is called prox run and reset

hard coded time of 80...
make a way to set it....
show it....
make visually, like shrink the lift or show progress bar

make counter not run when already reset, like in step 0...

should I start this type of lift with a prox?
make the mode 1 stuff only apply for type 1 steps....
did all that...

now to make them look nice, in mode 1 the first step should be a wait prox.
it is not required, but without it the lift will constantly reset to step 0 when the timer runs out.
also with this method, the rest timer will not run for other prox or wait steps
prox steps can't be used alone
but if you insert a wait then a prox in the middle....
player rides lift to the wait spot, then jumps off and runs away before the wait timer expires
when the wait timer expires, the prox step will sit there and wait and not reset....


bug, inserting steps erases w and h..fixed


--- make the original width and height sliders affect the current step, then they can be removed from the actual step button
 what is the current button is not a move step...hide them...
 actually I chose to just show them disabled..


 bug...make sure that current step in lift viewer is valid...mouse sometimes sets it to a negative value...done

bug cant set last two steps to be current step...
no matter how many steps in lift
highlight works fine...

there was a dumb redraw lift_viewer that was drawing the button off by one....

then there was the button for end step probably eats the mouse click....yes
finally this bug is closed....



make current step more obvious... like color it red or something....

step colors right now:

regular   = 3 med blue
highlight = 13 light blue
current   = 14 dark blue

where are they set?

void draw_steps(int step_ty, int lift, int current_step, int highlight_step)
{
   int color = 3;
   if (step == current_step) color = 13;
   if (step == highlight_step) color = 12;

changed it to 15 for regular, 10 for current and a yellow outline for highlight....i like it

now I need to change the text of the move step to be like the others....

then the buttons width and height that only apply to current step
I was thinking of making that more obvious
like put it next to the steps
have something similar for other types of steps


what about the buttons having columns?
first one is the step #
second step type
those can be rather narrow, then the rest of the space can be adjusters, etc

---------------------------------------------------------------------
make one and one only draw_lift
---------------------------------------------------------------------

// this is it....the one base function that draws a lift
void draw_lift(int l, int x1, int y1, int x2, int y2)
{
   int color = lifts[l].color;
   int a;

   // faded outer shell
   for (a=0; a<10; a++)
     al_draw_rounded_rectangle(x1+a, y1+a, x2-a, y2-a, 4, 4, palette_color[color + ((9 - a)*16)], 2 );

   // solid core
   al_draw_filled_rectangle(x1+a, y1+a, x2-a, y2-a, palette_color[color] );

   // name
    al_draw_textf(font, palette_color[color+160], (x1+x2)/2, (y1+y2)/2 - 3, ALLEGRO_ALIGN_CENTRE, "step:%d val:%2d", lifts[l].current_step, lifts[l].val1);
}



removed this from void highlight_current_lift(int l)

   // draw lift
   int a;
   for (a=0; a<10; a++)
      al_draw_rectangle((x1+a)*db/20, (y1+a)*db/20, (x2-a)*db/20, (y2-a)*db/20, palette_color[color+ (9-a)*16], 1 );
   al_draw_filled_rectangle((x1+a)*db/20, (y1+a)*db/20, (x2-a)*db/20, (y2-a)*db/20, palette_color[color] );

//   if ((lifts[l].width == 1) && (lifts[l].height > 1)) // rotate lift name for vertical lifts
//      rtextout_centre(NULL, lifts[l].lift_name, ((x1+x2)/2)*db/20, ((y1+y2)/2)*db/20, color+160, (float)db/20, 64, 1);
//   else

      rtextout_centre(NULL, lifts[l].lift_name, ((x1+x2)/2)*db/20, ((y1+y2)/2)*db/20, color+160, (float)db/20, 0, 1);



places I have used it:
-------------------------
draw_lifts()
int lift_editor(int lift)
void draw_fsel(void)


places I have checked:
-----------------------
e_lifts
z_lifts

places I have left...
the text editor ?? in menu

void draw_item_info(int x, int y, int color, int type, int num)
{
   int a, b;
   switch (type)
   {
      case 1:
         al_draw_bitmap(btile[num&1023], x, y, 0);
         al_draw_textf(font, palette_color[color], x+22, y+2, 0, "Block #%d",num&1023);
         al_draw_textf(font, palette_color[color], x+22, y+12, 0, "%s", get_text_description_of_block_based_on_flags(num) );
      break;
      case 2:
         draw_item_shape(num, x, y);
         a = item[num][0]; // type
         al_draw_textf(font, palette_color[color], x+22, y+2, 0, "%s", item_name[a]);
         al_draw_textf(font, palette_color[color], x+22, y+12, 0, "%d of %d", 1+num - item_first_num[a],item_num_of_type[a]);
      break;
      case 3:
         draw_enemy_shape(num, x, y);
         a = Ei[num][0]; // type
         al_draw_textf(font, palette_color[color], x+22, y+2, 0, "%s", enemy_name[a]);
         al_draw_textf(font, palette_color[color], x+22, y+12, 0, "%d of %d", 1+num - e_first_num[a],e_num_of_type[a]);
      break;
      case 4:
      {
         int col = lifts[num].color;
         int width = lifts[num].width;
         if (width > 140) width = 140;
         for (a=0; a<10; a++)
            al_draw_rectangle(x+a, y+a, x+(width)-1-a, y+19-a, palette_color[col+((9-a)*16)], 1 );

//         if ((lifts[num].width == 1) && (lifts[num].height > 1)) // rotate lift name for vertical lifts
  //          rtextout_centre(NULL, lifts[num].lift_name, x+(width*10), y, color+160, 1, 64, 1 );
    //     else
            al_draw_text(font, palette_color[col+160], x+(width/2), y+6, ALLEGRO_ALIGN_CENTER, lifts[num].lift_name);
      }
      break;
      case 5:
         a = PDEi[num][1]; // bmp or ans
         if (a < NUM_SPRITES) b = a; // bmp
         if (a > 999) b = zz[5][a-1000]; // ans
         al_draw_bitmap(tile[b], x, y, 0);
         a = Ei[num][0]; // type
         al_draw_text(font, palette_color[color], x+22, y+2, 0, "Special Item");
         al_draw_textf(font, palette_color[color], x+22, y+12, 0, "%s", PDEt[num][1]);
      break;
   }










-----------------------------------------

20220415 3:48AM


I have a block of uninterrupted time.
I am going to try to finish polishing up lift viewer
Then I am going to implement more of my lift improvements...

To start with...

finish list of steps with header...

why does the highlight and mouse_pointer and chosen current step not line up since I added header row?

when I draw steps, i use -1 for the header row

I pass ysb to draw_steps

I draw the frame at y1 = ysb

the buttons start at ya (ysb+fs) // frame size = 14

I draw the row header at ya + (a*bts) a = 0;

i draw step button 0 at  ya + (a*bts) a = 1;


so back in lift viewer I calculate the mouse highlight step with:

if ((mouse_x > xa + 10) && (mouse_x < xb - 10))         // mouse on step buttons
{
   int step0_y_offset = ysb + 14 + bts;
   int step = (mouse_y step0_y_offset) / bts;           // calculate step that mouse is on
   if ((step >= 0) && (step < lifts[lift].num_steps))   // is step valid



this works...i have a few tweaks...

step -1 draws....

because -1 marks a not valid highlight selection....fixed to -99

lower the bottom of the inside of frame by 2 pix...done
make the highlight not spill outside the button so much...done

that looks great..

now finish the row header...done
looks great

fix names of sliders to remove step# done...

move all lift related buttons and slider numbers to 500-599

buttons:500-549

   if (bn == 500) // lift mode
   if (bn == 501)
   if (bn == 502)
   if (bn == 503) sprintf(smsg, "Parameters");    // show row header

504   29 lift name

505   74 end step...



sliders:550-599

550   if (bn == 72) sprintf(smsg, "Timer:%-3d",lift_steps[type][num].val);
551   if (bn == 73) sprintf(smsg, "Distance:%-3d",lift_steps[type][num].val);
552   if (bn == 105) sprintf(smsg, "Speed:%d", lift_steps[type][num].val); // lift step resize time
553   if (bn == 106) sprintf(smsg, "Width:%d", lift_steps[type][num].w); // lift step resize time
554   if (bn == 107) sprintf(smsg, "Height:%d", lift_steps[type][num].h); // lift step resize time
done

fix name edit location and draw mode...done

now can I finally move on to making new stuff?

6:00AM

I just looked back in the notes for other things I wanted to add.


- option to make the lift invisible (probably use a flag)
- option to make the lift affect things differently
- player, enemies, items
- maybe even direction to (like an option to make the lift only raise the player, not push sideways or down)



- better indication of when it will disappear...did a nicer progress bar...good for now

- set the time the player can be away before reset in mode 1
val1 runs the counter
val2 sets the counter
make a slider...all done


bug --- when in mode 1, when moving to original step 0, step is actually 0 and the reset away timer does not activate
right now it looks for step>0...how about step != 1

does this break the shit where step 1 should be prox?
now step 1 while moving does not reset...

I should just ignore that and let the timer reset..that works...
I just need a way to hide the reset indicator when sittin at step 0 not moved..done



- new step wait on external trigger
type 5 - wait trig
x,y,w,h - not used
val - trigger event

lifts[lift].limit_type = 5; // wait trigger
lifts[lift].limit_counter;  // event number

case 5: // trigger wait
   if (pm_event[lifts[l].limit_counter]) next_step = 1;
   pm_event[lifts[l].limit_counter] = 0; // clear the trigger
break;

case 5: // wait trig
   lifts[l].limit_type = 5; // wait trig
   lifts[l].limit_counter = lift_steps[l][step].val;
break;



      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Time", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0, 100, 2);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Prox", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0, 80, 3);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Wait For Trig", c1, c2, 1)) quit = construct_lift_step(lift, step, 0, 0, 0, 0,  0, 5);
      jh++;
      if (draw_and_process_button(txc, stys+(jh*12), "Done", c1, c2, 1)) quit = 99;


   if (bn == 502)
   {
      if (num == -1) sprintf(smsg, "Type");  // show row header
      if (num == 1)  sprintf(smsg, "Move and Resize");
      if (num == 2)  sprintf(smsg, "Wait for Timer");
      if (num == 3)  sprintf(smsg, "Wait for Player");
      if (num == 4)  sprintf(smsg, "End Step");
      if (num == 5)  sprintf(smsg, "Wait for Trigger");
   }


added slider 556 for event trigger

added to list of steps and step details

holy shit it works!!! that was so easy to do..

rather than manually setting event, how do I do it in other cases?...


   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 320,  num, type, obt, 0, 13, 15, 15, 1,0,0,0); a+=2; // set trigger
      if (bn == 320)
      {

         int i = get_trigger_item("Select A Trigger To Link To", 2, item[num][0], num );
         if (i > -1)
         {
            int ev = get_unused_pm_event();
            item[num][1] = ev;

            if (item[num][0] == 16) // block manip
            {
               if (item[num][3] == 3) // mode 3 - toggle blocks
               {
                  item[i][11] = 0;
                  item[i][12] = 0;
                  item[i][13] = ev;  // needs a toggle trigger
                  item[i][14] = 0;
               }
               else
               {
                  item[i][11] = ev;  // regular trigger
                  item[i][12] = 0;
                  item[i][13] = 0;
                  item[i][14] = 0;
               }
            }

            if (item[num][0] == 17) // block damage
            {
               if (item[num][11] == 1) // mode 1 - toggle damage
               {
                  item[i][11] = 0;
                  item[i][12] = 0;
                  item[i][13] = ev;  // needs a toggle trigger
                  item[i][14] = 0;
               }
               else
               {
                  item[i][11] = ev;  // regular trigger
                  item[i][12] = 0;
                  item[i][13] = 0;
                  item[i][14] = 0;
               }
            }


         }
         Redraw = 1;
      }


make my own button



when I call button i pass bn, lift, step

button calls them num and type then passes them to:
fill_smsg_button(bn, obt, type, num);


then I call
int i = get_trigger_item("Select A Trigger To Link To", 4, type, num );

int get_trigger_item(const char *txt, int obj_type, int sub_type, int num )

so num = step and st=lift

this is so confusing!!!

num should always be the index to the obj(item, enemy, lift)...
the second number can be whatever else...
num should alway come right after the button num...


the whole trigger lift thing works great...
by default, if event trigger is zero it is skipped??
I think all trigger item set 0 every frame.....

it looks like it is one pixel bigger when waiting for trigger??
fixed....

so all the trigger stuff working great....

- option to make the lift invisible (probably use a flag)
- option to make the lift affect things differently
- player, enemies, items
- maybe even direction to (like an option to make the lift only raise the player, not push sideways or down)

implement some flags...

#define PM_LIFT_NO_DRAW          0b00000001
#define PM_LIFT_SOLID_PLAYERS    0b00000010
#define PM_LIFT_SOLID_ENEMY      0b00000100
#define PM_LIFT_SOLID_ITEM       0b00001000


make items that follow lift also able to take the exact size of the lift




make a level about running down a hall way and getting smashed by lifts from above


bug with triggers....

if the lift is not in the right step to detect the trigger, it will wait until it is...
I want to erase unused triggers from other steps


at the end of move lift,
cycle step and clear mentioned events...done

make pop up menu for new steps, one step bigger...done


this is so awesome!....make new levels


20220415 10:00 AM push


Redid much of the lifts code, increased size of lifts and lift steps
Implemented many new features for lifts, like resizing, triggers, reset when player not riding
Many improvements to the lift viewer in level editor

make lift steps that can turn on and off the solid effects, change color, etc

change color step!!



make it so that level editor remembers where you were...
like level, viewer and obj type
save it in config file
how about like a bookmark in level editor?
B to load and SHIFT B to set...

int bookmark_level = 0;
int bookmark_obj = 0;
int bookmark_num = 0;

extern int bookmark_level;
extern int bookmark_obj;
extern int bookmark_num;

added to save and load config




where am I going to put this?


in obt_viewer and lift viewer for the save...

load in edit menu..



   if (level_editor_running)
   {
      if (key[ALLEGRO_KEY_B])
      {
         while (key[ALLEGRO_KEY_B]) proc_controllers();


         if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT]))
         {
            printf("save bookmark\n");

            bookmark_level = last_level_loaded;
            bookmark_level = last_level_loaded;



            save_config();
         }
         else
         {
            printf("load bookmark\n");

         }
      }
   }


start with lift...
added to lift viewer and it works...


      if (key[ALLEGRO_KEY_B])
      {
         while (key[ALLEGRO_KEY_B]) proc_controllers();
         if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT]))
         {
            printf("save bookmark\n");

            bookmark_level = last_level_loaded;
            bookmark_obj = 4;
            bookmark_num = lift;
            save_config();
         }
         else
         {
            printf("load bookmark\n");
            if ((bookmark_level == last_level_loaded) && (bookmark_obj == 4) && (bookmark_num != lift))
            {
               if (bookmark_num < num_lifts) lift = bookmark_num;
            }

         }
      }

now edit menu:
if (key[ALLEGRO_KEY_B])
{
   while (key[ALLEGRO_KEY_B]) proc_controllers();
   printf("load bookmark\n");
   if (bookmark_level == last_level_loaded)
   {
      if ((bookmark_obj == 2) && (item[bookmark_num]))       object_viewer(2, bookmark_num);
      if ((bookmark_obj == 3) && (Ei[bookmark_num]))         object_viewer(3, bookmark_num);
      if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) object_viewer(4, bookmark_num);
   }
}
works...

now obj viewer
if (key[ALLEGRO_KEY_B])
{
   while (key[ALLEGRO_KEY_B]) proc_controllers();
   if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT]))
   {
      printf("save bookmark\n");
      bookmark_level = last_level_loaded;
      bookmark_obj = obt;
      bookmark_num = num;
      save_config();
   }
   else
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
          if ((bookmark_obj == 2) && (item[bookmark_num]))
          {
             obt = 2;
             num = bookmark_num;
          }
          if ((bookmark_obj == 3) && (Ei[bookmark_num]))
          {
             obt = 3;
             num = bookmark_num;
          }
          if ((bookmark_obj == 4) && (bookmark_num < num_lifts))
          {
             obt = 4;
             num = bookmark_num;
          }
      }
   }
}
works

the only thing that doesn't work yet is lift_viewer to 2 or 3
if (key[ALLEGRO_KEY_B])
{
   while (key[ALLEGRO_KEY_B]) proc_controllers();
   if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT]))
   {
      printf("save bookmark\n");

      bookmark_level = last_level_loaded;
      bookmark_obj = 4;
      bookmark_num = lift;
      save_config();
   }
   else
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
         if ((bookmark_obj == 2) && (item[bookmark_num]))
         {
            ret = 2000 + bookmark_num;
            quit = 1;
         }
         if ((bookmark_obj == 3) && (Ei[bookmark_num]))
         {
            ret = 1000 + bookmark_num;
            quit = 1;
         }
         if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) lift = bookmark_num;
      }
   }
}
now it does...

to use:

Save Bookmark of current viewer object
when in any viewer, item, enemy, lift
SHIFT B to save

Load bookmark

from any viewer or edit menu
B to load...


now to set up auto load....


change color step!!

flags
1 line in draw:
if (!(lifts[l].flags & PM_LIFT_NO_DRAW))

make a button to toggle it...

while we are at it make buttons to toggle all flags...

hide works good...hide lift lines too....done
maybe later make it its own toggle


now see if I can patch in solids

old:
   if (lift_check)
      for (int d=0; d<num_lifts; d++)
         if (solid_x > lifts[d].x1-18)
            if (solid_x < lifts[d].x2-2)
               if (solid_y > lifts[d].y1 - 25)
                  if (solid_y < lifts[d].y1 - 10)
                      return d+32;


new:
   if (lift_check)
      for (int d=0; d<num_lifts; d++)
         if ( ((type == 1) && (lifts[d].flags & PM_LIFT_SOLID_PLAYER)) ||
              ((type == 2) && (lifts[d].flags & PM_LIFT_SOLID_ENEMY )) ||
              ((type == 3) && (lifts[d].flags & PM_LIFT_SOLID_ITEM  )) )
            if (solid_x > lifts[d].x1-18)
               if (solid_x < lifts[d].x2-2)
                  if (solid_y > lifts[d].y1 - 25)
                     if (solid_y < lifts[d].y1 - 10)
                         return d+32;


that was easy...

now can I set these flags for each step??
or I can have base flags, and steps can change them
I would need a special step to do this...
if steps change the flags in lift, there will be no way to go back to the original
unless I do what I do for x, y, w, h in step 0...

can I also encode flags in move steps? what about color? I only need 4 bits for color...



I just broke all existing lifts...
by default flags are all zero and none are solid

what if I swap it around so zero is solid and 1 is passthrough?

Or I could just glt it and change all existing....done

now make it so that newly created one have those flags...done....

push

20220415 4:44 PM

damage range potential improvements
make the player damage the amount and the retrigger time..
time 1 would be every frame, etc...

I really think I should encode the flags in every move step
I could easily put 4 bits of color and flags in step type...


how many bit should I reserve for step type?
5-6 for 32-64

color needs 4 bits for 16 colors

i currently use 4 bits for flags..

I have lots left over...

lowest 5 for step type
next 4 for color_name
then remaining for flags




when I do these with a move step, do they take effect at the end of the step
or the start....I think the end...
when I insert a step in between 2 others what step I copy?

right click on step and choose copy from previous, copy from next.

then alter what I want...

make some funtions to extract what I need from step and put it in lift vars


lift_step[l][s].type & 31 -- step type

flags should be obvious like all other flags

color should be the highest 4 bits...
shift 28 to get it...

how do I start implementing this?

lets just do color...

add color button to step type 1


to start with add & 31 to all type checks...done for all of e_lifts and z_lifts

next I should use glt to put color in all step type 1 ....

how?

take color and shift it 28 bits...
combine with type...



int temp = color << 28



lift_step[l][s].type |= (color << 28)

color = lift_step[l][s].type >> 28;


this works:
if ((lift_steps[lift][step].type & 31) == 1)

this does not:
if (lift_steps[lift][step].type & 31 == 1)


this is how you set color:
first you have to clear those 4 bits
lift_steps[num][type].type &= 0b00001111111111111111111111111111; // clear old color

then shift the 4 bits into place
int cf = color << 28;

lift_steps[num][type].type |= cf; // lift color


this is how you have to extract color:
col = (lift_steps[l][0].type >> 28) & 15;
you cannot just do the shift because sign bits are inserted instead of zero's


then I can put some flags in there too...

first of all make the buttons to toggle flags

the rest of the lift stuff should work, no matter how the extra flags are set...

I should make the flags from the step, line up with the main lift flags...
to make it easier to copy across...

hell I could make flags and color do that... then all I would have to do is copy the flags

across when a new move step happens...
i could make the flags also do stuff when in wait type steps...why does it have to only be move steps?

re-arranged flags

#define PM_LIFT_COLOR_BITS       0b11110000000000000000000000000000
#define PM_LIFT_NO_DRAW          0b00001000000000000000000000000000
#define PM_LIFT_SOLID_PLAYER     0b00000100000000000000000000000000
#define PM_LIFT_SOLID_ENEMY      0b00000010000000000000000000000000
#define PM_LIFT_SOLID_ITEM       0b00000001000000000000000000000000

re-do glt and put color and default flags in ALL steps, not just move steps...

restore levels...
iterate all valid lifts and steps
mask off everthing except lowest 5 bits

add color...
add default solid flags



20220418 5:00 AM
all my colors are gone

went to a prev version of levels...

got the color back....
have not erased from main lift..

now make copy from steps happen...

lifts[lift].flags = lift_steps[lift][step].type; // get all the flags from the step type

done in:
void set_lift_to_step(int lift, int step)
and in move lifts when setting a new step


now make color come from this place:
flags upper 4 bits
I think it mostly does..its read from the step in draw lift lines...


in draw_lift and draw_lifts:

old:   int col = lifts[l].color;
new:   int col = (lifts[l].flags >> 28) & 15;

in set xyinc, removed  done when changing any step...



ok we are moving along here...
- all steps have color and flags embedded in type....
- they are copied to main lift flags for every step...
- lifts[].color is not used anymore...color is embedded in flags

now I need add color and solid flags to move step buttons...


added 510-513...


fixed the goddam button and slider bullshit calling order for all lift stuff...
call it in this order... lift, step....

button bn, num, type, obt
slider bn num, type, obt

all must be called in e_lifts.cpp


colsel 8 uses l, s


slider...done
550
551
552
553
554
556

button...done
505
510
511
512
513
520

use sl...fix...

500
504
use l only...good


new lift defaults
color and solids



all steps need flags buttons...done

need a way to show current step color....


make list of step buttons, not the place to edit, just show

x, y, w, h if applicable

color

flags??




bug player can't drop item on lift...it falls through....





make two versions of construct_lift_step



sets all parameters:
int construct_lift_step(int l, int s, int type, int x, int y, int w, int h, int val)


copies from previous step:
int construct_lift_step(int lift, int step, int type);
if new step is a move step, get xywh fwom previous move step
always get flags from prev step even if not move step

push
20220418 7:41 AM


how about if contruct lift step is passed a type < 16, then assume you want the rest copied from a previuos step...
no end step??
default speed = 80??



make list of step buttons, not the place to edit, just show

make type much shorter

1 move
235 wait
4 end


I want to make button capable of left justified text...

q4 for slider4 makes the fading in or out...


if going to use q5 for button centering.
0 default..centered
1 left justified..done..



I think I have this stuff pretty much done...
I should do some tests and see if everything works...

How to see hidden lifts in level editor...use color 0

color for step 0 does not show...instead color of loop to zero shows...

lift steps are kind of non-intuitive...

the place where I show them is where they will end up.. the place they come from is alway the lift before

when you are in a current move step, you are always behind where it shows in level editor...
maybe in level editor I should also show the prevous step with an an arrow on the line....


If I set step 0 to be the same as end step, lift lines and color do what I expect...
step 0 does not matter...only step end...
test by setting step 0.....does not line up...

lift lines are set by only looking for move steps, they should look at all...no..just no...

keep end step the same color as first and alll will be good.


now I want to try making my smash lifts shows warning color change...

looks good...

push for lunch...12:00


I would like to be able to hide the timer counter...
three options: hide, number, progress bar

the same with the lift mode reset....






bug - cant's detect lifts from object viewer map mode...fixed

bug - copy and paste lifts in zfs...done
pastes lift but no steps...fixed

bug - lifts has color 0 when editing text...fixed


add lift resize to map move options....


make a level with a long wide rising floor.







I want to make my button stuff simpler?, easier?
integrate fill smsg into button routine
check for mouse press at start
do one pass through...if or switch case  for each button number..
set the text there
process click there
at the end draw the common text...
i can do them one by one...removing the fill smsg entry...
done...now it is just one big monlithic function with a section for each button number
there you set how it displays and what happens when it is pressed.
in one place, instead of two...this should make it easier instead of scrolling up and down for pages
to work with buttons...


push

20220419 7:20 AM

make an option to hide lift lines. per step or for entire lift
per lift...just another flag...done



make some buttons to apply to all lift steps...
like right click on a step and get:
-apply size to all steps
-apply flags to all steps
-apply color to all steps...etc
all these are done from step 0....

in lift viewer make up and down arrow move current step....done

make a step or mode that is frozen or not based on a trigger....



working on map move to resize lift step..got too tired
8:43 PM

5:46 AM got the map resize thing to work just like I wanted...


what if I force end step to have same color as step 0?
same draw and line mode too, why would I ever want them to differ?
no time is ever spent in last mode, unless it freezes there...
in that case I might want something different...
leave it the way it is for now...


I want some sort of checkpoint system...

I juts made a long complicated level and I did not consider that if the player died he could not continue from start..


I could make multiple starts, each with a number...

I could make it so the last touched start is the one that you respawn at...per player or for all players?
maybe both

----------------------------
normal:
only one start
----------------------------

--------------------------------
all players common:
have a flag, current spawn point
if set to 1 then all players use this..

when any player touches it, that becomes the new current spawn point
there can only be one active at any time
----------------------------------

------------------------------------
each player has their own current spawn point
saved in player struct

each start will need an index
-------------------------------------------

whatever plan i use I want it to take all uses into account
the most complicated would be multi player where each player has their own spawn point..
I don't know how I would do teams...so for now I would just split them based on odd/even player number


----------------------------------------
team spawn:
item[][5] - team spawn
0 = off
1 = for odd players
2 = for even players
-----------------------------------------


----------------------------------------
common spawn:
item[][6] - common spawn
0 = off
1 = on

if on, then of all spawn points only one can be currently active
item[][8] - current active spawn point

if off, then each player keeps track of index of their own current spawn point





-----------------------

would it not be easier for player to keep track of that in all cases?
how hard is is to add a variable to player struct that is synced?

call it spawn_point_index

most of the time it will be zero, and link to spawn index 0..

when starting a level, if there is only one start, players have that set..

if there are multiple starts, and the starts are marked as team, then players will get corresponding starts...

as the level is played, if a player touches a start, their spawn point index will change

if the spawn point is marked team, then player much match team for it to be updated

otherwise all players can touch any spawn...

to make this work...

add spawn_point_index to player struct...
and make sure that does not break anything....

then starts need to be modified:

7 = index
----------------------------------------
team spawn:
item[][8] - team spawn
0 = off
1 = for odd players
2 = for even players
-----------------------------------------




20220420 9:20

before:

Variables used for netgame state exchange

players  :  1440
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105920

added 'int spawn_point_index;' to 'player' struct

Variables used for netgame state exchange

players  :  1472
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :105952

32 bits larger

//#define STATE_SIZE 105920
#define STATE_SIZE 105952



void set_player_start_pos(int p)

called from load_level for all 8 players
called when player becomes active...
called after death

single player no teams...
p0 gets index 0 set in player struct at level load..


modify set_player_start_pos(int p)

set_player_start_pos(int p, int cont)

if (cont == 0) set to initials
like load level and player comes active

cont == 1; // is for respawning



void set_player_start_pos(int p, int cont)
{
   if (cont == 0) // players initial entry
   {
      players[p].spawn_point_index = 0;
   }


   if (cont == 1) // players re spawn
   {
      for (int i=0; i<500; i++)
         if ((item[i][0] == 5) && (item[i][7] == players[p].spawn_point_index))
         {
            players[p].PX = itemf[i][0];
            players[p].PY = itemf[i][1];

         }
   }


now make some code for collision with start...


void proc_start_collision(int p, int i)
{
   players[p].spawn_point_index = item[i][7];
}


this works great!

I want to see a change in the start that is active
this could be a good opportunity to make some new tiles

how about when ever player collision with lift, mark it and unmark all others...
11 still
21 scroll
void proc_start_collision(int p, int i)
{
   players[p].spawn_point_index = item[i][7]; // set new spawn point

   // mark this one as active and all others as not
   for (int ii=0; ii<500; ii++)
      if (item[ii][0] == 5)
      {
         if (item[ii][7] == item[i][7]) item[ii][1] = 1021;
         else item[ii][1] = 1011;
      }
}

all this works great for single player, but not so good more multi..

any player can trigger new starts..








I want to add the ability to trigger with events. so the player does not have to actually touch the start..




I want to be able to draw a lift with blocks....

Make archwagon able to turn around before hole, not jump...









starts and modes...


team mode vs single player

with single player, all players have the same start


maybe a bunch of modes...

0 = normal default regular...exactly one start and everyone uses it the same way
- 1 start

1 = team
- 2 starts (0 and 1)
- even/odd player number split

2 = checkpoint common
- 2 or more starts
- all players use current start
- any player can set any checkpoint

3 = checkpoint individual
- 2 or more starts
- each player can set their own checkpoint
- all players start at checkpoint zero


this will all be set in start block with index zero..

what variable do I have to play with:

6-13

item[][6] - mode
item[][7] - index

made a button...

this all works exactly like I thought it would...

how can I show this for individual?  don't for now...



New write up for starts...

Mode:Default
- there is only one start with start index 0
- all players uses this start

Team Start
- 2 start blocks with index's 0 and 1
- even numbered players use start 0
- odd numbered players use start 1

Checkpoint Common
- 2 or more starts with indexes 0,1,2 etc...
- all players initially start at start 0
- when any start is touched by any player...
- that start becomes the new spawn point for all players


Checkpoint Common
- 2 or more starts with indexes 0,1,2 etc...
- all players initially start at start 0
- when a start is touched by a player...
- that start becomes the new spawn point for only that player



in help...I need to distinguish between tiles and btiles...

        if (strncmp(msg, "<s", 2) == 0) // <sxxx> show shape left just)
        if (strncmp(msg, "<ms", 2) == 0) // <msxxxxxxx....> show 20 shapes (left just)

        if (strncmp(msg, "<ac", 3) == 0) // <acxxx> show animation sequence (centered)
        if (strncmp(msg, "<a", 2) == 0) // <axx> show animation sequence (left just)


help has been fixed...made a few new tags...

            if (strncmp(msg, "<ab", 3) == 0) // <axx> show animation sequence (left just) // for block tiles instead of tiles
            else if (strncmp(msg, "<a", 2) == 0) // <axx> show animation sequence (left just)

            if (strncmp(msg, "<sb", 3) == 0) // <sxxx> show shape left just) // for block tiles instead of tiles
            else if (strncmp(msg, "<s", 2) == 0)   // <sxxx> show shape left just)

also in help, fixed the weird allignent issue on the first and last sections that use title and spinning mdw
also in help, completely updated the last section (credits)


now what?
the start improvements are completely done....


what about lifts?
- different drawing methods (blocks) other primitives...
- is that all?

bug---when adding steps in a loop it shows 2 ends...fixed.....



would it be so hard for zoom full screen to be able to paste only flags?

im thinking like a single block type of thing
why think small...

add a filter, block flags..

when on it acts just like blocks


when b abd bf are both on: same as b on now

when b abd bf are both off: same as b off now

when only blocks are on or only flags are on..same as now...

difference is in paste:

if only B then use default flags and ignore existing flags

if only F then ignore shape and just apply flags..


so the only difference would be in the pasting of blocks only...




OK do I want to redo 12 buttons in zfs?


yes I do...

how hard would it be to send a pointer to an int for buttons?
I would have to redo so many things....
every mention of button would need to be redone.
why?
so that I could get the button to manipulate the variable directly...
very useful for toggles....
in all the cases where it is not used send a pointer to a dummy variable...

or...

copy_blocks = button(intin intinint copy_blocks)

BUG - even when flags are off rectangle still show under draw item check boxes...

now that I redid the menu on zfs lets implement the button flags...

looks like it is working for me...

only works in block fill...
must have block filter off and flag filter on
gets flags from draw item, ignores tile, applies to all in range...


      if (draw_item_type == 1) // don't even show these 3 buttons unless...
      {
         if (mdw_button(x3, yfb+a*bts, x4, yfb+(a+1)*bts-2, 610, 0,  0, 0, 0,  9, 15, 0, 1,0,0,0)) // block fill
         {
            for (int x=stx; x<sux; x++)
               for (int y=sty; y<suy; y++)
               {
                  if ((copy_flags) && (copy_blocks))  l[x][y] = draw_item_num;
                  if ((copy_flags) && (!copy_blocks))
                  {
                     int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
                     l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
                     l[x][y] |= flags;                                // merge
                  }
               }
         }






this might be a huge project, but I want to make the randomize stuff work...

if I don't patch it into zfs, it will be something very similar

- make a selction on the map
- from that selection
- narrow it down to a certain type of enemy

I want to be able to do a discontinous selection...
I might need to have a list that I can fill by just rectangle selecting or clicking on individual enemies..

then in that list I can do things...

workflow:
- from obj selection choose cannon
- fill the list by rect selecting or clicking to toggle
- remove and reorder
when list is good
- randomize, increment on selected variables..


cannon will have x, y origin, speed, bullet speed, bullet retrigger, seek count, extra hits to kill

actions

min, max randomize
min max increment/decrement

special for x and y pos
set a box.
randomize in box
evenly space in x axis
evenly space in y axis


what does my list look like?

enemy and item can share?

obj_list[100][2]

obj_lift[][0] = type (0 empty, 1 enemy, 2 item)
obj_lift[][1] = number of item or enemy





I want to start building this:


I like building things like this!

group_edit

make selection buttons
all toggles
one for each enemy and item



I really want to make button toggles so I can do it in one line
send a pointer to the int and text true and text false


make a new type of button that does just that...


int mdw_button( int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )
void mdw_slider(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )
void mdw_colsel(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7 )



int mdw_toggle( int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7, int &var, int & flags, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1)



int mdw_toggle(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1);


int mdw_togglf(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, int flags, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_color0, int frame_color1);



// here it is...one line
mdw_toggle(x1, yfb+a*bts, x2, yfb+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, copy_blocks, "OFF", "ON", 15, 15, 15+64, 9); // block filter


try it out with int from an array
key...
mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, item[num][12], "Erase All Blocks In Range ", "Erase Only Matching Blocks", 15, 15, 4, 4); a++; // range type
works...

it makes the call more complicated...
from:
mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 48, num, type, obt, 0,  4, 15,  0, 1,0,0,0); a++; // range type
to:
mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, item[num][12], "Erase All Blocks In Range ", "Erase Only Matching Blocks", 15, 15, 4, 4); a++; // range type

but....
-I don't need custom button code for each type
-I can change colors of text and frame without custom code



try out togglef for trigger draw...

old:

if (FLAGS & PM_ITEM_TRIGGER_DRAW_ON)
{
   int col = item[num][2];
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 201,  num, type, obt, 0, col, 15, 15, 1,0,0,0); a++; // Draw on/off
   mdw_colsel(xa, ty+a*bts, xb, ty+(a+1)*bts-2,  6,   num, type, obt, 0,  0,   0,  0, 0,0,0,0); a++; // color select
}
else
{
   mdw_button(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 201,  num, type, obt, 0, 15+96, 15+96, 15, 1,0,0,0); a++; // Draw on/off
}
a++;

new:
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0,item[num][3], PM_ITEM_TRIGGER_DRAW_ON, "Draw Trigger Field:OFF           ","Draw Trigger Field:ON            ", 15+96, 15, 15+96, item[num][2]); a++; // Draw on/off
if (FLAGS & PM_ITEM_TRIGGER_DRAW_ON)
{
   mdw_colsel(xa, ty+a*bts, xb, ty+(a+1)*bts-2,  6,   num, type, obt, 0,  0,   0,  0, 0,0,0,0); a++; // color select
}
a++;

OK...it works....

this could simplify some stuff...

old:
if (FLAGS & PM_ITEM_TRIGGER_PLAYER) { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 202, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 202, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_ENEMY)  { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 203, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 203, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_ITEM)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 204, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 204, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_PBUL)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 205, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 205, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }
if (FLAGS & PM_ITEM_TRIGGER_EBUL)   { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 206, num, type, obt, 0, 14,     15,  0, 1,0,0,0); a++; }
else                                { mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 206, num, type, obt, 0, 14+d, 15+d,  0, 1,0,0,0); a++; }


new:
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_PLAYER, "Triggered by Players:OFF         ","Triggered by Players:ON          ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_ENEMY,  "Triggered by Enemies:OFF         ","Triggered by Enemies:ON          ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_ITEM,   "Triggered by Items:OFF           ","Triggered by Items:ON            ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_PBUL,   "Triggered by Player's Bullets:OFF","Triggered by Player's Bullets:ON ", 15+d, 15, 14+d, 14); a++;
mdw_togglf(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000,0,0,0, 0,0,0,0,1,0,0,0, item[num][3], PM_ITEM_TRIGGER_EBUL,   "Triggered by Enemy's Bullets:OFF ","Triggered by Enemy's Bullets:ON  ", 15+d, 15, 14+d, 14); a++;

also removed:

   if (bn == 201) // Item Trigger Draw Type
   {
      if (item[num][3] & PM_ITEM_TRIGGER_DRAW_ON) sprintf(smsg,"Draw Trigger Field:ON            ");
      else                                        sprintf(smsg,"Draw Trigger Field:OFF           ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_DRAW_ON;
   }
   if (bn == 202)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_PLAYER) sprintf(smsg, "Triggered by Players:ON          ");
      else                                       sprintf(smsg, "Triggered by Players:OFF         ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_PLAYER;
   }
   if (bn == 203)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_ENEMY)  sprintf(smsg, "Triggered by Enemies:ON          ");
      else                                       sprintf(smsg, "Triggered by Enemies:OFF         ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_ENEMY;
   }
   if (bn == 204)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_ITEM)   sprintf(smsg, "Triggered by Items:ON            ");
      else                                       sprintf(smsg, "Triggered by Items:OFF           ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_ITEM;
   }
   if (bn == 205)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_PBUL)   sprintf(smsg, "Triggered by Player's Bullets:ON ");
      else                                       sprintf(smsg, "Triggered by Player's Bullets:OFF");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_PBUL;
   }
   if (bn == 206)
   {
      if (item[num][3] & PM_ITEM_TRIGGER_EBUL)   sprintf(smsg, "Triggered by Enemy's Bullets:ON  ");
      else                                       sprintf(smsg, "Triggered by Enemy's Bullets:OFF ");
      if (press) item[num][3] ^= PM_ITEM_TRIGGER_EBUL;
   }


yes...this is nice...
lets move on....

I want to be able to select any combination of enemy and items type...
where will I store that?

int obf_filter[2][20] = {0};

obf_filter[1][num] = item types
obf_filter[2][num] = enemy types


1 door
2 bonus
3 exit
4 key
5 start

mdw_toggle(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, obj_filter[2][1], "Door:ON ", "Door:OFF", 15+64, 15, 15, 4); a++;



I have all the selection filters done...

now make it so that obj in the filter are marked on screen...done
now only filtered obj can be added to the list...done



now lets work on the list....

when adding, don't allow duplicates....done

show the list better...did bitmaps...more later

if mouse on map item that is in list, flash that item in the list
and vice versa


how am I going to mark things on the map?
- things that can get added to list (lt blue)
- things already added to list (red)
- mouse pointer (white)

if (++highlight_counter > 16) highlight_counter = 1;
if ((highlight_counter > 0)  && (highlight_counter < 5)) title_obj(obt, type, num, legend_line, 10);
if ((highlight_counter > 4)  && (highlight_counter < 9)) title_obj(obt, type, num, legend_line, 14);
if ((highlight_counter > 8)  && (highlight_counter < 13)) title_obj(obt, type, num, legend_line, 15);
if ((highlight_counter > 12) && (highlight_counter < 17)) title_obj(obt, type, num, legend_line, 11);

now back to making the list look better....

detect if mouse is on the list and what list item

should I do that at the same time as draw??

frame list after drawn, because then you know ho long it will be...done

move list off the map...done
add legend line...done
when mouse is on list item, mark as highlighted...done

problem with highlight showing when we have co-located objects on map...fixed....

now what?

I need a way to remove things from the list...done
draw rect around highlighted item in list...done
remove with SHIFT mouse_b1...works
and maybe re-order...done with mouse drag move

and when a filter is de-selected, remove that object type from list...done...

bug..can't add enemies to list...fixed...


OK... now I can add to list, delete, filter, rearrange....

what is next?

now based on what is in the list, show some options, if applicable to things in the list....
nice! I just came up with that on the spur of the moment...

everything can do randomize x y pos, but for some it makes little sense...


here is a list of all objects

[2][1] Door
[2][2] Bonus
[2][3] Exit
[2][4] Key
[2][5] Start
[2][7] Mine
[2][8] Bomb
[2][9] Trigger
[2][10]Message
[2][11]Rocket
[2][12]Warp
[2][14]Switch
[2][15]Sproingy
[2][16]Block Manip
[2][17]Block Damage
[3][3] Archwagon
[3][4] Bouncer
[3][6] Cannon
[3][7] Podzilla
[3][8] Trakbot
[3][9] Cloner
[3][10]Field
[3][11]Block Walker
[3][12]Flapper


list of obj that can have x y randomized
its most of them!!!

[2][1] Door
[2][2] Bonus
[2][3] Exit
[2][4] Key
[2][5] Start
[2][7] Mine
[2][8] Bomb
[2][10]Message
[2][11]Rocket
[2][12]Warp
[2][14]Switch
[2][15]Sproingy

[3][3] Archwagon
[3][4] Bouncer
[3][6] Cannon
[3][7] Podzilla
[3][8] Trakbot
[3][9] Cloner
[3][10]Field
[3][11]Block Walker
[3][12]Flapper



bouncer and cannon:
Ei[b][8] = (int) mdw_rnd(1, 4); // seek count
Efi[b][5] = al_ftofix(mdw_rnd(2, 5)); // seek speed
initial direction (random for point at start block)

cannon:
Ei[b][9] = (int) mdw_rnd(0, 4); // extra hits to kill
Ei[b][8] = (int) mdw_rnd(1, 4); // seek count
Efi[b][5] = al_ftofix(mdw_rnd(2, 5)); // seek speed
Efi[b][7] = al_ftofix(mdw_rnd(3, 8)); // bullet speed
Ei[b][15] = (int) mdw_rnd(60, 200); // bullet retrigger
initial direction (random for point at start block)


lets try implementing just seek speed for now.
just to get the frame work going

have separate function for all of them?



int ge_seek_speed(int e)
{



}



min max random
min max inc/dec
set to value



make a function to search list and find out what modify functions apply.

if selection has only enemy type 6




I am making some custom blocks of code to edit groups, but

they get called every frame and I want them to have some persistant data storage..



struct ge_datum
{
   char name[40];

   int type;   // 2=item, 3=Ei, 4=Efi
   int varnum; // index of the variable

   int adj_mode;
   float adj_min;
   float adj_max;

   float min_allowed;
   float max_allowed;
}

struct ge_datum ge_data[20];




make a new slider that you can pass a pointer to the var as well as limits and var type..
and format display string

I need to amke versions for int and fixed beacuse I can't pass pointers to unknown variable type

void mdw_slider2_int(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt, int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                 int &var, float sul, float sll, float sinc, char *txt)


lets test this out...

health bonus...

   if (bn == 1) sprintf(smsg, "Health Bonus:%d", item[num][7]);

   if (bn == 1) item[num][7] = (int)f;      // health bonus

      case 1:  sul=100;  sll=2;     sinc=1;   sdx=item[num][7];                break;  // health bonus


mdw_slider(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 1,  num, type, obt, 0, 12, 15, 15, 1,0,0,0); a++; // health bonus

mdw_slider2_int(xa, ty+a*bts, xb, ty+(a+1)*bts-2, 0,0,0,0,  0, 12, 15, 15, 1,0,0,0, item[num][7], 100, 2, 1, "Health Bonus:"); a++; // health bonus

works....



lets try the fixed version...

if (bn == 19) sprintf(smsg, "Bullet Speed:%-1.1f", al_fixtof(Efi[num][7]));
if (bn == 19) Efi[num][7] = al_ftofix(f);  // bullet speed
case 19: sul=20;   sll=.8;    sinc=.1;  sdx=al_fixtof(Efi[num][7]);      break;  // bullet speed


mdw_slider(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 19, num, type, obt, 0,  9, 15, 15, 1,0,0,0); a++;  // bullet speed
mdw_slider2_fix(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 0,0,0,0,0,  9, 15, 15, 1,0,0,0, Efi[num][7], 20, 0.8, 0.1, "Bullet Speed:"); a++;  // bullet speed

works...

now a float version....done...

now back to ge_data...

extend buttont to be able to be pressed too....done



I have the randomize working...

I want to show variables in the list...
if when checking the list for ge that apply also use that to show that var in list...

this is all coming along nicely...

I want to make the selection thing add everything to list....done

now I want to add seek speed...done
and in doing so, make the ways of doing it more generic


now I need to make the list wider to account for all the extra columns...

And I can start on making the ge's look nicer..much nicer...

add another ge then fix list

bullet speed
bullet retrigger

done...

now move the list...or
move the filter buttons to be right justified with screen edge...

the list is looking good now...

can bullet speed and retrigger be applied to other enemies?
Archwagon yes for both
podzilla yes for speed only
trakbot yes for both
flapper yes for both

fucking beautiful...

what next to add...

bullet prox
Ei[][17]
for both archwag and trakbot

               Ei[b][2] = (int) mdw_rnd(0, 2);  // initial direction


archwag:
initial direction...done
8 ge's already...



bouncer:
initial direction
could have random shapes...

cannon:
initial direction






trakbot:
initial direction...done

flapper:
initial direction
same as archwag...done




why does flapper have 3 variables for bullet prox?
should be redone like trakbot to be a circle
it should calculate the angle and if it's too steep don't fire..
don't get bogged down on it now....put it to do later...

width   = Ei[EN][17]
height  = Ei[EN][18]
depth   = Ei[EN][19]

now some fun stuff...

initial directions...should be all done...



now the big one...common to all...randomize start pos....
for this one I think I will use the selection rectangle to set bounds

how do I use that without affecting anything else...

always show sel...
have a button..add objects in sel window to list

when getting new sel window how to tell between click and click drag...


mode button?
0 click select
1 selection window




I have a much better solution

selection on or off:
when off click one obj at a time

when on show selection and draw new with mouse

then the button add selection does that..

now I can do the initial position for all...done...

I am 90% done, the remaining 10% will take the other 90% of the time...


What do I need to do?

Is there anything from items that you might want to adjust?
mine damage
health bonus
bomb and rocket damage
rocket accell, max speed, steerability
sproingy jump height

what about flapper bullet prox?
bouncer shapes?


there is only one way to remove things from list shift click

make a way so that list, ge and filters can coexist...

collapseable filters??

each filter besides the valid flag should have a hide/show flag
when clicking on the title it will hide/show
done

now make filters smaller...done

hide columns in list if collapsed...done

put ge under list...done....


now this shit is looking real good...

what about podzilla speed?
if (bn == 29) sprintf(smsg, "Speed:%-2.1f", al_fixtof(Efi[num][9]));
   if (bn == 29)                           // pod speed
   {
      Efi[num][9] = al_ftofix(f);
      recalc_pod(num);
   }


void recalc_pod(int EN)
{
   al_fixed xlen = Efi[EN][5] - Efi[EN][0];      // get the x distance
   al_fixed ylen = Efi[EN][6] - Efi[EN][1];      // get the y distance
   al_fixed hy_dist =  al_fixhypot(xlen, ylen);     // hypotenuse distance
   al_fixed speed = Efi[EN][9];                  // speed
   al_fixed scaler = al_fixdiv(hy_dist, speed);     // get scaler
   al_fixed xinc = al_fixdiv(xlen, scaler);         // calc xinc
   al_fixed yinc = al_fixdiv(ylen, scaler);         // calc yinc
   Efi[EN][2] = xinc;
   Efi[EN][3] = yinc;
   Efi[EN][14] = al_fixatan2(ylen, xlen) - al_itofix(64);  // rotation

   // set number of steps
   al_fixed ns;
   if (abs(xlen) > abs(ylen)) ns = al_fixdiv(xlen, xinc);
   else  ns = al_fixdiv(ylen, yinc);
   int num_steps = al_fixtoi(ns);
   if ((num_steps > 0) && (num_steps < 2000))
      Ei[EN][7] = num_steps;


}
case 29: sul=30;   sll=.5;    sinc=.5;  sdx=al_fixtof(Efi[num][9]);      break;  // pod speed
case 30: sul=40;   sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // pod wait time

needed a special case for pod 4 9
added this three times in do it section...
if ((gvt == 4) && (gvn == 9)) recalc_pod(num);


I want to make a pod with a spline..

tried some levels with a lots more objects...thinking of increasing obj list to 600....700 done...

pause time should not be a part of archwag...fixed

20220424 8:30 PM push...

20220425 5:00AM

added menu item for group edit
made a new source file e_group_edit.cpp
has approx 1000 lines of code....

fix title of object list to not exceed frame...done

rearrange filters so enemys are on top

rearrange ge so x and y speeds are on top...done

next should be initial directions

looking good...all in good order...



commit message:

Created 'Group Edit' for editing group of objects
can randomize or step sets of variables


what about block walker in common with archwagon?...done...


what if I decouple the whole viewer thing from full screen?
have the map part not be the entire screen up in the corner
what if the side panel of viewer buttons was a moveable window in its own right
sitting on top of the normal level display
and the normal level display was zoomable, just like in the game...
wow...mind blown...


can I do it for group edit to start?


mouse pointer item in regular editor show the view window for that item...

I would have to redo the entire object viewer to show the right panel in a window

make a new file..
e_object_viewer_windows.cpp

copy everything from object viewer and make it pop up windows...



make an object for this window

it needs to know

x1, y1, x2, x2

how to draw...

I can also patch it in where real obj viewer is called...done



now how to make it draw map things on the full size map...

how does editor do it?


I can draw the obj location highlight and archwagon prox for now...

working on key block range...


wx, wy are (0-99)

key block ranges are
6 7 x y (0-2000)
8 9 w h (0-2000)


move buttons for each object to its own function...done...
int obj_buttons(int x1, int x2, int ty, int a, int bts, int obj_type, int type, int obj_num)



what are my longest buttons and sliders?

go through them one at a time

archwagon:

Initial Driection:Right    23
Bullet Retrigger Time:100  25



I am making the map draw stuff work for full screen resoltuion, but I think I am on the wrong track...
I need to draw it on the level buffer so that it can be resized to any arbitary size....


do this for ovw for now but later for regular editor also


in the loop draw the background...very similar to how it is done in the game...






      proc_scale_factor_change();

      proc_controllers();

      get_new_background(0);

      draw_lifts();
      draw_items();
      draw_enemies();

      get_new_screen_buffer();

      al_flip_display();


before get new screen buffer is where I need to draw on the level buffer...

after get screen new screen buffer is where I need to draw the button control thing...

this is done and works but kind of sloppy.


I can resize level with F5 and F6

when in viewer all the highlights work..


the speed seems to fast...










i have a few things messed up..

legend line 1 does not blink in legend although frame around item does... for no reason...fixed
buttons don't show for anything....fixed...flip display too soon

animated shapes are smeared....

its like there is an animated shape and a static shape overlaid...


20220427
lets go through it one step at a time....
load level calls init_level_background()
draws blocks and lift lines on level background...

edit menu calls draw_big

void draw_big(int draw_lifts)
{
   init_level_background(); // fill level_background with blocks and lift lines
   draw_level2(level_background, 0, 0, 2000, 1, 1, 1, 1, 0);
   draw_level2(lefsm, 0, 0, db*100, 1, 1, 1, draw_lifts, 0);
   al_set_target_backbuffer(display);
}



what bitmap do these even draw on?...level_buffer


void draw_level2(ALLEGRO_BITMAP *b, int mx, int my, int ms, int blocks, int items, int enemies, int lifts, int players)
{
   if (blocks) get_new_background(1);
   if (valid_level_loaded)
   {
      if (lifts)   draw_lifts();
      if (items)   draw_items();
      if (enemies) draw_enemies();
      if (resume_allowed)
      {
         if (players) draw_players();
         draw_ebullets();
         draw_pbullets();
      }
   }
   if (b == NULL) al_set_target_backbuffer(display);
   else al_set_target_bitmap(b);
   al_draw_scaled_bitmap(level_buffer, 0, 0, 2000, 2000, mx, my, ms, ms, 0);
}


void get_new_background(int full)
{
   al_set_target_bitmap(level_buffer);
   if (full) al_draw_bitmap(level_background, 0, 0, 0);
   else
   {
      // this only grabs the visible region, in the interests of speed
      int x = level_display_region_x - 20; if (x < 0) x = 0;
      int y = level_display_region_y - 20; if (y < 0) y = 0;
      int w = level_display_region_w + 40; if (x+w > 2000) w = 2000-x;
      int h = level_display_region_h + 40; if (y+h > 2000) h = 2000-y;
      al_draw_bitmap_region(level_background, x, y, w, h, x, y, 0);
   }
}

void draw_items(void)
{
   al_set_target_bitmap(level_buffer);


I don't know why....

I found a way around it...
I don't actually need to call proc_frame_delay()
it works just fine without it, doesnt run too fast...
also don't need draw_screen_overlay();

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
//      proc_frame_delay();
      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();
      draw_object_overlays(obt, num, legend_line, highlight_counter);
      get_new_screen_buffer();
//      draw_screen_overlay();
      // draw button title, frame and legend lines
      title_objw(ov_x1, ov_y1, ov_x2, ov_y2, obt, num, 0, 15);

leave it like this for now...move on...

next make the background scrollable just like main editor


int ovw_process_scrolledge(void)
{
   int scrolledge=10;
   int old_wx = wx;
   int old_wy = wy;
   if (mouse_x < scrolledge) wx--;           // scroll left
   if (mouse_x > SCREEN_W-scrolledge) wx++;  // scroll right
   if (mouse_y < scrolledge) wy--;           // scroll up
   if (mouse_y > SCREEN_H-scrolledge) wy++;  // scroll down

   int rx = 100 - (SCREEN_W/20);
   int ry = 100 - (SCREEN_H/20);

   if (wx > rx) wx = rx;
   if (wy > ry) wy = ry;
   if (wx < 0) wx = 0;
   if (wy < 0) wy = 0;

   if ((old_wx != wx) || (old_wy != wy))
   {
      al_rest(.02);
   }
   return 0;
}


get_new_screen_buffer uses PX and PY to set WX and WY...im going to need to do something different...
maybe mouse....no

went with position of the object in the viewer...seems to work for now...
no mouse scroll at all...only zoom in and out and change object....

seem to work good...

now I really want to be able to move the button window by dragging the title bar...

then I want to make the button window automatically resize its height based on how many buttons it has...
and still have the legend at the bottom...

then maybe resize the width too, based on how wide the buttons are...

I should go through all the buttons and do them with them new slider and button functions
and at the same time make them return the width of the text?? would that even work??
its too late by then to adjust the width....



back at home...
F5 and F6 go all the way to the end...anyway to slow down??
added back frame delay
fixed the problem with the smearing...
needed to run init_level_background when starting ovw...
too much stuff was drawn on level_backbround already...

move button window

how do I do it for selection window?

   int swx1 = status_window_x;
   int swy1 = status_window_y;
   int swh = status_window_h;
   int sww = status_window_w;
   int swx2 = swx1 + sww;
   int swy2 = swy1 + swh;


// object viewer window
int ov_window_active = 1;
int ov_window_x = SCREEN_W - 300;
int ov_window_y = 140;
int ov_window_w = 240;
int ov_window_h = 600;

// object viewer window
extern int ov_window_active;
extern int ov_window_x;
extern int ov_window_y;
extern int ov_window_w;
extern int ov_window_h;

made it moveable!


now make it the right height
need to call draw buttons first and have that set ov_window_h...done
need to make title not erase buttons...done
need to make title add number of legend lines to ov_window_h ...
got to where legend is moveable, but mouse on it shows up in a different place...fixed..

now it is moveable and resizes height nicely....

what about width?

make up and down arrow change types...whoah!
this is done, but I want it to also switch from item to enemy and vice versa
later I will be able to do this with map...

increased width to 300 and all buttons seem to fit well now...
still would be nice to do dynamic width somehow...

so what is the next big thing to do to this??
map move......


erase the background of buttons
this is harder than I thought...I don't know how big they are until I draw them

I could store w and h for each obt and type...

I could draw on a extra long cleared bitmap then chop blank section...

I went with storing w and h for each object..
now I can have custom width...but I have to manually edit it..
I still have automatic height, but I know what it is before I draw the buttons
so that I can erase before...

this seems to be working....




redoing sliders and buttons...

archwag...

   if (bn == 12) sprintf(smsg, "X-Speed:%-1.2f", al_fixtof(Efi[num][6]));
   if (bn == 13) sprintf(smsg, "Y-Speed:%-1.2f", al_fixtof(Efi[num][3]));


   if (bn == 12)                            // x - speed
   {
      Efi[num][6] = al_ftofix(f);
      if (Efi[num][2] > al_itofix(0)) Efi[num][2] = Efi[num][6];
      if (Efi[num][2] < al_itofix(0)) Efi[num][2] = -Efi[num][6];

   }
   if (bn == 13) Efi[num][3] = al_ftofix(f);  // y - speed

      case 12: sul=9;    sll=.7;    sinc=.01; sdx=al_fixtof(Efi[num][6]);      break;  // archwagon x speed
      case 13: sul=9;    sll=.7;    sinc=.01; sdx=al_fixtof(Efi[num][3]);      break;  // y speed

does anything else use 12 and 13...
block walker...
do I need to set 2 also when changing 6??  look at archwag code...no I can ignore it...just set 6...


            mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 8,  num, type, obt, 0, 15, 13,  0, 1,0,0,0); a++;  // initial direction
            mdw_button(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 9,  num, type, obt, 0, 15, 13,  0, 1,0,0,0); a+=2; // bounce mode

   if (bn == 8) // archwag direction
   {
      if (Ei[num][2]) sprintf(smsg, "Initial Direction:Right");
      else            sprintf(smsg, "Initial Direction:Left ");
      if (press)
      {
         Ei[num][2] = !Ei[num][2];
         Redraw = 1;
      }
   }
   if (bn == 9) // archwag and walker
   {
      if (Ei[num][8]) sprintf(smsg, "Bounce Mode");
      else            sprintf(smsg, "Follow Mode");
      if (press) Ei[num][8] = !Ei[num][8];
   }




mdw_slider(xa, ty+(a*bts), xb, ty+(a+1)*bts-2, 19, num, type, obt, 0,  9, 15, 15, 1,0,0,0); a++;  // bullet speed
also pod and trakbot and cannon


if (bn == 19) sprintf(smsg, "Bullet Speed:%-1.1f", al_fixtof(Efi[num][7]));


   if (bn == 20) sprintf(smsg, "Bullet Proximity:%d", Ei[num][17]);

      case 20: sul=2000; sll=20;    sinc=1;   sdx=Ei[num][17];                 break;  // bullet prox
   if (bn == 20) Ei[num][17] = (int)f;     // bullet prox
arch and trak




   if (bn == 21) sprintf(smsg, "Bullet Retrigger Time:%d", Ei[num][15]);
   if (bn == 21) Ei[num][15] = (int)f;     // retrigger time
      case 21: sul=200;  sll=1;     sinc=1;   sdx=Ei[num][15];                 break;  // retrigger time
arch, cannon, trakbot, flapper





      case 24: sul=20;   sll=0;     sinc=1;   sdx=Ei[num][29];                 break;  // collision box
      case 25: sul=10;   sll=0;     sinc=.1;  sdx=al_fixtof(Efi[num][4]);      break;  // health dec
      case 42: sul=50;   sll=0;     sinc=1;   sdx=Ei[num][25];                 break;  // dead enemy health bonus




      case 22: sul=12;   sll=0;     sinc=.01; sdx=al_fixtof(Efi[num][5]);      break;  // cannon speed
      case 23: sul=100;  sll=0;     sinc=1;   sdx=Ei[num][8];                  break;  // seek count



//   if (bn == 35) sprintf(smsg, "Extra Hits to Kill:%d", Ei[num][9]);
   if (bn == 35) Ei[num][9] = (int)f;         // cannon extra hits to kill
      case 35: sul=40;   sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // cannon hits


bouncer and cannon speed and initial direction need custom shit..
direction and speed are saved with xinc, yinc....

revert 22....done



   if (bn == 12) // trakbot drop mode
   {
      if (Ei[num][7] == 0) sprintf(smsg, "Drop Mode:Off");
      else                 sprintf(smsg, "Drop Mode:On ");
      if (press)
      {
         if (bn == 12) Ei[num][7] = !Ei[num][7]; // trakbot drop mode
      }
   }



   if (bn == 45) sprintf(smsg, "X-speed:%-1.2f",al_fixtof(Efi[num][2]));
   if (bn == 46) sprintf(smsg, "Y-Speed:%-1.2f",al_fixtof(Efi[num][3]));


   if (bn == 36) sprintf(smsg, "Y Speed:%-1.2f", al_fixtof(Efi[num][3]));
   if (bn == 36) Efi[num][3] = al_ftofix(f);     // flapper x speed
      case 36: sul=5;    sll=0;     sinc=.01; sdx=al_fixtof(Efi[num][3]);      break;  // flapper y speed




   if (bn == 79) sprintf(smsg, "Flap Speed:%-1.2f", al_fixtof(Efi[num][10]));
   if (bn == 80) sprintf(smsg, "Flap Height:%d", Ei[num][21]);

   if (bn == 79) Efi[num][10] = al_ftofix(f);       // flap speed
   if (bn == 80) Ei[num][21] = (int)f;              // flap height

      case 79: sul=8;    sll=.5;    sinc=.1;  sdx=al_fixtof(Efi[num][10]);     break;  // flap speed
      case 80: sul=400;  sll=0;     sinc=10;  sdx=Ei[num][21];                 break;  // flap height


      case 63: sul=1000; sll=-1000; sinc=10;  sdx=Ei[num][20];                 break;  // height above player
   if (bn == 63) sprintf(smsg, "Height Above Player:%d",Ei[num][20]);
   if (bn == 63) Ei[num][20] =(int)f;       // flapper height above player



   if (bn == 38) Ei[num][17] = (int)f;        // flapper trigger box width
   if (bn == 39) Ei[num][18] = (int)f;        // flapper trigger box height
   if (bn == 40) Ei[num][19] = (int)f;        // flapper trigger box depth
   if ((bn == 38) ||(bn == 39) ||(bn == 40) ||(bn == 63))  // update flapper trigger box while adjusting
   {
       draw_big(1);
       show_big();
   }

   if (bn == 38) sprintf(smsg, "Trigger Box Width:%d", Ei[num][17]);
   if (bn == 39) sprintf(smsg, "Trigger Box Height:%d", Ei[num][18]);
   if (bn == 40) sprintf(smsg, "Trigger Box Depth:%d", Ei[num][19]);

      case 38: sul=500;  sll=20;    sinc=1;   sdx=Ei[num][17];                 break;  // width
      case 39: sul=600;  sll=1;     sinc=10;  sdx=Ei[num][18];                 break;  // y1
      case 40: sul=600;  sll=1;     sinc=10;  sdx=Ei[num][19];                 break;  // y2



      case 60: sul=8;    sll=.5;    sinc=.1;  sdx=al_fixtof(Efi[num][5]);      break;  // flapper max x speed
      case 61: sul=2;    sll=.01;   sinc=.01; sdx=al_fixtof(Efi[num][6]);      break;  // flapper x accel
      case 62: sul=4;    sll=0;     sinc=.1;  sdx=al_fixtof(Efi[num][8]);      break;  // flapper yinc flap scale

   if (bn == 60) sprintf(smsg, "X Speed:%-3.2f",al_fixtof(Efi[num][5]));
   if (bn == 61) sprintf(smsg, "X Accel:%-3.2f",al_fixtof(Efi[num][6]));
   if (bn == 62) sprintf(smsg, "Y Flap :%-3.2f",al_fixtof(Efi[num][8]));

   if (bn == 60) sprintf(smsg, "X Speed:%-3.2f",al_fixtof(Efi[num][5]));
   if (bn == 61) sprintf(smsg, "X Accel:%-3.2f",al_fixtof(Efi[num][6]));
   if (bn == 62) sprintf(smsg, "Y Flap :%-3.2f",al_fixtof(Efi[num][8]));






   if (bn == 83) // cloner only
   {
      if (Ei[num][30] ==  0) sprintf(smsg,  "      Normal     ");
      if (Ei[num][30] ==  1) sprintf(smsg,  "    Invincible   ");
      if (press)
      {
         Ei[num][30] = !Ei[num][30]; // cloner invinciblility
      }
   }



   if (bn == 34) sprintf(smsg, "Delay Timer:%d", Ei[num][6]);

   if (bn == 34)                           // cloner create delay
   {
      Ei[num][6] = (int)f;
      Ei[num][7] = (int)f;
   }

      case 34: sul=1000; sll=20;    sinc=1;   sdx=Ei[num][6];                  break;  // create delay



         if (bn == 74) sprintf(smsg, "Created Objects Time To Live:%-2d", Ei[num][9]);
   if (bn == 75) sprintf(smsg, "Max Created Objects At One Time:%-2d", Ei[num][10]);



         if (bn == 74) Ei[num][9] = (int)f;        // cloner created object time to live
   if (bn == 75) Ei[num][10] = (int)f;       // cloner max created objects active at one time


      case 74: sul=4800; sll=0;     sinc=1;   sdx=Ei[num][9];                  break;  // cloner created obj time to live
      case 75: sul=600;  sll=0;     sinc=1;   sdx=Ei[num][10];                 break;  // cloner max created obj at one time




made all enemy button widths 220 by changing 'viewer help' 'archwagon help' to 'help' 'archwagon help'...


now what is wrong with the map stuff...fixed crosshairs and podzilla legend




bonus needs fixing...
now it can be health, free man or purple coin



   if (bonus_type == 1) // health bonus
   {
      al_fixed f100 = al_itofix(100);


      if (players[p].LIFE < f100)
      {
         item[i][0] = 0;
         players[p].LIFE += al_itofix(item[i][7]);
         if (players[p].LIFE > f100) players[p].LIFE = f100;

         game_event(72, 0, 0, p, i, item[i][1], item[i][7]);
      }
   }

   if (bonus_type == 2) // free man
   {
      item[i][0] = 0;
      players[p].LIVES++;
      game_event(70, 0, 0, p, i, 0, 0);
   }



   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      // game_event(70, 0, 0, p, i, 0, 0);

   }


bonus is fixed....


fix door destination....done




   if (bn == 47) sprintf(smsg, "Exit with %d enemies left",item[num][8]);
   if (bn == 47) item[num][8] = (int)f;       // exit with x enemies left
      case 47: sul=100;  sll=0;     sinc=1;   sdx=item[num][8];                break;  // exit with x enemies left


working on lining up the message stuff...its a lot better but maybe not 100%...nah...its good...


High level shit here...where am I going with this?

If I make map move stuff work, then I have basically replaced all the viewer stuff (item and enemy anyways) with my new zoomable stuff....

then should I go further?
- integrate the main editor
- integrate the zoom full screen stuff
- integrate group edit
- integrate lift viewer?


could all of these things just be windows that float on top of the zoomable level background?
like status, selection, and now object viewer


added scroll to viewer
centers display on current obj when first started or when changing obj

I want podzilla to show tile at extended pos and connecting line...done


detect what object mouse pointer is on
this is the start of map move...


this is harder than it should be:


         float bs = scale_factor_current * 20; // block size

         float xpos = (float) (WX+mouse_x-BORDER_WIDTH);

         float fgx = xpos/bs;
         int gx = (int) fgx;

         float fgy = (WY+mouse_y-BORDER_WIDTH)/bs;
         int gy = (int) fgy;

         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f bs:%2.1f fgx:%2.1f gx:%d\n", mouse_x, WX, WX+mouse_x, WX+mouse_x-BORDER_WIDTH, scale_factor_current, bs, fgx, gx);
//         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen
         float sgx = gx*bs - WX+BORDER_WIDTH;
         float sgy = gy*bs - WY+BORDER_WIDTH;
         al_draw_rectangle(sgx, sgy, sgx+bs, sgy+bs, palette_color[14], 1);


this does not work:

when scale_factor_current = 1 it works no matter what WX and WY are
when WX and WY = 0 it works no matter what sfc is...
when either of those is different it does not line up


WX is a pointer to the unscaled source.....scale WX and try again...


WX is in 0-2000 format and is a pointer the the left edge of the source position in level buffer

what is shown on the screen has been scaled, but the left edge has the same x as the level buffer source


this works....


            // the mouse position past the border width is how far we are into the scaled map
            float mx1 = mouse_x-BORDER_WIDTH;

            // divide that by bs to get how many blocks we are into the map
            float mx2 = mx1 / bs;

            // get block position of WX
            float mx3 = WX / 20;

            // add WX
            float mx4 = mx3 + mx2;

            int gx = (int) mx4;


            // the mouse position past the border width is how far we are into the scaled map
            float my1 = mouse_y-BORDER_WIDTH;

            // divide that by bs to get how many blocks we are into the map
            float my2 = my1 / bs;

            // get block position of WX
            float my3 = WY / 20;

            // add WY
            float my4 = my3 + my2;

            int gy = (int) my4;





/*

            float my1 = (mouse_y-BORDER_WIDTH) * scale_factor_current;
            float my2 = (WY + my1) / 20;
            int gy = (int) my2;
*/
//            printf("mx1:%2.1f mx2:%2.1f mx3:%2.1f mx4:%2.1f gx:%d\n", mx1, mx2, mx3, mx4, gx);


//         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f gx:%d\n", mouse_x, WX, WX+mouse_x, WX+mouse_x-BORDER_WIDTH, scale_factor_current, gx);
         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen
//         float sgx = gx*bs - WX+BORDER_WIDTH;
//         float sgy = gy*bs - WY+BORDER_WIDTH;

         float sgx = BORDER_WIDTH + (gx-WX/20) * bs;
         float sgy = BORDER_WIDTH + (gy-WY/20) * bs;
         al_draw_rectangle(sgx, sgy, sgx+bs, sgy+bs, palette_color[14], 1);



but it only works when WX and WY are multiples of 20.....

I gave up all this bullshit and just draw directly on the level buffer like this:

      if (block_highlight_show) crosshairs_full(block_highlight_x, block_highlight_y, block_highlight_color, 1);

/*



         printf("WX:%d mx1:%2.1f mx2:%2.1f mx3:%2.1f mx4:%2.1f gx:%d\n", WX, mx1, mx2, mx3, mx4, gx);
//         printf("mx:%d WX:%d wx+mx:%d wx+mx-bw:%d sfc:%2.1f gx:%d\n", mouse_x, WX, WX+mouse_x, WX+mouse_x-BORDER_WIDTH, scale_factor_current, gx);
//         printf("mx:%d WX:%d sfc:%2.1f gx:%d\n", mouse_x, WX, scale_factor_current, gx);
//         printf("gx:%d gy:%d\n", gx, gy);

         // now reverse calc to draw on screen

         // block position of WX
         float bwx = (float)WX/20;

         // subtract from obj pos
         float gwx = (float)gx - bwx;

         // muliply obj block pos by bs
         float gwx2 = gwx * bs;

         float sgx = BORDER_WIDTH + gwx2;

         printf("WX:%d bwx:%2.1f gwx:%2.3f gwx2:%2.3f sgx:%2.3f scf:%2.1f bs:%2.1f\n", WX, bwx, gwx, gwx2, sgx, scale_factor_current, bs);






//         float sgx = BORDER_WIDTH + ( (float)gx -(float)WX / 20) * bs;

         float sgy = BORDER_WIDTH + ( (float)gy -(float)WY / 20) * bs;

         int sgx1 = (int)sgx;
         int sgy1 = (int)sgy;
         int sgx2 = (int)(sgx + bs + 1);
         int sgy2 = (int)(sgy + bs + 1);

         al_draw_rectangle(sgx1, sgy1, sgx2, sgy2, palette_color[14], 1);



*/










now move on...



when I scroll away...
clicking to move window resets the map pos...fixed...




what am I going to do with this block the mouse is on??
detect and set viewer to that object...

         // detect if we are on an object...
         for (int b=0; b<100; b++) // add enemies in selection
            if ((Ei[b][0]) && (al_fixtoi(Efi[b][0])/20 == gx) && (al_fixtoi(Efi[b][1])/20 == gy))
            {
               obt = 3;
               num = b;
               new_obj = 2;
            }

         for (int b=0; b<500; b++) // add items in selection
            if ((item[b][0]) && (item[b][4]/20 == gx) && (item[b][5]/20 == gy))
            {
               obt = 2;
               num = b;
               new_obj = 2;
            }


that was easy...

now do mouse move....




make a function that gets block x and y
from mouse, scf and WX



void ob_get_block_position_on_map(int*x, int*y)
{
   // scaled block size
   float bs = scale_factor_current * 20;
   // the mouse position past the border width is how far we are into the scaled map
   float mx1 = mouse_x-BORDER_WIDTH;
   float my1 = mouse_y-BORDER_WIDTH;
   // divide that by bs to get how many blocks we are into the map
   float mx2 = mx1 / bs;
   float my2 = my1 / bs;
   // get block position of WX
   float mx3 = (float)WX / 20;
   float my3 = (float)WY / 20;
   // add WX
   float mx4 = mx3 + mx2;
   float my4 = my3 + my2;
   *x = (int) mx4;
   *y = (int) my4;
}


int gx=0, gy=0;
ob_get_block_position_on_map(&gx, &gy);



// mouse move
if (mouse_on_obj)
{
   //printf("mouse on obj\n");
   if (mouse_b1)
   {
      //printf("mouse pressed on obj\n");
      while (mouse_b1)
      {
         if (obt == 2)
         {
            ob_get_block_position_on_map(&gx, &gy);
            item[num][4] = gx*20;
            item[num][5] = gy*20;
            itemf[num][0] = al_itofix(gx*20);
            itemf[num][1] = al_itofix(gy*20);
         }

         if (obt == 3)
         {
            ob_get_block_position_on_map(&gx, &gy);
            Efi[num][0] = al_itofix(gx*20);
            Efi[num][1] = al_itofix(gy*20);
         }
         al_flip_display();
         proc_scale_factor_change();

         proc_controllers();
         proc_frame_delay();
         get_new_background(0);
         draw_lifts();
         draw_items();
         draw_enemies();
         draw_object_overlays(obt, num, legend_line, highlight_counter);
         get_new_screen_buffer(3, obj_x, obj_y);
      }
   }
}

mouse move was easy....


things do not work nice if zoomed in so far that map is not in upper right corner....
how can I prevent this from happening...fixed...


   // is the entire level smaller than the screen buffer width?
   if (sls < sbw)
   {
      int a = sbw - sls; // how much smaller?
      sbw = sls;         // new screen_buffer blit width = sls
      if (!level_editor_running) sbx += a/2;        // new screen_buffer blit xpos
   }

   // is the entire level smaller than the screen buffer height?
   if (sls < sbh)
   {
      int a = sbh - sls; // how much smaller?
      sbh = sls;         // new screen_buffer blit height = sls
      if (!level_editor_running) sby += a/2;        // new screen_buffer blit ypos
   }




bug red line on exit only door...fixed....


now lets do pozilla extended position....
click and drag motherfucker!

make a function to get pod extended position and see how many places we can us it...

done and done

bug archwagon empty arrow ans seem to be blank....i think I got it back..must have erased ans#3 by accident....


next I want to do rectangular boxes....

start with podzilla and cloner trigger...done...

make the mouse pointer better...
only show higlighted square if object detected...otherwise just show regulat pointer....
tie this in with the mouse pointer...

then see if you can do the mouse pointer more accurate than block resolution

gx and gy are fine, but I want something better also....
hx and hy....done


old:
if ((al_fixtoi(Efi[b][0])/20 == gx) && (al_fixtoi(Efi[b][1])/20 == gy)) // if x and y position match, set this to current object

new:
int ex = al_fixtoi(Efi[b][0]);
int ey = al_fixtoi(Efi[b][1]);
if ((hx>ex+6) && (hx<ex+14) && (hy>ey+6) && (hy<ey+14))

much nicer...

just redid all detection like this and I like it a lot...

next to add would be the 4 item box moves....

            // ranges for key, trigger, manip and damage
            if (mouse_on_kbr_ul) // move block range from ul
            {
               // set new position
               item[num][6] = mx*20;
               item[num][7] = my*20;
            }
            if (mouse_on_kbr_lr) // adjust block range from lr
            {
               // don't allow lr to be less than ul
               if (mx < item[num][6]/20) mx = item[num][6]/20;
               if (my < item[num][7]/20) my = item[num][7]/20;

               // set new position
               item[num][8] = mx*20 - item[num][6];
               item[num][9] = my*20 - item[num][7];
            }


that was so easy.....


what next?


cloner src and dest...done...

messages done....

rocket and bomb damage ranges done...

sproingy done...


there is no trakbot bullet prox?
make one...done

did not do the part where moving main item also moves other stuff
cloner, pod, trigger bm bd, key, etc....


if (mouse_on_enemy)
{
   // get offset of move
   int x_off = al_fixtoi( al_itofix(mx * 20) - Efi[num][0] ) / 20;
   int y_off = al_fixtoi( al_itofix(my * 20) - Efi[num][1] ) / 20;

   // set new position
   Efi[num][0] = al_itofix(mx * 20);
   Efi[num][1] = al_itofix(my * 20);

   // move podzilla's trigger box too
   if (Ei[num][0] == 7)
   {
      Ei[num][11] += x_off;
      Ei[num][12] += y_off;
      Ei[num][13] += x_off;
      Ei[num][14] += y_off;
   }

   // move cloner's stuff too
   if (Ei[num][0] == 9)
   {
      Ei[num][11] += x_off; // trigger box
      Ei[num][12] += y_off;
      Ei[num][13] += x_off;
      Ei[num][14] += y_off;
      Ei[num][15] += x_off; // source
      Ei[num][16] += y_off;
      Ei[num][17] += x_off; // dest
      Ei[num][18] += y_off;
   }
} // end of mouse on enemy

did this also, but made it so that only by holding shift are those moved also.
should do it also for key msg, trigger bm bd...done...


now.....

can I merge some other things with this....

how about group edit?


I would need to make the windows for that float....or not...they could just be stuck where they are for now....

all I need to change is the map background....


make a new source file

e_group_edit_windows.cpp

copy everything there...then start modifying....


first of all I want to get rid of old obj viewer....

if it got lift stuff it just passed it on....
make that work again....


what about title obj...make a stripped down version....
this broke, or made look bad....the creators....fix later...I need to get lift viewer working though


patched lift viewer back in...

now you can right click on a lift from main editor and ovw will pass it to lift viewer
then if you mouse on an item or enemy in the lift viewer map it will switch to ovw for that obj....
not back yet though...now it is....


what if I made a function like get box, but that used the scaled map background....
I want to get rid of anything that uses the 100x100 map and title stuff...




for keys...
get rid of color select..
make 4 PDE..
make color changeable in viewer
make a new getbox and use it...


int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2)

find all the places I can swap for

int getbox(const char *txt, int obj_type, int sub_type, int num )

16 occurances!!

key block range done
type 1 0-1999 x y w h

move trigger box for 7 and 9...done
type 2 0-99 x1 y1 x2 y2

cloner source area creator...done
type 3 0-99 x y w h


field damage creator
field trigger creator
type 1 0-1999 x y w h

key creator
type 1

creators all type 1
trigger
bd
bm


button 5 key

button 17 cloner src

button 85 get new field
button 86 get new field trigger

200 trigger

now retired!!!
//int getbox(const char *txt, int obj_type, int sub_type, int num );

int getbox(const char *txt, int obj_type, int sub_type, int num )
{
   int bs_on = 1;
   int quit = 0;
   while (mouse_b1) proc_controllers();    // wait for release
   while (!quit)
   {
      proc_controllers();
      int dx = mouse_x/db;
      int dy = mouse_y/db;

      title_obj(obj_type, sub_type, num, 0, 15);

      // show text line
      al_draw_text(font, palette_color[9],  txc, 72,  ALLEGRO_ALIGN_CENTER, "Draw a new");
      al_draw_text(font, palette_color[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, palette_color[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "by clicking and");
      al_draw_text(font, palette_color[9],  txc, 96,  ALLEGRO_ALIGN_CENTER, "dragging with the");
      al_draw_text(font, palette_color[9],  txc, 104, ALLEGRO_ALIGN_CENTER, "left mouse button");
      al_draw_text(font, palette_color[14], txc, 130, ALLEGRO_ALIGN_CENTER, "Cancel with <ESC> or");
      al_draw_text(font, palette_color[9],  txc, 138, ALLEGRO_ALIGN_CENTER, "the right mouse button");

      if (bs_on) draw_bs(15);

      if ((obj_type == 3) && (sub_type == 9)) // cloner
         draw_cloner_boxes(num);

      // show block cursor
      if ((dx<100) && (dy < 100)) al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, palette_color[127-32], 1); // show which block is selected

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));

      if (mouse_b1)
      {
         quit = 1;
         bx1 = mouse_x/db;
         by1 = mouse_y/db;
         while (mouse_b1) // trap while b1 is held
         {
            proc_controllers();
            title_obj(obj_type, sub_type, num, 0, 15);

            // show text line
            al_draw_text(font, palette_color[9],  txc, 72,  ALLEGRO_ALIGN_CENTER, "Draw a new");
            al_draw_text(font, palette_color[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
            al_draw_text(font, palette_color[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "by clicking and");
            al_draw_text(font, palette_color[9],  txc, 96,  ALLEGRO_ALIGN_CENTER, "dragging with the");
            al_draw_text(font, palette_color[9],  txc, 104, ALLEGRO_ALIGN_CENTER, "left mouse button");
            al_draw_text(font, palette_color[14], txc, 130, ALLEGRO_ALIGN_CENTER, "Cancel with <ESC> or");
            al_draw_text(font, palette_color[9],  txc, 138, ALLEGRO_ALIGN_CENTER, "the right mouse button");

            if (bs_on) draw_bs(15);

            if ((obj_type == 3) && (sub_type == 9)) // cloner
              draw_cloner_boxes(num);


            // show selection rectangle
            bx2 = (mouse_x/db)+1;
            by2 = (mouse_y/db)+1;
            al_set_clipping_rectangle(0, 0, display_transform_double*db*100-1, display_transform_double*db*100-1);
            al_draw_rectangle((bx1)*db, (by1)*db, (bx2)*db, (by2)*db, palette_color[15], 1);
            al_reset_clipping_rectangle();

            al_flip_display();
            al_clear_to_color(al_map_rgb(0,0,0));
         }

         // limits
         if (bx1<0) bx1 = 0;
         if (bx2<0) bx2 = 0;
         if (by1<0) by1 = 0;
         if (by2<0) by2 = 0;

         if (bx1>99) bx1 = 99;
         if (bx2>99) bx2 = 99;
         if (by1>99) by1 = 99;
         if (by2>99) by2 = 99;

         // ensure top-right, bottom left format
         if (bx1 > bx2)
         {
            int btemp = bx2;
            bx2 = bx1;
            bx1= btemp;
         }
         if (by1 > by2)
         {
            int btemp = by2;
            by2 = by1;
            by1= btemp;
         }
      }
      if  (mouse_b2)
      {
         while (mouse_b2) proc_controllers(); // wait for release
         return 0;
      }
      if (key[ALLEGRO_KEY_ESCAPE])
      {
         return 0;
      }
   } // end of while not quit
   return 1;
}


getbox is dead...I wish I could get rid of the globals that it uses....bx1...etc

how about getxy? there are only 27 calls to that!!

could be done...keep all the cool shit
make it on the zoomable map also and no title obj

podzilla could have random extended position

get block range needs checks to prevent upside down...done



getxy...

the part at the start where variable are saved will be easier once I pass pointers

I think I might just redo the existing one instead of making a new one...

almost done...

when called ignore get100_y...done

get100x and y are completely gone....






int old_getxy(const char *txt, int obj_type, int sub_type, int num )
{
   int dx=0, dy=0;

   // in case these are needed for lifts
   int lift = sub_type;
   int step = num;

   int retval=0;
   int quit=0;

   while (mouse_b1) proc_controllers(); // wait for release
   al_flip_display();
   al_clear_to_color(al_map_rgb(0,0,0));


// get original positions in case we are cancelled
   int original_dx=0, original_dy=0;
   if (obj_type == 2)
   {
      original_dx = item[num][4];
      original_dy = item[num][5];
   }
   if (obj_type == 3)
   {
      original_dx = al_fixtoi(Efi[num][0]) / 20;
      original_dy = al_fixtoi(Efi[num][1]) / 20;
   }

   if (obj_type == 99) // pod extended
   {
      original_dx = al_fixtoi(Efi[num][5]) / 20;
      original_dy = al_fixtoi(Efi[num][6]) / 20;
   }

   if (obj_type == 98) // cloner destination
   {
      original_dx = Ei[num][17];
      original_dy = Ei[num][18];
   }

   if (obj_type == 4)
   {

      original_dx = lift_steps[lift][step].x / 20;
      original_dy = lift_steps[lift][step].y / 20;
   }

   while(!quit)
   {
      dx = mouse_x/db;
      dy = mouse_y/db;

      if ((dx < 100) && (dy < 100)) // if mouse on map
      {
         switch (obj_type) // show draw_item
         {
            case 2: // show item
               if (sub_type == 1010) // message display only
               {
                  show_big();
                  al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
                  al_draw_bitmap(mp, dx*db, dy*db, 0);
                  al_reset_clipping_rectangle();
               }
               else // all other items
               {
                  item[num][4] = dx*20;
                  item[num][5] = dy*20;
                  itemf[num][0] = al_itofix(dx*20);
                  itemf[num][1] = al_itofix(dy*20);
                  draw_big(1);
                  show_big();
                  draw_bs(14);            // show bullseye map
                  al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
                  al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, palette_color[127-32], 1); // draw box to show cursor
                  al_reset_clipping_rectangle();
               }
            break;
            case 3: // show enem
               Efi[num][0] = al_itofix(dx * 20);
               Efi[num][1] = al_itofix(dy * 20);
               draw_big(1);
               show_big();
               draw_bs(14);            // show bullseye map
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, palette_color[127-32], 1); // draw box to show cursor
               al_reset_clipping_rectangle();
            break;
            case 99: // move pod extended
            {
               Efi[num][5] = al_itofix(dx * 20);
               Efi[num][6] = al_itofix(dy * 20);
               draw_big(1);
               show_big();
               draw_bs(14);
               int ex = al_fixtoi(Efi[num][0])*db/20;
               int ey = al_fixtoi(Efi[num][1])*db/20;
               int px = al_fixtoi(Efi[num][5])*db/20;
               int py = al_fixtoi(Efi[num][6])*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ex, ey, ex+db-1, ey+db-1, palette_color[13], 1);           // draw box to show pod location
               al_draw_filled_rectangle(px, py, px+db-1, py+db-1, palette_color[10]);       // draw box to show pod extended
               al_draw_line(ex+db/2, ey+db/2, px+db/2, py+db/2, palette_color[10], 1); // connect with line
               al_reset_clipping_rectangle();
            }
            break;
            case 98: // cloner destination
            {
               Ei[num][17] = dx;
               Ei[num][18] = dy;
               draw_big(1);
               show_big();
               draw_bs(14);
              // draw_cloner_boxes(num);
            }
            break;
            case 97: // set new rocket direction
            {
               draw_big(1);
               show_big();
               draw_bs(14);
               int ix = item[num][4]*db/20;
               int iy = item[num][5]*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ix, iy, ix+db-1, iy+db-1, palette_color[13], 1);                     // show rocket location
               al_draw_filled_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, palette_color[10]);   // show cursor
               al_draw_line(ix+db/2, iy+db/2, dx*db+db/2, dy*db+db/2, palette_color[10], 1);     // connect with line
               al_reset_clipping_rectangle();
            }
            break;
            case 96: // set cannon or bouncer direction
            {
               draw_big(1);
               show_big();
               draw_bs(14);
               int ex = al_fixtoi(Efi[num][0])*db/20;
               int ey = al_fixtoi(Efi[num][1])*db/20;
               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               al_draw_rectangle(ex, ey, ex+db-1, ey+db-1, palette_color[13], 1);                   // draw box to show enemy location
               al_draw_filled_rectangle(dx*db, dy*db, (dx+1)*db-1, (dy+1)*db-1, palette_color[10]); // draw box to show cursor
               al_draw_line(ex+db/2, ey+db/2, dx*db+db/2, dy*db+db/2, palette_color[10], 1);   // connect with line
               al_reset_clipping_rectangle();

            }
            break;
            case 4: // show lift
            {
               lift_steps[lift][step].x = dx*20;
               lift_steps[lift][step].y = dy*20;

               //  redraw
               set_lift_to_step(lift, step);   // set current step in current lift
               draw_big(1);
               show_big();
               draw_bs(14);            // show bullseye map

               al_set_clipping_rectangle(1, 1, display_transform_double*db*100-2, display_transform_double*db*100-2);
               highlight_current_lift(lift);   // crosshairs and rect on current lift
               al_reset_clipping_rectangle();
            }
            break;
         }
      } // end of if mouse on map

      al_set_target_backbuffer(display);

      // show text line
      al_draw_text(font, palette_color[10], txc, 80,  ALLEGRO_ALIGN_CENTER, txt);
      al_draw_text(font, palette_color[9],  txc, 88,  ALLEGRO_ALIGN_CENTER, "with left mouse button");
      al_draw_text(font, palette_color[14], txc, 120, ALLEGRO_ALIGN_CENTER, "Cancel");
      al_draw_text(font, palette_color[9],  txc, 128, ALLEGRO_ALIGN_CENTER, "with right mouse button");

      al_flip_display();
      al_clear_to_color(al_map_rgb(0,0,0));
      proc_controllers();

      title_obj(obj_type, sub_type, num, 0, 15);

      while (mouse_b1)
      {
         proc_controllers();
         quit = 1;
         retval = 1;  // b1 xy
      }
      while (mouse_b2)
      {
         proc_controllers();
         quit = 1;
         retval = 2;  // b2 xy
      }
      while (key[ALLEGRO_KEY_ESCAPE])
      {
         proc_controllers();
         quit = 1;
         retval = 0;  // ignore xy
      }
   } // end of while(!quit);


   if (dx > 99) dx = 99;
   if (dy > 99) dy = 99;

   if (retval != 1) // restore old positions if cancelled
   {
      if (obj_type == 2)
      {
         item[num][4] = original_dx;
         item[num][5] = original_dy;
         itemf[num][0] = al_itofix(original_dx);
         itemf[num][1] = al_itofix(original_dy);
      }
      if (obj_type == 3)
      {
          Efi[num][0] = al_itofix(original_dx * 20);
          Efi[num][1] = al_itofix(original_dy * 20);
      }

      if (obj_type == 99)
      {
          Efi[num][5] = al_itofix(original_dx * 20);
          Efi[num][6] = al_itofix(original_dy * 20);
      }

      if (obj_type == 98)
      {
          Efi[num][5] = original_dx;
          Efi[num][6] = original_dy;
      }

      if (obj_type == 4)
      {
         lift_steps[lift][step].x = original_dx * 20;
         lift_steps[lift][step].y = original_dy * 20;
         set_lift_to_step(lift, step);   // set current step in current lift
      }
   }
   return retval;
}

old getxy is gone....

should slso get rid of bx1...



now can I get rid of title....lifts needs it I think...
14 occurances...

get_trigger_item()
called by sliders for bm and bd

redo it like the others....

fix this too....done
find_and_show_event_links(num);

this looks great...check if it works for lifts....

did a bunch of stuff to make it work for lifts...
show event links works great...
does not work for plain lift viewer because that still uses 100 map for now...




so back to what I was doing....

get trigger item is done....now uses new scaleable map and does not use title object_viewer

now get_item()

used only by doors to get linked door...done...


now what is left for title_obj()...?
draw and redraw lift_viewer...
a bunch of comment out stuff from the old object_viewer()...

hack it up so that only lift can use it...


this is all that is left....

void title_obj(int obj_type, int sub_type, int num, int legend_highlight, int highlight_color)
{
   al_draw_rectangle(0, 0,  SCREEN_W-1, SCREEN_H-1, palette_color[13], 1);         // outline screen
   al_draw_rectangle(0, 0, 100*db-1, 100*db-1, palette_color[13], 1);              // outline map
   al_draw_rectangle(100*db-1, 0,  SCREEN_W-1, SCREEN_H-1, palette_color[13], 1);  // outline side panel

   show_big();
   title("Lift Viewer",  0, 15, 13);

   int lift = sub_type;
   al_draw_rectangle(txc-90, 20, txc+90, 43, palette_color[15], 1);
   al_draw_textf(font, palette_color[13], txc, 29, ALLEGRO_ALIGN_CENTER, "Lift %d of %d",lift+1, num_lifts);
}

moved to e_lifts.cpp and renamed:

void title_lift(int lift)
{
   al_draw_rectangle(0, 0,  SCREEN_W-1, SCREEN_H-1, palette_color[13], 1);         // outline screen
   al_draw_rectangle(0, 0, 100*db-1, 100*db-1, palette_color[13], 1);              // outline map
   al_draw_rectangle(100*db-1, 0,  SCREEN_W-1, SCREEN_H-1, palette_color[13], 1);  // outline side panel
   show_big();
   title("Lift Viewer",  0, 15, 13);
   al_draw_rectangle(txc-90, 20, txc+90, 43, palette_color[15], 1);
   al_draw_textf(font, palette_color[13], txc, 29, ALLEGRO_ALIGN_CENTER, "Lift %d of %d",lift+1, num_lifts);
}

now all of object_viewer() is commented out....removed from project...yay!!

bx1 stuff...that global has been removed!!! yay!!


now what...



group edit was very easy.....

flash of item on level buffer does not work??
mouse on item in map make list flash, but not the other way...fixed by redordering

do not show crosshairs when show selection...done

do not show crosshairs when on windows...

made flash color global...

make the windows moveable....
how many windows do I have?

filters
list
ge_actions
buttons

move them all at once for now...
with the title bar...

make a way to get sizes of all the windows...

title bar is easy, it is 300 wide and 15 high

redo filter so that sizes are right...done
same with object list...done
what I mean is that the x and y are the actual sizes and not offset by frame..


now make it so that I can drag the whole thing....done



group edit to do:

make it easy to clear the list.

make it easier to add..like..set filters then selection could add automatically...

make it so that I can line up a group of enemies...
set the y values to all the same..
set the x in a increment thing...
right now that is not possible...

removed e_group_edit.cpp from sources....



next big thing....
lift viewer to match object viewer...
would that not be so awesome if they were one and the same
lift viewer if 400 LOC and the map move part is 200 of that....




// ----------------------------------------------------------------------
// ------------there are multiple ways to pass pointers....
// ----------------------------------------------------------------------


this is one way:
-------------------------------------------
int gx=0, gy=0, hx=0, hy=0;
ovw_get_block_position_on_map(&gx, &gy, &hx, &hy);

void ovw_get_block_position_on_map(int*x, int*y, int *hx, int *hy)
{
   *x = (int) mx4;
   *y = (int) my4;


this is another way:
-----------------------------------------
int mdw_toggle(int x1, int y1, int x2, int y2,
                int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7,
                  int &var, const char* t0, const char* t1 , int text_col0, int text_col1, int frame_col0, int frame_col1)

mdw_toggle(x1+fs, y+a*bts, x2-fs, y+(a+1)*bts-2, 1000, 0,0,0,0,0,0,0,1,0,0,0, obj_filter[2][5],  "Start",  "Start",  tc1, tc2, fc1, fc2); a++;



and this is an int, passed as an int to a different function, then that function in its parameters casts it to a pointer and send it to another function
------------------------------------------------------------------------------------------------------------------------------
void group_edit(void)
{
   int show_sel_frame = 1;
   ge_draw_on_screen_buffer(ge_window_x, ge_window_y, show_sel_frame);

int ge_draw_on_screen_buffer(int xa, int ya, int &show_sel_frame)
{
   mdw_toggle(bpx1+2, bpy1, bpx1+110, bpy2, 1000, 0,0,0,   0,0,0,0,1,0,0,0, show_sel_frame,  "Selection:OFF", "Selection:ON ", 15, 15, 15+64, 14);



20220502 6:20 AM

cleaned up object_viewerw() main function....
moved out map move and a few others...

now it is only 270 lines....
150 for button retvals and keys

it getting lean....

I am thinking of merging the lift viewer code into it....

it will be awesome....

20220502 7:22 PM

got lift map move to work in obv...!!!

pasted in the buttons, step list and current step details...

now I need to:

run lifts button replaces move...done
make all the upper buttons work...done


make sure everything stil works
clicking step in list does not set that step to current...fixed

make sure popup menus work and are in the right place...

do not let lift step buttons draw past right edge....done

run lifts gets stick on event trigger steps...
make it so that mouse in trigger box triggers
same for player in prox setp...

dynamic height with background erasing...
finally hacked together something that works for dynamic size and erase

int ovw_draw_buttons(int num, int type, int obt)
draws the default buttons
then calls  obj_buttons()??
why not combine??
why keep separate?


now I want to narrow the whole thing....done...down to 300 wide and looking good
Current Step (0) Details
First line has the long text description
second line
in list, change the details for move to:
and Resize Speed:50

object_viewer_window.cpp has 2300 lines
e_lifts.cpp has 600 lines


ovw dissappears when mouse_move is on....fixed...
legend lines have transparent background.....not erasing enough...fixed...

lift color does not update when changing step color, need to redraw something...fixed


test add lift steps and shit like that for updating screen...
pop-up menu for insert step....fixed that, I think..just made its position mouse_x and mouse_y


20220504 6:31 AM
got to go ...push


I need to make something like a redraw object viewer function...
so I can call it when I am in the middle of adding lifts steps

also can call it when I am moving window, or map moving things...




this is from line 1947 at the end of map_move...

         al_flip_display();
         proc_scale_factor_change();
         proc_controllers();
         proc_frame_delay();

         if (obt == 4) init_level_background(); // to draw new lift lines

         get_new_background(0);
         draw_lifts();
         draw_items();

         // if current object is messages, show all messages
         if ((obt == 2) && (type == 10))
         {
            for (int i=0; i<500; i++)
               if (item[i][0] == 10) draw_pop_message(i);
         }

         draw_enemies();
         ovw_draw_overlays(obt, num, 0);
         get_new_screen_buffer(3, obj_x, obj_y);


this is from window move
            al_flip_display();
            proc_scale_factor_change();
            proc_controllers();
            proc_frame_delay();

            get_new_background(0);

            draw_lifts();
            draw_items();
            draw_enemies();
            ovw_draw_overlays(obt, num, 0);
            get_new_screen_buffer(3, 0, 0);

            ovw_draw_buttons(num, type, obt);
            ovw_title(obt, num, 0);




this is from the main object viewer

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
      proc_frame_delay();

      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();

      ovw_draw_overlays(obt, num, legend_line);

      // if current object is message, show all messages
      if ((obt == 2) && (type == 10))
      {
         for (int i=0; i<500; i++)
            if (item[i][0] == 10) draw_pop_message(i);
      }

      get_new_screen_buffer(3, obj_x, obj_y);

      int mb = ovw_draw_buttons(num, type, obt);
      ovw_title(obt, num, 0); // draw button title, frame and legend lines



this is from insert lift_step

      al_flip_display();
      proc_scale_factor_change();
      proc_controllers();
      proc_frame_delay();
      get_new_background(0);
      draw_lifts();
      draw_items();
      draw_enemies();
      ovw_draw_overlays(4, lift, 0);
      get_new_screen_buffer(3, 0, 0);

      ovw_draw_buttons(lift, 0, 4);
      ovw_title(4, lift, 0); // draw button title, frame and legend lines



what am I going to call it

int ovw_redraw_background(int obt, int type, int num, int legend_line, int show_window)
{
   al_flip_display();
   proc_scale_factor_change();
   proc_controllers();
   proc_frame_delay();
   if (obt == 4) init_level_background(); // to draw new lift lines
   get_new_background(0);
   draw_lifts();
   draw_items();
   draw_enemies();

   ovw_draw_overlays(obt, num, legend_line);

   // if current object is message, show all messages
   if ((obt == 2) && (type == 10))
   {
      for (int i=0; i<500; i++)
         if (item[i][0] == 10) draw_pop_message(i);
   }

   get_new_screen_buffer(3, 0, 0);

   int mb = 0;
   if (show_window)
   {
      mb = ovw_draw_buttons(num, type, obt);
      ovw_title(obt, num, 0); // draw button title, frame and legend lines
   }
   return mb;
}

replaced in all 4 places...


now look at lift creator...fixed...


when inserting lifts steps

-blue title list of steps ypos is too low...fixed
-frame y2 is not correct until done...done..run redraw twice to get proper height



I think I have the lift viewer stuff all done.. seems to work very nicely...


what should I do next??

zoom full screen?

main editor?


even before that I could re do the status window...

I want to show something like the button list, but probably custom, smaller and read only...

at the top of the screen I want to have a collapsable filter window with lots of options...

each indivdual item and enemy
lifts
block and block flags

these would apply to viewer to filter what could be selected, or shown.


20220505



re enable bookmarks...done
can be in object viewer with obt and num
save in object viewer
load and auto load in edit_menu
all works good...


save positions of windows in cfg file just like status and sel...
group edit, and ovwindow...



zoom full screen....
make the side panel into a moveable window
call it something else...rectangular copy paste



do something about display_transform_double
make it automatic or manual and in cfg file...



void auto_set_display_transform_double(void)
{
   display_transform_double = 2;

/*
   display_transform_double = 1;

   if (disp_w_curr > 1023) display_transform_double = 2;
   if (disp_h_curr > 1023) display_transform_double = 2;

   if (disp_w_curr < 1024) display_transform_double = 1;
   if (disp_h_curr < 700)  display_transform_double = 1;

   if (level_editor_running) display_transform_double = 1;

   if (help_screens_running)
   {
      if (disp_w_curr > 1279) display_transform_double = 2;
      if (disp_w_curr < 1280) display_transform_double = 1;
   }
   */
   set_display_transform();
   set_map_var();
}


where is it called?
init_display(void)
proc_display_change(void)
help start and exit
why on help??
comment those out...



this is at the start of edit_menu:

   int original_display_transform_double = display_transform_double;

//   int target_display_transform_double = 1; // this is the orig

   int target_display_transform_double = original_display_transform_double; // this is the hacked line

   if (disp_w_curr > 3800) target_display_transform_double = 2;
   if (display_transform_double != target_display_transform_double)
   {
      display_transform_double = target_display_transform_double;
      set_display_transform();
      set_map_var();
   }


this is at the end...

   if (original_display_transform_double != display_transform_double)
   {
      display_transform_double = original_display_transform_double;
      set_display_transform();
      set_map_var();
   }

comment those out too...done



now I want to save just a single variable in cfg file for this...

if -1 then autoset, otherwise it is display_transform_double




remove all calls to:
auto_set_display_transform_double()

and replace them with calls to:
set_display_transform()


then call:
auto_set_display_transform_double()

only from from:
set_display_transform()


pass a value to set_display_transform()

if 1-3 then set that
if -1 then auto...

need a global variable for value saved in config file


saved_display_transform_double


when called most of the time, use saved_dtd to set dtd...
that could be a forced value or -1 for auto


when called with a forced value, set saved_dtd to that value


most calls will be 0...
only when changing with F12 use a forced val...

this is getting complicated....


lets me try to simplify:

you can set the variable "saved_display_transform_double" in the config file or CTRL-SHIFT-F12

(1, 2, 3) - forces the specific value for display_transform_double
0 lets it be set automatically



20220506 6:20 AM
started converting zfs to the same scaled background stuff..
made all buttons and controls into a moveable window


20220507 5:00 AM
making good progress on zfs...

make the paste selection bitmap work....


how about taking it directly from level background?

should I aleady have level background hide items, enemies, etc if not selected??

I made it work with only one line:
al_draw_bitmap_region(level_buffer, stx*20, sty*20, sw*20, sh*20, gx*20, gy*20, 0);

now I want to filter it to only show what actually will be pasted...

I think I will need ft_bmp for that...
I want the level background to show everything
so that means my copying a region of it and excluding things will not work as is..


made it work...


void draw_fsel(void)
{
   if (copy_blocks)
   {
      init_level_background();
      get_new_background(0);
   }
   else
   {
      al_set_target_bitmap(level_buffer);
      al_clear_to_color(al_map_rgb(0,0,0));
   }


   if (copy_items) draw_items();
   if (copy_enemies) draw_enemies();
   if (copy_lifts) draw_lifts();


   int sw = sux-stx;
   int sh = suy-sty;
   al_destroy_bitmap(ft_bmp);
   ft_bmp = al_create_bitmap(sw*20, sh*20);
   al_set_target_bitmap(ft_bmp);
   al_clear_to_color(al_map_rgb(0,0,0));
   al_draw_bitmap_region(level_buffer, stx*20, sty*20, sw*20, sh*20, 0, 0, 0);
}

void zfs_redraw_background(int gx, int gy)
{
   al_flip_display();
   proc_scale_factor_change();
   proc_controllers();
   proc_frame_delay();
   get_new_background(0);
   draw_lifts();
   draw_items();
   draw_enemies();

   zfs_show_level_buffer_block_rect(stx, sty, sux, suy, 14, "selection");

   if (copy_mode)
   {
      int sw = sux-stx;
      int sh = suy-sty;
      al_draw_bitmap(ft_bmp, gx*20, gy*20, 0);
      zfs_show_level_buffer_block_rect(gx, gy, gx+sw, gy+sh, 10, "paste");
   }
   get_new_screen_buffer(3, 0, 0);
}


I would really like the selection to show as transparent when block are not being copied....

in order to make that work...
I need to create level_buffer like this:

   // create level_background and level_buffer bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
// al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);
   level_background = al_create_bitmap(2000,2000);
   level_buffer = al_create_bitmap(2000,2000);
//   printf("level_background\n");
//   show_pixel_format(al_get_bitmap_format(level_background));
//   show_bitmap_flags(al_get_bitmap_flags(level_background));

   // reset defaults to use for new bitmaps
   al_set_new_bitmap_format(ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA);
   al_set_new_bitmap_flags(ALLEGRO_NO_PRESERVE_TEXTURE | ALLEGRO_VIDEO_BITMAP);

then when I use it to create ft_bmp I need to clear it like this:
//al_clear_to_color(al_map_rgb(0,0,0));
al_clear_to_color(al_map_rgba(0,0,0,0));

then when I create ft_bmp I need to:
al_clear_to_color(al_map_rgba(0,0,0,0));

were all of these changes worth it?

pro's
- now all bitmaps are created with the same format

con's
- might use a little more memory

do it for now, but leave options to revert....

what is left?
- implement scroll...done


I think everything is working...

do some code cleanup and test....

// e_editor_zfs.h
void zfs_pointer_text(int x, int y, int ty);
void zfs_do_brf(int x, int y, int flood_block);
void zfs_clear_ft(void);
int zfs_load_selection(void);
void zfs_save_selection(int save);
int enforce_limit(int val, int ll, int ul);
int check_limit(int val, int ll, int ul);
void zfs_do_fcopy(int qx1, int qy1);
void zfs_do_clear(void);
void zfs_draw_selection_filters(int x1, int y1, int x2);
void zfs_draw_buttons(int x3, int x4, int yfb);
void zfs_proc_window_move(int *x1, int *y1, int *x2, int *y2, int w, int h);
void zfs_draw_fsel(void);
void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
void zfs_redraw_background(int gx, int gy);
int zfs_redraw_window(int zfs_window_x1, int zfs_window_y1, int zfs_window_x2, int zfs_window_y2, int gx, int gy);
int zoom_full_screen(int wx, int wy, int draw_item);


does anything in zfs use ty, bts..no mention at all....

what globals does it use?

extern int stx;
extern int sty;
extern int sux;
extern int suy;

extern int copy_blocks;
extern int copy_enemies;
extern int copy_items;
extern int copy_lifts;
extern int copy_flags;
extern int copy_mode;
extern int brf_mode;

extern int ft_level_header[20];
extern int ft_l[100][100];
extern int ft_item[500][16];
extern char ft_pmsgtext[500][500];

extern int ft_Ei[100][32];
extern al_fixed ft_Efi[100][16];

extern char ft_ln[NUM_LIFTS][80];
extern int ft_lift[NUM_LIFTS][6];
extern int ft_ls[NUM_LIFTS][40][6];


what would happen if I put some in the file zfs?
I moved all these to the start of e_editor_zfs and it compiles clean....

int copy_blocks=1;
int copy_enemies=1;
int copy_items=1;
int copy_lifts=1;
int copy_flags=1;
int copy_mode = 0;
int brf_mode =0;

int ft_level_header[20];
int ft_l[100][100];
int ft_item[500][16];
char ft_pmsgtext[500][500] = {0};


int ft_Ei[100][32];
al_fixed ft_Efi[100][16];

char ft_ln[NUM_LIFTS][80];
int ft_lift[NUM_LIFTS][6];
int ft_ls[NUM_LIFTS][40][6];


all that is left is these:
extern int stx;
extern int sty;
extern int sux;
extern int suy;

they are shared with group_edit...

do they need to be?  no....
but its nice that the selection is persitant between those two functions so I'm going to leave it

in block floodfill mode, show selected block...done


I am done with zfs..


move on to the hugest one of all...editor_main....

20220507 8:20 AM..
make point item blink on level background....



select_bitmap uses some shit from editor_main...
process_scrolledge();
update_editor_background();

lets fix that first
then remove...done


now I am working on showing the draw item....


there are a lot of function that are all doing close to the same thing



draw_item...get item shape...etc...



I want one function that when you pass it item number, it will draw the item...
either where it belongs in the level, or an arbitary x and y

in all cases, draw on whatever bitmap is active...

void draw_item(int i, int default, int x, int y, float scale);


this can be called by the main game draw_items..like:
 i, 1, 0, 0, 0)


I have gotten rid of the extra draw item stuff and now only use:
void draw_item(int i, int custom, int cx, int cy)

what about enemies? done also...

now that all looks good and much extra duplicated code has been removed....

why do I get a crash when putting draw item? i and e only not block....fixed...


what about the section where you draw under the windows...done...

what about multiple selected objects...seems like its working as well as it did before...


only 900 lines...and 235 are for setblockrange...

clean up function names..done..

// e_editor_main.h
void em_set_block_range(int bx1, int by1, int bx2, int by2);
void em_get_new_box(int*bx1, int*by1, int*bx2, int*by2);
char* em_get_text_description_of_block_based_on_flags(int flags);
void em_show_draw_item_cursor(void);
void em_draw_item_info(int x, int y, int color, int type, int num);
int edit_menu(int el);

now only 850 lines....


what globals does this use...
int draw_item_num;
int draw_item_type;
int point_item_type;
int point_item_num;










int move_pod_extended(int num)
{
   if (getxy("Pod Extended Position", 99, 7, num) == 1) return 1;
   else return 0;
}

replace with just: getxy("Pod Extended Position", 99, 7, num)


int move_trigger_box(int num, int type)
{
   if (get_block_range("Trigger Box", &Ei[num][11], &Ei[num][12], &Ei[num][13], &Ei[num][14], 2)) return 1;
   else return 0;
}

replace with just:
get_block_range("Trigger Box", &Ei[num][11], &Ei[num][12], &Ei[num][13], &Ei[num][14], 2)


ty is gone!!!

bts??

don't kill them all, just the global ones...

there are a lot of them especially in lifts...I'll come back to this...
zfs paste crashes....fixed

level disappears when moving status and selection window..fixed

erase background under flags

I am going to make status window do its own detection of mouse on window...done

make sel window take pointer parameter instead of convoluted return values


holy shit...under 50 lines!

int edit_menu(int el)
{
   al_show_mouse_cursor(display);
   level_editor_running = 1;
   resume_allowed = 0;
   draw_item_type = 1;
   draw_item_num  = 0;
   check_s_window_pos(0);
   load_PDE();
   sort_enemy();
   sort_item();
   set_swbl();
   set_frame_nums(0);
   for (int k = ALLEGRO_KEY_A; k < ALLEGRO_KEY_MAX; k++) key[k] = 0; // clear_key array
   int quit=0, mouse_pointer_on_window=0;
   int gx=0, gy=0, hx=0, hy=0;
   if (!el) load_level_prompt(); // load prompt
   else load_level(el, 0);       // blind load
   if (autoload_bookmark)
   {
      printf("load bookmark\n");
      if (bookmark_level == last_level_loaded)
      {
         if ((bookmark_obj == 2) && (item[bookmark_num]))       object_viewerw(2, bookmark_num);
         if ((bookmark_obj == 3) && (Ei[bookmark_num]))         object_viewerw(3, bookmark_num);
         if ((bookmark_obj == 4) && (bookmark_num < num_lifts)) object_viewerw(4, bookmark_num);
      }
   }
   while (!quit)
   {
      ovw_process_scrolledge();
      ovw_get_block_position_on_map(&gx, &gy, &hx, &hy);
      em_redraw_background(gx, gy);
      mouse_pointer_on_window = 0;
      if (status_window_active) process_status_window(0, gx, gy, &mouse_pointer_on_window);
      if (select_window_active) process_select_window(0, &mouse_pointer_on_window);
      if (!mouse_pointer_on_window) // mouse pointer is not on window
      {
         em_find_point_item(gx, gy, hx, hy);
         if (mouse_b1) em_process_mouse_b1(gx, gy);
         if (mouse_b2) quit = em_process_mouse_b2(gx, gy);
      }
      else point_item_type = -1; // to mark that
      quit = em_process_keypress();
   }
   level_editor_running = 0;
   al_hide_mouse_cursor(display);
   return last_level_loaded;
}


OK edit menu is looking really good....now what?

status window:

- somehow accomodate the button lists....
- erase background for flags..
- maybe make some buttons to turn on and off the more detailed shit...like buttons and flags...


PDE...can you redo it?...why?..its only ~500 self contained lines..

move status and select windows to their own file
or stick them in with editor...yes do that....done

db is gone...

z_map.cpp
omg...i did not even know this was still in the sources!  wow!....
I am removing so much stuff....


20220507 8:02 PM
code stats:
code stats:
39 files
23126 code only
 6983 empty lines
 4023 comment lines
 4331 code and comments
38463 total


--------

where are the flags drawn?


ftx text x
tfy text y

frx - tfx-frw-2

   if ((show_flag_details) && (draw_item_type == 1))
   {
      // flags section
      int ftx = swx1+11;
      int fty = swy1+47;
      int ys = 10; // y spacing
      draw_flag_text(ftx+4, fty, ys, 15, 0);

      int frw = 6;         // flag rectangle width
      int frh = 6;         // flag rectangle height
      int frx = ftx-frw-2;        // flag rectangle x
      int fry = fty - (frh/2)+4;  // flag rectangle y

      draw_and_proc_flag_rects_draw_item(frx, fry, frw, frh, ys);


      int frx2 = frx+frw;
      int fry2 = fty+frh+(ys*13);

      frx  -=2;
      frx2 +=2;
      fry  -=2;
      fry2 +=4;

      if ((mouse_x > frx) && (mouse_x < frx2) && (mouse_y > fry) && (mouse_y < fry2))
      {
         *mpow = 1;
         al_draw_rectangle(frx, fry, frx2, fry2, palette_color[14], 1);
      }
   }


I'm going to change all of this
from now on, you just draw the rectangle and pass x and y
the text will automatically be called..
int draw_flags(int x1, int y1)
done and it looks good...
I have a dilemma...
when on a window, the flags don't show, the point item flags dissappear then a block is selected as point item
and the flags reappear
just don't do mpow...done
now all the flag drawing for draw item, point item and block select all use the same function..



maybe a second line in status window
ore controls like:
simple/detailed descriptions
sndb on/off
save
zfs
ge

make button list better...its as good as it gets

I really want to get a handle on the proliferation of globals and find an elegant way to encapsulate them...


20220508 - 6:00 AM

bug...items are all messed up with number like 42 of 0...fixed
sort was done before load level at start of edit menu



in all of these level editor map things I want a thin line to show the edge of the level if smaller than the screen...done



bug...group edit, when mouse on list, flash on screen..
when highlight are show in draw on level buffer, they are cleared first..
when this is removed it works, but they need to be cleared somehwere...
fixed by on checking for mouse on item in map if mouse not on window



--make the copying of items secondary things like keys block range work like map move with holding shift
instead of native pop up prompts.

tried to copy from zfs but that was wrong too...

make a txt file that describes all the different rectangles and formats...done...

now fix it...I have made em copy move the stuff correctly....

lets actually change all the things to a common format....

very easy should be pmg
position from 100 to 2000


do a glt thing to muliply all 10 and 11 by 20...done
changed void draw_pop_message(int i)
they work fine in game...

map move....done...
adjust in ov...follow button to getxy and fixed there...
create...works fine
edit text...all good...one done!!!
wait!!! what about:

obv move main item..msg should follow....
copy with em...done..moves msg too
copy with zfs...not yet...
in zfs you have to adjust when saving and loading...done
copy with cloner...

secondary items move:
msg
k t m d

em copy....done
zfs paste...done
ov map move..done
cloner copy..only message text was changed nothing adjusted

ok items should be all done...


next do pod and cloner trigger
range and w h
this could take some time

x1 = Ei[][11];
y1 = Ei[][12];
x2 = Ei[][13];
y2 = Ei[][14];

glt line....


      for (y=0; y<100; y++)
         if ((Ei[y][0] == 7) || (Ei[y][0] == 9))
         {
            int w = Ei[y][13] - Ei[y][11];
            Ei[y][11] *= 20;
            Ei[y][13] = w*20;

            int h = Ei[y][14] - Ei[y][12];
            Ei[y][12] *= 20;
            Ei[y][14] = h*20;

         }

backup levels and pull the trigger.....done...

now where to start...


void enemy_cloner(int e)

old:
   int x4 = Ei[e][11]*20 - 10; // trigger box
   int y4 = Ei[e][12]*20 - 10;
   int x5 = Ei[e][13]*20 + 10;
   int y5 = Ei[e][14]*20 + 10;

new:
   int x4 = Ei[e][11] - 10; // trigger box
   int y4 = Ei[e][12] - 10;
   int x5 = Ei[e][11] + Ei[e][13] + 10;
   int y5 = Ei[e][12] + Ei[e][14] + 10;


draw cloner...

old:
      // trigger box
      float tx1 = (float)Ei[e][11]*20;
      float ty1 = (float)Ei[e][12]*20;
      float tx2 = (float)Ei[e][13]*20+20;
      float ty2 = (float)Ei[e][14]*20+20;
new:
      // trigger box
      float tx1 = (float)Ei[e][11];
      float ty1 = (float)Ei[e][12];
      float tx2 = (float)(Ei[e][11]+Ei[e][13]+20);
      float ty2 = (float)(Ei[e][12]+Ei[e][14]+20);

void ovw_draw_overlays(int obt, int num, int legend_highlight)

pod old:
            int tx1 = Ei[num][11]*20;
            int ty1 = Ei[num][12]*20;
            int tx2 = Ei[num][13]*20 + 20;
            int ty2 = Ei[num][14]*20 + 20;
pod new:
            int tx1 = Ei[num][11];
            int ty1 = Ei[num][12];
            int tx2 = Ei[num][11]+Ei[num][13] + 20;
            int ty2 = Ei[num][12]+Ei[num][14] + 20;

same for cloner


void ovw_map_move(int &obt, int &num)
old:
            int x1 = Ei[b][11]*20;
            int y1 = Ei[b][12]*20;
            int x2 = Ei[b][13]*20+20;
            int y2 = Ei[b][14]*20+20;
new:
            int x1 = Ei[b][11];
            int y1 = Ei[b][12];
            int x2 = Ei[b][11]+Ei[b][13]+20;
            int y2 = Ei[b][12]+Ei[b][14]+20;



old:
         if (mouse_on_tb_ul) // move trigger box from ul
         {
            //printf("mouse pressed on tb_ul\n");
            // get the width and height
            int w = Ei[num][13] - Ei[num][11];
            int h = Ei[num][14] - Ei[num][12];
            // set new position
            Ei[num][11] = gx;
            Ei[num][12] = gy;
            Ei[num][13] = gx+w;
            Ei[num][14] = gy+h;
new:
         if (mouse_on_tb_ul) // move trigger box from ul
         {
            //printf("mouse pressed on tb_ul\n");
            Ei[num][11] = gx*20;
            Ei[num][12] = gy*20;
         }


old:
         if (mouse_on_tb_lr)  // resize trigger box from lr
         {
            // prevent lr corner from being less than ul corner
            if (gx < Ei[num][11]) gx = Ei[num][11];
            if (gy < Ei[num][12]) gy = Ei[num][12];
            // set new postion
            Ei[num][13] = gx;
            Ei[num][14] = gy;
         }

new:
         if (mouse_on_tb_lr)  // resize trigger box from lr
         {
            // prevent lr corner from being less than ul corner
            if (gx < Ei[num][11]/20) gx = Ei[num][11]/20;
            if (gy < Ei[num][12]/20) gy = Ei[num][12]/20;
            // set new postion
            Ei[num][13] = gx*20 - Ei[num][11];
            Ei[num][14] = gy*20 - Ei[num][12];
         }



old:
               if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT])) // move stuff also
               {
                  // move podzilla's trigger box too
                  if (Ei[num][0] == 7)
                  {
                     Ei[num][11] += x_off;
                     Ei[num][12] += y_off;
                     Ei[num][13] += x_off;
                     Ei[num][14] += y_off;
                  }
                  // move cloner's stuff too
                  if (Ei[num][0] == 9)
                  {
                     Ei[num][11] += x_off; // trigger box
                     Ei[num][12] += y_off;
                     Ei[num][13] += x_off;
                     Ei[num][14] += y_off;


new:
               if ((key[ALLEGRO_KEY_LSHIFT]) || (key[ALLEGRO_KEY_RSHIFT])) // move stuff also
               {
                  // move podzilla's trigger box too
                  if (Ei[num][0] == 7)
                  {
                     Ei[num][11] += x_off*20;
                     Ei[num][12] += y_off*20;
                  }
                  // move cloner's stuff too
                  if (Ei[num][0] == 9)
                  {
                     Ei[num][11] += x_off*20; // trigger box
                     Ei[num][12] += y_off*20;
                     Ei[num][15] += x_off; // source
                     Ei[num][16] += y_off;
                     Ei[num][17] += x_off; // dest
                     Ei[num][18] += y_off;
                  }


all that seem to work great:

now onto
em_copy
old:
            if (al_show_native_message_box(display, "Move?", "Move podzilla's trigger box too?", NULL, NULL, ALLEGRO_MESSAGEBOX_YES_NO | ALLEGRO_MESSAGEBOX_QUESTION ) == 1)
            {
               Ei[c][11] = Ei[din][11] + ofx/20;
               Ei[c][12] = Ei[din][12] + ofy/20;
               Ei[c][13] = Ei[din][13] + ofx/20;
               Ei[c][14] = Ei[din][14] + ofy/20;

new:
               Ei[c][11] = Ei[din][11] + ofx;
               Ei[c][12] = Ei[din][12] + ofy;

same for cloner...tested








zfs_copy

old save:

            if (ft_Ei[c][0] == 7 ) // podzilla
            {
               ft_Ei[c][11]-= x1/20;
               ft_Ei[c][12]-= y1/20;
               ft_Ei[c][13]-= x1/20;
               ft_Ei[c][14]-= y1/20;
            }
            if (ft_Ei[c][0] == 9 ) // cloner
            {
               ft_Ei[c][11]-= x1/20;
               ft_Ei[c][12]-= y1/20;
               ft_Ei[c][13]-= x1/20;
               ft_Ei[c][14]-= y1/20;

new save:
            if (ft_Ei[c][0] == 7 ) // podzilla
            {
               ft_Ei[c][11]-= x1;
               ft_Ei[c][12]-= y1;
            }
            if (ft_Ei[c][0] == 9 ) // cloner
            {
               ft_Ei[c][11]-= x1;
               ft_Ei[c][12]-= y1;

old fcopy:
                  if (Ei[c][0] == 7) // podzilla trigger box
                  {
                     Ei[c][11]+= x3/20;
                     Ei[c][12]+= y3/20;
                     Ei[c][13]+= x3/20;
                     Ei[c][14]+= y3/20;
                  }
                  if (Ei[c][0] == 9) // cloner
                  {
                     Ei[c][11]+= x3/20;
                     Ei[c][12]+= y3/20;
                     Ei[c][13]+= x3/20;
                     Ei[c][14]+= y3/20;

new fcopy:
                  if (Ei[c][0] == 7) // podzilla trigger box
                  {
                     Ei[c][11]+= x3;
                     Ei[c][12]+= y3;
                  }
                  if (Ei[c][0] == 9) // cloner
                  {
                     Ei[c][11]+= x3;
                     Ei[c][12]+= y3;

that works flawlessly


create and move with buttons...done

in: int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2, int type)
could modified type 2 only used for this

or I can try type 1...
size is off by one

modify type 2 then...done...


now on to cloner source and dest and then I will be done....


glt line:

      // converting cloner source and dest from 100 xywh to 2000 xywh format
      for (int y=0; y<100; y++)
         if (Ei[y][0] == 9)
         {
            Ei[y][15] *= 20;
            Ei[y][16] *= 20;
            Ei[y][17] *= 20;
            Ei[y][18] *= 20;
            Ei[y][19] *= 20;
            Ei[y][20] *= 20;
         }



backup levels and do it...





void enemy_cloner(int e)
draw cloner
void ovw_draw_overlays(int obt, int num, int legend_highlight)
map move...
all done...

I think this is all done....

now all rects have the same format

implement the shift thing in em copy...done




filter for object viewer..controls what the map move snaps to...
i, e, l and sub types...
i picture clicking on the top bar and a drop down filter list will pop up...

this will be used by more than just viewer
ge has one
zfs has one

I want to make a common very good one

ge has the most detailed one

could right click on it and get a popup menu:
clear all
clear all items
clear all enemies
set all enemies
set all items

It should also have lifts, blocks and block flags,
altough they won't be needed in every case, but they can be turned on and off as needed.

What variable structure?


int obj_filter[4][20] = {0};

change this to 5 and make it global

1 block
2 item
3 enemy
4 lift



ge - item and enemies only
ov - item, enemies, lifts
zfs - everything
em - ???

pass an int mode

now show it in ov

now use it in ov
map move....

that is fucking awesome...


now I want to be able to collapse it and stick it on the top border


it should be easy to use it for zfs also...

lifts, block and flags already have corresponding buttons

the only difference will be to filter for item and enemy types

but before I do that...
i want to make it an independant window
moveable, collapseable, resizable
is there a case for making this a structure?
all variables could be contained there.
and all in one source file

first of all it needs its own x and y positions
and hidden or not..

int ft_window_x1 = 100;
int ft_window_x1 = 180;
int ft_window_y1 = 200;
int ft_window_collapsed = 0;




i ran into a problem when one window is on top of another..
you would expect the window on top to be the active one, but..
on top just means it was draw last...
the one underneath that was drawn first will eat the mouse clicks first...


20220508
got filter window to work
it moves and it collapseable...
need to figure out how to make only one window get mouse when more than one overlap and are active
once i figure that out the rest of the window stuff will work

I might have to do more window management stuff, but it might be worth it in the end.

i also have to do something to make sure all these new moveable window are not off

redo push..crashed last time..hope it's ok










to solve my window problem....

I need to get more complex...

each window should be like an object..a C++ object...

it should have its own variables, methods, etc...

it should keep track of its position and size..

it should have a method to draw itself and a separate method to accept input

lets see what I can do with this, with the filter window....

class mWindow
{
   public:
   int x1, y1, x2, y2, w, h;
   void set_pos(int, int);
   void set_size(int, int);
};

void mWindow::set_pos(int x, int y)
{
   x1 = x;
   y1 = y;
   x2 = x + w;
   y2 = y + h;
}

void mWindow::set_size(int sw, int sy)
{
   w = sw;
   h = sh;
   x2 = x + w;
   y2 = y + h;
}

where do I declare it?
in pm.h

20220510 6:00 AM

Some thought on windows..

declare an array of them so they can be accessed in a loop

each one will have properties like:

active
has_focus
draw_order
moveable

'active'
used to determine if the window is shown or hidden
if not active the window is completely ignored, not drawn or processed at all
I am thinking that only one should accept input at a time
and I am thinking of enfocring that by only allowing one to have focus

'has_focus'
if the mouse moves to another window, that window will grab focus
when a window has focus, show it with a frame highlight
if the mouse is on multiple windows do not change focus
only when the mouse is on only one window
only the window that has focus can accept input or be moved

'draw_order'
maybe not needed as long as window that has fcous is drawn last



when they are called in a loop, the entire edit menu will change...

- draw level background, but customized, based on what edit_mode we are in
- process the window loop that draws and accepts input from all the active windows
- process mouse click and drags on the background based on what mode we are in..


the modes will be:
- edit menu
- group edit
- object viewer
- zfs

I will have a separate file for each window...
status
select
filter
object_viewer
zfs action
group edit list
group edit buttons

- edit menu
status
select

- group edit
filter
group edit list
group edit buttons

- object viewer
filter
object_viewer

- zfs
filter
zfs action


Then I can do things with each window like:
resizeable or not
moveable or not
collapseable or not
dockable to the frame

Then I can implement a method to ensure they are not off the edges of the screen

This will be a major re-write, but I think it will be worth it.

Buttons and slider will all have to be modified.
They need a variable they are passed that tells them to draw only or draw and process mouse clicks




I cannot get clipping to work....probably has something to do with display transform

   /*

   int cx, cy, cw, ch;
   al_get_clipping_rectangle(&cx, &cy, &cw, &ch);
   printf("1 - x:%d y:%d w:%d h:%d\n", cx, cy, cw, ch);



   al_set_clipping_rectangle(x1, y1, w, h);

   al_get_clipping_rectangle(&cx, &cy, &cw, &ch);
   printf("2 - x:%d y:%d w:%d h:%d\n", cx, cy, cw, ch);

//   al_reset_clipping_rectangle();


*/




20220510 6:00 PM

I have a nice example going...3 window in an array...

- the class "mWindow" is defined in pm.h
- all the member functions are prototyped there too

the actual function implementations are all in c_mWindow.cpp

10 objects are declared in main and externed in pm.h

mWindow mW[10];
this should make them visible everywhere


make only one have focus...
or none...

I might have to go higher...
run through all windows, but only detect if mouse is on window

if only one window set that to the one that has focus

if more than one, choose the one with the high layer (or draw order)...

i could achieve the same effect by drawing them in reverse order and detecting mouse on in that order

start with mouse_on_window = 0

if on lowest window set mow to that window
then move to higher windows
if any overlap the higher ones will overwrite the lower one...

maybe this is all too complex

draw order...0 is on top and is the only one with focus

whenever a new one is brought to top all others slide down in order

what I did:
int layer
draw them in order by layer and detect mouse also
that way the highest layer mouse detection will override lower layers
mouse detected window has focus

this works good but the draw order never changes

how about at the end...
make the mouse detected window the highest layer

function to re-arrange layers


pass it a window number..

void set_to_new_top_layer(int wn)
{
   // get layer number of wn we are promoting
   int oln = mW[wn].layer;

   // slide everything up one layer (add 1 to all layers)
   for (int a=0; a<NUM_MW; a++)
      if (mW[a].active) mW[a].layer++;

   // set new top layer
   mW[wn].layer = 0;

}

it is looking good..
I can move and resize
only one window has focus and is on top


lets add some more functionality like
moveable
resizable
min_w
min_h
max_w
max_h

it might be time to make some numbers permanently tied to window numbers...

filter = 3;
always....

make a custom function to draw the buttons
done

edit toggle so that it can do the read only thing..
find unused var...q7

how about:
q6 = draw
q7 = process input

done...i bet that broke a lot of stuff!!!

eventually I will do this for all the buttons and slider...

wait...in the interests of not breaking everything and being backwards compatible....
lets reverse those.....
q6 = don't draw (hide)
q7 = don't process input

that works!!!

I am on the way!!!

now implement the collapse button on the title bar...

use a toggle but with only a single char + or -
make a way to not draw the frame...

when in drag mode, deactivate the button detection...
still if you drag too fast and the mouse in on the buttons it freezes...done...

20220512 6:30 AM  push

implement the +/- collapse button

what kind of button?? the same!
that was easy!
still need to make it look better, like with no frame...done...

bug..why do I have a funny sized red rect when moving window...
its like my y2 is off...fixed..when I set y2 I also need to set h

implement the b2 menu...done..

I think filters is perfect...

next up for an easy one...

status_window

will always be 1...

fixed size..

I think I want to make mouse_on_window a static int in the class
i will still need to externally clear, check and set it.
but then I could see it inside the instances...
try it...
cant get it to work...
make it a global...no need, just calulate in place

status window looks perfect
hide old one...done
make pop up menu for status window to show/hide sbf..done

when moving a window, show all windows...done
need to make an external funtion to draw all windows in order...done

status window looks great...
still want to:
make status window collapse like filters
when collapsed move y pos to title bar

now all I need to do in a loop is:
mouse_on_window = mw_cycle_windows(0);

move on to select window...it will be 2...

selection window is coming along fine....

currently working on text desription lines for special...
and how to only show if mouse is on window and selection is valid...fixed...use have_focus

push

20220513 6:32 AM
friday the 13th!...woooo!
now show blocks....
holy shit this is coming along so good...i think its done....

when resuming game, items return to start of level positions
more accuratlely, when exiting to menu...
sort item called by item_data to show list of items on menu
I hope removing it wont mess things up...

lift viewer end step text wrong..is is only on old lifts??
now I can't reproduce...
I found some lifts that have an end step with a val of 20
don't know how it happened, this should not be
I think the value used to be ignored until recently when I made different types of end step
used glt to make all 20 into 0
changed buttons to show undefined val


20220513 6:00PM
make filters collapse to top frame
when collapsed, can still move in x axis
restoring restores both x and y
will need more variables...
int alt1_x1
int alt1_y1

int alt2_x1
int alt2_y1

collapsing switches to using alt2

normal:
collapse = 0;
use x1 and y1


switch to collapse
put x1 and y1 in alt1
get x1 and y1 from alt2
only allow x move...

switch to expand
put x1 and y2 in alt2
get x1 and x2 from alt1
back to normal...

this all sounds so complex....

enforce windows to be on screen...done

fix the bug - cannot draw backwards selection in em...
or in zfs
or in ge

fix it once and use it everywhere dammit

first click...set x1, y1
release...set x2, y2
simple...

show proper progress

void get_new_box(void) // keep the mouse !!
{
   int z; // for swap
   bx2 = bx1; // set all three to intial
   by2 = by1;
   int x1 = bx1;
   int y1 = by1;
   int x2 = bx2;
   int y2 = by2;

   while (mouse_b1)
   {
      al_flip_display();
      proc_controllers();
      show_draw_item_cursor();
      process_scrolledge();
      update_editor_background();

      bx2 = (mouse_x)/20+wx; // set both with mouse pointer
      by2 = (mouse_y)/20+wy;

      x2 = bx2;  // set with mouse
      y2 = by2;

      x1 = bx1; // get inital in case it was swapped
      y1 = by1;

      // swap x1 and x2 if neccesary
      if (x1 > x2) { z = x1; x1 = x2; x2 = z;}
      if (y1 > y2) { z = y1; y1 = y2; y2 = z;}

      if (x1>99) x1 = 99;
      if (y1>99) y1 = 99;
      if (x2>99) x2 = 99;
      if (y2>99) y2 = 99;

      // show the selection rectangle
      al_draw_rectangle((x1-wx)*20, (y1-wy)*20, (x2-wx)*20+19, (y2-wy)*20+19, palette_color[127], 1);
      al_draw_textf(font, palette_color[15], 100, 20, 0, " x1:%d y2:%d ", x1, y1);
      al_draw_textf(font, palette_color[15], 100, 28, 0, " x2:%d y2:%d ", x2, y2);

   }
   // swap bx1 and bx2 if neccesary
   if (bx1 > bx2) { z = bx1; bx1 = bx2; bx2 = z; }
   if (by1 > by2) { z = by1; by1 = by2; by2 = z;}

   // always set second to one more
   bx2++;
   by2++;
}


fuck it...make it so that they can be the same......



what is stx, sty, sux, suy bullshit?
lets use..bx1, by1, bx2, by2 // block selection x1, y1, x2, y2
main and pm.h...done

I should remove all traces of stx and sty and fix stuff as I go...

ge_edit first.....I think it is done....all that was needed was to add selection to list....

can I make this common?

I think zfs is good....


all stx shit is gone...

I want to make the function that draws the sel on level buffer common...

void ge_draw_box(void)
{
   int x1 = bx1;
   int y1 = by1;
   int x2 = bx2;
   int y2 = by2;
   if (x1 > x2) swap_int(&x1, &x2);
   if (y1 > y2) swap_int(&y1, &y2);
   int dstx = x1*20;
   if (dstx == 0) dstx = 1;
   int dsty = y1*20;
   if (dsty == 0) dsty = 1;
   al_draw_rectangle(dstx, dsty, (x2*20)+19, (y2*20)+19, palette_color[14], 1);
   al_draw_text(font, palette_color[14], x1*20+2, y1*20+3,  0, "selection");
   //al_draw_textf(font, palette_color[14], x1*20+2, y1*20+3,  0, "selection bx1:%d by1:%d bx2:%d by2:%d", bx1, by1, bx2, by2);
}

void zfs_show_level_buffer_block_rect(bx1, by1, bx2, by2, int color, "selection")

void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)
{
   if (x1 > x2) swap_int(&x1, &x2);
   if (y1 > y2) swap_int(&y1, &y2);
   int dstx = x1*20;
   if (dstx == 0) dstx = 1;
   int dsty = y1*20;
   if (dsty == 0) dsty = 1;
   al_draw_rectangle(dstx, dsty, (x2*20)+19, (y2*20)+19, palette_color[14], 1);
   al_draw_text(font, palette_color[color], x1*20+2, y1*20-11,  0, text);
}
done...
now there is only one....
void zfs_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)

patch it into em....done...

bug zfs does not copy items....yes it does...
sort item used to set itemf pos, removed to fix another bug...

now I made item sort set itemf for all cased except the one where items are listed...

next I will do zfs...its a simple single window
then make the new filter window work with zfs...

then group edit...
it has:
-filter window
-a few buttons
-list
-gedit action list
I will probably attach the buttons to the list and make the action stuff a separate window

then object viewer..
one window and filters...
this could take some time cleaning up all the sliders and buttons, there are a lot!!!

finally when all of that is done....

make more things common...

all of these methods that I am treating as separate:
em
ge
ov
zfs

they all have many things in common...

they all have the scaled level as the background

the redraw background will be made to be common
with custom drawing on the level background as necessary for each mode...
em:
selection,
non-defult flags

zfs:
selection

group edit:
selected objects

ov:
lots of things to adjust

then after the get screen buffer:
then window processing will be very streamlined..

then if mouse not on window, process mouse on the background...
quite a lot......

first things...i need to get all the windows working under the new manager...

in zfs loop...
put filter...

20220514 5:00AM

make zfs use filter window values...

should be easy for lifts, blocks, flags, they have a 1-1 with exist buttons...
old var:
int copy_blocks=1;
int copy_enemies=1;
int copy_items=1;
int copy_lifts=1;
int copy_flags=1;

new vars:
obj_filter[1][1],  "Blocks"
obj_filter[1][2],  "Flags"
obj_filter[4][1],  "Lifts"

obj_filter[3][3],  "Arcwgn"
obj_filter[3][4],  "Bouncr"
obj_filter[3][6],  "Cannon"
obj_filter[3][7],  "Podzil"
obj_filter[3][8],  "Trakbt"
obj_filter[3][9],  "Cloner"
obj_filter[3][10], "Field"
obj_filter[3][11], "Blk Wk"
obj_filter[3][12], "Flappr"

obj_filter[2][1],  "Door"
obj_filter[2][2],  "Bonus"
obj_filter[2][3],  "Exit"
obj_filter[2][4],  "Key"
obj_filter[2][5],  "Start"
obj_filter[2][7],  "Mine"
obj_filter[2][8],  "Bomb"
obj_filter[2][9],  "Triggr"
obj_filter[2][10], "Messge"
obj_filter[2][11], "Rocket"
obj_filter[2][12], "Warp"
obj_filter[2][14], "Switch"
obj_filter[2][15], "Spring"
obj_filter[2][16], "Blk Mn"
obj_filter[2][17], "Blk Dm"

obj_filter[2][item[b][0]]

if ((item[b][0]) && (item[b][4] >= x1) && (item[b][4] < x2) && (item[b][5] >= y1) && (item[b][5] < y2))

filter window has been integrated into zfs...

now convert window to 4...

what if I try status window for zfs?



---- should I just bite the bullet and make gx, gy, hx, hy global?????
I pass them around a lot....
do it...right beside bx1...

there are a lot of refernces...

start by removing all other declarations..done 11 times...

now stop passing them to this
ovw_get_block_position_on_map(&gx, &gy, &hx, &hy); .. done 19 refs

OK I think Im done....

new zfs looks good..disable old one....

now fix the buttons so they only detect mouse b when have focus

int mw_draw_filter_buttons(int x1, int x2, int y1, int mode, int have_focus, int moving)
{
   int d = 1;
   if (have_focus) d = 0;
   if (moving) d = 1;


this uses custom buttons...
610, 611, 612
620, 621, 622, 623, 624

replace them all with generic

if (mdw_button(x3, yfb, x4, yfb+bnh, 610, 0,  0, 0, 0,  9, 15, 0, 1,0,0,0)) // block fill

// just display a text string, and return 1 if pressed
int mdw_buttont(int x1, int y1, int x2, int y2, int bn, int num, int type, int obt,
                 int q0, int q1, int q2, int q3, int q4, int q5, int q6, int q7, const char* txt)

those buttons are completely removed....
there is some weirdness around block fill and frame...

   if (draw_item_type == 1) // don't even show these 3 buttons unless draw item type is block
   {
      yfb+=bnh/2; // spacing between groups
      if (mdw_buttont(x3, yfb, x4, yfb+bnh, 0,0,0,0, 0,9,15,0, 1,0,0,d, "Block Fill"))
      {
         for (int x=bx1; x<bx2+1; x++)
            for (int y=by1; y<by2+1; y++)
            {
               if ((obj_filter[1][2]) && (obj_filter[1][1]))  l[x][y] = draw_item_num;
               if ((obj_filter[1][2]) && (!obj_filter[1][1]))
               {
                  int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
                  l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
                  l[x][y] |= flags;                                // merge
               }
            }
         init_level_background();
      }
      yfb+=bnh+2;
      if (mdw_buttont(x3, yfb, x4, yfb+bnh, 0,0,0,0, 0,9,15,0, 1,0,0,d, "Block Frame"))
      {
         for (int x=bx1; x<bx2+1; x++)
         {
            l[x][by1] = draw_item_num;
            l[x][by2] = draw_item_num;
         }
         for (int y=by1; y<by2+1; y++)
         {
            l[bx1][y] = draw_item_num;
            l[bx2][y] = draw_item_num;
         }
         init_level_background();
      }
      yfb+=bnh+2;

make a function to set a block from draw_item

void set_block_from_draw_item(int x, int y)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {

      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = draw_item_num;

      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {
         int flags = draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item
         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
         l[x][y] |= flags;                                // merge
      }

      // blocks only (same as block and flags???)
      if ((obj_filter[1][1]) && (obj_filter[1][2])) l[x][y] = draw_item_num;
   }
}

8:00 AM I think zfs is done

moving on to group edit
the list window will be 5..
disable existing filter window...

ge list was very easy to add....
make the draw only version....done
ge_show_obj_list(int x, int y, int *ew, int *eh)

ge list is done....

next....
ge controls will be 6

looking good....
give it a title bar for dragging...done
remove old one...i removed a lot

draw only buttons...done

find a way to implement mouse on window so mouse click won't pass through to level beneath..done

find a way to add functionality of two buttons....
show selection
add selection to list
and maybe more...
pop up menu toggles...
show/hide selection
put in on the object list...done

hide when no valid controls...
here is the thing...if I make the window inactive, i won;t be able to detect when to bring it back???
I can do it from the list maybe...
or I can make another setting for mWindows called hidden...done


11:31 AM

my next step is a big one...

object viewer is huge...

luckily there is only window....
it will be 7

it still uses the old filters....

it needs some clean up....

all these four modes should be cleaned up so that they all look common and can be integrated easily


something is stealing my mouse....fixed

making a new title function...

pass it x1, y1, x2, y2...something else will figure that out....
this is not the place to do it...


OK i got the title to somewhat work....
only buttons left

the height is working good...
get the return mb to where I can use it...done...
now the legend highlights...

making great progress....

now to go through all the buttons...

clean them up...and make them respect draw only...
everything in sliders has been modified to be read only if q7==1
everything in buttons has been done too....
yay!!!

20220514 7:00PM
I have probably introduced some bugs that I will need to catch...
the next thing on the list was to try to merge and simplify more things

make an global int that tells me what mode the level editor is in

level_editor_mode
0 = undef
1 = em
2 = zfs
3 = ge
4 = ov

make a common redraw background function
void cm_redraw_level_editor_background(int mode)
{

em replaced 3 calls
zfs replaced 2 calls
ge replaced 2 calls
ov 3 calls and 4 in lifts...
that is coming along nicely....

I know I have some bugs in the lifts stuff
but what the hell am I going to do about it?...fixit!!

so the high level common stuff....

- redraw the background
- redraw the windows

- process mouse on windows
- process mouse on background

this is pretty much done like this:

      cm_redraw_level_editor_background();

      mouse_on_window = mw_cycle_windows(0);

      if (!mouse_on_window) // mouse pointer is not on window
      {
         em_find_point_item();
         if (mouse_b1) em_process_mouse_b1();
         if (mouse_b2) quit = em_process_mouse_b2();
      }
      else point_item_type = -1; // to mark that
      quit = em_process_keypress();


20220515 6:00 AM
cleaning up...

made some common functions:
void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text)
void cm_get_new_box(void)
make get box use my new stuff...done...
lets do getxy also...

make a version of cm_redraw_level_editor_background() that stops just before get_new_screen_buffer()
mode 0...

more common stuff sorted out..
run lifts looks good now....

what about mouse_on_window??
for all the bullshit time I spend passing it around...
I could make it a global...
make it part of the mWindow class...
calculate it every time I need it...
how about

this is how condensed I got the edit menu loop:

em:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) quit = em_process_mouse();
   quit = em_process_keypress();
}

lets see if I can do similar for others

zfs:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) zfs_process_mouse();
   quit = zfs_process_keypress();
}

ge:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) ge_process_mouse();
   quit = ge_process_keypress();
}
ovw:
while (!quit)
{
   cm_redraw_level_editor_background();
   if (!mw_cycle_windows(0)) ovw_process_mouse();
   quit = ovw_process_keypress();
}


now...

go through the variables....
each window used to have its own custom global variables...

I could hide a lot of the window globals in mWindow...

got rid of a bunch, but these I will add...

// status window only used by mW[1]
extern int draw_item_num;
extern int draw_item_type;
extern int point_item_type;
extern int point_item_num;

// object viewer window
extern int ov_window_lift_buttons_h;

// status window
extern int draw_item_num;
extern int draw_item_type;
extern int point_item_type;
extern int point_item_num;

// select window
extern int select_window_block_on;
extern int select_window_special_on;
extern int select_window_num_special_lines;

extern int swbn;  // number of special
extern int swnbl; // number if special lines (just swbn / 16 + 1)
extern int swnbl_cur; // current number of lines shown
extern int swbl[NUM_SPRITES][2];

extern int show_non_default_blocks;
extern int show_flag_details;

Well I got rid of a lot.....the list is smaller now

lifts seem to work fine
pop message seem to be fine


viewer lock has some issues:
- when locked, it still switches
- can't move any secondary stuff on map for current object when not selected in filters...
if viewer lock on and current obt = 3
only do stuff for that
wow this is tougher that I thought...
if viewer_lock only process move for main obj and aux things for that object...
if obt is different dont even do that section...
maybe I need to split this huge function into detection and processing....
its kind of like that already...only one thing can be pass to the second half for adjustment
the detection part will stop at the first valid match and send it....
another assumption is that if you are adjusting a secondary thing, the main object is set to current object
I think I have fixed it....

I want to see the non-default blocks in the draw item and view_item and draw item cursor....done

Purple Martians Version 7.10
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
running level editor for level:4
00000000 00011001 00000000 10000000  - draw_item
00000000 00011001 00000000 00000000  - flags only
00000000 00011111 00000000 11011100  - destination block
00111111 11111111 00000000 00000000  - PM_BTILE_MOST_FLAGS
11000000 00000000 11111111 11111111  - ~PM_BTILE_MOST_FLAGS
00000000 00000000 00000000 11011100  - destination block =~PM_BTILE_MOST_FLAGS
00000000 00011001 00000000 11011100  - merge l[x][y] |= flags

this works exactly as intended....

void set_block_from_draw_item(int x, int y)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {

      printBits(4, &mW[1].draw_item_num);
      printf("%s - draw_item\n", msg);

      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = mW[1].draw_item_num;




      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {

         int flags = mW[1].draw_item_num & PM_BTILE_MOST_FLAGS; // get only flags from draw item

         printBits(4, &flags);
         printf("%s - flags only\n", msg);


         printBits(4, &l[x][y]);
         printf("%s - destination block\n", msg);

         int f = PM_BTILE_MOST_FLAGS;
         printBits(4, &f);
         printf("%s - PM_BTILE_MOST_FLAGS\n", msg);


         f = ~PM_BTILE_MOST_FLAGS;
         printBits(4, &f);
         printf("%s - ~PM_BTILE_MOST_FLAGS\n", msg);


         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                 // clear flags in destination
         printBits(4, &l[x][y]);
         printf("%s - destination block =~PM_BTILE_MOST_FLAGS\n", msg);

         l[x][y] |= flags;                                // merge
         printBits(4, &l[x][y]);
         printf("%s - merge l[x][y] |= flags\n", msg);


      }

      // blocks only (same as block and flags?)
      if ((obj_filter[1][1]) && (!obj_filter[1][2])) l[x][y] = mW[1].draw_item_num;
   }
}

I think I was expecting the other part of zfs to do this...the copy paste...
I made a common function to do both:


void set_block_with_flag_filters(int x, int y, int tn)
{
   if ((x>=0) && (x<100) && (y>=0) && (y<100))
   {
      // blocks and flags
      if ((obj_filter[1][1]) && (obj_filter[1][2]))  l[x][y] = tn;

      // flags only
      if ((!obj_filter[1][1]) && (obj_filter[1][2]))
      {
         int flags = tn & PM_BTILE_MOST_FLAGS; // get only flags from draw item
         l[x][y] &= ~PM_BTILE_MOST_FLAGS;                       // clear flags in destination
         l[x][y] |= flags;                                      // merge
      }
      // blocks only (same as block and flags?)
      if ((obj_filter[1][1]) && (!obj_filter[1][2])) l[x][y] = tn;
   }
}

look into brf mode also...done...

also if block filter is not set, nothing gets copied to ft_...fixed

make it so that the paste selection is updated when ever filter changes...done...

clean up variables for old window positions...
maybe find a way to save them...
I could save the entire array of window objects...
have a simple load and save thing...T-save Y-load
when do I load? in
save when quitting level editor
load when starting
seems to work pretty good...


20220516 4:30AM

rockets cannot go through semisolid..has it alwats been this way?
I could just clear item solid...

rockets can go off the edge of the level....fixed for all items


demo mode annoys me when it starts in the middle of things I am doing
I could make it start on a timer, but only if nothing happens after the program is first run
after that do not automatically start it again
done...and it is so much nicer now!


add 4 keys to PDE and remove key creator....done



I am going to remove enemy field...everything it does can be done with trig, bm and bd...
PDE is removed....

20220516 6:30 AM push

bug...when moving lift step from map move, take into account the offset...done

in PDE custom draw 4 keys and 4 switches on a line by themselves...done
allow key color (and switch) to be changed in viewer...done

when doing highlights for key, show blocks that will be removed...done...







