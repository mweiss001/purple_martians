proof of concept

make an app that can display logs...

couldn't get past the qt download page, it just rubs me the wrong way...

mweiss001#gmail.com

Blargit1



https://stackoverflow.com/questions/71208815/how-to-connecte-my-application-qt-cmake-to-mysql-database




Place

find_package(Qt6 REQUIRED COMPONENTS Sql)

before this code

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(appName MANUAL_FINALIZATION ${PROJECT_SOURCES})
else()
    if(ANDROID)
        add_library(appName SHARED ${PROJECT_SOURCES})
    else()
        add_executable(appName ${PROJECT_SOURCES})
    endif()
endif() 

and then add

target_link_libraries(appName PRIVATE Qt6::Sql)







#include <QSqlDatabase>

    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    db.setHostName("bigblue");
    db.setDatabaseName("flightdb");
    db.setUserName("acarlson");
    db.setPassword("1uTbSbAs");
    bool ok = db.open();    


QSqlDatabase db = QSqlDatabase::addDatabase("QODBC");
db.setDatabaseName("Driver={MySQL ODBC 5.3 Unicode Driver};DATABASE=test;");
db.setUserName("root");
db.setPassword("password");
if (!db.open()) {
    qDebug() << db.lastError().text();
} else {
    qDebug("success");
}



database error: "[Microsoft][ODBC Driver Manager] Data source name not found and no default driver specified, IM002 QODBC: Unable to connect"


db = QSqlDatabase::addDatabase("QODBC");
db.setDatabaseName("Driver={MySQL ODBC 5.1 Driver};DATABASE=agp-dbserver01;");
db.setUserName("xcdr");
db.setPassword("xcdr");@





installed the mysql connector odbc 8.4

Running as Admin
Changing the directory...
Registering Unicode driver
Checking if "MySQL ODBC 8.4 Unicode Driver" is not already registered
Registering "MySQL ODBC 8.4 Unicode Driver"
Success: Usage count is 1
Registering ANSI driver
Checking if "MySQL ODBC 8.4 ANSI Driver" is not already registered
Registering "MySQL ODBC 8.4 ANSI Driver"
Success: Usage count is 1
+-----------------------------------------------------+
| DONE                                                |
+-----------------------------------------------------+
|                                                     |
| Hopefully things went well; the Connector/ODBC      |
| driver has been registered.                         |
|                                                     |
| Connector/ODBC is ready to use.                     |
|                                                     |
| The most common thing to do next is to go to the    |
| Control Panel and find the ODBC Administrator -     |
| then use it to create a Data Source Name (DSN)      |
| so you (and your application) can connect to a      |
| MySQL server.                                       |
|                                                     |
| Alternatively you can use the MyODBC Installer      |
| utility to define data sources.                     |
|                                                     |
+-----------------------------------------------------+
Press any key to continue . . .




---------------------------------------

https://github.com/thecodemonkey86/qt_mysql_driver/releases

Since the Qt Company cannot provide qsqlmysql.dll / libqsqlmysql.so in binary form, you have to build it on your own, which can be a pain. Here is a build for various Qt versions. Get precompiled qsqlmysql.dll for Windows / libqsqlmysql.so for Linux from releases. Be sure to match your Qt version and compiler (Microsoft Visual C++/MSVC, MinGW) EXACTLY. For example if you use Qt 6.4.2, you cannot use driver version 6.4.1 or 6.4.3


how do I know what compiler I have? Does this mean I have to build Qt?

When I installed Qt it also installed Qt maintenance tool.
Ran that and found my qt version is 6.7.1 and my MinGW version is 11.2.0 64bit

but there is nothing in there about mysql..



Deployment

    copy qsqlmysql.dll (release build) / MSVC: qsqlmysqld.dll, MinGW: qsqlmysql.dll+qsqlmysql.debug (debug build) to subdirectory "sqldrivers" of application directory (or build directory while developing)

    copy libmysql.dll (MySQL library) and the libcrypto/libssl OpenSSL libraries from zip file (or from https://dev.mysql.com and https://kb.firedaemon.com/support/solutions/articles/4000121705 respectively) to application directory (or more generally, any directory that is registered in PATH environment variable)


this is what i downloaded:
qsqlmysql.dll_Qt_SQL_driver_6.7.1_MinGW_11.2.0_64-bit.zip

then I copied the files and put them in the same dir as executable

    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    db.setHostName("purplemartians.org");
    db.setDatabaseName("Syslog");
    db.setUserName("pete");
    db.setPassword("park");
    bool ok = db.open();

06:18:00: Starting C:\Users\m\Documents\test1\build\Desktop_Qt_6_7_1_MinGW_64_bit-Debug\test1.exe...
QSqlDatabase: QMYSQL driver not loaded
QSqlDatabase: available drivers: QSQLITE QMIMER QODBC QPSQL
database error: "Driver not loaded Driver not loaded"
       


OMFG I got it to work!!!!
I copied the sqldrivers directory and the three other files to the same dir as my executable







/*

    QSqlDatabase db = QSqlDatabase::addDatabase("QODBC");
    //    db.setDatabaseName("SystemEvents");
//    db.setHostName("purplemartians.org");

    db.setDatabaseName("Driver={MySQL ODBC 8.4 ANSI Driver};DATABASE=rsyslog_odbc;");
    db.setUserName("pete");
    db.setPassword("park");
    bool ok = db.open();
*/



    QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL");
    db.setHostName("purplemartians.org");
    db.setDatabaseName("Syslog");
    db.setUserName("pete");
    db.setPassword("park");
    bool ok = db.open();

    if (!ok) qDebug() << "database error:" << db.lastError().text();
    else
    {
        QSqlQuery query;
        query.exec("SELECT Message FROM SystemEvents WHERE ID = 120895");
        while (query.next()) {
            QString name = query.value(0).toString();
            ui->textBrowser->setPlainText(name);
        }
    }
}






































I am trying to figure out how to call some code in my own functions in qt...
also some place to store variables

make a class?

m_base.cpp
m_base.h

right click on source and add new...class..called m_base

make it visible with .h


18526863
18548837

SELECT MAX(ID) FROM SystemEvents


the server is doing this 40 times per second: rew and save state..
I have 18 million rows in SystemEvents


It is time to work on getting the data from SystemEvents to a custom database on my own...

I will need code to scrape SystemEvents and do this. What Language?

I have some cron called PHP on the server already...
I could do it in c++ with the Qt app...

What will my main table look like?

First what feilds from System Events do I want do keep?


Message
ReceivedAt
Device Reported Time? (not unless I actually record and add it)

I need to make something to mark the ones that come from purplemartians

I think I will use SysLogTag

I don't feel like any other fields can be reliably set when I pass UDP packets, so I plan to do the rest in the message field.
I might keep FromHost, but lets rslsylog fill it out on the server..

new table

ID
ReceivedAt
RawMessage

player number
frame
log message line type
trunc message

this looks pretty simple...

what if I have extra fields for number that are specific to certain message types
like 8 ints and 8 floats?

can be a later thing....



what do I need to do first?

make my logging add purplemartians in SysLogTag

what if I shortened it to pm? done


Make the new table.

Make it under the same DATABASE?...idk..yes for now

CREATE TABLE pm_log (
  id                INT AUTO_INCREMENT,
  received_at       DATETIME,
  agt               DOUBLE, 
  player_num        INT,
  message_type      INT,
  frame_num         INT,    
  message           text,
  PRIMARY KEY(id)
);

done...

 use indexOf. Is th









To create a line chart, a QLineSeries instance is needed. Let's create one.

auto series = new QLineSeries;

Then we add data to the series. We can use the append() member function or use the stream operator.

series->append(0, 6);
series->append(2, 4);
series->append(3, 8);
series->append(7, 4);
series->append(10, 5);
*series << QPointF(11, 1) << QPointF(13, 3) << QPointF(17, 6) << QPointF(18, 3) << QPointF(20, 2);

To present the data on the chart we need a QChart instance. We add the series to it, create the default axes, and set the title of the chart.

auto chart = new QChart;
chart->legend()->hide();
chart->addSeries(series);
chart->createDefaultAxes();
chart->setTitle("Simple Line Chart");

Then we create a QChartView object with QChart as a parameter. This way we don't need to create a QGraphicsView scene ourselves.

createDefaultChartView(chart);

The chart is ready to be shown.






added to CMakeLists.txt

find_package(Qt6 REQUIRED COMPONENTS Sql, Charts)

target_link_libraries(test1 PRIVATE Qt6::Charts)

in mbase.h

#include <QChart>
#include <QLineSeries>

QLineSeries* series;

in mbase.cpp

   series = new QLineSeries;

   series->append(0, 6);
   series->append(2, 4);
   series->append(3, 8);
   series->append(7, 4);
   series->append(10, 5);



in mpmlogview.h
#include <QChart>
#include <QChartView>

QChart* chart;
QChartView* chartView;



in mpmlogview.cpp

   chart = new QChart;
   chart->legend()->hide();
   chart->addSeries(mbase.series);
   chart->createDefaultAxes();
   chart->setTitle("Simple Line Chart");

   chartView = new QChartView(chart);

   vbox->addWidget(chartView);



that was all I needed to display a chart....



now how can I make a chart display from a model


first of all...

I should make this code somewhat segregated...

load the model from my new status table


ok now I have a thingy...

my model has muliple players

load a different model for each player?

i need a different line series for each player...
is this the best way to do it?

it seems to work...


can I make the graph resizable


This functionality is provided by QChartView:

QChartView v;
v.setRubberBand(QChartView::HorizontalRubberBand);
this is awesome, but how do I zoom back out?
left click and drag - zoom in to selection
right click - zoom out...

I want to be able to drag also

maybe later


what else for now?


should I put this on its own tab

or at least its own widget that I can put where I want...


how am i going to handle this proliferation of variables, classes and the like?



make all common stuff live in mbase...

make classes for things you could display in many places


I want to have common:
sessions
it would be nice if I had a session_id that was part of every table

I think I can handle it by having start and end dt and player number

I will have a way of selecting which sessions I want to look at...
I can select more than one.

This tab will be called the data selection tab

At the top you can set the ip, db, usr, pwd...

It will show you the total range of the data

Then it will show you the sessions and some data for each...

Then you can select one or more sessions...

also the limit of the number of records to load into the log models and the status models

this seems like to much to cram into one thing, how about just start and end ranges of data to load into models?






bar chart horizontal with datetime axis...


I think I need to figure out more about graphs then simply using model to drive them...

create my own line series from a model...

then I could make it a datetime axis


if my datetime axis only has a resolution of 1 second....

can I do better? I should be able to...

anyway I have datetime x axis figured out

now I want to get horizontal boxes


I am going to ask on the Qt forums...


Word it well....



I am trying to create a specific type of chart with QCharts.
The x axis needs to be DateTime, I have figured out how to do that.
I have data called 'sessions' that has a start and endtime in DateTime format.
These sessions are from multiple clients and the time ranges can overlap.
I would like to show them as horizontal rectangles that span the start and end times.
Then I would like to be able to select one or more of them and extract the earliest and latest datetimes.

I am fairly new to Qt and would appreciate if anyone with more experience could point me in the right direction.





------------------


make a class and a widget for sessions, but keep the data in mbase so others can use it...


while I am at it, nail down some naming conventions...


this new class:



QModelIndexList selection = yourTableView->selectionModel()->selectedRows();

// Multiple rows can be selected
for(int i=0; i< selection.count(); i++)
{
    QModelIndex index = selection.at(i);
    qDebug() << index.row();
}

now I want to connect selection changed

this is so painfull...it takes so long to do such simple things....


now I want to have a global start and end datetime

make up names
declare in mbase

set them when changing session list..

use them as filters when doing sql queries...



I already have most of this functionality in my daterange widget....

what if I just add actual QDate time thing to mbase and make them both use it..

QDateTime dtStart;
QDateTime dtEnd;



---------------


I just lost a huge section of info about what I was working on when I copied and pasted from notes in pm to here...damn....

20240712


what am I working on now?


resizing charts with splitter

working on min height, etc...


how do I get series colors after I apply a theme, so I can use them to color my custom legend?


how do I backup this project?

it was in c:/users/m/decouments/test1
size 65M
133k sources only



how do I make a standalone executable?

--------------------------------------------
---   how to copy and relocate sources   ---
--------------------------------------------

copy the folder to a new place

delete the build dir
delete CMakeList.txt.user

rename all occurances of executable name 'test1' to 'pm_log' in CMakeList.txt

open project in Qt Creator by opening CMakeList.txt

on the Configure Project page leave all targets selected then click 'configure project'

choose a target and build...

12:27:31: Starting C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-Debug\pm_log.exe...
QSqlDatabase: QMYSQL driver not loaded
QSqlDatabase: available drivers: QSQLITE QMIMER QODBC QPSQL
database error: "Driver not loaded Driver not loaded"
QSqlQuery::exec: database not open
12:27:39: C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-Debug\pm_log.exe exited with code 0

copy 3 files and one dir to same folder as executable:

libmysql.dll
libssl-3-x64.dll
libcrypto-3-x64.dll
sqldrivers (folder)


-----------------------------------------------
---   how to make a standalone executable   ---
-----------------------------------------------

C:\Qt\6.7.1\mingw_64\bin\windeployqt C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-Debug

now I can run pm_log.exe from its folder without qt creator running

the whole folder is over 100M
but this is the debug target...

start over:

delete build folder
target Debug
30M
add sql drivers:
44M
C:\Qt\6.7.1\mingw_64\bin\windeployqt C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-Debug
108M

try min_release
target MinSizeRel
8M
add sql drivers:
24M
C:\Qt\6.7.1\mingw_64\bin\windeployqt C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-MinSizeRel
84M



---------------------------

what am I working on next?


resizing charts with splitter
working on min height, etc...
when I adjust a chart larger, what happens to other charts? especially if they are already minimum size??


how do I get series colors after I apply a theme, so I can use them to color my custom legend?

frame as x axis


pop up dialog for db setting

save chart selection



20240713

save charts visible is working, how about saving size as well....

I could save the size list from the splitter...
I would need to make the splitter visible, maybe declare it in mbase
or do I?
could I just get the init code to read it from the settings file?

made QSettings * settings declared and created in mbase, so it is visible for the whole program...
how about I make the splitter save to it when resized?
and load from it when created?
this works perfectly!

I think I found someting I am doing wrong...
when the charts are clicked on or off, all I do is set visible in mbase

but when I resize the charts with splitter it is based on size > 0
fixed this is auto size stuff but still have issues when enabling a chart
its size is zero..

should I make another function that looks at the splitter and if any visible are size 0, sets them to min size

I did not need to do this, this one setting did it for me:

childrenCollapsible : bool
This property holds whether child widgets can be resized down to size 0 by the user
By default, children are collapsible. It is possible to enable and disable the collapsing of individual children using setCollapsible().


I am very happy with how this is working out...

now about the series colors....
- I could force my colors back after changing theme
that was so easy to do, just called controlsChanged after setting theme

or I could see if I can get the colors somehow
if I could, what would I do with them? overwrite my array colors? yes...


I have it done:

added color setup to updateLegend() as well as constructor

void mChartsWidgetControlWidget::updateLegend()
{
   for (int i=0; i<8; i++)
   {
      QPalette p = legendSel[i]->palette();
      p.setColor(QPalette::Active, QPalette::WindowText, mbase.statChartSeriesStructArray[i].col);
      legendSel[i]->setPalette(p);




void mChartsWidget::changeTheme()
{
   qDebug() << "mChartsWidget::changeTheme()";
   for (int i=0; i<NUM_CHARTS; i++)
      statChartView[i]->chart()->setTheme(static_cast<QChart::ChartTheme>(mbase.mChartsWidgetChartTheme));

   // find series colors
   for (int s=0; s<8; s++)
      mbase.statChartSeriesStructArray[s].col = statChartSeries[0][s]->color();
   
   // change all series colors   
   controlsChanged();
   
   // change legend colors
   mbase.updateLegendFunction();
}

I can easily make my original colors persist by commenting out:

   // find series colors
//   for (int s=0; s<8; s++)
//      mbase.statChartSeriesStructArray[s].col = statChartSeries[0][s]->color();




-------------------

make a group box for theme
make a checkbox 'allow theme to change series color'
or maybe 'my series colors'
then make something to reload them...

this will reload them:
void m_base::initStatChartSeriesStructArray(void)



is seems to work:

when checked, selecting a new them keeps the original color
when not checked, selecting a new them changes colors

if color are set by a theme, clicking the box reverts them to original

but if colors are original, clicking the box does not set them to the theme???

i think the theme is not applied if it is the same...



void mChartsWidgetControlWidget::keepSeriesColorsClicked()
{
   bool checked = keepSeriesColors->isChecked();
   mbase.mChartsWidgetForceMySeriesColors = checked;

   if (!checked) // force theme reload to get theme colors
   {
      mbase.mChartsWidgetChartTheme++;
      mbase.updateChartThemeFunction();
      mbase.mChartsWidgetChartTheme--;
   }
   mbase.updateChartThemeFunction();
}

move this to where theme is actually changed....

void mChartsWidget::changeTheme()
{
   qDebug() << "mChartsWidget::changeTheme()";

   // test if theme is the same as current theme

   int newTheme = mbase.mChartsWidgetChartTheme;
   int oldTheme = statChartView[0]->chart()->theme();

   qDebug() << "old theme:" << oldTheme << "  new theme:" << newTheme;

   if (oldTheme == newTheme)
   {
      qDebug() << "new theme is the same as old theme";

      int tmpTheme = newTheme + 1;
      if (tmpTheme > 7) tmpTheme = 0;

      qDebug() << "setting tmpTheme:" << tmpTheme;


      // set temp theme
      for (int i=0; i<NUM_CHARTS; i++)
         statChartView[i]->chart()->setTheme(static_cast<QChart::ChartTheme>(tmpTheme));
   }


   qDebug() << "setting newTheme:" << newTheme;

   for (int i=0; i<NUM_CHARTS; i++)
      statChartView[i]->chart()->setTheme(static_cast<QChart::ChartTheme>(newTheme));




ok, now how about saving:
theme
line size
keep series colors


save line size when it changes

void mChartsWidgetControlWidget::lineSizeChanged()
{
   //qDebug() << "Line Size Changed" << lineSizeSpinBox->value();
   mbase.mChartsWidgetPlotLineSize = lineSizeSpinBox->value();
   mbase.settings->setValue("mChartsWidgetPlotLineSize", mbase.mChartsWidgetPlotLineSize);
   mbase.chartsWidgetsControlsChangedFunction();
}

read line size when creating

   // Create spinbox to modify line size
   lineSizeSpinBox = new QDoubleSpinBox(this);

   // get initial value from settings
   mbase.mChartsWidgetPlotLineSize = mbase.settings->value("mChartsWidgetPlotLineSize", 1).toFloat();
   lineSizeSpinBox->setValue(mbase.mChartsWidgetPlotLineSize);


that was so easy!!

now do keep series colors...should be just as easy...done

now theme...

Now I have so much done:
theme, line size, keep colors, visible charts, splitter sizes, are all saved and restored

clean up the constructor and rearrange the layout grid...done...

now what?







------------------------

downloaded stlyesheet from 

https://qss-stock.devsecstudio.com/documentation.php

copied Darkeum.qss file to same dir as exe


#include "mMainWindow.h"
#include <QApplication>
#include <QFile>

int main(int argc, char *argv[])
{
   QFile file("Darkeum.qss");
   file.open(QFile::ReadOnly);
   QString styleSheet { QLatin1String(file.readAll()) };
   
   QApplication a(argc, argv);

   a.setStyleSheet(styleSheet);
   
   mMainWindow w;
   w.setWindowTitle("pm logs");
   w.show();
   return a.exec();
}









Download/clone the project and copy the following files to your application directory (keep the existing directory hierarchy). Substitute the all the THEME words by the currently available (dark/light) the theme you need to use.

        qdarkstyle/THEME/THEMEstyle.qss
        qdarkstyle/THEME/THEMEstyle.qrc
        qdarkstyle/THEME/rc/ (the whole directory)

Add qdarkstyle/THEME/THEMEstyle.qrc to your .pro file as follows:

    RESOURCES += qdarkstyle/THEME/THEMEstyle.qrc

what I did was add:

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(pm_log
        MANUAL_FINALIZATION
        ${PROJECT_SOURCES}
        m_base.h m_base.cpp
        mlogmessagetypeselector.h mlogmessagetypeselector.cpp
        mLogView.h mLogView.cpp
        mlogdaterange.h mlogdaterange.cpp
        msqlwidget.h msqlwidget.cpp
        mpmselect.h mpmselect.cpp
        mdelegate.h

        mSessionsWidget.h mSessionsWidget.cpp
        mdelegate2.h
        mChartView.h
        mChart.h

        mChartsWidget.h mChartsWidget.cpp
        mChartViewCrosshairs.h mChartViewCrosshairs.cpp
        mChartsWidgetControlWidget.h mChartsWidgetControlWidget.cpp

        qdarkstyle/dark/darkstyle.qrc



Load the stylesheet:

    QFile f(":qdarkstyle/THEME/THEMEstyle.qss");

    if (!f.exists())   {
        printf("Unable to set stylesheet, file not found\n");
    }
    else   {
        f.open(QFile::ReadOnly | QFile::Text);
        QTextStream ts(&f);
        qApp->setStyleSheet(ts.readAll());
    }

Note: The ":" in the file name is necessary to define that file as a resource library. For more information see the discussion here.



What about defining a const string and changing only the color ?

const QString ss = "QComboBox::drop-down {border-width: 0px;} QComboBox::down-arrow {image: url(noimg); border-width: 0px;} QComboBox { background:%1 }";
QColor c(Qt::red);  
//Set background red
ui->comboBox_0->setStyleSheet(ss.arg(c.name()));

//...
 c = QColor(Qt::blue); 
//Set background blue
ui->comboBox_0->setStyleSheet(ss.arg(c.name()));

const QString ss = "QComboBox::drop-down {border-width: 0px;} QComboBox::down-arrow {image: url(noimg); border-width: 0px;} QComboBox { background:%1 }";


fixed the legend colors with drawstyle stylesheet!!

      const QString ss = "QCheckBox {  color: %1 }";
      legendSel[i]->setStyleSheet(legendSel[i]->styleSheet() + ss.arg(mbase.statChartSeriesStructArray[i].col.name()));
      
      // this method works, but will not override the stylesheet      
      // QPalette p = legendSel[i]->palette();
      // p.setColor(QPalette::Active, QPalette::WindowText, mbase.statChartSeriesStructArray[i].col);
      // legendSel[i]->setPalette(p);





can I implement the frame x axis?

make a check box to toggle it, a variable to hold it and save in settings...done...

removed crosshairs for now...


in ChartsWidget I create a DateTimeAxis...how do I get around that?
remove it and create another one?


I am thinking I will probably need to reload all the data if I change the axis anyway

so make creating the X axis part of the update stuff



how are charts, chartview, series, axis all related?

I want to redo axis, how far do I have to go?

- create chart
- create axis and add to chart
- create series
- attach axis to series

- create chartview
- add chart to chartview

- add chartview to splitter

if I redo everything, how do I clean up first?

- delete series
- remove axis from charts
- delete axis
- delete charts
- delete chartview

delete splitter...

actually the only thing I had to do was delete the main layout:

   delete(this->layout());

then I use the same code to build in the constructor as I do when i update the sql

i changed the x and y axis to being created just as needed
it used to be an array in the header..

then when I create the x axis it could be datetime or value

      if (mbase.mChartsWidgetXAxisFrame)
      {
         QValueAxis * statChartXaxis = new QValueAxis;
         statChartXaxis->setTitleText("Frame");
         statChart[i]->addAxis(statChartXaxis, Qt::AlignBottom);
      }
      else
      {
         QDateTimeAxis * statChartXaxis = new QDateTimeAxis;
         statChartXaxis->setTitleText("Time");
         statChartXaxis->setFormat("HH:mm:ss.zzz");
         statChart[i]->addAxis(statChartXaxis, Qt::AlignBottom);
      }

then when I need to use the axes after that, I get them with: 

   // set the range for all charts
   // -----------------------------------
   for (int i=0; i<NUM_CHARTS; i++)
   {
      // get the first x axis from the chart
      QList qlxa = this->statChart[i]->axes(Qt::Horizontal);
      qlxa.at(0)->setRange(mbase.sessionsDtStart, last);

      // get the first y axis from the chart
      QList qlya = this->statChart[i]->axes(Qt::Vertical);
      qlya.at(0)->setRange(statChartMinY[i], statChartMaxY[i]);
   }

      if (mbase.mChartsWidgetXAxisFrame)
      {
         qDebug() << "value axis";

//         statChartXaxis[i] = new QValueAxis;
//         statChartXaxis[i]->setTitleText("Frame");
//         statChart[i]->addAxis(statChartXaxis[i], Qt::AlignBottom);
         QValueAxis * statChartXaxis = new QValueAxis;
         statChartXaxis->setTitleText("Frame");
         statChart[i]->addAxis(statChartXaxis, Qt::AlignBottom);
      }
      else
      {
         qDebug() << "datetime axis";
//         statChartXaxis[i] = new QDateTimeAxis;
//         statChartXaxis[i]->setTitleText("Time");
//         statChartXaxis[i]->setFormat("HH:mm:ss.zzz");
//         statChart[i]->addAxis(statChartXaxis[i], Qt::AlignBottom);

         QDateTimeAxis * statChartXaxis = new QDateTimeAxis;
         statChartXaxis->setTitleText("Time");
         statChartXaxis->setFormat("HH:mm:ss.zzz");
         statChart[i]->addAxis(statChartXaxis, Qt::AlignBottom);
      }

//      statChartXaxis[i]->setTitleFont(labelsFont);
      // statChartXaxis[i]->setVisible(false);

      QValueAxis * statChartYaxis = new QValueAxis;
      statChartYaxis->setTitleText(mbase.statChartGraphTypeArray[i].display_name);
      statChartYaxis->setLabelFormat("%3.1f");
      statChart[i]->addAxis(statChartYaxis, Qt::AlignLeft);



      // statChartYaxis[i] = new QValueAxis;
      // statChartYaxis[i]->setTitleText(mbase.statChartGraphTypeArray[i].display_name);
      // statChartYaxis[i]->setLabelFormat("%3.1f");
      // statChart[i]->addAxis(statChartYaxis[i], Qt::AlignLeft);




now make the crosshairs and mouse wheel scroll work again...done


next... adjustable number of records in the model, and show the time range of that 

what do i call that?






I have a memory leak...probably due to me not freeing new object when I update graphs


some stats:
25.7M no charts loaded
36.7M load last one in chart
46.3  load second last one
55.7  load last one
65.4  load 2nd last

approx 10M per chart reload

add this code to delete all charts

   for (int i=0; i<NUM_CHARTS; i++)
      delete statChart[i];


24.3M no charts loaded
30.2M load last one in chart
31.8  load second last one
33.6  load last one
34.9  load 2nd last

approx 1.5M per chart reload


what else can I destroy?

   for (int i=0; i<NUM_CHARTS; i++)
   {
      delete statChart[i];
      delete statChartView[i];
   }

25.7
30.1
30.3
30.2
30.3
30.5
30.4


way better!!


i have a bug though

when in frame mode the last charts all look the same...is is because they all start at frame 0??



I want some way to see both frame and time at the same time and why is there such a difference?




these status logs are just what the server records, once per frame, they should not be out of order


do one more graph called frame to check if they are...

I found some cases of frame 0 in the middle of the data...how can I fix this?
order by id?

wait...why is there random frame 0 in the middle of the data? this is not what should happen?

lets add back in the table view and see what happens around this time...





I have 3 widgets now:
mSessionsWidget
mChartsWidget
mChartsWidgetControlWidget

mSessionsWidget is common

they are all children of mLogView

I want to add:
2 tableviews

   // message line type selector

   // column select widget
   
   // sql execute button

   // auto exec check box

   // number of rows label
   
   // font size spin box


could I make these into a widget:





rename some classes:

mpmselect to mTableColumnSelectWidget ..done

mlogmessagetypeselector to mTableRowSelectWidget 

done...

make their selections saved


make table2 able to do other players than 1 

do col sel first





the anomalous data is not frame 0, it is approx x frames below its siblings


evenly spaced 728 729 730 731

but between 728 and 729 is 718 (-10)

between 739 and 740 is 719 (-20)


362 363 354 (-8)

372 373 355 (-17)

382 383 356 (-26)

----
patterns:

the anomalous data are sequential frames 719, 718 and 354, 355, 356

they appear to be inserted every 10-11 frames

I wonder where the bug is?
Is this how the data is stored on files on the disk?

look at the 300 range one:

actual time:

2024-07-01 9:14:59.199 - 774


2024-07-01 09:14:58.974,1352,0,0,3.7,0.0,0.0,  0,0.0,0.0,421,  0,  1,  0
2024-07-01 09:14:58.974,1352,1,0,3.9,6.7,0.0,343,0.0,0.0,421,  0,  1,  0
2024-07-01 09:14:58.999,1353,0,0,3.6,0.0,0.0,  0,0.0,0.0,429,1386,  1, 11
2024-07-01 09:14:58.999,1353,1,0,1.5,7.1,0.0,351,0.0,0.0,429,1386,  1, 11
2024-07-01 09:14:59.24,1354,0,0,3.7,0.0,0.0,  0,0.0,0.0,400,  0,  1,  0
2024-07-01 09:14:59.24,1354,1,0,1.5,7.1,0.0,322,0.0,0.0,400,  0,  1,  0
2024-07-01 09:14:59.49,1355,0,0,3.5,0.0,0.0,  0,0.0,0.0,400,983,  1,  8
2024-07-01 09:14:59.49,1355,1,0,1.4,7.6,0.0,322,0.0,0.0,400,983,  1,  8
2024-07-01 09:14:59.74,1356,0,0,3.6,0.0,0.0,  0,0.0,0.0,377,872,  1,  7
2024-07-01 09:14:59.74,1356,1,1,1.4,0.6,0.0,299,0.0,0.0,377,872,  1,  7
2024-07-01 09:14:59.99,1357,0,0,3.6,0.0,0.0,  0,0.0,0.0,400,723,  1,  6
2024-07-01 09:14:59.99,1357,1,1,3.7,-0.6,0.0,322,0.0,0.0,400,723,  1,  6
2024-07-01 09:14:59.124,1358,0,0,3.7,0.0,0.0,  0,0.0,0.0,421,381,  1,  3
2024-07-01 09:14:59.124,1358,1,1,3.7,-0.6,0.0,343,0.0,0.0,421,381,  1,  3
2024-07-01 09:14:59.149,1359,0,0,3.6,0.0,0.0,  0,0.0,0.0,441,1065,  1,  9
2024-07-01 09:14:59.149,1359,1,1,3.8,-2.2,0.0,363,0.0,0.0,441,1065,  1,  9
2024-07-01 09:14:59.174,1360,0,0,3.7,0.0,0.0,  0,0.0,0.0,440,723,  1,  6
2024-07-01 09:14:59.174,1360,1,1,3.8,-3.6,0.0,362,0.0,0.0,440,723,  1,  6
2024-07-01 09:14:59.199,1361,0,0,3.7,0.0,0.0,  0,0.0,0.0,404,723,  1,  6
2024-07-01 09:14:59.199,1361,1,1,3.7,-4.2,0.0,326,0.0,0.0,404,723,  1,  6
2024-07-01 09:14:59.224,1362,0,0,3.6,0.0,0.0,  0,0.0,0.0,467,673,  2,  6
2024-07-01 09:14:59.224,1362,1,1,3.7,-4.9,0.0,327,0.0,0.0,467,673,  2,  6
2024-07-01 09:14:59.249,1363,0,0,3.6,0.0,0.0,  0,0.0,0.0,424,881,  1,  8
2024-07-01 09:14:59.249,1363,1,1,3.7,-5.9,18.7,346,0.0,0.0,424,881,  1,  8
2024-07-01 09:14:59.274,1364,0,0,3.6,0.0,0.0,  0,0.0,0.0,406,620,  1,  5
2024-07-01 09:14:59.274,1364,1,1,3.7,-3.6,18.7,328,0.0,0.0,406,620,  1,  5
2024-07-01 09:14:59.299,1365,0,0,3.6,0.0,0.0,  0,0.0,0.0,383,828,  1,  7
2024-07-01 09:14:59.299,1365,1,1,3.7,-3.7,18.7,305,0.0,0.0,383,828,  1,  7
2024-07-01 09:14:59.324,1366,0,0,3.6,0.0,0.0,  0,0.0,0.0,382,724,  1,  6
2024-07-01 09:14:59.324,1366,1,1,3.7,-4.7,18.7,304,0.0,0.0,382,724,  1,  6
2024-07-01 09:14:59.349,1367,0,0,3.6,0.0,0.0,  0,0.0,0.0,392,724,  1,  6
2024-07-01 09:14:59.349,1367,1,1,3.7,-5.3,18.7,314,0.0,0.0,392,724,  1,  6
2024-07-01 09:14:59.374,1368,0,0,3.6,0.0,0.0,  0,0.0,0.0,397,724,  1,  6
2024-07-01 09:14:59.374,1368,1,1,3.7,-5.3,18.7,319,0.0,0.0,397,724,  1,  6
2024-07-01 09:14:59.399,1369,0,0,3.6,0.0,0.0,  0,0.0,0.0,407,724,  1,  6
2024-07-01 09:14:59.399,1369,1,1,3.6,-6.7,18.7,329,0.0,0.0,407,724,  1,  6
2024-07-01 09:14:59.424,1370,0,0,3.7,0.0,0.0,  0,0.0,0.0,424,724,  1,  6
2024-07-01 09:14:59.424,1370,1,1,3.6,-7.7,18.7,346,0.0,0.0,424,724,  1,  6
2024-07-01 09:14:59.449,1371,0,0,3.6,0.0,0.0,  0,0.0,0.0,417,724,  1,  6
2024-07-01 09:14:59.449,1371,1,1,3.6,-8.8,18.7,339,0.0,0.0,417,724,  1,  6
2024-07-01 09:14:59.474,1372,0,0,3.6,0.0,0.0,  0,0.0,0.0,396,724,  1,  6
2024-07-01 09:14:59.474,1372,1,1,3.6,-10.1,18.7,318,0.0,0.0,396,724,  1,  6
2024-07-01 09:14:59.499,1373,0,0,3.6,0.0,0.0,  0,0.0,0.0,396,724,  1,  6
2024-07-01 09:14:59.499,1373,1,1,3.6,-11.6,18.7,318,0.0,0.0,396,724,  1,  6
2024-07-01 09:14:59.524,1374,0,0,3.6,0.0,0.0,  0,0.0,0.0,407,724,  1,  6
2024-07-01 09:14:59.524,1374,1,1,3.6,-12.1,18.7,329,0.0,0.0,407,724,  1,  6
2024-07-01 09:14:59.549,1375,0,0,3.7,0.0,0.0,  0,0.0,0.0,411,149,  1,  1
2024-07-01 09:14:59.549,1375,1,1,3.6,-12.1,18.7,333,0.0,0.0,411,149,  1,  1
2024-07-01 09:14:59.574,1376,0,0,3.6,0.0,0.0,  0,0.0,0.0,423,978,  1,  8
2024-07-01 09:14:59.574,1376,1,1,1.4,-13.3,18.7,345,0.0,0.0,423,978,  1,  8
2024-07-01 09:14:59.599,1377,0,0,3.6,0.0,0.0,  0,0.0,0.0,387,785,  1,  6
2024-07-01 09:14:59.599,1377,1,1,1.4,-13.3,18.7,309,0.0,0.0,387,785,  1,  6
2024-07-01 09:14:59.624,1378,0,0,3.7,0.0,0.0,  0,0.0,0.0,398,342,  1,  3
2024-07-01 09:14:59.624,1378,1,1,1.3,-15.1,18.7,320,0.0,0.0,398,342,  1,  3
2024-07-01 09:14:59.649,1379,0,0,3.6,0.0,0.0,  0,0.0,0.0,401,724,  1,  6
2024-07-01 09:14:59.649,1379,1,1,5.0,-15.7,18.7,323,0.0,0.0,401,724,  1,  6
2024-07-01 09:14:59.674,1380,0,0,3.6,0.0,0.0,  0,0.0,0.0,410,724,  1,  6
2024-07-01 09:14:59.674,1380,1,1,3.6,-16.3,18.7,332,0.0,0.0,410,724,  1,  6
2024-07-01 09:14:59.699,1381,0,0,3.7,0.0,0.0,  0,0.0,0.0,444,724,  1,  6
2024-07-01 09:14:59.699,1381,1,1,3.6,-16.9,18.7,366,0.0,0.0,444,724,  1,  6
2024-07-01 09:14:59.724,1382,0,0,3.7,0.0,0.0,  0,0.0,0.0,450,724,  1,  6
2024-07-01 09:14:59.724,1382,1,1,3.6,-17.4,18.7,372,0.0,0.0,450,724,  1,  6
2024-07-01 09:14:59.749,1383,0,0,3.7,0.0,0.0,  0,0.0,0.0,418,1448,  1, 12
2024-07-01 09:14:59.749,1383,1,1,3.6,-19.0,18.7,340,0.0,0.0,418,1448,  1, 12
2024-07-01 09:14:59.774,1384,0,0,3.7,0.0,0.0,  0,0.0,0.0,420,620,  1,  5
2024-07-01 09:14:59.774,1384,1,1,3.6,-19.9,18.7,342,0.0,0.0,420,620,  1,  5
2024-07-01 09:14:59.799,1385,0,0,3.7,0.0,0.0,  0,0.0,0.0,432,253,  1,  2
2024-07-01 09:14:59.799,1385,1,1,3.6,-19.9,18.7,354,0.0,0.0,432,253,  1,  2
2024-07-01 09:14:59.824,1386,0,0,3.6,0.0,0.0,  0,0.0,0.0,437,  0,  1,  0
2024-07-01 09:14:59.824,1386,1,1,3.6,-19.9,18.7,359,0.0,0.0,437,  0,  1,  0
2024-07-01 09:14:59.849,1387,0,0,3.6,0.0,0.0,  0,0.0,0.0,449,128,  1,  1
2024-07-01 09:14:59.849,1387,1,1,3.6,-19.9,18.7,371,0.0,0.0,449,128,  1,  1


it looks like the fractional seconds of 354-356 are 2 digits

and of instead of being interpreted as .024 they are interpreted as .240

this is actually how I would expect it to work, the problem is with my saving .024 as .24

fixed in pm and committed...

now I need to redeploy to pmh and kill all the old database....done...

save eveything and take m36 to garage...

done...

sessions do not seem to be scraping...bug in php strstartswith....

ok I now have some data...copy it to scat...shut down clients and go back inside....


all done but the going inside part....

now where was I before I fixed that bug in the data?

add number of model rows to charts....

in mbase:

      int mChartsWidgetSqlModelLimit = 400;


now put effective range label after that:

both in time and frames

then make it reload the model automatically...

Effective range: x frames x seconds

actual model rows
actual model range
 
I should store these values in mbase so I can see them in controls

      // x axis ranges of sql model
      QDateTime mChartsWidgetModelXAxisDateTimeStart;
      QDateTime mChartsWidgetModelXAxisDateTimeEnd;
      
      int mChartsWidgetModelXAxisFrameStart;
      int mChartsWidgetModelXAxisFrameEnd;




I think I want to try QFormLayout:


put these things in it:

Plot Line Size
x axis frame or date time
slq limit
theme
keep series color
label for range...





how to add a separator line:

void QUtility::insertSeparator(QGridLayout *layout, int row, int columnSpan) {
  QFrame *separator = new QFrame(this);
  separator->setLineWidth(1);
  separator->setMidLineWidth(1);
  separator->setFrameShape(QFrame::HLine);
  separator->setPalette(QPalette(QColor(0, 0, 0)));

  layout->addWidget(separator, row, 0, 1, columnSpan);
}



It took hours to figure this out!!!

I had a QGridLayout and I added a QFormLayout at a lower position like 3,0

now matter what I did the QForm was at 0,0 in the grid.

then I tried a boxlayout, same thing, form is in top left corner..

finally got it to work by putting a groupbox at that location, then adding formlayout to the groupbox

looks like you cannot add QFormLayout to another layout...

anyways, I am very happy with how it looks.

Make a combox for xaxis units..done

now do one for the other...done..

I am happy with this for now, one last thing, can I make the chart controls right aligned against the charts...yes...


Now I want to clean up the table stuff

make my own form layout for that...

should I make it its own class just like charts controls??


lets make mTablesWidgetControlWidget

I have done that and started the implementation...

I find I will need to make mTablesWidget now so I can implement functions from controlwidget there...


it is really coming along nicely....

now I want to sort out the updating of table and all tangled siagnals there...

looks like it all starts with sessions calling do sql changed
this will be common for tables and charts.

change this to a function call in mbase called IDK... sessionSelectionChanged 

I think I will just update a WHERE sql string a sent signals to things that need to be updated

make sessions call mbase.sessionSelectionChanged()..done
then in mbase emit signal to update charts...done

now do the same for tables...

the major moving has been done...now just bugfixing...

do the limit..done

fix it so font works...

I am having a hell of a time resizing the 3 main panels...finally I gave up and used a splitter.

It looks great, but now I want to save and restore the splitter positions...

there are only 3 sizes...I could manually put them in mbase when changed...do it...

connect the splitter to a function in logview that saves the size to mbase
it was almost exactly like what I did in chartView...works great...

now back to why font size is not working...fixed


next sql limit


what should it trigger? full update...done 
rows and cols are done...now save them in settings...done


make sessions where clause common...



void mTablesWidget::updateTables()
{
//   qDebug() << "mTablesWidget::updateTables()";

   QString pml_sql_all;

   QString sql = "created BETWEEN '";
   sql += mbase.sessionsDtStart.toString("yyyy-MM-dd HH:mm:ss.z");
   sql += "' AND '";
   sql += mbase.sessionsDtEnd.toString("yyyy-MM-dd HH:mm:ss.z");
   sql += "'";



void mChartsWidget::update()
{

   // update the sql model
   // ----------------------------
   QString sqlw = "timestamp BETWEEN '";
   sqlw += mbase.sessionsDtStart.toString("yyyy-MM-dd HH:mm:ss.z");
   sqlw += "' AND '";
   sqlw += mbase.sessionsDtEnd.toString("yyyy-MM-dd HH:mm:ss.z");
   sqlw += "'";

      QString   sessionsSqlWhereDateClause;


I have done that....


20240714 10:00PM

copy all sources to pm folder and do a push







20240715

wtf is going on? how did I lose my last typing? CTRL-R == reload from disk...


I reall want to make a global position that persists between charts and tables

in tables I have the highlight, but its not super noticeable

in charts I have the crosshairs



could I do something like crosshairs for tables?

also something better for charts...
something that persists

also something that removes the mouse crosshairs when the mouse is not there.
or always diplays crosshairs!!, but uses global position when mouse is not on chart

also I want to have the same crosshairs on all charts...
you know what else would be nice? only one x axis...
they are all common anyway so why do I need to show them all...

then on mTableView...
- customize number of tables
- first one can be all players or only p0
- second and more can be customized to be p1, p2 etc...




make model range only based on datetime...done
show model range for tables also
make a function to update mTablesWidgetControlWidget
then connect a signal to it...done


making highlight on charts and making global cursor position

try making higlight black...

I was unable to make any changes to the TableView with my global dark theme

I think I will subclass QTableView...I wanted to do it anyway to draw overlays...

very similar to what I did with ChartView


mTableView has been added

now make mTableViewOverlay


I am having some issues:

when creating a graphicsItem I cant set the parent the to QTableView like I could with QChartView

then in my subclass mTableView I don't seem to have a scene....

I think there are some answer in here:

https://stackoverflow.com/questions/61216527/drawing-qgraphicslineitem-on-a-qtableview



what if I overload painter in mTableView...


I got nowhere.....giving up....



I think I figured something out:
QChartView is special. I can add scenes to it.


QChartView inherits QGraphicsView which has scene()


----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------


The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene
QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework.
To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example:


The QGraphicsScene class provides a surface for managing a large number of 2D graphical items.
The class serves as a container for QGraphicsItems. It is used together with QGraphicsView for visualizing graphical items, such as lines, rectangles, text, or even custom items, on a 2D surface


The QGraphicsItem class is the base class for all graphical items in a QGraphicsScene.
It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers.



So how do I do it in my mChartViewCrosshairs ?

I make a QGraphicsItem class:

class mChartViewCrosshairs : public QGraphicsItem

Then I make an instance in mChartView:
then I add that instance to mChartView's scene
(mChartView has a scene() because it inherits one from QChartView which inherits one from QGraphicsView)

class mChartView : public QChartView
{
   Q_OBJECT
   public:

      mChartView(QChart* chart = 0, QWidget* parent = 0, int index = 0) : QChartView(chart, parent)
      {
         mChartViewCrosshairsInstance = new mChartViewCrosshairs(chart);
         mChartViewCrosshairsInstance->setZValue(100); // to draw on top
         mChartViewCrosshairsInstance->setVisible(false);

         // if no scene has been set, set scene
         if (!mChartViewCrosshairsInstance->scene()) scene()->addItem(mChartViewCrosshairsInstance);



   private:
      mChartViewCrosshairs * mChartViewCrosshairsInstance = nullptr;

};


I think I know what is going on here...but does this help me draw on TableView?

do I want to draw on TableView? Is that the best way to do it?


OK so if I can't do it like that, how about my derived class mTableView and 
overide the painter...I think I tried to do that...


https://stackoverflow.com/questions/32653267/paintevent-in-qtableview-derived-class-paint-device-returned-engine-0-type

As QTableView is a subclass of QAbstractScrollArea you should open QPainter on its viewport:

void CDerivedFromQTableView::paintEvent(QPaintEvent *event)
{
    QTableView::paintEvent(event); // draw original content

    QPainter p(this->viewport());
    p.drawRect(0, 0, 20, 20);
}

OMG! that was it!!! it now works!!!



20240717 7:00AM

now I spent a few more hours figuring ou how to get the viewport size...this is it:


#ifndef MTABLEVIEW_H
#define MTABLEVIEW_H

#include <QTableView>
#include <QPainter>
#include <QGraphicsItem>

#include "m_base.h"

class mTableView : public QTableView
{
//   Q_OBJECT

   public:
//   explicit  mTableView(QWidget *parent = nullptr) {  }

   protected:
      void paintEvent(QPaintEvent *event)
      {
//         Q_UNUSED(event);

         QTableView::paintEvent(event); // draw original content

         QPainter painter(this->viewport());

         int w = this->viewport()->width() - 1;
         int h = this->viewport()->height() - 1;

         painter.setBrush(QColor(0, 0, 0));
         painter.setPen(QColor(255, 0, 0));

         QPainterPath path;

         /*

         QRect pa2(0, 0, w, h);

         path.addRect(pa2);
         painter.setPen(QColor(255, 0, 0));
         painter.drawPath(path);

         path.clear();
         pa2.adjust(2, 2, -2, -2);
         path.addRect(pa2);

         painter.setPen(QColor(255, 255, 0));
         painter.drawPath(path);

         path.clear();
         pa2.adjust(24, 24, -24, -24);
         path.addRoundedRect(pa2, 5, 5);

         path.moveTo(100, pa2.top());
         path.lineTo(100, pa2.bottom());
         path.moveTo(pa2.left(), 200);
         path.lineTo(pa2.right(), 200);

         painter.setPen(QColor(255, 0, 255));
         painter.drawPath(path);
*/

         QRectF pa(100, 100, 200, 200);
         path.clear();
         path.addRoundedRect(pa, 5, 5);

         painter.setPen(QColor(255, 255, 255));
         painter.setBrush(QColor(100, 100, 100));

         painter.drawPath(path);



now see if I can get some screen positions of cells, expecially selected cells...

Should I do that here, or in parent?

for now, here,

when drawing, look for selected items...

I can list the selected item index....


 

[pure virtual]
QRect QAbstractItemView::visualRect(const QModelIndex &index) const

Returns the rectangle on the viewport occupied by the item at index.

If your item is displayed in several areas then visualRect should return the primary area that contains index and not the complete area that index might encompasses, touch or cause drawing.

In the base class this is a pure virtual function.

See also indexAt() and visualRegionForSelection().
[pure virtual protected]
QRegion QAbstractItemView::visualRegionForSelection(const QItemSelection &selection) const

Returns the region from the viewport of the items in the giv


I finally have a simple way of drawing my own highlight of selected item:

#ifndef MTABLEVIEW_H
#define MTABLEVIEW_H

#include <QTableView>
#include <QPainter>
#include <QGraphicsItem>

#include "m_base.h"

class mTableView : public QTableView
{
   public:
   protected:
      void paintEvent(QPaintEvent *event)
      {
         QTableView::paintEvent(event); // draw original content

         QPainter painter(this->viewport());

         int w = this->viewport()->width() - 1;
         int h = this->viewport()->height() - 1;

         painter.setBrush(QColor(0, 0, 0, 0));
         painter.setPen(QColor(255, 255, 255));

         // get first item from list of selected items
         QModelIndexList selection = this->selectionModel()->selectedRows();
         if (selection.size())
         {
            QModelIndex index = selection.at(0);
            QRect rgr = visualRect(selection.at(0));
            rgr.setWidth(w);
            QPainterPath p;
            p.addRect(rgr);
            painter.drawPath(p);
         }
      }
   private:
};
#endif // MTABLEVIEW_H



Now what?


make the selected thing save a global cursor position (probabaly a datetime)
that I will show in all other things (other tableviews, charts)  


      // Global Cursor DateTime Position
      //------------------------------------------------------------
      QDateTime globalPosition;


Now set it when tableview it clicked..done...

now show it in charts



I dont think I will do it in crosshairs, i think I will make a new one called x axis cursor or something like that

mChartViewCursor

I think it is working, but how do I trigger a redraw...


how about in mbase, make a function to set globalPosition, then send signals to redraw...or update, or whatever


void m_base::updateGlobalPosition(QDateTime pos)
{
   globalPosition = pos;
   emit updateGlobalPositionSignal();
}


OK I think I have that done....


now make it so that clicking on chart sets globalPosition


in mChartView

       void mousePressEvent(QMouseEvent *event)
       {
          // call the main handler for this event
          QChartView::mousePressEvent(event);


          // set global cursor position
          if (event->button() == Qt::MouseButton::LeftButton)
          {

             qDebug() << "mChartView left mouse press event";

             qDebug() << "event->position" << event->position();

             QPointF val = chart()->mapToValue(event->position());

             qDebug() << "val: " << val;

             QDateTime cp = QDateTime::fromMSecsSinceEpoch(val.x());

             qDebug() << "cp: " << cp;

             mbase.updateGlobalPosition(cp);

------------------

much simpler....

       void mousePressEvent(QMouseEvent *event)
       {
          // call the main handler for this event
          QChartView::mousePressEvent(event);
          if (event->button() == Qt::MouseButton::LeftButton)
          {
             // set global cursor position
             QPointF val = chart()->mapToValue(event->position());
             mbase.updateGlobalPosition(QDateTime::fromMSecsSinceEpoch(val.x()));
          }
       }



Now make it so that table highlight is set when 

void m_base::updateGlobalPosition(QDateTime pos)

is called...


right now when a table is clicked, I have some custom code for each table
that finds the next model index that is not hidden on that table..


I need to to modify so that a click sets void m_base::updateGlobalPosition(QDateTime pos)
then calls something apropriate to set selected row on tables


I already have mousePressEvent in mTableView setting the globalPosition


make function in mTableWidget to update table selected rows


void mTablesWidget::updateRowSelection()
{
   // find the the first match >= mbase.globalPosition that is not hidden for each table and set selected row

   bool foundt1 = 0;
   bool foundt2 = 0;

   // cycle all rows in model
   for(int i=0; i<mTablesWidgetSqlQueryModel->rowCount(); i++)
   {
      if ((!foundt1) && (!foundt2))
      {
         // get player number from column 6
         QModelIndex qmi = mTablesWidgetSqlQueryModel->index(i, 6);
         QVariant v = qmi.model()->data(qmi, Qt::DisplayRole);
         int p = v.toInt();

         // get created from column 3
         qmi = mTablesWidgetSqlQueryModel->index(i, 3);
         v = qmi.model()->data(qmi, Qt::DisplayRole);
         QDateTime rdt = v.toDateTime();

         if (rdt >= mbase.globalPosition)
         {
            if ((p==0) && (!foundt1) && (!mTablesWidgetTableView1->isRowHidden(i)))
            {
               mTablesWidgetTableView1->selectRow(i);
               mTablesWidgetTableView1->update();
               foundt1 = true;
               qDebug() << "setting table1 selection to index:" << i << "  - time:" << rdt;
            }

            if ((p==1) && (!foundt2) && (!mTablesWidgetTableView2->isRowHidden(i)))
            {
               mTablesWidgetTableView2->selectRow(i);
               mTablesWidgetTableView2->update();
               foundt2 = true;
               qDebug() << "setting table2 selection to index:" << i << "  - time:" << rdt;
            }
         }
      }
   }
}

this does it!!


remove this:

void mTablesWidget::on_tb1_clicked(QModelIndex indx)
{
   // get first item from list of selected items
   QModelIndexList selection = mTablesWidgetTableView1->selectionModel()->selectedRows();
   QModelIndex index = selection.at(0);

   int row = index.row(); // starting row
   int wd = 100;          // max num of rows to look through
   while ((mTablesWidgetTableView2->isRowHidden(++row)) && (--wd > 0));

   if (!(mTablesWidgetTableView2->isRowHidden(row))) // did we find a non hidden row?
   {
      //   qDebug() << "first unhidden row in table2" << row;
      mTablesWidgetTableView2->selectRow(row);
      mTablesWidgetTableView2->scrollTo(mTablesWidgetSqlQueryModel->index(row, 0));
   }
   //  else qDebug() << "no unhidden rows in table2";
}

void mTablesWidget::on_tb2_clicked(QModelIndex indx)
{
   // get first item from list of selected items
   QModelIndexList selection = mTablesWidgetTableView2->selectionModel()->selectedRows();
   QModelIndex index = selection.at(0);

   int row = index.row(); // starting row
   int wd = 100;          // max num of rows to look through
   while ((mTablesWidgetTableView1->isRowHidden(++row)) && (--wd > 0));

   if (!(mTablesWidgetTableView1->isRowHidden(row))) // did we find a non hidden row?
   {
      //   qDebug() << "first unhidden row in table1" << row;
      mTablesWidgetTableView1->selectRow(row);
      mTablesWidgetTableView1->scrollTo(mTablesWidgetSqlQueryModel->index(row, 0));
   }
   //  else qDebug() << "no unhidden rows in table1";
}

// how can I overide global style here:...
//   setStyleSheet("QTableView {selection-background-color: plum;}");
//   setStyleSheet("QTableView {selection-background-color: red;}");
//   setStyleSheet("QTableView {selection-background-color: red;}");

//   connect(mTablesWidgetTableView1, SIGNAL(clicked(QModelIndex)), this, SLOT (on_tb1_clicked(QModelIndex)));
//   connect(mTablesWidgetTableView2, SIGNAL(clicked(QModelIndex)), this, SLOT (on_tb2_clicked(QModelIndex)));

   //  colors

//   const QString ss = "QCheckBox {  color: %1 }";
//   legendSel[i]->setStyleSheet(legendSel[i]->styleSheet() + ss.arg(mbase.statChartSeriesStructArray[i].col.name()));

//   const QString ss = "QCheckBox {  color: %1 }";
//   mTablesWidgetTableView1->setStyleSheet(mTablesWidgetTableView1->styleSheet() + ss.arg(mbase.statChartSeriesStructArray[i].col.name()));

//   const QString ss = "QTableView#test1 { selection-background-color: red;}";
//   mTablesWidgetTableView1->setStyleSheet(mTablesWidgetTableView1->styleSheet() + ss);


//   mTablesWidgetTableView1->setStyleSheet("QTableView { selection-background-color: red;}");


//   setStyleSheet("QTableView#test1 { selection-background-color: red;}");





bug - why does my highlight not work if id column is hidden?
bug - why does clicking on t2 not update t1 fixed



what happens is the selection seems to default to column zero, and if column zero is hidden the size returned is zero

         // get first item from list of selected items
         QModelIndexList selection = this->selectionModel()->selectedRows();
         if (selection.size())
         {
            QModelIndex index = selection.at(0);
            QRect rgr = visualRect(index);


if I manually find a sibling that is not hidden is seems to work:

            QModelIndex index = selection.at(0).siblingAtColumn(3);


so a fix is to find the first visible column and use that...done...


         // get first item from list of selected items
         QModelIndexList selection = this->selectionModel()->selectedRows();
         qDebug() << "selection.size()" << selection.size();
         if (selection.size())
         {
            // find first non hidden column
            int col = -1;
            for (int i=9; i>-1; i--)
               if (mbase.col_types[i].valid)
                  if (mbase.col_types[i].shown) col = i;

            if (col != -1)
            {
               QModelIndex index = selection.at(0).siblingAtColumn(col);
               QRect rgr = visualRect(index);
               rgr.setWidth(this->viewport()->width() - 1);
               QPainterPath path;
               path.addRect(rgr);
               painter.drawPath(path);
            }
         }
      }



now I need to figure out what tables are actually doing for player filter
right now table 1 also has some player 2 stuff
added code to hide from both tables if p>1

where can I add player selection for tables?

- number of tables (1-4)

players to show in each table

all, selected only...

20240719 7:35

It looks like the next 2 big things are:

- number of tables and player filters for each table

- session widget visual stuff:
show sessions visually.
show regions of that with viewable rectangles and global position




-------

tableViews. what variables do I need?


how many tableViews? (int)  limit 4?
array of structs for each
includes

mTableView
somthing to filter players for each tableview





------------------
resizing columns

I had this code at the end 

void mTablesWidget::updateTablesHiddenColumns()
{
   for (int i=0; i<10; i++)
      if (mbase.col_types[i].valid)
      {
         if (mbase.col_types[i].shown == 0)
         {
            mTablesWidgetTableView1->hideColumn(i);
            mTablesWidgetTableView2->hideColumn(i);
         }
         else
         {
            mTablesWidgetTableView1->showColumn(i);
            mTablesWidgetTableView2->showColumn(i);
         }
      }
//   mTablesWidgetTableView1->resizeColumnsToContents();
//   mTablesWidgetTableView2->resizeColumnsToContents();
}


but it doesn't seem to do anything...

QHeaderView.ResizeToContents

QHeaderView::setResizeContentsPrecision(int precision)


is this part of chartView?

I want to try this

also I want to also adjust header font...








-----
why does header font size not kick in until first font change, what get called then that never gets called before?

its not:
void mTablesWidget::doFontSizeChange(void)

I cant figure it out...

make it simpler...

only one function to set table font in mbase, not 2

pass it the font size..

done...

now this whole set font thing is much simpler:


in m_base:

      // mTablesWidget
      //------------------------------------------------------------
      QFont mTablesWidgetFont;
      int mTablesWidgetFontSize = 8;
      void mTablesWidgetFontChangeFunction(int fontSize);

I have this function to do it:

void m_base::mTablesWidgetFontChangeFunction(int fontSize)
{
   qDebug() << "void m_base::mTablesWidgetFontChangeFunction(int fontSize)" << fontSize;
   mTablesWidgetFontSize = fontSize;
   mTablesWidgetFont = QFont{ "Courier", mTablesWidgetFontSize, QFont::Monospace };
   emit mTablesWidgetFontChangeSignal();
}

in mTablesWidgetControlWidget:

initialize:

   // -----------------------------------------------------------------------
   // font size spin box
   // -----------------------------------------------------------------------
   QSpinBox * fontSizeSpinBox = new QSpinBox();
   fontSizeSpinBox->setRange(4, 20);

   // get initial value from settings
   int fontSize = mbase.settings->value("mTablesWidgetFontSize", 10).toInt();
   mbase.mTablesWidgetFontChangeFunction(fontSize);
   fontSizeSpinBox->setValue(fontSize);

   formLayout->addRow(tr("Table Font Size:"), fontSizeSpinBox);
   connect(fontSizeSpinBox, SIGNAL (valueChanged(int)), this, SLOT (fontSizeChanged(int)));

change:

void mTablesWidgetControlWidget::fontSizeChanged(int val)
{
   qDebug() << "void mTablesWidgetControlWidget::fontSizeChanged(int val)";
   mbase.mTablesWidgetFontChangeFunction(val);
   mbase.settings->setValue("mTablesWidgetFontSize", mbase.mTablesWidgetFontSize);
}


in mTablesWidget:

mTablesWidget::mTablesWidget(QWidget *parent) : QWidget{parent}
{
   connect(&mbase, SIGNAL(mTablesWidgetFontChangeSignal()),     this, SLOT(doFontSizeChange()));

void mTablesWidget::doFontSizeChange(void)
{
   // qDebug() << "void mTablesWidget::doFontSizeChange(void)";

   mTablesWidgetTableView1->setFont(mbase.mTablesWidgetFont);
   mTablesWidgetTableView2->setFont(mbase.mTablesWidgetFont);

   // get new row height
   QFontMetrics fm(mbase.mTablesWidgetFont);
   int height = fm.height() - 2;

   mTablesWidgetTableView1->verticalHeader()->setMinimumSectionSize( height );
   mTablesWidgetTableView1->verticalHeader()->setMaximumSectionSize( height );
   mTablesWidgetTableView1->verticalHeader()->setDefaultSectionSize( height );

//   mTablesWidgetTableView1->resizeRowsToContents();

   mTablesWidgetTableView1->resizeColumnsToContents();


//   mTablesWidgetTableView1->horizontalHeader()->setFont(mbase.mTablesWidgetFont);


   mTablesWidgetTableView1->viewport()->update();

   mTablesWidgetTableView2->verticalHeader()->setMinimumSectionSize( height );
   mTablesWidgetTableView2->verticalHeader()->setMaximumSectionSize( height );
   mTablesWidgetTableView2->verticalHeader()->setDefaultSectionSize( height );
   mTablesWidgetTableView2->resizeColumnsToContents();
   mTablesWidgetTableView2->viewport()->update();

//   mTablesWidgetTableView1->horizontalHeader()->setMinimumSectionSize(-1);

}
void mTablesWidget::updateTables()
{
   //qDebug() << "mTablesWidget::updateTables()";

   doFontSizeChange();
   updateTablesHiddenColumns();
   showHideRowsBasedOnPlayer();

so now that this is simplified, fonts seem to load initially properly

onto the next issue:

this line seems necesary:

   mTablesWidgetTableView1->resizeColumnsToContents();





QHeaderView::ResizeMode QHeaderView::sectionResizeMode(int logicalIndex) const


Constant	Value	Description
QHeaderView::Interactive	0	The user can resize the section. The section can also be resized programmatically using resizeSection(). The section size defaults to defaultSectionSize. (See also cascadingSectionResizes.)
QHeaderView::Fixed	2	The user cannot resize the section. The section can only be resized programmatically using resizeSection(). The section size defaults to defaultSectionSize.
QHeaderView::Stretch	1	QHeaderView will automatically resize the section to fill the available space. The size cannot be changed by the user or programmatically.
QHeaderView::ResizeToContents	3	QHeaderView will automatically resize the section to its optimal size based on the contents of the entire column or row. The size cannot be changed by the user or programmatically. (This value was introduced in 4.2)


are these the same?
   mTablesWidgetTableView1->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);
   mTablesWidgetTableView1->resizeColumnsToContents();

the second one still allows manual adjusting afterwards and needs to be called repeatedly

the first one can be called only once in mTableView constructor...do that...

I can't seem to get darkstyle to not mess with things...
mostly the font size of the header will not follow the size of the rest of the table
also the column width does not resize...

screw it, I don't want to waste time on this...


Now without the style I cant see the selected row in table...
made it red and thicker lines




20240720

lets work on the big one, visual session, model loaded range...

I should make sure I define exactly what I want before I start.

As a beginning test, make a new widget that displays rectangles

Do I want a graphicsView...I think I do?


A class that derives graphics view?

A widget that just draws itself?


made a new class mtest


The QGraphicsView class provides a widget for displaying the contents of a QGraphicsScene
QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable viewport. To create a scene with geometrical items, see QGraphicsScene's documentation. QGraphicsView is part of the Graphics View Framework.
To visualize a scene, you start by constructing a QGraphicsView object, passing the address of the scene you want to visualize to QGraphicsView's constructor. Alternatively, you can call setScene() to set the scene at a later point. After you call show(), the view will by default scroll to the center of the scene and display any items that are visible at this point. For example:


The QGraphicsScene class provides a surface for managing a large number of 2D graphical items.
The class serves as a container for QGraphicsItems. It is used together with QGraphicsView for visualizing graphical items, such as lines, rectangles, text, or even custom items, on a 2D surface


The QGraphicsItem class is the base class for all graphical items in a QGraphicsScene.
It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers.



make a graphics scene

then add items to it

then make a graphics view


I have got that working...

now I want to make rectangles and detect if the mouse is on them



I think I need to connect to scene signal...

I am lost here...

do I need to subclass QGraphicsScene to re-implement mouseEvents??

I think this is the way....

https://stackoverflow.com/questions/26079807/function-getting-clicked-object-from-qgraphicsscene


No, you do it wrong. I wrote small example. You should subclass QGraphicsScene and reimplement mousePressEvent and process clicks in it. For example:

*.h

#ifndef GRAPHICSSCENE_H
#define GRAPHICSSCENE_H

#include <QGraphicsScene>
#include <QPoint>
#include <QMouseEvent>
class GraphicsScene : public QGraphicsScene
{
    Q_OBJECT
public:
    explicit GraphicsScene(QObject *parent = 0);

protected:
    void mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent);
};

#endif // GRAPHICSSCENE_H

In cpp

void GraphicsScene::mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent)
{
    //qDebug() << "in";
    if (mouseEvent->button() == Qt::LeftButton)
    {
        QGraphicsItem *item = itemAt(mouseEvent->scenePos(), QTransform());// it is your clicked item, you can do everything what you want. for example send it somewhere
        QGraphicsEllipseItem *ell = qgraphicsitem_cast<QGraphicsEllipseItem *>(item);
        if(ell)
        {
            ell->setBrush(QBrush(Qt::black));
        }
        else
            qDebug() << "not ell" << mouseEvent->scenePos();
        }

}

On the scene there are a few ellipses, when you click somewhere in scene we get item under cursor and check it is it ellipse for example. If is, then we set new background to it.

Main idea are itemAt method and qgraphicsitem_cast



This worked for me! I am on the right track!


I think I am ready to make the real thing.

Plan:

sessions

add all sessions to a scene
view only the section I want...
I already have sessions table in a model

iterate and add graphics items to a scene

what should I call this?

mSessionsTimelineWidget



coming along nicely...


do I need to make 2 models? or can I share?

I want player num also...
just add it to common


//      qDebug() << dts << dte;

      qint64 ds = dts.toSecsSinceEpoch();
      qint64 de = dte.toSecsSinceEpoch();

      qDebug() << p << ds << de;

      int he = 20;


      QPoint tl(ds, p*he);
      QPoint br(de, (p+1)*he-4);


      QRect r(tl, br);
      scene->addRect(r, pen);
      



-------------

so know when I click on one of those rectangles, I what to do something...

first of all


static const int ObjectName = 0;

QGraphicsItem *item = scene.itemAt(100, 50);
if (item->data(ObjectName).toString().isEmpty()) {
    if (qgraphicsitem_cast<ButtonItem *>(item))
        item->setData(ObjectName, "Button");
}








See also acceptTouchEvents().
void QGraphicsItem::setAcceptedMouseButtons(Qt::MouseButtons buttons)

Sets the mouse buttons that this item accepts mouse events for.

By default, all mouse buttons are accepted. If an item accepts a mouse button, it will become the mouse grabber item when a mouse press event is delivered for that button. However, if the item does not accept the mouse button, QGraphicsScene will forward the mouse events to the first item beneath it that does.

To disable mouse events for an item (i.e., make it transparent for mouse events), call setAcceptedMouseButtons(0).

See also acceptedMouseButtons() and mousePressEvent().


I think this does not work because I am not looking for events from QGraphicsItem, I am looking for events from QGraphisScene...


should I change it?

I would need to subclass mGraphicsItem, then re-implement mousePressEvent

it seems less hacky...???


what if I just let a mouse click select the item?
I think that is where I want to go any way...


do I still need to subclass mGraphicsItem??
I think I should...do it kind of like crosshairs


OK do it:

mSessionsGraphicsItem

now implement mousePressed...nice


now how about selected?

how to set and clear?

how to show?


void QGraphicsItem::setFlags(QGraphicsItem::GraphicsItemFlags flags)

Sets the item flags to flags. All flags in flags are enabled; all flags not in flags are disabled.

If the item had focus and flags does not enable ItemIsFocusable, the item loses focus as a result of calling this function. Similarly, if the item was selected, and flags does not enabled ItemIsSelectable, the item is automatically unselected.

By default, no flags are enabled. (QGraphicsWidget enables the ItemSendsGeometryChanges flag by default in order to track position changes.)

See also flags() and setFlag().




this->setFlag(QGraphicsItem::ItemIsSelectable, true);

if (this->isSelected()) framePen.setWidthF(3.8);


this was all I had to do!!!

CTRL allows multiple selections


now how to get min and max of all selected

connect to selection changed in scene


   scene = new QGraphicsScene();
   connect(scene, SIGNAL (selectionChanged()), this, SLOT (onSelectionChanged()));


void mSessionsTimelineWidget::onSelectionChanged()
{
   // qDebug() << "void mSessionsTimelineWidget::onSelectionChanged()";

   mbase.sessionsDtStart = QDateTime::fromString("2100", "yyyy"); // set start to max
   mbase.sessionsDtEnd   = QDateTime::fromString("1900", "yyyy"); // set end to min

   QList<QGraphicsItem *> items = scene->selectedItems();
   if (items.count())
   {
      for (int i=0; i<items.count(); i++)
      {
         QRectF br = items[i]->boundingRect();
         QDateTime dts = QDateTime::fromSecsSinceEpoch(br.left());
         QDateTime dte = QDateTime::fromSecsSinceEpoch(br.right());
         if (dts < mbase.sessionsDtStart) mbase.sessionsDtStart = dts;
         if (dte > mbase.sessionsDtEnd)   mbase.sessionsDtEnd = dte;
      }
      mbase.sessionSelectionChanged();
   }
}


this is working well!!  now what?

I might use this as the main thing and not use the tableview...
I don't want to figure out how to syncronize the 2


what next?

I would like to be able to scroll and zoom sessions just like charts....

I also would like an x axis...

what if I overlaid all I have done so far on top of a chart




 










#include <QObject>
#include <QGraphicsView>

/*!
 * This class adds ability to zoom QGraphicsView using mouse wheel. The point under cursor
 * remains motionless while it's possible.
 *
 * Note that it becomes not possible when the scene's
 * size is not large enough comparing to the viewport size. QGraphicsView centers the picture
 * when it's smaller than the view. And QGraphicsView's scrolls boundaries don't allow to
 * put any picture point at any viewport position.
 *
 * When the user starts scrolling, this class remembers original scene position and
 * keeps it until scrolling is completed. It's better than getting original scene position at
 * each scrolling step because that approach leads to position errors due to before-mentioned
 * positioning restrictions.
 *
 * When zommed using scroll, this class emits zoomed() signal.
 *
 * Usage:
 *
 *   new Graphics_view_zoom(view);
 *
 * The object will be deleted automatically when the view is deleted.
 *
 * You can set keyboard modifiers used for zooming using set_modified(). Zooming will be
 * performed only on exact match of modifiers combination. The default modifier is Ctrl.
 *
 * You can change zoom velocity by calling set_zoom_factor_base().
 * Zoom coefficient is calculated as zoom_factor_base^angle_delta
 * (see QWheelEvent::angleDelta).
 * The default zoom factor base is 1.0015.
 */
class Graphics_view_zoom : public QObject {
  Q_OBJECT
public:
  Graphics_view_zoom(QGraphicsView* view);
  void gentle_zoom(double factor);
  void set_modifiers(Qt::KeyboardModifiers modifiers);
  void set_zoom_factor_base(double value);

private:
  QGraphicsView* _view;
  Qt::KeyboardModifiers _modifiers;
  double _zoom_factor_base;
  QPointF target_scene_pos, target_viewport_pos;
  bool eventFilter(QObject* object, QEvent* event);

signals:
  void zoomed();



#include "Graphics_view_zoom.h"
#include <QMouseEvent>
#include <QApplication>
#include <QScrollBar>
#include <qmath.h>

Graphics_view_zoom::Graphics_view_zoom(QGraphicsView* view)
  : QObject(view), _view(view)
{
  _view->viewport()->installEventFilter(this);
  _view->setMouseTracking(true);
  _modifiers = Qt::ControlModifier;
  _zoom_factor_base = 1.0015;
}

void Graphics_view_zoom::gentle_zoom(double factor) {
  _view->scale(factor, factor);
  _view->centerOn(target_scene_pos);
  QPointF delta_viewport_pos = target_viewport_pos - QPointF(_view->viewport()->width() / 2.0,
                                                             _view->viewport()->height() / 2.0);
  QPointF viewport_center = _view->mapFromScene(target_scene_pos) - delta_viewport_pos;
  _view->centerOn(_view->mapToScene(viewport_center.toPoint()));
  emit zoomed();
}

void Graphics_view_zoom::set_modifiers(Qt::KeyboardModifiers modifiers) {
  _modifiers = modifiers;

}

void Graphics_view_zoom::set_zoom_factor_base(double value) {
  _zoom_factor_base = value;
}

bool Graphics_view_zoom::eventFilter(QObject *object, QEvent *event) {
  if (event->type() == QEvent::MouseMove) {
    QMouseEvent* mouse_event = static_cast<QMouseEvent*>(event);
    QPointF delta = target_viewport_pos - mouse_event->pos();
    if (qAbs(delta.x()) > 5 || qAbs(delta.y()) > 5) {
      target_viewport_pos = mouse_event->pos();
      target_scene_pos = _view->mapToScene(mouse_event->pos());
    }
  } else if (event->type() == QEvent::Wheel) {
    QWheelEvent* wheel_event = static_cast<QWheelEvent*>(event);
    if (QApplication::keyboardModifiers() == _modifiers) {
      if (wheel_event->orientation() == Qt::Vertical) {
        double angle = wheel_event->angleDelta().y();
        double factor = qPow(_zoom_factor_base, angle);
        gentle_zoom(factor);
        return true;
      }
    }
  }
  Q_UNUSED(object)
  return false;
}

Usage example:

Graphics_view_zoom* z = new Graphics_view_zoom(ui->graphicsView);
z->set_modifiers(Qt::NoModifier);


pasted it in and I am vert happy with how it works...

now remove y axis zoom




havins issues with the whole thing...

first lets get the container to be the right size and not extend past the edge...

It seems like right now, the size of the graphic view controls the size of the containing group box

do i need to pass parent??



#include "m_base.h"

class mChartViewCrosshairs : public QGraphicsItem
{
   public:
      mChartViewCrosshairs(QChart *chart) : QGraphicsItem(chart), m_chart(chart) { }

      QRectF boundingRect() const override;
      void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
      void setMousePos(QPointF pos);

   protected:

   private:

      void setXAxisText();
      void setYAxisText();

      QFont m_font;
      QChart *m_chart = nullptr;

      QPointF mousePos;





I have been banging my head against the wall with this for quite a while:

Write it all down.


I have a QGraphicsView. It all seems to work fine.


What I cannot seem to make happen is the make the size of the QGraphicsView span the entire width of my main window.

Changing all the containers and layouts that it is in has no effect.

The only thing that does work is calling

view->setGeometry(0, 0, pa.width()-20, 200);

I can't do that in the contructor, the size of its parent is not valid yet.




After all that pain, I figured it out.
I added another wdiget after it and they were drawn on top of each other.
I did not set the hbox layout for this!!! not this all works...

   QHBoxLayout *hbox = new QHBoxLayout;
   this->setLayout(hbox);

   view = new QGraphicsView(scene, this);
   view->setRenderHint(QPainter::Antialiasing);
   view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
   view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
   view->setDragMode(QGraphicsView::ScrollHandDrag);

   hbox->addWidget(view);

that is all....






now I am having troubles with the hand mouse move

   view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
   view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);

   view->setDragMode(QGrahicsView::ScrollHandDrag);

It just does not work....

I set scale to 2,1 

I don't even get any indication on the scrollbar that it is capable of scrolling


I want to try this:

https://stackoverflow.com/questions/55007339/allow-qgraphicsview-to-move-outside-scene/55043082#55043082


class CustomGraphicsView : public QGraphicsView




#ifndef CUSTOMGRAPHICSVIEW_H
#define CUSTOMGRAPHICSVIEW_H

#include <QGraphicsView>

class CustomGraphicsView : public QGraphicsView
{
  Q_OBJECT
public:
  CustomGraphicsView(QWidget* parent = nullptr);

protected:
  virtual void wheelEvent(QWheelEvent* event) override;
  virtual void mouseMoveEvent(QMouseEvent* event) override;
  virtual void mousePressEvent(QMouseEvent* event) override;
  virtual void mouseReleaseEvent(QMouseEvent* event) override;

  void autocomputeSceneSize(const QList<QRectF>& region);
};

#endif  // CUSTOMGRAPHICSVIEW_H



#include "customview.h"

#include <QWheelEvent>

CustomGraphicsView::CustomGraphicsView(QWidget* parent) : QGraphicsView(parent)
{
  // Set up new scene
  setScene(new QGraphicsScene);

  // Do not show scroll bars
  setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
  setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

  // Connect scene update to autoresize
  connect(scene(), &QGraphicsScene::changed, this, &CustomGraphicsView::autocomputeSceneSize);
}

void CustomGraphicsView::wheelEvent(QWheelEvent* event)
{
  // if ctrl pressed, use original functionality
  if (event->modifiers() & Qt::ControlModifier)
    QGraphicsView::wheelEvent(event);
  // Rotate scene
  else if (event->modifiers() & Qt::ShiftModifier)
  {
    if (event->delta() > 0)
    {
      rotate(1);
    }
    else
    {
      rotate(-1);
    }
  }
  // Zoom
  else
  {
    ViewportAnchor previous_anchor = transformationAnchor();
    setTransformationAnchor(QGraphicsView::AnchorUnderMouse);
    if (event->delta() > 0)
    {
      scale(1.1, 1.1);
    }
    else
    {
      scale(0.9, 0.9);
    }
    setTransformationAnchor(previous_anchor);
  }
}

void CustomGraphicsView::mouseMoveEvent(QMouseEvent* event)
{
  QGraphicsView::mouseMoveEvent(event);
  if (event->buttons() & Qt::LeftButton)
    // If we are moveing with the left button down, update the scene to trigger autocompute
    scene()->update(mapToScene(rect()).boundingRect());
}

void CustomGraphicsView::mousePressEvent(QMouseEvent* event)
{
  if (event->buttons() & Qt::LeftButton)
    // Set drag mode when left button is pressed
    setDragMode(QGraphicsView::ScrollHandDrag);
  QGraphicsView::mousePressEvent(event);
}

void CustomGraphicsView::mouseReleaseEvent(QMouseEvent* event)
{
  if (dragMode() & QGraphicsView::ScrollHandDrag)
    // Unset drag mode when left button is released
    setDragMode(QGraphicsView::NoDrag);
  QGraphicsView::mouseReleaseEvent(event);
}

void CustomGraphicsView::autocomputeSceneSize(const QList<QRectF>& region)
{
  Q_UNUSED(region);

  // Widget viewport recangle
  QRectF widget_rect_in_scene(mapToScene(-20, -20), mapToScene(rect().bottomRight() + QPoint(20, 20)));

  // Copy the new size from the old one
  QPointF new_top_left(sceneRect().topLeft());
  QPointF new_bottom_right(sceneRect().bottomRight());

  // Check that the scene has a bigger limit in the top side
  if (sceneRect().top() > widget_rect_in_scene.top())
    new_top_left.setY(widget_rect_in_scene.top());

  // Check that the scene has a bigger limit in the bottom side
  if (sceneRect().bottom() < widget_rect_in_scene.bottom())
    new_bottom_right.setY(widget_rect_in_scene.bottom());

  // Check that the scene has a bigger limit in the left side
  if (sceneRect().left() > widget_rect_in_scene.left())
    new_top_left.setX(widget_rect_in_scene.left());

  // Check that the scene has a bigger limit in the right side
  if (sceneRect().right() < widget_rect_in_scene.right())
    new_bottom_right.setX(widget_rect_in_scene.right());

  // Set new scene size
  setSceneRect(QRectF(new_top_left, new_bottom_right));
}





this still has some of the same issues...

the thing is...if I can see the scrollbars with a grey area, I can drag scroll...



I can understand zooming out too much, then all the scene is visible and scrolling does not make sense...


but zooming in too much? why do my scroll bars dissappear when I do that?

is is because of the very large numbers I am using?

debug print them and see...

1 720 962 827

lets try dividing by 1000 before I put them in...it seems to work

I don't want to lose that much precision...can I just do an offset?


 C:\Users\m\Desktop\pm_log\build\Desktop_Qt_6_7_1_MinGW_64_bit-MinSizeRel\pm_log.exe...
ds 4102470000
de -2208963600


it looks like Qt uses qreal and QRectF...maybe I should too....

where will I do that?

tried that but it still has issues...


let me try an offset...


ds 4 102 470 000
de -2 208 963 600

those numbers are def too big!!



dsr 4102470000
der -2208963600


 QDateTime dts = QDateTime::fromString("2100", "yyyy"); // set start to max
   QDateTime dte = QDateTime::fromString("1900", "yyyy"); // set end to min

   qDebug() << "dts" << dts;
   qDebug() << "dte" << dte;

   qDebug() << "dts.toSecsSinceEpoch()" << dts.toSecsSinceEpoch();
   qDebug() << "dte.toSecsSinceEpoch()" << dts.toSecsSinceEpoch();

   qint64 dsi = dts.toSecsSinceEpoch();
   qint64 dei = dte.toSecsSinceEpoch();

   qDebug() << "dts_qint64" << dsi;
   qDebug() << "dte_qint64" << dei;

   qreal dsr = dts.toSecsSinceEpoch();
   qreal der = dte.toSecsSinceEpoch();

   qDebug() << "dts_real" << dsr;
   qDebug() << "dte_real" << der;

dts QDateTime(2100-01-01 00:00:00.000 Mountain Standard Time Qt::LocalTime)
dte QDateTime(1900-01-01 00:00:00.000 Mountain Standard Time Qt::LocalTime)
dts.toSecsSinceEpoch() 4102470000
dte.toSecsSinceEpoch() -2208963600
dts_qint64 4102470000
dte_qint64 -2208963600
dts_real 4.10247e+09
dte_real -2.20896e+09



dt QDateTime(2020-01-01 00:00:00.000 Mountain Standard Time Qt::LocalTime)
dt.toSecsSinceEpoch() 1 577 862 000
ds_qint64 1577862000
dts_real 1.57786e+09

even if it did work, scaling like this distorts the rectangles that I am drawing

what if, instead of scaling I change region of the scene
that does not seem to work




-----------------------------

I had a crazy idea...try to do this in a QChart

Also another idea, I should create more session data to text large date gaps...

I did that...


now my main clump of sessions is from 2024-07-14 and I have a new one from 2024-07-21

what if I restrict the range of session data I put in timeline widget

like maybe 1 hour, 1 day, etc then scroll that

the main problem is that the sessions are very small compared to the large gaps in between them

---------------------------
for now put this on hold

it is not crtical, I can still select sessions with the table

what I want to do now is:

the thing that displays the current selected session range as a large horizontal rectangle 
and shows the current position within that range

and shows the range of data loaded into the table model and charts model

what will I call this?

mCurrentSessionTimelineWidget


do it....



here is the thing... sure it is nice to scroll and zoom a view into a scene, but then the lines and text get distorted...
what if I took care of all the translation of coordinates myself..

like, treat my scene as 0,0 to width, height, then map those to actual dt_msec




map function

I should keep these values in my class


these are the 

      QDateTime sessionsDtStart;
      QDateTime sessionsDtEnd;

input start
input end
input range 

converted to mSecsinceEpoch

output start = 0;
output end = width of viewport (and scene)


    f(x) = (x - input_start) / (input_end - input_start) * (output_end - output_start) + output_start


OK implement it...

first make your class able to take a signal to update itself..done

now when we update, the first thing we should do is get the mapping variables and save them locally for convenience


moving right along, I have a great start
entire range, table model, chart model, global pos


now what?

well wasnt one of the main points of this to allow moving of those windows?

what about clicking to set new global pos?

then if that is out of the range of the models, move the model start position...

now we are getting into some core functionality that has been sorely needed!!




implement click ...

can I connect to viewport clicked?
viewport mouse press event

it looks like no matter how I do it I will need to subclass something, scene, view, item...

I think I will do it at view

mGraphicsViewSessionTimeline
maybe an h only??

I have the mouse event and position, now translate back to val...

I could have the view emit a signal and look for it in timeline widget
there I could translate back to val and updat globalpos

yes...do that...done...

#ifndef MGRAPHICSVIEWSESSIONTIMELINE_H
#define MGRAPHICSVIEWSESSIONTIMELINE_H

#include <QGraphicsView>
#include <QMouseEvent>

class mGraphicsViewSessionTimeline : public QGraphicsView
{
   Q_OBJECT
   public:
      mGraphicsViewSessionTimeline(QWidget* parent = nullptr) { }

   protected:
      virtual void mousePressEvent(QMouseEvent* event) override
      {
         emit timelineClicked(event->pos().rx());
      }

   signals:
      void timelineClicked(int xpos);

};
#endif // MGRAPHICSVIEWSESSIONTIMELINE_H


   view = new mGraphicsViewSessionTimeline(this);
   connect(view, SIGNAL(timelineClicked(int)), this, SLOT(onTimelineClicked(int)));

void mCurrentSessionTimelineWidget::onTimelineClicked(int pos)
{
   mbase.updateGlobalPosition(QDateTime::fromMSecsSinceEpoch(mapToVal(pos)));
}

this was pretty simple...


next...
when clicking on timeline and tables, charts are not updated
actually they are, but the line does not move until mouse over the charts
fixed..


now implement the model offset

each model has a certain start, end, and range
now add offset...
could it be just another DateTime? I think it should


right now these values are calculated, not set

      // x axis ranges of sql model
      QDateTime mChartsWidgetModelXAxisDateTimeStart;
      QDateTime mChartsWidgetModelXAxisDateTimeEnd;

when I do the query I could just use globalPos...try that as a start...


right now the sql uses start and end from
sessionsDtStart and End then has a limit



I made charts update its model

charts does not like to reload the model, but only when triggered from clicking on itself


lets follow that through


click on chart comes from where?

mChartView mousePressedEvent calls:
mbase.updateGlobalPosition(QDateTime::fromMSecsSinceEpoch(val.x()));

that emits updateGlobalPositionSignal();

which in mChartsWidget is connected to updateCursor

updateCursor calls reload

reload calls build charts, which deletes and rebuilds the very chartView this started from

to test it, temp disable that delete

what if I just went higher up before emitting that signal...
it works when the other 2 things emit it...



how would i do that?

what if Chartview signaled chartWidget and we did it from there...

remind me why I am deleteing and rebuilding charts??
I think it was so that I could change the x axis type

I should just abandon that...having frame number as x axis was never going to work well...was it?
I don't think it was...the problem was that frame numbers can get reset when a new level is started...


go ahead and remove all that....done

now remove all the deleting and recreating...done
done and working....


now I would like to make the start point a little earlier than the cursor, but how to do that?

a static amount, proportional amount

   // start 1 second before the cursor
   QDateTime start = mbase.globalPosition.addSecs(-1);

   // don't let start be before session start
   if (start < mbase.sessionsDtStart) start = mbase.sessionsDtStart;

this is not ideal...

the best way would be:
- find the index of the datetime that matches the cursor
probably wont be exact match...how about minimum dif between timestamp and cursor
- start the query at id - LIMIT/2
SELECT * FROM status WHERE id BETWEEN id_start AND id_end
this assumes that all id's and timestamps are sequential and well formed



SELECT id FROM status WHERE min ABS(timestamp-cursor)

SELECT id, ABS(timestamp - '2024-07-14 07:24:25') FROM status

SELECT id, MIN(ABS(TIMESTAMPDIFF(SECOND, timestamp, '2024-07-14 07:24:25'))) FROM status;

SELECT id FROM status where MIN(ABS(TIMESTAMPDIFF(SECOND, timestamp, '2024-07-14 07:24:25')));

"2024-07-14 07:24:25.0"

'2009-06-29 04:00:44';

From temp where mydate > STR_TO_DATE('2009-06-29 04:00:44', '%Y-%m-%d %H:%i:%s');

There are functions TIMEDIFF(expr1,expr2), which returns the value of expr1-expr2, and TIME_TO_SEC(expr3), which expresses expr3 in seconds.

Note that expr1 and expr2 are datetime values, and expr3 is a time value only.

Check this link for more info.
Share
Improve this answer
Follow
edited Apr 29, 2021 at 2:51
Gamopo's user avatar
Gamopo
1,59811 gold badge1414 silver badges2323 bronze badges
answered Jun 11, 2009 at 14:05
Matthew Jones's user avatar
Matthew Jones
26k1717 gold badges104104 silver badges156156 bronze badges
Add a comment
79

TIMESTAMPDIFF is like TIMEDIFF which Matthew states, except it returns the difference of the two datetimes in whatever units you desire (seconds, minutes, hours, etc).

For example,

SELECT TIMESTAMPDIFF(MINUTE,LogOutTime,LogInTime) AS TimeLoggedIn
FROM LogTable

Would return the number of minutes the user was logged in (assuming you stored this kind of thing in a table like that).





SELECT TOP 1 id, price FROM price WHERE id_quote=36 ORDER BY price ASC



SELECT TOP 1 id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25')) as mt FROM status ORDER BY mt ASC;


SELECT TOP 1 id, timestamp AS mt FROM status ORDER BY mt ASC;


SELECT p.*
FROM price p
WHERE p.id_quote = 36 AND
      p.price = (SELECT MIN(p2.price) FROM price p2 WHERE p2.id_quote = p.id_quote);

SELECT id, timestamp FROM status WHERE MIN(ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25'))) = (SELECT MIN(ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25'))) FROM status);

mallest number is this:

SELECT Id, name, price
FROM sampleTable
ORDER BY price ASC 
LIMIT 1;

finally after all that headaches I got this:

SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25')) as mt FROM status ORDER by mt ASC LIMIT 1;

now can I embed this in another query?

SELECT id, timestamp FROM status WHERE id BETWEEN 

((SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25')) as mt FROM status ORDER by mt ASC LIMIT 1)-10)

AND

((SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25')) as mt FROM status ORDER by mt ASC LIMIT 1)+10);

i think this does not work because the SELECT should return one value

ERROR 1241 (21000): Operand should contain 1 column(s)

SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '2024-07-14 07:24:25.0')) as mt FROM status ORDER by mt ASC LIMIT 1;

id_start = id-LIMIT/2
id_end = id+LIMIT/2




Here is the final result:

   // first get the id of the record closest to the cursor
   // ----------------------------------------------------   
   QString sql = "SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, timestamp, '";
   sql += mbase.globalPosition.toString("yyyy-MM-dd HH:mm:ss.z");
   sql += "')) as mt FROM status ORDER by mt ASC LIMIT 1;";
   // qDebug() << "sql:" << sql;
   QSqlQuery query;
   if (!query.exec(sql)) { qDebug() << query.lastError(); }
   query.next();
   int id = query.value(0).toInt();
   // qDebug() << "id:" << id;
   
   // update the sql model
   // ----------------------------
   sql = "SELECT * FROM status WHERE id BETWEEN ";
   int lim = mbase.mChartsWidgetSqlModelLimit / 2;
   sql += QString::number(id - lim);
   sql += " AND ";
   sql += QString::number(id + lim);
   // qDebug() << "sql:" << sql;
   statChartModel->setQuery(sql);


now do it for tables also

it does not work as well there...

If I use indexes lower than the start weird things happen

new algorithm:

- get the id of the record closest to the cursor
- get the id of the session start
- get the id of the session end

set start to cursor - lim/2
if less than session start set to session start

set end to start + lim
if end > session end set end to session end



I had a bunch on NULL in logs that were screwing things up...

now make changing timeline also change tables...




For each of tables and charts


when the session change reload model

when global position changes, only reload model if new pos is outside model...

start with tables...done
now charts


I have a bug in the tables filter shit

if I go from startid to end id and I hide lots of rows, I am not gaining anything

I need to use LIMIT

this whole thing does not make much sense for table...
going back half the limit, rarely will center it...and it takes a long time...


removed all this and went back to just using created as a filter

int mTablesWidget::getClosestIndexToDateTime(QDateTime dt)
{
   QString sql = "SELECT id, ABS(TIMESTAMPDIFF(MICROSECOND, created, '";
   sql += dt.toString("yyyy-MM-dd HH:mm:ss.z");
   sql += "')) as mt FROM logs ORDER by mt ASC LIMIT 1;";
   //qDebug() << "sql:" << sql;
   QSqlQuery query;
   if (!query.exec(sql)) { qDebug() << query.lastError(); }
   query.next();
   int id = query.value(0).toInt();
   // qDebug() << "id:" << id;
   return id;
}

void mTablesWidget::updateTables()
{
   qDebug() << "mTablesWidget::updateTables()";

   /*

   QElapsedTimer timer;
   timer.start();

   int cursorId       = getClosestIndexToDateTime(mbase.globalPosition);
   int sessionStartId = getClosestIndexToDateTime(mbase.sessionsDtStart);

   qDebug() << "2 sql queries took" << timer.elapsed() << "milliseconds";



   int sqlLimit = mbase.mTablesWidgetSqlModelLimit;

   // qDebug() << "cursorId:" << cursorId;
   // qDebug() << "sessionStartId:" << sessionStartId;
   // qDebug() << "sqlLimit:" << sqlLimit;

   // start at 1/2 limit less than cursor
   int sqlStartId = cursorId - sqlLimit / 2;

   // if less than session start, clamp to session start
   if (sqlStartId < sessionStartId) sqlStartId = sessionStartId;

   QString sql = "SELECT id, msg_type, sub_type, created, agt, frame_num AS frame, player AS p, client AS c, message";

   sql += " FROM logs WHERE id > ";
   sql += QString::number(sqlStartId);

   */

ok now to clean up charts the same way...it is looking great


what next?

bugs


changing visible charts
line size
all need me to reload the charts to see anything..


working on sizing the shit in logview



----------------------------

I am really wondering if somethings might be easier the ui layout

I have many nested layout

I got it to work with code only...



mLogView::mLogView(QWidget *parent) : QWidget{parent}
{
   
// ---------------------------------------------------
// first create all the things I will show here
// ---------------------------------------------------

   mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget(this);

   mTablesWidget * mTablesWidgetInstance = new mTablesWidget(this);

   mChartsWidgetInstance = new mChartsWidget(this);


   // ---------------------------------------------------------
   // middle panel
   // ---------------------------------------------------------
   QFrame * middlePanelFrame = new QFrame();
   middlePanelFrame->setLineWidth(0);
   middlePanelFrame->setMidLineWidth(0);
   middlePanelFrame->setFrameStyle(QFrame::Panel);
   middlePanelFrame->setMaximumWidth(640);


   // make vbox for frame
   QVBoxLayout *MPFvbox = new QVBoxLayout;

   // add vbox layout to frame
   middlePanelFrame->setLayout(MPFvbox);

   // ---------------------------------------------------------------------
   // mTablesWidgetControlWidget
   // ---------------------------------------------------------------------
   mTablesWidgetControlWidget * mTablesWidgetControlWidgetInstance = new mTablesWidgetControlWidget(this);
   MPFvbox->addWidget(mTablesWidgetControlWidgetInstance);

   // ---------------------------------------------------
   // sessions widget
   // ---------------------------------------------------
   mSessionsWidgetInstance = new mSessionsWidget(this);
   MPFvbox->addWidget(mSessionsWidgetInstance);

   // ---------------------------------------------------
   // charts controls widget
   // ---------------------------------------------------
   mChartsWidgetControlWidgetInstance = new mChartsWidgetControlWidget(this);

   // put it in its own hbox so I can push it over to the right
   QHBoxLayout *MPFhbox = new QHBoxLayout;
   MPFvbox->addLayout(MPFhbox);

   MPFhbox->addStretch();
   MPFhbox->addWidget(mChartsWidgetControlWidgetInstance);




// --------------------------------------------------------------------------
// layout
// --------------------------------------------------------------------------
   
   //-------------------------------------
   // make a frame to contain lower items
   //-------------------------------------
   
   
   // create frame
   QFrame * lowerFrame = new QFrame(this);
   lowerFrame->setLineWidth(0);
   lowerFrame->setMidLineWidth(0);
   lowerFrame->setFrameStyle(QFrame::Panel);

   // create layout and apply to frame
   QHBoxLayout *lowerFrameLayout = new QHBoxLayout;
   lowerFrame->setLayout(lowerFrameLayout);
   
   // instantiate splitter and add to layout
   splitter = new QSplitter(this);
   splitter->setChildrenCollapsible(false);
   splitter->setOrientation(Qt::Horizontal);
   splitter->setHandleWidth(8); // 5 is default
   lowerFrameLayout->addWidget(splitter);

   // add widgets to splitter
   splitter->addWidget(mTablesWidgetInstance);
   splitter->addWidget(middlePanelFrame);
   splitter->addWidget(mChartsWidgetInstance);
   
   
   
   
   //-------------------------------------
   // top level layout
   //-------------------------------------
   
   // create topLayout and apply to this->
   QVBoxLayout *topLayout = new QVBoxLayout;
   this->setLayout(topLayout);
   
   
   // when I do it this way the lower frame expands
   
   // make vertical splitter and add to layout
   QSplitter * vSplitter = new QSplitter(this);
   vSplitter->setChildrenCollapsible(false);
   vSplitter->setOrientation(Qt::Vertical);
   topLayout->addWidget(vSplitter);

   // add widgets to vsplitter
   vSplitter->addWidget(mCurrentSessionTimelineWidgetInstance);
   vSplitter->addWidget(lowerFrame);



   // when I do it this way, the lower frame does not expand

   // // add widgets to layout
   // topLayout->addWidget(mCurrentSessionTimelineWidgetInstance);
   // topLayout->addWidget(lowerFrame);


   readSplitterSizes();
   connect(splitter, SIGNAL(splitterMoved(int, int)), this, SLOT(saveSplitterSizes(int, int)));
}





--------------------------


20240722 6:51AM

I should push all these recent changes

done


next:

move sessions tableview to top area

legend for current session timeline

hide show config popups

do a sql setup modal dialog from menu

try dockable stuff

can I do a top level window?

floating...


It was trivial to make current session timeline widget its own window

- when instantiating, do not set parent:

//   mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget(this);
   mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget();
   mCurrentSessionTimelineWidgetInstance->setWindowFlags(windowFlags() | Qt::Window);
   mCurrentSessionTimelineWidgetInstance->show();



this is awesome!

I really want to try the dockable stuff....






in mainwindow set one widget a central:

setCentralWidget(textEdit);



 QDockWidget *dock = new QDockWidget(tr("Customers"), this);
    dock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    customerList = new QListWidget(dock);
    customerList->addItems(QStringList()
            << "John Doe, Harmony Enterprises, 12 Lakeside, Ambleton"
            << "Jane Doe, Memorabilia, 23 Watersedge, Beaton"
            << "Tammy Shea, Tiblanka, 38 Sea Views, Carlton"
            << "Tim Sheen, Caraba Gifts, 48 Ocean Way, Deal"
            << "Sol Harvey, Chicos Coffee, 53 New Springs, Eccleston"
            << "Sally Hobart, Tiroli Tea, 67 Long River, Fedula");
    dock->setWidget(customerList);
    addDockWidget(Qt::RightDockWidgetArea, dock);
    viewMenu->addAction(dock->toggleViewAction());


first of all this I changed the way I did things from:

   // centralWidget = new QWidget;
   // setCentralWidget(centralWidget);

   // // logview
   // mLogViewInstance = new mLogView(this);
   // QHBoxLayout *hbox = new QHBoxLayout;
   // centralWidget->setLayout(hbox);
   // hbox->addWidget(mLogViewInstance);

to:
   // logview
   mLogViewInstance = new mLogView(this);
   setCentralWidget(mLogViewInstance);



this works!!

   auto viewMenu = menuBar()->addMenu(tr("&View"));

   // sessions table
   QDockWidget *dock = new QDockWidget(tr("Sessions"), this);
   mSessionsWidget * mSessionsWidgetInstance = new mSessionsWidget(dock);
   dock->setWidget(mSessionsWidgetInstance);
   addDockWidget(Qt::RightDockWidgetArea, dock);
   viewMenu->addAction(dock->toggleViewAction());

   // sessions timeline
   dock = new QDockWidget(tr("Sessions Timeline"), this);
   mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget(dock);
   dock->setWidget(mCurrentSessionTimelineWidgetInstance);
   addDockWidget(Qt::TopDockWidgetArea, dock);
   viewMenu->addAction(dock->toggleViewAction());

now I want to clean up logview by removing all the unnecsary frame and group boxes, but first save a copy here...



// ---------------------------------------------------
// first create all the things I will show here
// ---------------------------------------------------

//   mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget(this);

   // mCurrentSessionTimelineWidget * mCurrentSessionTimelineWidgetInstance = new mCurrentSessionTimelineWidget();
   // mCurrentSessionTimelineWidgetInstance->setWindowFlags(windowFlags() | Qt::Window);
   // mCurrentSessionTimelineWidgetInstance->show();



   mTablesWidget * mTablesWidgetInstance = new mTablesWidget(this);

   mChartsWidgetInstance = new mChartsWidget(this);


   // ---------------------------------------------------------
   // middle panel
   // ---------------------------------------------------------
   QFrame * middlePanelFrame = new QFrame();
   middlePanelFrame->setLineWidth(0);
   middlePanelFrame->setMidLineWidth(0);
   middlePanelFrame->setFrameStyle(QFrame::Panel);


//   middlePanelFrame->setMaximumWidth(640);
   middlePanelFrame->setMaximumWidth(360);


   // make vbox for frame
   QVBoxLayout *MPFvbox = new QVBoxLayout;

   // add vbox layout to frame
   middlePanelFrame->setLayout(MPFvbox);

   // ---------------------------------------------------------------------
   // mTablesWidgetControlWidget
   // ---------------------------------------------------------------------
   mTablesWidgetControlWidget * mTablesWidgetControlWidgetInstance = new mTablesWidgetControlWidget(this);
   MPFvbox->addWidget(mTablesWidgetControlWidgetInstance);

   // ---------------------------------------------------
   // sessions widget
   // ---------------------------------------------------
//   mSessionsWidgetInstance = new mSessionsWidget(this);
//   MPFvbox->addWidget(mSessionsWidgetInstance);


   // mSessionsWidgetInstance = new mSessionsWidget();
   // mSessionsWidgetInstance->setWindowFlags(windowFlags() | Qt::Window);
   // mSessionsWidgetInstance->show();


   // ---------------------------------------------------
   // charts controls widget
   // ---------------------------------------------------
   mChartsWidgetControlWidgetInstance = new mChartsWidgetControlWidget(this);

   // put it in its own hbox so I can push it over to the right
   QHBoxLayout *MPFhbox = new QHBoxLayout;
   MPFvbox->addLayout(MPFhbox);

   MPFhbox->addStretch();
   MPFhbox->addWidget(mChartsWidgetControlWidgetInstance);




// --------------------------------------------------------------------------
// layout
// --------------------------------------------------------------------------

   //-------------------------------------
   // make a frame to contain lower items
   //-------------------------------------


   // create frame
   QFrame * lowerFrame = new QFrame(this);
   lowerFrame->setLineWidth(0);
   lowerFrame->setMidLineWidth(0);
   lowerFrame->setFrameStyle(QFrame::Panel);

   // create layout and apply to frame
   QHBoxLayout *lowerFrameLayout = new QHBoxLayout;
   lowerFrame->setLayout(lowerFrameLayout);

   // instantiate splitter and add to layout
   splitter = new QSplitter(this);
   splitter->setChildrenCollapsible(false);
   splitter->setOrientation(Qt::Horizontal);
   splitter->setHandleWidth(8); // 5 is default
   lowerFrameLayout->addWidget(splitter);

   // add widgets to splitter
   splitter->addWidget(mTablesWidgetInstance);
   splitter->addWidget(middlePanelFrame);
   splitter->addWidget(mChartsWidgetInstance);




   //-------------------------------------
   // top level layout
   //-------------------------------------

   // create topLayout and apply to this->
   QVBoxLayout *topLayout = new QVBoxLayout;
   this->setLayout(topLayout);


   // when I do it this way the lower frame expands

   // make vertical splitter and add to layout
   QSplitter * vSplitter = new QSplitter(this);
   vSplitter->setChildrenCollapsible(false);
   vSplitter->setOrientation(Qt::Vertical);
   topLayout->addWidget(vSplitter);

   // add widgets to vsplitter
//   vSplitter->addWidget(mCurrentSessionTimelineWidgetInstance);
   vSplitter->addWidget(lowerFrame);



   // when I do it this way, the lower frame does not expand

   // // add widgets to layout
   // topLayout->addWidget(mCurrentSessionTimelineWidgetInstance);
   // topLayout->addWidget(lowerFrame);

   readSplitterSizes();
   connect(splitter, SIGNAL(splitterMoved(int, int)), this, SLOT(saveSplitterSizes(int, int)));
}


figured out how to save dock widgets state...



20240723 6:52 AM

I am so happy with dock widgets!!!

now what?

add to table controls...multiple tables in array instead of static 2 tables

tableViews. what variables do I need?

how many tableViews? (int)  limit 4?
array of structs for each
includes

mTableView
somthing to filter players for each tableview


in class mTableWidget



filters:

player, client

client filter will only come into play is player is zero (server)

should each filter be an array of 8 bools?

this would be the max



most common setups:

server and one client
---------------------
2 tables
table 0  p:0 c:x
table 1  p:x c:dont care


all in one table
----------------
table 0 p:all c:all


server and all clients
----------------------
table 0  p:0 c:all
table 1  p>0

should I make one control for all tables or one for each table


how will I handle tableviews that I do not show?

should I create them and not show them?



how do I do it with charts?


make all tables active and create them

then only show visible...that seems to work...


now controls:

what about a strip on top of each table?
P 0 1 2 3 4 5 6 7 ALL NONE
C 0 1 2 3 4 5 6 7 ALL NONE

and even better only show for data that exists...

add number of tables control to controls 0-4

when this changes in controls, i will need to signal widgets...

this is all done...I can easily change the number of tables

now add filter to the top of each table

should I put each table in a frame?

should i make this table filter its own widget class?

class...mTablesWidgetTableFilter



do i need to put each table and controls in a frame then hide/show the frame?



am I thinking about this wrong?
what is the progression? struct -> class

should I make each table a class instead of a struct?
and include a frame and controls...yes do that...

mTablesWidgetTable

changed struct to class and added all struct var as public in class

runs...

now make fraem and filter part of class...



I think a bug that I run into quite often is not setting a layout for a widget...



I am having visibility issues again...I think I am going to put filters in mbase

wait, are they not members of ....


what if I just declare my instance of mTablesWidget in mbase

then I should be able to get everything else

now its is declared and instantiated in logView

   mTablesWidget * mTablesWidgetInstance = new mTablesWidget(this);


if I move the declaration to mbase, then I could do something like this:

mbase.mTablesWidgetInstance->mTablesWidgetTables[]->tableFilter[]

is this helping or making things more complicated?

would it be simpler to pass a pointer to the array to filter, so i could modify it there?

try that...




or I could fall back on the method I have been using else where:
- read from settings file when creating the control
- write to settings file when changing the control
- read from settings file when attempting to use values

this way I do not have to worry aboput what can see what, becasue everything can see the settings file...



lets do this for filters...
first figure out saving and restoring




void mTableWidgetsTable::saveFilter()
{
   //qDebug() << "mTableColumnSelectWidget::saveColumnSelection()";
   mbase.settings->beginWriteArray("mTableColumnSelect");
   for (int i=0; i<10; i++)
   {
      mbase.settings->setArrayIndex(i);
      mbase.settings->setValue("sel", mbase.col_types[i].shown);
      //qDebug() << "w:" << i << " - " << mbase.col_types[i].shown;
   }
   mbase.settings->endArray();
}


















void mTableColumnSelectWidget::readColumnSelection()
{
   //qDebug() << "mTableColumnSelectWidget::readColumnSelection()";
   mbase.settings->beginReadArray("mTableColumnSelect");
   for (int i=0; i<10; i++)
   {
      mbase.settings->setArrayIndex(i);
      mbase.col_types[i].shown = mbase.settings->value("sel", 1).toInt();
      //qDebug() << "r:" << i << " - " << mbase.col_types[i].shown;
   }
   mbase.settings->endArray();






declare in mbase:
      bool mTablesWidgetTableFilter[NUM_TABLES][2][8] = { 0 };

0 = player
1 = client
      
fix so that everything that uses it points there...done...

now save...


I never use active for tables, just remove it...

for that matter, what about visible? what is that used for..removed also...

now do something when checkboxes are changed

I think I have that working!!!

now make all none buttons work...

all the functionality is working and it is not too complex...



here it is in 90 lines:


#ifndef MTABLESWIDGETTABLEFILTER_H
#define MTABLESWIDGETTABLEFILTER_H

#include <QWidget>
#include <QBoxLayout>
#include <QGroupBox>
#include <QCheckBox>
#include <QPushButton>
#include "m_base.h"

class mTablesWidgetTableFilter : public QWidget
{
   Q_OBJECT
   public:
      mTablesWidgetTableFilter(QWidget *parent = nullptr, int id = 0)
      {
         // qDebug() << "mTablesWidgetTableFilter::mTablesWidgetTableFilter(QWidget *parent) : QWidget{parent}";

         tableId = id;

         // top level vbox
         QVBoxLayout *vbox = new QVBoxLayout;
         this->setLayout(vbox);

         // player filters GroupBox and hbox layout
         QHBoxLayout *pHbox = new QHBoxLayout;
         QGroupBox * pGb = new QGroupBox("Player Filter", this);
         pGb->setLayout(pHbox);
         vbox->addWidget(pGb);

         QPushButton * allP  = new QPushButton("all", this);
         QPushButton * noneP = new QPushButton("none", this);
         connect(allP,  SIGNAL (clicked()), this, SLOT (onPAllClicked()));
         connect(noneP, SIGNAL (clicked()), this, SLOT (onPNoneClicked()));
         pHbox->addWidget(noneP);
         pHbox->addWidget(allP);

         for (int i=0; i<8; i++)
         {
            pCb[i] = new QCheckBox(QString::number(i), this);
            pCb[i]->setChecked(mbase.mTablesWidgetTableFilter[tableId][0][i]);
            connect(pCb[i], SIGNAL (clicked()), this, SLOT (onPCbClicked()));
            pHbox->addWidget(pCb[i]);
         }


         // client filters GroupBox and hbox layout
         QHBoxLayout *cHbox = new QHBoxLayout;
         QGroupBox * cGb = new QGroupBox("Client Filter", this);
         cGb->setLayout(cHbox);
         vbox->addWidget(cGb);

         QPushButton * allC  = new QPushButton("all", this);
         QPushButton * noneC = new QPushButton("none", this);
         connect(allC, SIGNAL  (clicked()), this, SLOT (onCAllClicked()));
         connect(noneC, SIGNAL (clicked()), this, SLOT (onCNoneClicked()));
         cHbox->addWidget(noneC);
         cHbox->addWidget(allC);

         for (int i=0; i<8; i++)
         {
            cCb[i] = new QCheckBox(QString::number(i), this);
            cCb[i]->setChecked(mbase.mTablesWidgetTableFilter[tableId][1][i]);
            connect(cCb[i], SIGNAL (clicked()), this, SLOT (onCCbClicked()));
            cHbox->addWidget(cCb[i]);
         }
      }

   private slots:
      void onPAllClicked()   { for (int i=0; i<8; i++) pCb[i]->setChecked(true);   onPCbClicked();  }
      void onPNoneClicked()  { for (int i=0; i<8; i++) pCb[i]->setChecked(false);  onPCbClicked();  }
      void onPCbClicked()
      {
         for (int i=0; i<8; i++) mbase.mTablesWidgetTableFilter[tableId][0][i] = pCb[i]->checkState();
         mbase.mTablesWidgetTableFiltersChangeFunction();
      }
      void onCAllClicked()   { for (int i=0; i<8; i++) cCb[i]->setChecked(true);   onCCbClicked();  }
      void onCNoneClicked()  { for (int i=0; i<8; i++) cCb[i]->setChecked(false);  onCCbClicked();  }
      void onCCbClicked()
      {
         for (int i=0; i<8; i++) mbase.mTablesWidgetTableFilter[tableId][1][i] = pCb[i]->checkState();
         mbase.mTablesWidgetTableFiltersChangeFunction();
      }

   private:
   int tableId;
   QCheckBox * pCb[8];
   QCheckBox * cCb[8];
};
#endif // MTABLESWIDGETTABLEFILTER_H




void m_base::mTablesWidgetTableFiltersChangeFunction()
{
   //qDebug() << "void m_base::mTablesWidgetTableFiltersChangeFunction()";
   saveFilters();
   emit mTablesWidgetTableFiltersChangeSignal();
}

void m_base::saveFilters()
{
   // qDebug() << "void mbase::saveFilters()";
   for (int t=0; t<NUM_TABLES; t++)
      for (int f=0; f<2; f++)
      {
         QString id = "mTableFilter";
         id += QString::number(t);
         id += QString::number(f);

         mbase.settings->beginWriteArray(id);
         for (int p=0; p<8; p++)
         {
            mbase.settings->setArrayIndex(p);
            mbase.settings->setValue("val", mbase.mTablesWidgetTableFilter[t][f][p]);
            // qDebug() << "w:" << id << p << " - " << mbase.mTablesWidgetTableFilter[t][f][p];
         }
         mbase.settings->endArray();
      }
}

void m_base::loadFilters()
{
   // qDebug() << "void mbase::loadFilters()";
   for (int t=0; t<NUM_TABLES; t++)
      for (int f=0; f<2; f++)
      {
         QString id = "mTableFilter";
         id += QString::number(t);
         id += QString::number(f);

         mbase.settings->beginWriteArray(id);
         for (int p=0; p<8; p++)
         {
            mbase.settings->setArrayIndex(p);
            mbase.mTablesWidgetTableFilter[t][f][p] = mbase.settings->value("val", 1).toBool();
            // qDebug() << "r:" << id << p << " - " << mbase.mTablesWidgetTableFilter[t][f][p];
         }
         mbase.settings->endArray();
      }
}



#ifndef MTABLESWIDGETTABLE_H
#define MTABLESWIDGETTABLE_H

#include <QWidget>
#include <QBoxLayout>
#include <QGroupBox>
#include "m_base.h"

#include "mTableView.h"
#include "mTablesWidgetTableFilter.h"

class mTablesWidgetTable : public QWidget
{
   Q_OBJECT
   public:
      mTablesWidgetTable(QWidget *parent = nullptr, int id = 0, QSqlQueryModel * qm = nullptr)
      {
         tableId = id;

         QVBoxLayout *vbox1 = new QVBoxLayout;
         this->setLayout(vbox1);

         QString gbTitle = "Table:";
         gbTitle += QString::number(tableId);
         gb = new QGroupBox(gbTitle);
         vbox1->addWidget(gb);

         QVBoxLayout *vbox = new QVBoxLayout;
         gb->setLayout(vbox);

         tableFilter = new mTablesWidgetTableFilter(this, tableId);
         vbox->addWidget(tableFilter);

         tableView = new mTableView();
         tableView->setModel(qm);
         vbox->addWidget(tableView);
      }
   int tableId;
   QGroupBox * gb;
   mTableView * tableView = nullptr;
   mTablesWidgetTableFilter * tableFilter = nullptr;
};
#endif // MTABLESWIDGETTABLE_H

now make a button in controls to show hide filters..done



make message header left justified, where?
it looks like I can set the alignment of them all with setDefaultAlignment, but not individually....
I can do the cells with my delegate, but that does not affect the header...


See also QStyleOption::initFrom() and initStyleOptionForIndex().
[virtual protected, since 6.0]
void QHeaderView::initStyleOptionForIndex(QStyleOptionHeader *option, int logicalIndex) const

Initializes the style option from the specified logicalIndex. This function is called by the default implementation of paintSection after initStyleOption has been called.
This function was introduced in Qt 6.0.

I am giving up on this, too much work to simply change alignment of one column

//         this->horizontalHeader()->initStyleOptionForIndex(QStyleOptionHeader *option, 7);
//         this->horizontalHeader()->setDefaultAlignment(Qt::AlignLeft);
//         this->horizontalHeader()->setAlignment(Qt::AlignLeft);


bug where if number of table is zero, nothing happens?? all four show up...fixed


now see if I can remove group box to get more room
maybe make it a frame

ok spent some time making that look nice

now how about some helper functions to quickly set up some defaults 

call them from menu...


2 chart defaults

0
p0 and all client 

1
p1 and all clients


 
it works, but I need a way to make the stuff update back to the control widget....

update number of tables
update filters

what am I calling now?

   mTablesWidgetTableFiltersChangeFunction();


make a function in table filter to update check boxes...done...

but this will need to be called for every table....

what if I make its parent do it....mWidgetsTable...maybe even one higher...mTablesWidget...
this might get cyclic...this function is also called when filters change like this:

   connect(&mbase, SIGNAL(mTablesWidgetTableFiltersChangeSignal()),  this, SLOT(showHideRowsBasedOnPlayer()));


this seems to work, when I get this signal I call the function to reload filter cb from array....


niow I want to update the numtbales also...


now I need to also reload the numtable spinbox on controls

I think I jave that working but it is a huige tangled mess of signals and slots


I want to have one function that updates everything that can be updated in the UI

I will call it updateUI

stick it right under the constructor

use it to update all the widgets

this means that all the widgets need to have a pointer and a variable in mbase...



Lets start from the top of the list and work down:


variable in mbase:

      int numVisibleTables = 2;      

load from settings in updateUI:

   mbase.numVisibleTables = mbase.settings->value("numVisibleTables", 2).toInt();
   numTablesSpinBox->setValue(mbase.numVisibleTables);


   
   // -----------------------------------------------------------------------
   // number of tables spin box
   // -----------------------------------------------------------------------
   numTablesSpinBox = new QSpinBox();
   numTablespinBox->setRange(0, 4);
   connect(numTablesSpinBox, SIGNAL (clicked()), this, SLOT (numTablesClicked()));
   formLayout->addRow(tr("Number of Tables:"), numTablesSpinBox);


void mTablesWidgetControlWidget::numTablesClicked()
{
   // qDebug() << "void mTablesWidgetControlWidget::numTablesClicked()";
   mbase.numVisibleTables = numTablesSpinBox->value();   
   mbase.settings->setValue("mTablesWidgetNumTables", mbase.numVisibleTables);
   mbase.mTablesWidgetNumTablesChangeFunction();
}

   
the one last thing to do it fix the reload the first time

if 0 it does not work...fixed...



next one on the list...

   // -----------------------------------------------------------------------
   // show hide filter controls
   // -----------------------------------------------------------------------
   showHideFilterControls = new QPushButton("Show");
   showHideFilterControls->setCheckable(true);
   connect(showHideFilterControls, SIGNAL (toggled(bool)), this, SLOT (showHideFilterControlsToggled(bool)));
   formLayout->addRow(tr("Filter Controls:"), showHideFilterControls);


variable in mbase:

      bool showFilterControls = true;

load from settings in updateUI:


next one on the list

   // -----------------------------------------------------------------------
   // font size spin box
   // -----------------------------------------------------------------------




now I have all the controls on mTableWidgetControlWidget done
except for the 2 sub widgets row and column
I have been through them as well


now when I click default table filters, what happens?

it does show hide rows...
that could be cleaned up as well....




how about I have one update for mTablesWidget...or fewer...

I def need one for sql changed
this is the highest level and reloads everything

'updateNewSession'

also globalPosition is set to start of session externally













then one for current pos changed
this checks if new pos is in model range, and reloads model if it is not
'currentPositionChanged'

then one for font, columns, num tables, 
basically changes that should never have to reload the model...
'updateUI'

if row selection changed the model will need to be reloaded...





I basically want less entry points

cases that I want to force model reload:
- new session
- row selection changed
- current pos not in model range



cases where I am sure no model reload is needed:
- font change
- column change
- numtables change
- table filters changes
- show hide filter controls




these should all be lumped together as updateUI
lets start there
coming along nicely...now table filters..done

this is working great... now what?

are charts and charts controls just as messed up?
did a little cleanup...

table selected rows do not work past first 2 tables...


I need to rethink the whole algorithm

separate the part where I check if the new position is in the model


void mTablesWidget::updateGlobalPosition()
{
   // is new global position in model range
   if ((mbase.globalPosition >= mbase.mTablesWidgetModelXAxisDateTimeStart) && (mbase.globalPosition <= mbase.mTablesWidgetModelXAxisDateTimeEnd))
   {
      updateSelectedRow();
   }
   else reloadModel();
}

done...

now what?


cycle all rows in model and get created time

if row time >= global pos

for each active table:
   if model row is visible in that table: set selected row
   
   
   but only do the first one of each


void mTablesWidget::updateSelectedRow()
{
   //qDebug() << "mTablesWidget::updateSelectedRow()";
   bool found[4] = { false };
   // cycle all rows in model
   for (int r=0; r<mTablesWidgetSqlQueryModel->rowCount(); r++)
   {
      // get created from column 3
      QModelIndex qmi = mTablesWidgetSqlQueryModel->index(r, 3);
      QDateTime rdt = qmi.model()->data(qmi, Qt::DisplayRole).toDateTime();

      if (rdt >= mbase.globalPosition)
         for (int t=0; t<4; t++)
            if ((!found[t]) && (!mTablesWidgetTables[t]->tableView->isRowHidden(r)))
            {
               mTablesWidgetTables[t]->tableView->selectRow(r);
               found[t] = true;
            }
   }
   for (int t=0; t<4; t++)
      mTablesWidgetTables[t]->tableView->update();
}

this does it...


time to get ready for work...commit...

20240725 7:18 AM


remove update charts theme from menu...done

fix crosshairs alignment of lower and background color
also make crosshairs disapear when mouse leaves area

remove text boxes from bottom of session and add to sessions timeline
make variable for all three ranges and set when setting start and end

better yet, a function that you give 2 QDateTime and returns QString

QString mbase.getRangeText(QDateTime start, QDateTime end)













make session widget stretchbale in y axis...done


make highlight line in charts and selscted bow color in tables have a common color












why can I not find where I make the y axis in the charts not visible?
because I never did that...


the problem is in the code that sets all the chart to have a common axis

it uses: 
mbase.mChartsWidgetXAxisMin
mbase.mChartsWidgetXAxisMax

and this works when mouse wheel changes them, but I need to set these other places also....

          // get first x axis axis of chart
         QList qlxa = this->chart()->axes(Qt::Horizontal);

         // cast to QValueAxis to get min and max
         const auto va = static_cast<QValueAxis*>(qlxa.at(0));

         // set new min and max
         mbase.mChartsWidgetXAxisMin = va->min();
         mbase.mChartsWidgetXAxisMax = va->max();

now that I've finally got that figured out....



can I make the crosshairs disspear when no mouse is present?

      void leaveEvent(QEvent *event)
      {
         //qDebug() << "leaveEvent";
         mChartViewCrosshairsInstance->setVisible(false);
      }

it was that simple...

now can I line up the bottom crosshair label even if no x axis labels...yes

now make the crosshairs have one place where I set color
p and b



now make a clor for sessions...






I found this exmaple a while ago on the internet, but now I think there is a much better way to do it:

QColor c = mbase.log_types[i].color;
mlts_cb[i]->setStyleSheet(QString("background-color: rgba(%1,%2,%3,%4); border:  2px;").arg(c.red()).arg(c.green()).arg(c.blue()).arg(c.alpha()));


mlts_cb[i]->setStyleSheet("background-color: " + mbase.log_types[i].color.name(QColor::HexArgbQColor::HexArgb) + " ; border: 2px ;");





20240806

I took a break for a while. Seemed to be at a logical stopping place.

Today I came back and played with the alignments of row and column select, table controls and log view
renamed and rearranged groupboxes and layouts...code looks better now...



I want to do the modal pop up form for database setting and save in config...



minor annoyances:
the group of up to 4 tables...
there is extra space at the end when not all tables are shown

the spacing in the middle frame should always shrink to the minimum when moving splitters


why am I getting the warning about setting layouts twice?
creating layouts with 2nd parameter, "this" just dont do it....fixed



20240807

working on settings modal dialog with tabbed pages

added "Settings" to misc menu

made a class mSettingsDialog

figured out how to add tab widget, buttons, formlayout



20240808

figured out how to handle exec and accept with the class...

now I need a way to load and store values I change here to the settings file...


first make variables for all the database settings:
      
      QString dbHostName = "purplemartians.org";
      QString dbDatabaseName = "pm";
      QString dbUserName = "pmdb_ro";
      QString dbPassword = "readonly";

then load them from settings:

void m_base::setup_db(void)
{
   dbHostName     = settings->value("dbHostName",     "purplemartians.org").toString();
   dbDatabaseName = settings->value("dbDatabaseName", "pm").toString();
   dbUserName     = settings->value("dbUserName",     "pmdb_ro").toString();
   dbPassword     = settings->value("dbPassword",     "readonly").toString();

   db = QSqlDatabase::addDatabase("QMYSQL");
   db.setHostName(dbHostName);
   db.setDatabaseName(dbDatabaseName);
   db.setUserName(dbUserName);
   db.setPassword(dbPassword);
   if (!db.open()) qDebug() << "database error:" << db.lastError().text();

   sessionsModel = new QSqlQueryModel();
   sessionsModel->setQuery("SELECT dt_start, dt_end, duration AS dur, player_num AS p, hostname AS host, endreason FROM sessions ORDER by dt_start");
}


then in settings dialog, save them to file and call setup_db...

this works, but the reload after changing database parameters does not...
works fine when program is restarted


20240811 

remove a couple of classes from project...make copies here in here you need them later


#ifndef CUSTOMGRAPHICSVIEW_H
#define CUSTOMGRAPHICSVIEW_H

#include <QGraphicsView>

class CustomGraphicsView : public QGraphicsView
{
   Q_OBJECT
   public:
   CustomGraphicsView(QWidget* parent = nullptr);

   protected:
   virtual void wheelEvent(QWheelEvent* event) override;
   virtual void mouseMoveEvent(QMouseEvent* event) override;
   virtual void mousePressEvent(QMouseEvent* event) override;
   virtual void mouseReleaseEvent(QMouseEvent* event) override;

   void autocomputeSceneSize(const QList<QRectF>& region);
};

#endif  // CUSTOMGRAPHICSVIEW_H


#include "customgraphicsview.h"

#include <QWheelEvent>

CustomGraphicsView::CustomGraphicsView(QWidget* parent) : QGraphicsView(parent)
{
   // Set up new scene
   setScene(new QGraphicsScene);

   // Do not show scroll bars
   setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
   setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

   // Connect scene update to autoresize
   connect(scene(), &QGraphicsScene::changed, this, &CustomGraphicsView::autocomputeSceneSize);
}

void CustomGraphicsView::wheelEvent(QWheelEvent* event)
{
   // if ctrl pressed, use original functionality
   if (event->modifiers() & Qt::ControlModifier)
      QGraphicsView::wheelEvent(event);
   // Rotate scene
   else if (event->modifiers() & Qt::ShiftModifier)
   {
      if (event->angleDelta().ry() > 0)
      {
         rotate(1);
      }
      else
      {
         rotate(-1);
      }
   }
   // Zoom
   else
   {
      // ViewportAnchor previous_anchor = transformationAnchor();
      // setTransformationAnchor(QGraphicsView::AnchorUnderMouse);

      if (event->angleDelta().ry() > 0)
      {
         scale(1.1, 1.0);

         // qDebug() << "up";
         // QRectF sr = sceneRect();
         // qDebug() << sr;
         // sr.adjust(200, 0, -200, 0);
         // qDebug() << sr;
         // setSceneRect(sr);
         // this->update();


      }
      else
      {
         scale(0.9, 1.0);

         // QRectF sr = sceneRect();
         // sr.adjust(-200, 0, 200, 0);
         // setSceneRect(sr);


      }
//      setTransformationAnchor(previous_anchor);

   }
}

void CustomGraphicsView::mouseMoveEvent(QMouseEvent* event)
{
   QGraphicsView::mouseMoveEvent(event);
   if (event->buttons() & Qt::LeftButton)
      // If we are moveing with the left button down, update the scene to trigger autocompute
      scene()->update(mapToScene(rect()).boundingRect());
}

void CustomGraphicsView::mousePressEvent(QMouseEvent* event)
{
   if (event->buttons() & Qt::LeftButton)
      // Set drag mode when left button is pressed
      setDragMode(QGraphicsView::ScrollHandDrag);
   QGraphicsView::mousePressEvent(event);
}

void CustomGraphicsView::mouseReleaseEvent(QMouseEvent* event)
{
   if (dragMode() & QGraphicsView::ScrollHandDrag)
      // Unset drag mode when left button is released
      setDragMode(QGraphicsView::NoDrag);
   QGraphicsView::mouseReleaseEvent(event);
}

void CustomGraphicsView::autocomputeSceneSize(const QList<QRectF>& region)
{
   Q_UNUSED(region);

   // Widget viewport recangle
   QRectF widget_rect_in_scene(mapToScene(-20, 0), mapToScene(rect().bottomRight() + QPoint(20, 0)));

//   qDebug() << widget_rect_in_scene;



   // Copy the new size from the old one
   QPointF new_top_left(sceneRect().topLeft());
   QPointF new_bottom_right(sceneRect().bottomRight());

   // Check that the scene has a bigger limit in the top side
   if (sceneRect().top() > widget_rect_in_scene.top())
      new_top_left.setY(widget_rect_in_scene.top());

   // Check that the scene has a bigger limit in the bottom side
   if (sceneRect().bottom() < widget_rect_in_scene.bottom())
      new_bottom_right.setY(widget_rect_in_scene.bottom());

   // Check that the scene has a bigger limit in the left side
   if (sceneRect().left() > widget_rect_in_scene.left())
      new_top_left.setX(widget_rect_in_scene.left());

   // Check that the scene has a bigger limit in the right side
   if (sceneRect().right() < widget_rect_in_scene.right())
      new_bottom_right.setX(widget_rect_in_scene.right());

   // Set new scene size
   setSceneRect(QRectF(new_top_left, new_bottom_right));




}













#ifndef MSESSIONSTIMELINEWIDGET_H
#define MSESSIONSTIMELINEWIDGET_H

#include <QWidget>
#include <QGroupBox>
#include <QBoxLayout>
#include <QGraphicsScene>
#include <QGraphicsView>

#include "m_base.h"
#include "mSessionsGraphicsItem.h"


class mSessionsTimelineWidget : public QWidget
{
   Q_OBJECT
   public:
   mSessionsTimelineWidget(QWidget *parent = nullptr);

   private slots:
   void onSelectionChanged();

   private:
   QGraphicsScene * scene;
   QGraphicsView * view;
};

#endif // MSESSIONSTIMELINEWIDGET_H


#include "mSessionsTimelineWidget.h"
#include "mGraphicsViewZoom.h"

#include "customgraphicsview.h"



mSessionsTimelineWidget::mSessionsTimelineWidget(QWidget *parent) : QWidget{parent}
{
   scene = new QGraphicsScene();
   connect(scene, SIGNAL (selectionChanged()), this, SLOT (onSelectionChanged()));

   // add rects from session model
   // cycle all rows in model
   for(int i=0; i<mbase.sessionsModel->rowCount(); i++)
   {
      // get dt_start from column 0
      QModelIndex qmi = mbase.sessionsModel->index(i, 0);
      QVariant v = qmi.model()->data(qmi, Qt::DisplayRole);
      QDateTime dts = v.toDateTime();

      // get dt_end from column 1
      qmi = mbase.sessionsModel->index(i, 1);
      v = qmi.model()->data(qmi, Qt::DisplayRole);
      QDateTime dte = v.toDateTime();

      // get player_num from column 3
      qmi = mbase.sessionsModel->index(i, 3);
      v = qmi.model()->data(qmi, Qt::DisplayRole);
      int p = v.toInt();

      // get host from column 4
      qmi = mbase.sessionsModel->index(i, 4);
      v = qmi.model()->data(qmi, Qt::DisplayRole);
      QString host = v.toString();

      // get color from player num
      QColor col = mbase.statChartSeriesStructArray[p].col;

      qreal ds = dts.toSecsSinceEpoch()/100;
      qreal de = dte.toSecsSinceEpoch()/100;

      qreal rectHeight = 20;

      QPointF topLeft(ds, p * rectHeight);
      QPointF bottomRight(de, (p+1) * rectHeight - 4);

      QRectF r(topLeft, bottomRight);

      mSessionsGraphicsItem * temp = new mSessionsGraphicsItem(i, r, host, col);
      scene->addItem(temp);
   }

   // top level hbox
   QHBoxLayout *topHBox = new QHBoxLayout;
   this->setLayout(topHBox);


   QGroupBox * gb = new QGroupBox("Sessions", this);
   topHBox->addWidget(gb);


   QHBoxLayout *hbox = new QHBoxLayout;
   gb->setLayout(hbox);


   view = new CustomGraphicsView(this);
   view->setScene(scene);

//   view = new QGraphicsView(scene, this);

   view->setRenderHint(QPainter::Antialiasing);

   // view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
   // view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
   // view->setDragMode(QGraphicsView::ScrollHandDrag);
   view->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
   view->setMinimumHeight(156);
   view->scale(1, 1);

   hbox->addWidget(view);

//   mGraphicsViewZoom * z = new mGraphicsViewZoom(view);
//   z->set_modifiers(Qt::NoModifier);


}
void mSessionsTimelineWidget::onSelectionChanged()
{
/*
   QDateTime dts = QDateTime::fromString("2100", "yyyy"); // set start to max
   QDateTime dte = QDateTime::fromString("1900", "yyyy"); // set end to min

   qDebug() << "dts" << dts;
   qDebug() << "dte" << dte;

   qDebug() << "dts.toSecsSinceEpoch()" << dts.toSecsSinceEpoch();
   qDebug() << "dte.toSecsSinceEpoch()" << dte.toSecsSinceEpoch();

   qint64 dsi = dts.toSecsSinceEpoch();
   qint64 dei = dte.toSecsSinceEpoch();

   qDebug() << "dts_qint64" << dsi;
   qDebug() << "dte_qint64" << dei;

   qreal dsr = dts.toSecsSinceEpoch();
   qreal der = dte.toSecsSinceEpoch();

   qDebug() << "dts_real" << dsr;
   qDebug() << "dte_real" << der;
  */

   QDateTime dt = QDateTime::fromString("2020", "yyyy");
   qDebug() << "dt" << dt;
   qDebug() << "dt.toSecsSinceEpoch()" << dt.toSecsSinceEpoch();
   qint64 ds = dt.toSecsSinceEpoch();
   qDebug() << "ds_qint64" << ds;
   qreal dr = dt.toSecsSinceEpoch();
   qDebug() << "dts_real" << dr;


   QList<QGraphicsItem *> items = scene->selectedItems();
   if (items.count())
   {
      for (int i=0; i<items.count(); i++)
      {
         QRectF br = items[i]->boundingRect();
         QDateTime dts = QDateTime::fromSecsSinceEpoch(br.left());
         QDateTime dte = QDateTime::fromSecsSinceEpoch(br.right());
         if (dts < mbase.sessionsDtStart) mbase.sessionsDtStart = dts;
         if (dte > mbase.sessionsDtEnd)   mbase.sessionsDtEnd = dte;
      }
      mbase.sessionSelectionChanged();
   }
}



#ifndef MGRAPHICSVIEWZOOM_H
#define MGRAPHICSVIEWZOOM_H


#include <QObject>
#include <QGraphicsView>

/*!
 * This class adds ability to zoom QGraphicsView using mouse wheel. The point under cursor
 * remains motionless while it's possible.
 *
 * Note that it becomes not possible when the scene's
 * size is not large enough comparing to the viewport size. QGraphicsView centers the picture
 * when it's smaller than the view. And QGraphicsView's scrolls boundaries don't allow to
 * put any picture point at any viewport position.
 *
 * When the user starts scrolling, this class remembers original scene position and
 * keeps it until scrolling is completed. It's better than getting original scene position at
 * each scrolling step because that approach leads to position errors due to before-mentioned
 * positioning restrictions.
 *
 * When zommed using scroll, this class emits zoomed() signal.
 *
 * Usage:
 *
 *   new Graphics_view_zoom(view);
 *
 * The object will be deleted automatically when the view is deleted.
 *
 * You can set keyboard modifiers used for zooming using set_modified(). Zooming will be
 * performed only on exact match of modifiers combination. The default modifier is Ctrl.
 *
 * You can change zoom velocity by calling set_zoom_factor_base().
 * Zoom coefficient is calculated as zoom_factor_base^angle_delta
 * (see QWheelEvent::angleDelta).
 * The default zoom factor base is 1.0015.
 */


class mGraphicsViewZoom : public QObject
{
   Q_OBJECT
   public:
   mGraphicsViewZoom(QGraphicsView* view);
   void gentle_zoom(double factor);
   void set_modifiers(Qt::KeyboardModifiers modifiers);
   void set_zoom_factor_base(double value);

   private:
   QGraphicsView* _view;
   Qt::KeyboardModifiers _modifiers;
   double _zoom_factor_base;
   QPointF target_scene_pos, target_viewport_pos;
   bool eventFilter(QObject* object, QEvent* event);

   signals:
   void zoomed();

};

#endif // MGRAPHICSVIEWZOOM_H



#include "mGraphicsViewZoom.h"

#include <QMouseEvent>
#include <QApplication>
#include <QScrollBar>
#include <qmath.h>



mGraphicsViewZoom::mGraphicsViewZoom(QGraphicsView* view)
    : QObject(view), _view(view)
{
   _view->viewport()->installEventFilter(this);
   _view->setMouseTracking(true);
   _modifiers = Qt::ControlModifier;
   _zoom_factor_base = 1.0015;
}

void mGraphicsViewZoom::gentle_zoom(double factor)
{
   _view->scale(factor, 1.0);
   _view->centerOn(target_scene_pos);
   QPointF delta_viewport_pos = target_viewport_pos - QPointF(_view->viewport()->width() / 2.0,
                                                              _view->viewport()->height() / 1.0);
   QPointF viewport_center = _view->mapFromScene(target_scene_pos) - delta_viewport_pos;
   _view->centerOn(_view->mapToScene(viewport_center.toPoint()));
   emit zoomed();
}

void mGraphicsViewZoom::set_modifiers(Qt::KeyboardModifiers modifiers)
{
   _modifiers = modifiers;
}

void mGraphicsViewZoom::set_zoom_factor_base(double value)
{
   _zoom_factor_base = value;
}

bool mGraphicsViewZoom::eventFilter(QObject *object, QEvent *event)
{
   if (event->type() == QEvent::MouseMove)
   {
      // qDebug() << "QEvent::MouseMove";

      QMouseEvent* mouse_event = static_cast<QMouseEvent*>(event);
      QPointF delta = target_viewport_pos - mouse_event->pos();
      if (qAbs(delta.x()) > 5 || qAbs(delta.y()) > 5)
      {
         target_viewport_pos = mouse_event->pos();
         target_scene_pos = _view->mapToScene(mouse_event->pos());
      }
   }
   else if (event->type() == QEvent::Wheel)
   {
      // qDebug() << "QEvent::Wheel";
      QWheelEvent* wheel_event = static_cast<QWheelEvent*>(event);
      if (QApplication::keyboardModifiers() == _modifiers)
      {
//         if (wheel_event->orientation() == Qt::Vertical)
         {
            double angle = wheel_event->angleDelta().y();
            double factor = qPow(_zoom_factor_base, angle);
            gentle_zoom(factor);
            return true;
         }
      }
   }
   Q_UNUSED(object)
   return false;
}




#ifndef MGRAPHICSSCENE_H
#define MGRAPHICSSCENE_H

#include <QGraphicsScene>
#include <QGraphicsSceneMouseEvent>
#include <QGraphicsItem>


#include <QPoint>
#include <QMouseEvent>

class mGraphicsScene : public QGraphicsScene
{
   Q_OBJECT
   public:
   explicit mGraphicsScene(QObject *parent = 0) {}

   protected:

/*


       void mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent)
       {
         qDebug() << "void mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent)";

//         QGraphicsScene::mousePressEvent(mouseEvent);
//         mouseEvent->setAccepted(false);

         if (mouseEvent->button() == Qt::LeftButton)
         {

            qDebug() << "(mouseEvent->button() == Qt::LeftButton)";

            QGraphicsItem *item = itemAt(mouseEvent->scenePos(), QTransform());

            qDebug() << "item at:" << item;

            QString dta = item->data(0).toString();

            qDebug() << "data" << dta;




         }
       }
*/



};

#endif // MGRAPHICSSCENE_H






#ifndef MSESSIONSGRAPHICSITEM_H
#define MSESSIONSGRAPHICSITEM_H

#include <QGraphicsItem>
#include <QPainter>
#include <QGraphicsSceneMouseEvent>


class mSessionsGraphicsItem : public QGraphicsItem
{
   public:
      mSessionsGraphicsItem(int p_index, QRectF p_rect, QString p_txt, QColor p_col)
      {
         index = p_index;
         rect = p_rect;
         txt = p_txt;
         col = p_col;
         this->setFlag(QGraphicsItem::ItemIsSelectable, true);
      }

      QRectF boundingRect() const override  {  return rect; }

      void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override
      {
         // frame
         QPen framePen(col);
         framePen.setWidthF(1.8);
         if (this->isSelected()) framePen.setWidthF(3.8);
         painter->setPen(framePen);
         painter->drawRect(rect);

         // text
         framePen.setColor(Qt::black);
         painter->setPen(framePen);
         painter->drawText(rect.adjusted(2, 0, 0, 0), txt);
      }


      // void mousePressEvent(QGraphicsSceneMouseEvent *mouseEvent) override
      // {
      //    if (mouseEvent->button() == Qt::LeftButton)
      //    {
      //       qDebug() << "left mouse button pressed on:" << index << txt;
      //    }
      // }



      int index;
      QRectF rect;
      QString txt;
      QColor col;

};
#endif // MSESSIONSGRAPHICSITEM_H











































































































































































   




















































 









 













































































































































































































































































