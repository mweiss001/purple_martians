



void test_window_size_and_pos(void)
{
   int adj = 0;
   // test if window origin (UL) is off screen
   if ((disp_x_wind > disp_w_full) || (disp_x_wind < 0))
   {
      disp_x_curr = disp_x_wind = 32;
      adj = 1;
   }

   if ((disp_y_wind > disp_h_full) || (disp_y_wind < 0))
   {
      disp_y_curr = disp_y_wind = 32;
      adj = 1;
   }

   // test if window (LR) is off screen
   if ((disp_x_wind+disp_w_wind) > disp_w_full)
   {
      disp_x_curr = disp_x_wind = 32;
      adj = 1;

      if ((disp_x_wind+disp_w_wind) > disp_w_full) // still off screen?
      {
          disp_w_curr = disp_w_wind = disp_w_full - disp_x_wind - 32;;
      }
   }

   if (disp_y_wind + disp_h_wind > disp_h_full)
   {
      disp_y_curr = disp_y_wind = 32;
      adj = 1;

      if (disp_y_wind + disp_h_wind > disp_h_full) // still off screen?
      {
          disp_h_curr = disp_h_wind = disp_h_full - disp_y_wind - 32;
      }
   }
   if (adj) save_config();
}


void fill_door_tile(void)
{
   if (1) // load from disk
   {
      dtilemap = al_load_bitmap("bitmaps/door_tiles.bmp");
      if (!dtilemap) m_err((char*)"Can't load tiles from bitmaps/door_tiles.bmp");
      else
      {
         //printf("load good\n");
         al_convert_mask_to_alpha(dtilemap, al_map_rgb(0, 0, 0)) ;
         al_set_target_bitmap(M_dtilemap);
         al_draw_bitmap(dtilemap, 0, 0, 0);

         for (int a=0; a<16; a++)
            for (int b=0; b<8; b++)
               door_tile[0][a][b] = al_create_sub_bitmap(dtilemap, b*20, a*20, 20, 20);

         for (int a=0; a<16; a++)
            for (int b=0; b<8; b++)
               door_tile[1][a][b] = al_create_sub_bitmap(dtilemap, b*20, 320+a*20, 20, 20);
      }
   }

   if (0) // create from shapes
   {
      // new set
      for (int a=0; a<16; a++)
         for (int b=0; b<8; b++)
         {
            al_set_target_bitmap(door_tile[0][a][b]);
            al_draw_bitmap(tile[972+b], 0, 0, 0);
         }

      // old set
      for (int a=0; a<16; a++)
         for (int b=0; b<7; b++)
         {
            al_set_target_bitmap(door_tile[1][a][b]);
            al_draw_bitmap(tile[448+b], 0, 0, 0);
         }

      // i use color 12 and 3
      // 12 dark blue for the corners and center that do not move
      // 3 light blue for the lines that move
      // lets just change 3 for now


      // change index to lowest value (color -2)
      int cs = -2;
      for (int b=0; b<8; b++) //cycle 8 shapes
      {
         al_set_target_bitmap(door_tile[0][0][b]);
         al_lock_bitmap(door_tile[0][0][b],al_get_bitmap_format(door_tile[0][0][b]),ALLEGRO_LOCK_READWRITE);

         for (int x=0; x<20; x++)
            for (int y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(door_tile[0][0][b], x, y);

               float D = 0.1;
               if (  (abs(p.r - palette_color[3].r) < D) &&
                     (abs(p.g - palette_color[3].g) < D) &&
                     (abs(p.b - palette_color[3].b) < D) ) al_put_pixel(x, y, palette_color[(3+cs)]);

            }
            //   if (getpixel(door_tile[0][0][b], x, y) == palette_color[3])  putpixel(door_tile[0][0][b], x, y, palette_color[1]);

         al_unlock_bitmap(door_tile[0][0][b]);
      }

      //set rest of table
      for (int a=1; a<16; a++)
         for (int b=0; b<8; b++)
         {
            al_lock_bitmap(door_tile[0][0][b],al_get_bitmap_format(door_tile[0][0][b]),ALLEGRO_LOCK_READONLY);
            al_lock_bitmap(door_tile[0][a][b],al_get_bitmap_format(door_tile[0][a][b]),ALLEGRO_LOCK_READWRITE);
            al_set_target_bitmap(door_tile[0][a][b]);

            for (int x=0; x<20; x++)
               for (int y=0; y<20; y++)
               {
                  ALLEGRO_COLOR p = al_get_pixel(door_tile[0][0][b], x, y);

                  float D = 0.1;
                  if (  (abs(p.r - palette_color[1].r) < D) &&
                        (abs(p.g - palette_color[1].g) < D) &&
                        (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[a]);
               }
                  //if (getpixel(door_tile[0][0][b], x, y) == palette_color[1])  putpixel(door_tile[0][a][b], x, y, palette_color[a] );
            al_unlock_bitmap(door_tile[0][0][b]);
            al_unlock_bitmap(door_tile[0][a][b]);
            al_convert_mask_to_alpha(door_tile[0][a][b], al_map_rgb(0, 0, 0)) ;

         }



      // old door uses colors 12, 76, 124
      // change index to lowest value (color -11
      cs = -11;
      for (int b=0; b<7; b++) // cycle 7 shapes
      {
         al_set_target_bitmap(door_tile[1][0][b]);
         al_lock_bitmap(door_tile[1][0][b],al_get_bitmap_format(door_tile[1][0][b]),ALLEGRO_LOCK_READWRITE);

         for (int x=0; x<20; x++)
            for (int y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(door_tile[1][0][b], x, y);

               float D = 0.1;
               if (  (abs(p.r - palette_color[12].r) < D) &&
                     (abs(p.g - palette_color[12].g) < D) &&
                     (abs(p.b - palette_color[12].b) < D) ) al_put_pixel(x, y, palette_color[12+cs]);

               if (  (abs(p.r - palette_color[76].r) < D) &&
                     (abs(p.g - palette_color[76].g) < D) &&
                     (abs(p.b - palette_color[76].b) < D) ) al_put_pixel(x, y, palette_color[76+cs]);

               if (  (abs(p.r - palette_color[124].r) < D) &&
                     (abs(p.g - palette_color[124].g) < D) &&
                     (abs(p.b - palette_color[124].b) < D) ) al_put_pixel(x, y, palette_color[124+cs]);
            }
         al_unlock_bitmap(door_tile[1][0][b]);
      }

      // set rest of table
      for (int a=1; a<16; a++)
         for (int b=0; b<7; b++) // cycle 7 shapes
         {
            al_lock_bitmap(door_tile[1][0][b],al_get_bitmap_format(door_tile[1][0][b]),ALLEGRO_LOCK_READONLY);
            al_lock_bitmap(door_tile[1][a][b],al_get_bitmap_format(door_tile[1][a][b]),ALLEGRO_LOCK_READWRITE);
            al_set_target_bitmap(door_tile[1][a][b]);

            for (int x=0; x<20; x++)
               for (int y=0; y<20; y++)

               {
                  ALLEGRO_COLOR p = al_get_pixel(door_tile[1][0][b], x, y);

                  float D = 0.1;
                  if (  (abs(p.r - palette_color[1].r) < D) &&
                        (abs(p.g - palette_color[1].g) < D) &&
                        (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[a]);

                  if (  (abs(p.r - palette_color[65].r) < D) &&
                        (abs(p.g - palette_color[65].g) < D) &&
                        (abs(p.b - palette_color[65].b) < D) ) al_put_pixel(x, y, palette_color[64+a]);

                  if (  (abs(p.r - palette_color[113].r) < D) &&
                        (abs(p.g - palette_color[113].g) < D) &&
                        (abs(p.b - palette_color[113].b) < D) ) al_put_pixel(x, y, palette_color[112+a]);
               }

            al_unlock_bitmap(door_tile[1][0][b]);
            al_unlock_bitmap(door_tile[1][a][b]);
            al_convert_mask_to_alpha(door_tile[1][a][b], al_map_rgb(0, 0, 0)) ;

         }
   }

//   int text_col = 15;
//   draw_small_text(tile[1014], 7, 8, text_col, 2); // "IN"
//   draw_small_text(tile[1015], 5, 8, text_col, 1); // "OUT"
//   al_set_target_bitmap(tilemap);
//   al_draw_bitmap(tile[1014], 22*20, 31*20, 0);
//   al_draw_bitmap(tile[1015], 23*20, 31*20, 0);
//   al_set_target_bitmap(M_tilemap);
//   al_draw_bitmap(tilemap, 0, 0, 0);
//   al_save_bitmap("bitmaps/tiles2.bmp", M_tilemap);



   /*
   al_set_target_backbuffer(display);
   al_draw_bitmap(tile[1014], 100, 100, 0);
   al_draw_bitmap(tile[1015], 100, 120, 0);

al_draw_scaled_bitmap(tile[1014],0, 0, 20, 20, 200, 100, 100, 100, 0);
al_draw_scaled_bitmap(tile[1015],0, 0, 20, 20, 200, 200, 100, 100, 0);

       al_flip_display();
       al_rest(2);

*/


   if (0)
   {
       // save to disk
       al_set_target_bitmap(dtilemap);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[0][a][b], b*20, a*20, 0);

       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[1][a][b], b*20, 320+a*20, 0);


       al_set_target_backbuffer(display);
       al_draw_bitmap(dtilemap, 0, 0, 0);
       al_flip_display();

       al_save_bitmap("bitmaps/door_tiles.bmp", dtilemap);
       tsw();
   }



   // show all
   if (0)
   {
       al_set_target_backbuffer(display);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[0][a][b], b*20, a*20, 0);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[1][a][b], b*20, 340+a*20, 0);
       al_flip_display();
       tsw();
   }

}


void fill_player_tile(void)
{
   //printf("fill player bitmap\n");
   int a, b, x, y;

   if (1) // load from disk
   {
      ptilemap = al_load_bitmap("bitmaps/player_tiles.bmp");
      if (!ptilemap) m_err((char*)"Can't load tiles from bitmaps/player_tiles.bmp");
      else
      {
         //printf("load good\n");
         al_convert_mask_to_alpha(ptilemap, al_map_rgb(0, 0, 0)) ;

         al_set_target_bitmap(M_ptilemap);
         al_draw_bitmap(ptilemap, 0, 0, 0);

         // create sub bitmaps
         for (a=0; a<16; a++)
            for (b=0; b<19; b++)
               player_tile[a][b] = al_create_sub_bitmap(ptilemap, b*20, a*20, 20, 20);
      }
   }



   if (0) // create from shapes
   {
      //int bf = al_get_bitmap_format(player_tile[0][0]);
      //printf("bitmap format %d\n", bf);


   // fill the player_tile
   // fill the top row first and make it color = 1 then generate all next row aoutomatically
      for (a=0; a<16; a++) // set all to default shapes
      {
         al_set_target_bitmap(player_tile[a][0]); al_draw_bitmap(tile[400], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][1]); al_draw_bitmap(tile[401], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][2]); al_draw_bitmap(tile[402], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][3]); al_draw_bitmap(tile[403], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][4]); al_draw_bitmap(tile[404], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][5]); al_draw_bitmap(tile[405], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][6]); al_draw_bitmap(tile[368], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][7]); al_draw_bitmap(tile[369], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][8]); al_draw_bitmap(tile[370], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][9]); al_draw_bitmap(tile[371], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][10]); al_draw_bitmap(tile[372], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][11]); al_draw_bitmap(tile[373], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][12]); al_draw_bitmap(tile[384], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][13]); al_draw_bitmap(tile[385], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][14]); al_draw_bitmap(tile[386], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][15]); al_draw_bitmap(tile[387], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][16]); al_draw_bitmap(tile[388], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][17]); al_draw_bitmap(tile[389], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][18]); al_draw_bitmap(tile[755], 0, 0, 0);
      }

      // change index to lowest value (color -7)
      int cs = - 7; // first pass will set index(0) to lowest value possible (1)
      for (b=0; b<19; b++) //cycle 19 bitmaps for one color
      {
         al_set_target_bitmap(player_tile[0][b]);
         al_lock_bitmap(player_tile[0][b],al_get_bitmap_format(player_tile[0][b]),ALLEGRO_LOCK_READWRITE);

         for (x=0; x<20; x++)
            for (y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(player_tile[0][b], x, y);

   /*          if (p == 8  ) putpixel(player_tile[0][b], x, y, (p+cs) );
               if (p == 56 ) putpixel(player_tile[0][b], x, y, (p+cs) );
               if (p == 136) putpixel(player_tile[0][b], x, y, (p+cs) );
   */
             // new method also works with true color
   //        if (!memcmp(&p, &palette_color[8], sizeof(ALLEGRO_COLOR))) al_put_pixel(x, y, palette_color[(8+cs)] );

   //            printf ("x%d y%d - pr%f pg%f pb%f cr%f cg%f cb%f\n", x, y, p.r, p.g, p.b,
   //                     palette_color[8].r, palette_color[8].g, palette_color[8].b );

                 float D = 0.1;
                 if (  (abs(p.r - palette_color[8].r) < D) &&
                       (abs(p.g - palette_color[8].g) < D) &&
                       (abs(p.b - palette_color[8].b) < D) ) al_put_pixel(x, y, palette_color[(8+cs)]);

                 if (  (abs(p.r - palette_color[56].r) < D) &&
                       (abs(p.g - palette_color[56].g) < D) &&
                       (abs(p.b - palette_color[56].b) < D) ) al_put_pixel(x, y, palette_color[(56+cs)]);

                 if (  (abs(p.r - palette_color[136].r) < D) &&
                       (abs(p.g - palette_color[136].g) < D) &&
                       (abs(p.b - palette_color[136].b) < D) ) al_put_pixel(x, y, palette_color[(136+cs)]);
            }
        al_unlock_bitmap(player_tile[0][b]);
        al_convert_mask_to_alpha(player_tile[0][b], al_map_rgb(0, 0, 0)) ;
      }

      //set rest of table
      for (a=1; a<16; a++) //cycle 15 player colors (no zero)
      {
         //printf("%d\n",a);
         for (b=0; b<19; b++) //cycle 18 bitmaps for one player
         {
            al_set_target_bitmap(player_tile[a][b]);
            al_lock_bitmap(player_tile[a][b],al_get_bitmap_format(player_tile[a][b]),ALLEGRO_LOCK_READWRITE);
            al_lock_bitmap(player_tile[0][b],al_get_bitmap_format(player_tile[0][b]),ALLEGRO_LOCK_READONLY);

            for (x=0; x<20; x++)
               for (y=0; y<20; y++)
               {
                  ALLEGRO_COLOR p = al_get_pixel(player_tile[0][b], x, y); // always read from 0 index if reference


                 float D = 0.1;
                 if (  (abs(p.r - palette_color[1].r) < D) &&
                       (abs(p.g - palette_color[1].g) < D) &&
                       (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[(1+a)]);

                 if (  (abs(p.r - palette_color[49].r) < D) &&
                       (abs(p.g - palette_color[49].g) < D) &&
                       (abs(p.b - palette_color[49].b) < D) ) al_put_pixel(x, y, palette_color[(49+a)]);

                 if (  (abs(p.r - palette_color[129].r) < D) &&
                       (abs(p.g - palette_color[129].g) < D) &&
                       (abs(p.b - palette_color[129].b) < D) ) al_put_pixel(x, y, palette_color[(129+a)]);
               }
            al_unlock_bitmap(player_tile[0][b]);
            al_unlock_bitmap(player_tile[a][b]);
            al_convert_mask_to_alpha(player_tile[a][b], al_map_rgb(0, 0, 0)) ;
         }
      }
   }

   if (0)
   {
       // show all new player shapes
       al_set_target_backbuffer(display);
       for (a=0; a<16; a++)
          for (b=0; b<19; b++)
             al_draw_bitmap(player_tile[a][b], b*20, a*20, 0);
       al_flip_display();
       tsw();
   }


   if (0)
   {
       // save to disk
       al_set_target_bitmap(ptilemap);
       for (a=0; a<16; a++)
          for (b=0; b<19; b++)
             al_draw_bitmap(player_tile[a][b], b*20, a*20, 0);

       al_set_target_backbuffer(display);
       al_draw_bitmap(ptilemap, 0, 0, 0);

       al_flip_display();

       al_save_bitmap("bitmaps/player_tiles.bmp", ptilemap);

       tsw();
   }


}


void show_resize_msg(int type)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(al_map_rgb(0,0,0));
   float sc = (float)SCREEN_W / 120; // fill horizontally
   sc /=2;
   if (type == 1) rtextout_centre(NULL, (char*)"Resizing Screen ", SCREEN_W/2, SCREEN_H/2, 10, sc, 0, 1);
   if (type == 2) rtextout_centre(NULL, (char*)"Reloading Shapes", SCREEN_W/2, SCREEN_H/2, 10, sc, 0, 1);
   if (type == 3) rtextout_centre(NULL, (char*)"Options", SCREEN_W/2, SCREEN_H/2, 9, sc, 0, 1);
   al_flip_display();
}





int small_letter(ALLEGRO_BITMAP *bmp, int x, int col, char *t)
{


   int text_width = 0;
   switch(t[0])
   {
/*      case 68: // D
             rect(bmp, x+0, 0, x+2, 3, palette_color[col]);
         putpixel(bmp, x+2, 0,    palette_color[0]);
         putpixel(bmp, x+2, 3,    palette_color[0]);
         text_width = 4;
      break;
*/

      case 73: // I
            al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         text_width = 2;
      break;
      case 78: // N
         al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         al_draw_line(x+3.5f, 0.5f, x+3.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+1, 1, palette_color[col]);
         al_put_pixel(x+2, 2, palette_color[col]);
         text_width = 5;
      break;




      case 79: // O
         al_draw_rectangle(x+0.5f, 0+0.5f, x+2+0.5f, 3+0.5f, palette_color[col], 1);
         text_width = 4;
      break;

/*
      case 80: // P
             rect(bmp, x+0, 0, x+2, 2, palette_color[col]);
         putpixel(bmp, x+0, 3,    palette_color[col]);
         text_width = 4;
      break;
  */

      case 84: // T
            //vline(bmp, x+1, 0, 3, palette_color[col]);
         al_draw_line(x+1.5f, 0.5f, x+1.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+0, 0, palette_color[col]);
         al_put_pixel(x+2, 0, palette_color[col]);
         text_width = 4;
      break;


      case 85: // U
         al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         al_draw_line(x+2.5f, 0.5f, x+2.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+1, 3, palette_color[col]);
         text_width = 4;
      break;


/*

      case 87: // W
            vline(bmp, x+0, 0, 2, palette_color[col]);
            vline(bmp, x+4, 0, 2, palette_color[col]);
         putpixel(bmp, x+1, 3,    palette_color[col]);
         putpixel(bmp, x+3, 3,    palette_color[col]);
         putpixel(bmp, x+2, 2,    palette_color[col]);
         text_width = 6;
      break;
*/

   }


   return text_width;


}

void draw_small_text(ALLEGRO_BITMAP * bmp, int x, int y, int col, int textnum)
{

   int xpos = 0;
   ALLEGRO_BITMAP *temp = NULL;

   if (textnum == 1) // OUT
   {
      temp = al_create_bitmap(11,4);
      al_set_target_bitmap(temp);
      al_clear_to_color(al_map_rgb(0,0,0));
      xpos += small_letter(temp, xpos, col, (char*)"O");
      xpos += small_letter(temp, xpos, col, (char*)"U");
      xpos += small_letter(temp, xpos, col, (char*)"T");
      al_set_target_bitmap(bmp);
      al_draw_bitmap(temp, x, y, 0);
   }
   if (textnum == 2) // IN
   {
      temp = al_create_bitmap(6,4);
      al_set_target_bitmap(temp);
      al_clear_to_color(al_map_rgb(0,0,0));
      xpos += small_letter(temp, xpos, col, (char*)"I");
      xpos += small_letter(temp, xpos, col, (char*)"N");
      al_set_target_bitmap(bmp);
      al_draw_bitmap(temp, x, y, 0);
   }
/*
   if (textnum == 3) // UP
   {
      temp = al_create_bitmap(7,4);
      clear(temp);
      xpos += small_letter(temp, xpos, col, "U");
      xpos += small_letter(temp, xpos, col, "P");
      draw_sprite(bmp, temp, x, y);
   }
   if (textnum == 4) // DOWN
   {
      temp = al_create_bitmap(19,4);
      clear(temp);
      xpos += small_letter(temp, xpos, col, "D");
      xpos += small_letter(temp, xpos, col, "O");
      xpos += small_letter(temp, xpos, col, "W");
      xpos += small_letter(temp, xpos, col, "N");
      draw_sprite(bmp, temp, x, y);
   }

*/
   al_destroy_bitmap(temp);



}



















/*
int st_sr(int sx, int sy, int cd, int gfx_card)
{
   set_color_depth(cd);
   if (set_gfx_mode(gfx_card, sx, sy, 0, 0) == 0)
   {
      if (gfx_card == 1) sprintf(msg, "[%4d x %4d] %2d bit fullscreen..", sx, sy, cd);
      if (gfx_card == 2) sprintf(msg, "[%4d x %4d] %2d bit windowed....", sx, sy, cd);

      strcat(log_msg, msg);
      printf("%s", msg);
      return 1;
   }
   else  // failed
   {
      sprintf(msg, "Error setting: [%d x %d] gfx_card:%d color_depth:%d\n", sx, sy, gfx_card, cd);
      strcat(log_msg, msg);
      printf("%s", msg);
      return 0;
   }
}


void st_run(void)
{
   load_gm("test1.gm");
   players[0].control_method = 1;
   start_mode = 2; // load level and start, but skip game array erasing
   game_exit = 0;

   int start_timer = clock();
   pm_main();
   int finish_time = clock();
   int time = finish_time - start_timer;

   int cps = CLOCKS_PER_SEC;

   sprintf(msg, "[%3d] Frames per second -- [%dms] per frame\n",(passcount*cps) / time, time/passcount);
   printf("%s", msg);
   strcat(log_msg, msg);

}

void speed_test(void)
{
   sprintf(msg, "\n---------------------------------\n- Speed test for %s\n", local_hostname);
   printf("%s", msg);
   strcpy(log_msg, msg);

   get_desktop_resolution(&desktop_sx, &desktop_sy);
   desktop_colordepth = desktop_color_depth();

   sprintf(msg, "Desktop resolution: [%d x %d] %d bit\n", desktop_sx, desktop_sy, desktop_colordepth);
   printf("%s", msg);
   strcat(log_msg, msg);

   // get operating system type
   show_os_detected();
   strcat(log_msg, msg);
   strcat(log_msg, "\n");

   int cps = CLOCKS_PER_SEC;
   sprintf(msg, "CLOCKS_PER_SEC [%d]\n", cps);
   printf("%s", msg);
   strcat(log_msg, msg);

   // get allegro id
   sprintf(msg, "Allegro version:    [%s]\n\n", allegro_id);
   printf("%s", msg);
   strcat(log_msg, msg);

   speed_testing = 1;








//   if (st_sr(desktop_sx, desktop_sy, 32, 1)) st_run();
//   if (st_sr(desktop_sx, desktop_sy, 16, 1)) st_run();
//   if (st_sr(desktop_sx, desktop_sy, 8, 1)) st_run();
//
//   if (st_sr(1024, 768, 32, 2)) st_run();
//   if (st_sr(1024, 768, 16, 2)) st_run();
//   if (st_sr(1024, 768, 8, 2)) st_run();
//
//
//
//   if (st_sr(1024, 768, 32, 1)) st_run();
//   if (st_sr(1024, 768, 16, 1)) st_run();
//   if (st_sr(1024, 768, 8, 1)) st_run();



//   if (st_sr(800, 600, 32, 2)) st_run();



//   if (st_sr(800, 600, 16, 2)) st_run();
//   if (st_sr(800, 600, 8, 2)) st_run();
//
//   if (st_sr(800, 600, 32, 1)) st_run();
//   if (st_sr(800, 600, 16, 1)) st_run();
//   if (st_sr(800, 600, 8, 1)) st_run();


   FILE *filepntr;
   char filename[140];
   sprintf(filename, "logs/speedtest[%s].txt", local_hostname);
   filepntr = fopen(filename,"w");
   fprintf(filepntr, "%s", log_msg);
   fclose(filepntr);
}

*/









/*
   load_tiles();
   for (int z = 0; z < 32; z++)
   {
      al_set_target_bitmap(tile[z]);
      al_lock_bitmap(tile[z], al_get_bitmap_format(tile[z]), ALLEGRO_LOCK_READWRITE);
      for (int x = 0; x < 20; x++)
         for (int y = 0; y < 20; y++)
         {
            ALLEGRO_COLOR c = al_get_pixel(tile[z], x, y);
            float r, g, b;
            al_unmap_rgb_f(c, &r, &g, &b);

            if ( (r < 0.2) && (g < 0.2) && (b < 0.2) )
               al_put_pixel(x, y, al_map_rgb(0,0,0));

         }
      al_unlock_bitmap(tile[z]);
   }
    save_tiles();
*/




//   draw_large_2lines(gv, "Purple", "Martians", 8, 1);
//   al_flip_display();
//   tsw();

//   ALLEGRO_COLOR c[5];
//   c[0] = al_map_rgb(255, 0, 0);
//   c[1] = al_map_rgb(0, 255, 0);
//   c[2] = al_map_rgb(0, 0, 255);
//   c[3] = al_map_rgb(255, 255, 255);
//   c[4] = al_map_rgb(0, 0, 0);
//
//   int quit = 0;
//   while (!quit)
//   {
//      proc_controllers();
//      if (key[ALLEGRO_KEY_ESCAPE]) quit =1;
//
//      char m1[256];
//      char m2[256];
//      int bbx1, bby1, bbw1, bbh1;
//      int bbx2, bby2, bbw2, bbh2;
//
//      sprintf(m1, "Michael") ;
//      sprintf(m2, "Weiss") ;
//
//      sprintf(m1, "Purple") ;
//      sprintf(m2, "Martians") ;
//      al_get_text_dimensions(gv, m1, &bbx1, &bby1, &bbw1, &bbh1);
//      al_get_text_dimensions(gv, m2, &bbx2, &bby2, &bbw2, &bbh2);
//
//      // get max w and h
//      float bbw3 = bbw1; if (bbw2 > bbw1) bbw3 = bbw2;
//      float bbh3 = bbh1; if (bbh2 > bbh1) bbh3 = bbh2;
//
//      printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);
//      printf("bbx2:%d bby2:%d bbw2:%d bbh2:%d\n",bbx2, bby2, bbw2, bbh2);
//
//      ALLEGRO_BITMAP *t1 = al_create_bitmap(bbw3, bbh3);
//      al_set_target_bitmap(t1);
//      al_clear_to_color(al_map_rgb(0,0,0));
//      al_draw_text(gv, palette_color[8], 0-bbx1 + (bbw3-bbw1)/2, 0-bby1, 0, m1);
//      al_convert_mask_to_alpha(t1, al_map_rgb(0, 0, 0));
//
//      ALLEGRO_BITMAP *t2 = al_create_bitmap(bbw3, bbh3);
//      al_set_target_bitmap(t2);
//      al_clear_to_color(al_map_rgb(0,0,0));
//      al_draw_text(gv, palette_color[8], 0-bbx2 + (bbw3-bbw2)/2, 0-bby2, 0, m2);
//      al_convert_mask_to_alpha(t2, al_map_rgb(0, 0, 0));
//
//
//      int xs = SCREEN_W*7/8; // x size
//      int ys = SCREEN_H*3/8; // y size
//
//
//      int x1 = (SCREEN_W - xs)/2;
//      int x2 = xs;
//
//      int yu1 = SCREEN_H*1/4 - ys/2;
//      int yu2 = ys;
//
//      int yl1 = SCREEN_H*3/4 - ys/2;
//      int yl2 = ys;
//
//
//
//
//      al_set_target_backbuffer(display);
//
////      al_draw_line(0, SCREEN_H*1/4, SCREEN_W, SCREEN_H*1/4, c[2], 1);
////      al_draw_line(0, SCREEN_H*2/4, SCREEN_W, SCREEN_H*2/4, c[2], 1);
////      al_draw_line(0, SCREEN_H*3/4, SCREEN_W, SCREEN_H*3/4, c[2], 1);
//
//
//
//      al_draw_scaled_bitmap(t1, 0, 0, bbw3, bbh3, x1, yu1, x2, yu2, 0);
//      al_draw_scaled_bitmap(t2, 0, 0, bbw3, bbh3, x1, yl1, x2, yl2, 0);
//
//      al_flip_display();
//      al_clear_to_color(al_map_rgb(0,0,0));
//
//      al_destroy_bitmap(t1);
//      al_destroy_bitmap(t2);
//   }
//


//   char fn[1000];
//   sprintf(fn, "help/");
//   int ret = mw_file_select("Test get filename", fn, ".txt", 0);
//   printf("ret:%d  filename:[%s]", ret, fn);


   //options_menu();

   /*

   int c, r, g, b;

   c = palette_color[3];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("3 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[9];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("9 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[10];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("10 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[13];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("13 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[15];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("15 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);


   c = palette_color[173];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("173 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[141];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("141 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   //            tsw();

   int c, r, g, b;

   c = getpixel(tile[400], 6, 3);
   r = getr(c);
   g = getg(c);
   b = getb(c);

   int c32 = makecol32(r, g, b);

   int ccc = 56;
   //            int ccc = palette_color[c];

   int cc8 = palette_color[8];

   //            int cc8 = 23;


   printf("c:%4d   r:%3d g:%3d b:%3d   32:%d  ccc:%d  cc8:%d\n", c, r, g, b, c32, ccc, cc8);


   c = getpixel(tile[400], 7, 3);
   c = getpixel(tile[400], 8, 3);

   */




   /*

   int size = sizeof(players);
   int lim = size / 1;

   memmove(c_players, players, size); // copy to temp player struct for comparison

   //            players[0].active++;

   //            players[0].paused+=256;

   //            players[0].shape = 256;



   for (i=0; i<lim; i++)
      if (memcmp(&players+i, &c_players+i, 1) != 0)
         printf("difference found in player struct at %d bytes\n", i);
   */

   /*
   int size = sizeof(players);
   char b1[size];
   char b2[size];

   memcpy(b1, players, size);

   players[0].active++;

   players[0].active = 256;

   players[1].active = 256;

   memcpy(b2, players, size);


   for (int i=0; i<size; i++)
      if (b1[i] != b2[i])
         printf("difference found in player struct at %d bytes\n", i);


   tsw();

   */

   /*

     load_level(39, 1);
     void chunk(void);
     chunk();

   */


   /*

   ALLEGRO_PATH * exe  = al_get_standard_path(ALLEGRO_EXENAME_PATH);

   // remove the filename part
   al_set_path_filename(exe, NULL);

   // add savegame as last dir in path
   al_append_path_component(exe, "savegame");

   // convert to string
   const char * cpathx  = al_path_cstr(exe, ALLEGRO_NATIVE_PATH_SEP);
   const char * ret;

   ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(cpathx, "Run Game Filename", "*.gm", 0);

   if (al_show_native_file_dialog(display, afc))
   {

   if (al_get_native_file_dialog_count(afc) == 1)
   {
   ret =  al_get_native_file_dialog_path(afc, 0);
   printf("file selected:%s\n", ret);

   }

   }
   else printf("file select cancelled\n" );

   al_destroy_native_file_dialog(afc);



   */

   //     load_gm(NULL);

   //            spline_test();
   //            spline_adjust();
   //            mdw_an();


   // get some random numbers

   // suppose i want from 2-5 with .01

   // scale for int = *100;
   // 200-500

   // range = 300
   // 300

   /*

   for (int y = 0; y<100; y++)
   {
      int r = 200 + rand() % 300;
      al_fixed s = al_itofix(r) / 100;
      printf("[%3.2f]",al_fixtof(s));
   }
   tsw();



   //void solid_test(void);

   //   solid_test();

   //void run_dialog_netgame_conf(void);
   //run_dialog_netgame_conf();


   //void speed_test(void);
   //speed_test();




   // test nested if else


    int a = 5;
    int b = 18;
    int c = 10;

    if (a == 5)
       if (b == 8)
          if (c == 10) printf("test1\n");
             else printf("test2\n");

   tsw();




   int d =4;
   while (d > 0)
   {
      rect(screen, SCREEN_W/2-164, SCREEN_H/2-42, SCREEN_W/2+160, SCREEN_H/2-24, 11);
      sprintf(msg, "Chasing to passcount");
      rtextout_centre(screen, msg, SCREEN_W/2, SCREEN_H/2-32, 10, 2, 0);
      rectfill(screen, SCREEN_W/2-180, SCREEN_H/2-20, SCREEN_W/2+180, SCREEN_H/2+20, 0);
      rect(screen, SCREEN_W/2-180, SCREEN_H/2-20, SCREEN_W/2+180, SCREEN_H/2+16, 10);
      sprintf(msg, "[%d]", d);
      rtextout_centre(screen, msg, SCREEN_W/2, SCREEN_H/2, 10, 4, 0);
       d--;
    }

   tsw();*/






// ---------------------------------------------------------------------------------------------------------------
// ***************************************************************************************************************
//----------------------------------------------------------------------------------------------------------------

void nc_client(void) // for specialized packet testing only
{
   if (ClientInit("192.168.1.170"))  printf("Client init failed\n");
//   if (ClientCheckResponse())        printf("No server response\n");
   while (ClientCheckResponse()); // wait until its zero        printf("No server response\n");
   int quit = 0;
   while (!quit)
   {
      proc_controllers();
      if (key[ALLEGRO_KEY_ESCAPE]) quit = 1;
      if ((packetsize = ClientReceive(packetbuffer)) &&  (PacketRead("peep")))
      {
         int pc = PacketGet2ByteInt();
//            printf("client rx peep:[%d]\n", pc);
         pc++;
         if (pc < 1000)
         {
//               printf("client tx poop:[%d]\n",pc);
            Packet("poop");
            PacketPut2ByteInt(pc);
            ClientSend(packetbuffer, packetsize);
         }
         else
         {
            int finish_time = clock(); // stop the timer
            int time = finish_time - log_timer;
            printf("time:[%d]ms\n", time);
         }
      }
      if (key[ALLEGRO_KEY_1])
      {
         while (key[ALLEGRO_KEY_1]) proc_controllers();
         log_timer = clock(); // start the timer...
         printf("Sending poop packet to server\n");
         Packet("poop");
         PacketPut1ByteInt(0);
         ClientSend(packetbuffer, packetsize);
      }
   }
}







// ---------------------------------------------------------------------------------------------------------------
// ***************************************************************************************************************
//----------------------------------------------------------------------------------------------------------------

void nc_server(void) // for specialized packet testing only
{
   static int who;
   if (ServerInit())  printf ("Error initializing server\n");

   int quit = 0;
   while (!quit)
   {
      if (key[ALLEGRO_KEY_ESCAPE]) quit = 1;
      ServerListen(); // listen for connections
      packetsize = ServerReceive(packetbuffer, &who); // get packets
      if (packetsize > 0)
      {
         if(PacketRead("poop"))
         {
            int pc = PacketGet2ByteInt();
//            printf("server rx poop:[%d]\n", pc);
            pc++;
//            printf("server tx peep:[%d]\n", pc);
            Packet("peep");
            PacketPut2ByteInt(pc);
            ServerSendTo(packetbuffer, packetsize, who, 0);
         }
      }
      if (key[ALLEGRO_KEY_0] && ClientNum)
      {
         while (key[ALLEGRO_KEY_0]);
         Packet("stoc");
         PacketPut1ByteInt(0);
         ServerSendTo(packetbuffer, packetsize, 0, 0);
      }
   }
}






//   offset += size;
//   size = sizeof(players);
//   memmove(b+offset, players, size);
//   //printf("players \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(Ei);
//   memmove(b+offset, Ei, size);
//   //printf("int Ei[100][32] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(Efi);
//   memmove(b+offset, Efi, size);
//   //printf("al_fixed Efi[100][16] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(item);
//   memmove(b+offset, item, size);
//   //printf("int item[500][16] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(itemf);
//   memmove(b+offset, itemf, size);
//   //printf("al_fixed item[500][4] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(lifts);
//   memmove(b+offset, lifts, size);
//   //printf("lifts \t\t\tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(l);
//   memmove(b+offset, l, size);
//   //printf("l[100][100] \t\tsize %d \toffset %d \n", size, offset);

   //offset += size;
   //printf("----------------total chunk size %d \n", offset);








//   if (screen_messages_on)
//      switch (ev)
//      {
//         case   1: add_screen_msg("bang!", x, y, 100, 4, z1, z2, z3, z4); break;
//         case   2: add_screen_msg("key", x, y, 100, 5, z1, z2, z3, z4); break;
//         case   3: sprintf(msg, "%d enemies left to kill!", z1);
//                   add_screen_msg(msg, x, y, 100, 0, z1, z2, z3, z4); break;
//         case   3: add_screen_msg("------O------", x, y, 100, 0); break;
//         case   5: add_screen_msg("--O--", x, y, 100, 0); break;
//         case   5: add_screen_msg("Door", x, y, 100, 1, z1, z2, z3, z4); break;
//         case   6: sprintf(msg, "H+%d", z1);
//                   add_screen_msg(msg, x, y, 100, 2, z1, z2, z3, z4); break;
//         case   7: sprintf(msg, "H-%d", z1);
//                   add_screen_msg(msg, x, y, 100, 3, z1, z2, z3, z4); break;
//         case  8:  add_screen_msg("Bomb Damage!", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  10: add_screen_msg("Mine", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  13: sprintf(msg, "%s died! (%d left)", enemy_name[Ei[z1][0]],  num_enemy-1);
//                   add_screen_msg(msg, x, y, 100, 0, z1, z2, z3, z4); break;
//         case  21: add_screen_msg("You Died!", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  30: add_screen_msg("switch", x, y, 100, 7, z1, z2, z3, z4); break;
//         case  31: add_screen_msg("boing!", x, y, 100, 6, z1, z2, z3, z4); break;
//         case  32: add_screen_msg("In", x, y, 100, 1, z1, z2, z3, z4); break;
//         case  33: add_screen_msg("Out", x, y, 100, 1, z1, z2, z3, z4); break;
//         case  34: add_screen_msg("Ouch", x, y, 100, 34, z1, z2, z3, z4); break;
//         case  35: add_screen_msg("Ouch", x, y, 100, 35, z1, z2, z3, z4); break;
//      }






void draw_screen_msg(void)
{
    for (int a=0; a<100; a++)
       if (screen_msgs[a].active)
       {
          int ssn = screen_msgs[a].ssn;

          int x = screen_msgs[a].x;
          int y = screen_msgs[a].y;
          int c = screen_msgs[a].color;
          int rot = screen_msgs[a].rot;
          float s = screen_msgs[a].size;

          rtextout_centre(level_buffer, screen_msgs[a].text, x + 10, y + 10, c, s, rot, 1 );

           // for all mode that aren't multimode
           if ((ssn == 0) || (ssn == 0) || (ssn == 4) || (ssn == 5) || (ssn == 6) || (ssn == 7) || (ssn == 34)|| (ssn == 35))
           {
             // decrement delay till 0 then set inactive
             --screen_msgs[a].delay;
             if (screen_msgs[a].delay == 0) screen_msgs[a].active = 0;
           }

           if (screen_msgs[a].ssn == 2) // health +
           {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // next out
                 {
                    screen_msgs[a].delay = 5;
                    screen_msgs[a].color = 11;
                    screen_msgs[a].yinc = -5;
                    screen_msgs[a].size = .5;
                    screen_msgs[a].size_inc = .11;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].color = 11;

                    screen_msgs[a].yinc = 0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {
                 if (screen_msgs[a].delay == 0) // next in
                 {
                    screen_msgs[a].delay = 6;
                    screen_msgs[a].color = 11;
                    screen_msgs[a].yinc = 4;
                    screen_msgs[a].size_inc = -.14;
                    screen_msgs[a].current_step = 8;
                 }
              }
              if (screen_msgs[a].current_step == 8)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }

          }

          if (screen_msgs[a].ssn == 3) // health -
          {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // next out
                 {
                    screen_msgs[a].delay = 5;
                    screen_msgs[a].color = 10;
                    screen_msgs[a].yinc = -8;
                    screen_msgs[a].size = .5;
                    screen_msgs[a].size_inc = .11;
                    screen_msgs[a].rot_inc = 0;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].yinc = 0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {


                 if (screen_msgs[a].delay == 0) // next in
                 {
                    screen_msgs[a].delay = 6;
                    screen_msgs[a].yinc = 4;
                    screen_msgs[a].size_inc = -.14;
                    screen_msgs[a].current_step = 8;
                 }
              }
              if (screen_msgs[a].current_step == 8)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }

          }

           if (screen_msgs[a].ssn == 1) // door (fade in and out)
           {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // fade in
                 {
                    screen_msgs[a].delay = 6;

                    screen_msgs[a].color = 12 + (6 * 32);

                    screen_msgs[a].color_inc = - 32;

//                  screen_msgs[a].color_inc_holdoff = screen_msgs[a].delay / 12;
                    screen_msgs[a].color_inc_holdoff = 1;

                    screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;

                    screen_msgs[a].size = 1.0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].color = 12;
                    screen_msgs[a].color_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {
                 if (screen_msgs[a].delay == 0) // fade out
                 {
                    screen_msgs[a].delay = 15;
                    screen_msgs[a].color = 12;
                    screen_msgs[a].color_inc = 16;
                    screen_msgs[a].color_inc_holdoff = 1;

                    screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;


                    screen_msgs[a].current_step = 4;
                 }
              }

              if (screen_msgs[a].current_step == 4)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }
          }

          // increment the size
          screen_msgs[a].size = screen_msgs[a].size + screen_msgs[a].size_inc;

          // increment the rot
          screen_msgs[a].rot = screen_msgs[a].rot + screen_msgs[a].rot_inc;

          // increment x and y
          screen_msgs[a].x = screen_msgs[a].x + (int) screen_msgs[a].xinc;
          screen_msgs[a].y = screen_msgs[a].y + (int) screen_msgs[a].yinc;

          // increment color
          if (screen_msgs[a].color_inc) // do nothing if no color_inc
          {
             if (--screen_msgs[a].current_holdoff <= 0)
             {
                screen_msgs[a].color += screen_msgs[a].color_inc;

                if (screen_msgs[a].color < 0) screen_msgs[a].color += 256;
                if (screen_msgs[a].color < 255) screen_msgs[a].color -= 256;

                screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;
             }
          }

       }
}



void add_screen_msg(char *txt, int x, int y, int delay, int ssn, int z1, int z2, int z3, int z4 )
{
   // check to see if identical to any active entry
   int already_exists = 0;
    for (int a=0; a<100; a++)
       if (screen_msgs[a].active)
          if (screen_msgs[a].original_x == x)
             if (screen_msgs[a].original_y == y)
                if (strcmp(screen_msgs[a].text, txt) == 0)
                   if (ssn != 4 ) already_exists = 1;

   if (!already_exists)
   {
      for (int a=0; a<100; a++)
         if (!screen_msgs[a].active) // find first empty
         {
             // default settings
             screen_msgs[a].delay = 40;
             screen_msgs[a].active = 1;
             screen_msgs[a].color = 15;
             screen_msgs[a].color_inc = 0;
             screen_msgs[a].color_inc_holdoff = 0;
             screen_msgs[a].current_holdoff = 0;
             screen_msgs[a].delay = delay;
             screen_msgs[a].ssn = ssn;
             screen_msgs[a].original_x = x;
             screen_msgs[a].original_y = y;
             screen_msgs[a].x = x;
             screen_msgs[a].y = y;
             screen_msgs[a].xinc = 0;
             screen_msgs[a].yinc = 0;
             sprintf(screen_msgs[a].text, "%s", txt);
             screen_msgs[a].size = 1.0;
             screen_msgs[a].size_inc = 0.0;
             screen_msgs[a].rot = 0;
             screen_msgs[a].rot_inc = 0;

             // specific overrides

             if (ssn == 1) // Door
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 0;
                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;
                screen_msgs[a].size = 1.0;
                screen_msgs[a].size_inc = -.000;
                screen_msgs[a].x = x;
                screen_msgs[a].y = y-12; // raise above door

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;
             }


             if (ssn == 2) // Health +
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 11; // green

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;

             }

             if (ssn == 3) // Health -
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 10; // red

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;

             }


             if (ssn == 4) // player shoots, bang!
             {
                screen_msgs[a].delay = 8;

                int p = z1; // player num
                int b = z2; // bullet num

                screen_msgs[a].x = pbullet[b][2];
                screen_msgs[a].y = pbullet[b][3];

                screen_msgs[a].xinc = pbullet[b][4]/3;
                screen_msgs[a].yinc = pbullet[b][5]/3;

                // do one inc to see if lines up better
                screen_msgs[a].x += pbullet[b][4];
                screen_msgs[a].y += pbullet[b][5];

                screen_msgs[a].color = players[p].color;

                screen_msgs[a].size = .2;
                screen_msgs[a].size_inc = .1;
             }


             if (ssn == 5) // key
             {
                screen_msgs[a].delay = 20;
                // get key tile
                if  (z2 == 1039) screen_msgs[a].color = 10; //red
                if  (z2 == 1040) screen_msgs[a].color = 11; //green
                if  (z2 == 1041) screen_msgs[a].color = 13; //lt blue
                if  (z2 == 1042) screen_msgs[a].color = 8;  //purple
             }

             if (ssn == 6) // boing
             {
                screen_msgs[a].delay = 20;
                screen_msgs[a].color = 14; //yellow

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .4;
                screen_msgs[a].size_inc = .015;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y;
                screen_msgs[a].yinc = -4;

             }


             if (ssn == 7) // switch
             {
                screen_msgs[a].delay = 20;
                screen_msgs[a].color = 15; // white

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .8;
                screen_msgs[a].size_inc = .005;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y;
                screen_msgs[a].yinc = -1;

             }

             if ((ssn == 34) || (ssn == 35))  // squished or stuck
             {
                screen_msgs[a].delay = 8;
                screen_msgs[a].color = 10; // red

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .8;
                screen_msgs[a].size_inc = .035;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y-10;
                screen_msgs[a].yinc = -3;

             }

              a =100; // quit loop
         }
   }
}

struct screen_msg
{
   int active;
   int delay;
   int original_x;
   int original_y;

   int x;
   int y;
   char text[80];

   int color;
   int color_inc;

   int color_inc_holdoff;
   int current_holdoff;

   int ssn; //type of msg; used to select processing and initalization

   int current_step; // used by certain ssn's for multi-mode

   float size;
   float size_inc;

   float xinc;
   float yinc;

   int rot;  /// (0-255)
   int rot_inc;

};
extern struct screen_msg screen_msgs[100];

struct screen_msg screen_msgs[100];








//
//   Ei[e][4]++; // my ans counter
//   if (Ei[e][4] > 22) Ei[e][4] = 0;
//
//   int a=0, so, yo;
//
//   if (Ei[e][4] == a++) { so = 0; yo = -3; } // wings at bottom
//   if (Ei[e][4] == a++) { so = 0; yo = -4; }
//   if (Ei[e][4] == a++) { so = 0; yo = -3; }
//   if (Ei[e][4] == a++) { so = 0; yo = -3; }
//   if (Ei[e][4] == a++) { so = 0; yo = -2; }
//   if (Ei[e][4] == a++) { so = 0; yo = -1; }
//   if (Ei[e][4] == a++) { so = 0; yo = +0; }
//   if (Ei[e][4] == a++) { so = 0; yo = +1; }
//
//   if (Ei[e][4] == a++) { so = 1; yo = +2; } // wings 1/2 bottom coming up
//   if (Ei[e][4] == a++) { so = 1; yo = +2; }
//   if (Ei[e][4] == a++) { so = 1; yo = +2; }
//
//   if (Ei[e][4] == a++) { so = 2; yo = +2; } // wings 1/2 up coming up
//   if (Ei[e][4] == a++) { so = 2; yo = +2; }
//   if (Ei[e][4] == a++) { so = 2; yo = +2; }
//
//   if (Ei[e][4] == a++) { so = 3; yo = +2; } // wings at top
//   if (Ei[e][4] == a++) { so = 3; yo = +2; }
//   if (Ei[e][4] == a++) { so = 3; yo = +2; }
//
//   if (Ei[e][4] == a++) { so = 4; yo = +2; } // wings 1/2 up coming down
//   if (Ei[e][4] == a++) { so = 4; yo = +1; }
//   if (Ei[e][4] == a++) { so = 4; yo = -0; }
//
//   if (Ei[e][4] == a++) { so = 5; yo = -1; } // wings 1/2 down coming down
//   if (Ei[e][4] == a++) { so = 5; yo = -2; }
//   if (Ei[e][4] == a++) { so = 5; yo = -3; }
//







/* show whats going on...
   printf("step:%d  so:%d  yo:%3.2f\n",Ei[e][4], so, al_fixtof(fyo));
   if (yo < 0) Ei[e][20] += yo;
   if (yo > 0) Ei[e][21] += yo;

   if (Ei[e][4] == 0)
   {
      printf("up_count%d down_count:%d\n",Ei[e][20], Ei[e][21]);
      Ei[e][20] = 0;
      Ei[e][21] = 0;
   }
*/


/*

   // follow in y axis
   if (EYint < al_fixtoi(players[p].PY) - height_above_player)
   {
      Efi[e][1] += Efi[e][3];
      EYint = al_fixtoi(Efi[e][1]);
      if (is_down_solid(EXint, EYint, 1)) Efi[e][1] -= Efi[e][3]; // take back move
   }
   if (EYint > al_fixtoi(players[p].PY) - height_above_player)
   {
      Efi[e][1] -= Efi[e][3];
      EYint = al_fixtoi(Efi[e][1]);
      if (is_up_solid(EXint, EYint, 1)) Efi[e][1] += Efi[e][3]; // take back move
   }

*/



/*


 // bounce in x axis
   if ((Efi[e][2]) > al_itofix(0))  // move right
   {
      int prox = Ei[e][17];
      Ei[e][2] = 1; // h_flip to face right
      // try to shoot right
      if (--Ei[e][16] < 0)
         if (EYint+Ei[e][18] > al_fixtoi(players[p].PY) && (EYint-Ei[e][19]) < al_fixtoi(players[p].PY))
            if (EXint < al_fixtoi(players[p].PX) && (EXint + prox) > al_fixtoi(players[p].PX) )
            {
               fire_enemy_bulleta(e, 62, p);
               Ei[e][16] = Ei[e][15]; // set new prox wait
            }
     Efi[e][0] += Efi[e][2];
     EXint = al_fixtoi(Efi[e][0]);
     EYint = al_fixtoi(Efi[e][1]);
     if (is_right_solid(EXint, EYint, 1))
     {
        Efi[e][0] -= Efi[e][2]; // take back last move
        Efi[e][2] =- Efi[e][2]; // bounce
        EXint = al_fixtoi(Efi[e][0]);
     }
   }
   else if ((Efi[e][2]) < al_itofix(0))  // move left
   {
      int prox = Ei[e][17];
      Ei[e][2] = 0; // no h_flip
      // try to shoot left
      if (--Ei[e][16] < 0)
         if (EYint+Ei[e][18] > al_fixtoi(players[p].PY) && (EYint-Ei[e][19]) < al_fixtoi(players[p].PY))
            if (EXint-prox < al_fixtoi(players[p].PX) &&  (EXint) > al_fixtoi(players[p].PX) )
            {
               fire_enemy_bulleta(e, 62, p);
               Ei[e][16] = Ei[e][15]; // set new prox wait
            }
      Efi[e][0] += Efi[e][2];
      EXint = al_fixtoi(Efi[e][0]);
      EYint = al_fixtoi(Efi[e][1]);
      if (is_left_solid(EXint, EYint, 1))
      {
         Efi[e][0] -= Efi[e][2]; // take back last move
         Efi[e][2] =- Efi[e][2]; // bounce
         EXint = al_fixtoi(Efi[e][0]);
      }
   }

*/


/*
   int b = Ei[e][3]; // ans
   int c = zz[4][b];  // num of shapes in seq
   int x = (EXint/5) % c;
   Ei[e][1] = zz[x+5][b];
*/


/*
   Ei[e][4]++; // my ans counter
   if (Ei[e][4] > 2)
   {
      Ei[e][4] = 0;
      Ei[e][5]++; // current sequence
      if (Ei[e][5] > 5) E[e][5] = 0;
   }

   int so = Ei[e][5]; // current sequence


   Ei[e][1] = zz[5+so][Ei[e][3]];


   int yo;
   if (so == 0) yo = -15;
   if (so == 1) yo = 2;
   if (so == 2) yo = 10;
   if (so == 3) yo = 15;
   if (so == 4) yo = -2;
   if (so == 5) yo = -10;

   al_fixed fyo = al_itofix(yo)/8;

//   printf("so:%d  yo:%3.2f\n",so, al_fixtof(fyo));

*/

// 6 shapes
// 8 coast
// 3 for all others 3x5 = 15
// 23 total


// coast      = 8 * +1 = +8
// wings up   = 6 * +3 = +18

// wing top   = 3 * +1

// wings down = 6 * -5 = -30





/*
   int so, yo;
   if ((Ei[e][4] >= 0) && (Ei[e][4] < 8)) // coast (0-7)
   {
      so = 0;  // wings at bottom
      yo = +1;
   }

   if ((Ei[e][4] > 7) && (Ei[e][4] < 11)) // wings coming up (8-10)
   {
      so = 1;   // wings 1/2 bottom coming up
      yo = +2;
   }

   if ((Ei[e][4] > 10) && (Ei[e][4] < 14)) // wings coming up (11-13)
   {
      so = 2; // wings 1/2 top coming up
      yo = +2;
   }

   if ((Ei[e][4] > 13) && (Ei[e][4] < 17)) // wings at top (14-16)
   {
      so = 3; // wings at top
      yo = +2;
   }

   if ((Ei[e][4] > 16) && (Ei[e][4] < 20)) // wings coming down (17-19)
   {
      so = 4; // wings 1/2 up coming down
      yo = -4;
   }

   if ((Ei[e][4] > 16) && (Ei[e][4] < 20)) // wings coming down (20-22)
   {
      so = 5; // wings 1/2 down coming down
      yo = -4;
   }
*/











         #ifdef SHOW_CLONERLINES
         if (Ei[e][0] == 9) // cloner
         {
            // show counter
            int cx = al_fixtoi(Efi[e][0]) + 10;     // middle of cloner
            int cy = al_fixtoi(Efi[e][1]) - 8;      // above cloner
            //int cy = al_fixtoi(Efi[e][1])+24;     // below cloner
            //int cy = al_fixtoi(Efi[e][1])+8;      // middle of cloner
            al_draw_textf(font, palette_color[10], cx, cy, ALLEGRO_ALIGN_CENTER, "%d" ,Ei[e][7] );

//            int x1 = al_fixtoi(Efi[e][6]) - 2;    // source x
//            int y1 = al_fixtoi(Efi[e][7]) - 2;    // source y
//            int x2 = x1 + x_size;
//            int y2 = y1 + y_size;
//
//            int x3 = al_fixtoi(Efi[e][8]) - 2;    // dest x
//            int y3 = al_fixtoi(Efi[e][9]) - 2;    // dest y
//            int x4 = x3 + x_size;
//            int y4 = y3 + y_size;

            int cw = Ei[e][19]*20;     // width
            int ch = Ei[e][20]*20;     // height

            int x1 = Ei[e][15]*20;    // source
            int y1 = Ei[e][16]*20;
            int x2 = x1 + cw;
            int y2 = y1 + ch;

            int x3 = Ei[e][17]*20;    // destination
            int y3 = Ei[e][18]*20;
            int x4 = x3 + cw;
            int y4 = y3 + ch;


            al_fixed ratio = al_fixdiv(al_itofix(Ei[e][7]), al_itofix(Ei[e][6])) * 10;

            if ((ratio < al_ftofix(2) ) && (ratio > al_ftofix(.5) ))
            {
               int color = 10; // red

            // ratio is a float between 0 and 10
            // to get here ratio must be > 2 and < 4
            // converts to il and li which are the sizes of the inner and outer boxes
            // when stated ratio is 3.999 and ends when ratio is 1.999
            // when started li needs to be ~40-100 and 0 when ends...
            // when started il needs to be ~40-100 and 20 when ends...
               al_fixed tr = ratio - al_itofix(2); // starts at 1 and goes to -1
               int il = al_fixtoi(tr * 32);
               int li = al_fixtoi(tr * 16) - 20;
               al_draw_rectangle(x1-il, y1-il, x2+il, y2+il, palette_color[color], 1);
               al_draw_rectangle(x1-li, y1-li, x2+li, y2+li, palette_color[color], 1);
               al_draw_line(x1-il, y1-il, x1-li, y1-li, palette_color[color], 1);
               al_draw_line(x2+il, y2+il, x2+li, y2+li, palette_color[color], 1);
               al_draw_line(x1-il, y2+il, x1-li, y2+li, palette_color[color], 1);
               al_draw_line(x2+il, y1-il, x2+li, y1-li, palette_color[color], 1);
            }
            if (ratio < al_itofix(1) )
            {
               int color = 11; // green
               al_fixed tr = al_itofix(1) - ratio; // starts at 0 and goes to 1
               int il = al_fixtoi(tr * 8);
               int li = al_fixtoi(tr * 4) - 20;
               al_draw_rectangle(x3-li, y3-li, x4+li, y4+li, palette_color[color], 1);
               al_draw_rectangle(x3-il, y3-il, x4+il, y4+il, palette_color[color], 1);
               al_draw_line(x3-il, y3-il, x3-li, y3-li, palette_color[color], 1);
               al_draw_line(x4+il, y4+il, x4+li, y4+li, palette_color[color], 1);
               al_draw_line(x3-il, y4+il, x3-li, y4+li, palette_color[color], 1);
               al_draw_line(x4+il, y3-il, x4+li, y3-li, palette_color[color], 1);
            }
         }
         #endif





/*

int oldload_level(int level_to_load, int display) //old
{
   int level_header[20];

   display = 0; // force display on or off
   int error_logging = 0;
   valid_level_loaded = 0;
   resume_allowed = 0;
   int level_load_error = 0;
   int loop, ch, c, x, y;
   char buff[2000];

   //printf("load level\n");

   zero_level_data();

   while (level_to_load > 1000) level_to_load -= 1000;

   make_filename(level_to_load);   // update filename
   level_num = level_to_load;
   level_load_error = 0;

   if (!al_filename_exists(level_filename))
   {
      sprintf(msg, "Can't Find Level %s ", level_filename);
      //m_err(msg);
      level_load_error = 1;
   }

   if (!level_load_error) // file exists
   {
      if (error_logging) printf("file exists\n");
      if ((filepntr=fopen(level_filename,"r")) == 0)
      {
         sprintf(msg, "Error opening %s ", level_filename);
         m_err(msg);
         level_load_error = 1;
      }
   }

  if (!level_load_error)  // file open !
  {
     if (error_logging) printf("reading level header\n");
     for (c=0; c<20; c++) // level header
     {
        loop = 0;
        ch = fgetc(filepntr);
        while((ch != '\n') && (ch != EOF))
        {
           buff[loop] = ch;
           loop++;
           ch = fgetc(filepntr);
        }
        buff[loop] = 0;
        level_header[c] = atoi(buff);
        if (ch == EOF)
        {
           sprintf(msg, "Error reading level header in %s ", level_filename);
           m_err(msg);
           level_load_error = 1;
        }
     }

     num_lifts = level_header[5];
     if (error_logging) printf("%d items\n", level_header[3]);
     if (error_logging) printf("%d enemies\n", level_header[4]);
     if (error_logging) printf("%d lifts \n", level_header[5]);
     if (error_logging) printf("reading blocks\n");


     for (c=0; c<100; c++)  // l[100][100]
        for (y=0; y<100; y++)
        {
           loop = 0;
           ch = fgetc(filepntr);
           while((ch != '\n') && (ch != EOF))
           {
               buff[loop] = ch;
               loop++;
               ch = fgetc(filepntr);
           }
           buff[loop] = 0;
           l[c][y] = atoi(buff);
           if (ch == EOF)
           {
              sprintf(msg, "Error reading blocks in %s ", level_filename);
              m_err(msg);
              level_load_error = 1;
           }
        }

     if (!level_load_error)
     {
        if (error_logging) printf("reading items\n");
        for (c = 0; c < level_header[3]; c++)  // read item
        {
           for (x = 0; x < 16; x++)
           {
              loop = 0;
              ch = fgetc(filepntr);
              while((ch != '\n') && (ch != EOF))
              {
                  buff[loop] = ch;
                  loop++;
                  ch = fgetc(filepntr);
              }
              buff[loop] = 0;
              item[c][x] = atoi(buff);

              if (ch == EOF)
              {
                 sprintf(msg, "Error reading items in %s ", level_filename);
                 m_err(msg);
                 level_load_error = 1;
              }
           }
           if (item[c][0] == 10) // get pmsg
           {
              loop = 0;
              ch = fgetc(filepntr);
              while((ch != '\n') && (ch != EOF))
              {
                 if (ch != 13) // ignore and don't add if 13 ( needed for linux)
                 {
                    buff[loop] = ch;
                    loop++;
                 }
                 else printf("lev:%d pmsg:%d found char 13 and ate it\n", level_to_load, c);


                 ch = fgetc(filepntr);
              }
              buff[loop] = 0;
              pmsg[c] = (char*) malloc (strlen(buff)+1);
              strcpy(pmsg[c], buff);
           }
        }
        for (int x=0; x<500; x++)
           if (item[x][0]) // only if active set x y
           {
              itemf[x][0] = al_itofix(item[x][4]);
              itemf[x][1] = al_itofix(item[x][5]);
           }
     }
     if (!level_load_error)
     {
        if (error_logging) printf("reading enemy fixeds \n");
        for (c=0; c<level_header[4]; c++) // read enemy fixeds
           for (x=0; x<16; x++)
           {
              loop = 0;
              ch = fgetc(filepntr);
              while((ch != '\n') && (ch != EOF))
              {
                 buff[loop] = ch;
                 loop++;
                 ch = fgetc(filepntr);
              }
              buff[loop] = 0;
              Efi[c][x] = atoi(buff);  // enemy al_fixed

              if (ch == EOF)
              {
                 sprintf(msg, "Error reading Ef in %s ", level_filename);
                 m_err(msg);
                 level_load_error = 1;
              }
           }
        if (error_logging) printf("reading enemy ints\n");
        for (c=0; c < level_header[4]; c++)  // enemy ints
           for (x=0; x<32; x++)
           {
              loop = 0;
              ch = fgetc(filepntr);
              while((ch != '\n') && (ch != EOF))
              {
                  buff[loop] = ch;
                  loop++;
                  ch = fgetc(filepntr);
              }
              buff[loop] = 0;
              Ei[c][x] = atoi(buff);
              if (ch == EOF)
              {
                 sprintf(msg, "Error reading Ei in %s ", level_filename);
                 m_err(msg);
                 level_load_error = 1;
              }
           }
     }
     if (!level_load_error)
     {
        if (error_logging) printf("reading %d lifts\n", num_lifts);
        for (c=0; c<num_lifts; c++) // read lifts
        {
           if (error_logging) printf("--------------\nreading lifts %d\n", c);
           int tr[5];
           char tmsg[80];
           for (x=0; x<5; x++) // lift data
           {

              loop = 0;
              ch = fgetc(filepntr);
              while((ch != '\n') && (ch != EOF))
              {
                 if (ch != 13)
                 {
                    buff[loop] = ch;
                    loop++;
                 }
                 ch = fgetc(filepntr);
              }
              buff[loop] = 0;
              if (x == 0) strcpy(tmsg, buff); // get lift name
              else tr[x] = atoi(buff); // get int
           }
           if (error_logging) printf("name(%s) w:%d h:%d c:%d num_step[%d]\n", tmsg, tr[1],tr[2],tr[3],tr[4]);
           construct_lift(c, tmsg, tr[1],tr[2],tr[3],tr[4]);

           for (x=0; x<lifts[c] . num_steps; x++) // step data
           {
              if (error_logging) printf("   reading lift step %d  ", x);

              int tr[4];
              for (y=0; y<4; y++) // read 4
              {
                 loop = 0;
                 ch = fgetc(filepntr);
                 while((ch != '\n') && (ch != EOF))
                 {
                    buff[loop] = ch;
                    loop++;
                    ch = fgetc(filepntr);
                 }
                 buff[loop] = 0;
                 tr[y] = atoi(buff);
              }
              if (error_logging) printf("d1:%4d d2:%4d d3:%4d d4:%4d\n", tr[0],tr[1],tr[2],tr[3]);
              construct_lift_step(c, x, tr[0], tr[1], tr[2], tr[3]);

           }
           set_lift(c, 0);
        }
     }
     fclose(filepntr);
   } // end of file open


   if (level_load_error)
   {
      if (error_logging) printf("level loading error occurred\n");
      num_lifts = 0;
      return 0;
   }
   else
   {
      if (error_logging) printf("level loading complete with no errors\n");
      valid_level_loaded = 1;

      level_check();

      init_level_background(); // draw blocks and lift lines on level_background
      if (error_logging) printf("blocks drawn\n");
      reset_animation_sequence_frame_nums(0);
      if (error_logging) printf("ans seq reset\n");
      for (int p=0; p<NUM_PLAYERS; p++) set_player_start_pos(p);
      if (error_logging) printf("got start\n");
      return 1;
   }
}


*/




/*
int old_save_level(int level_to_save)
{
   level_check();

   int level_header[20];
   int c, x, y;

   while (level_to_save > 1000) level_to_save -= 1000;
   make_filename(level_to_save);   // update filename

   filepntr = fopen(level_filename,"w");

   level_num = level_to_save;

   level_header[3] = sort_item(); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy; // num_of_enemies
   level_header[5] = num_lifts;

   for (x=0; x<20; x++)
      fprintf(filepntr,"%d\n",level_header[x]);

   for (c=0; c<100; c++)  // level
      for (x=0; x<100; x++)
         fprintf(filepntr,"%d\n",l[c][x]);

   for (c=0; c < level_header[3]; c++) // item
   {
      for (x=0; x<16; x++)
         fprintf(filepntr,"%d\n",item[c][x]);

      if (item[c][0] == 10) // pmsg
      {
         y = 0;
         while (pmsg[c][y] != 0)
         {
            if (pmsg[c][y] == 13) fprintf(filepntr,"%c", 126);
            else fprintf(filepntr,"%c", pmsg[c][y]);
            y++ ;
         }
         fprintf(filepntr,"\n");
      }
   }
   for (c=0; c < level_header[4]; c++)  // enemy float
      for (x=0; x<16; x++)
         fprintf(filepntr,"%d\n", Efi[c][x]); // enemy fixed

   for (c=0; c < level_header[4]; c++) // enemy int
      for (x=0; x<32; x++)
         fprintf(filepntr,"%d\n",Ei[c][x]);

   for (c=0; c < level_header[5]; c++)   // lifts
   {
      fprintf(filepntr,"%s\n",lifts[c].lift_name);
      fprintf(filepntr,"%d\n",lifts[c].width);
      fprintf(filepntr,"%d\n",lifts[c].height);
      fprintf(filepntr,"%d\n",lifts[c].color);
      fprintf(filepntr,"%d\n",lifts[c].num_steps);

      for (x=0; x<lifts[c].num_steps; x++)  // steps
      {
         fprintf(filepntr,"%d\n",lift_steps[c][x].x);
         fprintf(filepntr,"%d\n",lift_steps[c][x].y);
         fprintf(filepntr,"%d\n",lift_steps[c][x].val);
         fprintf(filepntr,"%d\n",lift_steps[c][x].type);
      }
   }
   fclose(filepntr);
   return 0;
}


*/




/*
      fread(level_header, sizeof(level_header), 1, fp);
      fread(l,            sizeof(l),            1, fp);
      fread(item,         sizeof(item),         1, fp);
      fread(Efi,          sizeof(Efi),          1, fp);
      fread(Ei,           sizeof(Ei),           1, fp);
      fread(lifts,        sizeof(lifts),        1, fp);
      fread(lift_steps,   sizeof(lift_steps),   1, fp);
      fread(pmsgtext,     sizeof(pmsgtext),     1, fp);

  */


      // decompress client_state_buffer to dif

//      uncompress((Bytef*)client_state_dif, (uLongf*)&destLen, (Bytef*)client_state_buffer, sizeof(client_state_buffer));


/*
      char pml[PML_SIZE];
      fread(pml,   sizeof(pml),      1, fp);
      pml_to_var(pml);

*/





/*

      printf("level_header:%6d\n",  sizeof(level_header) );
      printf("l           :%6d\n",  sizeof(l)            );
      printf("item        :%6d\n",  sizeof(item)         );
      printf("Efi         :%6d\n",  sizeof(Efi)          );
      printf("Ei          :%6d\n",  sizeof(Ei)           );
      printf("lifts       :%6d\n",  sizeof(lifts)        );
      printf("lift_steps  :%6d\n",  sizeof(lift_steps)   );
      printf("pmsgtext    :%6d\n",  sizeof(pmsgtext)     );


      int sz = 0;
      sz+= sizeof(level_header);
      sz+= sizeof(l)            ;
      sz+= sizeof(item)         ;
      sz+= sizeof(Efi)          ;
      sz+= sizeof(Ei)           ;
      sz+= sizeof(lifts)        ;
      sz+= sizeof(lift_steps)   ;
      sz+= sizeof(pmsgtext)     ;
      printf("       total:%6d\n",  sz );

*/








   // put variables in pml
   char pml[PML_SIZE];
   var_to_pml(pml);

   // compress pml to cmp
   char cmp[PML_SIZE];
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)pml, sizeof(pml), 5);
   int cmp_size = destLen;

   // write cmp to file
   FILE *fp = fopen(level_filename,"wb");
   fwrite(cmp, cmp_size, 1, fp);
   fclose(fp);

























