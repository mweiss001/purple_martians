20221228

New running log of changes to the project...

The old one was over 40,000 lines and 1M char...


do a line count:

24525 code only
8006 empty
4979 comment
4557 code and comment
----------------
42067 total


where do I use proc_controllers?
108 matches

not in client anymore since I removed the blocking...

client does not exit when connection fails...fixed first part...

now what about waiting for initial state from server?

break it on the server and test how client responds

did it not used to say waiting for server in a few places?


I have made a nice way to quit while waiting for initial state....

I should make all the ways to exit from client go to a state that cleans up....i think I did...

client still will not rejoin until program is restarted....fixed...it was a strange issue with packetpos needing to be reset to 0


later make sure that server cleans up at exit like client, and try to restart....

also make sure that TCP still works...



Now I think I am finally ready to try some fast ping packets


OK I have the packet passing...what should I do about it?


when server receives pong do some timing

ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   1.2 ms
ping time:   1.6 ms
ping time:   1.6 ms
ping time:   0.5 ms
ping time:   1.3 ms
ping time:   0.9 ms
ping time:   1.1 ms
ping time:   1.5 ms
ping time:   1.0 ms
ping time:   1.5 ms
ping time:   0.7 ms
ping time:   0.6 ms
ping time:   0.6 ms

this is round trip UDP on LAN

switching to WAN


96.45.15.187


I am going to send the ts with the packet and add client ts also...
how do I add a double to a packet?

I could turn it into a char array like I do with state...


im guessing sizeof double is 8...

double test = 1.23;

memcpy(packetbuffer+pos, test,  8);





   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;




before I do this in a packet, lets just try to do it in a regular way....



void PacketPutDouble(double *d)
{
   memcpy(packetbuffer+packetsize, d, 8);
	packetsize+=8;
}

double PacketGetDouble(void)
{
   double d[2];
   memcpy(d, packetbuffer+packetpos, 8);
	packetpos+=8;
	return *d;
}



use this:
char packetbuffer[1024];

make a function to stick something in it and another fucntion to get it out....




char packetbuffer1[1024] = {0};
int packetsize1 = 0;
int packetpos1 = 0;

void PacketPutDouble1(double d)
{
   double dd[2] = {0};
   dd[0] = d;
   memcpy(packetbuffer1 + packetsize1, dd, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d[2] = {0};
   memcpy(d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d[0];
}

void temp_test(void)
{
   double t0 = 0.000123;
   printf("1 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);

   PacketPutDouble1(t0);
   printf("2 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);


   double t1 = PacketGetDouble1();
   printf("3 - ps:%d pp:%d sot:%d t1:%f\n", packetsize1, packetpos1, sizeof(t1), t1);


this shit works!!!


the problem I was having is that memcopy does not like to be passed plain variables, it wants pointers...
so I made an array of the variable tyope I wanted and only use the first element...

found this:


double in=2.132;
char arr[12] = {};
memcpy(arr,&in,sizeof(in));

char arr2[12] = ...;
double out;
memcpy(&out,arr2,sizeof(out));

void PacketPutDouble1(double d)
{
   memcpy(packetbuffer1 + packetsize1, &d, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d = 0;
   memcpy(&d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d;
}

that works too!

now put it in the packets....done...

now try


C:\pm>pm -s

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Local address of channel:24785
Network initialized - channel mode (UDP)
Server successfully initialized

Server received initial 1234 packet from '192.168.1.116:24785'
Server opened channel for `192.168.1.116:24785' and sent reply
ping time:   0.7 ms
ping time:   0.7 ms
ping time:   0.4 ms
ping time:   1.3 ms
ping time:   0.3 ms
ping time:   1.1 ms
ping time:   1.0 ms
ping time:   1.2 ms
ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.4 ms
ping time:   1.1 ms
ping time:   0.4 ms
ping time:   0.6 ms
ping time:   0.5 ms
Shutting down the server


now try internet:


Server received initial 1234 packet from '70.75.228.155:24785'
Server opened channel for `70.75.228.155:24785' and sent reply
ping time:  30.6 ms
ping time:  25.7 ms
ping time:  21.7 ms
ping time:  26.7 ms
ping time:  20.7 ms
ping time:  31.1 ms
ping time:  26.3 ms
ping time:  27.9 ms
ping time:  24.1 ms
ping time:  27.8 ms
ping time:  25.9 ms
ping time:  35.6 ms
Shutting down the server


OK I've got something

now try TCP

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Network initialized - connection mode (TCP)
Server successfully initialized

Connection received from 70.75.228.155:63272
ping time:  34.1 ms
ping time:  48.3 ms
ping time:  24.3 ms
ping time:  23.1 ms
ping time:  23.7 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  27.4 ms
ping time:  32.7 ms
ping time:  25.6 ms
ping time:  30.6 ms
ping time:  28.6 ms
ping time:  31.7 ms
ping time:  70.3 ms
Shutting down the server

not that much of a difference...

Now how can I use this to monitor and adjust timing..

Now that I can receive stdf any time, I want to know exactly when I am receiving them

this will be a client thing

when client gets an stdf, compare to the latest frame start

it was about 23ms after frame start...

soon, timestamp fills up.. I should make one global timestamp called frame_start....
I am amazed at how stable the timer is, fps adjust very rarely has anything to do...

now lets try fine tuning the sync...


I can get it down to 5-10 instead of 22 with fine tuning, but it does not make the game more playable on WAN
LAN still looks great

the problem on WAN is the corrections make it look really jumpy
try s1 = 2...



it work so good on LAN, whay not WAN, why so many jumpy corrections??

I need to look into the timing closer

maybe running just in time to get difs as needed is not the right approach

If I got difs for a frame that I has already rendered...
I could replay with the local controls for that frame that has already occured...
this would mean I am running ahead of the the server
controls that I am currently pressing are not as old on the server


If I got difs for a frame that I had not rendered yet...
i would hold off till then and apply it
this would mean I am running behind the server
controls that I am currently pressing are even older on the server



I will need to experiment with both

20221219 11:22PM ..push



I have some thoughts...

I want to know where in the client frame are the stdf's rx'd and where are they used..


Make a graphical overlay for the game

sliding bar to show sync and stuff

controls also...

timestamp bar in screen overlay
what am I going to show?

where will i get the data for that

should I clear old timestamps every second?

yes and I should do somthing in there about doing some nice averages and min max

later...


now I want to have some timestamps that do not get saved, only for current frame...
I have one for frame start, but I also want one for stdf rx..


what if I log these so that I can make a nice graph and look at them?? maybe later...


what I am seeing is the stdf being rx'd right after draw in the frame


where in the frame does the client use stdf?

at the very start...

- input
- move
- draw


what if I measured the timestamp difference between stdf packet being received and it being used by the client?

that is the critical timing anyway, is it not?



I want to solve the client sync thing....
I want to be able to control where in the frame the stdf is rx'd
this is proving to be harder than I thought

OK I think I figured out how to do that...

now I want to see if I can have some on screen controls

they will need to be non-blocking


run them from debug screen overlay

first can I show mouse??..yes

button works but blocks on mouse press....
made a non_blocking version


         static int pres = 0;
         if (mdw_buttont_nb(100, yyy, 200, 16,  0,0,0,0,  0,14,15, 0,  1,0,1,0, "Inc"))
         {
            if (pres == 0) printf ("incd\n");
            pres = 1;
         }
         else pres = 0;




now make a global to control the client dsync....done


when adjusting chase too close the connection is lost
the client gets difs too late to apply and does nothing??

cleaning up the logging...

removed call to apply dif from rx packet thing
now only called in the loop every frame and when waiting for intial state

logs look much better now...

I can tell the we are receiving stdf's too late..

they fail all the time when trying to apply, but that is normal.

what I should do is check when they are completed if there is any chance they can be used....
if they are late then I should raise some errors...already done....but addedd to log...
in client debug screen if server_sync = -1

and stays there for 100 frames server will drop

should client reply at all, all it has is stak...and we are not acknowledging anything...

we ack when we get a bad base, should we ack when we get a bad dest??...yes...done...



now sync can go to -1 and client stays connected

I should have something on the client to tell when te last applied dif is.

I am thinking about the nice little graph that shows dsync...
It could also display last diff applied....

added to player1

   int client_last_diff_applied;


That works...


now I want to make a nice little display for the client.

graph
buttons
chase_offset
last_dif
draw in red if last_dif > 2


for the actual value, lets take if from

added to player1 struct...
   double dsync;


OMG that looks great...

now what??

that is about the only thing that I can adjust and monitor on the client....
it sends cdats when they occurs
it processes stdfs just before it has to apply them...

this client dsync is such an important number that I wonder if I should sync it back to the server.
I could add it to stak....

on the client


move all of these to player1

double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;
double client_chase_offset = 0.010;

done...

I actually did not need these and removed them...
double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;

still wondering about adding dsync to stak so server has it....

It was as easy as adding one line on the client:

   PacketPutDouble(players1[p].dsync);

   and one on the client...

   players1[p].dsync            = PacketGetDouble();

add display it in server debug...done...


now what?

do some things for server...like?

buttons to change s1 and s2

graph to show when clients cdats arrive in relation to current frame...

s1 and s2 are already part of the player1 struct...

done...


I want to know at what position in the frame do cdats arrive at, and how many frames behind....

crudely looking in the logs -2 and rarely -3 for a WAN game....
-1 for a LAN game....this might be unavoidable...

if the round trip ping is around 30 then one way would be 15...

I want to know exactly what it is and see if adjusting the client offset can do anything about it....


so how to measure?


server fast packet loop already marks cdats with timestamp when they arrive

so go to where they are processed...




I still don't like how the frame_number are processed!!
I really want to fix it but I am scared of what it will break....

---------------
- current:
---------------
timer_triggers_event

input
move
draw
inc frame

wait until triggered again...


---------------
what I want:
---------------
timer_triggers_event

inc frame
input
move
draw

wait until triggered again...

this would mean that for the entirety of the frame, the frame number is the same

not
change frame number
wait
do stuff

the wait would be at the end....


goddamn it!! I don't care what I have to fix...I'm going to make it so that is how it is...

one consequence is there will never be a frame 0...I know somethings depend on that....

or rather any setup that is done before the first loop will be done on frame 1....


it is done, these are the first lines

mwPS.frame_num++;
update_animation();

lets see what still works...

single player seems good....level done too

server and client seem to work...omg...

This will have more of an effect on some timer things I am doing....




[1457]cdat 1455  gc:-2 0.016008
[1458]cdat 1456  gc:-2 0.012546
[1459]cdat 1457  gc:-2 0.008733
[1460]cdat 1458  gc:-2 0.013411
[1461]cdat 1459  gc:-2 0.015866
[1462]cdat 1460  gc:-2 0.016015
[1463]cdat 1461  gc:-2 0.008641
[1464]cdat 1462  gc:-2 0.012660
[1465]cdat 1463  gc:-2 0.016165
[1466]cdat 1464  gc:-2 0.016065
[1467]cdat 1465  gc:-2 0.008550
[1468]cdat 1466  gc:-2 0.016006
[1469]cdat 1467  gc:-2 0.013687
[1470]cdat 1468  gc:-2 0.010922
[1471]cdat 1469  gc:-2 0.011143
[1472]cdat 1470  gc:-2 0.015377
[1473]cdat 1471  gc:-2 0.011053
[1474]cdat 1472  gc:-2 0.013461
[1476]cdat 1473  gc:-3 0.023695
[1477]cdat 1474  gc:-3 0.023571
[1477]cdat 1475  gc:-2 0.015960
[1478]cdat 1476  gc:-2 0.016023
[1479]cdat 1477  gc:-2 0.008565
[1480]cdat 1478  gc:-2 0.015372
[1481]cdat 1479  gc:-2 0.011239
[1482]cdat 1480  gc:-2 0.015975
[1483]cdat 1481  gc:-2 0.016240
[1484]cdat 1482  gc:-2 0.013693
[1485]cdat 1483  gc:-2 0.013712
[1486]cdat 1484  gc:-2 0.016219
[1487]cdat 1485  gc:-2 0.006484
[1488]cdat 1486  gc:-2 0.010268
[1489]cdat 1487  gc:-2 0.016290
[1490]cdat 1488  gc:-2 0.016250
[1491]cdat 1489  gc:-2 0.005989
[1492]cdat 1490  gc:-2 0.016332
[1493]cdat 1491  gc:-2 0.016286
[1494]cdat 1492  gc:-2 0.011335
[1496]cdat 1493  gc:-3 0.015332
[1496]late cdat dropped p:1 c:1493  state:1494  tally:5
[1496]cdat 1494  gc:-2 0.015881
[1497]cdat 1495  gc:-2 0.011157
[1498]cdat 1496  gc:-2 0.016283
[1500]cdat 1497  gc:-3 0.018602
[1500]cdat 1498  gc:-2 0.016122
[1501]cdat 1499  gc:-2 0.016274
[1502]cdat 1500  gc:-2 0.016290
[1504]cdat 1501  gc:-3 0.022777
[1504]cdat 1502  gc:-2 0.015344
[1505]cdat 1503  gc:-2 0.016394
[1506]cdat 1504  gc:-2 0.013682
[1507]cdat 1505  gc:-2 0.005452
[1508]cdat 1506  gc:-2 0.016448
[1509]cdat 1507  gc:-2 0.008965
[1510]cdat 1508  gc:-2 0.013958
[1511]cdat 1509  gc:-2 0.012853
[1512]cdat 1510  gc:-2 0.012440
[1513]cdat 1511  gc:-2 0.010386
[1514]cdat 1512  gc:-2 0.015350
[1515]cdat 1513  gc:-2 0.002899
[1516]cdat 1514  gc:-2 0.015026
[1517]cdat 1515  gc:-2 0.010401
[1518]cdat 1516  gc:-2 0.012886
[1519]cdat 1517  gc:-2 0.012882
[1520]cdat 1518  gc:-2 0.015386
[1521]cdat 1519  gc:-2 0.012910
[1522]cdat 1520  gc:-2 0.015355
[1523]cdat 1521  gc:-2 0.007923
[1524]cdat 1522  gc:-2 0.012935
[1525]cdat 1523  gc:-2 0.012978
[1526]cdat 1524  gc:-2 0.015520
[1527]cdat 1525  gc:-2 0.012827
[1528]cdat 1526  gc:-2 0.015430
[1529]cdat 1527  gc:-2 0.015545
[1530]cdat 1528  gc:-2 0.012892
[1531]cdat 1529  gc:-2 0.012998
[1532]cdat 1530  gc:-2 0.014326
[1533]cdat 1531  gc:-2 0.012941
[1534]cdat 1532  gc:-2 0.015566
[1535]cdat 1533  gc:-2 0.008016
[1537]cdat 1535  gc:-2 0.015592
[1538]cdat 1536  gc:-2 0.015593
[1539]cdat 1537  gc:-2 0.000435
[1540]cdat 1538  gc:-2 0.015559
[1541]cdat 1539  gc:-2 0.015597
[1542]cdat 1540  gc:-2 0.015425
[1543]cdat 1541  gc:-2 0.008001
[1544]cdat 1542  gc:-2 0.014422
[1545]cdat 1543  gc:-2 0.008050
[1546]cdat 1544  gc:-2 0.015639
[1547]cdat 1545  gc:-2 0.015657
[1548]cdat 1546  gc:-2 0.010277
[1549]cdat 1547  gc:-2 0.015553
[1550]cdat 1548  gc:-2 0.013098
[1551]cdat 1549  gc:-2 0.008058
[1552]cdat 1550  gc:-2 0.015317
[1553]cdat 1551  gc:-2 0.016250
[1554]cdat 1552  gc:-2 0.016115
[1555]cdat 1553  gc:-2 0.006201
[1556]cdat 1554  gc:-2 0.016057
[1557]cdat 1555  gc:-2 0.013614
[1558]cdat 1556  gc:-2 0.011243
[1559]cdat 1557  gc:-2 0.013781
[1560]cdat 1558  gc:-2 0.015270
[1561]cdat 1559  gc:-2 0.016355
[1562]cdat 1560  gc:-2 0.016313
[1563]cdat 1561  gc:-2 0.005983
[1564]cdat 1562  gc:-2 0.016292
[1565]cdat 1563  gc:-2 0.016259
[1566]cdat 1564  gc:-2 0.016243
[1568]cdat 1565  gc:-3 0.021811
[1568]late cdat dropped p:1 c:1565  state:1566  tally:6
[1568]cdat 1566  gc:-2 0.010779
[1569]cdat 1567  gc:-2 0.013561
[1570]cdat 1568  gc:-2 0.013822
[1571]cdat 1569  gc:-2 0.013807
[1572]cdat 1570  gc:-2 0.016112
[1573]cdat 1571  gc:-2 0.013626
[1574]cdat 1572  gc:-2 0.011389
[1575]cdat 1573  gc:-2 0.008685
[1576]cdat 1574  gc:-2 0.014161
[1577]cdat 1575  gc:-2 0.013923
[1578]cdat 1576  gc:-2 0.013768
[1579]cdat 1577  gc:-2 0.011336
[1580]cdat 1578  gc:-2 0.013763
[1581]cdat 1579  gc:-2 0.013759
[1582]cdat 1580  gc:-2 0.016342
[1583]cdat 1581  gc:-2 0.013814
[1584]cdat 1582  gc:-2 0.009788
[1585]cdat 1583  gc:-2 0.015957
[1586]cdat 1584  gc:-2 0.015287
[1587]cdat 1585  gc:-2 0.012783
[1588]cdat 1586  gc:-2 0.012283
[1589]cdat 1587  gc:-2 0.014804
[1590]cdat 1588  gc:-2 0.009828
[1591]cdat 1589  gc:-2 0.012939
[1592]cdat 1590  gc:-2 0.014961
[1593]cdat 1591  gc:-2 0.014743
[1594]cdat 1592  gc:-2 0.015493
[1595]cdat 1593  gc:-2 0.015486
[1596]cdat 1594  gc:-2 0.015339
[1597]cdat 1595  gc:-2 0.015183
[1598]cdat 1596  gc:-2 0.012898
[1599]cdat 1597  gc:-2 0.012872
[1600]cdat 1598  gc:-2 0.015144
[1601]cdat 1599  gc:-2 0.015399
[1602]cdat 1600  gc:-2 0.015535
[1603]cdat 1601  gc:-2 0.015149
[1604]cdat 1602  gc:-2 0.015224
[1605]cdat 1603  gc:-2 0.015317
[1606]cdat 1604  gc:-2 0.015380
[1607]cdat 1605  gc:-2 0.015513
[1608]cdat 1606  gc:-2 0.015421
[1609]cdat 1607  gc:-2 0.013009
[1610]cdat 1608  gc:-2 0.015586
[1611]cdat 1609  gc:-2 0.013025
[1612]cdat 1610  gc:-2 0.009968
[1613]cdat 1611  gc:-2 0.012802
[1614]cdat 1612  gc:-2 0.015206
[1615]cdat 1613  gc:-2 0.013571
[1616]cdat 1614  gc:-2 0.010078
[1617]cdat 1615  gc:-2 0.013467
[1618]cdat 1616  gc:-2 0.011040
[1619]cdat 1617  gc:-2 0.008677
[1620]cdat 1618  gc:-2 0.013720
[1621]cdat 1619  gc:-2 0.008645
[1622]cdat 1620  gc:-2 0.016253
[1623]cdat 1621  gc:-2 0.013690
[1624]cdat 1622  gc:-2 0.010371
[1625]cdat 1623  gc:-2 0.016220
[1626]cdat 1624  gc:-2 0.016234
[1627]cdat 1625  gc:-2 0.013284
[1628]cdat 1626  gc:-2 0.016230
[1629]cdat 1627  gc:-2 0.016302
[1630]cdat 1628  gc:-2 0.013344
[1631]cdat 1629  gc:-2 0.013923
[1632]cdat 1630  gc:-2 0.014303
[1633]cdat 1631  gc:-2 0.011076
[1634]cdat 1632  gc:-2 0.016218
[1636]cdat 1634  gc:-2 0.016113
[1637]cdat 1635  gc:-2 0.016295
[1638]cdat 1636  gc:-2 0.011313
[1639]cdat 1637  gc:-2 0.011073
[1640]cdat 1638  gc:-2 0.009382
[1641]cdat 1639  gc:-2 0.015344
[1642]cdat 1640  gc:-2 0.013728
[1643]cdat 1641  gc:-2 0.011338
[1644]cdat 1642  gc:-2 0.012676
[1645]cdat 1643  gc:-2 0.016255
[1646]cdat 1644  gc:-2 0.016330
[1647]cdat 1645  gc:-2 0.011304
[1648]cdat 1646  gc:-2 0.012836
[1649]cdat 1647  gc:-2 0.016026
[1650]cdat 1648  gc:-2 0.013793
[1651]cdat 1649  gc:-2 0.011195
[1652]cdat 1650  gc:-2 0.015942
[1653]cdat 1651  gc:-2 0.013636
[1654]cdat 1652  gc:-2 0.013275
[1655]cdat 1653  gc:-2 0.013769
[1656]cdat 1654  gc:-2 0.015110
[1657]cdat 1655  gc:-2 0.010577
[1658]cdat 1656  gc:-2 0.016374
[1659]cdat 1657  gc:-2 0.011284
[1660]cdat 1658  gc:-2 0.010566
[1661]cdat 1659  gc:-2 0.015398
[1662]cdat 1660  gc:-2 0.015214
[1663]cdat 1661  gc:-2 0.012801
[1664]cdat 1662  gc:-2 0.007925
[1665]cdat 1663  gc:-2 0.014823
[1666]cdat 1664  gc:-2 0.012664
[1667]cdat 1665  gc:-2 0.012927
[1668]cdat 1666  gc:-2 0.007893
[1669]cdat 1667  gc:-2 0.013443
[1670]cdat 1668  gc:-2 0.015582
[1671]cdat 1669  gc:-2 0.000908
[1672]cdat 1670  gc:-2 0.009900
[1673]cdat 1671  gc:-2 0.013594
[1674]cdat 1672  gc:-2 0.015531
[1675]cdat 1673  gc:-2 0.010952
[1676]cdat 1674  gc:-2 0.013435
[1677]cdat 1675  gc:-2 0.013549
[1678]cdat 1676  gc:-2 0.008466
[1680]cdat 1677  gc:-3 0.019645
[1680]cdat 1678  gc:-2 0.002917
[1681]cdat 1679  gc:-2 0.008503
[1682]cdat 1680  gc:-2 0.016072
[1683]cdat 1681  gc:-2 0.011123
[1684]cdat 1682  gc:-2 0.003675
[1685]cdat 1683  gc:-2 0.013604
[1686]cdat 1684  gc:-2 0.015596
[1687]cdat 1685  gc:-2 0.016052
[1688]cdat 1686  gc:-2 0.015212
[1689]cdat 1687  gc:-2 0.016168
[1690]cdat 1688  gc:-2 0.011074
[1691]cdat 1689  gc:-2 0.013681
[1692]cdat 1690  gc:-2 0.013463
[1693]cdat 1691  gc:-2 0.011137
[1694]cdat 1692  gc:-2 0.011156
[1695]cdat 1693  gc:-2 0.000906
[1696]cdat 1694  gc:-2 0.009721
[1697]cdat 1695  gc:-2 0.016065
[1698]cdat 1696  gc:-2 0.010847
[1699]cdat 1697  gc:-2 0.008499
[1700]cdat 1698  gc:-2 0.015868
[1701]cdat 1699  gc:-2 0.013527
[1702]cdat 1700  gc:-2 0.012817
[1703]cdat 1701  gc:-2 0.013946
[1704]cdat 1702  gc:-2 0.015312
[1705]cdat 1703  gc:-2 0.016129
[1706]cdat 1704  gc:-2 0.016215
[1707]cdat 1705  gc:-2 0.001235
[1708]cdat 1706  gc:-2 0.016209
[1709]cdat 1707  gc:-2 0.016298
[1710]cdat 1708  gc:-2 0.016262
[1711]cdat 1709  gc:-2 0.006192
[1712]cdat 1710  gc:-2 0.015423
[1713]cdat 1711  gc:-2 0.015889
[1714]cdat 1712  gc:-2 0.013694
[1715]cdat 1713  gc:-2 0.013802
[1716]cdat 1714  gc:-2 0.013334
[1717]cdat 1715  gc:-2 0.011154
[1718]cdat 1716  gc:-2 0.016351
[1719]cdat 1717  gc:-2 0.016319
[1720]cdat 1718  gc:-2 0.002903
[1721]cdat 1719  gc:-2 0.015321
[1722]cdat 1720  gc:-2 0.013337
[1723]cdat 1721  gc:-2 0.013783
[1724]cdat 1722  gc:-2 0.016235
[1725]cdat 1723  gc:-2 0.016357
[1726]cdat 1724  gc:-2 0.015293
[1727]cdat 1725  gc:-2 0.016391
[1728]cdat 1726  gc:-2 0.012899
[1729]cdat 1727  gc:-2 0.011115
[1730]cdat 1728  gc:-2 0.015705
[1731]cdat 1729  gc:-2 0.013571
[1732]cdat 1730  gc:-2 0.013652
[1733]cdat 1731  gc:-2 0.013832
[1734]cdat 1732  gc:-2 0.015658
[1735]cdat 1733  gc:-2 0.013765
[1736]cdat 1734  gc:-2 0.010355
[1737]cdat 1735  gc:-2 0.015423
[1738]cdat 1736  gc:-2 0.012726
[1739]cdat 1737  gc:-2 0.005048
[1740]cdat 1738  gc:-2 0.015540
[1741]cdat 1739  gc:-2 0.010319
[1742]cdat 1740  gc:-2 0.007640
[1743]cdat 1741  gc:-2 0.002646
[1744]cdat 1742  gc:-2 0.010272
[1745]cdat 1743  gc:-2 0.020515
[1746]cdat 1744  gc:-2 0.015403
[1747]cdat 1745  gc:-2 0.012900
[1748]cdat 1746  gc:-2 0.007992
[1749]cdat 1747  gc:-2 0.015303
[1750]cdat 1748  gc:-2 0.010310
[1751]cdat 1749  gc:-2 0.007921
[1752]cdat 1750  gc:-2 0.012557
[1753]cdat 1751  gc:-2 0.015826
[1754]cdat 1752  gc:-2 0.016052
[1755]cdat 1753  gc:-2 0.011077
[1756]cdat 1754  gc:-2 0.013468
[1757]cdat 1755  gc:-2 0.016045
[1758]cdat 1756  gc:-2 0.016096
[1759]cdat 1757  gc:-2 0.011004
[1760]cdat 1758  gc:-2 0.015371
[1761]cdat 1759  gc:-2 0.011178
Shutting down the server
savegame/game_exit_20221230-183937-lev150.txt - saved
logs/20221230-183937-[150][m36].txt saved

C:\pm>







so how to combine those two numbers


and do they even still make sense?


Now, if I get one I can assume by the time it gets added it will be the next frame...
or this frame because by the time it is processed the frame has incremented

so when I get one that says -2 on frame 1730 for example...
that mean the cdat is for 1728, 2 frame ago...


now that the start of frame timer can be trusted, I should use that to go back and find out exactly when the packet arrived in relation to the frame start.

then I can make a composite number of how late it is...

WAN

[244]cdat 242  gc:-2 0.016242 -33.757700ms
[245]cdat 243  gc:-2 0.013527 -36.472500ms
[246]cdat 244  gc:-2 0.001073 -48.926800ms
[247]cdat 245  gc:-2 0.013675 -36.325100ms
[248]cdat 246  gc:-2 0.008515 -41.484700ms
[249]cdat 247  gc:-2 0.013653 -36.346700ms
[250]cdat 248  gc:-2 0.003773 -46.226500ms
[251]cdat 249  gc:-2 0.013406 -36.593600ms
[252]cdat 250  gc:-2 0.013678 -36.322400ms
[253]cdat 251  gc:-2 0.013635 -36.364900ms
[255]cdat 252  gc:-3 0.018778 -56.222400ms
[256]cdat 253  gc:-3 0.013594 -61.405500ms
[256]cdat 254  gc:-2 0.013532 -36.468100ms
[257]cdat 255  gc:-2 0.013844 -36.155600ms
[258]cdat 256  gc:-2 0.008631 -41.369000ms
[259]cdat 257  gc:-2 0.011310 -38.690000ms
[260]cdat 258  gc:-2 0.013817 -36.183400ms
[261]cdat 259  gc:-2 0.012976 -37.023800ms
[262]cdat 260  gc:-2 0.006389 -43.610600ms
[263]cdat 261  gc:-2 0.011331 -38.669100ms
[264]cdat 262  gc:-2 0.013452 -36.548300ms
[265]cdat 263  gc:-2 0.003223 -46.777400ms
[266]cdat 264  gc:-2 0.008756 -41.244300ms
[267]cdat 265  gc:-2 0.011006 -38.994200ms
[268]cdat 266  gc:-2 0.016051 -33.949000ms
[269]cdat 267  gc:-2 0.013857 -36.143100ms
[270]cdat 268  gc:-2 0.008706 -41.294100ms
[271]cdat 269  gc:-2 0.011205 -38.794700ms
[272]cdat 270  gc:-2 0.013796 -36.204100ms
[278]cdat 276  gc:-2 0.006955 -43.044900ms



LAN 10ms

[352]cdat 351  gc:-1 0.012526 -12.474100ms
[353]cdat 352  gc:-1 0.011416 -13.583900ms
[354]cdat 353  gc:-1 0.012495 -12.505200ms
[355]cdat 354  gc:-1 0.012518 -12.481800ms
[356]cdat 355  gc:-1 0.011462 -13.538200ms
[357]cdat 356  gc:-1 0.013423 -11.577100ms
[358]cdat 357  gc:-1 0.013426 -11.573700ms
[359]cdat 358  gc:-1 0.012400 -12.599700ms
[360]cdat 359  gc:-1 0.012547 -12.453300ms
[361]cdat 360  gc:-1 0.013429 -11.570900ms
[362]cdat 361  gc:-1 0.012374 -12.626400ms
[363]cdat 362  gc:-1 0.013445 -11.554800ms
[364]cdat 363  gc:-1 0.013457 -11.543500ms
[365]cdat 364  gc:-1 0.012394 -12.606000ms
[366]cdat 365  gc:-1 0.012999 -12.001300ms
[367]cdat 366  gc:-1 0.012964 -12.036300ms
[368]cdat 367  gc:-1 0.011328 -13.672500ms

LAN 2ms

[573]cdat 572  gc:-1 0.021599 -3.400600ms
[574]cdat 573  gc:-1 0.021587 -3.412900ms
[575]cdat 574  gc:-1 0.020520 -4.480400ms
[576]cdat 575  gc:-1 0.020883 -4.117200ms
[577]cdat 576  gc:-1 0.021548 -3.452300ms
[578]cdat 577  gc:-1 0.020530 -4.470000ms
[579]cdat 578  gc:-1 0.021555 -3.445200ms
[580]cdat 579  gc:-1 0.021530 -3.469900ms
[581]cdat 580  gc:-1 0.020455 -4.545000ms
[582]cdat 581  gc:-1 0.021507 -3.493000ms
[583]cdat 582  gc:-1 0.021511 -3.489000ms
[584]cdat 583  gc:-1 0.019713 -5.286600ms
[585]cdat 584  gc:-1 0.021510 -3.490400ms
[586]cdat 585  gc:-1 0.021510 -3.489900ms
[587]cdat 586  gc:-1 0.020450 -4.550300ms
[588]cdat 587  gc:-1 0.021512 -3.488100ms



I want to have server stats on cdat_rx time
tally for 1s and do average and max min
same for late cdats

OK I have done that...big surprise...nothing seems to effect when cdats are received on server, except for client dsync....


the only thing I can do to get cdats to the server faster, would be to let the client move ahead of the server in time....
but then the client would always get difs that were too late to apply....

what if I let the client rewind?
and apply the local moves from the last frame?

that would mean I would have to keep the clients local moves...it would only be one move per frame max...

this is just crazy enough to maybe work.....

client stores all its game moves in it's own local array....
when client get a dif that is in the past:
apply then play back to current...



right now I have the server in the lead, the client lags behind just enough so I can get the current state from the server and apply it.
If I let the client pass the server, the server will be able to get cdats with less delay, but who knows what else might happen??

I think it's worth a try....

1 - make client put stuff in its own local game_moves array

2 - remove the part in rx stdf where we ignore late difs

3 - modify apply dif to allow late ones

this is a tricky bit of code here....

   // check to see if frame_nums match and its time to apply dif or if initial state when mwPS.frame_num == 0
   if ((mwPS.frame_num != client_state_dif_dst) && (mwPS.frame_num != 0))
   {


first of all if the match then do it
second of all if mwPS.frame_num == 0 do it
third of all...
if newer than last applied dif....

what is the varaible for the last applied dif mwPS.frame_num? 'client_state_base_frame_num'

so check if the dest of the dif_dest on deck is newer than that

if (client_state_dif_dst > client_state_base_frame_num) // we have dif with a newer dest than previous

omg I am ready to try it....

well it looks like I can run a game succesfully with negative sync... lets try it on WAN


client has all been put back together nicely...
still to do on client
look into chase multiplier...seems to work good but I have not examined it
automatically set chase amount, but based on what?
should it be a sliding scale, or a fixed number?

on server I have issues if I try to lower s1
raising it is OK but when I lower it, server becomes unresponsive and will not accept new connections

show more about the clients on the server...but what and why??

profile using timestamps certain functions...

move
draw
rewind
send stdf
receive packets

move packetbuffer code and functions to packet file


testing...making the client -40 seemed to make the game a lot smoother....


calculate and show ping on client and server...


server tx ping from 'loop' with current time

client rx ping and tx pong with passed time and current time

server rx pong
calc rt
return passed ts in pang

client rx pang
calc rt


ok now where to store it...

player1
   double ping;

put it on the bottom for client

in server it will be part of debug array



flush client and server on level done


when does client show red...removed

how about auto setting clients offset to ping....

but I would need to get an average ping
I only read it every 2s

how about reading it one per second and keep a 10s rolling average....

at the start of when a client joins
use default of zero to start...
get 8 pings in 2s for avg then use that to adjust
then do the rolling replace one every 2 sec

is this overkill...maybe...

but just blindly plugging one ping into offset is bad also

should have some limits....
+20 absolute max, why would you even want to go positive?
-50 to -80 somehwere around there for the min need to test...




try experimenting with different s1 and s2
3 1 - default

I'm getting late cdats and stuff from 4230's but not scat or e6430
the sync on them is jumping around a lot...
I could probably benefit from some code profiling....


20221231 9:26 AM

make the client initiate ping, as it is the one that needs it.
where?
how about from a timer?
too complex, just do it like the server does...
done...

now make way for client to do more right after join...

how about make the cyclic buffer of ping to average first....

then make a method to add new pings

then make a way that the average is calultaed

then make a way that when the buffer is not full, its pings mopre often...

struct ping_buffer

int num_filled;
int new_index;
double ping[8];
double avg;

initially:
num_filled = 0;
index = 0;
all are 0;

as added:
num_filled++
index++

num_filled can be greater than index

when doing avg

loop and add from 0 to num filled, or max if full

then divide and set avg...


do I need to do it in a struct? probably not the besy way...

double ping_array[8];
double ping_avg;
int    ping_num_filled;
int    ping_index;

make a new file ping_buffer.cpp

clear in client init..done

now make a function to add...done...

now where am I going to save this?

player1

ping_avg

ok that's done...now make it run faster until filled...

done...

now maybe toss out the highest and lowest for average....

experiment with different values of s1 and s2

right now I have been using 3 and 1

re do the client sync graph for the server, especially since I now use dsync

what did I use before?

stak packet on server prints this log line:

sprintf(tmsg1, "rx stak sync:[%d] chase:[%d] ack_fn:%d cli_fn:%d", players1[p].server_sync, players1[p].client_chase_fps, ack_frame_num, client_frame_num );

[30][1][318]rx stak sync:[1] chase:[39] ack_fn:316 cli_fn:317 set new base

I want to add dsync and remove unneeded things...why do I have 2 fn that are always the same??

change client_chase_fps to double from int....

its main use is to get back to the server to be displayed

OK I have parsed it from the log lines in graph...

but the problem is that the data for the graph is an integer array....

for now, multiply by 10...

redo sync to display in ms

I can come back to this later....
when I get this done I can examine chase better.....

OK, Ive been thinking...
I want to make the tag parsing thing a separate function...done
replaced 8-10 calls

Also this sync graph would probably be better on the client.

The server only has data when it receives stak....

what can I do to make the graph look better??

it is not frames anymore, but ms...

better....

can I auto range based on the data shown?...yes...

my stak log line can be too long

[30][3][500]rx stak syn:[4] dsy:[12405.5] chs:[70.0] afn:496 cfn:496 failed to set base! cl:499

[30][4][6180]rx stak syn:[-2] dsy:[-113.3] chs:[31.7] afn:6177 cfn:6182 failed to set base! cl:6179
[30][3][6182]rx stak syn:[-2] dsy:[-104.8] chs:[33.0] afn:6179 cfn:6184 failed to set base! cl:6181
[30][4][6182]rx stak syn:[-2] dsy:[-104.6] chs:[32.6] afn:6177 cfn:6184 failed to set base! cl:6181
[30][2][6183]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6185 failed to set base! cl:6181
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183


failed to set base! cl:6183
change to
fail base set:6183

saved 9 char

more:
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183

[30][2][6184]rx stak s[-2] d[-100.0] c[33.0] af:6179 cf:6186 fail set base:6183

saved 20 char





can I make some buttons in graphs?  at the top of the legend scale lock or autorange..
auto/manual
manual +/-



I really want to make the graphs simpler...

wouldn't it be nice to have a common function for all of them?

they all seem to have common x axis...frames, seconds, minutes, etc.....


what is the data needed to describe a graph?

screen coordinates x1, y1, x2, y2, w, h
these are in the standard computer screen format: x1,y1 is upper left corner

graph x axis
start and end data values

graph y axis
start and end data values

can get range from these.

an array of data used to plot points on the graph

data[][0] = x
data[][1] = y

can I make this an object?

why?

so it encaspulates it's own data and methods

I will call it to draw itself
optionally draw legends and gridlines
process mouse input on the graph

class mw_graph

make a new file and lets do this....


I don't get why I am having such a hard time mapping one range to another....
am i doing the wrong things??
I don't need to map the data range to the axis range!
I need to map the axis range to the screen range!!!!

   double xm = screen_w / x_axis_rng;
   double ym = screen_h / y_axis_rng;

   for (int i=0; i<data_points; i++)
   {
      float x = screen_x1 + (data[i][0]-x_axis_min) * xm;
      float y = screen_y2 - (data[i][1]-y_axis_min) * ym;
      al_draw_rectangle(x, y, x+1, y+1, mColor.pc[10], 1);
   }


now what??

should I put some mouse_controls in?
yes...

ist show mouse...

2nd show mouse position and convert to values...

this will mean I have to call this in a loop and process event queue....

done...
now I want an autoscale button
one for x and y and one for each also...

done...


what now?

can you do a nice title...

set a minimum x axis range....

butttons for nice axis management:
auto/manual
of just auto button
+ and - to adjust scale
for each min and mix??

not sure if this will be that usefull

implement mouse_drag...
x only or x and y?
can you set a scale conevrsion varaible for x axis and y axis
do it on the fly..it was easy...
mouse drag works beautifully




            // graph position under mouse (mx1) needs to stay the same

            // change range?? then find min and max to ensure same pos??


            // what if i calulated scaler, then changed that, then worked backwards from there
//            double x_scaler =  x_axis_rng / screen_w;
//            x_scaler *= 1.1;
//            x_axis_rng = x_scaler * screen_w; // convert range back

            // now how do I adjust min so that current pos is the same

            // old distance from current pos to min * scaler  ????

//
//            // old distance from curent position to min
//            double old_offset = mx1 - x_axis_min;
//
//            printf("old_offset:%f\n", old_offset);
//
//
//            // get original scale
//            double x_scaler =  x_axis_rng / screen_w;
//
//            printf("orignal_scale:%f\n", x_scaler);
//
//
//
//            // change scale
//            x_scaler *= 1.1;
//
//
//            printf("new_scale:%f\n", x_scaler);
//
//
//            printf("old range:%f\n", x_axis_rng);
//
//            // convert range
//            x_axis_rng = x_scaler * screen_w;
//
//            printf("new range:%f\n", x_axis_rng);
//
//
//
//            printf("old offset:%f\n", old_offset);
//
//            // scale to new
//            double new_offset = old_offset * 1.1;
//
//
//            printf("new offset:%f\n", new_offset);
//
//
//
//            printf("old min:%f\n", x_axis_min);
//
//            // set min from original position and new offset
//            x_axis_min = mx1 - new_offset;
//
//
//            printf("new min:%f\n", x_axis_min);
//
//            // set max1
//            x_axis_max = x_axis_min + x_axis_rng;
//
//
//


            double old_offset = mx1 - x_axis_min;     // old distance from curent position to min
            double new_offset = old_offset * 1.1;     // scale to new
            x_axis_min = mx1 - new_offset;            // set min from original position and new offset
            x_axis_rng *= 1.1;                        // convert range
            x_axis_max = x_axis_min + x_axis_rng;     // set new max


holy shit that is beautiful!!

mouse drag (x axis)
mouse wheel zoom (x axis)
mouse drag zoom in (x and y axis)

do something about mouse drag when off screen, clamp to edges done...

try y drag move...awesome...

try y zoom wheel...wicked...

now if I added lock buttons on the x and y axis to prevent this

will it lock both scroll and zoom??

for x axis

zoom lock..


I want scroll bars...

do an x one first


I think I am readt to start thinking about some limits....

limit the axis ranges....

make all changes to the axis ranges go through a common function so limit will only need to be tested once
done...
it works, but seems a little weird when drag turns into resize...
drag normally moves both start and end
if one does not move, it turns into a resize...
the alternative would be to do nothing, no drag move allowed if it would change range

I can live with it for now...


now make some ways to drag the scroll bar...

make scrollbar variables part of class...done

int x_axis_scrollbar_x1;
int x_axis_scrollbar_x2;
int x_axis_scrollbar_w;

int x_axis_scrollbar_bar_x1;
int x_axis_scrollbar_bar_x2;

int x_axis_scrollbar_y1;
int x_axis_scrollbar_y2;

moved draw into its own function


figure out the offset...data does not start till 40...done...


now I have 5 ways to adjust the scroll bar with the mouse and its looking pretty good...

sometimes I can adjust past data max and stuff breaks...
a_axis min can be more the max...this should not happen...

there is some chicken and egg things going on with enforce limits...

testing for min max
testing for wrong order

I need to test both min and max to see if they are in range

I also want to add another test...minimum range...

I should find the smallest difference between x values and make the minum range 10 of those...

for now, lets just set a static value and test..

if both max and min are stuck near the top separate them by minimum range...

this all looks good...

now I want to do some y ranging


   bool x_axis_lock_scroll;
   bool x_axis_lock_zoom;

   bool y_axis_lock_scroll;
   bool y_axis_lock_zoom;
   bool y_axis_lock_auto_zoom;



y_axis_lock_zoom
done for drag rect and mouse wheel
not done for drag scroll...still changes zoom...fixed

y_axis_lock_scroll

y_axis scrollbars

y axis is reversed, which poses some issues
how am I going to deal with that? at what point do I flip the axis...
x1 is smaller than x2 when drawing on the screen
but when the mouse moves they are oppposite...
make the data reveser
y2 is min, y1 is max...
im thinking of doing it all upside down...
y1 is lower

I just made the scrollbar y1 and y2 reversed....

I have implemented all scrollbar functionality to y scroll bar...
make the highlight look better, align better, color, size, different mouse_pointer....done...



now back to the locking...

enforce zoom lock on y scroll bar..done...


what does it mean if scroll is locked and zoom is not? does that even make sense??
it could mean that the x_min is locked, but not x_max and scroll


can change   min max rng
no lock       1   1   1
zl            1   1   0
sl            0   1   1
zl + sl       0   0   0


what about autoscale y depending on what is on screen

what if I made zoom_lock have 3 values

0 off
1 lock
2 auto

rignt click on axis or scrollbar for options..

mouseover text ...

mouse crosshairs

jump to nearest data position and show data for that...

I want a way to store the units for each axis...
call a fucntion to set msg

right click on stuff to popup menu....done


20230103 back to work...

what are the main things left to do on graph?

units, axis labels, gridlines

nice bounding boxes for all the graph elements
(optional) title and (optional)space for it (probably above but not married to it)

y axis labels (could be on left or right side)
y axis scrollabr (left or right)

x axis labels (could be on top or bottom)
x axis scrollabr (could be up or down)

all of these things are optional

reset range should turn auto off....

need to stack things on the axis...

gridlines and labels
axis label
scrollbar
these should all dynamically size...
then when that is all done, I will have the size of the entire graph area
maybe I can rename that to graph_x y etc... and the other to plot...

graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

these are the main ones that are set outside the class....
then after the width of all the things in the axes are calculated...
then what is left over will be for the plot

call resize at the beginning....

these will never be changed internally:
graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

find out the width needed for axes...

set:
plot_x1
plot_y1
plot_x2
plot_y2
plot_w
plot_h





make a function to auto set positions... for each axis...

void x_axis_draw(void) // does gridlines, labels, axis title and scroll bars

int x_axis_get_size(void) // returns the size needed by x_axis


start with gridlines and labels...
make them all optional




I now have:

void x_axis_draw(void);
void x_axis_get_size(void);
void x_axis_draw_legend(void);
void x_axis_draw_gridlines_and_labels(void);
int  x_axis_draw_scrollbar(void);
void x_axis_proc_scrollbar(void);


called from main draw:

void mwGraph::x_axis_draw(void)
{
   x_axis_draw_gridlines_and_labels();
   x_axis_draw_legend();
   x_axis_draw_scrollbar();
}


I also have:

void mwGraph::process_input(void)
{
   x_axis_proc_scrollbar();

which also calls:

void mwGraph::x_axis_proc_scrollbar(void)
{
   int sb = x_axis_draw_scrollbar();


how are draw and proc called?
like this externally:
mG[0].draw();
mG[0].process_input();

I will probabaly change that later, do I really need to separarte them?

for now I have other things to do:

get the variables for each x_axis element done


int x_axis_label_draw_on;
int x_axis_label_tick_size;
int x_axis_label_text_size;
int x_axis_label_draw_size;



1st get axis sizes
2nd set plot size and pos
3rd set axis pos

do I need a spearate value for actual size, vs stored size
so I can restore if turned on and off...

I think the x axis is looking really good...now work on the y axis

I am very happy with how these look

next I want to have the option of small text on legends
done and now I have a much nicer method for drawing those...


next, I want to always put labels on origins...

done, but sometimes overwrite other axis labels..



make a function to display axis values...

why can't I put mouse on point on the edge of plot?? fixed
also fixed when point text box is draw off screen...

implment units for axis...

x_axis_value_type..

0 = none
1 = time in frames...

this will have a large impact...

depending on the current displayed range,
the units for an axis will change..

the max value displayed could be used to set the units in some cases...n other cases the range...

like for time (frames)
could be frames, sec, minutes...
depending on what range is shown

this will change:
x axis legend
gridlines and labels
point text box...

I need a main title for the legend:
Time
then I need another for units

I could make a type...

type 0 - do nothing
type 1 - customized for frames

made a type..


if 1, where do I check it??

depending on the range I need to set units, divider and legend

where does that naturally happen?
draw
set size and pos
input

none of these actually

how about enforce axis limits?


and what am I going to be setting?

if type 1
use range to set
legend text
divider
units text

add divider...


----------------------

make labels also able to have font
start with x..done
and also reduce space between labels and legend..done

now do y...done...


it gets kind of messy at the origin when I draw labels there that conflict with the auto ones...and the x and y sometimes confict too...

remove x, keep y.. actually fixed origin still conficts with auto...remove (comment out) both for now...








I am happy with this


should I try it on some real data??

what would happen if I tried more data? like a real bandwidth graph...


what if I made the array larger, to include more players


or I could put them all in the main array but tag them with different series...

or I could make an entirely new graph and overlay the data...

all these things I am thinking of would have a common x axis...

should I try to put everything in one array and tag it by series?
or should I have multiple arrays?

with any method, I need to make sure the data is in order



how about a three dimensional array

point[series][x][y]


I want an int for series and doubles for the other two..

looks like a structure

max needed would be 16 if I do 8tx and 8rx



each instance of my class will get this:


struct data_seri
{
   double data[10000][2];
   int num_data;
   int active;
   int color;
   char name[1024];
};
data_seri series[20] = {0};

use like this:
series[0].data[i][0]

wow! that was surpisingly easy to get 8 tx rate lines...

next I need a series legend and the ability to toggle series on and off while the graph is running...

I want to be able to have many other things shown as well...


when setting unlocked, make sure to set autrange off also...

I want to make a nice gui setup for changing things....

like a page of toggles and checkmarks...

maybe some sliders and buttons too..

show legend like:

series number - series name - show the color and line style - click to toggle

bug--scrollbar does not like negative data

removed clear screen from calling loop, handle it internally

I am calling axis_get_size_and_arrange_pos() externally every loop, do I need to?..yes
so call it internally then...
from draw, or proc input?  proc input...

now I only call 3 things externally and one is only in case the user resized the screen...

mG[0].set_graph_pos(0,0, SCREEN_W, SCREEN_H/2-10);
mG[0].draw();
mG[0].process_input();

now back to showing legend for multiple series.......



figure out how to draw dashed line...

https://www.allegro.cc/forums/thread/615463
https://www.allegro.cc/forums/thread/615415



It looks like I can only do al_draw_soft_line on a bitmap, drawing directly to the backbuffer has weird results

so lets try to figure out hpw to do that...


make a bitmap the same size as graph

now make all my draw stuff draw on that, but all coordinates will need to be adjust to 0,0 for graph_x and y

there were surprisingly few references to those..mostly in adjust x amd y axis...

now that I am drawing onto a bitmap instead of the backbuffer, the drawing looks a lot blockier...yay! :(
text looks fine, but the high level primitives (lines) suck...

the gridlines are terriblly blocky and missing in places...

what a goddamn hassle to try to draw dashed lines

there is no godamn reason for it...



how hard would it be to revert now?
and either:
- only draw the plot lines on its own bitmap, or
- figure out how to use soft lines with backbuffer

reverted...

try to figure out how to use soft lines with backbuffer

- does soft line return x and y that make sense?? yes...


if I store all the x and y in an array then draw them outside the function that seems to work...go fig...





now how im I going to implement this?

ideally I would like to call something very similar to draw_line

al_draw_line(100, 110, 200, 110, mColor.pc[15], 1);
mw_draw_line(100, 110, 200, 110, col1, col2);


here it is:

int mw_p[10000][2] = {0};
int mw_i = 0;

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t state, int x, int y)
{
   if (mw_i < 10000)
   {
      mw_p[mw_i][0] = x;
      mw_p[mw_i][1] = y;
      mw_i++;
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, int c1, int c2)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   mw_i = 0;
   al_draw_soft_line(&v1, &v2, (uintptr_t)NULL , mw_FirstFunction , mw_StepFunction , mw_DrawFunction);

   int cycle = 0;
   for (int i=0; i<mw_i; i++)
   {
      int x = mw_p[i][0];
      int y = mw_p[i][1];

      int c = c1;
      if ((cycle % 8) < 4) c = c2;
      cycle++;

//      al_draw_filled_circle(x, y, 1, mColor.pc[c]);
      al_draw_filled_rectangle(x-0.5, y-0.5, x+0.5, y+0.5, mColor.pc[c]);

//   printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
      //al_put_pixel(p[i][0], p[i][1], mColor.pc[p[i][2]]);
   }
}


I am thinking about doing it slightly different...

make my array contain only line segements of the same color

then use the regular al_draw_line to draw those segments...

then I would have less draw calls, and I could use the thickness of lines


values to send to draw:
cycle total
cycle 0 col (default color)

// cycle & total < val color = c1
cycle 1 val
cycle 1 col

8, 15, 4, 10

then when drawing, draw 1 to 0, 2 to 1...etc...

I have it all implemented except for the thinning of call to al_draw_line
it would make it more complicated and im not sure it is needed...

not that complicated

now I need to ensure the last point is not skipped...


int mw_p[10000][3] = {0};
struct mw_state
{
   int num_points;
   int cycle_total;
   int cycle_tally;
   int default_color;
   int c1_val;
   int c1_col;
   int c2_val;
   int c2_col;
};

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t ms1, int x, int y)
{
   struct mw_state* ms = (struct mw_state*) ms1;
   if (ms->num_points < 10000)
   {
      // get color from cycle
      int col = ms->default_color;
      int mod = ms->cycle_tally++ % ms->cycle_total;
      if (mod < ms->c1_val) col = ms->c1_col;
      if (mod < ms->c2_val) col = ms->c2_col;

      // always set these, in case we get to the end and the point is skipped beacuse of duplicate colors
      mw_p[ms->num_points][0] = x;
      mw_p[ms->num_points][1] = y;

      // should i add this point?
      if ((ms->num_points == 0) || (col != mw_p[ms->num_points-1][2])) // if first point, or color different from previous
      {
         mw_p[ms->num_points][2] = col;
         ms->num_points++;
      }
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, float thickness, int cycle_total, int default_color, int c1_val, int c1_col, int c2_val, int c2_col)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   struct mw_state ms;
   ms.num_points = 0;
   ms.cycle_total = cycle_total;
   ms.default_color = default_color;
   ms.c1_val = c1_val;
   ms.c1_col = c1_col;
   ms.c2_val = c2_val;
   ms.c2_col = c2_col;

   al_draw_soft_line(&v1, &v2, (uintptr_t)&ms, mw_FirstFunction, mw_StepFunction, mw_DrawFunction);

   // ensure last point was not skipped, due to duplicate color
   mw_p[ms.num_points][2] = mw_p[ms.num_points-1][2];
   ms.num_points++;


   for (int i=1; i<ms.num_points; i++)
   {
      int x1 = mw_p[i-1][0];
      int y1 = mw_p[i-1][1];
      int x2 = mw_p[i][0];
      int y2 = mw_p[i][1];
      int c =  mw_p[i][2];
      al_draw_line(x1, y1, x2, y2, mColor.pc[c], thickness);
      //printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
   }
}

that was the final iteration...now try it in action!!

see how long it takes...
it is literally 1000 times slower....

plot time: 0.000210   lines drawn:152
plot time: 0.227604   lines drawn:156

I commented out the drawing part...
its not the drawing part, its the call to soft line...

this is useless, but at least now I know it

I just wasted 6 hours on this...

can I make my own code that will do it better?


pass it 2 vertexes
and a span like this:

   int c0_len;
   int c1_col;
   int c1_len;
   int c1_col;

it will create an array of points

point 0 = vertex 1
next point

what math will you use?

total x span
total y span
total length

length of span / color_span = divider

divide xspan and yspan by divider to get incs

do incs and add vertex points...

this is my first hacked together implementaion and it works...
before I go any further, speed test it....


void mw_draw_line2(int x1, int y1, int x2, int y2, float thickness)
{
   int color_span = 10;

   double line_xspan = x2-x1;
   double line_yspan = y2-y1;
   double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

   double div = line_span / color_span; // number of spans

   double xinc = line_xspan / div;
   double yinc = line_yspan / div;

   int xa = x1;
   int ya = y1;

   int xb = xa+xinc;
   int yb = ya+yinc;


   int c = 15;

   while (xa < x2)
   {
      al_draw_line(xa, ya, xb, yb, mColor.pc[c], thickness);
      if (c == 15) c = 10;
      else if (c == 10) c = 15;
      xa+=xinc;
      ya+=yinc;
      xb+=xinc;
      yb+=yinc;
   }
}


plot time: 0.000283   lines drawn:156


I'm back baby! as proof of concept it works and is just as fast as the al_draw_line...

now clean it up....

what if I kept the remainder of the color shift for the next line, that would make the graph look awesome...

I could keep a static int 'distance travelled' and use mod for the cycling repeats

3 colors, just like last one

this will mean a major rewrite of how I do the getting of lines..

it is so simple now because the span is always the same

8 red
3 blue
4 yellow


get inc from main period (14)
get inc from main to 2   (3)
get inc from 2 to 3      (4)

distance_travelled

start with the args...
 int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col))

I have a beautiful three color version working, but no carry over for color shift

plot time: 0.000990   lines drawn:156
plot time: 0.000983   lines drawn:156
plot time: 0.000986   lines drawn:156

now it takes almost 1ms...should I be worried?

it depends on how small the color line segments are


now how will i make this work in the plot? how will I keep track of color?

negative values for color?

2 values for color?

if second one is 0 just draw normally






if (series[s].color2 == 0) al_draw_line(ox, oy, x, y, mColor.pc[series[s].color1], 1.0);
else                       mw_draw_line(ox, oy, x, y, 1.0, 8, series[s].color1, 10, series[s].color2, 0, 0);

wait how??



I think I do want to implement the color shift across lines...when lines are too short, sometimes they dont show at all...


when I zoom in and get more color segments it really slows down...

do all lines draw every time? yes

try thinning....

did the test for x_axis min...works but i want to draw a line to the first offscreen data points

mak a function to get that....

get lowest x and highet x index on screen...
for each series
cycle the dat

that is done...

can I make a way to adjust the color shift span based on size?
I also could make the color shift carry over...

add clicking on series legend....
put series legend in y axis lineup...??
what order? can I assume...

now I want to try the color shift carry over


remainder as a fraction of position in the total color cycle...

maybe there is an easier way...


startxy endxy

get a unit for 1 pixel diagonally converted to x and y

then I can pick any spot on the line and do x,y

then start drawing the line sequence before the actual line

seg1
get ab_positin
static double line_color_offset = 0;
find un


I have finally done it, after much, much work....



20230108 sunday morning

I have the multi-colored line thing working,
the complicated part was the bit where I keep the color sequence going over multiple calls.
this was important so that a graphline made of short segments has a consistant color pattern
and doesn;t just restart the pattern for every line.

to do today...





pop up menu to adjust stuff on series legend, like line size.
config screen that stays overlaid while you change things and see immediate results

move position of mouse over box...done
make only one call to process input and draw
maybe don't redraw every frame, only when changed

when is draw called on its own??
a few times when adjusting things...

when is proc_input called...only externally
added draw to proc_input...seems to work
I still call draw() every frame...

pop up menus...made one for series and cleaned up a bit...

series_legend...

need to make it to fit with all...
series_legend_type
0 autofill
1 8 player array

why does not having at least 1 series initialized cause crash?
range is set to zero and enforce range loops forever
fixed it with an error message if no data
I just need to make sure to set up at least one series when loading data...

or call mG[0].set_series_legend_type(0);
and auto detect...done...

make it so that any arbitrary series can be turned on and off..done...

now do I even need a special mode for type 1...yes...

now on to the big one:
figure out why with short color sequences, especially at the end I have gaps before the first line

what I have discovered is that the color wrap does not work if the end occurs in the first sequence


actually it never works at all...
the next lines always start somwhere in segment 0


where do I use store and use lco?
store it outside the call, the call uses and modifies it

fixing lco made things better...

does not like when c = 0;

when b = 0, it triggers a call to regular line draw..no its when b_col = 0;


trouble shoot c = 0;



in all my checks I am comparing the x and y values separately,
would it not be easier to somehow check the vector...
that is how it is specified...
10 vector units of one color, 5 of another

line is 100 vector pixels

0-9 are one color

10-14 are another

then convert those to x and y at the very last step...

this sounds a lot easier....


I have xa ya xb yb....
I want za and zb, each is just the number of pixels we are on the current line

start:

za = 0; // or previous color shift index
zb = za + c0_val;
do line checks

if (zb < 0)           // off line completely
if (za > line_length) // off line completely

else
if (za<0) adjust za to zero
if (zb>line_length) adjust to line length.

that did not take very long...

test...

c = 0
a = 0
b = 0

all work fine... but the total cannot be zero....
patched into the graph...

now lets make bandwidth graph do its thing

that took like 10 minutes...wow...


now lets do the other one...

client sync actually has 3 graphs...
active
sync
chase

not only that, it has 8 players * 3 graphs

this should be fun...
do three different graphs

0 active
1 sync
2 chase

OK that all works, but now I need to customize the graphs
default values are nice, but I want more control...

like on the active graph, I want to set and lock the y ranges...


now I want to slave the x ranges to a different graph


x_axis_slave

100 slave to 0
101 slave to 1...etc..

where to check...proc x scroll bar...done

now I also need to make sure plot_x1 lines up for all slaved plots...
still need to make these work together


make a copy of original bad method in note then erase it//done

try a version with only 2 colors to see if its faster...less segements by 1/3 but not faster...




/*
original bad mnethod, actually the second....

// returns 1 if end adjust...
int check_and_draw(double x1, double y1, double x2, double y2, double xa, double ya, double xb, double yb, double line_xinc, double line_yinc, int col, float thickness, int &segments_drawn, int &lco)
{
   char t[1024] = {0};
   sprintf(t, "\n");


   int skip = 0;
   int start_adj = 0;
   int end_adj = 0;

   // these checks mean that the segment is entirely not on the line
   if (((line_xinc > 0) && (xb < x1)) || ((line_xinc < 0) && (xb > x1))) skip = 1; // xb before line start
   if (((line_xinc > 0) && (xa > x2)) || ((line_xinc < 0) && (xa < x2))) skip = 2; // xa after line end
   if (((line_yinc > 0) && (yb < y1)) || ((line_yinc < 0) && (yb > y1))) skip = 1; // yb before line start
   if (((line_yinc > 0) && (ya > y2)) || ((line_yinc < 0) && (ya < y2))) skip = 2; // ya after line end

   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (((line_xinc > 0) && (xa < x1)) || ((line_xinc < 0) && (xa > x1))) start_adj = 1; // xa is before line start
      if (((line_yinc > 0) && (ya < y1)) || ((line_yinc < 0) && (ya > y1))) start_adj = 1; // ya is before line start

      if (((line_xinc > 0) && (xb > x2)) || ((line_xinc < 0) && (xb < x2))) end_adj = 1; // xb is after line end
      if (((line_yinc > 0) && (yb > y2)) || ((line_yinc < 0) && (yb < y2))) end_adj = 1; // yb is after line end

      if (start_adj)
      {
         sprintf(t, "start_adj\n");
         xa = x1;
         ya = y1;
      }
      if (end_adj)
      {
         int xlo = abs(x2-xb);
         int ylo = abs(y2-yb);

         if (xlo>ylo) lco = xlo;
         else         lco = ylo;

         sprintf(t, "end_adj - lco:%d\n", lco);
         xb = x2;
         yb = y2;
      }


      printf("%s   drawn at xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f\n", t, xa, ya, xb, yb);


      al_draw_line(xa, ya, xb, yb, mColor.pc[col], thickness);
      segments_drawn++;



   }

  // if (skip == 2) end_adj = 1;

   return end_adj;
}



int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
  // printf("mw_dl x1:%f y1:%f x2:%f y2:%f\n", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion

   int segments_drawn = 0;

   if (c1_col == 0) al_draw_line(x1, y1, x2, y2, mColor.pc[c0_col], thickness);
   else
   {
      int color_span = c0_val + c1_val + c2_val;
      printf("\nlco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span

      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_span != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         // one unit of these are one unit of vector move
         double line_xinc = line_xspan / line_span;
         double line_yinc = line_yspan / line_span;

         int section = 0;

         while (!done)
         {
            printf("\nSection:%d\n", section);


            // draw first segment
            double xa = x1 + ((section * color_span) - line_color_offset) * line_xinc; // start position for drawing
            double ya = y1 + ((section * color_span) - line_color_offset) * line_yinc;
            double xb = xa + c0_val * line_xinc;
            double yb = ya + c0_val * line_yinc;

            printf("1st segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
            if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = color_span - c1_val - c0_val - lco;
            }
            if (!done)
            {
               // draw second segment
               xa = x1 + ((section * color_span) - line_color_offset + c0_val) * line_xinc; // start position for drawing
               ya = y1 + ((section * color_span) - line_color_offset + c0_val) * line_yinc; // start position for drawing
               xb = xa + (c1_val) * line_xinc;
               yb = ya + (c1_val) * line_yinc;
               printf("2nd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
               if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c1_col, thickness, segments_drawn, lco))
               {
                  done = 1;
                  line_color_offset = color_span - c1_val - lco;
               }
               if (!done)
               {
                  // draw third segment
                  xa = x1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_xinc; // start position for drawing
                  ya = y1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_yinc; // start position for drawing
                  xb = xa + (c2_val) * line_xinc;
                  yb = ya + (c2_val) * line_yinc;
                  printf("3rd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
                  if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c2_col, thickness, segments_drawn, lco))
                  {
                     done = 1;
                     line_color_offset = color_span - lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}
*/

good method....




int check_and_draw(double x1, double y1, double line_length, double line_xinc, double line_yinc, double za, double zb, int col, float thickness, int &segments_drawn, int &lco)
{
   int debug_print = 0;
   char t[1024] = {0};
   sprintf(t, "\n");
   int skip = 0;
   int end_adj = 0;
   // these checks mean that the segment is entirely not on the line
   if (za > line_length) skip = 1; // za after line end
   if (zb < 0)           skip = 1; // zb before line start
   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (za < 0) // za is before line start
      {
         if (debug_print) sprintf(t, "start_adj\n");
         za = 0;
      }
      if (zb > line_length) // zb is after line end
      {
         lco = line_length - zb;
         if (debug_print) sprintf(t, "end_adj - lco:%d\n", lco);
         zb = line_length;
         end_adj = 1;
      }
      double xa = x1 + za * line_xinc; // convert to screen coordinates
      double ya = y1 + za * line_yinc;
      double xb = x1 + zb * line_xinc;
      double yb = y1 + zb * line_yinc;
      if (debug_print) printf("%s   drawn at za:%3.0f zb:%3.0f\n", t, za, zb);
      al_draw_line(xa, ya, xb, yb, mColor.pc[col], thickness);
      segments_drawn++;
   }
   return end_adj;
}

int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
   int debug_print = 0;

   if (debug_print) printf("\nmw_dl x1:%3.1f y1:%3.1f x2:%3.1f y2:%3.1f ", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion
   int segments_drawn = 0;

   int color_span = c0_val + c1_val + c2_val;
   if ((color_span < 1) || ((c1_col == 0) && (c2_col == 0))) al_draw_line(x1, y1, x2, y2, mColor.pc[c0_col], thickness);
   else
   {
      if (debug_print) printf("lco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span
      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_length = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_length != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         double line_xinc = line_xspan / line_length; // one unit of these are one unit of vector move
         double line_yinc = line_yspan / line_length;
         int section = 0;
         while (!done)
         {
            if (debug_print) printf("Section:%d\n", section);
            double section_z_start = ((section-1) * color_span) - line_color_offset;

            double za = section_z_start;   // start position for drawing 1st segment
            double zb = za + c0_val;
            if (debug_print) printf("1st segment za:%3.0f zb:%3.0f ", za, zb);
            if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = lco - c2_val - c1_val;
            }
            if (!done)
            {
               za = section_z_start + c0_val;   // start position for drawing 2nd segment
               zb = za + c1_val;
               if (debug_print) printf("2nd segment za:%3.0f zb:%3.0f ", za, zb);
               if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c1_col, thickness, segments_drawn, lco))
               {
                   done = 1;
                   line_color_offset = lco - c2_val;
               }
               if (!done)
               {
                  za = section_z_start + c0_val + c1_val;   // start position for drawing 3rd segment
                  zb = za + c2_val;
                  if (debug_print) printf("3rd segment za:%3.0f zb:%3.0f ", za, zb);
                  if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c2_col, thickness, segments_drawn, lco))
                  {
                      done = 1;
                      line_color_offset = lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}




add pop up menu to plot area or series legend to thin number of segments or change to solid color.
changing from a segmented line to solid only make a small change

show hide segments drawn and time taken..




amke y xais arrange customizable...

if axis slaved, make it so the plot_x1 follows master
gridlines and label are always anchored to plot

on slaves, don't show x axis legends



remove y scrollbar for active...

put dsync on bottom and make it the master

active on top

make a y axis label type for active

slave series legend...just copy x_axis_slave

thin out player active....done

make it so that you can still see series legend on slave and change things, but only master can change active...

make it so that number of points on series legend is optional....done
also plot time optional

hide and show series legend from main plot popup menu...done

main plot pop up menu..done


fix the double drawing nonsense on the scroll bars....

remove from draw because proc calls draw...
double shit is gone, but now I have no mouse cursors

they are fixed but the mouse over is done....

make nice colors match...done


make units from pointer data and stuff work nicely wit ha few new types



I have a bigger issue...

I cant quite figure out in what order to do all the things....

I have moved everything in the draw function....

but that is bad because sometimes I call that recursively when moving stuff...


I need to separate the draw from the input....

also what about the checking of variables??


lets start with the most obvious

draw_plot() and
process_mouse_on_plot() (which also draws on plot)

obviously the plot area has to be drawn first, then the stuff on top, or it will never be seen

I should merge these two....
and have a draw only option for when I have call to it recursively

void proc_plot_area(int draw_only)
{
   draw

   if ()!draw_only)

   proc mouse on graph

}


do the same with scrollbars

have one entry point and an option to draw only...

then have draw itself have an option to draw only

void mwGraph::y_axis_proc_scrollbar(void)
{
      int sb = y_axis_draw_scrollbar(0);

now I have one entry point:
mG[].proc_graph(void)

all it does is call:
draw_graph(int draw_only)

and that calls:

x_axis_get_size_and_arrange_pos();
y_axis_get_size_and_arrange_pos();
enforce_axis_limits();

al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color+224]); // erase plot background
al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color], 2); // frame plot

x_axis_draw();
y_axis_draw();


x_axis_proc_scrollbar(draw_only);
y_axis_proc_scrollbar(draw_only);

proc_plot_area(draw_only);

draw_title(0);
draw_series_legend();

this seems to work pretty good

can I refine it? yes I can...

void mwGraph::draw_graph(int draw_only)
{
   al_show_mouse_cursor(display);
   if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2))
      al_set_system_mouse_cursor(display, ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT);

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


it looks really good now....

make nice title and colors for bandwidth..done
make bandwidth have option for 2 graph (tx and rx)..done
make a way to slave y axis range also...done...

make units for all types look good...

y axis
tx = 1
rx = 2
dsync = 3
FPS = 4

done....


add reset all to plot menu

add resize slider in between graphs...done...added to bandwidth...

make is so when x_axis_slave, can't even slide x axis a little bit...done

make it so if y legend does not fit on screen, auto set to smaller font...


make a way to not draw x_axis labels and reclaim space....

I think I might need to properly separate gridline and labels
right now I kind of lump them together

I still want to draw them together, but the variable used to control whether tey are draw or not are overly complicated


this is what I have now:
int  x_axis_label_draw_on;
int  x_axis_label_font;
int  x_axis_label_draw_size;
int  x_axis_label_tick_size;
int  x_axis_label_text_size;
int  x_axis_label_text_draw;
int  x_axis_label_color;

change to:
int x_axis_grid_draw_on
int x_axis_grid_color
int x_axis_grid_labels_draw_on
int x_axis_grid_labels_font
int x_axis_grid_labels_color
int x_axis_grid_labels_draw_size
int x_axis_grid_labels_tick_size
int x_axis_grid_labels_text_size


this is done and it works way better

add one more...
int x_axis_grid_draw_to_top_of_other_graph...why bother...

removed the lock, unlock, auto button...

now clean up the y axis the same way...

old
int y_axis_label_draw_on;
int y_axis_label_font;
int y_axis_grid_label_draw_size;
int y_axis_label_tick_size;
int y_axis_label_text_size;
int y_axis_label_text_draw;
int y_axis_label_color;

new
int y_axis_grid_draw_on
int y_axis_grid_color
int y_axis_grid_label_draw_on
int y_axis_grid_label_font
int y_axis_grid_label_color
int y_axis_grid_label_draw_size
int y_axis_grid_label_tick_size
int y_axis_grid_label_text_size

fixed some weirdness in void mwGraph::y_axis_get_size_and_arrange_pos(void)
now it's much simpler

add reset to main menu...done...



add x_axis_top_graph_gridline...done...

now it matter in what order thing are drawn in
the graph that draws the gridlines, needs to be last or the other plots will overwrite them
also when thet are draw, they draw on top of everything else....
not sure if this was a good idea...removed....


how about the mouse position on any graph is sent to the others so they can show that x position on their graph too...

how will I go about linking them?

make a series number that they can share
if the mouse is diplaying a point, send that to all others in the same series

all others look for shared values when they don't have mouse...

each graph could have a

if graph does not have the mouse, they are listening
if graph does have the mouse, they sending


all I need to link is x_cursor_pos...

any of the linked ones can set all other linked ones...


code:
if mouse on plot, set x_cursor_pos on all others..
if mouse not on plot read x_cursor pos...

this could work...

vars

int linked_group_id;
double x_axis_cursor_pos;

ok fine, try it




x_axis_cursor_pos = -99999;

if mouse is on graph, but not on plot set all local and remote to dont show value

if mouse is not on graph at all, read and use value from local

if mouse is on plot, set local and send to all linked

have a common place to draw....



i need a function that you pass it only an x position
and you get:

0 = no data at that x point
1 = scaled y position at that point
2 = closest point (less tham threshold)

this is getting complicated....

i could have mutiple y matches for x at the destination

keep it simple...

do only the line....done

         else // show mouse position
         {
            col = 15;
            x = mI.mouse_x;
            y = mI.mouse_y;
            draw_point_data(x, y, mx1, my1, col, f3, -1);
         }
         if (linked_group_id)
         {
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = x;
         }


      } // end of mouse on plot area
      else // mouse not on plot area
      {
         if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2)) // not on plot, but on graph
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = 99999; // set all linked cursors to not valid

         if (x_axis_cursor_pos > -99998)
            al_draw_line(x_axis_cursor_pos, plot_y1, x_axis_cursor_pos, plot_y2, mColor.pc[15], 0); // draw if valid
      }



that is done...now add it to bandwidth graph...done....


test graph on weak clients...it seems really slow  can take up to 800ms to plot
in that case I could automatically reduce the x range....


is there anything else in the logs I could graph?




make a client sync graph from the clients point of view:
fps chase
dsysnc
ping
what log line am I basing this on?

the server only has data when the client sends stak but the client should have much more data than that...


it looks like the client only adjust timer when rxing stdf....

I thought it would happen more often...but what does it have to sync with?

I suppose we could use ping...

I want to do a ping vs dsync from the client's pov


there are three things on the client...

ping
sync target
acually sync

I think a graph of those might be insightful

where does it happen and what are the vars again??


in client_fast_packet_loop:
players1[active_local_player].ping = t2 - t0;
ping_array_add(players1[active_local_player].ping);
I should add a log entry for this...

then what?

void client_timer_adjust(void)
{
   int p = active_local_player;
   double dsync = players1[p].dsync - players1[p].client_chase_offset; // adjust for target offset
   double fps_adj = dsync * 100; // make the change bigger

   float fps_chase = frame_speed + fps_adj;
   if (fps_chase < 10) fps_chase = 10; // never let this go negative
   if (fps_chase > 70) fps_chase = 70;
   al_set_timer_speed(fps_timer, ( 1 / fps_chase));
   players1[p].client_chase_fps = fps_chase;
}




where is offset calculated...

in ping array add....

places for log inputs:
- stdf rx (dysnc, fps_chase) this is already done...
- add ping... (ping_curr, ping avg, offset)


add one in timer adjust....


36 tmaj // timer adjust
37 cpng // client ping


sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", dsync, players1[p].client_chase_offset, fps_chase);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(36, p, msg);

sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping, players1[p].ping_avg);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(37, p, msg);


OK I have some log lines, now lets make a graph....




I need a way to get value for y axis....


just throw a values and it will know how to print it...

i think I started one of those already....
char* mwGraph::y_axis_get_val_text(double val, int units)


dsync is huge at the start....how about we don't actually use it to set fps until after initial state is received and chase starts....




clean up the number formating stuff+...

int y_axis_type
set for different types

y_axis_type
y_axis_legend
y_axis_units
y_axis_divider

The name you give to legend, should not ever automatically change
however the units may depending on type...

at init:
set name, units name, divider,

now I only have types 1 and 2 that change units
they do that in enforce_axis_limits(5)


all the rest should be handled in:
char* mwGraph::y_axis_get_val_text(double val, int units)

this should not change units, just print formating

type 3 for all ms
type 4 for FPS

check where thet are all set...done...



now what else can I monitor??

on the server, late cdat dropped


d 3-1 30s 1c

e 3-1 at 15s 3-1 ic




why? on my latest test graph, do the 2 graphs not line up vertically?

im guessing something to do with enforce limits.....
can i disable it for x axis on slaves...
made it so that plot can start before data....
this broke scrollbars, now ends are past...
2 ways to fix...
adjust only scrollbar ends to b not past data max...
adjust data max be larger
add new variable data display max and min
set clip...

try set_clip...

also disable slaving of series legend tied to x axis slaving...done


make it so that you can see status of things in menu...
make the main menu do everything
like locking x and y axis and show status of locking...
Y axis: free move / locked / auto range
unlock/lock Y axis
set y ais auto range..

done and it looks way better...

can you also lock x axis?
autoscroll does not make sense for x axis, but lock would be nice so I could zoom and move y without moving x...

I don't think I need menus for scroll bars any more, comment out for now....

added this....

   // min, max, and range for min and max displayable range (used for limits on axis, instead of using data)
   double x_disp_min;
   double x_disp_max;
   double x_disp_rng;
   double y_disp_min;
   double y_disp_max;
   double y_disp_rng;


cleaned up the scroll bar code a lot...





am I drawing scroll bars twice?


proc_plot_area calls

x and y axis_draw
then draws plot

x and y axis_draw call grid and labels, legend and scroll bars
this seems like too much...

where are they arranged?

down the fucking rabbit hole!!

proc_graph -> draw_graph ->

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


this all works but seems overly complicated

gridlines and labels have always had to be drawn before plot...
well...I don't want to separate gridlines and labels...
but they need to be done after old plot is erased and before data is plotted...
make it a part of draw plot??

this is the way it is now:
void mwGraph::proc_plot_area(int draw_only)
{
   al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color+224]); // erase plot background
   al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color], 2);         // frame plot

   x_axis_draw();
   y_axis_draw();

   draw_plot_area();

I want to replace
   x_axis_draw();
   y_axis_draw();


with just the labels and gridlines

leaving legend and scroll bars for somehwere else...done...much better now...

bool mouse_on_graph;
bool mouse_on_scrollbar;

done...awesome!!

make x axis use get text...done


still have issues with labels, now the first one less than 0 does not show.....



I'm sure its my rounding function

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 =  nr + (in - tmp);
   if (nr2 < 0) nr2 -= nr; // hack because negatives were rounding too high
   printf("in:%f  nr:%f  nr2:%f\n", in, nr, nr2);
   return nr2;
}

what is it supposed to do?

round 'in' up to the nearest 'nr'

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 = (in - tmp) + nr;
   if (tmp < 0) nr2 -= nr; // hack because negatives were rounding too high
   //printf("in:% 5.1f  out:% 5.1f  tmp:% 3.1f\n", in, nr2, tmp);
   return nr2;
}
this is the fix....nice...
auto reduce legend font if too tall, also clip so it won't exceed graph..done for y and x
make x legend do name and units like y....done

make split bar invisible until mouse over...
remove top padding for graph....


20220110 1:11PM

graph is done....


put chase and ping into main log thing

make sure the other graphs still work nice

separate the load part of each graph
fail gracefully if no data found..


how to check for no data...


I could use
void mwGraph::calc_data_range(void)
yes...but need to set series first...done...

now do the same for bandwidth graph...


erased all the old graph stuff from z_logs.cpp...1500+ lines gone
now the entire z_logs.cpp is around 1500 lines...

made it very easy to load graphs....

from log file viewer:
log_bandwidth_graph(int num_lines, int both);
log_client_server_sync_graph(int num_lines);
log_ping_graph(int num_lines);

from anywhere else:
log_bandwidth_graph(load_log_lines_array_from_static_file("logs/a.txt"), 0);
log_client_server_sync_graph(load_log_lines_array_from_static_file("logs/a.txt"));
log_ping_graph(load_log_lines_array_from_static_file("logs/e.txt"));

I use this function in 4 places:
int load_log_lines_array_from_static_file(const char* f));
it loads:
extern char log_lines[NUM_LOG_LINES][100]; // for log file viewer
extern int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer

this makes things much simpler...



now clean up the other 2 graphs:

bandwidth
make nice splitter
why no x gridlines on upper
done...

client sync...looks good...

now the only thing left is the three way splitter...done

bug... when x axis is locked, disable x scroll bar...done....

we are way further along now.....

can I call the graph thing done? yes...

now what?

log:
when the server gets late cdats?
the current s1 and s2 values on the server...
when clients base is reset

how about some code profiling...

draw_time
move time
decompress time

I am going to make the busiest level I can imagine...

how do I get the default menu back on level editor after I come back...done...

bug on graph.. y axis scroll bars draw off their range. it was a bug I inadvertantly introduced when making type 3 for active...fixed...



what do I have for my timer thing...

I have 10,000 of these

struct timestamp
{
   int frame0;
   int frame1;
   int frame2;
   int type;
   double t0;
   double t1;
   double t2;
};


how was i supposed to use them?

void add_timestamp(int type, int f1, int f2, double t1, double t2)
{
   if (timestamps_index < 9998)
   {
      timestamps[timestamps_index].frame0 = mwPS.frame_num;
      timestamps[timestamps_index].frame1 = f1;
      timestamps[timestamps_index].frame2 = f2;
      timestamps[timestamps_index].type   = type;
      timestamps[timestamps_index].t0     = al_get_time();
      timestamps[timestamps_index].t1     = t1;
      timestamps[timestamps_index].t2     = t2;

      timestamps_index++;
   }
}

            add_timestamp(1, 0,0,0,0);
            timestamp_frame_start = al_get_time();

            proc_timer_adjust();

            proc_scale_factor_change();

            if (ima_server) server_control();
            if (ima_client) client_control();

            proc_player_input();
            proc_game_moves_array();

            if (players[0].level_done_mode) proc_level_done_mode();
            else
            {
               //add_timestamp(5, 0,0,0,0);
               move_frame(0);
               //add_timestamp(6, 0,0,0,0);
            }

            if (players1[0].server_send_dif) server_send_stdf();



//            if (get_delta(mwPS.frame_num,   3, mwPS.frame_num,   4, res)) printf("time in draw: %5.1f us\n", res*1000000);
//            if (get_delta(mwPS.frame_num,   1, mwPS.frame_num,   2, res)) printf("time in move: %5.1f us\n", res*1000000);
//
//            if (get_delta(mwPS.frame_num-2, 1, mwPS.frame_num-1, 1, res)) printf("total fram time: %5.1f us\n", res*1000000);




now that I have the mwPS.frame_num inc at the very start of every frame it should make timing easier.


I don't know why I have multiple frame numbers in the structure

most of the time I just use the current frame number and the current timestamp


so lets do it...

take some times and plot them...

I want to have a log entry every frame

how many timestamps per frame?

lets say 10, that would give me 1000 frames or 250s or just over 4 min...

that's a good start

time for a new log entry...44

holy shit that was fast!
I got some profile timestamps, made a new log entry and made a dual graph to view them both: draw time and move time
It only took about 1H to do all that, because of all the framework I have in place...nice...

I can't wait to profile more things....

but I am going to do a push, then get a hot drink...

20230110 10:15PM


do a timer for server send stdf
one for each client...or all together?

they will all be on the same frame, but with different player numbers

I can probably do this one in line, without the timer struct...

use tag 45...

more data...like was the base reset? how many packets...

[45][1][169]tmst [1.368000] [0] [835] [1]
[45][1][172]tmst [1.355800] [0] [792] [1]
[45][1][175]tmst [1.369900] [0] [800] [1]
[45][1][178]tmst [1.347400] [0] [704] [1]
[45][1][181]tmst [1.367600] [0] [804] [1]
[45][1][184]tmst [1.369800] [0] [799] [1]

I could plot all these on the same graph if /1000 for 3...do it...

20230111 7:41AM


I want to make a different, easier way to get these profiling timestamps into a graph..


Maybe I could tag each one like td:[] tm:[] stdf:[]

then I will need a tag reader than can get the text before...

I can have multiple log file lines that all have the code 45 tmst

they can all go on the same graph beacuse they all have the same units

I have the very basic framwork in place....


I want to make a new gui element.
I will act exactly like button toggle but will look different
[] - name


I have the logging options page looking really good...
what other pages?

sound, color, splash screen

controllers

netgame options

make multiple tabbed pages...

this should be fun

in the end it will be so much easier to add new options, so many more that I have not even thought about....

make it look good...


I think I have all the functionality for controls except for set indivual

now I need to make it look good..


make the list of keys more centered but still left justified
add a button to the left of each key, 'new' which prompts to set that one control

I want my own function to redraw all keys....done...

what is the maxiumun text length of key_names[]? 11 PRINTSCREEN
make it so that this displays nicely....
press new control is 17....

page for controllers is setup and looks great!!

next, nextgame??
all the controls are in place and working...now make it look good...


display server name and give a text description

Server Name: ....

Clients must have the server name or IP address set here.


OK...config page for netgame is done...


This is looking very nice...how are you going to patch it into the game_menu?
I think I should have an overall larger background and title:

Like 'Configuration'

make it a fixed width of 400,400


do I need a large size for the frame, tabs, and title??

Yes, obviosly....

OK what am I going to name them?

Do I have an actual minimun size for the useable pages?

can I go up from there??

sure why not?

add tab height and title height

that should do it...


I don't know where am going to patch it into the menu...
it seems like it is already pretty busy...

put it on the options menu for now and have a hotkey to bring it up any time from any menu....ok...
CTRL SHIFT O


i like it....

when it gets full I will need to have a second row of tabs...


I have changed my mind...


I want to start with the full outer size and then shrink it as I move in...

what are my varaible going to be called?


this is all I have for now:



   int cfp_x1 = 200;
   int cfp_y1 = 200;
   int cfp_x2 = 600;
   int cfp_y2 = 600;
   int cfp_txc = cfp_x1 + (cfp_x2 - cfp_x1) / 2;



I think I will keep these vars...

entire thing:
cf_x1
cf_w
cf_x2
cf_y1
cf_y2
cf_h

then I will figure out the borders, tab height, title height, and then finally set:

cfp_x1
cfp_w
cfp_x2
cfp_y1
cfp_y2
cfp_h

for the display area of the pages


goddamn this looksg good...


what else can I add?

sound
color
splash screen


today:
finish basic page..done
make advanced page
add help buttons to pages...
think about re-arranging menus to make simpler

do I have enough tabs??..yes


what wil go on advanced?
speed
disable timed demo mode...
show hysteris box...

what is left on the options menu that I don't have in config pages?

   strcpy (global_string[8][3], "Netgame Options");
   strcpy (global_string[8][4], "<-Change Color->");
   strcpy (global_string[8][5], "Controller Setup");
   strcpy (global_string[8][6], "Speed:40fps");
   strcpy (global_string[8][7], "Sound:Off");
   strcpy (global_string[8][8], "Sound Effects Volume:9");
   strcpy (global_string[8][9], "Sound Track Volume:9");
   strcpy (global_string[8][10], "Logging Options");
   strcpy (global_string[8][11], "Splash Screen:ON");
   strcpy (global_string[8][12], "Save Demo");
   strcpy (global_string[8][13], "Run Demo");
   strcpy (global_string[8][14], "Configuration Pages");
   strcpy (global_string[8][15], "end");

speed
save demo
run demo

I could have a tab just for demo...
run
save
disable timed demo
options for auto save

yes, do this...then options menu can go away totally and be replaced with config pages on main menu....

Maybe it could be renamed to 'Settings'...that seems more generic and apt and standard...done

here is the thing...

running demo from these pages is not as simple as just calling a function...

we are in menu, then in config, how to get back to where the game runs??

we have to:
- set next program mode
- quit config
- quit zmenu


I guess this all depends on where config_pages is called from...

lets make sure it is always called from zmenu...
then we can figure out how to handle return...
called from:
args
zmenu CTRL O
game_menu options 14

for now just do CTRL O

if I can make config pages return something...

maybe the zmenu was not better choice..another layer deep...

make the CTRL O call option 14 then deal with it there for now in game menu

maybe I am doing this wrong...maybe config pages ahould be another program_state

something that I can return to, like command line and zmenu

that seem a little less hacky...

from menu, leave menu and do configpages..from there do run games...

   if (program_state == 3) config_pages();  // this blocks


ok it gets there, but how does it get back??

replace OPTIONS MENU with SETTING and then it will come back there...


coming back from playing demo does not come back to config, it come back to menu...why??


it seems like a lot of things set old_program_state...too many


like for instance it is set when rungame_key_check exits...it is set to 1...why?  how does it know what called it?

where are the places it should be set?


0 when delared
then if called from command line it will know where to go

1 when starting game_menu

2 when starting demo mode

3 when starting config...

those are the only places it should be set....

it is used when leaving a running game to determine where to go back to....




This is what actually is in place:

int old_program_state = 1;

when game_menu() starts
old_program_state = 1;



when demo_mode loads a level and plays it
new_program_state = 14;
old_program_state = 2;

if demo mode fails to load level
new_program_state = 1;
old_program_state = 1;


when config starts rungame
new_program_state = 14;
old_program_state = 3;

when config ends with ESC
new_program_state = 1;
old_program_state = 1;

rungame_key_check
new_program_state = 1;
does not set old....


OK this is looking a little better...


start game, start config, rungame from file...

exit with any key..goes back to config...good

exit with ESC key..skips past config to menu...fix this
added this in rungame_key_check to eat ESC
while (mI.key[ALLEGRO_KEY_ESCAPE][0]) proc_controllers();

now it does stimp and goes back to config....
from there you can run another file...

this all works great...

but when you leave config for menu, stimp is called again...
happens every time config to menu....fixed
if (program_state != 3) stamp();


that was the last thing from options menu...time to retire it....

and at the same time...call it settings...
settings_pages


top_men_sel == 7 // settings

CTRL SHIFT O from zmenu as a shortcut

commented out all option menu stuff in game menu

returns to setting selection when leaving config..

wow! all of this works so good...

I will miss wacthing the title screen change immediatley when changing player color....


should I alway have that background behind settings_pages?yes
the only other possible thing would be a partially played demo level....
do it...
call frame and title and make sure settings is centered also....done...

you know what would be amazing?
If I could center the title 'Settings' on the menu item 'Settings'
how do I know where that is?
set_map_vars()
done....
now can I show the menu text only....done

now hide the mouse when leaving settings..done

rename...done...

now make that goddamn demo_mode time able to be disabled



what variables?


demo_mode_countdown_val;
demo_mode_countdown_reset;

demo_mode_enabled

int demo_mode_enabled = 1; when declared

then set to zero:
if resume allowed
if any menu key is moved
if demo mode times out and starts


i suppose I could read this value from config file

default it to 1 and if player turns it off in config...

the problem is...any time config file is read, it gets turned back on...

make a separate config file varibale and only use it to set the global one once at startup..

this is getting confusing!!

demo_mode_config_enable

extern int demo_mode_config_enable;
now use it in initial_setup() to set  demo_mode_enabled
this is all done!!!

next, demo mode....
when trying to exit, it quits the current level and immediately plays next....

in rungame_key_check:

      new_program_state = 1;
      if (old_program_state == 2) old_program_state = 1; // don't send back to demo mode if cancelled

this seems to have fixed it....



now, does it work from settings....yes, but it comes back to menu, not settings...big deal....
when demo mode starts it sets old_program_state to 2..in this way we do not know what started demo mode
it could be menu or settings

do I want yet another variable to track this?
some humor 'older_program_state'

used only when starting demo mode
3 from settings
1 from menu

then when demo mode is cancelled from rungame_key_check it can set the appropriate place to return to...

new_program_state = 1;
if (old_program_state == 2) old_program_state = older_program_state; // don't send back to demo mode

done and it works perfectly....

now to make demo tab look nicer.. looking pretty good!!!


now how many things call zmenu? only one: top
old ones:
options
logging
netgame
controller



put speed on advanced tab...done

also by default make the speed locked, disabling function key
also speed is never saved to config file

add DEMO MODE overlay transparency option to demo tab...and config file...done

add other hysteris mode stuff somewhere


now that I have everything from option menu on the settings page....

I have so many more things I want to put there....

but first...

lets see what it would take to get more tabs....

and a second row....

maybe an optional second row...

erased options menu...now game menu is <70 lines

going through code and removing unneeded references to global_string....


why don;t I make a struct for each tab...then make an array of structs
done and its looking good...



I want to see how hard it is to draw a filled polygon with allegro primitives....

float v[4][2] = {0};

v[0][0] = 100;
v[0][1] = 100;

v[1][0] = 100;
v[1][1] = 200;

v[2][0] = 200;
v[2][1] = 200;

v[3][0] = 200;
v[3][1] = 100;

al_draw_filled_polygon(*v, 4, mColor.pc[14]);

this is all it takes....

now use that to draw tabs....done...

that looks so much better...


now what?

rename the logging netplay things and add more....


now I have game_menu down to 25 lines!!!

// z_game_menu.cpp
#include "pm.h"
void game_menu(void)
{
   old_program_state = 1;
   if (!splash_screen_done) { splash_screen(); splash_screen_done = 1; }
   if (!resume_allowed) load_level(start_level, 0);
   if (top_menu_sel < 3) top_menu_sel = 3;
   while (top_menu_sel != 1)
   {
      top_menu_sel = zmenu(7, top_menu_sel, 10);
      if  (top_menu_sel == 1)  { program_state = 0;                                           return; } // exit
      if  (top_menu_sel == 2)  { visual_level_select(); top_menu_sel = 3;                             } // visual level select
      if ((top_menu_sel == 4) && (resume_allowed)) { new_program_state = 13;                  return; } // resume game
      if  (top_menu_sel == 3)  { new_program_state = 10;  top_menu_sel = 4;                   return; } // start new game
      if  (top_menu_sel == 5)  { new_program_state = 20;                                      return; } // host network game
      if  (top_menu_sel == 6)  { new_program_state = 24;                                      return; } // join network game
      if  (top_menu_sel == 7)  { new_program_state = 3;                                       return; } // settings
      if  (top_menu_sel == 8)  { play_level = edit_menu(start_level); new_program_state = 10; return; } // level editor
      if  (top_menu_sel == 9)  { new_program_state = 2;  older_program_state = 1;             return; } // demo mode
      if  (top_menu_sel == 10)                                                                help(""); // help
      if (top_menu_sel == 102) if (++start_level > 399) start_level = 399; // start level inc
      if (top_menu_sel == 202) if (--start_level < 1) start_level = 1;     // start level dec
      if (top_menu_sel > 100) { set_start_level(start_level); load_level(start_level, 0); top_menu_sel = 2; }
   }
}



these are the config names:
LOGGING_NETPLAY);
LOGGING_NETPLAY_JOIN);
LOGGING_NETPLAY_PLAYER_ARRAY);
LOGGING_NETPLAY_bandwidth);
LOGGING_NETPLAY_cdat);
LOGGING_NETPLAY_game_move);
LOGGING_NETPLAY_sdat);
LOGGING_NETPLAY_sdak);
LOGGING_NETPLAY_stdf);
LOGGING_NETPLAY_stdf_all_packets);
LOGGING_NETPLAY_stdf_when_to_apply);
LOGGING_NETPLAY_show_dif1);
LOGGING_NETPLAY_show_dif2);


extern int L_LOGGING_NETPLAY;
extern int L_LOGGING_NETPLAY_JOIN;
extern int L_LOGGING_NETPLAY_PLAYER_ARRAY;
extern int L_LOGGING_NETPLAY_bandwidth;
extern int L_LOGGING_NETPLAY_cdat;
extern int L_LOGGING_NETPLAY_game_move;
extern int L_LOGGING_NETPLAY_sdat;
extern int L_LOGGING_NETPLAY_sdak;
extern int L_LOGGING_NETPLAY_stdf;
extern int L_LOGGING_NETPLAY_stdf_all_packets;
extern int L_LOGGING_NETPLAY_stdf_when_to_apply;
extern int L_LOGGING_NETPLAY_show_dif1;
extern int L_LOGGING_NETPLAY_show_dif2;


I want to make this simpler:

variables:
LOG_NET_xxx

config
CLOG_NET

and make them all lower case after the _

replace:

L_LOGGING_NETPLAY_
LOG_NET_

do it: 75 replaced  still compiles


now replace
LOGGING_NETPLAY
CLOG

wait why??
they can have the exact same name, i do it all the time in config..same variable name and config name
OK

replace
LOGGING_NETPLAY
LOG_NET

OK done.. now do lower case for JOIN and PLAYER_ARRAY

ok that's all done too:

demo mode is not on by default...fixed...


keep a list in to do of other things to add to settings....


many of them will require:
- making a global variable
- saving it in config
- making a way to change it in settings

how about 'send stat to console'

made a lot of those....




what do I call the hyst thing?
lakitu
viewport

lets go with viewport

do a global for viewport_type

0 = force to be in the center of the screen all the time, except when near edges of course...
1 = regular hysteresis
2 = slowly changing hysteresis

added these globals:

int viewport_mode = 1;
int viewport_show_hyst = 0;
int viewport_x_div = 8;
int viewport_y_div = 12;


20230213 6:24AM Friday the 13th
I have taken the entire week off work so far, I probably will take today also...
I have gotten a lot done...
what are some of my next plans?

make links to graphs??? from settings..and log_file_viewer..done




settings - add more stuff
program state - clean up and make simpler
see if I can make level done part of program state...




add timers and LOG_TMR tags for the packets related...

how many do I want?

move
draw
stdf send (server only)
dif unpack (client only)
rewind time (client or server)

LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd
first of all, make these global variables, then save in config, then add toggle in setting...all done
now just patch them into the code where log entries are entered...





make options on logs to never save log files....
I am so annoyed when shit gets saved and I dont want it to....


i am thinking of 2 different types of timestamps


one would be used to profile sections of code...

like move, draw, stdf etc....


each will have a tag like

tmst move:[]


then my tagging system will find them all and apply the label to the series.....

I will have as many or as few as I want, and when I run the graph it will automatically show the ones present

the other type of timestamp would show things in relation to frame start...I can think about that later....

I am excited to do this one....

use these to start:
LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd

I want to make global double t0 just to make the code look cleaner


now make a graph....

looking good....

make a us y axis type....already done, but store data as ms...al_get_time * 1000 print wih %0.4f


looking good...

now make this graph so it can be called with its own file select....


then put it on a button in settings....

this looks awesome....

how about saving log when coming back to menu or config, instead of having to quit game..

options:

save log on program exit
save log on game quit
save log on level done
save log manually only
save log now

do it...




I redid all of the config with macro's..
it took a while but it is so much shorter and easier
to do a config value, i need 1 set and one get, before I need 3 for get and 2 for set
I should really test each one to make sure they are working....
erase config file and see!!
looks good...
color does not stick...fixed...


in program_mode 12 - level done

added: if (autosave_log_on_level_done) save_log_file();

this was here:
blind_save_game_moves(1) - level done

this checks to see if autosave is on and labels the save file accordingly...
I guess this is OK

what else calls blind save??


blind_save_game_moves(2) - game_exit
at the end of main...we should change this to when leaving running game...that seems much more useful...

blind_save_game_moves(3) - bad exit

fast_exit and

void function_key_check(void)
{
   if (mI.key[ALLEGRO_KEY_F4][3])
   {
      blind_save_game_moves(3);
      save_log_file();



-----------

log files for now...

put checks for program exit in fast exit and end of main....done...

look for occurances of save_log_file...good

now just find an entry point for leaving a running game...


resume_allowed...no...

when leaving program_mode 11 to 1 or 3

done...




I think all cases ahould be covered now...

occ of blind_save_game_moves();

blind_save_game_moves(3); F4         only if game_exit set
blind_save_game_moves(3); fast exit  only if game_exit set
blind_save_game_moves(2); game quit  only if game_exit set
blind_save_game_moves(1); level done only if level done set

occ of save_log_file()
F4           only if program exit set
fast exit    only if program exit set
end of main  only if program exit set
game quit    only if game_exit set
level done   only if level done set

looking good....





lets try some log tmr and view on graph...nice....

tmst back:[0.0060] lifts:[0.0207] items:[0.5058] enem:[0.0101] ebul:[0.0001] pbul:[0.0001] play:[0.0035] buff:[0.0111] ovrl:[0.1171] flip:[0.1415]
tmst back:[0.0053] lifts:[0.0197] items:[0.5073] enem:[0.0097] ebul:[0.0001] pbul:[0.0002] play:[0.0033] buff:[0.0112] ovrl:[0.1181] flip:[0.1382]
tmst back:[0.0060] lifts:[0.0206] items:[0.5062] enem:[0.0096] ebul:[0.0002] pbul:[0.0001] play:[0.0034] buff:[0.0108] ovrl:[0.1169] flip:[0.1311]

its 150 char

lets log it...



20230114 8:44 AM

working on timestamp logging today....at least for now...

have move and draw done
total and all individual..

now work on graph and pop up values...
show series and accurate units

units done
series name done


I have this stupid bug that is annoying me....

I have text drawing routines I have made that can take either 'font' pristine or 'f3' pixel gosub

I have been making good use of:
al_get_text_dimensions(f3, text, &bx, &by, &bw, &bh);

I have no problems with the width but the bh and by sometimes do strange things...

mostly by

I want to do some experiment with these fonts to see if I can make a solution

I just want my text to line up consistantly

what is the character range?

pristine 32-127
pixel_gosub 32-127


what is the max and min for bx, by, bw, bh


the built in font has all 0 0 8 8...nice

how did stuff not break when I changed to pristine??
why does it still draw with 8 8 like the old one....




int al_get_font_line_height(const ALLEGRO_FONT *f)

font and font0 are 8
f3 is 9??? WTF

looking into it: almost everything I care about in f3 is 5 high
exceptions:
Q - 6
{} () | $ are 7

also all the ones that are bh5 are also by4...this would cover 99% of what I do with them....


so to make some code common.....

do not use al_get_text_dimensions for height...
you can us it for width, that seems to be fine

have my own custom get text_height thing...
for font or font0, always return 0 8
for f3 always return -4 5

void mw_get_text_height(ALLEGRO_FONT *f, int by, int bw)
{
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

this is just craxy enough to work!

what can I do to test it?

make an example that shows the problem...


function that you send a char, font, color, x, y and it prints that in a nice bounding box with 1 pixel border.
then test that funtion with various fonts and text strings....

I think I got it!

2 steps:
- use my function to get text dimensions
- use bx and by when drawing text
this seems to work for all cases

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

void draw_text_in_box(const char* txt, ALLEGRO_FONT *f, int x, int y, int color, int type)
{
   int bx, by, bw, bh;

   if (type == 0) // the regular method
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2, y+2, 0, txt);
   }
   if (type == 1) // use bx, by to offset text
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2-bx, y+2-by, 0, txt);
   }

   if (type == 2) // use my method to force by offset and bh size
   {
      mw_get_text_dimensions(f, txt, bx, by, bw, bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2-bx, y+2-by, 0, txt);
   }
}


void temp_test(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(mColor.pc[0]);

   ALLEGRO_FONT *f = font;

   for (int j=0; j<3; j++)
      for (int i=0; i<3; i++)
      {
         if (i == 0) f = font;
         if (i == 1) f = font0;
         if (i == 2) f = f3;

         draw_text_in_box("Hellg", f, 100, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("Hello", f, 150, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("emmem", f, 200, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("e{3}",  f, 250, 100 + i*20 + j*100, 10, j);
      }
}


lets try it out...

where to put my function...in z_fnx...

fixed draw point...perfect...

now lets go through graph, and fix all.....

basically just search for al_get_text_dimensions

make series legend text x + 1
what if I load that font with no kerning???


it is loaded with no kerning...

force bx for that font?? yes...and bw...remember, this font is suppose to be 8x8

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
    // first get from the allegro method
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);

   // then override for my nefarious purposes!
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; bx = 0; bw = 8*strlen(txt); }
   if (f == font0) { by = 0; bh = 8; }
}


done all the mw_get_text_dimensions in mwGraph....

I should add some code to see if labels are touching each other because they are too close...
try x axis first....i have it working....
labels can only be powers of 10....that is fine...
what would the whole thing look like if I used this to set major instaed of bewyeen 2 and 20...gave up...

oh this is done...

now what the hell was I doing before?

just added move profiling...


better auto colors in graph...
make a function to set colors...just skip 0....done....

now fix the goddam 2 line drawing bug....done...

take a break and come back for more....


now I want to go inside the move enemy and break down individual types..same with draw....


Hysterisis window following player
lots of options there

can I make the hyst div number make more sense?

its a fraction of screen size...

2 is max

how about 1/num * 2 that was 1 will be widest

20 min 1/20 * 2 == .1

save as float from 0.01 to 1

when using it do 1/num and divide by 2....

i use it to divide SCREEN_W and H so now I can just muliply instead...done...

this settings page works, but could use some polish






make a header of mwGraph and move header there


what have you done?

made z_mwGraph.h

put the class declaration there
and at the end of the class declaration:
extern mwGraph mG[10];



// z_mwGraph.cpp
#include "pm.h"
#include "z_mwGraph.h"
mwGraph mG[10];


then the only other source file that needed access was z_log.cpp and all I had to do was add
// zlog.cpp
#include "pm.h"
#include "z_mwGraph.h"


wow, that was easy...

z_mwGraph.h 250 lines
z_mwGraph.cpp 1850 lines

viewport page on settings completely done....

zoom is not saved...well it is, but when getting loaded it always loads 1...
I should make sure of that then remove it from config file...not yet, just disabled and forced to 1.0 instant on load

Disable speed settings including function keys
Speed testing abilites.

is speed save to config file? no and I don't think it should be
I do want a variable to unlock speed changes though...

int speed_control_lock = 1;


done...


I have all the stuff in place for display trandform double, just need to make it look nice...


20230114 9:45PM...push



I don't think I can profile the individual enemies and items as easy....

so what else can I do...





20230115 11:11

so this morning I chose to do something completely different...
something meta....

source code stats!!!

Purple Martians Source Code Line Counts [2023-01-15  11:11:11]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[  2378][  1597][  1387][   385][   175][   210][   606] - z_log.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
--------------------------------------------------------
[ 46138][ 33787][ 28655][  8526][  3394][  5132][  8957] - Total





Purple Martians Source Code Line Counts [2023-01-15  11:27:00]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2435][  1623][  1411][   388][   176][   212][   636] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
--------------------------------------------------------
[ 46195][ 33813][ 28679][  8529][  3395][  5134][  8987] - Total


sorted by code size



why the fuck do I still have z_map.cpp??


// zmap.cpp

#include "pm.h"

void set_map_position()
{

//  1   9   2
//      |
// -----+-----
//      |
//  4   |   3

   int alp = active_local_player;

   int px1 = players1[alp].sbx1;
   int py1 = players1[alp].sby1;
   int px2 = players1[alp].sbx2;
   int py2 = players1[alp].sby2;

//   printf("gmo:%d mx:%d my:%d px1:%d py1:%d px2:%d py2:%d\n",game_map_on, map_x, map_y, px1, py1, px2, py2);
   switch (game_map_on)
   {
      case 0:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
      break;
      case 1:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         // check to see if player is covered by the map
         if ((px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 2;
      break;
      case 2:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (py1 < map_y + map_size))  game_map_on = 1;
      break;
      case 3:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px2 > map_x)
          && (py2 > map_y))  game_map_on = 4;
      break;
      case 4:
         map_x = BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px1 < map_x + map_size)
          && (py2 > map_y))  game_map_on = 3;
      break;
      case 9:
         map_x = SCREEN_W/2 - map_size/2;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 4;
      break;
   }
}

void next_map_mode()
{
   int old_game_map_on = game_map_on;
   switch (game_map_on)
   {
      case 0: game_map_on = 1; break;
      case 1: game_map_on = 2; break;
      case 2: game_map_on = 3; break;
      case 3: game_map_on = 4; break;
      case 4: game_map_on = 9; break;
      case 9: game_map_on = 0; break;
   }
   set_map_position();
   if (old_game_map_on == game_map_on) game_map_on = 0;
}

void next_map_size()
{
   int smin = 0;
   if (SCREEN_H < SCREEN_W) smin = SCREEN_H;
   else smin = SCREEN_W;

   if (new_size == smin /4) new_size = smin/3; // 1/3
   else if (new_size == smin /3) new_size = smin/2; // 1/2
   else if (new_size == smin /2) new_size = smin/4; // 1/4
   else  new_size = smin /3; // if for some reason none of these match
}

void draw_map()
{
   if (game_map_on)
   {
      // process the size change gradually
      if (map_size < new_size)
      {
         map_size+=30;
         if (map_size > new_size) map_size = new_size;
      }
      if (map_size > new_size)
      {
         map_size-=60;
         if (map_size < new_size) map_size = new_size;
      }
      set_map_position();
      al_draw_scaled_bitmap(level_buffer, 0,0, 2000, 2000, map_x, map_y, map_size, map_size, 0);
   }
}

kill it!!!

a few more tweaks then I am done....

Purple Martians Source Code Line Counts [2023-01-15  11:41:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2404][  1620][  1405][   391][   176][   215][   608] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
-------------------------------------------------------- - totals
[ 46055][ 33720][ 28587][  8519][  3386][  5133][  8949] - 44 files

done!!!!...

just for comparison, what does code blocks say?

47 files
45856 - total
26651 - code only
 4834 - code and comment
 8899 - blank
 5472 - comment

manually add
26651 - code only
 4834 - code and comment
-------
31485

what files does it get that I don't




got to move on.....






make sure all logging entries throughtout the code have appropriate if statements
list them...


extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_game_move;
extern int LOG_NET_sdat;
extern int LOG_NET_sdak;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_show_dif1;
extern int LOG_NET_show_dif2;

--------------------------------------------------------
LOG_NET [10]
--------------------------------------------------------

8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()


6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()


1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()




   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }


   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }


   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }



1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL

server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked



--------------------------------------------------------
LOG_NET_player_array [26]
--------------------------------------------------------
1 x server_control() [26]

--------------------------------------------------------
LOG_NET_bandwidth [23][24]
--------------------------------------------------------
1 x process_bandwidth_counters() [23][24]

--------------------------------------------------------
LOG_NET_cdat [35]
--------------------------------------------------------
1 x server_proc_cdat_packet() [35]
1 x proc_player_input() // when client sends cdat [35]

--------------------------------------------------------
LOG_NET_game_move
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdat
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdak
--------------------------------------------------------
not used


--------------------------------------------------------
LOG_NET_stdf
--------------------------------------------------------
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]
1 x client_process_stdf_packet() dif decompressed [27]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]
1 x server_proc_stak_packet() [30]

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   //---------------------------------------
   // server new game
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }



--------------------------------------------------------
LOG_NET_stdf_all_packets
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received [28]
1 x server_send_stdf() // when sending an individual stdf packets to a client [28]


1 x client_timer_adjust() [36]
   sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", players1[p].dsync*1000, players1[p].client_chase_offset*1000, fps_chase);
   if (LOG_NET_stdf_all_packets) add_log_entry2(36, p, msg);

1 x ping_array_add() [37]
   sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping*1000, players1[p].ping_avg*1000);
   if (LOG_NET_stdf_all_packets) add_log_entry2(37, p, msg);

--------------------------------------------------------
LOG_NET_stdf_when_to_apply
--------------------------------------------------------
1 x client_apply_diff() [29]
   sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);



--------------------------------------------------------
LOG_NET_show_dif1
--------------------------------------------------------
all in fnx

--------------------------------------------------------
LOG_NET_show_dif2
--------------------------------------------------------
all in fnx

void show_state_dif(char *a, char *b) 430 lines..has not been used in a while....

maybe its time for all that to go away.....gone...now remove the LOG_NET...done...


what about the ping... what is it used for??
is it only for ping_graph?

Make this list also show the log entry type number....
also removed game_move, sdat, sdak...











---------------------------------------------------------------------------------
-------------   The official list of how logging works: -------------------------
---------------------------------------------------------------------------------
extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_client_ping;
extern int LOG_NET_client_timer_adj;
extern int LOG_NET_server_rx_stak;

--------------------------------------------------------
LOG_NET [10] [both]
--------------------------------------------------------
8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()

6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()

1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()

   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11] [both]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL
server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked

--------------------------------------------------------
LOG_NET_player_array [26] [server]
--------------------------------------------------------
1 x server_control()

--------------------------------------------------------
LOG_NET_bandwidth [23][24] [both]
--------------------------------------------------------
1 x process_bandwidth_counters()

--------------------------------------------------------
LOG_NET_cdat [35] [both]
--------------------------------------------------------
1 x server_proc_cdat_packet()
1 x proc_player_input()

--------------------------------------------------------
LOG_NET_stdf [27][29] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() dif received and decompressed [27]
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]

   //---------------------------------------
   // 12 - level done [27]
   //---------------------------------------
   //---------------------------------------
   // server new game [27]
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }

--------------------------------------------------------
LOG_NET_stdf_all_packets [28] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received
1 x server_send_stdf() // when sending an individual stdf packets to a client

--------------------------------------------------------
LOG_NET_stdf_when_to_apply [29] [client]
--------------------------------------------------------
1 x client_apply_diff()

--------------------------------------------------------
LOG_NET_client_timer_adj [36] [client]
--------------------------------------------------------
1 x client_timer_adjust()

--------------------------------------------------------
LOG_NET_client_ping [37] [client]
--------------------------------------------------------
1 x ping_array_add()

--------------------------------------------------------
LOG_NET_server_rx_stak [30] [server]
--------------------------------------------------------
1 x server_proc_stak_packet() [30]


the only area that I still am not sure about is 27 and 29 for stdf...
a lot of these things all fall under the stdf blanket...
but it would be nice to have the option of not filling the log with unneeded stuff...

what is the point of logging that dif was received if I don't say if it was successfully appllied?



here is what I would like to see in great detail:

1 - server decides to make new dif (this is when the base it uses comes due)

2 - server rewinds to previous saved state

3 - server plays back a set number of frames (and applies all late input)

4 - server saves a new state

5 - server plays a set number of states to get back to where it was originally

6 - server set a flag to send stdf

7 - goes back into the game loop and continues the current frame (processes input, moves frame, draws frame, then sends stdf to clients)

why the delay here? why can't I send it sooner?
I am already delayed by having to rewind and make a new state....
Nothing in the state I am sending will change by playing this current loop....

The way I am doing it now is waiting for the worst possible time to do that.

I have waited for the timer to fire, then I send based on the old state
I don't even get fresh input...

What I think I should do is: (server only)

play the frame to the end (draw also?) ...no... everything but draw
get all the input
process all the client packets
move the frame...

then...before draw...do the server thing if needed....

rewind, make new state, apply lost stuff (you realize this means you will replay the frame you just played...???)

then send the stdf, then draw...


I just had a thought...what if all I do is send the stdf before I draw?

would that have the same effect??

also if I could process all client input before I make the dif that should be good also....



one at a time....
on the server, when do I process cdats.....
right at the top of the frame...I cannot make that any sooner...

second...
I already send the stdf before draw...

you were saying.....

what about when the client sends pings....literally at the end of the game_loop right before the free time....

could I be rewinding and replaying in the background?...idk

i think it is time for some tests....

ping graph needs 36 and 37 tmaj and ping




show in debug overlay, how much time it took to process the last frame
basically how much free time....
as a percentage...

50% means it took 20ms...

done...


do some more testing....






I would like a scrolling real time graph to show on debug overlay...
oh really, and would you like some gold and silver with that?


come on it will be fun and will look so cool....

make it a class kind of like ping buffer...

all you need to do it pass it values once a frame

then call it to draw itself


it will only keep a certain ammount of history then throw stuff away.


use it to show, ping, dysnc, cpu, draw, move...


1 pixel per frame....


similar to mWgraph

it doesn't even have to have any history...it can just slide over the bitmap and draw a new pixel...

what am I going to call it?

class qGraph

what about the series size, this should be a lot samller than mwGraph...after all it is quick graph...

4 series max
1000 data points max

implicit x axis is frames and should be an int

1000 / 40 = 25 sec

yaxis will be a double

how about

double data[1000][4]

the index is the x axis

or this...

   struct data_series
   {
      double data[1000];
      int active;
      int color1;
      int color2;
      char name[256];
   };
   data_series series[4] = {0};

this expects new data every frame

when it gets data the old data is pushed down one.

draw is called independantly


y axis will be scaled manually or auto
for now lets start with manual...


I will call draw from srceen overlay..done
I will add data at the end of game loop
where am I going to set this up..new game...done


I don't think I want store x and y in the class...just pass x and y with draw...

the object must know its size though

should we put some data in?

it is working!!

in single player what else can I show but cpu??

client can do ping, dysnc, cpu

I think they should be on separate graphs...

make one just for cpu

auto range from 100 to 50 to 25

OK, challenge accepted


make type variable and type 1 == cpu

make y_axis_min, y_axis_max, y_axis_rng

its just fucking beautiful!!
I love it so much!!

cant wait to make it work on client with dsync and ping....

I could still do it on m36...just make something else the server....

OK lets do this...done....


the cpu makes use of the timestamp buffer, which fills up pretty soon...
change it to just use standard timstamps in the main loop....


then try again...

it 11:30 at night....just a little longer....

fixed cpu...now lets get this to as many clients as I can...

11:57 push



20230117 6:0AM

thing are going slower now that I am back to work....

add more options to pm -t
-t   type 1 exe only
-tl  type 2 exe and levels
-tr  type 3 delete everything first and do release
-ta  type 4 abslutely everything

cleaned up this part of the code...works nicely now...

lets do a full release to all...done


not much time...

what graph can I run on client to see what is using all cpu??

profile

level 29 single player on m36

draw from 500 to 800us

move 95% 30us BUT! spikes to 2000 and once to 4000!!!

I need to know what...

did the move_all profiling and found spikes on player (2ms) and enemy (2-4ms)


implement the per enemy and per item timers...

can I use the timer buffer??

I might have 100 thing to time...

put each enemy in a bin...

      timestamps[i].frame0 = 0;
      timestamps[i].frame1 = 0;
      timestamps[i].frame2 = 0;
      timestamps[i].type   = 0;
      timestamps[i].t0     = 0;
      timestamps[i].t1     = 0;
      timestamps[i].t2     = 0;


I think I will precalc each time...


then add a timestamp like
frame0 - current frame
frame1 - enemy number
frame2 - enemy type
t0 - delta time

then at the end, calculate, enter log entry and erase them all...

LOG_TMR_enem added...

I need to know how many enemies cause the number...



It looks like I have a problem with enemy deathcount...
walk through what happens....


enemy killed by player bullet...

void enemy_bouncer(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return; // to stop rest of execution
   }

in enemy killed:
Ei[e][0] = 99; // set type to death loop


in enemy_move:
case 99: enemy_deathcount(e); break;


void enemy_deathcount(int e)
{
   int EXint = al_fixtoi(Efi[e][0]);
   int EYint = al_fixtoi(Efi[e][1]);
   Efi[e][14] += Efi[e][13]; // rot inc
   Efi[e][12] = al_fixmul(Efi[e][11], Efi[e][12]); // scale inc

   Efi[e][0] += Efi[e][2]; // xinc
   Efi[e][1] += Efi[e][3]; // yinc

   Ei[e][1] = zz[0][ Ei[e][3] ]; // draw current ans shape
   // dec and check countdown timer
   if (--Ei[e][30] < 0) // create bonus
   {
      Ei[e][0] = 0; // kill enemy
      for (int c=0; c<500; c++)
         if (item[c][0] == 0) // find empty
         {
            for (int y=0; y<16; y++) item[c][y] = 0; // clear item
            item[c][0] = 2;           // type - bonus
            item[c][1] = Ei[e][24];  // flower shape
            item[c][2] = 1; // draw mode normal
            item[c][3] = -1; // carryable
            item[c][4] = EXint;
            item[c][5] = EYint;
            item[c][6] = 1; // bonus type 1 - health
            item[c][7] = Ei[e][25];  //  life
            item[c][8] = 0;

            item[c][14] = 800; // time to live

            itemf[c][0] = al_itofix(item[c][4]);
            itemf[c][1] = al_itofix(item[c][5]);
            itemf[c][2] = al_itofix(0);
            itemf[c][3] = al_itofix(0);
            break; // end loop
         }
   }
}

looks like its only the first frame of 99...

tmst arch:[0.3217] cann:[0.3111] trak:[0.6000] clon:[0.1750] flap:[0.4810]
tmst arch:[0.3043] cann:[0.3444] trak:[0.7000] clon:[0.1500] flap:[0.4333]
tmst arch:[0.3522] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6050] dth1:[1600.6000]
tmst arch:[0.2957] cann:[0.3333] trak:[0.7000] clon:[0.2000] flap:[0.5050] dth1:[0.1000]
tmst arch:[0.3000] cann:[0.3111] trak:[0.6000] clon:[0.1500] flap:[0.4800] dth1:[0.1000]
tmst arch:[0.4174] cann:[0.5000] trak:[0.8000] clon:[0.3250] flap:[0.5750] dth1:[0.3000]
tmst arch:[0.3565] cann:[0.3556] trak:[0.7000] clon:[0.1750] flap:[0.5400] dth1:[0.1000]
tmst arch:[0.3261] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3087] cann:[0.3444] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.2000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.8000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.6000] clon:[0.2000] flap:[0.4750] dth1:[0.1000]
tmst arch:[0.3609] cann:[0.3667] trak:[0.7000] clon:[0.2000] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3222] trak:[0.8000] clon:[0.1250] flap:[0.5300] dth1:[0.1000]
tmst arch:[0.3783] cann:[0.4333] trak:[0.9000] clon:[0.3750] flap:[0.6400] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.3778] trak:[0.6000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3667] trak:[0.7000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.4222] trak:[0.7000] clon:[0.2000] flap:[0.5000] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3889] trak:[0.8000] clon:[0.1750] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3667] trak:[0.7000] clon:[0.1750] flap:[0.5000] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3889] trak:[0.7000] clon:[0.2250] flap:[0.5500] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst arch:[0.3913] cann:[0.4556] trak:[0.8000] clon:[0.2750] flap:[0.6200] dth1:[0.2000]
tmst arch:[0.3304] cann:[0.3444] trak:[0.6000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst mpty:[0.2000] arch:[0.3000] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6500]
tmst arch:[0.3217] cann:[0.3556] trak:[0.6000] clon:[0.1750] flap:[0.5000]
tmst arch:[0.3304] cann:[0.3667] trak:[0.8000] clon:[0.1750] flap:[0.6050]

I think it might be one of these....

//      if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);


3 should not exist...field


         case 60: case 62: case 64: // enemy killed
            al_play_sample(snd[8], 0.5, 0, 1.2, ALLEGRO_PLAYMODE_ONCE, NULL);
         break;



its definitely in bmsg...not the sound part though...

is it every call to create new bmsg??.. i think it is...disable this bullshit and see what happens...

much better... now lets try a busy level...

copy all to clients

now I found that drawing the screen overlay takes almost 25ms on 4230 ClientSend
on e6430 it only takes 2.5ms


there are definitely some things to look at....

can I make screen overlay take less?
how much do graphs take?


bottom msg
why does it take so much when creating a new one?
displaying them all does not take so much...


gtg its linzies 18th!!

20230118 6:45AM



run profile graph with screen overlay on/off

could it be that the temp_bitmap created is a memory bitmap??

won't know till I profile...







made profiling page in settings
button to open most recent graph
button to run game from that page
done


some duplicate labels are messing up profile graphs...

all draw have d- prefix
all move have m- prefix
all move enemy now have m- prefix


all profile to add new bmsg




making sounds have its own header...


moved all externs and function prototypes to  .h

// ------------------------------------------------
// ---------------- sound -------------------------
// ------------------------------------------------
extern ALLEGRO_VOICE *voice;
extern ALLEGRO_MIXER *mn_mixer;
extern ALLEGRO_MIXER *se_mixer;
extern ALLEGRO_MIXER *st_mixer;
extern ALLEGRO_SAMPLE *snd[20];
extern ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
extern ALLEGRO_AUDIO_STREAM *pm_theme_stream;
extern int fuse_loop_playing;
extern int sample_delay[8];
extern int st_scaler;
extern int se_scaler;
extern int lit_item;
extern int sound_on;

// z_sound.h
void start_music(int resume);
void stop_sound(void);
void proc_sound(void);
void load_sound(void);
void set_se_scaler(void);
void set_st_scaler(void);
void sound_toggle(void);



moved all declarations to sound.cpp

ALLEGRO_VOICE *voice = NULL;
ALLEGRO_MIXER *mn_mixer = NULL;
ALLEGRO_MIXER *se_mixer = NULL;
ALLEGRO_MIXER *st_mixer = NULL;
ALLEGRO_SAMPLE *snd[20];
ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
ALLEGRO_AUDIO_STREAM *pm_theme_stream;
int fuse_loop_playing;
int sample_delay[8];
int se_scaler=5;
int st_scaler=5;
int lit_item;
int sound_on = 1;


then every file that needs access includes z_sound.h

that seems to work good.....

did the same with z_log...




I am profiling bmsg...

add 1.4-2.2ms
draw 7us


now lets try to change somethings...

see what type of bitmap is created...


there is a global variable:
ALLEGRO_BITMAP *bmsg_temp;

every time new_bmsg is called:
bmsg_temp = al_create_bitmap(800, 20); // create a temp bitmap to build a single line
al_destroy_bitmap(bmsg_temp); // destroy the temp bitmap

why do I bother?? it is always the same size...
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE

I will try to create it in create bitmap

still 1.6 to 1.9ms

next....

maybe its my dtextout...does nothing except double text size, but it uses a temp bitmap...

comment out and speed test..still 1.1 to 1.3...


how about instead of all these temp bitmaps, I just draw on the final...pass a pointer to it to al the subfunctions


al_set_target_bitmap(bmsg_bmp[bmsg_index]);
al_clear_to_color(al_map_rgb(0, 0, 0));

//al_draw_bitmap(bmsg_temp, (400 - (bmsg_length/2)), 0, 0); same as 0

al_convert_mask_to_alpha(bmsg_bmp[bmsg_index], al_map_rgb(0, 0, 0)) ;
al_set_target_backbuffer(display);


so just pass (bmsg_bmp[bmsg_index]);

I don't think that was what was slowing it down

I think it was:
- the dtextout using a temp bitmap to doubel text size
- the call to set alpha..

i fixed the text thing by creating another font that is size 16..
have not figured out the alpha yet...

i think I need to bring bacj the temp bitmap, if for no other reason than:
I need to make it centered, but can't do that until I am finished drawing...
like I said, I dont think that was the bottleneck...

changed from
al_clear_to_color(al_map_rgb(0, 0, 0));
to
al_clear_to_color(al_map_rgba(0, 0, 0, 0));

now it works better...


first add spikes to 700us then around 100-150us...10x better...

not sure why first one is different

print bmsg when adding and compare to profile graph...


why when I draw a tile it takes ~6us but when I draw text, it takes ~100us

it makes no sense to me...



when I use the built in 8x8 font I get the first spike to 50us then around 10-15us

maybe the problem all along has been the truetype font

can I convert it to a bitmap type font?


I sure as fuck am going to try...

first of all print the pristine char set...



I only care about 32-127


now that I have done that, they seem to draw very fast....
no big spike on start, max for everything in add bmsg is 34us..draw text is typically 10us
I am very happy with that...I'll need to put it all back together

put the code here in the comments for future reference...




//   convert pristine ttf font to bitmap font so I can draw it faster 16x16 version



   ALLEGRO_BITMAP *b = al_create_bitmap(290, 110);
   al_set_target_bitmap(b);

   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);

   al_clear_to_color(bg1);

   int y = 2;
   for (int b=32; b<128; b+=16)
   {
      int x = 2;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*18, y, x+a*18+16, y+16, bg2);
         al_draw_textf(font2, t, x+a*18, y, 0, "%c", a+b);
      }
      y+=18;
   }

   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);

   al_save_bitmap("bitmaps/Pristine_16.bmp", b);


   al_flip_display();
   tsw();



//   convert pristine ttf font to bitmap font so I can draw it faster 8x8 version
//
//   ALLEGRO_BITMAP *b = al_create_bitmap(162, 62);
//   al_set_target_bitmap(b);
//
//   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
//   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
//   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);
//
//   al_clear_to_color(bg1);
//
//   int y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//   al_set_target_backbuffer(display);
//   al_draw_bitmap(b, 0, 0, 0);
//
//   al_save_bitmap("bitmaps/new_p_8.bmp", b);
//
//
//   al_flip_display();
//   tsw();
//
//
//   ALLEGRO_BITMAP* tmp234 = al_load_bitmap("bitmaps/new_p_8.bmp");
//   if (!tmp234) mI.m_err((char*)"Can't load bitmaps//new_p_8.bmp");
//   else
//   {
//      al_destroy_font(font);
//      int ranges[] = {32, 127};
//      font = al_grab_font_from_bitmap(tmp234, 1, ranges);
//      if(!font) mI.m_err("Failed to load font from bitmaps/Pristine.ttf");
//      al_destroy_bitmap(tmp234);
//   }
//
//
//   al_set_target_backbuffer(display);
//   al_clear_to_color(bg2);
//   al_flip_display();
//
//   y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//
//
//
//   al_flip_display();
//   tsw();
//
//




OK that should be done for now....

I have other things to profile...like screen overlay...lets see if that got any better now that I have fonts fixed....





20230120 2:00AM
profile screen overlay..


make a way to disable bmg in settings...done
hostname is not getting saved...done




on m36 as client
cpu 120us
sync 230us
cbuttons 43us


none of that seems excessive....


I want to know what happens when player paused due to death...

scrn overlay takes a huge hit in jq...
why don't I get jq when clients join quit?? i do...

what can I do to make jq faster??

5ms then 1.5, 1.5, 1.5 then 5ms
spikes once to 6.7 at start and end..

its that fucking convert mask to alpha!!
265us spike then 35 then 164 spike near end...

why is it sooo slow? why do I need it?

same thing as bmsg....

old:
al_clear_to_color(al_map_rgb(0,0,0));
al_draw_text(font0, mColor.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);
al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

new:
al_clear_to_color(al_map_rgba(0,0,0,0));
al_draw_text(font0, mColor.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);

now it is transparent and really fast...



find all occurances of: al_convert_mask_to_alpha and see if they are needed...

25 matches...

ignore one that are not in a fast loop..
6 in bitmap.cpp
4 in file when loading from file..
7 in logo
mw_text for 'created by' fixed...
title..fixed

2 x void draw_large_text_overlay(int type, int color)..fixed
3 x void idw(int txt, int x, int y, float x_scale, float y_scale)

some when loading my new fonts...can I do that before I save?
does not seem to save in bmp format, i still need to call

al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)) in bmp after loading and before loading font from it...

here is my new routine:

void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size)
{
   // converts ttf fonts to bitmap font to draw faster and have consistant size
   sprintf(msg, "bitmaps/%s", ttf_filename);
   ALLEGRO_FONT *cf = al_load_ttf_font(msg, char_size, ALLEGRO_TTF_NO_KERNING | ALLEGRO_TTF_MONOCHROME | ALLEGRO_TTF_NO_AUTOHINT);
   if(!cf)
   {
      sprintf(msg, "Failed to load font from bitmaps/%s", ttf_filename);
      m_err("Failed to load font from bitmaps/Pristine.ttf");
   }
   else printf("loaded font %s\n", msg);

   int bw = 1;                 // border width
   int step0 = char_size+bw;   // step size between char
   int step1 = char_size;      // char size
   int bmp_w = (16 * step0) + bw;
   int bmp_h = (6  * step0) + bw;

   ALLEGRO_BITMAP *b = al_create_bitmap(bmp_w, bmp_h);
   al_set_target_bitmap(b);

   al_clear_to_color(al_map_rgb(255, 0, 0));  // set entire bitmap to red, this will be the background color separating the glyphs

   int y = bw;
   for (int b=32; b<128; b+=16)
   {
      int x = bw;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*step0, y, x+a*step0+step1, y+step1, al_map_rgb(0, 0, 0)); // clear glyph background
         al_draw_textf(cf, al_map_rgb(255, 255, 255), x+a*step0, y, 0, "%c", a+b);
      }
      y+=step0;
   }
   al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)); // does not actually save in bmp format :(
   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);
   sprintf(msg, "bitmaps/%s", bmp_filename);
   al_save_bitmap(msg, b);
   al_destroy_font(cf);
}

convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_16.bmp", 16);

and here is how I load them...

   ALLEGRO_BITMAP* tmp = al_load_bitmap("bitmaps/Pristine_8.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_8.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font);
      int ranges[] = {32, 127};
      font = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font) m_err("Failed to load font from bitmaps/Pristine_8.bmp");
      al_destroy_bitmap(tmp);
   }

   tmp = al_load_bitmap("bitmaps/Pristine_16.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_16.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font2);
      int ranges[] = {32, 127};
      font2 = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font2) m_err("Failed to load font from bitmaps/Pristine_16.bmp");
      al_destroy_bitmap(tmp);
   }


back to looking for al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;

should be all good...

I have a couple of functions that are not used anymore:

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col);
void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col);

ill list them here then delete them...



/*

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // can show mirror image text when scales are negative
   // used only mdw logo animation
//   int sw = strlen(txt1) * 8;      // string length in pixels
//   int sh = 8;                     // string height in pixels


   int bbx1, bby1, bbw1, bbh1;
   al_get_text_dimensions(f1, txt1, &bbx1, &bby1, &bbw1, &bbh1);

//   printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);

   // scale the scale...
   x_scale *=  24 / (float) al_get_font_line_height(f1);
   y_scale *=  24 / (float) al_get_font_line_height(f1);

   int sw = bbw1;
   int sh = bbh1;



   ALLEGRO_BITMAP *temps = NULL;
   temps = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temps);
   al_clear_to_color(al_map_rgb(0,0,0));


//   al_draw_text(font,mColor.pc[col], 0, 0, 0, txt1 );

   al_draw_text(f1, mColor.pc[col], 0-bbx1, 0-bby1, 0, txt1);


   al_convert_mask_to_alpha(temps, al_map_rgb(0, 0, 0)) ;


   int flags = 0;
   if (x_scale < 0) flags |= ALLEGRO_FLIP_HORIZONTAL;
   if (y_scale < 0) flags |= ALLEGRO_FLIP_VERTICAL;

   // offset x pos if scale is negative
   if (x_scale < 0) x -= abs( (int) ((float)sw * x_scale) );

   // offset y pos if scale is negative
   if (y_scale < 0) y -= abs( (int) ((float)sh * y_scale) );

   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temps, 0, 0, x, y, fabs(x_scale), fabs(y_scale), 0, flags);
   al_destroy_bitmap(temps);
}

void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // used only by bottom message and level done
   int sw = strlen(txt1) * 8;      // string length in pixels
   int sh = 8;                     // string height in pixels

   ALLEGRO_BITMAP *temp = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));

   int dw = (int) ((float)sw * x_scale);
   int dh = (int) ((float)sh * y_scale);

   al_draw_text(font, mColor.pc[col], 0, 0, 0, txt1);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

   al_set_target_backbuffer(display);
   al_draw_scaled_bitmap(temp, 0, 0, sw, sh, x-dw/2, y, dw, dh, 0);

   al_destroy_bitmap(temp);
}
*/


20230120 7:00AM

well I think I have that sorted out...


now back to things that were slowing down on profile...


I was in client with the three things in screen overlay...


240us sync_ping
130us CPU
100   client grid
90    debug common
44    cbuttons
it all adds up to about 700us


when running as client everything added up (cpu) takes about 1ms, draw and move

if i turn off the debug overlay everything is around 400us





clients still around 90-100%

ran the profile graph on a client and 22ms spent in draw and 17 was screen overlay


what to do about that?

make it adjustable somehow. I want to see cpu

sync 7ms
cpu 4ms
c_grid 2.3
dbug_com 1.5

the width of the qGraph determines how many points are drawn...
right now I am using 200 for width which gives me 5s

should I make this adjustable?

set ranges based on how large the screen is?

I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...


20230221 5:00AM
pm -? show commandline options...done




show_debug_overlay to have more options:

0-off
1-minimal
2-medium
3-all

mimimal
cpu only

medium
cpu and sync (client only)

all


make list of things that can be shown:
- cpu
- client sync and ping
- client grid
- server grid

common list of text
more list of text...






I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...

the way I have it now is is only measures send to one client...
and it only add a log entry when it actually sends...
what I want to do is move it to here:

from loop:
if (players1[0].server_send_dif) server_send_stdf();

and add a log entry every frame...
that way I will get the total time, and zero's when nothing happens

between this and rewind, I should have all the main server stuff profiled...done


log cpu (total time spent processing each frame)

calc where?

right now screen_overlay does it...is this what I want??
this is not actually at the end of the frame is it?
no...it is at the end of loop where it is added to qG

            if (proc_frame_skip()) draw_frame();

            double pt = al_get_time() - timestamp_frame_start;
            double cpu = (pt/0.025)*100;
            qG[0].add_data(0, cpu);

literally the last thing...
this is where I should add the log entry also...
LOG_TMR_cpu

done...


ready for some more tests??
looking good...

bug..why does it fail at level done when trying to load next level and getting level 0?

it looks like next_level is only set when player touches exit or warp...
I think some clients are missing this...

fix when I get back....

got to go to a first aid class on a saturday...oh well..8H OT..

push..





20230121 4:30PM
moved all settings related stuff to z_settings.cpp and z_settings.h

e_mWindow.h done
z_player.h done


now I am down to 1300 lines in pm.h...little by little, I am chipping away at it....


added to player array:

   int level_done_next_level;

find occ of next_level and replace with players[0].level_done_next_level....done

that should fix that....


I think I am back to the testing part of things....
send out to all


the dsync on clients has a bit of a strange pattern

on e6430 one peak at +60-500us then a few at -2.3ms

on 4230 4 around +1ms then 1 at -15ms

why is this happening?

what does it all mean?

what happens on a pattern of 5 frames?

I think its the timer adjust...the patterns match...

can I make it less aggressive....



I am dealing with very small values here...

I have usually kept fps at 40 and set timer with 1/40

I could just as easily set timer with 0.025

1 / 40.00 = 0.0250000
1 / 40.10 = 0.024937
            0.000063 or 63us

1 / 40.00 = 0.0250000
1 / 40.01 = 0.0249937
            0.0000063 or 6.3us

my adjustments seem really small


maybe I need to print all the numbers used in my calc

make a new log entry for now...temp...









I want to make a PID loop...


I have an output I can measure: dsync
I have a setpoint I am trying to achieve: offset
I have a variable I can use to control the process: fps


first of all I want to graph these...
then I will try to plug in a new PID algorithm


make a new graph just for this....
client only

in the interests of it all fitting on the same graph I will use fps_adjust as my control

and I will make fps adjust the value added or subtracted to 0.025....

all my values will be in ms to 3 deciaml places...

make a new log entry...done...


now I can easily plot...

   float mv = players1[p].dsync;                 // measured value
   float sp = players1[p].client_chase_offset;   // set point
   float err = sp - mv;                          // error = set point - measured value



my control loop currently is just P, err*100 = P

to get the integral I will need a running total...

simply add and subtract the error....

why do I have doubts this will work?

beacuse when it ramps up the I will grow really fast...

2 ways to solve this...
- set limits on i
- gradually decay i


first of all I need a global variable to keep a running total...

done...



what if the problem is that the things I am trying to sync are inherently unstable....

what if I took an average of dsync and used that...


how often do I get dsync?

with every dif so 2-3 frame...


what if I just took a running average, like ping?


I can still show the instantaneous ones, but use the average to set chase speed

this needs to be fast for initial chase though...


try it....



make ping_buffer have a header file and be self contained...then add dsync...

add dsync_avg to player1 array..done


add call when calc



I think I have stumbled upon something amazing...all this bullshit happens when we need 2 packets...

each packet causes its own timer adjust, and one is definitely later than the other...duh...


how can I make it not do that?

have a variable last stdf_packet frame and check it...
already had var...check it now and only do one timer adj per frame based on first stdf rx'd..done

still getting some wild oscilliations


lets also try starting offset at 0 instead of +10ms


set ia to zero.
how long does it take for mv to climb to zero line?
then with overshoot how long to cross back down?

pa = 100
mv  = 748-727 = 21
mv  = 793-727 = 66

mva = 762-727 = 35
mva = 805-727 = 78


pa = 60

mv  = 428-384 = 44
mv  = 456-384 = 72

mva = 442-384 = 58
mva = 471-384 = 87



make client offset update faster at start of chase..
it seems to take a while to actually change off zero...
352-259 = 93 frames

i cant run ping graph...i broks it..fixed
691-622 = 69

still does not seem to send first ping till mwPS.frame_num>0 (initial state rx?)


this is getting complicated...is is worth it to send pings while still in setup?
while still in setup stdf packets are being processed and timer is being adjusted...
might as well be based on a real setpoint based on a real ping...
while in setup the loop happens very fast and mwPS.frame_num is not incremented...

need another way to trigger sending pings...


how about in loop, after the main 11 is done, send client ping if flag is set.

then I can set this flag in 11 like normal, and also in setup based on a timer...

if (players1[active_local_player].client_ping_flag)
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

make a new timer png_timer..done...

now the event timer is the only thing that sets the flag...
it works, but still no pings for the first bit...

why the fuck not??

log...
all on frame 0:
got reply
send and rx join
start level..

then on frame 152
152 game state updated
162 tmaj
165
166
172
...
240
243
244 ping!!!

this is a long delay...

also client does not show when they became active??
not in log anyway

so back to the issue at hand:

after client gets initial state, it starts the main loop and and chases, while inactive
there is a long pause here before the first ping is received...

why?


show on console the frames when ping is sent..

191026 initial state
191028 ping
191047 ping
191067 ping
191087 ping
191107 ping
191128 ping

in logs
191108 1st ping received 24ms
191129 2nd ping received 28ms


I am sending them, but it appears that the first 4 are lost??

what a subtle bug!!!
on server, when rxing ping and replying, it looks up who from player_num and fails if player is not active yet!!

int get_player_num_from_who(int who)
{
   for(int p=0; p<NUM_PLAYERS; p++)
//      if ((players[p].active) && (players1[p].who == who)) return p;
      if (players1[p].who == who) return p;
   return -1;
}

still the same

console:
652 initial state
671 ping
691 ping
711 ping
731 ping
752 ping

log
732 1st ping
753 2nd ping

still missing first 4 pings...


more console logging:

049 init state
069 send ping
089 send ping
109 send ping
129 send ping
130 rx pong
150 tx ping
151 rx pong

as far as I can tell server is not sending reply...

add console logging on server and look into who...


I think I forgot to send most recent compile to server...it works now...


ping graph dumps a bunch of shit to console...fixed

make it so that once init state is rx, do a one time send ping by setting flag...

OK I think I have that one thing figured out....

clean up and move on...

this is how I handle client ping sends:

made a timer:
png_timer = al_create_timer(.5);   // 2 fps

made a variable in player1 array:
players1[].client_ping_flag

when timer event fires:
if (ev.timer.source == png_timer) players1[active_local_player].client_ping_flag = 1;

in the main loop just after every thing else:
if ((players1[active_local_player].client_ping_flag) && (ima_client))
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

in client setup, when initial state is received:
players1[active_local_player].client_ping_flag = 1;

the only thing I might like to add later is a method of slowing the ping timer...
maybe I don't need to...2 packets per second is hardly anything

now I want to make the ping and sync graph easier to use..

first of all...
make a button on logging to load most recent file in log file viewer..done
then remove profile button from that page...done
then put both pages adjacent...done

now, how do I make ping sync graph better?

I can do most stuff with generic profile graph
tmaj and ping

the only nice thing about the specific one is that it has ping also...

make it all use profile...

ping uses 37
old tmaj uses 36

tmr uses 44

do both for now:

LOG_NET_client_timer_adj 36
LOG_NET_client_ping 37

new:
LOG_TMR_client_timer_adj
LOG_TMR_client_ping

now both graphs can co-exist....


after all this messing around, I have not come to any real conclusions

client sync is still pretty much what it used to be...


now can I finally look at what changing s1 and s2 do?


server_rewind is called and it determines if it is time to make a new state and send dif...

if the current mwPS.frame_num matches the mwPS.frame_num of the last saved base+s1+s2....

then it is time....

- rewind to the last saved base
- play forward s1 frames
- save new state
- play forward s2 frames




random demo game is very not random...
always starts with trigger...
add this: srand((unsigned) time(&t)); // done
checkbox to test opacity on demo...done
when starting stuff from demo save config first so it comes back to the same page..done



next on my simulation
keep client and server frame numbers different
when server is in rewind do not move client fn...

when server makes new state, jump to clients side and receive and rewind it...



what happens if I set s2 to 0??

LAN seem to work with no issues...
WAN i get a few late cdats and some noticeable corrections

tried s2 == 1
WAN was about the same...






I never use the 4 states in this array:
// server's copy of last stdf state
extern char srv_stdf_state[4][STATE_SIZE];
extern int srv_stdf_state_frame_num[4];

I only ever use [1]


I should remove it and make it a flat array....

do I use all 8 of these?

extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

they are server only, so is 0 unused?

I would have to say I think it is

so for server only iI can use 0

I am currently using:
srv_stdf_state[1]
srv_stdf_state_frame_num[1]

I propose to use:
srv_client_state[0][1]
srv_client_state_frame_num[0][1]

I am 99% sure I can do this...so do it...but doc all that you do....

7 occ of
pm..done
main...done
fnx memset..done

loop: 2 places....
old:
game_vars_to_state(srv_stdf_state[1]);
srv_stdf_state_frame_num[1] = mwPS.frame_num;

new:
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;

server 1:
//mwPS.frame_num = srv_stdf_state_frame_num[1]; // set rewind frame num
//state_to_game_vars(srv_stdf_state[1]);   // apply rewind state
mwPS.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
state_to_game_vars(srv_client_state[0][1]);   // apply rewind state

server 2:
//game_vars_to_state(srv_stdf_state[1]);
//srv_stdf_state_frame_num[1] = mwPS.frame_num;
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;


4 more in server:
if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
sprintf(msg, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
if (cdat_frame_num < srv_client_state_frame_num[0][1])
printf("[%d]late cdat dropped p:%d c:%d  state:%d  tally:%d\n", mwPS.frame_num, p, cdat_frame_num, srv_client_state_frame_num[0][1], players1[p].late_cdats);



it still seems to work...remove all traces...

I would like to put all netgame stuff in its own file...

n_netgame.cpp
n_netgame.h

do it...done...



20230124 6:15AM

I have some thoughts about what I would like to monitor:
I want to be able to see how much the clients need to rewind
in LAN test they are exact or 1






I think I have an idea about what s2 is for..
its so that the difs sent are not the most current







remove from player1 struct??
there is no field anymore...

//   float field_damage_tally;
//   int field_damage_holdoff;
//   int field_damage_enemy_number;




but is it used for other stuff?  like mine or block damage?
idk
yes, used for block damage, but not mine...


game_event(59
called only when block_damage is taking health from player

game_event(57
not called at all

game_event(50
mine collison

convert the bit in health to work with block_damage
OK I fixed all that, but that was not what I planned to do...


I wanted to add client_rewind to player1...done and added to client debug grid...done
LAN always 0 or 1..even when increasing s1 and s2...
WAN always 1 or 2..even when increasing s1 and s2... (ping ~27)



20230125 2:20AM


add some sort of manual sync control to client

Like I can set to manual, or the value for auto..

I want to experiment with changing offset and seeing how my clients rewinds come out..


what variables?, should I put it in settings? yes, and also live control..

players1[p].client_chase_offset

currently set in add ping:

players1[p].client_chase_offset = - players1[p].ping_avg;

also in debug overlay


double client_chase_offset;
double client_chase_offset_auto_offset;
int client_chase_offset_mode; // 0 = manual, 1 = auto

add button /auto/manual done
make button adjust ping offset in that mode..done...

now make a way to view client rewind in real time..I can see it in debug grid just fine...


in LAN mode, if I increase a few ms, I no longer jump from 0 to 1, I stay steady on 1

in WAN mode with a ping of 20-30, if I add or subtract a few I can force mostly 1 or 2 for rewind

what have I learned from this?

idk...


I am trying to figure out the effect of changing client sync offset

what effect does it have on when server receives cdat?  I guess I actually have to press keys to see that!

when client is doing rewind of 2 server say game move sync is 0


s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

I think I am on to something here...

try this with different s1 and s2 values

s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

s1:3 s2:2
crwd sgms
2    0
1    -1
0    -2

s1:4 s2:2
crwd sgms
2    0
1    -1
0    -2

that did not seem to change anything...
how is sgms calculated?

void server_proc_cdat_packet(double timestamp)
{
   players1[p].server_game_move_sync = cdat_frame_num - mwPS.frame_num;


what does this tell me?

at what point of sgms are cdats considered late and not applied?
when they are earlier than last saved server state...

lets try to make that happen...

when client moves ahead of server with a positive offset
and sgms gets to -3 then I get late cdat errors...

changing s1 did not seem to affect this...


on client, when I adjust dsync too high it ramps...see if I con find out why...


It looks like my raw calclution of dsync...when it goes over 25, it subtracts 25....

   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   players1[p].client_sync = dst - mwPS.frame_num;               // crude integer sync based on frame numbers

   if (players1[p].client_last_stdf_rx_frame_num != mwPS.frame_num)       // this is the first stdf received for this frame
   {
      players1[p].client_last_stdf_rx_frame_num = mwPS.frame_num;         // client keeps track of last stdf rx'd and quits if too long
      players1[p].dsync = al_get_time() - timestamp;                 // time between when the packet was received into the packet buffer and now
      players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot
      dsync_array_add();
      client_timer_adjust();
   }


the problem is that csync goes to 1 for only one frame

the problem is much deeper than that....
the client has no way of dealing with a future dif...
it just applies it, and that has the effect of the client jumping forward in time

yes abandon this line of questioning, I don't really care about this case...or do I?

what would happen if I did not apply till the next frame??

I think I have that fixed, and it seems to work...


I need to change to docs...

now why did i do that again?


to see what happens to sgms and crwd...ok let see...


crwd now goes to -1 and -2, never got less than zero before...
sgms now to -3 and -4....

when sgms goes to -3 (in s1:3 s2:1) late cdats happen constantly

lets try changing s2....

when s2 goes to 2 late cdats stop...
then increasing client offset till sgms = 4
late cdats again...

I think I found out something...

s2 affects late cdats...

lets do a grid compare again..

WAN with 20-30ms ping


s1:3 s2:0
offs crwd sgms late cdats
-40  2    0
-15  1    -1  rare
+10  0    -2  constant
+80       -6  game done

s1:3 s2:1
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same
          -6    game done


s1:3 s2:2
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same game done


s1:3 s2:3
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    none
+54  0/-2 -4    rare
+80  0/-3 -5    constant
+86       -6    game done


s1:3 s2:4
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5    rare game done


OK now what if I try changing s1:

leave s2 at 1

s1:1 s2:1
offs crwd sgms late cdats base resets
-40  2    0
-15  1    -1
+10  0    -2   rare
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5



with s1 set at 1, I get constant base resets 7K dif size 7 packets 290kBs or 2.3Mbps
lets just throw this one out...its sending dif every frame...

OK so lets start with the minimum s1 of 2
now around 30kBs or 0.24Mpbs

s1:2 s2:1
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   occ/rare   occ/rare
+35  0/-1 -3   constant   const
+54  0/-2 -4   lost server


s1:2 s2:2
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   rare       const
+50  0/-2 -4   const      const
+55  lost server

s1:2 s2:3
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   0          const
+50  0/-2 -4   rare       const
+55  lost server


redo 3
around 21kBps or 0.17Mbps


s1:3 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    const      0
+40  0/-2 -3    const      occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    rare       0
+40  0/-2 -3/-4 most       occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 0          0
+25  0/-1 -3    0          0
+40  0/-2 -3/-4 0          occ
+45  0/-2 -4    0          const
+68       -5    const      const
+80 lost server

now do 4
15kBps or 0.12Mbps


s1:4 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+20  0    -2/-3 occ        0
+30  0/-1 -3    const      0
+50  0/-2 -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+40       -3/-4 rare       0
+50       -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+50       -4    0          0
+65       -4/-5 rare       occ
+70       -5    const      const
+95       -6
+110 lost server



OK... there is alot of data:

its 7:30 so I don't have time to analyze

very briefly

s1
min:2
best 3-4


s2
min:0
best 1-3

3 2 will probalby be best...

experiment with auto sync at 1/2 round trip ping....



20230126 3:00AM

So see if you can do so sort of summary...

s1
controls the frequency or sending difs
1 sends them every frame, should not use, every dif will be full size
2 sends every other frame, occasional base resets are common
3 base reset are very rare


s2
how much the client can lag server without late cdats..
1-3 works probably use 2..


there are probably other things that these affect, that I have not been able to measure yet
I assume that the longer I take to rewind and resnd, the more jarring the corrections will be..

I need some way of measuring that...


how long from sending a cdat, does the client need to wait before it gets a dif with that cdat...
that sounds so simple, how will I measure it

client rx dif for frame 98-100, current client frame = 102...

client rewinds to 100 and ff 2..

so that worst case is a move made on frame 98 does not get back to client until 102...

something like that, lets look at some real data from a log...

3871 tx cdat
3873 dif applied 3867-3871

just that one line:
3873 dif applied 3867-3871

tells me that at worst case 3873-3867 = 6 frames before making a move and getting the official dif from server

this was in mode 4 3..

try in mode 2 3











side track:

why does server rack up a shitload of base resets, waiting for client to join?

make finer tuning of stdf shit in log

I would like to be able to filter out all unsuccessful dif applied
there are a lot of them

maybe a different tag for succesfull vs unsuccesful

27 and 29


extern int LOG_NET_dif_applied;
extern int LOG_NET_dif_not_applied;

replace
extern int LOG_NET_stdf_when_to_apply;

done...the logging is much more better...



mode 2 3 gets 4...this is better yes?

should I calculate and show on client?


where? when dif applied
saved where?

new var
int client_move_lag;

done...now experimeting with that..
I would assume that lower is better..

I have found that when s1 = 2
I need to adjust offset so dsync is about -12 (half frame) or I get base resets...

should I show somewhere on client the base resets?

I already have players1[p].client_base_resets++; on the server
re use it for clients...done..now in debug grid



so, is that what I should do for offset?  aim for - 1/2 frame??

ping  offset
0-12   -12
12-37  -37


changing the offset changes move_lag also...


I have one setup that should work good but the corrections are quite jarring:
s1:2 s2:2
move_lag:2
dsync +12
sgms -2
no late cdat
no base reset

this one has much less jarring corrections:
s1:2 s2:2
move_lag:3
dsync -12
sgms -1
jno late cdat
no base reset

also good is
s1:3 s2:1
move_lag:5
dsync -35
sgms 0
jno late cdat
no base reset

many settings work
also good
s1:2 s2:1

maybe the move_lag is not all important...
it can be longer, as long as the prediction and the actual are not too far off...

I might just be as good as I can get...

set offset so that dsync is about 12-14 ms independant of ping

figure out how to test on worse networks...

why does reducing s1 cause bad problems on server?
kicks client and wont let new one connect

when the new one tries to connect:
server log shows stak reply that client fails base set, has base from previous game


am I not resetting something on server?
when that happens on server, server resets its copy of client base state to zero..
am I not resetting that on client?


reset_states()
client_state_dif_src = -1; // -1 will never match a mwPS.frame_num
client_state_dif_dst = -1;

this will mark if we have not received a state yet, or the state is a bad decompress



server keeps old last acked state for client

need to reset that on server when client quits or is dropped....done

changed this:
void client_apply_diff(void)
{
   int p = active_local_player;

   // check if valid dif
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1))
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
//      if (mwPS.frame_num == 0)
//      {
//         printf("initial state - dif_src:%d dif_dts:%d  cbsfn:%d \n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
//      }
//      if ((client_state_dif_dst > client_state_base_frame_num) || (mwPS.frame_num == 0)) // stored dif with a new dest, or initial state (frame 0)



      if ((client_state_dif_dst > client_state_base_frame_num)) // stored dif has a newer dest
      {

OK with that cleaned up..back to why reducing s1 is bad...does not seem to be bad any more, maybe test more...


when client does level done and starts new level...
it is not waiting for initial state...that is the way it should be
it is still getting stdfs from last level...? at least it is smart enough not to try tp apply them

on the server, do I need to reset client states at level done??

in level done reset_states is called....

clientlog:
------------------
1    client rx dif from 22122 to 22124
     client says wrong client base and replies with 0 for client base
4    client rx dif from 0-22126
4-10 client doesnt apply...too early
11   client rx dif from 0-3

then we are back on track..


server log:
------------------
22122 tx 22120-22122
22123 rx stak  22122
22124 tx 22122-22124
22125 rx stak  0
22125 server drop player sync>100
22126 tx 0-22126
22127 NEXT LEVEL
3     tx 0-3
4     rx stak 3

then we are back on track..

OK what can I do about this?
nothing right now...its time for work...

20230126 7:37AM
20230127 4:24 AM

why do I want to do something about it? it works
I don't like how the server tries to drop the client


I don't like how the client is still getting difs from the previous level.
It is just a natural consequence of the client being ahead of the server..

What if on the client, I check to see if dif_src is much larger than current frame number?
Won't this also catch initial state? Maybe not...is not initial state dif_src == 0?

if (client_state_dif_src - mwPS.frame_num > 100)


I have rewritten the client_apply_dif() again..


this time I have front loaded all the tests and added one for  if (client_state_dif_src - mwPS.frame_num > 100)
it only seems to catch when level done and client is ahead of server...


void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - mwPS.frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d mwPS.frame_num:%d\n", client_state_dif_src, mwPS.frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // stored dif has a newer dest
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }

            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);

               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = mwPS.frame_num - client_state_dif_dst; // dst compared to current mwPS.frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", mwPS.frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (mwPS.frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (mwPS.frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));


                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mColor.pc[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

                  // for initial state only
                  if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);

                  players1[p].client_last_dif_applied = mwPS.frame_num;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = mwPS.frame_num - client_state_dif_src;

                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}

this is a log of how it works


[31][1][2272]dif [2267 to 2269] not applied - not newer than current [2269]
[27][1][2273]rx dif complete [2269 to 2271] sync[-2] dsync[-35.9ms] - decompressed
[30][1][2273]dif [2269 to 2271] applied - rewind [2] frames
[31][1][2274]dif [2269 to 2271] not applied - not newer than current [2271]
[27][1][2275]rx dif complete [2271 to 2273] sync[-2] dsync[-36.7ms] - decompressed
[30][1][2275]dif [2271 to 2273] applied - rewind [2] frames
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                              NEXT LEVEL:151                              |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 151 STARTED                             |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[31][1][1]dif is not valid - src:-1 dst:-1
[27][1][2]rx dif complete [2273 to 2275] sync[2273] dsync[56839.2ms] - decompressed
[31][1][2]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:2
[31][1][3]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:3
[31][1][4]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:4
[31][1][5]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:5
[31][1][6]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:6
[31][1][7]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:7
[31][1][8]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:8
[27][1][9]rx dif complete [0 to 3] sync[-6] dsync[-136.1ms] - decompressed
[31][1][9]Resetting client base state to zero
[30][1][9]dif [0 to 3] applied - rewind [6] frames
[31][1][10]dif [0 to 3] not applied - not newer than current [3]
[31][1][11]dif [0 to 3] not applied - not newer than current [3]
[27][1][12]rx dif complete [3 to 5] sync[-7] dsync[-168.9ms] - decompressed
[30][1][12]dif [3 to 5] applied - rewind [7] frames
[31][1][13]dif [3 to 5] not applied - not newer than current [5]
[31][1][14]dif [3 to 5] not applied - not newer than current [5]
[31][1][15]dif [3 to 5] not applied - not newer than current [5]
[27][1][16]rx dif complete [5 to 7] sync[-9] dsync[-210.9ms] - decompressed
[30][1][16]dif [5 to 7] applied - rewind [9] frames
[31][1][17]dif [5 to 7] not applied - not newer than current [7]
[31][1][18]dif [5 to 7] not applied - not newer than current [7]
[27][1][19]rx dif complete [7 to 9] sync[-10] dsync[-243.8ms] - decompressed
[30][1][19]dif [7 to 9] applied - rewind [10] frames
[31][1][20]dif [7 to 9] not applied - not newer than current [9]
[31][1][21]dif [7 to 9] not applied - not newer than current [9]
[31][1][22]dif [7 to 9] not applied - not newer than current [9]
[27][1][23]rx dif complete [9 to 11] sync[-12] dsync[-285.9ms] - decompressed



windows wants to do an update so I am going to do a push first


then go through code and make sure dif is not spelled diff
and that state and dif refer to the proper things...


'state' refers the the entire game state, typically put into a char array of size STATE_SIZE
'dif' is when 2 states are subtracted, resulting in the diference between the 2

difs are then compressed, optionally broken into packet sized pieces and sent from server to clients

when a client has all the pieces of a dif, and the state on which it is based,
it applies the dif to its base state, recreating the server state..

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

removed this... i don't think it ever applies... in the previous line mwPS.frame_num will be set to something non-zero

                  // for initial state only
            //      if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);




re did the netgame docs for client_apply_dif()

time for work:

20230127 7:25AM


what do I want to do next?

make the auto offset run at - 1/2 frame

figure out how to test with bad network...


document:
void client_fast_packet_loop(void)
void server_fast_packet_loop(void)

extern struct packet_buffer packet_buffers[200];
struct packet_buffer
{
   int active;
   int type;
   double timestamp;
   int who;
   int packetsize;
   char data[1024];
};



files I want to have for netgame

netgame_client_state

netgame_client_sync

netgame_client_control_change

netgame_fast_packet_loop

netgame_state (describes state and dif)







fixed a bug in STATE_SIZE
old:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

new:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

the totals are the same, but the individual value for itemf was wrong..


I have netgame_state_and_dif complete...

next finish netgame_client_state..done...
now make a few links from one to the other....
did reset to zero -> state copmpression methods...
stak...done
state..done

next do:

netgame_client_control_change...done

netgame_client_sync



I just found something I didn't realize

      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


I though that the client used the server's local frame number when calculating sync
it doesn't...

what it uses is the dst frame number, which, depending on s2 is NOT the server's local frame number

what does this all mean?

is my sync not what I thought it is?

the client is syncing to the dst frame of the state....


why do I even need s2 is my question??

could I not handle that by just moving clients sync offset??




try this by making s2 = 0 and running some tests...


if s2 == 0 then dst == server local frame num...




LAN (ping 0.1-0.2)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  5        3    2    0          0
-45  4        2    1    0          0 - playable
-20  3        1    0    0          0 - very playable
+5   2        0    -1   0          0 - very playable
+30  2        0/-1 -2   const      0



4.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  6        3    2    0          0
-45  5        2    1    0          0 - playable
-20  4        1    0    0          0 - very playable
+5   3        0    -1   0          0 - very playable
+30  3        0/-1 -2   const      0






WAN (ping 22-27)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  5        3    1    0          0
-38  4        2    0    0          0 - playable
-13  3        1    -1   very rare  0 - playable (better)
+12  2        0    -2   const      some


WAN (ping 22-27)
5.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  6        3    1    0          0
-38  5        2    0    0          0
-13  4        1    -1   very rare  0
+12  2        0    -2   const      0


conclusions:


I think I could do without s2: not sure why I had it in the first place....



am I ready to test degraded network?



yes!!



tried clumsy 0.3rc4-win64a on win7 e6430
failed to open device 577


linux...


tc and netem


Linux  tc & netem

The most low-level and feature-rich at the same time is Linux Network Emulator (netem). If you are using one of the most common Linux distributions(Fedora, OpenSuse, Gentoo, Debian, Mandriva, Ubuntu) you already have it enabled in the kernel. It comes along with another built-in utility Traffic Control(tc). There is no UI, just CLI, the way most of Linux users like it.

Obviously the sky is the limit in terms of functionality with this tool. I would provide some examples, just to give you a hint:

tc qdisc add dev eth0 root netem delay 100ms

What happens here:

    tc qdisc  what Traffic control is doing under the hood is configuring the kernel packet scheduler.
    add  operation of appending new rule, after the test you probably would want to execute `del` operation.
    dev eth0  the device on which the rule would be applied.
    root  apply it on the egress (outbound traffic) qdisc
    netem  use the network emulator
    delay  network metric to be modified
    100ms  value to be set on this metric

So overall this adds a delay of 100ms to outbound traffic.

This is how can you set it up to simulate 5 percent of packet loss, 2 percent of packet corruption and 1% of duplication:

tc qdisc add dev eth0 root netem loss 5%tc qdisc change dev eth0 root netem corrupt 2%tc qdisc change dev eth0 root netem duplicate 1%

Not enough? Here comes more:

tc qdisc change dev eth0 root netem delay 10ms reorder 25%

With this rule, 25 percent of packets will get sent immediately, others will be delayed by 20ms.

And so on, I think you have got the idea. In the end if you want to delete these traffic shaping rules, just execute:

tc qdisc del dev eth0 root

Check out the manual to get more information.

It is installed on scat Ubuntu 20.04.5 LTS

the line I need to use is:

sudo tc qdisc add dev eno1 root netem delay 100ms

first of all test with 40



set up 40ms delay on outgoing traffic:
--------------------------------------
sudo tc qdisc add dev eno1 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev eno1 root


How can I use netem on incoming traffic?

You need to use the Intermediate Functional Block pseudo-device IFB . This network device allows attaching queuing discplines to incoming packets.

 # modprobe ifb
 # ip link set dev ifb0 up
 # tc qdisc add dev eth0 ingress
 # tc filter add dev eth0 parent ffff: \
   protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
 # tc qdisc add dev ifb0 root netem delay 750ms



set up 40ms delay on incoming traffic:
--------------------------------------
sudo modprobe ifb
sudo ip link set dev ifb0 up
sudo tc qdisc add dev eno1 ingress
sudo tc filter add dev eno1 parent ffff: protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
sudo tc qdisc add dev ifb0 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev ifb0 root

















can I do some sort of max correction measurement on the client?
like actually measure the difference between the local and the server
lets use players x pos.. beacuse y might be on the ground...


how to do this??


good, now what to do with it?

get the max and avg

no, just the max, but reset every 2-3 sec

   float xcor_max;
   int xcor_reset_frame;


this works...


the max correction I can get is when I am manuall running back and forth, fakekey has much less corrections

the max possible would be if I was running in one direction and changed the same frame I got a correction...i think...

test manually for now by running back and forth

I think the max is achieved by running in one direction than changing
that way I get multiples of 4, the max x speed of the player




LAN (40ms) 20in 20out

s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  6        3    0    0          0           12
-35  5        2    -1   0          0           8
-20  4        1    -1   0          0           4
+5   3        0    -2   yes        0

s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  nan      3    0    0          const       12
-45  4        2    0    0          0           8
-20  3        1    -1   0          0           4
+5   2        0    -2   yes        0



LAN (60ms) 30in 30out

s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  6/7      2/3  -1    0          0           12
-45  6        2    -1    0          0           8 - playable
-36  6        2    -1/-2 yes        0           4 late cdats  start

s1:3 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  5/6      2/3  -1    0          occ         12 base resets stop
-45  5        2    -1    0          0           8 - playable
-36  5        2    -1/-2 yes        yes         4 late cdats and base resets start

s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
at no time do base resets stop...
late cdats start at -35



LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable



LAN (100ms) 50in 50out
s1:5 late cdats start at -76
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-80  9        4    -1    0          0           16 - playable

now I want to test with random shittienes...

lets do 30 20 on both in and out

from 10-50 delay

its still playable at -80 on s1:5


I can't wait to test dropped packets and corrupt packets

duplicates should not be a problem, but corrupt? I have nothing to stop bad shit from happening...

reset cor_max on level start...with player stuff...done...

don't reset offset mode and offset...

how am I going to set this up?

- use ping average

first of all, how should I set s1:?

actually even before that, does s2 really not do anything useful?

go back to an exmaple




LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable


try this with different s2 values...


sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms




LAN (80ms) 40in 40out

then
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

now:
s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
base resets stop at -73 and start again at -1

base resets start at -81



I am so confused...


I should make a training sequence to get this info automatically

It should cycle through the values for offset and see where base resets and late cdats happens...



how can I do this?

start server on s1:3

redo all these test manually and this time:

measure when br and lc start and stop...




sudo tc qdisc change dev eno1 root netem delay 0ms
sudo tc qdisc change dev ifb0 root netem delay 0ms


LAN (0ms)
s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-25  3/4      1/2   0    0          0
-15  3        1     0    0          0           4
0    2/3      0/1   -1   0          0           4
25   2        -1/0  -2   yes        0

late cdats start >+25 stop: n/a
base reset start lose sever before than happens


ping / 25

>100 = 4
>75  = 3
>50  = 2
>25  = 1

s1 = 2+(ping/25)

2 for LAN

3-5 for internet

first of all, find settings to get no base resets
s1 and offset

I guess even before that, go back to why lowering s1 can drop client and prevent reconnecting
I though I had it fixed but it still happens...

on client in the join procedure it look s like it never gets initial state


on server the first drop was for last stak rx > 100 (fix spelling!!!)


maybe on the server the rewind thing gets broken...

   int s1 = players1[0].s1;
   int s2 = players1[0].s2;
   int s3 = s1+s2;

   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
   {


   if (mwPS.frame_num >= srv_client_state_frame_num[0][1] + s3)

I think that fixed that...lets see if I can lower s2 to 0 also...
looks good....


now how can I do a training session?

makes sense for newly joining clients, but not server

run training session on client....



ramps through the offset values by fives
starts at 0 and decreases until -100

stays on each for 1s

how many late_cdats
how many base_reset

---------------


I still want to know if changing s2 does anything

sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms


LAN (80ms) 40in 40out
s1:4 s2:0
base resets
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
start at -100 and increase
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


here is some great evidence...changing s2 from 0 to 1 definitely affected late cdats
but...did it really???
it just put a 25ms offset on dsync!!!



test some more...

why are base resets so cyclic?










LAN (100ms) 50in 50out
s1:5 s2:0
base resets never
late cdats start at -76

LAN (100ms) 50in 50out
s1:4 s2:0
base resets always
late cdats start at -76

LAN (90ms) 45in 45out
s1:5 s2:0
base resets never
late cdats start at -66

LAN (90ms) 45in 45out
s1:4 s2:0
base resets (16 on)
-90 to -76
-66 to -50
late cdats start at -66


LAN (80ms) 40in 40out
s1:5 s2:0
base resets never from -100 to +40
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


LAN (70ms) 35in 35out
s1:4 s2:0
base resets: never from -100 to 0
late cdats start at -46

LAN (70ms) 35in 35out
s1:3 s2:0
base resets: (20 on)
-95 to -75
-70 to -50
-55 to -25
-20 to 0
late cdats start at -46


LAN (60ms) 30in 30out
s1:4 s2:0
base resets: never
late cdats start at -36

LAN (60ms) 30in 30out
s1:3 s2:0
base resets: (9 on)
-86 to -75
-61 to -49
-36 to -25
-11 to 0
late cdats start at -36



LAN (50ms) 25in 25out
s1:4 s2:0
base resets: never
late cdats start at -26

LAN (50ms) 25in 25out
s1:3 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at -26


LAN (40ms) 20in 20out
s1:3 s2:0
base resets: never
late cdats start at -16

LAN (40ms) 20in 20out
s1:2 s2:0
base resets: (16 on)
91-75
66-50
41-25
16-0
late cdats start at -16


LAN (30ms) 15in 15out
s1:3 s2:0
base resets: never
late cdats start at -6

LAN (30ms) 15in 15out
s1:2 s2:0
base resets: (6 on)
-81 to -75
-56 to -50
-31 to -25
-6 to 0
late cdats start at -6


LAN (20ms) 10in 10out
s1:2 s2:0
base resets: never
late cdats start at +4

LAN (20ms) 10in 10out
s1:1 s2:0
base resets: (21 on)
-96 to -75
-71 to -50
-46 to -25
-21 to 0
late cdats start at +4


LAN (10ms) 5in 5out
s1:2 s2:0
base resets: never
late cdats start at +14

LAN (10ms) 5in 5out
s1:1 s2:0
base resets: (11 on)
-86 to -75
-61 to -50
-36 to -25
-11 to 0
late cdats start at +14

LAN (0ms) 0in 0out
s1:2 s2:0
base resets: never
late cdats start at +24

LAN (0ms) 0in 0out
s1:1 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at +24


what is the correlation of those two variables?

ping 100 needs s1:5 offset < -76  (4 + 25)
ping 90  needs s1:5 offset < -66  (4 + 16)
ping 80  needs s1:5 offset < -56  (4 + 7)
ping 70  needs s1:4 offset < -46  (3 + 20)
ping 60  needs s1:4 offset < -36  (3 + 9)
ping 50  needs s1:4 offset < -26  (3 + 2)
ping 40  needs s1:3 offset < -16  (2 + 16)
ping 30  needs s1:3 offset < -6   (2 + 6)
ping 20  needs s1:2 offset < +4   (1 + 21)
ping 10  needs s1:2 offset < +14  (1 + 11)
ping  0  needs s1:2 offset < +24  (1 + 2)

so, given an input, ping, formula for s1

                    ping/20
 0 < ping < 20 = 2    0
20 < ping < 40 = 3    1
40 < ping < 60 = 4    2
60 < ping < 80 = 5    3

s1 = 2 + (ping/20)

will never be less than 2



formula for offset

ping  offset
0  -> 10
10 -> 0
20 -> -10
30 -> -20

offset = (10-ping)

I can easily do this on the client
offset = (10-ping)


on the server though...

take the average client ping?
worst client ping?

set s1 from that?


but I don't want to change it too often

is once per second too often??

first of all, do the client auto stuff...done


now where to do the calc on the server



first of all, what the hell?


server sets:

            double t0 = PacketGetDouble();
            double t1 = al_get_time();
            players1[p].ping = t1 - t0;

when rxing both ping and pang...that cant be right....

cli tx ping
srv rx ping then tx pong
cli rx pong then tx pang
srv rx pang

it should be only when server rx's pang..it makes no sense to do it after rxing ping...


client does a nice average for its local ping..that doesn't help me..

server need to keep track of maximum and reset somehow...

make a var in player struct....

20230129 5:49 AM

I made a lot of progress yesterday...

I am pretty sure that s2 is not needed, all it does is adjust where in the cycle the dif is sent,
so all it really does give an offset to dsycn on the client...

I did a lot of tests, made some new measurements, and made some automatic adjustments..

I should add some of this info to the docs...


what am I going to do with client offset?

10-ping...
did I not alreay have -ping
yes I did...

so if I make the offset +10 by default that should so it. It will stay there unless changed..
that takes are of that...

now for for the other one...

everytime server gets a pang packet, it calculates the ping for that client
at the same time, it checks that ping value only against max client ping and sets if higher

if (players1[p].ping > players1[0].server_max_client_ping) players1[0].server_max_client_ping = players1[p].ping;

then in the once per second timer area, if server...
use that max client ping to set s1, then reset max client ping

if (ima_server)
{
   int cmp = players1[0].server_max_client_ping*1000;
   players1[0].server_max_client_ping = 0;
   if (cmp > 100) cmp = 100;
   players1[0].s1 = 2 + cmp/20; // use client max ping to set s1

this looks like it is finished, as long as it keeps working as good as it has...


so now what?


what are sc cs and rt in server debug grid?
are they used?
how are they calculated


void server_proc_stak_packet(void)
{
   int p                        = PacketGetInt1();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;

   int sfn1 = ack_frame_num;
   int cfn = client_frame_num;
   int sfn2 = mwPS.frame_num;

   players1[p].sc_sync = sfn1 - cfn; // packet stdf from s to c  sfn1-cfn
   players1[p].cs_sync = cfn - sfn2; // packet stak from c to s  cfn-sfn
   players1[p].rt_sync = sfn2 - sfn1; // round trip to server back to server through client via stdf and stak


all three of them are only used to show in server debug grid, and I don't recall them ever being useful...

lets kill them...done...

make a new switch -tl to copy src dir only to linux...


done...

now just run pm -tu, then recompile on ubuntu..

now I can complie and run on linux with F9...not sure why I could not run on linux before, except command line...
still can't just click on the executable in linux though...


anyway, now that I have that done lets check out the new server debug grid


what is lcls...late cdats last second...makes sense...
lets hide if for now...


when server displays dsync for clients, where does it come from?
client sends it to server with stak packet

what is gmav on server for each client...
// client game move sync avg last sec
the amount of time between server getting cdat and when it should be applied...???

pretty much follows offset on client....
when client offset is 10ms, gmav is -10...etc...i think ill keep it for now....but hide it



what is server_sync used for?

server keeps track of it for each client when stak packet received

void server_proc_stak_packet(void)
{
   int p                        = PacketGetInt1();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;
   server_lock_client(p);



server uses it to lock clients when first joining

void server_lock_client(int p)
{
   if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
   {
      if ((players1[p].server_sync > -2) && (players1[p].server_sync < 5)) players1[p].sync_stabilization_holdoff++;
      else players1[p].sync_stabilization_holdoff = 0;
   }
   if (players1[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
   {
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      players1[p].sync_stabilization_holdoff = 0;

      sprintf(msg,"Player:%d has locked and will become active in 4 frames!", p);
      if (LOG_NET_join) add_log_entry_header(11, 0, msg, 0);
   }
}


server uses it to drop clients if it goes over 100

         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
         }


I now have dsync, which does pretty much the same thing, only higher resolution..
it is calculated on the client and passed to server with stak packet....

just for the sake of making things simpler, could I replace server_sync with the dsync that I get from clients?

why do I need both?


right now, server does not get anything for server_sync until it gets stak packet from client, this should not change anything...


lets run a log and look at the stak packets rx'e by server...especially when joining and level done...



first try to replace in the locking part....

what ranges should I use?

max +30  +0.03
min -150 -0.15
try that...


it seems to work but I should try it on some shitty networks....

where does it show waiting for sync?
it show it on the client (duh!) and uses the varaible client_sync...

on the client,

calculated in rx_stdf:
players1[p].client_sync = dst - mwPS.frame_num;                        // crude integer sync based on frame numbers

then used to calculate higher resolution dsync:
players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot

then after that it is used only to display...
log entries,
client debug grid
"Please wait for server sync" overlay

I think I want make it only used for a few lines in rx stdf
then after that, just use dsync...
client_sync is gone....

back to server sync...

test with 40 30 on both

it joined...


try 80 on both (160)

it still joined...
I think the target was 150 (160-10) so try 90 90 (180)

now it fails...

lets try setting the limit to 0.2 or (200)

that works, it finally joined with a ping of 200

reduced stabilization time to 10 frames...

OK moving on to removing server_sync....

do I even need to drop players with a huge sync??
how about I take a page from the join stuff and make it so that it has to be over the value for a specified number of frames?
or just don't do it...lets try not doing it....

//         if ((players[p].active) && (players1[p].server_sync > 100))
//         {
//            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
//            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)
//
//            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
//            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
//         }
server_sync is completely gone....


that all seems to work...


bug...can't quit on client while waiting for sync

after getting initial state it goes to mode 11, the normal running mode...
but the client is not active yet, until the server says it is....
all I want is a way out of this mode...

added this to control....

      else if (players[p].control_method == 4) // not active and control method 4 is a client waiting for server to make it active
      {
         if (mI.key[ALLEGRO_KEY_ESCAPE][1]) new_program_state = 25; // give them an escape option
      }

there do not seem to be any other escape routes in client setup...

if the network setup fails, it will just timeout...

what about when waiting for a join invitation?
it normally never fails, but lets make it fail then make a way out...done
nothing is shown, except on the console, but that's ok

can I add one to the network setup?
especially the part where it waits for a response...done

now fix what you broke....done...


moving right along... now what?

remove s2....

should I rename s1?

im doing documnenataion and would like to call it something else..

i used to call it stdf freq

how about dif_freq?
i like that
server_state_frequency would be more accurate
it does rewinds and makes states even when it has no clients...


ok

server_state_frequency it is....

find all s1 and replace...

also kill s2..

...........


more testing, with corrupted and missing packets

more documentation... did a lot of doc......



I don't think I need to send the client ping when the client joins...it should be fine just doing it with just the 2 Hz png_timer
the timer is constantly running, and therefore the flag is set..
only gets cleared if it actually send a ping...

ima_client gets set when sjon is rx'd

while waiting for initial state we are not in mode 11 yet

as soon as innitial stae is rx'd flag is set and we are in mode 11

but!!.. ping is not sent in game loop, it is sent just past it on the outside..

so ping will be sent with 2 Hz timer as soon as ima_client is set when sjon is rx'd
the extra one when initial state is rx'd is still not needed...

OK I'm convinced...kill it...


I don't think I want to save players1[0].server_state_freq in config file anymore...
after all, i dysnalically set it...
just make sure it has a sane value...

at the same time, also lose zlib compression...I have never once changed it...done...

what about TCP/UDP? leave it for now, but its very experimental

Actually I would have liked to experiment with zlib_cmp...
I should make i changeable as the game is running...but no need to set it in config though...

-------------------------


next...


while gointg through the code, i realize...

why do I have two states for every client?

I only keep one previous state...

the other one is only used as a temp storage when making difs...

make sure this is the case, then remove it..

15 occurances:
2 define and declare
4 for clear

that leaves 9
4 time server only [0]
all cases where I use it for the server:
I use [0][1]


I know why!!

I don't actually overwrite the old state until I get an ack for the new one....

OK, just leave it....

experiment with zlib_cmp...I would really like to see it in real time...
i still like 7 the best








can I make a general rolling average algorithm...

then just make instances of it?

what would that look like?
a class


OK, I think I have the class done, now how to patch it in...

lets do cpu...

I need to choose which one I'm going to use and initialize it somewhere....you don't even have to initialize!

make cpu graph show inst and avg...but make text use avg...

looking good...

I add data in loop..
I draw in graph screen overlay

I am spending far too much time on this...
be done with CPU...
in the very middle: CPU: just liek it used to be, then min and max on each side...
CPU is done!!


now redo ping with new RollingAverage

0 = CPU
1 = PING
2 = DSYNC
right in ping array was where the avg was used...move it...done

I think ping is done
next dsync..done...

now remove ping_buffer and all traces of it...done...

nice...now I have a nice rolling average I can use when I want...

I should send dsync _avg to server instead of raw...done

remove the adjustments to s1..just comment out..done
but then I would like to be able to view state_freq...put it in debug grid....done






can I let client know when late cdats happen, so I might adjust offset to prevent it??
the only way would be to add it to stdf packet and that is pretty much full...
I think I use 1022/1024 bytes already


      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


4 stdf
4
4
1
1
4
4
1000
--
1022

do I need 4 bytes for start_byte and packet data size?


what is tha max the could be

well packet_data_size would be 1000 max

what is the data range of a 2byte int?

2^16 = 63356
or +/- 32768

what is the max data size we are prepared to handle? do I have a limit somewhere?

I'm putting it in a buffer the size of a state so that is not a limit...

I don't see anything on the server that would limit it...
it just breaks it into 1000byte pieces...

ok, i only use 1 byte for num_packets so I have a limit of 256 there....

on the client, I have client_state_buffer_pieces[i]

int  client_state_buffer_pieces[16];   // to mark packet pieces as received

so there is my only limit so far and it would be trivial to increase...

start_byte could be 16,000 if I used 16 packets...
still easily fit into 2 bytes...

should I do it?

reduce to 2 bytes...

then I would have 6 extra...
what do I want to send?  how about late_cdats_last_sec...
what is the max that could be?
40 fps could be 40 late cdats...hell I could just use 1 byte for that...
lets just do that...done

OK now client has late_cdats_last_sec...what is he going to do about it?

when not zero, show a warning on the screen in red...

can I make rtextout_centre take an arbitrary font?

11 occurances...
9 uses...2 i just used...
converted...also that fixed edit server name having the wrong font...

I think I will just put this error message on the bottom frame...I like it there better....done...






make the mouse disappear if not moved and and appear if moved
I could put this in the event processing loop...

make a 5s timer...
if the event timer fires (times out), hide the mouse...
if the mouse is moved, show the mouse and reset timer
this worked on my first try...

   mou_timer = al_create_timer(5);    // 5s
   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mou_timer));
   // start timers
   al_start_timer(mou_timer);

   if (ev.type == ALLEGRO_EVENT_MOUSE_AXES)
   {
      al_set_timer_count(mou_timer, 0);
      al_show_mouse_cursor(display);
   }
   if (ev.timer.source == mou_timer) al_hide_mouse_cursor(display);

done......

it is 5:44PM on Jan 30, 2023

I took today opff work due to being sick with a headache...

got a lot done...

next up on the things to do, test more with shitty networks...





there is some stuff that should be cleaned up in program states...

when client exits, it has its own special state 25 where it cleans up, then goes to state 1.

server does not have this...just goes to 1...

in 1:
         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();

            if (autosave_log_on_game_exit) save_log_file();
            if (autosave_game_on_game_exit) blind_save_game_moves(2);

            stop_sound();
            if (program_state != 3) stamp();

            program_state = old_program_state; // go back to the state that called 0,1,2 or 3
         }
      }
      new_program_state = 0;

in 25:

   //---------------------------------------
   // 25 - client exit
   //---------------------------------------
   if (program_state == 25) // client exit
   {
      client_exit();
      new_program_state = 1;
   }

in the interests of making them both them same...

should I make them both like client, or both like server??



both like client...

add a new state then..

19 is server_exit

now find places where the server would exit...


I think I still want to keep:

         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();


and use 19 and 25 for errors in setup...

not sure what I gained here...at least its more consistant looking


now back to doc...where was I? server_setup...??





I have an urge to figure out more exactly what is going on with the timing loop in netgame...


I can picture the server making and sending the state on a specific frame

I will draw a rectangle with time on the y axis like normal

then I will draw a rectangle below it show the clients frame and the offset is determined ny the ping and offset...

I need pictures, diagrams..



go back to your data...

when you increase offset evetually you get late cdat on the server, right?? yes...



that would mean that increasing offset, makes the clients less ahead of the server..

dsync > 0   client gets difs for future frames
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client gets difs for past frames

as the dsync decreases the client has to rewind, meaning that it got a past dif, meaning that the client is further ahead of the server...

dsync > 0   client is further behind
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client is further ahead

so... when offset increases, the client is further behind, until late cdats happen







could I actually do these graphs in real time, based on the real data??

server would should a rectangle the size of stdf freq frames...
server would show when it got stak replies and cdats...



I would need persistant data over the course of a state

sending a new state would reset the variable...

start_frame_num
start_frame_ms
num_frames
num_ms

sdak_rx_ms - how many milliseconds to get the reply from the client
cdat_rx_ms - cdat offset from frame start...


do I already do this with sgms? server game move sync?
measure how far off the cdats are from when they are needed?

I do...

on the sever, I maeasure that and it it always the neagtive of dysnc on the server

for ping 0..clients dsync 10 gmav -10

so I already have this...

what am I trying to figure out here?

Do i just want some nice pictures to help me understand?


from the server's point of view:

see the entire state to state block.
see when sdaks come back..
see when client input arrives..
see how far the client is running ahead/behind

from the client's point of view..
show timing relation to server, (dsync)

I don't think I am getting anything new here...

this is all information I already have...

I think the most important thing is to set state_freq first.
make that as fast as possible, without getting base resets
right now I am just setting that based on ping...

would it be any better if I set it based on how long it takes to get stak replies?
they are pretty much the same thing as pings...??

then after that set the client offset...

I really can't see any improvements to be made...

I think I might be getting a little lost here...

I think I need to officially stop messing with the netgame stuff...
I am afraid that there might be a few improvements I could do that if I don't do it now I never will...

the only improvement I could possibly think of, is when in the loop are dif's made and sent...

I went down that rabbit hole once, it was very complicated and I never came to any resolution...

at most, I could save part of a frame in time...maybe...

here is the old description:

In the game loop, 'server_send_stdf()' is called after 'move()' but before 'draw()'

It is important that it is in this place in the game loop.

It cannot be called before move...why not??

Was it because in the old way, frame numbers changing was a big issue?

Now the frame numbers are the same in both places.

the state needs to be made at a very specific place in the loop, you can't just move it before or after the input has been applied and moves made

I don't think it really matters at all now, but I would like to test it.....later

now that I think about it, why do I make a state before input is applied for a frame?

I don't know, but it smells wrong...

rewind 3
play 3
make state
do input
move
send dif
draw

back to top



what do you think it should look like, and why?

rewind and get all missed input
do input for this frame
move

make and send state

draw


what if I did the rewind for input independant of the make and send state?

and only do it if there is actually something to rewind for...

I could do it every frame. if I remember, it was not expensive in cpu time..

but why? what are you trying to achieve?

premature optimization when you don't even think there is a problem?

the problem I thought I saw was the server replaying and making states early in the frame.
then still applying local input and doing the move after...

I thought this would result in the state being made and sent to the clients just before it changed as opposed to just after it changed...
that still seems true..


but the way I have things set up, after loading a state, both client and server still expect to play that frame out...

what if I changed it to:

server saves states after all input and moves are done for mwPS.frame_num
then when loading them the first thing that shoud be done is to increment the frame number and start at the top of the loop.

basically I would be changing the states behaviuor from:
frame:100 starting state
to:
frame:100 ending state



OK this is the final time we go over this:


frame++ (100)

server control
 - check for client input and put in game moves array (could get client input for 100 here)
 - time to make state? rewind and replay then make new state for 100 (before any processing of 100)

local input for 100
game moves array input

move 100

send stdf for 100 (pre move)

draw 100


the first thing I notice is that there is no reason to wait until after move to send the state
nothing about the state will change...

the second thing...
the rewind, replay, and make state are at the start of the frame after the previous frame pause...


a thought....

----------------

top of frame

frame++

if it is time to make a new state:

at the start of the frame:
- check for more client input
- do the rewind

do local and game move input...

move the frame

make the state and send it with the frame number for the next frame

draw the frame

----------


all that would be required to make this change is:
- move the part where the state gets made to the send part
- date the frame to the future...

a state would still refer to a frame that has not been processed yet...
the starting state of a frame...

the benefit would be that I am not waiting till the next frame to send a state from the previous...


I think I have convinced myself to do this:

I was very easy to implement...


the first thing I noticed is that late cdats happen at the normal +10 offset...

changing to -10 fixed that..

that would make sense as my timing has shifted by the entire wait period...


should I redo all my time testing? yes


put back the manual adjust of state_freq...



I am loving this new way....

on the server I monitor cdsync and gmav
they can both run in low single didgits


I was working on some tools to help me understand in finer detail what is happening with
the different offsets and state_frequency settings...

I still kind of want to understand this better.


I was wondering if I could remove the ping stuff...
the only reason is to simplify things...

I was thinking of using the stdf-stak exchange..
then the server could calculate ping and send it to clients..

but...
client only replies when applying the dif..

nevermind...it is fine the way that it is..




Could I show a nice rectangular graphical representaition on the server...
Show the width of the state_freq
show when cdats mostly come in
show the client sync
show when sdak was recieved...

does this even make any sense?

the data I would need to keep..

once per state save

start frame
end frame
when was stak rx'd (in finer resolution than 1 frame)
client offset
all the client cdat sync times..

I could just start with frame and stak rx...

make stak rx time and use fine detail


I made stak_dsync and am testing..


something weird..

on LAN (ping < 1)
state_freq = 1

no matter how I adjust client offset, I never get base resets...
saem with 20ms

lets try 30..finally I get some..

stak_dsync is not what I think it should be

I want it to be a positive number in ms
of how far after the frame start i receive stak...
it will probably be very similar to raw ping

I don't seem to be getting anywhere with this


OK lets do something easier, maybe...make a class for last_sec...

what uses it?

lots...
late_cdats_last_sec
game_move_dsync_avg_last_sec
frames_skipped_last_sec
timer_adjust_last_sec

bandwidth counters..
also do frame as well as last sec..

what does each one have in common?
they need a tally, a running total

optional:
number of entries
average
min
max

OK do it...
first what are you going to call it?

mwPerSecond


while implementing, I realized, it doesn't have to be per second
it could be any arbitrary period..
whenever calc is called

also I realized I want to fix the naming of my classes

I want them all to begin with mw then use CamelCase

what do I have so far?

e_mWindow
z_mwGraph
z_qGraph
z_mwRollingAverage
z_mwPerSecond


this is what I want:

mwWindow
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

I want the file name for the cpp and h to be the same as the class name...

start with an easy one: qGrapgh

remove files from project
rename
add files to project

done:
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

window is huge...do it later...


i think tally is ready to implement...

lets try late_cdats_last_sec...

it looks like there are 3 varaibles used in player struct..

   int late_cdats;
   int late_cdats_last_sec;
   int late_cdats_last_sec_tally;

I will keep:
   int late_cdats;
   int late_cdats_last_sec;


this is where I add:

      players1[p].late_cdats++;
      //players1[p].late_cdats_last_sec_tally++;
      mwT[0].add_data(1);

this is where I initialize:

      players1[p].late_cdats = 0;
      mwT[0].initialize();

this is where I tally:
                     players1[p].late_cdats_last_sec = mwT[0].get_tally();
                     //players1[p].late_cdats_last_sec = players1[p].late_cdats_last_sec_tally;
                     //players1[p].late_cdats_last_sec_tally = 0;



OK this one works...

now these:

mwT[1]

   int frames_skipped;
   int frames_skipped_last_sec;
   int frames_skipped_last_sec_tally;

mwT[2]
   int timer_adjust;
   int timer_adjust_last_sec;
   int timer_adjust_last_sec_tally;



            players1[active_local_player].frames_skipped_last_sec = mwT[1].get_tally();
//            players1[active_local_player].frames_skipped_last_sec = players1[active_local_player].frames_skipped_last_sec_tally;
//            players1[active_local_player].frames_skipped_last_sec_tally = 0;

            players1[active_local_player].timer_adjust_last_sec = mwT[2].get_tally();
//            players1[active_local_player].timer_adjust_last_sec = players1[active_local_player].timer_adjust_last_sec_tally;
//            players1[active_local_player].timer_adjust_last_sec_tally = 0;



      players1[p].frames_skipped = 0;
      players1[p].frames_skipped_last_sec = 0;
      mwT[1].initialize();

      players1[p].timer_adjust = 0;
      players1[p].timer_adjust_last_sec = 0;
      mwT[2].initialize();


those two are done...this is going well...
can't wait to do more...



now for a more difficlut one

mwT[3].initialize();


game_move_dsync_avg_last_sec

   double game_move_dsync; // current value
   double game_move_dsync_max; // never used
   double game_move_dsync_avg_last_sec;
   double game_move_dsync_avg_last_sec_tally;
   double game_move_dsync_avg_last_sec_count;


                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
                     {
                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
                        players1[p].game_move_dsync_avg_last_sec_count = 0;
                     }

   // calculate game_move_dsync
   players1[p].game_move_dsync = ( (double) players1[p].server_game_move_sync * 0.025) + timestamp_frame_start - timestamp;
   mwT[3].add_data(players1[p].game_move_dsync);
//   players1[p].game_move_dsync_avg_last_sec_tally += players1[p].game_move_dsync;
//   players1[p].game_move_dsync_avg_last_sec_count +=1;



                     players1[p].game_move_dsync_avg_last_sec = mwT[3].get_avg();
//                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
//                     {
//                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
//                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
//                        players1[p].game_move_dsync_avg_last_sec_count = 0;
//                     }



server max client ping...
mwT[4].initialize();

               if (players1[0].server_state_freq_mode == 1) // 0 = manual, 1 = auto
               {
                  int mcp = players1[0].server_max_client_ping*1000;
                  players1[0].server_max_client_ping = 0;
                  if (mcp > 100) mcp = 100;
                  //players1[0].server_state_freq = 2 + mcp/20; // use max_client_ping to set server_state_freq
                  players1[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq
               }


OK I think I have all those done:

should I test them??

what about bandwidth?
leave for now...



I am thinking about reanmeing functions in server send state...


now:
void server_create_new_state(void) // rewids and sets flag

void server_send_stdf(void) // craetes new state

void server_send_stdf(int p) // send stdf to a specific client


new:

server_rewind...done
server_create_new_state..done
server_send_dif..done



I want to do some tests...

with lots of clients..


I was a little concerned when running a game with 40ms lag
I saw what looked like quite huge corrections.
On one client to another.
Viewing a client with fake key on another client looked very jumpy...




OK I have some serious bugs here


some clients simply cannot connect:
they either fail at sync with a high number till they time out
or they never get the initial state...

why? what is going on??


it looks like they have a very high cpu..

it looks like draw it taking >20ms

but then clients cannot connect after that

and on server

state_freq is an enormous number....

log when it is set...

or just print...

fixed a bug the tally max code used by max client_ping
now if no enries, the max returned is zero, not min double!

deploy to server and test...better


Now running profile on client
draw
8 ms lift
7 ms screen overlay
2 ms item

this is on level 13 which has 15 lifts...not even close to a max...

also it seems to take a long time to chase...



on client, the time inbetween init state and first timer adjust

1-3 frame

level 150
m36   3f -6
      2f +3

4230l 1f +39
      1f +25



level 13
m36   2f +5
      2f +12


4230l 1f +177
      3f +175

I can't see what might be causing this in the logs or profile


could it be redraw tiles in client_apply_dif?
profile it...does not look like the culprit

are you sure about this?

the time in between the initial state received and the first timer adjust...

look at timer_adjust...it never fires....

I just had a client that never connected. could not catch up...
It looks like when it is trying to go faster, it has even less time process the frame...
but more importantly, I don't think that skip drawing frame ever triggers!


old:
int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

   if ((mwPS.frame_num+0) < al_get_timer_count(fps_timer)) // skip drawing frame


it appears that in single player and client that fn is one less than timer

do I care?

i use the raw timer event to flag that it is time to process a frame...


should I keep them in sync? should timer always match the current frame?


the only thing I use the actual timer value for is deciding if I skip drawing

void set_frame_nums(int fn)
{
   // reset mwPS.frame_num and fps_timer count
	mwPS.frame_num = fn;
   al_set_timer_count(fps_timer, fn);
   reset_animation_sequence_frame_nums(fn);
}


at the start of loop i check to see if the counter is too far ahead

void proc_timer_adjust(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num+1)
   {
      players1[active_local_player].timer_adjust++;
      mwT[2].add_data(1); // add to tally
      al_set_timer_count(fps_timer, mwPS.frame_num+1);
      printf("Adjusted timer - fn:%d timer:%d\n", mwPS.frame_num, (int) al_get_timer_count(fps_timer));
   }
}


then later in the loop if check it again to see if I skip drawing:

int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}


these conflict and are unccesarily complicated...

do it once..



int proc_frame_skip(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num) // skip drawing frame
   {
      al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

this has the effect of forcing timer to always have the value of frame number

the timer will fire and event an increment the timer

the loop will increment mwPS.frame_num

if, while processing the loop, the timer increments again, the loop will not be drawn

if, when starting the loop the timer is ahead of frame, frame will still be processed, but draw will be skipped.

when the test to draw is performed, if timer is ahead, it will be set to current......is this part necessary?
wont that speed up the game enough to catch up?

I want to try this without the reset timer...

the one thing I am not checking for is if the timer is behind mwPS.frame_num
we don't want to stop or slow the game to catch up to the timer (i think?)
so we should move the timer ahead to the actual mwPS.frame_num...
not sure if this ever happens though...

first:
comment out timer adjust (it never fired anyway)...
change
int proc_frame_skip(void)
{
   int draw_frame = 1;
   if (al_get_timer_count(fps_timer) > mwPS.frame_num)
   {
      draw_frame = 0;
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
   }
   al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
   return draw_frame;
}

mwPS.frame_num is the reference.
set the timer from this, not the other way around

why do I get to a place where clients cannot join server?
the only thing I can do is reset the server
clients stall at waiting for initial state...

client log shows that they cannot apply dif from over 100 frames in the future..
if (client_state_dif_src - mwPS.frame_num > 100)
fixed...
if ((client_state_dif_src - mwPS.frame_num > 100) && (mwPS.frame_num != 0))


now I want to make a much more minimal overlay
just show cpu and fsls in border...
done

still at 70% cpu on level 13
state_freq and zlib_cmp make no difference...

its still draw lift at 8ms

can I improve on that?
removed draw lift lines and got about 4ms

removed the drawing of 10 shrinking rounded filled rectangles
less than 1ms

I know it looks nice, but is there a less expensive way of drawing it?

same with lift lines...is every frame neccesary?

maybe I could measure if lifts draw time > 5ms then go to a simpler draw method...

draw lift lines every other frame...

etc...

go back to the original method of drawing lift lines
only when drawing background..

when do I do this:

switches, bombs, keys, block manip, client_apply_dif

I don't know if I can go back to this...
I just checked and I don't think lift lines ever change...

why is this such a change, did I not notice it before?

maybe I could make a global reduce cpu thingy..

don't I already have that with drawing less??


I think I broke stuff!

client does not play nice on cleint anymore  :(

I like it on m36 0ms...
and on e6430...

but on 4230j it does not seem to skip frames gracefully...


to test this....


make a function that adds delay in the draw stuff.
like pct_y

seems to work ok in single player...
but the terminology is a liitle off

FPS set..good
FPS actual..not really..
FPS skipped..just skipped drawing is all, not actually skipped...

have a look at this...

on the 1 Hz timer:
actual_fps = mwPS.frame_num - last_fps_frame_num;
last_fps_frame_num = mwPS.frame_num;

why? what good is this?

just use:
frames_skipped_drawing_total
frames_skipped_drawing_last_sec
done...

maybe actual fps had some use in speed testing?
it just records the number of times the game loop has been processed in the last 1s

something funny is going on...why does it record less when a frame skip happens?

when I change the timer count, do I also reset when the tick happens?

i think I should not be correcting the timer


when timer > frame then skip

but if i don't do any corections it will be the same next frame....


how about this:

at the start of the game loop:
fn++
timer event has fired and incremented timer_fn

before anything else...
if we are already behind at this point:
correct timer to match frame
flag this frame as not to be drawn

if we are on the same frame:
process as normal

then test to see if we are behind after processing...
if so, skip drawing, but do not correct timer..

so there will be two types:

one at frame start
one after processing

give this a try...

no luck...


I have made a big mess here...
this should not be complicated....



can I do a timestamp when the event fires then compare it with when the frame starts..

print timestamp on 1Hz timer...see if that is actually 1Hz
it is not...maybe its my stupid way of calling al_rest...

I should do something else to pause...

same with 40hz



am I all fucked up here?

timers do not seem to be firing when I think they should

I could be that I am doing things that pause them more than the period of the timer....


for example, if draw takes more that 25ms how do I handle that?

my network code needs the rest of the stuff to run at 40hz


even if I draw every other frame, when I do draw, the draw time being over 25ms will mess up my nice timing...


could I figure out a way to split the draw between 2 frames?


I think I should just put all this back together and abandon the idea of skipping draw frames for now....
It just does not work nicely

if I go over 80% cpu, I should enable econ_draw...



how much can I remove?

do I even care at all what the timer count is?

all I need is the timer event firing...

I'm gonna say no and remove it...



fix animation sequence...you know what I mean..

this has been this this way for over 25 years

I don't want to embed frame numbers in it anymore..

how does it work now?

   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count

what I need to do is:

make 2 the tally count and inc evey frame
if 2 > 3 then next shape and 2 = 0;

old:
void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

  // printf("update_animation :%d\n", mwPS.frame_num);


   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
         if ((mwPS.frame_num - zz[2][y]) > zz[3][y])
         {
            zz[2][y] = mwPS.frame_num;                     // set counter
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
}

new:

void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = count tally
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

   // printf("update_animation :%d\n", mwPS.frame_num);

   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
      {
         if ((++zz[2][y]) > zz[3][y])
         {
            zz[2][y] = 0;                             // reset tally
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
      }
}

yay that has been there for far too long!

next I want to get rid of set_frame_nums();

at least in the game for now...done

now is there anything that reads timer?

yes, some stuff in level editor...I want to get rid of it too...

these no longer exist:
al_get_timer_count
al_set_timer_count
set_frame_nums()
proc_frame_skip()

so much simpler...

now I have removed all safeguards against cpu > 100%

bad things will happen!!

what do you want to do?

put draw in economy mode...

draw half the things one frame and half the next...but where do I draw the line?


   get_new_background(1);
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   get_new_screen_buffer(0, 0, 0);
   draw_screen_overlay();
   al_flip_display();




everything has to:

   get_new_background(1);
   get_new_screen_buffer(0, 0, 0);
   al_flip_display();


optional
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   draw_screen_overlay();


int draw_seq[20]

0 = always
1 = odd frames
2 = even frames



I am tempted to make a acreen overlay that shows these times:

then go through the list from max to min and put one in each column...



I want to max this a class

mwDrawSequence

mwDS

only one instance

has an array for times, min, max, avg and draw sequence

everytime something is actually drawn the time is measured


it look horrible!!

lets rethink this:


odd:
   sprintf(name_long[0], "get_new_background");

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");

even

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");


There is a lot of flickering no matter what I do.

I could make screen_overlay use its own bitmap.....

it is one of the biggest culprits

and in screen overlay, QuickGraph uses a lot

measure it..

or just disable it...


I think I am just going to leave stuff the way it is.

sure the screen overlay take lots of cpu, but you can just turn it off...

lets test...




I would like to make things optional in the debug screens

make a grid in settings:

number of debug levels across the top

things that can be shown is a list to the left

then a grid of check boxes.

different one for client and server:



server:

CPU graph
screen info
debug grid
bandwidth
draw timers
adjustment buttons


put text cpu in bottom display for all...far right...done


                    mode 0 mode 1 mode 2 mode 3
debug grid
cpu graph
sync graph
display info
bandwidth stats
draw timers
adjustment buttons
fps
player pos


overlay_grid[10][4]

overlay_grid[0][0]  debug grid on for mode 0
overlay_grid[0][1]  debug grid on for mode 1
overlay_grid[0][2]  debug grid on for mode 2
overlay_grid[0][3]  debug grid on for mode 3

overlay_grid[1][3]  cpu graph on for mode 0
...
...


can set the number of modes from 2 to 4




I think I have most of the client server stuff done...

there is also file play and demo mode to straighten out

push for now...



I want to straighten out the functions in screen overlay





























void show_player_stat_box(int tx, int y, int p)
void show_level_done(void)
void draw_screen_overlay(void)
void set_player_joint_quit_display(int p, int type, int time)
void show_player_join_quit(void)
void sdg_show_column(int col, int &x, int y)
void sdg_show(int x, int y) // server debug grid
void cdg_show(int x, int y) // client debug grid

void draw_top_frame(int p)

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)

void draw_top_display(void)



The very top is

void draw_screen_overlay(void)

it calls:

   show_level_done();
   draw_top_display();
   draw_bmsg();
   show_player_join_quit();


I want it to also call:

draw_top_frame
draw_bottom_frame

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)


and remove top_display...



I want to combine draw_top display text stuff and debug display stuff...

can I call it
draw_on_screen_overlay

it will have sections for server, client, file, common
it will call debug overlays
misc text overlays
waiiting to join
demo mode overlay...

just rename top_display to draw_on_screen_overlay




that was a lot of rearranging...hopefully it's better now:

void draw_screen_overlay(void)
{
   int p = active_local_player;
   int cx = BORDER_WIDTH;
   int cy = BORDER_WIDTH+72;

   al_set_target_backbuffer(display);

   if (LOG_TMR_scrn_overlay) t0 = al_get_time();

   show_level_done();

   draw_bmsg();

   show_player_join_quit();

   draw_top_frame(p);
   draw_bottom_frame(p);

   draw_common_debug_overlay(p, cx, cy);

   if (ima_server)                     draw_server_debug_overlay(p, cx, cy);
   if (ima_client)                     draw_client_debug_overlay(p, cx, cy);
   if (players[0].control_method == 1) draw_demo_debug_overlay(p, cx, cy);

   if (LOG_TMR_scrn_overlay) add_log_TMR(al_get_time() - t0, "scrn_overlay_all", 0);
}

do some testing and make sure demo mode is working
display stuff draws on border...fixed...
demo mode misc...good..

single player..good

fix pos and backgrounf for draw profile timers..done..
test client...
fix bandwidth...done
why is packets per sec rx so high?? fixed

what about the space after the debug grid?
if not used can be move everything else up?

I guess it all depends on what order I draw things in..

first:
debug grid
specific misc

last:
display
timers
bandwidth


common does in this order:
display
profile
cpu

client does in this order:
debug grid
sync graph
snyc adjust
misc
bandwidth

server does in this order:
debug grid
adjust
misc
bandwidth

demo does in this order:
misc


so if I just switch common to after specific, then make debug grid part of the cy stuff....


OK this is all looking good

If everything is on, this is the order it shows in:
debug grid
misc
bandwidth
display
profile

I just have server left to do:
make debug grid like client..done...

server adjust widget... where should i put it?

on the right like client?

just above cpu...done..


the only thing I still want to test is where late cdats are drawn in flashing on bottom frame...

I need to manually adjust offset till I get late..done and it lokks great..

in demo mode stuff overwrites the player array...fixed...

now in settings:
make a default button
reduce the number of debug states

the samllest screen size that the entire settings thing fits on is 400x400..


I am finally done with all this debug overlay stuff...it looks pretty good too.

Now to clean up that mess I made with the drawing....

In loop it is fine, just one call to mwDW

The class takes care of
drawing
profiling and averaging
printing screen overlay of results
plus all the optional stuff that didn't work out as planned

It all looks good...logging annd overlay work...the rest has been disabled...


An important question I need to ask?  Do you feel lucky, punk?

I have disabled all frame skipping.  I expect bad things to happen if cpu hits 100%.

What actually happens? Should I try to do something about it?

My rationale was mostly this:

99% of the time, the reason we will not be able to draw is that the draw function takes too long.
It is exceeding rare that the other part of the code is the limiting factor.

I still want to do soemthing about it though...

But what?

I have made it possible to disable with fine control all the bad things in screen overlay.

What about drawing every other frame, just doing the frame skip like we used to?
I can have a mode where I draw thing as simple as possible..

I would like to automatically play all the demo levels and record info about what timing profiles they have...
not every frame, but lets say the average of the last 10s

then I could try out some new economical draw routines

One that comes to mind right away is lifts.

I could draw lifts using much less resource than I do now.


I should just make a global int eco_draw...

be able to toggle it on and off and see what I can do...

I have made a global;
extern int eco_draw;
saved in config
toggle with F2
display on bottom frame...

yay!

now lets test it in draw lifts..


level 155 with 39 lifts with 37 steps each
1400 circles

4.7 ms 3 circles
2.4 ms 1 circle
1.3 ms 0 circles

stick in on 0 for now and test rects..

0.19 1      filled rect
0.20 1      filled rounded rect
0.51 10 not-filled rounded rects and 1 filled not-rounded

that is quite an impressive change..

total:
4.96 original
0.99 eco

5 times faster...


lets try this shit on a 4230
level 13
8.5 ms original
1.5 ms eco_draw

level 155
125 ms original
26 ms eco_draw

nice... now what else can I try to eco?

I think pmsg are a resource hog....

lets make a test level...copy 1...

level 154 has 105 messages
1.99 ms original
1.62 ms force all frame sizes over 1 to be 1

when the text is commented out
0.58 orig
0.19 eco

1.44 for text alone


what can I do?

I could draw them only once...
make a bitmap, draw the frame and text, then just draw the bitmap in the future...

maybe I could pre_calc line_height, so I don't have to do it every time


removing just the call to al_draw_multiline_text:
0.65 orig
0.28 eco_draw

1.34 just for al_draw_multiline_text:

I don't think that I can optimize this any further...
unless I predraw on bitmaps...

test on 4230...
level 154 with draw disabled
15 ms orig
5 ms eco_draw

draw enabled:
29 ms orig
19 ms eco_draw

it takes 14ms to draw text alone...


what are some other candidates?

things that draw rectangles, especially rect with diag lines
make a level with block damages and 10x10 rects...

level 157
50 block damage with 10x10 rect with diag...
1.15  ms orig
thats not too bad....
33 ms on 4230


what about vinepods?
they draw the entire vine every frame
level 158
10 vinepods
0.01 stationary
1.46 when fully extended

4230:
0.2 ms stationary
41  ms when fully extended

what about explosions??

figure out how to tell how much cpu time an explosion takes
- time drawing the circles
- time erasing blocks

so far the only thing I have been able to eco draw is
lifts
lift_lines
message frames



I am thinking that I should just say fuck it to the old 4230...I don't care if the game will run on it.

I still need to do something though when cpu hits 100%

what specs are the 4230's

64 bit win7 sp1
core2 T5500 @ 1.66GHz
2G RAM
Intel Mobile 945 Express
256M video memory







testing...


e6403 server on eidnet
ping 25-30


client 1 - m36
getting late cdats, no matter what offset I use

client 2 - scat
getting late cdats on server, but server never show any for late cdats last sec..
and client does not show any because lcls is what is being sent back and server thinks it is zero...


on server cdsy is about -35 for both clients, this seems normal
gmav of 4-8 for m36 and follows offset changes
but gmav is always zero for scat?

am i missing some things here, only done for first client?

the game is jumpy as ecxpected, late cdats and all...

but why?


I am using a tally for late_cdats last sec, and guess what?...I need one for each player

make them then...
extern mwTally mwT_late_cdat_last_sec[8];

extern mwTally mwT_game_move_dsync_avg_last_sec[8];



I think the late cdats can be explained by gmav


when offset is 10+ping sometimes it varies and you get late cdats
increasing to 20 gave more of a buffer and no more late...
well they were very rare....

look into this more...

I'm thinking that with state_freq 2 there is a pretty small window that client input can arrive in...

I want to make some logs and investigate...

make a function that returns a complimetary contrasting color.

use when you want to draw on the frame...

test it with version...looks good, now used whenever I draw on the frame.. I like it better that the yellow I was using before..







I want to get rid of the old proc_controllers();

136 matches..

I think most of the time, I am waiting for input, or a key to be released ...

in those case, a straight replacement with mwEQ.proc_event_queue would work...

other times, the menu_timer_block thing is being used...


down to 135...


I going to do a global replace for things like... while () proc_controllers()

proc_controllers()
mwEQ.proc_event_queue()
proc_event_queue_menu()


this is a replacement for when I want a timer

      while (!program_update) mwEQ.proc_event_queue();
      program_update = 0;

but then I'll never get the 3's to fire.. use 0 instead



in visual_level I also want the controls to be checked

add these two lines to peq...
no, I don't think I will...
   // only do key check for active local player


   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);

   if I want to do that I'll just make a wrapper
   that does both...

   for menu and visual level select...


    while (!menu_update) mwEQ.proc_event_queue();
    menu_update = 0;




e_bitmap.cpp done and checked
e_fnx.cpp done and checked
e_lift.cpp done
e_pde.cpp done
e_sliders.cpp done
e_visual_level.cpp
mwGraph.cpp
z_args.cpp done
z_log.cpp done
z_log.cpp done  // can't cancel splash screen??


edit_pmsg_text looks a little funny


0   - proc_controllers()
147 - mwEQ.proc_event_queue()
17  - proc_event_queue_menu()

officially gone!!!
void proc_controllers(void)
{
   int menu_timer_block=1;
   mI.key[ALLEGRO_KEY_PRINTSCREEN][0] = 0; // hack to make PRINTSCREEN key work properly
   key_pressed_ASCII = 0;

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if ((ev.type == ALLEGRO_EVENT_TIMER) && (ev.timer.source == mnu_timer)) menu_timer_block = 0;
            else proc_events(ev);
         }
      }
   }

   proc_keys_held();
   function_key_check();

   // only do key check for active local player
   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);
}


key_pressed_ASCII does not work as 'press any key' beacuse it only has a value for the frame it was pressed on..

I can't use it to cancel splash screen anymore until i added a hack

when the event happens, I now also trigger the menu_update and it works!!

   if (ev.type == ALLEGRO_EVENT_KEY_CHAR)
   {
      key_pressed_ASCII = ev.keyboard.unichar;
      serial_key_check(key_pressed_ASCII);
      menu_update = 1;
      //printf("key_pressed_ASCII:%d\n", key_pressed_ASCII);
   }

go the fuck to bed!!


20230205 11:46 PM


20230207 4:52 AM

still can't escape from level editor

145 - mwEQ.proc_event_queue()

what are my key array things?
0 = pressed
1 = pressed last frame
2 - just pressed this frame
3 - just released this frame


do I need to document the program flow for level editor?

I would be nice...
and I can rename mWindow also...

done..now mwWindow
decided not to change all >500 referneces to mW[] that can stay



so what is the process of level editor?

it is started by calling:
edit_menu(start_level)

edit_menu sets some stuff up, then does this loop

   while (mW[8].active)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) cm_process_mouse();
      cm_process_keypress();
   }


cm_redraw_level_editor_background();
- mwEQ.proc_event_queue
- does the delay (currently by calling mwEQ.proc_event_queue and waiting on program_update)
- gets new background
- draws lifts, enemies, items
- draws overlay specific to mode
- gets new screen buffer


if (!mw_cycle_windows(0)) cm_process_mouse();
- processes and draws all active windows for this mode
- if the mouse is not on any window, process mouse for background



cm_process_keypress();
custom handler for em and ovw
but mostly all ESC tries to quit the entire level editor

I have simplified this now...
- still have a custom handler for em and ovw
- in any other mode ESC quits
that seems to work good now

removed up and down from ovw

em_keypress custom...all it did was check for hotkeys for lists...removed...

so now it is even simpler:
cm_process_keypress();
- runs custom handler for ovm
- checks for ESC in all modes for quit
- runs the exit dialog for last chance to abort or save before quit


I think that is all I have time for today...

add this to level_editor_process.txt and push...





I think there is something in zz animation sequence used by enemy killed that I need to fix...done

I want a new name for zoom full screen

how about selection edit?

main edit
selection edit
group edit
object viewer
tile helper


I like it...

how to rename:

file:

old e_editor_zfs
new e_edit_selection


the prefices I have...

em
ge
ovw
use es where I used to use zfs

I think it is all done...

rename group_edit_windows to just group_edit
that was easy, I think it was mostly just the filename...

now object_viewer_windows to just object_viewer

done...

now I have:
e_editor_main.cpp
e_edit_selection.cpp
e_group_edit.cpp
e_object_viewer.cpp

and the prefixes:
em_
es_
ge_
ov_



changed the behaviour of cm_redraw_level_editor_background..

old:
mwEQ.proc_event_queue and block, waiting for program_update
draw

new:
mwEQ.proc_event_queue
if program_update, draw
no blocking...

seems to work good


I want to make the file mwWindow only have functions from that specific class

any common files put in a seperate file e_mw_common.cpp


what calls draw?
.draw(
only one thing:
- cycle windows


how about from within the class? none!

nice! so there is only one single point of entry...

well cycle windows probbaly has many, it draws them all...

calls to cycle_windows(int draw_only)
- 1 call in editor_main (main loop)           (draw_only = 0)
- 2 calls when moving or resizing windows     (draw_only = 1)
- 1 call when blocked in tmenu                (draw_only = 1)
- 1 call when re-arranging ge list items      (draw_only = 1)
- 1 call running lifts                        (draw_only = 1)
- sliders has 2 calls when moving slider bars (draw_only = 1)

OK, this is all coming together....







I was thinking about making a mwWindowManager class to handle all of the windows as a group...

I am not sure what I would gain from that...

what functions would be a part of it:

void cm_get_block_position_on_map();
void cm_process_scrolledge(void);
void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
void cm_get_new_box(void);
void cm_redraw_level_editor_background(int mode);
void cm_process_mouse(void);
void cm_process_keypress(void);
int cm_redraw_level_editor_background(void);
void set_windows(int mode);
int is_mouse_on_any_window(void);
int mw_get_max_layer(void);
int mw_cycle_windows(int draw_only);


not these:
void cm_process_menu_bar(int draw_only);
int cm_draw_filter_buttons(int x1, int x2, int y1, int mode, int draw_only);
void cm_draw_status_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);
void cm_draw_selection_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);



that is actually quite an impressive list of functions that could all be rolled into a class..
as far as the data is concerned, it's almost entirely just the window objects..


imagine that...

the entirety of level editor in one class, one instance of that class, one object...
it is very tempting...


there is already very few globals for level editor...

one thing I am anticpating having problems with (because I have run into it before)
I want to make mwWindowManager contain the array of mwWindows

It should be possible, but I get errors about muliple definitions whenever I try.

I think I could solve it by using pointers to objects, but I have been trying to stay away from dynamically creating things...

started making the frameworks...


make an array of 10 pointers to mwWindows

when I construct a new mwWindowManager, dynamically allocate the 10 mwWindows


this is what I have so far:


// mwWindowManager.h
class mwWindow{};
#define NUM_MW 10
class mwWindowManager
{
   public:
    mwWindowManager();  // constructor
    ~mwWindowManager(); // destructor
//    mwWindow * mwW;
    mwWindow * mwW[10];
};

// mwWindowManager.cpp
#include "pm.h"
#include "mwWindowManager.h"
mwWindowManager::mwWindowManager()  // constructor
{
   //mwW = new mwWindow[10];
   for (int i=0; i<10; i++)
      mwW[i] = new mwWindow;
}
mwWindowManager::~mwWindowManager()  // destructor
{
   //delete [] mwW;
   for (int i=0; i<10; i++)
      delete mwW[i];
}

what next?


where do I create and destroy mwWindowManager?

at the start and end of edit menu

statically allocated at the start:
mwWindowManager mWM;

it should automatically get destroyed when it goes out of scope


I'm still getting stupid multiple definition errors...

I'm going to experiment with header guards...

maybe I don't have to use dynamic after all??





Use header guards in all your header file and declare a global variable in .c file and declare extern to that global variable in a header file.

#ifndef HEADER_FILE_NAME_H    /* if not defined already */
#define HEADER_FILE_NAME_H
extern wchar_t szClassName[];
#endif


omg that was excactly what I was looking for!

now I can use statically define varaibles...


create at the start of edit menu:
mwWindowManager mwWM;

class mwWindowManager
{
   public:
   mwWindowManager();  // constructor
   ~mwWindowManager(); // destructor
   mwWindow mwW[10];
};

now what?

start copying things over?

   void cm_get_block_position_on_map(void);
   void cm_process_scrolledge(void);
   void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
   void cm_get_new_box(void);
   void cm_redraw_level_editor_background(int mode);
   void cm_process_mouse(void);
   void cm_process_keypress(void);
   int cm_redraw_level_editor_background(void);

   void set_windows(int mode);
   int is_mouse_on_any_window(void);
   int mw_get_max_layer(void);
   int mw_cycle_windows(int draw_only);

all these have been added


now what?

make my own loop()
i can even call it loop...done

started renaming functions that are part of the class...
could be easier if I comment out the old ones and find out where they are used...
did a shit load of that...
now its mostly all patched in...

did it get any simpler?

still need to clean up some stuff...

pm.h defines for all removed functions in e_window common..done

what to do with the 4 functions left in that file...bite the bullet and move all to the class?
right now window manager class is 600 lines

170 menu
80 filter
50 status
200 selection
-----
520 lines

the window varaibles are all long now, especially outisde of class like mwWM.mW[4].blah
'mwWM.mW' is used 420 times in the project

some things make better sense as part of the manager class like:
set_focus.done
level_editor_mode.done

can I reimplement the saving?

20230211
move level_editor_mode from mwWM.mW[8].level_editor_mode to mwWM.level_editor_mode
done...

save_mW..done

I am using while (mW[8].active) to control when the entire level_editor process ends

what if I change it to something that window manager owns? active..done..

OK now that I have all that done...I want to continue with the documenting of the level editor process...

first what have I changed?..fixed all

fixed enemy shapes not all showing in ge list

but ge_controls never show...why?..deleted mw.pm and all good..


maybe I could make a menu option:

auto save level editor state
reset level editor saved state

and maybe also if level editor crashes on entry to reset state..

under the view menu:

Autosave level editor state
Reset level editor state

done...but did not do the auto reset if something went wrong...too hard to tell??
how about I have a variable that gets set when level editor starts
and reset when level editor ends normally

then next time it starts if it did not exit noramlly the prviuos time, reset state..

I could manually save this in config
level_editor_exit_flag

at start:

if set to 1, reset state
set to 1 and save

at normal exit
set to 0 and save


or:

at start, delete mw.pm
only save if normal exit..
this looks a lot simpler

whenever I do a load, delete it there...done...
hard to test, eh?


what next?

can I make these part of the window manager class? yes..done


// ------------------------------------------------
// ----- level editor unsorted --------------------
// ------------------------------------------------
extern int swbl[NUM_SPRITES][2];

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

extern int gx; // mouse position relative to scaled level background
extern int gy;
extern int hx;
extern int hy;


#define NUM_OBJ 600
// list of objects to edit as a group
extern int obj_list[NUM_OBJ][3];
extern int obj_filter[5][20];


extern int swbl[NUM_SPRITES][2]; ..done..moved to mw class
extern int obj_list[NUM_OBJ][3]; ..done
extern int obj_filter[5][20];..done
extern int gx; done
extern int gy; done

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

all done...


make logo its own class...
mwLogo

I have two very close function I would like to merge:
an is for menu
an3 is for help

can I start using it yet?

I want to put these globals in the class...

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;


I have gotten rid of the old file z_logo.cpp

I forget to take adjust and test!!!..fixed


now work on the globals

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;
those are all done...


I should put these in the .cpp and .h for logo...

not the class? why not?

int show_splash_screen = 1;
int splash_screen_done = 0;
put in class and done...

I think I am all done with logo...


what about bottom message?

that is a good candidate for a class...

mwBottomMessage
mwBM

make it declare, create and destroy its own bitmaps...


   // bottom msg bitmaps
   for (int x=0; x<20; x++)
   {
      bmsg_bmp[x] = al_create_bitmap(800, 20);
      al_set_target_bitmap(bmsg_bmp[x]);
      al_clear_to_color(al_map_rgba(0,0,0,0));
      bmsg_bmp2[x] = bmsg_bmp[x];
   }


actually that does not work...
I can declare pointers in the class, but if I try to create bitmaps at the same time it dies,
probably because allegro is not initialized yet.

So I just create them when I create all the other bitmaps, and it works...

all the fuinctions have been moved to the class and erased from screen_overlay..

now I have three more variables to add to the class:

extern int bottom_msg_on;
extern int bottom_msg;
extern int bmsg_index;

done...


now how about demo mode?

mwDemoMode
mWDM


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
extern ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
extern int demo_played[100];
extern int num_demo_filenames;
extern int demo_mode_loaded;
extern int demo_mode_on;
extern int demo_mode_countdown;
extern int demo_mode_countdown_val;
extern int demo_mode_countdown_reset;
extern int demo_mode_enabled;
extern int demo_mode_last_frame;
extern int demo_mode_config_enable;
extern float demo_mode_overlay_opacity;

I think demo mode is done...

now demo mode starts immediately??


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
int demo_played[100];
int num_demo_filenames = 0;
int demo_mode_loaded = 0;
int demo_mode_enabled = 1;
int demo_mode_on = 0;
int demo_mode_countdown_val;
int demo_mode_countdown_reset = 2400;
int demo_mode_last_frame = 0;
int demo_mode_config_enable = 1;
float demo_mode_overlay_opacity = 0.1;


demo is now done...


OK the huge one:
display

mwDisplay
mwD

created the class and copied all these functions in:

   void show_bitmap_flags(int flags);
   void show_pixel_format(int df);
   void show_display_flags(int flags);
   void show_display_options(void);
   void show_display_orienation(void);
   void show_fullscreen_modes(void);
   void auto_set_display_transform_double(void);
   void set_saved_display_transform(int sdt);
   void cycle_display_transform(void);
   void set_display_transform();
   void show_disp_values(int fs, int disp, int curr, int wind, int full, char *head);
   void show_display_adapters(void);
   int init_display(void);
   void proc_display_change(void);
   void save_display_window_position(void);
   void proc_display_change_tofs(void);
   void proc_display_change_fromfs(void);


it compiles and works!!

now for all these varaibles:


extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // current (either wind in windowed mode or full in fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

extern int disp_x_full; // fullscreen  (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;

extern int SCREEN_W;
extern int SCREEN_H;
extern int WX;
extern int WY;
extern int fullscreen;
extern int display_adapter_num;
extern float WX_shift_speed;

extern int viewport_mode;
extern int viewport_show_hyst;
extern float viewport_x_div;
extern float viewport_y_div;

// used to only redraw a region of background to increase fps
extern int level_display_region_x;
extern int level_display_region_y;
extern int level_display_region_w;
extern int level_display_region_h;

extern int display_transform_double;
extern int display_transform_double_max;
extern int saved_display_transform_double;
extern int show_dtd;

make a method to replace these:
         if (mwD.fullscreen) mwD.proc_display_change_fromfs();
         else                mwD.proc_display_change_tofs();
done...

make my own set_clipping_rect...done
al_set_clipping_rectangle

more vars?

extern float scale_factor;
extern float scale_factor_current;
extern float scale_factor_inc;
extern int show_scale_factor;
extern int scale_factor_holdoff;

done...
what about set_scale_factor?..done
what about proc_scale_factor_change()?..done


any more?

I'm thinking about adding these:

// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;


I have something similar in logo

   float mdw_map_logo_x;
   float mdw_map_logo_y;
   float mdw_map_logo_scale;

   float mdw_splash_logo_x;
   float mdw_splash_logo_y;
   float mdw_splash_logo_scale;


and I have a function that sets all this up:

void set_map_var(void)
{
   // determine menu_map_size and position
   int y_size = mwD.SCREEN_H-160;
   int x_size = mwD.SCREEN_W-260;
   if (y_size < x_size) menu_map_size = y_size;
   else menu_map_size = x_size;
   if (menu_map_size < 10) menu_map_size = 10;
   menu_map_x = mwD.SCREEN_W/2-(menu_map_size/2);
   menu_map_y = 140;

   // splash screen logo position
   mwL.mdw_splash_logo_x = mwD.SCREEN_W/2;
   mwL.mdw_splash_logo_y = mwD.SCREEN_H/2;

   // splash screen logo size
   float min_d = mwD.SCREEN_H;  // find miniumum dimension
   if (mwD.SCREEN_W < mwD.SCREEN_H) min_d = mwD.SCREEN_W;
   mwL.mdw_splash_logo_scale = min_d / 500; // 400 is the exact size, make it bigger for padding

   // map screen logo position and size
   float sp = menu_map_x - BORDER_WIDTH;    // how much space do I have between the map and the screen edge?
   mwL.mdw_map_logo_scale = sp / 500; // 400 is the exact size, make it bigger for padding
   mwL.mdw_map_logo_x = BORDER_WIDTH + sp/2;
   mwL.mdw_map_logo_y = menu_map_y + mwL.mdw_map_logo_scale * 200; // align top of logo with top of map

   // this is the link from splash to map
   mwL.mdw_logo_scale_dec = (mwL.mdw_splash_logo_scale - mwL.mdw_map_logo_scale) / 320;
   mwL.mdw_logo_x_dec = (mwL.mdw_splash_logo_x - mwL.mdw_map_logo_x) / 320;
   mwL.mdw_logo_y_dec = (mwL.mdw_splash_logo_y - mwL.mdw_map_logo_y) / 320;

//   printf("slx %f sly %f\n", mdw_splash_logo_x, mdw_splash_logo_y );
//   printf("mlx %d mly %d\n", mdw_map_logo_x, mdw_map_logo_y );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec, mdw_logo_y_dec );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec*320, mdw_logo_y_dec*320 );
}

this leads me to the place where I figure out what goes in display, screen, and bitmaps

display - for all the setup
screen - for actually drawing on the screen

screen should have:
all the level draw functions
all the screen overlay things

screen should not have:
create and load bitmaps
rebuild bitmaps
load fonts

what if I renamed e_bitmap to e_bitmap_tools or something like that...done

then make a class mwBitmap mwB
this class will have all the bitmap pointer declarations
have methods to create load, rebuild bitmaps
might as well stick fonts in there too...


done and I have moved

   void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size);
   void load_fonts(void);
   void create_bitmaps(void);
   void rebuild_bitmaps(void);

and it runs...
what else?
load tiles is in file.cpp and it called after more stuff is set up...

timestamps...just get it out of the way...done
packetbuffer..just make a header for n_packet.cpp and stick it in there..done

I might leave it there..

what variables do I have?

extern ALLEGRO_FONT *font0;
extern ALLEGRO_FONT *font;
extern ALLEGRO_FONT *font2;
extern ALLEGRO_FONT *f1;
extern ALLEGRO_FONT *f2;
extern ALLEGRO_FONT *f3;

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern int sa[NUM_SPRITES][2];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;


do the fonts, but also name them better:

extern ALLEGRO_FONT *font0; // built-in thick 8x8
extern ALLEGRO_FONT *font;  // pristine, my new fav 8x8
extern ALLEGRO_FONT *font2; // pristine, in 16x16 format for bmsg
extern ALLEGRO_FONT *f1;    // achafont
extern ALLEGRO_FONT *f2;    // saucer
extern ALLEGRO_FONT *f3;    // pixel gosub

what will they be now:

mF.bltn
mF.pr8
mF.pr16
mF.sauc
mF.acha
mF.pixl

I want them to have their own class file mwFont mF
ok that's done.. now the grueling task of replacing all font references...

font0 mF.bltn  .done
font  mF.pr8
font2 mF.pr16  .done
f1    mF.acha  .done
f2    mF.sauc  .done
f3    mF.pixl  .done

font has 667 occurances!!

I am all done with fonts...

add these to mwBitmap

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



   ALLEGRO_BITMAP *tilemap;
   ALLEGRO_BITMAP *btilemap;
   ALLEGRO_BITMAP *ptilemap;
   ALLEGRO_BITMAP *dtilemap;
   ALLEGRO_BITMAP *M_tilemap;
   ALLEGRO_BITMAP *M_btilemap;
   ALLEGRO_BITMAP *M_ptilemap;
   ALLEGRO_BITMAP *M_dtilemap;

   ALLEGRO_BITMAP *tile[NUM_SPRITES];
   ALLEGRO_BITMAP *btile[NUM_SPRITES];

   ALLEGRO_BITMAP *player_tile[16][32];
   ALLEGRO_BITMAP *door_tile[2][16][8];

   ALLEGRO_BITMAP *level_background;
   ALLEGRO_BITMAP *level_buffer;


bitmaps has quite a lot done...

I could still put more like:

extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;

but I am not sure they belong...



lifts is next....

e_lift.cpp 500 lines
z_lift.cpp 500 lines
pm.h

// ------------------------------------------------
// ---------------- lifts -----------------------
// ------------------------------------------------
extern int num_lifts;
extern char lift_step_type_name[10][10];
extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};

// e_lift.h
al_fixed lift_get_distance_to_previous_move_step(int lift, int step);
void show_all_lifts(void);
void lift_step_set_size_from_previous_move_step(int lift, int step);
int lift_find_previous_move_step(int lift, int step);
void erase_lift(int lift);
void delete_lift_step(int l, int step);
void lift_setup(void);
int create_lift(void);
void move_lift_step(int lift, int step);
int get_new_lift_step(int lift, int step);
int insert_lift_step(int lift, int step);
void insert_steps_until_quit(int lift, int step);
void set_all_steps(int l, int s, int what);
void step_popup_menu(int lift, int step);
int draw_current_step_buttons(int x1, int x2, int y, int l, int s, int d);
void draw_step_button(int xa, int xb, int ty1, int ty2, int l, int s, int rc, int d);
int draw_steps(int x1, int x2, int y, int lift, int current_step, int highlight_step, int d);

// z_lift.h
int construct_lift(int l, char* lift_name);
void clear_lift(int l);
int construct_lift_step(int l, int s, int type, int x, int y, int w, int h, int val);
void clear_lift_step(int l, int s);
void set_lift_to_step(int l, int s);
int is_player_riding_lift(int l);
void draw_lift_line(int l);
void draw_lift(int l, int x1, int y1, int x2, int y2);
void draw_lifts();
void set_lift_xyinc(int d, int step);
int lift_check_prox(int l, int pd);
void move_lifts(int ignore_prox);

what is my plan here?

I still want lifts and lift_steps accessible

I think I still want the seperation of e_lifts and z_lifts

One possibility:
- put both in one file
- make one header file

that would be easy

cons:
the one file would be >1000 lines
nbd

now I only have one file: z_lift.cpp
one one header z_lift.h

now pm.h is less than 100 lines!!

523 function defs
200 lines global vars

some low hanging fruit...
sliders, should just get a h file

renamed to mwWidget, even though it wont have a class, its a generic group




here is some low hanging fruit:


// n_client.h
void client_read_packet_buffer(void);
void client_fast_packet_loop(void);
int  ClientInitNetwork(const char *serveraddress);
void ClientExitNetwork(void);
int  ClientCheckResponse(void);
int  ClientReceive(void *data);
void ClientSend(void *data, int len);
void client_flush(void);
int  client_init_join(void);
void client_exit(void);
int  client_init(void);
void client_read_game_move_from_packet(int x);
void client_send_ping(void);
void client_process_stdf_packet(double timestamp);
void client_apply_dif();
void client_block_until_initial_state_received(void);
void client_process_sdat_packet(void);
void client_process_serr_packet(void);
void client_proc_player_drop(void);
void client_control(void);
void client_local_control(int p);
void process_bandwidth_counters(int p);

// n_network.h
extern int NetworkDriver;
int NetworkInit();

// n_packet.h
extern char packetbuffer[1024];
extern int packetsize;
void set_packetpos(int pos);
int get_packetpos(void);
void Packet(const char *id);
int PacketRead(const char *id);
void PacketAddByte(char b);
char PacketGetByte(void);
void PacketAddString(char*);
void PacketReadString(char*);
void PacketPut1ByteInt(int b);
void PacketPut2ByteInt(int b);
void PacketPut3ByteInt(int b);
void PacketPut4ByteInt(int b);
int PacketGet1ByteInt(void);
int PacketGet2ByteInt(void);
int PacketGet3ByteInt(void);
int PacketGet4ByteInt(void);
void PacketPutDouble(double);
double PacketGetDouble(void);

//n_server.h
int ServerInitNetwork(void);
void ServerExitNetwork(void);
void ServerListen(void);
int ServerReceive(void *data, int *sender);
void ServerBroadcast(void *data, int len);
void ServerSendTo(void *data, int len, int who, int player);
void server_flush(void);
int  server_init(void);
void server_exit(void);
void server_send_dif(int p);
void server_create_new_state(void);
void server_rewind(void);
void server_send_sdat(void);
void server_proc_player_drop(void);
void server_proc_cdat_packet(double timestamp);
void server_proc_stak_packet(double timestamp);
void server_proc_cjon_packet(int who);
void server_control();
void server_fast_packet_loop(void);

done..

give bullets a header file..done

visual_level..done

396 function def
167 globals

I want to make game_moves array a class...maybe...






   if (players[0].level_done_mode == 5) // skippable 15s timeout
   {
      if (!ima_client)
      {
         if (have_all_players_acknowledged()) players[0].level_done_timer = 0; // skip
         for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }
      }
   }


i want to move this to have_all_players_acknowledged()...should be pretty straightforward



            for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }

GMA works...


level_header should only live in file.cpp..done..


I have intoduced a bug somehwere...

when I resize the screen, I lose screen_overlay...maybe just the fonts..they need to be reloaded also? yes. fixed..



move these declatations to logo...done

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

tile_helper.h ..done
pde.h..done


I am thinking of making color a class.. mwColor mColor
yes...

old:
mColor.pc[15]

new:
mColor.c[15];

or:
mColor.white;

it will return an actual ALLEGRO_COLOR..

I will also have all the color names in the class

maybe later I will extend it to have more fading than just the 16 preset levels

also it will have the flash colors

to start with, and replace all occurance of color...how many?...1143!...
I'll just do a straight replace of mColor.pc with mColor.pc

flash_color is not actually a color, its an index

It compiles and runs!!
now for some more features..
add color names...done..

add specific colors like:

mColor.white..etc..done...

make flash colors actual colors instead of indexes..done, but most use case still use the indexes...


pm_events .. the one used in the game for triggers and such...

make it its own class. It has a lot going on...
mwPMEvent mwPME

I think I have it all in there and working...



mouse
keys
joystick
event
timers
queue

lets call these mwInput
mouse
keys
joystick


OK now I have a huge search and repalce to do:


extern char skc[64]; // serial key check
extern int skc_index;

extern char *key_names[]; 12-done
extern bool mI.key[ALLEGRO_KEY_MAX][4];  297
extern int key_pressed_ASCII;18-done

extern int mouse_x; 107-done all blind replace
extern int mI.mouse_y; 124- done all blind
extern int mouse_z; 4-done
extern int mouse_dx; 4-done
extern int mouse_dy; 5-done
extern int mouse_dz; 12-done

extern bool mI.mouse_b[5][4]; 183 blind

clear_keys
proc_keys_held


globals < 100 !!

what esle can I add to mwInput?
function_key_check()..done

all done from control.cpp




put event queue and timers into mwEventQueue
do it...you've come too far to stop now!!

now add timers...

I have about 40 globals variables left!!!

put animation_sequence array in with bitmaps...
also rest and update...done...

what aboout sa, shape atributes?  same place? yup..done

last of the bitmaps there too...done


I'm gettting down to the last of them

I want something like a class called mwProgramState to catch a lot of things like:


add to bmsg:
extern int game_event_retrigger_holdoff[10];
extern float game_event_retrigger_holdoff_tally[10];


add to logo
// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;
done...


make this a part of menu..
extern char global_string[20][25][80];
menu.h
done..
setup menu



I think I am ready to make all of these part of a class called mwProgramState

extern int program_state;
extern int new_program_state;
extern int old_program_state;
extern int older_program_state;

extern int top_menu_sel;
extern int main_loop_exit;

extern int autosave_level_editor_state;
extern int level_editor_running;
extern int help_screens_running;
extern int visual_level_select_running;

// frame_speed, frames per second, mwPS.frame_num stuff
extern int speed_testing;
extern int frame_speed;
extern int speed_control_lock;
extern int mwPS.frame_num;

extern int show_debug_overlay;
extern int show_player_join_quit_timer;
extern int show_player_join_quit_player;
extern int show_player_join_quit_jq;

extern int eco_draw;

// temp testing variable
extern int pct_x;
extern int pct_y;
extern char msg[1024];

// some global strings
extern char level_filename[80];
extern char local_hostname[80];
extern char pm_version_string[80];
extern char al_version_string[80];



need to fix level_filename later...vl uses is to get a filename from make_filename....



there is some weird shit going on where I work with filenames...
I should examine as fix it...

the first thing I did was get rid of the global level_filename...


my base functions are:

int save_level(int level_to_save)
always returns 0

int load_level(int level_to_load, int load_only)
returns 1 on success, 0 on failure

      if (!load_only)
      {
         valid_level_loaded = 1;
         lift_setup();
         for (int x=0; x<500; x++)
            if (item[x][0]) // only if active set x y
            {
               itemf[x][0] = al_itofix(item[x][4]);
               itemf[x][1] = al_itofix(item[x][5]);
            }
         level_check();
         init_level_background(0); // draw blocks on level_background
         mwB.reset_animation_sequences();
         //set_player_start_pos(0, 0);
      }


they both take an integer level num and call make filename..

To print with padding by Zeros, we use the following format specifier with the printf() statement,

    %d : No padding.
    %01d : 1 digit padding with zeros.
    %02d : 2 digits padding with zeros.
    %03d : 4 digits padding with zeros.

replaced make_filename with:

char lf[255];
sprintf(lf, "levels/level%03d.pml", level_num);

now load and save level make their own filename
save level does not return anything...



load_level_prompt()

is called from level_editor popup menu and from regular menu..

also from command line but that never works...

what if command line is passed a level that deosn exist?
level loading error..


edit_menu is called by:

pm -e (uses play_level)
pm -e num (uses num if 0 < num < 400)
game_menu (uses start_level)

in edit menu if passed 0 it would run the prompt, but that never occurs...


I am happy with how load level prompt works

save_level_prompt..good...

le popmnu new
le regmnu new
le regmnu save_as

what is left?

why does level viewer not work?
It just gives errors for every level it cannot find...
can I make that optional? yes I can...

not sure if the level viewer copying thing is working...it is..


msg...784 matches...that's just lazy

where can I hide it? z_menu...just like global_string...



Now I have this left for global variables:


// items
int item[500][16];      // item ints
al_fixed itemf[500][4]; // item fixeds
int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];
char pmsgtext[500][500] = {0};
int item_tile[20];

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
int e_num_of_type[50];
int e_first_num[50];
char enemy_name[100][2][40] = {0};
int num_enemy;
int enemy_tile[20];




// ------------------------------------------------
// ---------------- level -------------------------
// ------------------------------------------------
int l[100][100];
int warp_level_location = 0;
int start_level;
int play_level;
int valid_level_loaded;
int last_level_loaded; // used by level editor and load file to keep track of last level loaded
int resume_allowed=0;
int number_of_starts;
int number_of_purple_coins;


for level I need to make a cpp file or a class
lets just do a cpp file for now..
z_level.cpp and z_level.h


20230212 4:36PM all globals are gone!!
well...at least from pm.h..there are still some in other files but they are only externed where needed...

now I plan to make .h files and move all function prototypes there...

I still have 250 function in 18 files...

tell me again why I would want them spread over 18 files instead of all in one place?

and why would I want 18 more files?...

I now have 100 files...58 cpp and 42 header

Purple Martians Source Code Line Counts [2023-02-12  17:27:41]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2872][  2172][  1734][   605][   167][   438][   533] - z_item.cpp
[  2705][  1951][  1367][   848][   264][   584][   490] - z_enemy.cpp
[  2087][  1755][  1347][   515][   107][   408][   225] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1599][  1448][   207][    56][   151][   220] - mwGraph.cpp
[  1745][  1343][  1124][   319][   100][   219][   302] - z_player.cpp
[  1865][  1334][  1110][   275][    51][   224][   480] - mwWidget.cpp
[  1658][  1222][  1019][   335][   132][   203][   304] - z_fnx.cpp
[  1416][  1140][  1009][   181][    50][   131][   226] - z_menu.cpp
[  1250][  1003][   901][   139][    37][   102][   210] - z_screen_overlay.cpp
[  1281][   963][   834][   188][    59][   129][   259] - e_bitmap_tools.cpp
[  1595][   905][   820][   183][    98][    85][   592] - e_glt.cpp
[  1157][   901][   731][   219][    49][   170][   207] - z_lift.cpp
[  1078][   891][   755][   195][    59][   136][   128] - e_edit_selection.cpp
[  1129][   802][   737][   125][    60][    65][   267] - z_settings.cpp
[   994][   735][   659][   108][    32][    76][   227] - e_fnx.cpp
[   851][   716][   401][   363][    48][   315][    87] - e_editor_main.cpp
[   782][   689][   606][   101][    18][    83][    75] - e_group_edit.cpp
[   874][   657][   621][    99][    63][    36][   154] - z_file.cpp
[   937][   634][   548][   166][    80][    86][   223] - z_screen.cpp
[   765][   616][   559][    92][    35][    57][   114] - n_client.cpp
[   777][   611][   562][   100][    51][    49][   115] - n_server.cpp
[   819][   587][   536][   117][    66][    51][   166] - e_visual_level.cpp
[  1140][   548][   472][   343][   267][    76][   325] - z_args.cpp
[   759][   538][   461][   160][    83][    77][   138] - z_loop.cpp
[   622][   510][   385][   150][    25][   125][    87] - e_item.cpp
[   642][   489][   416][   118][    45][    73][   108] - mwWindowManager.cpp
[   705][   477][   457][    93][    73][    20][   155] - mwLogo.cpp
[   542][   434][   387][    77][    30][    47][    78] - e_window_common.cpp
[   560][   432][   407][    28][     3][    25][   125] - mwInput.cpp
[   588][   416][   191][   258][    33][   225][   139] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   565][   372][   369][    63][    60][     3][   133] - mwDisplay.cpp
[   439][   367][   327][    48][     8][    40][    64] - e_pde.cpp
[   451][   328][   328][    31][    31][     0][    92] - pm.h
[   360][   297][   237][    71][    11][    60][    52] - e_enemy.cpp
[   341][   291][   272][    31][    12][    19][    38] - mwWindow.cpp
[   405][   289][   288][    22][    21][     1][    95] - z_config.cpp
[   308][   221][   180][    56][    15][    41][    72] - mwPMEvent.cpp
[   285][   208][   202][    26][    20][     6][    57] - z_main.cpp
[   303][   198][   173][    81][    56][    25][    49] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   250][   178][   148][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   151][   124][   113][    18][     7][    11][    20] - z_control.cpp
[   146][   117][   115][    11][     9][     2][    20] - z_sound.cpp
[   219][   115][   106][    68][    59][     9][    45] - mwDrawSequence.cpp
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   187][   100][    92][    42][    34][     8][    53] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   117][    85][    77][    13][     5][     8][    27] - mwFont.cpp
[   130][    75][    70][    16][    11][     5][    44] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   106][    65][    59][    12][     6][     6][    35] - mwEventQueue.cpp
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    64][    60][    58][     4][     2][     2][     2] - z_item.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    31][    29][     3][     1][     2][     5] - z_enemy.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
-------------------------------------------------------- - totals
[ 47082][ 34769][ 29614][  8162][  3007][  5155][  9306] - 100 files

On to something else...

what about those defines..kept the ones that worked

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-12  18:26:29]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2876][  2176][  1738][   605][   167][   438][   533] - z_item.cpp
[  2705][  1953][  1369][   848][   264][   584][   488] - z_enemy.cpp
[  2088][  1758][  1350][   515][   107][   408][   223] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1749][  1346][  1127][   319][   100][   219][   303] - z_player.cpp
[  1865][  1335][  1111][   275][    51][   224][   479] - mwWidget.cpp
[  1661][  1225][  1022][   335][   132][   203][   304] - z_fnx.cpp
[  1417][  1142][  1011][   181][    50][   131][   225] - z_menu.cpp
[  1255][  1005][   903][   139][    37][   102][   213] - z_screen_overlay.cpp
[  1287][   968][   839][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1600][   909][   824][   183][    98][    85][   593] - e_glt.cpp
[  1163][   905][   735][   219][    49][   170][   209] - z_lift.cpp
[  1082][   896][   760][   195][    59][   136][   127] - e_edit_selection.cpp
[  1136][   806][   741][   125][    60][    65][   270] - z_settings.cpp
[   998][   738][   662][   108][    32][    76][   228] - e_fnx.cpp
[   856][   721][   406][   363][    48][   315][    87] - e_editor_main.cpp
[   786][   693][   610][   101][    18][    83][    75] - e_group_edit.cpp
[   883][   660][   624][    99][    63][    36][   160] - z_file.cpp
[   941][   636][   550][   166][    80][    86][   225] - z_screen.cpp
[   771][   620][   563][    92][    35][    57][   116] - n_client.cpp
[   781][   613][   564][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1147][   554][   478][   343][   267][    76][   326] - z_args.cpp
[   765][   545][   468][   160][    83][    77][   137] - z_loop.cpp
[   622][   513][   388][   150][    25][   125][    84] - e_item.cpp
[   648][   496][   423][   118][    45][    73][   107] - mwWindowManager.cpp
[   705][   478][   458][    93][    73][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   441][   368][   328][    48][     8][    40][    65] - e_pde.cpp
[   360][   299][   239][    71][    11][    60][    50] - e_enemy.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   409][   291][   290][    22][    21][     1][    97] - z_config.cpp
[   308][   222][   181][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   252][   180][   150][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   219][   117][   108][    68][    59][     9][    43] - mwDrawSequence.cpp
[   130][   110][   110][     5][     5][     0][    15] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   190][   101][    93][    42][    34][     8][    55] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   119][    86][    78][    13][     5][     8][    28] - mwFont.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    86][    76][    74][     4][     2][     2][     8] - z_item.h
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    51][    42][    40][     4][     2][     2][     7] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    39][    37][    37][     1][     1][     0][     1] - z_fnx.h
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47189][ 34913][ 29758][  8153][  2998][  5155][  9278] - 116 files


pm.h has been stripped of all global variables and function prototypes

god help us all...


now, why do lifts need a button from bitmap_editor..


I will replace with a button...but...

the one thing I like about the old button was that they showed a highlight when the mouse was on them


I want to make a new type of button...

text and returns 1 when pressed, just like buttont, but...

this one will show a highlight when moused over
and will draw centered
and will auto size based on text length...

how about all that?..done...


Its time for a push, I shoudl be done for today...


20230212 7:18PM


20230214 4:00AM
remove menu fromn e_bitmap by making msg local to funtions is in done..4x
make DS have static RA's done

PDE could be a class to reduce a few globals
mwPDE mPDE..done...

glt no globals and no msg...done

color done...

cleanup is going well...





remove globals in bullets, can it be made a class?

mwBullets mwBullets

what about mwShots mShots

mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc

why don't I also start here with changing all fixed to floats

how about you do that first?

ebullet fixed to floats
then test with all types of enemies that shoot bullets...
I think I did it...

now make the class...


mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc



to start with just replace variables all the variables with the ones in the class

old:
ebullets[].active
ebullets[].shape

new:
e[].active
mShot.e[].shape

done...

next remove old variable defs..


next change all pbullet refs to class and use floats...

old:
pbullet[][0] - active
pbullet[][1] - player
pbullet[][2] - int x
pbullet[][3] - int y
pbullet[][4] - int xinc
pbullet[][5] - int yinc

new
mwS.p[].active
mwS.p[].player
mwS.p[].x
mwS.p[].y
mwS.p[].xinc
mwS.p[].yinc

done...
now what?
mwShots has been all renamed..only thing left would be to add some bullet functions..done...
void mwShots::fire_enemy_bulletz(int EN, int bullet_ans, al_fixed px, al_fixed py)
void mwShots::fire_enemy_bulleta(int EN, int bullet_ans, int p)
void mwShots::fire_enemy_x_bullet(int EN, int p)
replace deathmatch_pbullets and suicide bullets with shots..done and also made a part of class...
bul

all ref to bullet, bull, bul have been removed from game...

nice....


One thing..my new short class instance names may be kind of cryptic...like mwS for shots
alternatives? mwShot.e[].active
I can always search and replace later


how about changing lifts back to floats?
then items, players, enemies...

make it a class
that constains 2 arrays of structs

what about inheritance?

how many things all have x, y, xinc, yinc

players
enemies
items
lifts
e shots
p shots

how many have active, bitmap
players
enemies
items
e shots
p shots

later


back to lifts..

I also want to add active to lifts

and maybe get rid of level header...
where used?
3 times in fnx, but only for size display..
10 times in file.cpp

when saving level:
- erase level_header
fill from:
   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(1); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   lift_setup();
   level_header[5] = num_lifts;  // num of lifts

when loading level:
    num_lifts = level_header[5];

I want to use a different method of iterating lifts and lose level_header

also turn lifts into a class

also change fixed to floats

also do something about the int versions of x1, y1, x2, y2, width, height

where to start...

iterator:

old:
for (int l=0; l<num_lifts; l++) // iterate lifts

new:
for (int l=0; l<NUM_LIFTS; l++) // iterate lifts
   if (lifts[l].active)


I can have a member of the lifts class that tells me how many lifts are active
and a sort function that pretty much just removes spaces..optional, why bother?
it would break event links if there are any...


added active to lift struct..
now crashes hard when loading any level with lifts...
remove and rethink this...

should I just jump to class?
and change all the variables at that time?
mwLift mwLifts
started the class...


in order to change variables I need to make a shadow variable for lifts (lift steps is not changing)

load old
convert to new
save


old:

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

new:

struct lift2
{
   float x1;
   float y1;
   float x2;
   float y2;
   float w;
   float h;
   float xinc;
   float yinc;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};



I still think I should do this in small steps:
first just add active..

step 1:
make shadow struct array lifts2 with added variable..done


step2
load normal
in glt copy to shadow
modify save to use new struct and new PML_SIZE
run glt..

now all levels are save in new format.

add var to lifts struct
increase PML_SIZE

load all level succesfully!!

remove mod to save...


wow that was a lot to modify save level format...
















Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112928


Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts2    :  5440
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :113088



#define PML_SIZE 384960

+160

#define PML_SIZE 385120



now fix the iterators

start with move and draw...

make a function to get the next empty lift...

like item and enemy..

I have removed all refs to num_lifts...
next:

does erase do the job of closing gaps, or do I need something else?..its good
figure out next and prev in ov..done
re implement num_lifts for display only..done
remove level header completely..not used..next time I re-do level format remove it...
what is going on with ft_? it all seems to work..it still uses ft_level_header but I dont care right now
in es copy and delete seem to be working good..
make a test level and try copy and paste and from disk...
copying 4 lifts works..
clearing lifts only erases half of them...fixed

all this is working so well...
what next??
replace fixed...

all 8 at once?  why not?

step 1
lifts2 has fixed replaced with floats

step 2
old vars
Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120


new vars (lifts2) and remove level_header
Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385040


don't reduce size of PML_SIZE until after re-saving

step 3
void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 4
in glt:

      for (int l=0; l<NUM_LIFTS; l++)
         if (lifts[l].active)
         {
            lifts2[l].x = al_fixtof(lifts[l].fx);
            lifts2[l].y = al_fixtof(lifts[l].fy);
            lifts2[l].w = al_fixtof(lifts[l].fw);
            lifts2[l].h = al_fixtof(lifts[l].fh);
            lifts2[l].xinc = al_fixtof(lifts[l].fxinc);
            lifts2[l].yinc = al_fixtof(lifts[l].fyinc);
            lifts2[l].winc = al_fixtof(lifts[l].fwinc);
            lifts2[l].hinc = al_fixtof(lifts[l].fhinc);

            lifts2[l].active = lifts[l].active;

            lifts2[l].x1 = lifts[l].x1;
            lifts2[l].y1 = lifts[l].y1;
            lifts2[l].x2 = lifts[l].x2;
            lifts2[l].y2 = lifts[l].y2;
            lifts2[l].width = lifts[l].width;
            lifts2[l].height = lifts[l].height;

            lifts2[l].flags = lifts[l].flags;
            lifts2[l].mode = lifts[l].mode;
            lifts2[l].val1 = lifts[l].val1;
            lifts2[l].val2 = lifts[l].val2;

            lifts2[l].color = lifts[l].color;
            lifts2[l].current_step = lifts[l].current_step;
            lifts2[l].num_steps = lifts[l].num_steps;
            lifts2[l].limit_counter = lifts[l].limit_counter;
            lifts2[l].limit_type = lifts[l].limit_type;

            sprintf(lifts2[l].lift_name, lifts[l].lift_name);

         }


step 5
make backup of levels...


step 6
run glt


step 7:
disable glt

you fucked up..go back to step 3

this was wrong....

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}

restored levels from backup...

set this properly:

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 6
run glt

step 7
disable glt

step 8
change load

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
//   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 9:

fix struct declaration

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int active;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};


level_header has been completely removed

now remove the integer shit in lift

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;



step 1
lifts2 has fixed replaced with floats

step 2

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080

don't reduce size of PML_SIZE until after re-saving

step 3

struct lift2
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}



step 4:
in glt do nothing, just load and save




step 5 backup levels

step 6 do glt...



wrong!

restore levels...

in glt copy from lifts to lifts2...



OK now I think I have it:

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080


level_header is completely gone...

lifts have been converted to floats


now working on item fixed to float..


change all these to not even pass x, y..get it from itemfl

         bomb_blocks( i, 1, item[i][7], fx, fy); // mark blocks that will be destroyed
         bomb_enemies(i, 1, item[i][7], fx, fy); // mark enemies that will be destroyed
         bomb_players(i, 1, item[i][7], fx, fy); // mark players in damage range



I got it all to compile!! now I have some bugs to fix...


first I want to record some performance metrics:
348 al_fixed
138 al_ftofix
383 al_itofix
207 al_fixtoi
124 al_fixtof


bugs..
player start position..fixed
jump on spring..fixed

OK its looking good...

what fixed to replace now?
player...the big one

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

   al_fixed LIFE;
   al_fixed old_LIFE;

   al_fixed draw_rot;
   al_fixed draw_scale;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;

lets do LIFE and old LIFE first
I also want to take this opportunity to rename it to health
done..


now PX, PY and rename to x, y
I should do all:

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

at the same time...

x, y, fxinc, fyinc, fright_xinc, fleft_yinc

the name change is important to find all the places it needs changing

convert all to float


I got stuck in the door move stuff...

there are ints:
   int door_xinc;
   int door_yinc;

that are used as fixed even though not declared as ints...I think...


I think I need to do the door ones at the same time..

   int door_xinc;
   int door_yinc;

   float door_fxinc;
   float door_fyinc;




ran into another issue with solidfm


they get passed fixeds and return fixed...

can I make a float wrapper?

they are used for ladder move and trakbot only...Ill need to fix them later...

well it compiles...

there is probably a lot broken...

remove these also:

   al_fixed draw_rot;
   al_fixed draw_scale;
   int door_draw_rot_num_steps;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


start with these:

   al_fixed draw_rot;
   al_fixed draw_scale;

done..

next:
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


compiles clean but there are so many things to fix...

first I want to record some performance metrics:
292 al_fixed
91  al_ftofix
287 al_itofix
138 al_fixtoi
114 al_fixtof


to fix:
rotation
rocket and door

ladder and rope

the rocket rotates like it should, but not player..


how does rotation work?

uses radians

pi/2 = 90
pi radians = 180


how is it done in items?

      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);



fuck all that...
I am going to start from scratch
if I have to store rotation as an int, how would I do that?

I figured it out and added notes in pm_docs

now implement for rocket

in proc_lit_rocket(int i)
angle is read from item[i][10] and used to calculate x and yinc inc and apply
also acceleration is processed

in proc_player_riding_rocket(int p)
player's controls are used to change angle
player gets pos and incs set from rocket

not much I could change there
steerability is simply the amount added or subtracted from the angle

I still think I should multiply by 100 to save angle as int
do it and fix whatever breaks

this is how it is drawn

    // these types need rotation
   if ((type == 11) || (type == 98) ||  // rockets
      ((type == 4) && (item[i][11] > 0))) // moving key
   {
      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);
      drawn = 1;
   }


Lets start with changing how it is draw

how do I want to do it?

should the angle be the one for draw or for trig?

I choose the trig one
this is how it is drawn now, deal with it...
      float rot = (float) item[i][10] / 1000;
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);

how was it done before?

when a rocket was created and all..

[10] is zero in PDE for rocket

fixed rocket lines...

multiplied steerability by 2
what if I just left it and increased the slider limit..
set rocket initial direction..done

what else do I need to fix?
when letting go of rocket, player warps...added to bugs...

now why do I have scale and door scale and all that?

check door stuff..

I think I fixed the player rotation stuff in door travel

door creator position bad...fixed

what about orb rotation?
there is another item that rotates...it works fine...

time for players ladders and bullshit like that...
make a wrapper...done..

first I want to record some performance metrics:
235 al_fixed
78  al_ftofix
246 al_itofix
135 al_fixtoi
109 al_fixtof

now the last big one: enemies

620 occurances of Efi



just like items, I will need to change the structure, then run glt



step 1 - backup levels

step 2 - add Ef[][16]

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
float Ef[100][16];      // enemy floats

extern int Ei[100][32];        // enemy ints
extern al_fixed Efi[100][16];  // enemy fixeds
extern float Ef[100][16];      // enemy floats

step 3 - glt
      // copy enemy fixed to to new float array
      for (int e=0; e<100; e++)
         for (int f=0; f<16; f++)
            Ef[e][f] = al_fixtof(Efi[e][f]);


step 4 - file.

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Ef);           memcpy(b+offset, Ef,           sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 5 run glt

step 6
disable glt
fix file
comment out Efi..


then fix!! 620 refs...
also in es I have this :
al_fixed ft_Efi[100][16];

change it too..
float ft_Ef[100][16];

PDEfx will also need changing later
rot for ft enemies


flapper does some weird flap sequences based on 0-100 and 0-255 and fixed sin

//   Efi[][8]  = flap offset for next loop



finally compiles clean!!!


first I want to record some performance metrics:
71 al_fixed
22 al_ftofix
66 al_itofix
28 al_fixtoi
51 al_fixtof

get_sproingy_jump_height(int num)
2 calls


convert PDE to use floats again
then remove the last calls to sliderf..done


now can I rename all the float ones from d to f...done...

key rotation..fixed..
fix the solid routines..done
fixed is no longer needed anywhere..

20230219 5:00AM

how many left?
33 al_fixed
15 al_ftofix
45 al_itofix
21 al_fixtoi
43 al_fixtof


fix enemy rotations, start with trakbot
look in enemy draw code:
float rot = Ef[e][14];
float sc =  Ef[e][12];
al_draw_scaled_rotated_bitmap(mwB.tile[tn], 10, 3, EXint+10, EYint+10, sc, sc, rot, flags);

deg fix rad
0   0   0
270 192 3p/2

trakbot is done..
check bouncers...good
vinepods, pozilla..good
flapper..no
jumpworm..good
fix flapper flap thingy..done

find a way to not use fixed trig in logo..done...
fixed trig 0-256

removed all the old solid functions

20230219 6:46 AM
0 al_fixed
0 al_ftofix
0 al_itofix
0 al_fixtoi
0 al_fixtof

they are all gone!!

cannon explosion death sequence looks different
need to fix rot inc in death sequence
done...

when letting go of rocket, player warps...fixed





lifts have strange artifacts in many levels...

clean up messed up levels


what about 'could not find move step!!' error?

lev 1 good
lev 2 2 lifts, one does not move..
lev 3 2 lifts, both move fine
lev 4 3 lifts, all move fine
when speed is too low, lifts don't move...fixed

5 no lifts
6 phantom lifts from level 4...removed
7 fixed
8
9
10
11
12
13 has 15 lifts
14
15
16
17 has 17 lifts
18 2
19 13
-36 done

80
81
82
83-99 done


100
108 37 lifts
109
155 39 lifts

I have gone through all 127 levels and removed bad lifts!

now what?


bullet targetting
seek xincs
set rot..etc
enemy stuff


I want to make a nice solution for angles
x,y is the reference, the angle will be refences to that point
      float xlen = mx-x;
      float ylen = my-y;
now get the answer in rad and shift by 90 deg
      float ra = atan2(ylen, xlen) + pi/2;;


now do the flapper targetting...
I think I got it..

all of that stuff is looking very good now

these functions in z_fnx are all looking great..
maybe later they can become a part of something like an enemy class

they are only 200 lines:

void set_enemy_rot_from_incs(int e);
void set_enemy_rot_from_player(int e, int p);
void seek_set_xyinc(int e);
int find_closest_player(int e);
int find_closest_player_flapper(int e);
int find_closest_player_trakbot(int e);
int find_closest_player_cannon(int e);
float deg_to_rad(float deg);


20230219 12:48  I should do a push..it has been a while....


test netgame

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Ef       :  6400
item     : 32000
itemf    :  8000
lifts    :  4480
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112128

it got 800 bytes smaller
800 / 40 = 20 / 4 = 5...could be 5 ints smaller in lifts

//#define STATE_SIZE 112928
#define STATE_SIZE 112128

of course it still works...I'm not just banging rocks together here....

what next?

I had started making lifts a class...

I have 1200 lines of code in z_lifts.cpp

lets move the data structures first and fix all references to them...

this is what I have now:

class mwLift
{
   public:

   mwLift(); // default constructor
   void initialize(void);

   struct lift lifts[NUM_LIFTS];
   struct lift_step lift_steps[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

};
extern mwLift mwLifts;


old:
lifts[].x
lift_steps[][].x

new:
mwLifts.l[].x
mwLifts.lift_steps[][].x

comment out the old and lets change shit...

actually it might be easier if I did all the funtions at the same time...
then I won't have to change them only to change them back later...
ok do it...

copied all header and function..compiles clean

now comment out the old and watch everything break!
compiles clean and completely removed old z_lifts files


can I make the names shorter?

mwLifts.lifts[].x
mwLifts.lift_steps[][].x

Lifts.l[] 13 to 7 (-6)
Lifts.steps[][] 18 to 11 (-7)

yes, do it

130 lifts
86 steps
41 member function refs

now I've gone and fucked it all up

lifts within the class now has changed

it does not like the single letter l...

what else can I call it?  curr, main,
cur for lifts
stp for steps..

like this:
lift.cur[]
lift.stp[][]

OK lets try to make that happen

replace
Lifts.l[
lift.cur[

replace
Lifts.steps[
lift.stp[


now that the class name is 'lift' I can't use that as a local int anymore

I should have just called it Lift dammit!!

there is a reason for complicated variable name

to simple and search and replace fails hard

Once more with feeling...
replace lift. with Lift.

done..and it compiles:

here is what the variables are called now:

   struct lift       cur[NUM_LIFTS];
   struct lift_step  stp[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

Lift.cur[]
Lift.stp[][]

so now that I have done that, what did I gain?


not sure...




z_item has ~3000 lines
e_item has 600


some items that are complex maybe should have there own source files..

I'm thinking doors, keys, rockets,

z_item.cpp
z_item_door.cpp
z_item_rocket.cpp


lets try it with keys..

just as a test to see how it could work...

got 100 lines out of z_items.cpp
and as a bonus, most stuff related to key is in the same place..


there is a bunch of stuff related to seq_color that I could find a place for..

the sorting stuff could go in e_items..

seq colors..part of bomb_blocks

I want to put bombs and rockets in their own file

z_item_bomb.cpp also rockets...500 lines

pmsg..done

also move switch to key..done


make one source file for all 4 of these closely related things:

call it trigger..

door
trigger
bd
bm

this will be the last for a while...

how nice can I make z_items.cpp look now?
now I only have around 600 lines

how big is z_enemy.cpp? 2400 lines...maybe later...




Server opened channel for `192.168.1.122:24785' and sent reply
Shutting down the server

C:\pm>pm

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-19  17:18:27]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2626][  1926][  1382][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1899][  1327][  1101][   278][    52][   226][   520] - mwWidget.cpp
[  1611][  1250][  1058][   279][    87][   192][   274] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1249][  1003][   907][   142][    46][    96][   200] - z_menu.cpp
[  1290][   971][   842][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1136][   897][   731][   206][    40][   166][   199] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1064][   881][   747][   190][    56][   134][   127] - e_edit_selection.cpp
[  1137][   807][   742][   125][    60][    65][   270] - z_settings.cpp
[   990][   734][   658][   108][    32][    76][   224] - e_fnx.cpp
[   857][   722][   407][   363][    48][   315][    87] - e_editor_main.cpp
[   926][   702][   560][   175][    33][   142][   191] - z_item_trigger.cpp
[  1191][   699][   635][   129][    65][    64][   427] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   862][   650][   618][    95][    63][    32][   149] - z_file.cpp
[   815][   642][   537][   140][    35][   105][   138] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   774][   621][   564][    92][    35][    57][   118] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1233][   585][   509][   346][   270][    76][   378] - z_args.cpp
[   766][   545][   468][   160][    83][    77][   138] - z_loop.cpp
[   650][   539][   416][   148][    25][   123][    86] - e_item.cpp
[   786][   539][   456][   155][    72][    83][   175] - z_fnx.cpp
[   649][   497][   424][   118][    45][    73][   107] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   449][   393][   316][    87][    10][    77][    46] - mwBottomMessage.cpp
[   521][   384][   299][   132][    47][    85][    90] - z_item_bomb.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   438][   367][   327][    48][     8][    40][    63] - mwPDE.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   411][   293][   291][    23][    21][     2][    97] - z_config.cpp
[   350][   288][   228][    71][    11][    60][    51] - e_enemy.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   256][   217][    67][    28][    39][    69] - mwShots.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   163][   127][    53][    17][    36][    71] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   128][    97][    81][    20][     4][    16][    27] - mwColor.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   116][    85][    77][    13][     5][     8][    26] - mwFont.cpp
[   141][    79][    72][    29][    22][     7][    40] - mwBitmap.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    55][    42][    40][     4][     2][     2][    11] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    48][    37][    35][     4][     2][     2][     9] - z_item.h
[    51][    31][    30][     3][     2][     1][    18] - mwBitmap.h
[    40][    31][    30][     2][     1][     1][     8] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    32][    24][    24][     1][     1][     0][     7] - z_fnx.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    23][    14][     8][     7][     1][     6][     8] - mwFont.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_bomb.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    16][    12][    12][     1][     1][     0][     3] - z_menu.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47880][ 35512][ 30292][  8207][  2987][  5220][  9381] - 130 files


about 600 lines more than last time I looked....



bug - sometimes rocket bomb lines do not work properly
the bomb_blocks circle is way behind...
fixed...

bug - door animation sequence sometimes disappears
door tiles don't get rebuilt...
at what point are they bad?
can I check them right after creating them...
goddamn I'm dum!!!


here is what I notice...


explosions are slightly more powerful than before
test this...
level 12 aim rocket lower center and 2 rows of blocks can be destroyed...seems the same...

rockets turn at a different rate
how to test this?
before, rotation was 0-256 fixed...x10

0    =  0 deg
640  = 90 deg
-640 = 270 deg_to_rad
1200 = 180 deg

steerability slider 1-50
item[][6]

that was added directly to angle, it wrapped forever...

what values do I have now


0    =  0 deg
1500 = 90 deg
3100 = 180 deg
4600 = 270 deg

so to convert

3142/1280 = 2.45

void proc_player_riding_rocket(int p)
{
   float rot_inc = (float)item[c][6] * 2.45;

this seems really close...

I would like to use glt and multiply all the vals by 2.5

then increase the slider range to 0-100

then manually adjust directions...
ok do it...


I really don't have that many rockets in my levels


Running Global Level Test
Level:  6 st:16
Level:  8 st:45
Level: 11 st:38
Level: 11 st:25
Level: 11 st:50
Level: 11 st:30
Level: 11 st:40
Level: 11 st:50
Level: 11 st:25
Level: 11 st:1
Level: 12 st:21
Level: 12 st:21
Level: 17 st:22
Level: 22 st:30
Level: 23 st:10
Level: 26 st:35
Level: 28 st:24
Level: 50 st:16
Level: 83 st:20
Level: 84 st:32
Level:101 st:20
Level:102 st:25
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:20
Level:155 st:1

only 28 up to here...
now can I do something about the initial directions?
or should I just adjust them all manually? yes...

rockets are done...

bottom messages do not show enemies anymore and item are not lined up...fixed
also I want some settings controls for them..

make it when left and right on levels, go to the next found level, not missing
done and it works great!!


if cancel from visual level don't reset level to 1

there are many different ways of doing this
- whenever selection is changed in vls make it change start_level
- exit with esc back to menu
- exit with enter, run level

- whenever selection is changed in vls do not change start_level
- exit with esc back to menu no change
- exit with enter, change start_level and run

which way do I like it? the first way..


here I am making a filename in a stupid way:

   char fn[20] = "levels/level000.pml";
   // look for levels that exist and put them in array
   for (int x=lll; x<ull; x++)
   {
      int h, d, rem = x;

      h = rem/100; // hundreds
      fn[12] = 48+h;
      rem -=h*100;

      d = rem/10;  // tens
      fn[13] = 48 + d;
      rem -=d*10;

      fn[14] = 48 + rem;
      if (al_filename_exists(fn)) le[num_levs++] = x; // put in array
   }

   char lf[255];
   sprintf(lf, "levels/level%03d.pml", level_num);
   //printf("saving: %s\n", lf);


right now z_level just has some variable definitions
I could make it into a class and add a bunch of methods
like what?
calc num of purple coins
take care of all the start block things
take care or erasing blocks and redrawing the level editor background when blocks change
calc num of enemies left alive??
mwLevel mLevel
.la[100][100]

done...
move tsw and merr to mwInput...done...

move more things out of file:
bitmaps
game moves
WM
then file will be done...

the only thing left in file is mw_file_select..used by bitmap_tools, edit_selection, and mwLevel..
I think I'll just put it in z_fnx for now...done

remove z_file from project...done...


void make_palette(void); -- to color
now called from display init...
moved to mwColor class and called in contructor...works good..
void window_title(void); -- to display..done
void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh);  -- to font..dpne


void get_hostname(int print); used in main and when clicking on button in settings..
maybe do inline?
print only from settings..done
inline in main


void spin_shape(int tn, int x, int y, int tsx, int tsy, int tsw, int tsh, float scale, float dim, int cycle);
move to bitmaps..

void show_var_sizes(void);
move to display with all the other console text dumps..


the pile is getting small...

should I make multi color lines its own thing?
it does not need to be a class, it only has 3 functions:

call it mw_multicolor_line...

move everything left into e_fnx...done

remove z_fnx...done



help should be made a class...
mwHelp mHelp
done..


I should be more consistant with my naming conventions

class names all start with mw then CamelCase...
they are already all like that...
but the instances of classes are all over the place
sometimes I made them shorter, but that hurts readability...just like too long does also...


menu stuff...

I should get rid of global_string

use something local and fill it everytime it is called...

I will still need to store it somewhere:

how about a class?

this time though, create instances when needed, nothing global
put all three menu type in the class..
use a common global string and have methods to assist with filling it

zmenu and tmenu done...
pmenu done..
disabling all old vars...done...

now move the text setup into item and enemy respectivbely...done

now the only thing left in z_menu is the text editing stuff....

and that fucking msg...


well its 3:40

20230220 3:40PM

push...

Purple Martians Source Code Line Counts [2023-02-20  15:45:36]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2089][  1761][  1353][   514][   106][   408][   222] - e_object_viewer.cpp
[  2550][  1685][  1468][   405][   188][   217][   677] - z_log.cpp
[  1878][  1601][  1450][   207][    56][   151][   221] - mwGraph.cpp
[  1899][  1328][  1102][   278][    52][   226][   519] - mwWidget.cpp
[  1609][  1249][  1056][   280][    87][   193][   273] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1293][   970][   841][   189][    60][   129][   263] - e_bitmap_tools.cpp
[  1399][   945][   834][   189][    78][   111][   376] - e_fnx.cpp
[  1140][   899][   733][   206][    40][   166][   201] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1063][   879][   745][   190][    56][   134][   128] - e_edit_selection.cpp
[  1139][   807][   742][   125][    60][    65][   272] - z_settings.cpp
[   862][   723][   408][   363][    48][   315][    91] - e_editor_main.cpp
[   925][   702][   560][   174][    32][   142][   191] - z_item_trigger.cpp
[  1194][   701][   637][   121][    57][    64][   436] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   815][   641][   536][   140][    35][   105][   139] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   777][   620][   563][    92][    35][    57][   122] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[  1234][   582][   506][   347][   271][    76][   381] - z_args.cpp
[   718][   580][   457][   148][    25][   123][   113] - e_item.cpp
[   810][   580][   531][   115][    66][    49][   164] - e_visual_level.cpp
[   765][   533][   456][   161][    84][    77][   148] - z_loop.cpp
[   682][   522][   449][   120][    47][    73][   113] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   683][   465][   426][   124][    85][    39][   133] - mwGameMovesArray.cpp
[   592][   459][   434][    28][     3][    25][   130] - mwInput.cpp
[   553][   443][   396][    77][    30][    47][    80] - e_window_common.cpp
[   679][   442][   439][    67][    64][     3][   173] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   492][   422][   366][    73][    17][    56][    53] - mwHelp.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   495][   380][   295][   120][    35][    85][    80] - z_item_bomb.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   438][   366][   326][    48][     8][    40][    64] - mwPDE.cpp
[   403][   332][   272][    71][    11][    60][    60] - e_enemy.cpp
[   475][   322][   297][    62][    37][    25][   116] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   348][   297][   278][    32][    13][    19][    38] - mwWindow.cpp
[   409][   290][   288][    23][    21][     2][    98] - z_config.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   255][   216][    67][    28][    39][    70] - mwShots.cpp
[   319][   232][   226][    27][    21][     6][    66] - z_main.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   197][   185][    29][    17][    12][    42] - z_menu.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   162][   126][    53][    17][    36][    72] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    12][    10][     2][    22] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   124][    92][    84][    15][     7][     8][    25] - mwFont.cpp
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   132][    76][    71][    16][    11][     5][    45] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   111][    71][    65][    12][     6][     6][    34] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    38][    36][     4][     2][     2][     9] - z_item.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    59][    32][    32][     4][     4][     0][    23] - e_fnx.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    20][    10][    10][     5][     5][     0][     5] - z_item_bomb.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     7][     4][     4][     1][     1][     0][     2] - z_menu.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 48239][ 35551][ 30333][  8226][  3008][  5218][  9680] - 132 files



lets remove msg wherever we can

I guess I could take 250 lines of edit text from menu and put it in e_fnx...
then kill menu


or....
leave only msg in menu...to see where I need to kill it...
done..I have been through every file and removed all global msg.. then kill z_menu.cpp and h...



mwItem mItem

mItem.i[16]
mItem.f[4]


I will have multiple source files for this class named as follows:

mwItem.h
mwItem.cpp

mwItemDoor.cpp
mwItemBomb.cpp
mwItemKey.cpp
mwItemMessage.cpp
mwItemTrigger.cpp


I will also put all functions from e_items.cpp in mwItem.cpp  if there are too many, later I will make more files

for now, lets just stick everything in the one file...mwItem.cpp...and get it to compile..


I now have a 4000 line file....
now for the header....
it will never change...


that all compiles clean...

I am a little scared to make my var names too short...

I would like:
mItem.i[16]
mItem.f[4]

but that would mean that in the class they would look like:

i[16]
f[4]

and could easily get confused with other single char var names:

I am just going to leave them as they are:

mItem.item[16]
mItem.itemf[4]


item[
itemf

1784 occ
186

do a global replace...just make sure to not do any within the class

item[ to mItem.item[
itemf[ to mItem.itemf[


it compiles...

I have removed:
e_items.cpp
z_items.cpp
z_items_xxx.cpp
files are removed from project...

everything is in the class and it compiles and seems to work!!

now lets try to make more .cpp files..

mwItemTrigger.cpp 880 lines
mwItemMessage.cpp 400 lines
mwItemBomb.cpp 500 lines
mwItemKey.cpp 200 lines
mwItemDoor.cpp 350 lines
mwItem.cpp 1500 lines

getting there...

700 lines of stuff that used to be in e_items...

time for a push then bed time...



Purple Martians Source Code Line Counts [2023-02-20  23:33:51]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1519][  1225][   999][   285][    59][   226][   235] - mwItem.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   817][   701][   559][   165][    23][   142][    93] - mwItemTrigger.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   489][   379][   294][   120][    35][    85][    75] - mwItemBomb.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   407][   282][   235][    73][    26][    47][    99] - mwItemMessage.cpp
[   357][   264][   187][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   315][   232][   226][    27][    21][     6][    62] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   199][   160][   124][    53][    17][    36][    22] - mwItemKey.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   133][    87][    84][    11][     8][     3][    38] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47894][ 35597][ 30380][  8163][  2946][  5217][  9351] - 124 files


now: (final)
700 mwItem.cpp
650 mwItemEditorFnz.cpp
800 mwItemTrigger.cpp
500 mwItemBomb.cpp
400 mwItemMessage.cp
200 mwItemKey.cpp
350 mwItemDoor.cpp
100 mwItem.h
-------------
3700 lines



in draw item make custom functions to draw key, start, exit, rocket message...

push..
maybe I'll get to do something at work...

nope...

num of starts is set only when items are sorted...
I should do it where i count purple coins...done..

items is done..

System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  19:00:59]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   313][   231][   225][    27][    21][     6][    61] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47891][ 35624][ 30408][  8168][  2952][  5216][  9315] - 126 files






now enemies!!

first put everything in one file...

2600 z_enemy.cpp
400  e_enemy.cpp
200 e_fnx.cpp


that's not how I did it with items


mwEnemy mEnemy

mEnemy.Ei[]
mEnemy.Ef[]


put everything in class
class file compiles

now fix all refs..
done:

compiles and runs!!!

now what?

3200 lines..
start making other files...

got to go..push time...



Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  21:16:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  2231][  1654][  1244][   590][   180][   410][   397] - mwEnemy.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1443][   985][   894][   148][    57][    91][   401] - e_fnx.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   311][   230][   224][    27][    21][     6][    60] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   223][   133][   100][    65][    32][    33][    58] - mwEnemyCloner.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    76][    57][    54][     8][     5][     3][    14] - mwEnemy.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    48][    27][    27][     1][     1][     0][    20] - e_fnx.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47986][ 35649][ 30433][  8182][  2966][  5216][  9371] - 129 files






I want to change the name of enemy move functions...


old:

enemy_cannon

new:
move_cannon

etc..

done:
move_archwagon
move_block_walker
move_arch_block_common
move_cannon
move_bouncer
move_bouncer_cannon_common
move_cloner
move_flapper
move_jumpworm
move_trakbot
move_podzilla
move_vinepod




int is_player_in_trigger_box(int x1, int y1, int x2, int y2);

is used only once by cloner

could I do it more genrically?
what else tests for this?
pod and vine
trigger
block damage


vine:
//     Ei[e][11] = trigger box x
//     Ei[e][12] = trigger box y
//     Ei[e][13] = trigger box w
//     Ei[e][14] = trigger box h
pod:
//     Ei[e][11] = trigger box x
//     Ei[e][12] = trigger box y
//     Ei[e][13] = trigger box w
//     Ei[e][14] = trigger box h
cloner:
//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2

just enemy for now..

int mwEnemy::is_player_in_enemy_trigger_box(int e)
{
   int x1 = Ei[e][11] - 10; // trigger box
   int y1 = Ei[e][12] - 10;
   int x2 = Ei[e][11] + Ei[e][13] + 10;
   int y2 = Ei[e][12] + Ei[e][14] + 10;
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (!players[p].paused))
      {
         int px = players[p].x;
         int py = players[p].y;
         if ((px > x1) && (px < x2) && (py > y1) && (py < y2)) return 1;
      }
   return 0;
}

done and patched in for cloner, pod, vine...


void show_level_data(void);
void mwEnemy::show_level_data(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(al_map_rgb(0,0,0));
   int y_pos = 40;
   int x_pos = 40;
   if (mLevel.valid_level_loaded)
   {
      y_pos = show_enemy_data(x_pos, y_pos) + 8;
      y_pos = mItem.item_data(x_pos, y_pos) + 8;
      al_draw_textf(mF.pr8, mColor.pc[15], x_pos, y_pos,   0, "%d Lifts  ", Lift.get_num_lifts());
      al_draw_text(mF.pr8, mColor.pc[15], x_pos, y_pos+8,  0, "-------");
   }
   al_flip_display();
   mI.tsw(); // wait for keypress
}

is in enemy, but I want to move it..
only used by level editor menu
other places?

int mwVisualLevel::lev_show_level_data(int x_pos, int y_pos)
int mwVisualLevel::lev_show_level_data(int x_pos, int y_pos)
{
   int ey_pos = mEnemy.show_enemy_data(x_pos, y_pos);
   int iy_pos = mItem.item_data(x_pos+135, y_pos);
   ey_pos = ey_pos + 8;
   al_draw_textf(mF.pr8, mColor.pc[15], x_pos, ey_pos, 0,"%d Lifts  ", Lift.get_num_lifts());
   ey_pos += 8;
   al_draw_text(mF.pr8, mColor.pc[15], x_pos, ey_pos, 0, "-------");
   ey_pos += 8;
   if (iy_pos > ey_pos) return iy_pos;
   else return ey_pos;
}

make a generic version and put it in mwLevel.cpp..done
1 call from visual and 1 from level editor menu...

but the best part is
void show_level_data(void);
is removed from enemy class...

how about:
mwEnemyEditorFnx

this is used in lots of place...move out of enemy to e_fnx...
void rectangle_with_diagonal_lines(float x1, float y1, float x2, float y2, int spacing, int frame_color, int line_color, int clip_mode);

done..

now mwEnemy.cpp is less than 500 lines before the huge comment section at the end...



Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-22  07:41:51]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1472][   999][   908][   149][    58][    91][   415] - e_fnx.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   705][   562][   408][   176][    22][   154][   121] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   553][   444][   397][    77][    30][    47][    79] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   454][   326][   310][    28][    12][    16][   116] - mwLevel.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   311][   230][   224][    27][    21][     6][    60] - z_main.cpp
[   315][   226][   178][    71][    23][    48][    66] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   281][   176][   122][   105][    51][    54][    54] - mwEnemyVinePod.cpp
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   172][   125][    81][    61][    17][    44][    30] - mwEnemyCannon.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    86][    57][    55][    12][    10][     2][    19] - mwEnemy.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    47][    29][    28][     2][     1][     1][    17] - mwLevel.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    54][    28][    28][     1][     1][     0][    25] - e_fnx.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47973][ 35649][ 30436][  8173][  2960][  5213][  9364] - 134 files



push....

rename mwS

class is mwShots
instance should be mShot not mwS




do something about this code...
it looks weird

void mwEnemy::proc_enemy_collision_with_pshot(int e)
{
   float ex = Ef[e][0];
   float ey = Ef[e][1];

   for (int c=0; c<50; c++)
      if (mwS.p[c].active)
      {
         // shot collision box size adjusted with shot speed
         float cx = fabs(mwS.p[c].xinc/2) + 8;
         float cy = fabs(mwS.p[c].yinc/2) + 8;

         // shot collision box size adjusted with enemies collision box size
         cx += (float) Ei[e][29] - 10;
         cy += (float) Ei[e][29] - 10;

         float bx1 = mwS.p[c].x - cx;
         float bx2 = mwS.p[c].x + cx;
         float by1 = mwS.p[c].y - cy;
         float by2 = mwS.p[c].y + cy;

         // check for collision with player's shots
         if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2))
         {
            //printf("hit!\n");
            int p = mwS.p[c].player;       // player number of shot
            Ei[e][31] = 1;                 // flag that this enemy got shot
            Ei[e][26] = p;                 // number of player that shot enemy
            players[p].stat_enemy_hits++;  // add to number of hits the player has
            mwS.p[c].active = 0;           // shot dies
         }
      }
}

players shot speed is always 12..

so after these lines:
float cx = fabs(mwS.p[c].xinc/2) + 8;
float cy = fabs(mwS.p[c].yinc/2) + 8;

one of cx or cy will be 8 and the other one will be 14


Ei[e][29] is almost always 10
then after these lines:
cx += (float) Ei[e][29] - 10;
cy += (float) Ei[e][29] - 10;
no change..

I want to make this test a point compare to a box.

first set up the enemy box

then test with the bullet point..

void mwEnemy::proc_enemy_collision_with_pshot(int e)
{
   float cb = (float) Ei[e][29]; // enemy collision box size
   float x1 = Ef[e][0] - cb;
   float y1 = Ef[e][1] - cb;
   float x2 = Ef[e][0] + cb;
   float y2 = Ef[e][1] + cb;

   for (int c=0; c<50; c++)
      if (mwS.p[c].active)
      {
         // shot position
         float x = mwS.p[c].x;
         float y = mwS.p[c].y;

         // adjust enemy collision box with shot speed
         float cx = fabs(mwS.p[c].xinc/2);
         float cy = fabs(mwS.p[c].yinc/2);

         if ((x > x1-cx) && (x < x2+cx) && (y > y1-cy) && (y < y2+cy))
         {
            //printf("hit!\n");
            int p = mwS.p[c].player;       // player number of shot
            Ei[e][31] = 1;                 // flag that this enemy got shot
            Ei[e][26] = p;                 // number of player that shot enemy
            players[p].stat_enemy_hits++;  // add to number of hits the player has
            mwS.p[c].active = 0;           // shot dies
         }
      }
}


this looks funny to me too...
enemy keeps track of when they last gave damage to a player for holdoff reasons? OK...

if collision happens when in holdoff, it is not cleared until holdoff is done and damage applied

only the most recent collision can cause damage...





void mwEnemy::enemy_player_hit_proc(int e)
{
   if (--Ei[e][23] < 0) // hit player retrigger
   {
      if (Ei[e][22]) // player hit!
      {
         int p = Ei[e][22]-1;
         players[p].health -= Ef[e][4];

         game_event(44, 0, 0, p, e, 0, Ef[e][4]);
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount
      }
   }
   else Ei[e][22] = 0;
}






it is time to make player a class

mwPlayers mPlayer

the two arrays: player and player1

how about syn and loc

mplayer.syn[0].
mplayer.loc[0].



what is the easiest way to do this?

rename arrays later...

first just make it into a class...done and compiles

now remove old z_player.cpp and h...


now do some search and replace

players[  to mPlayer.players[  // 965 matches
players1[  to mPlayer.players1[
active_local_player to    mPlayer.active_local_player


did all the functions...

now it compiles and runs...

now I want to change:
players[]  to syn[]
players1[] to loc[]


first in mwPlayers.cpp and .h

structure name:
old player
new psyn
old player1
new ploc
that was easy, only 4 occ...done

next struct instances in class:
players[]  to syn[]
players1[]  to loc[]

then external refs

mPlayer.players[]. to  mPlayer.syn[].
mPlayer.players1[]. to  mPlayer.loc[].


compare lengths:
players[] 7
mPlayer.players[].  15
mPlayer.syn[].  11

players1[]  8
mPlayer.players1[]. 16
mPlayer.loc[]. 11



I am rethinking syn and loc...

they look good outside the class
mPlayer.syn[].
mPlayer.loc[].

but inside the class they don't make much sense...
syn[].
loc[].

fuck it, I'll live with it..if I really want I can keep the long ones in the class also..

players is all done and compiles




20230225 5:00AM
made log into a class..

I want to straighten out the naming for the pairs of graph functions...
for example:
   void run_timestamp_graph(void);
   void log_timestamp_graph(int num_lines);

log_timestamp_graph loads the data then calls run to display it...

how about:
show_timestamp_graph
calls load_time_stamp graph, or just does it internally..


lets do it for profile first..done..

void run_profile_graph(int choose);
calls
int load_profile_graph(int choose);


next ping_graph...called only from log_file_viewer..done
void run_ping_graph(int num_lines);
calls
int load_ping_graph(int num_lines);

next
void run_client_server_sync_graph(void);
void log_client_server_sync_graph(int num_lines);
done:

next
void run_bandwidth_graph(int both);
void log_bandwidth_graph(int num_lines, int both);

done for now...



I want to do netgame...
files:
n_client.cpp
n_server.cpp
n_network.cpp
n_netgame.cpp
n_packet.cpp
and h files for all..

after:

mwNetgame.cpp
mwNetgameServer.cpp
mwNetgameClient.cpp

and one h file for all

class mwNetgame
instance mNetgame

created the class..

add all these:
n_network.cpp
n_packet.cpp
n_netgame.cpp

or should I add everything?

do it...

copied all the contents to cpp and h then removed from project and moved files...

class compiles clean...and works!!

next:


what if I move game_event to sound or bottom_message

it seems out of place in screen_overlay


I have three things that have event in them:
allegro events mwEventQueue mwEQ;
game events
trigger events mwPMEvent mwPME;

I would like to make the naming more consistant..

mwAllegroEvent mAllegroEvent
mwTriggerEvent mTriggerEvent
mwGameEvent mGameEvent

right now, do I make a new class ?
mwGameEvent mGameEvent
it will be very small
yes, I think I should..done

then after I want to rename PMEvent, it is a silly name...done..
now called mwTriggerEvent mTriggerEvent

now make glt a class..why? why not? im doing it for everything else...

mwGlobalLevelTool mGlobalLevelTool


next bitmap tools
mwBitmapTools mBitmapTools
done..


mwMulticolorLine ..done...



can I make solid part of something else, or a class to itself?

class
mwSolid mSolid

done..


// z_control.h

void clear_controls(int p);
void set_controls_from_comp_move(int p, int comp_move);
void set_comp_move_from_player_key_check(int p);
void set_controls_from_player_key_check(int p);
void rungame_key_check(int p);
void proc_player_input(void);

I thinking this could be made part of player...
its only 150 lines

yes..do it...done..


what are the few things left?

e_fnx
z_screen
z_screen_overlay

main
loop
args

6 level editor files

lets look at screen and screen overlay...

800 lines
// z_screen.h

void get_new_background(int full);
void stimp(void);
void stamp(void);
void draw_hyst_rect(void);
void get_new_screen_buffer(int type, int x, int y);
void set_map_var(void);
void mark_non_default_block(int x, int y);
void init_level_background(int);
void draw_level2(ALLEGRO_BITMAP *b, int mx, int my, int ms, int blocks, int items, int enemies, int lifts, int players);
void draw_level_centered(int screen_x, int screen_y, int level_x, int level_y, float scale_factor);
void draw_level(void);
int get_contrasting_color(int color);
void frame_and_title(int show_players);
void rtextout_centre(ALLEGRO_FONT *f, ALLEGRO_BITMAP *dbmp, const char *txt1, int x, int y, int col, float scale, float op);
void draw_title(int tx, int ty, int ttw, int tth, int color);
void draw_large_text_overlay(int type, int color);
void draw_percent_barc(int cx, int y, int width, int height, int percent, int c1, int c2, int fc);
void draw_percent_bar(int cx, int y, int width, int height, int percent);
void draw_percent_bar_line(int cx, int y, int width, int height, int rise, int color, int percent);
void draw_percent_bar_range(int cx, int y, int width, int height, int color, int start, int end);


1100 lines
// z_screen_overlay.h
int dif_from_now_to_nl();
void show_player_stat_box(int tx, int y, int p);
void show_level_done(void);
void draw_screen_overlay(void);
void set_player_join_quit_display(int p, int type, int time);
void show_player_join_quit(void);
void draw_top_frame(int p);
void draw_bottom_frame(int p);
void draw_common_debug_overlay(int p, int &cx, int &cy);
void draw_server_debug_overlay(int p, int &cx, int &cy);
void draw_client_debug_overlay(int p, int &cx, int &cy);
void draw_demo_debug_overlay(int p, int &cx, int &cy);




I think I will combine them into a class:
mwScreen mScreen
then later seperate to two cpp files...
done..

move contrasting color to color....done

now I have args loop and main on the one end and e_fnx and the 6 level editor files on the other end...




what do args and main look like?

400 lines
// z_args.h
void proc_command_line_args1(int argument_count, char **argument_array);
void proc_command_line_args2(int argument_count, char **argument_array);
void copy_files_to_clients(int exe_only);
void temp_test(void);

300 lines
// z_main.h
void final_wrapup(void);
void fast_exit(int why);
void show_system_id();
void set_and_get_versions(void);
void get_desktop_resolution();
int initial_setup(void);
int main(int argument_count, char **argument_array);


what should i do with them?


how about a file called main.cpp with no header that only calls:

mwMain.cpp mMain


and in that class I will have everything from args and main..

lets try it...done...

now all I have is loop



700 lines
// z_loop.h
void draw_frame(void);
void move_frame(void);
void loop_frame(int);
int have_all_players_acknowledged(void);
void proc_level_done_mode(void);
void proc_program_state(void);
void proc_level_done_mode(void);
void main_loop(void);



has no functions
// mwProgramState.h
class mwProgramState
{
   public:

   mwProgramState(); // default constructor
   void initialize(void);


   int program_state = 0;
   int new_program_state = 0;
   int old_program_state = 0;
   int older_program_state = 0;

   int top_menu_sel = 3;
   int main_loop_exit = 0;

   // temp testing variables
   int pct_x = 0;
   int pct_y = 0;

   int autosave_level_editor_state;
   int level_editor_running;
   int help_screens_running;
   int visual_level_select_running;


   int show_debug_overlay;

   int show_player_join_quit_timer;
   int show_player_join_quit_player;
   int show_player_join_quit_jq;


   // frame_speed, frames per second, mwPS.frame_num stuff
   int speed_testing = 0;
   int frame_speed = 40;
   int frame_num;
   int speed_control_lock = 1;
   int eco_draw = 0;

   // some global strings

   char local_hostname[80];
   char pm_version_string[80];
   char al_version_string[80];
   //char msg[1024];

};
extern mwProgramState mwPS;

I somehow want to combine them...

loop has no varaibles
program state has no functions


mwLoop mLoop

should get all of the variables from program state...

yes..do it...


mwProgramState is gone..replaced by mwLoop

now add everything from z_loop to that...done...


now there is nothing but e_fnx and the 6 level editor files...



// e_fnx.h

int exit_level_editor_dialog(void);
int mw_file_select(const char * title, char * fn, const char * ext, int save);

void draw_block_non_default_flags(int tn, int x, int y);

void chop_first_x_char(char *str, int n);

int round20(int val);
int enforce_limit(int val, int ll, int ul);
int check_limit(int val, int ll, int ul);
void swap_int(int *i1, int* i2);
float mdw_rnd(float rmin, float rmax);
void set_int_3216(int &I32, int H16, int L16);
void get_int_3216(int I32, int &H16, int &L16);
void printBits(size_t const size, void const * const ptr);


float get_sproingy_jump_height(int num);
int get_sp(float jh);

void set_xyinc_rot(int e, int x2, int y2);
void set_rocket_rot(int num, int x2, int y2);



int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2, int type);
int getxy(const char *txt, int obj_type, int sub_type, int num);
int get_trigger_item(int obj_type, int sub_type, int num);
int get_item(int obj_type, int sub_type, int num);

void crosshairs_full(int x, int y, int color, int line_width);
void titlex(const char *txt, int tc, int fc, int x1, int x2, int y);
void rectangle_with_diagonal_lines(float x1, float y1, float x2, float y2, int spacing, int frame_color, int line_color, int clip_mode);

void show_cursor(char *f, int cursor_pos, int xpos_c, int ypos, int cursor_color, int restore);
void edit_server_name(int type, int x, int y);
int edit_lift_name(int lift, int step_ty, int bts, char *fst);



thin out e_fnx....
removed:
void draw_vinepod_controls(int num, int legend_highlight);
void scale_bouncer_and_cannon_speed(int e);







// used only in sliders for button set new direction (rocket) !!! actually only in getxy
void set_rocket_rot(int num, int x2, int y2)
{
   float xlen = x2 - mItem.item[num][4];      // get the x distance between item and x2
   float ylen = y2 - mItem.item[num][5];      // get the y distance between item and y2
   float a = atan2(ylen, xlen) + ALLEGRO_PI/2;
   mItem.item[num][10] = a * 1000;
}
put this one instance inline...done



only in sliders for button set new direction (cannon and podzilla) !! actually in get xy just like above
void set_xyinc_rot(int e, int x2, int y2)
{
   float xlen = x2 - mEnemy.Ef[e][0];      // get the x distance between enemy and x2
   float ylen = y2 - mEnemy.Ef[e][1];      // get the y distance between enemy and y2
   float hy_dist = sqrt(pow(xlen, 2) + pow(ylen, 2)); // hypotenuse distance
   float speed = mEnemy.Ef[e][5];                  // speed
   float scaler = hy_dist / speed;     // get scaler
   mEnemy.Ef[e][2] = xlen / scaler;         // calc xinc
   mEnemy.Ef[e][3] = ylen / scaler;         // calc yinc
   mEnemy.Ef[e][14] = atan2(ylen, xlen) - ALLEGRO_PI / 2;
}
also used in ge to aim bouncer and cannon at start block or random
rename it:
void set_new_initial_direction(int e, int x2, int y2)
move it:done...


the list is a little thinner...


now for the huge one:

level_editor_mode is very similar to program state

It should not be that much of a stretch to make the level editor stuff fit into the loop and program state thing.


But I want to do something with all the source files...

list them first:
700  mwWindowManager
350  mwWindow

1000 edit_selection
800  editor_main
800  group edit
2000 object_viewer
600  tile helper
500  window common..


what if I amke them all part of the big window class
they alreay are, I mean just make all the functions member functions if they aren't already

mwWindow.cpp
mwWindowEditorMain
mwWindowEditSelection
mwWindowGroupEdit
mwWindowObjectViewer
mwWindowTileHelper


lets start with one that isn't too big..tile helper

// e_tile_helper.h

extern int thl[100][100]; // tile helper

void th_replace(int type);
int th_draw_buttons(int x3, int x4, int yfb, int draw_only);
int th_compare_tile(int rb, int cb, int group);
void th_find_connected(int x, int y, int group);
void th_process_mouse(void);


I don't want that array part of the windows class...i save and restore that..maybe part of wm class??
actually it makes no sense to add to win class, then all windows would get it...
I want specific storage for specific instances of windows
i could put it in wm as long as nothing else but wm uses w's

actually I save wm not w...maybe I should try it and see...40K..nbd 100x100x4

tile helper is done...mW.pm went from 18k to 58k


next add these to the main cpp file and make them part of the class..


500lines
// e_window_common.h
void cm_process_menu_bar(int draw_only);
int cm_draw_filter_buttons(int x1, int x2, int y1, int mode, int draw_only);
void cm_draw_status_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);
void cm_draw_selection_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);

350 lines
mwWindows.cpp

done:

Now I have left:
edit_selection..done
editor main
group edit..done
object viewer..done

the big ones...

mwWM.mW[1].editor main

mwWM.mW[4].edit selection
mwWM.mW[5].group edit
mwWM.mW[7].object viewer
mwWM.mW[9].tile helper

edit selection is done but has all the ft_ globals..Im amazied it works...
one left...done...woo hoo!! that was a lot of work...

actually there is one more..
e_fnx
mwMiscFnx mMiscFnx
lots of those....done!!


save and push..


Purple Martians Source Code Line Counts [2023-02-25  16:35:10]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1758][  1350][   515][   107][   408][   223] - mwWindowObjectViewer.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  2040][  1480][  1292][   349][   161][   188][   399] - mwLog.cpp
[  1767][  1366][  1162][   297][    93][   204][   308] - mwPlayers.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1292][   970][   841][   188][    59][   129][   263] - mwBitmapTools.cpp
[  1144][   948][   856][   125][    33][    92][   163] - mwScreenOverlay.cpp
[  1291][   903][   827][   114][    38][    76][   350] - mwMiscFnx.cpp
[  1136][   898][   732][   206][    40][   166][   198] - mwLift.cpp
[  1059][   878][   744][   190][    56][   134][   125] - mwWindowEditSelection.cpp
[  1137][   805][   740][   125][    60][    65][   272] - mwSettings.cpp
[   918][   724][   658][   107][    41][    66][   153] - mwWindow.cpp
[   858][   721][   406][   363][    48][   315][    89] - mwWindowEditorMain.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1193][   702][   638][   121][    57][    64][   434] - mwGlobalLevelTool.cpp
[   776][   686][   603][   101][    18][    83][    72] - mwWindowGroupEdit.cpp
[   838][   627][   541][   153][    67][    86][   144] - mwScreen.cpp
[   769][   622][   565][    91][    34][    57][   113] - mwNetgameClient.cpp
[   824][   614][   569][    95][    50][    45][   160] - mwNetgameServer.cpp
[  1261][   582][   506][   346][   270][    76][   409] - mwMainArgs.cpp
[   768][   570][   406][   210][    46][   164][   152] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   791][   554][   477][   163][    86][    77][   151] - mwLoop.cpp
[   676][   551][   468][   107][    24][    83][   101] - mwItem.cpp
[   653][   541][   418][   148][    25][   123][    87] - mwItemEditorFnx.cpp
[   677][   519][   445][   121][    47][    74][   111] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   668][   467][   428][   124][    85][    39][   116] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   585][   438][   347][   150][    59][    91][    88] - mwSolid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   416][   192][   257][    33][   224][   139] - mwWindowTileHelper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   380][   304][    86][    10][    76][    44] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   454][   326][   310][    28][    12][    16][   116] - mwLevel.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   386][   268][   266][    23][    21][     2][    97] - mwConfig.cpp
[   359][   265][   188][   114][    37][    77][    57] - mwItemDoor.cpp
[   373][   262][   246][    37][    21][    16][    90] - mwNetgame.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   383][   231][   171][   122][    62][    60][    90] - mwEnemyVinePod.cpp
[   311][   227][   221][    27][    21][     6][    63] - mwMain.cpp
[   316][   226][   178][    71][    23][    48][    67] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwTriggerEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   294][   169][   151][    27][     9][    18][   116] - mwPlayers.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   233][   164][   111][    78][    25][    53][    44] - mwEnemyCannon.cpp
[   169][   150][   133][    20][     3][    17][    16] - mwMulticolorLine.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   209][   140][   107][    69][    36][    33][    33] - mwColor.cpp
[   146][   117][   104][    22][     9][    13][    20] - mwNetgame.h
[   219][   116][   107][    68][    59][     9][    44] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   170][   111][   107][    18][    14][     4][    45] - mwWindow.h
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   124][    97][    95][     8][     6][     2][    21] - mwSound.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   124][    78][    75][    10][     7][     3][    39] - mwLog.h
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    99][    73][    72][     6][     5][     1][    21] - mwLift.h
[   111][    70][    64][    12][     6][     6][    35] - mwEventQueue.cpp
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[    76][    65][    55][    13][     3][    10][     8] - mwGameEvent.cpp
[    95][    60][    58][    13][    11][     2][    24] - mwEnemy.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    95][    43][    40][     4][     1][     3][    51] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    59][    40][    40][     4][     4][     0][    15] - mwScreen.h
[    62][    39][    38][     5][     4][     1][    19] - mwLoop.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    45][    33][    32][     2][     1][     1][    11] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    39][    31][    30][     2][     1][     1][     7] - mwConfig.h
[    47][    29][    28][     2][     1][     1][    17] - mwLevel.h
[    42][    29][    29][     1][     1][     0][    12] - mwMiscFnx.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    27][    27][     1][     1][     0][    15] - mwBottomMessage.h
[    52][    25][    25][     1][     1][     0][    26] - mwBitmapTools.h
[    33][    25][    24][     2][     1][     1][     7] - mwSettings.h
[    50][    24][    22][     4][     2][     2][    24] - mwGameMovesArray.h
[    28][    24][    24][     1][     1][     0][     3] - mwSound.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    45][    23][    23][     2][     2][     0][    20] - mwMain.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    23][    17][    17][     1][     1][     0][     5] - mwSolid.h
[    29][    16][    15][     2][     1][     1][    12] - mwTriggerEvent.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][     9][     9][     1][     1][     0][     5] - mwGlobalLevelTool.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    15][     9][     9][     1][     1][     0][     5] - mwMulticolorLine.h
[    10][     7][     7][     1][     1][     0][     2] - main.cpp
[    10][     6][     6][     1][     1][     0][     3] - mwGameEvent.h
-------------------------------------------------------- - totals
[ 46556][ 34554][ 29523][  7921][  2890][  5031][  9112] - 116 files






ok, what do I need to rename?


mwBitmap mwB;
mwB to mBitmap
done

mwBottomMessage mwBM;
mwBM to mBottomMessage
done


mwColor mColor;
mColor to mColor
done

mwDemoMode mwDM;
mwDM to mDemoMode
done

mwDisplay mwD;
mwD to mDisplay
done

mwDrawSequence mwDS;
mwDS to mDrawSequence
done

mwEventQueue mwEQ;
mwEQ to mEventQueue
done

mwFont mF;
mF to mFont
done

mwGameMovesArray mwGMA;
mwGameMovesArray to mwGameMoves done
mwGMA to mwGameMoves
done


mwGraph mwG[10];
mwG to mGraph
done


mwInput mI;
mI to mInput
done

mwLogo mwL;
mwL to mLogo
done

mwQuickGraph mwQG[10];
mwQG to mQuickGraph
done


mwRollingAverage mwRA[4];
mwRA to mRollingAverage
done

mwTally mwT[8];
mwT to mTally
done

mwTimeStamp mwTS;
mwTS to mTimeStamp
done


mwWidget is not even a class!!!


i have almost 500 occurances of widgets..search and replace would take a while

name length

mdw_slider
mdw_slideri
mdw_button
mdw_buttonp

mwWidget mW.slider

mW.slider
mWidget.slider


I alreadt have
mwWindow mW
mwWindowManager mwWM

at least mW is wholly contained in mwWM

how about mWidget

just do it...

why?...just so everything is the same...



20230226
82  slideri done
30  slider0 done
40  sliderf done
35  button
144 buttont
9   buttont_nb
7   buttonca
9   buttontt
33  buttonp
45  toggle
34  togglef
48  togglecc
8   colsel
-------------
520

widget is done...

then I should also do mwWM 744 references?? maybe later



I broke up mwLog.cpp (>2000) into:
380 mwLog.cpp
450 mwLogViewer.cpp
830 mwLogGraph.cpp

and also made a new class
220 mwCodeStat.cpp




I am having issues with callbacks in log files

C:\pm\src\mwLog.cpp|101|error: cannot convert 'mwLog::fill_filename_array' from type 'int (mwLog::)(ALLEGRO_FS_ENTRY*, void*)' to type 'int (*)(ALLEGRO_FS_ENTRY*, void*)'|
try to make the functiom static
I ended up keeping the callback function external to the class
it is defined in mLogViewer.cpp

int fill_filename_array(ALLEGRO_FS_ENTRY *fs, void * extra)
{
   if (mLog.num_filenames > 999) return 0; // only get 1000 max
   mLog.filenames[mLog.num_filenames] = al_create_fs_entry(al_get_fs_entry_name(fs));
   mLog.num_filenames++;
   return ALLEGRO_FOR_EACH_FS_ENTRY_OK;
}

has a prototype outside the class in mwLog.h
// cant be a part of the class if it gets called in a callback
int fill_filename_array(ALLEGRO_FS_ENTRY *fs, void * extra);
class mwLog
{
   private:

it uses the mLog instance of the variables internally..


this is shared with code stats... demo mode... maybe glt and visual level...

maybe I should make my own file iterator class that all of these can use...
it would still need an external callback function...


mwFileIterator mFileIterator

   ALLEGRO_FS_ENTRY *filenames[1000];
   int num_filenames;



show it being used:


int mwLog::load_profile_graph(int choose)
{
   mGraph[0].initialize();
   mGraph[0].set_series(0, "", 1, 0);
   char fname[256] = {0};
   int done = 0;
   int debug_print = 0;

   if (choose)
   {
      ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(fname, "Select Log File to View", "*.txt", 0);
      if (al_show_native_file_dialog(mDisplay.display, afc))
      {
         if (al_get_native_file_dialog_count(afc) == 1) sprintf(fname, "%s", al_get_native_file_dialog_path(afc, 0));
      }
      else { al_destroy_native_file_dialog(afc); return 0; } // user cancelled
      al_destroy_native_file_dialog(afc);
   }
   else // most recent file
   {
      sprintf(fname, "logs/");
      //printf("fname:%s\n", fname);
      // convert to 'ALLEGRO_FS_ENTRY' (to makes fully qualified path)
      ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

      // convert back to string
      sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));
      //printf("FS_fname:%s\n", fname);

      num_filenames = 0;
      // iterate levels in log folder and put in filename array
      al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);
      if (num_filenames == 0) printf("No log files found.\n");
      else
      {
         //for (int i=0; i< num_filenames; i++)
         //printf("%s\n", al_get_fs_entry_name(filenames[i]));
         time_t t = 0;
         int latest = 0;
         for (int i=0; i< num_filenames; i++)
            if (al_get_fs_entry_ctime(filenames[i]) > t)
            {
               t = al_get_fs_entry_ctime(filenames[i]);
               latest = i;
            }
         //printf("most recent file is: %s\n", al_get_fs_entry_name(filenames[latest]));
         sprintf(fname, "%s", al_get_fs_entry_name(filenames[latest]));
      }
   }


   FILE *filepntr=fopen(fname,"r");
   while(!done)
   {




void mwCodeStats::run(void)
{
   char msg[1024];
   struct code_stat cs[200] = {0};

   char fname[1024];
   sprintf(fname, "src/");
   ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

   // convert back to string
   sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));

   mLog.num_filenames = 0;

   // iterate files in folder and put in filename array
   al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);

   if (mLog.num_filenames == 0) printf("No files found.\n");
   else
   {
      for (int i=0; i<mLog.num_filenames; i++)
      {
         // printf("%s\n", al_get_fs_entry_name(filenames[i]));
         sprintf(cs[i].fname, al_get_fs_entry_name(mLog.filenames[i]));
         fill_stat_struct(cs[i]);

         // get just the name part of the path
         ALLEGRO_PATH * path = al_create_path(cs[i].fname);
         sprintf(cs[i].name, "%s", al_get_path_filename(path));
         al_destroy_path(path);
      }
   }
   // do the totals





{
   char msg[1024];
   al_show_mouse_cursor(mDisplay.display);
   char fname[1024];
   sprintf(fname, "logs/");
   //printf("fname:%s\n", fname);
   // convert to 'ALLEGRO_FS_ENTRY' (to makes fully qualified path)
   ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

   // convert back to string
   sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));
   //printf("FS_fname:%s\n", fname);

   if (type == 2) // most recent file
   {
      num_filenames = 0;
      // iterate levels in log folder and put in filename array
      al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);
      if (num_filenames == 0)
      {
         printf("No log files found.\n");
         type = 1; // prompt for select file
      }
      else
      {
         //for (int i=0; i< num_filenames; i++)
         //printf("%s\n", al_get_fs_entry_name(filenames[i]));
         time_t t = 0;
         int latest = 0;
         for (int i=0; i< num_filenames; i++)
            if (al_get_fs_entry_ctime(filenames[i]) > t)
            {
               t = al_get_fs_entry_ctime(filenames[i]);
               latest = i;
            }
         //printf("most recent file is: %s\n", al_get_fs_entry_name(filenames[latest]));
         sprintf(fname, "%s", al_get_fs_entry_name(filenames[latest]));
      }
   }
   if (type == 1) // select file
   {
      int user_cancelled = 0;
      ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(fname, "Select Log File to View", "*.txt", 0);
      if (al_show_native_file_dialog(mDisplay.display, afc))
      {
         if (al_get_native_file_dialog_count(afc) == 1)
         {
            const char * r = al_get_native_file_dialog_path(afc, 0);
            sprintf(fname, "%s", r);
            //printf("file selected:%s\n", fname);
         }
      }
      else
      {
         user_cancelled = 1;
         //printf("file select cancelled\n" );
      }
      al_destroy_native_file_dialog(afc);
      if (user_cancelled) return 0;
   }

   // get just the name part of the path
   ALLEGRO_PATH * path = al_create_path(fname);
   const char *tmp = al_get_path_filename(path);
   char fnam[100];
   sprintf(fnam, "%s", tmp);
   al_destroy_path(path);






for just these 3 case I will make the class, but I hope to do more with it later

mwFileIterator mFileIterator

   ALLEGRO_FS_ENTRY *filenames[1000];
   int num_filenames;

call it with dir and search string, it will fill its own internal array

also will have a method to get the most recent..

also..I am going to try to not have a global instance, only create one when needed...
dammit, there needs to be an instance for the callback...

OK I have it working for code stats...

does code stats need a global instance? probably not....
{mwCodeStats t; t.run();} works..
also make all functions static works...

try that with mwFileIterator...no luck....

moving on...

next load profile graph...

1 line!!!
sprintf(fname, "%s", al_get_fs_entry_name(mFileIterator.filenames[mFileIterator.get_most_recent("logs/")]));

better 1 line:
sprintf(fname, "%s", mFileIterator.get_most_recent_fname("logs/", fname));

next...log file viewer...done...







moving on...

demo mode.

int fill_demo_array(ALLEGRO_FS_ENTRY *fs, void * extra)
{
   if (mDemoMode.num_demo_filenames > 99) return 0; // only get 100 max
   mDemoMode.demo_FS_filenames[mDemoMode.num_demo_filenames] = al_create_fs_entry(al_get_fs_entry_name(fs));
   mDemoMode.demo_played[mDemoMode.num_demo_filenames] = 0;
   mDemoMode.num_demo_filenames++;
   return ALLEGRO_FOR_EACH_FS_ENTRY_OK;
}


   ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
   int num_demo_filenames;

looks like they are never referenced outside this class

I think I am going to leave this the way it is...
very small
only uses 100 instead of 1000
array is persistant

visual level does not use this method...

OK I think I'm done..


how does it work in linux?
looks good




what would a slider that doesnt block look like?
make one...done





new trigger emitter..timer

item 13 name timer

copy stuff from block damage, that has timers built in...
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val

t1 val
t2 val
count

if free run then count goes from 0 to t2 then resets

if wait for trigger then the same but wait for trigger before starting
can emit tiggers at t1 and t2


uses:
1 free run with on and off times by emitting 2 events at t1 and t2

2 wait for trigger then do something for t1 time, then something else at t2

what variable are going to be needed?

what shape?

I can have much better control over a timer display with all these extra variables

how about also something like cloner..then timer will only advance when triggered

so something like player has to be in box for timer to run
optionally reset if trigger goes away..


state t1 or t2

timer 1 val
timer 1 count

timer 1 trigger input mode:
0 = free run
1 = trigger to start then free run
2 = timer only runs when trigger is active
3 = timer only runs when trigger is active and resets when not
event used to trigger timer 1

timer 1 trigger output mode:
event to set when in mode (continuous)
event to set when mode completed (one time)




timer 2 val
timer 2 count

timer 2 trigger input mode:
0 = free run
1 = trigger to start then free run
2 = timer only runs when trigger is active
3 = timer only runs when trigger is active and resets when not
event used to trigger timer 2

timer 2 trigger output mode:
event to set when in mode (continuous)
event to set when mode completed (one time)

item[][0]  = 13 - Time Trigger
item[][1]  = count
item[][2]  = state
item[][3]  = flags

item[][4]  = x pos   (2000)
item[][5]  = y pos   (2000)

item[][6]  = t1 reset val
item[][7]  = t1 mode (0,1,2,3)
item[][8]  = t1 i/p event
item[][9]  = t1 o/p event

item[][10]  = t2 reset val
item[][11]  = t2 mode (0,1,2,3)
item[][12]  = t2 i/p event
item[][13]  = t2 o/p event

item[][14] = x2  for display
item[][15] = y2

now what kind of display icon TM

tile 987


now how to create one..
use PDE

I now have the shell of the new item..

create the ov


I will assume the item will always be in state 1 or 2
#define PM_ITEM_TIMER_STATE_CURR     0b00000000000100000
#define PM_ITEM_TIMER_STATE_PREV     0b00000000000100000


1 - find out what state we are in now
2 - compare with prev state and set appropriate events


wow, that was easy to implement..90% of all the functionality is there

I did not do any optimization of variables..
I still have left
3 flags
14 display
15 display

if I squeezed I could:
put state as a flag
put t1 and t2 mode as using 2 bits each in flags
this would get me 3 more variables to play with

I dont need it...

I want to make the draw mode use 14 and 15 and draw a rectangle there

it would be so nice to use 6789 for a rect just like all the others...

ok make me some free ones...

6 and 10 could be put into one...


new:

item[][0]  = 13 - Time Trigger
item[][1]  =
item[][2]  =
item[][3]  = flags

item[][4]  = x pos
item[][5]  = y pos

item[][6]  = x1
item[][7]  = y1
item[][8]  = w
item[][9]  = h

item[][10] = t1 reset val
item[][11] = t2 reset val
item[][12] = t1 i/p event
item[][13] = t1 o/p event
item[][14] = t2 i/p event
item[][15] = t2 o/p event

start by putting state into flags
make a function that does all that:

state:1
t1mode:2
t2mode:2
count:16

done...

now I have:
2 ints free even after using 4 for the display rectangle

item[][0]  = 13 - Time Trigger
item[][1]  =
item[][2]  =
item[][3]  = flags

item[][4]  = x pos
item[][5]  = y pos

item[][6]  = x1
item[][7]  = y1
item[][8]  = w
item[][9]  = h

item[][10] = t1 reset val
item[][11] = t2 reset val
item[][12] = t1 i/p event
item[][13] = t1 o/p event
item[][14] = t2 i/p event
item[][15] = t2 o/p event

void mwItem::set_timer_flags(int &pack, int state, int t1_mode, int t2_mode, int cnt)
{
   pack = state -1;
   int H16 = cnt<<16; // shift to upper 16 bits
   H16 &= 0b11111111111111110000000000000000; // clear other bits
   pack += H16;
   int t1m = t1_mode << 14; // shift to bits 14 and 15
   t1m &= 0b00000000000000001100000000000000; // clear other bits
   pack += t1m;
   int t2m = t2_mode << 12; // shift to bits 12 and 13
   t2m &= 0b00000000000000000011000000000000; // clear other bits
   pack += t2m;
}


void mwItem::get_timer_flags(int pack, int &state, int &t1_mode, int &t2_mode, int &cnt)
{
   cnt = pack>>16;
   t1_mode = pack>>14;
   t1_mode           &= 0b00000000000000000000000000000011;  // clear other bits
   t2_mode = pack>>12;
   t2_mode           &= 0b00000000000000000000000000000011;  // clear other bits
   state = 1 + (pack &  0b00000000000000000000000000000001); // clear other bits
}



next:

hook up the buttons that let you easily pick trigger input sources..

the same for outputs

test block manip

add some draw modes for the timing indicator


its been a long day..time for a push

Purple Martians Source Code Line Counts [2023-02-26  22:38:24]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2146][  1799][  1385][   522][   108][   414][   239] - mwWindowObjectViewer.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1980][  1388][  1150][   300][    62][   238][   530] - mwWidget.cpp
[  1745][  1359][  1155][   297][    93][   204][   293] - mwPlayers.cpp
[  1425][   971][   892][   122][    43][    79][   411] - mwMiscFnx.cpp
[  1144][   948][   856][   125][    33][    92][   163] - mwScreenOverlay.cpp
[  1247][   944][   815][   190][    61][   129][   242] - mwBitmapTools.cpp
[  1138][   897][   731][   206][    40][   166][   201] - mwLift.cpp
[  1053][   878][   698][   212][    32][   180][   143] - mwItemTrigger.cpp
[  1059][   878][   744][   190][    56][   134][   125] - mwWindowEditSelection.cpp
[  1120][   799][   734][   125][    60][    65][   261] - mwSettings.cpp
[   923][   725][   658][   108][    41][    67][   157] - mwWindow.cpp
[   858][   721][   406][   363][    48][   315][    89] - mwWindowEditorMain.cpp
[  1193][   702][   638][   121][    57][    64][   434] - mwGlobalLevelTool.cpp
[   776][   686][   603][   101][    18][    83][    72] - mwWindowGroupEdit.cpp
[   838][   627][   541][   153][    67][    86][   144] - mwScreen.cpp
[   769][   622][   565][    91][    34][    57][   113] - mwNetgameClient.cpp
[   824][   614][   569][    95][    50][    45][   160] - mwNetgameServer.cpp
[   813][   593][   493][   167][    67][   100][   153] - mwLogGraph.cpp
[  1261][   582][   506][   346][   270][    76][   409] - mwMainArgs.cpp
[   767][   570][   406][   210][    46][   164][   151] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   698][   555][   430][   151][    26][   125][   117] - mwItemEditorFnx.cpp
[   679][   554][   471][   107][    24][    83][   101] - mwItem.cpp
[   790][   554][   477][   163][    86][    77][   150] - mwLoop.cpp
[   677][   519][   445][   121][    47][    74][   111] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   554][   459][   434][    28][     3][    25][    92] - mwInput.cpp
[   635][   443][   410][   118][    85][    33][   107] - mwGameMoves.cpp
[   639][   441][   438][    67][    64][     3][   134] - mwDisplay.cpp
[   585][   438][   347][   150][    59][    91][    88] - mwSolid.cpp
[   492][   422][   366][    73][    17][    56][    53] - mwHelp.cpp
[   588][   416][   192][   257][    33][   224][   139] - mwWindowTileHelper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   435][   383][   307][    84][     8][    76][    44] - mwBottomMessage.cpp
[   438][   366][   326][    48][     8][    40][    64] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   443][   325][   263][    94][    32][    62][    86] - mwLogViewer.cpp
[   479][   316][   268][    77][    29][    48][   134] - mwItemMessage.cpp
[   404][   315][   291][    34][    10][    24][    79] - mwMenu.cpp
[   408][   305][   290][    27][    12][    15][    91] - mwLevel.cpp
[   390][   302][   298][     8][     4][     4][    84] - mwLog.cpp
[   373][   268][   267][    22][    21][     1][    84] - mwConfig.cpp
[   359][   265][   188][   114][    37][    77][    57] - mwItemDoor.cpp
[   371][   262][   246][    36][    20][    16][    89] - mwNetgame.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   383][   231][   171][   122][    62][    60][    90] - mwEnemyVinePod.cpp
[   308][   227][   221][    27][    21][     6][    60] - mwMain.cpp
[   316][   226][   178][    71][    23][    48][    67] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwTriggerEvent.cpp
[   296][   212][   187][    62][    37][    25][    47] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   246][   181][   180][     5][     4][     1][    61] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   274][   167][   150][    26][     9][    17][    98] - mwPlayers.h
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   233][   164][   111][    78][    25][    53][    44] - mwEnemyCannon.cpp
[   169][   150][   133][    20][     3][    17][    16] - mwMulticolorLine.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   209][   145][   124][    60][    39][    21][    25] - mwCodeStats.cpp
[   146][   117][   104][    22][     9][    13][    20] - mwNetgame.h
[   219][   116][   107][    68][    59][     9][    44] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   158][   111][   107][    18][    14][     4][    33] - mwWindow.h
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   134][   104][    88][    33][    17][    16][    13] - mwColor.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][   100][    97][    11][     8][     3][    29] - mwItem.h
[   124][    97][    95][     8][     6][     2][    21] - mwSound.cpp
[   133][    94][    93][    17][    16][     1][    23] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   118][    76][    73][    12][     9][     3][    33] - mwLog.h
[   105][    75][    70][    17][    12][     5][    18] - mwDemoMode.cpp
[    92][    73][    72][     6][     5][     1][    14] - mwLift.h
[    85][    73][    73][     1][     1][     0][    11] - mwTimeStamp.cpp
[    87][    67][    64][     5][     2][     3][    18] - mwDisplay.h
[    75][    65][    55][    13][     3][    10][     7] - mwGameEvent.cpp
[    81][    63][    57][    12][     6][     6][    12] - mwEventQueue.cpp
[    93][    60][    58][    13][    11][     2][    22] - mwEnemy.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    66][    50][    49][     7][     6][     1][    10] - mwFileIterator.cpp
[    91][    43][    40][     4][     1][     3][    47] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    59][    40][    40][     4][     4][     0][    15] - mwScreen.h
[    62][    39][    38][     5][     4][     1][    19] - mwLoop.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    75][    36][    36][     1][     1][     0][    38] - mwWidget.h
[    58][    35][    34][     3][     2][     1][    21] - mwBitmap.h
[    38][    32][    31][     2][     1][     1][     5] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    38][    31][    30][     2][     1][     1][     6] - mwConfig.h
[    47][    31][    31][     1][     1][     0][    15] - mwMiscFnx.h
[    43][    27][    27][     1][     1][     0][    15] - mwBottomMessage.h
[    40][    27][    27][     1][     1][     0][    12] - mwLevel.h
[    31][    25][    25][     1][     1][     0][     5] - mwBitmapTools.h
[    36][    24][    22][     3][     1][     2][    11] - mwGameMoves.h
[    30][    24][    24][     1][     1][     0][     5] - mwSettings.h
[    28][    24][    24][     1][     1][     0][     3] - mwSound.h
[    45][    23][    23][     2][     2][     0][    20] - mwMain.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    36][    23][    23][     1][     1][     0][    12] - mwTimeStamp.h
[    28][    22][    22][     1][     1][     0][     5] - mwCodeStats.h
[    33][    22][    21][     2][     1][     1][    10] - mwDrawSequence.h
[    33][    20][    15][     6][     1][     5][    12] - mwEventQueue.h
[    26][    19][    19][     1][     1][     0][     6] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    23][    17][    17][     1][     1][     0][     5] - mwSolid.h
[    29][    16][    15][     2][     1][     1][    12] - mwTriggerEvent.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    23][    15][    15][     1][     1][     0][     7] - mwPDE.h
[    21][    12][    11][     2][     1][     1][     8] - mwFileIterator.h
[    20][    11][    11][     1][     1][     0][     8] - mwMenu.h
[    15][     9][     9][     1][     1][     0][     5] - mwGlobalLevelTool.h
[    15][     9][     9][     1][     1][     0][     5] - mwHelp.h
[    15][     9][     9][     1][     1][     0][     5] - mwMulticolorLine.h
[    10][     6][     6][     1][     1][     0][     3] - mwGameEvent.h
[     8][     5][     5][     1][     1][     0][     2] - main.cpp
-------------------------------------------------------- - totals
[ 46533][ 34775][ 29712][  7931][  2868][  5063][  8890] - 122 files



20230227
fix percent bar to draw exactly where you would expect it to..done

hook up the buttons that let you easily pick trigger input sources..
seems to work



the same for outputs
add some draw modes for the timing indicator

make sure timer always starts in mode 1, with cnt = t1_count..done

add to creator choose display rect..done

make header for each timer in ov

separate display stuff in ov..done



what happens when timer is set to zero?

should this be an option for both, for only 2, for neither?



some of my confusion is coming from the fact that timer is both event sender and reeiver

show timer sender links also..



when choosing event source and picking timer...it would be nice to know what timer is being used as a source...

change some functions like:

int get_trigger_item(int obj_type, int sub_type, int num);
right now it only returns item num or -1 if bad

change return val to be zero if bad or cancelled
add extra params

int get_trigger_item(int obj_type, int sub_type, int num, int &ti_type, &int ti_sub_type, &int ti_num );

then it can be used for lifts and others in the future, and subtype can also be used for timer 1 or 2..


now do the same for:

int is_mouse_on_trigger_item(ti_obj_type, ti_num);

i think i've got it...

do some tests...


block damage needs some tweaking

I want a mode that is on only when triggered
needs to be constantly triggered or it turns off

and the same only reversed:

off only when triggered
needs to be constantly triggered or it turns on


then I want a mode that toggles with trigger
I have that already

then I want a mode that turns on with one trigger and turns off with another..
this would be tricky to implement, I would need 2 input triggers...
can I do it with the new constant mode I am thinking of implementing?
probably

maybe I could make the timer outputs constant or only when switching

what are they now?, only once when changing...

options:
- add 2 more more output events or
- add a flag to each output event so it could be one or the other

what should I do next?


I want to add something to bm, a way of marking block that it will effect, like a flag..
so that it can turn on and off blocks without having to use toggle

add trigger sender to lift
works!!

fix new step menu length..done
fix list of steps..done
remove the button that searches for inputs..done
add to list so it can be found as a sender

I need to get my terminology consistant
it will help a lot in my code..


i use trigger, event, transmitter, receiver, sender...

preferred:
event sender
event receiver

to specify an object I will need three variables:
obj_type
obj_num
obj_ext

       obj_type obj_num obj_ext
item      2       num    n/a
orb       2       num    n/a
trigger   2       num    n/a
timer     2       num    timer number
enemy     3       num    n/a
lift      4       step   lift

when choosing lift step 6 as trigger sender, switch lift to that step for display..done..

this is coming along nicely


void mwTriggerEvent::find_and_show_event_links(int type, int i, int num2)

change to
void mwTriggerEvent::find_and_show_event_links(int obj_type, int obj_num, int obj_ext)

bug---can't see any prox line in level editor for prox lift step
it shows up fine in game
in level editor the function:
void set_lift_to_step(int l, int s)
{
   // new behaviour
   // if passed step is a move step, set that
   // if not, then set to previous move step
does not actually set lift's current step to steps that are not move steps

what if I changed that to only set lifts main pos to prev lift step, not actual step...fixed....


20230304 10:00AM

still working on lifts and trigger events...
I think lifts are done...

what should I do next?

add cloner to receivers

I think I can use Ei[][21] for trigger input..

I should also add a mode for that..

will I blindly just clone when trigger is received?

modes:
force clone when trigger received, probably use a toggle on

clone when trigger received, then use a cool done timer
run timer while triggered then when timer is full clone..

I think all of these case could be handled by the combination of timer and trigger items..


trigger direct will do instant

timer direct can do timed

I think I sould add the event option and see if I can replace all other uses...

make the option to have a timer run the cloner animation.

for now make a new mode and the option to set an event receiver..done
now I can control cloner with just event..

see if I can replace uses...

level 5
cloner 2
mode immed delay 90 with trigger box...
make trigger item of same size with player input...done
make the trigger item trigger a timer with t1 set to run whenever player is in trigger area

this works...

needs trigger item -> timer item -> cloner


level 6
cloner for rocket...
immed delay 20

trigger->timer->cloner

this time I want immediate with a cool off...

t1 time:1  run after trigger send event 2
t2 time:20 free run


I think those are the two most common use cases

check with glt...


the only types used are 0 and 2
0 timer runs
2 imdediate on trigger then timer runs

0 will be easy to replace with a straight timer.
2 can be replaced with a combo of trigger and timer..

I can also do a straight trigger input..

what I need to do is make a way that the timer can affect the cloner display

cloner display:
hidden or not
static shape
linked to timer (timer item num, timer 1 or 2)

I will have more space once I get rid of the 4 ints used for cloner trigger

all these can go:

//      Ei[e][5] = player in box
//      Ei[e][6] = create wait
//      Ei[e][7] = create wait counter
//      Ei[e][8] = trigger mode (0 = wait, 1=reset, 2=immed)
//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2


how will I go about changing all this?

Level:  1 - cloner:3 trigger type:0
Level:  5 - cloner:1 trigger type:0
Level:  5 - cloner:2 trigger type:3
Level:  5 - cloner:3 trigger type:0
Level:  6 - cloner:0 trigger type:3
Level:  7 - cloner:0 trigger type:0
Level:  8 - cloner:0 trigger type:2
Level:  8 - cloner:1 trigger type:0
Level:  8 - cloner:2 trigger type:0
Level:  8 - cloner:3 trigger type:0
Level:  8 - cloner:4 trigger type:2
Level:  9 - cloner:0 trigger type:2
Level:  9 - cloner:1 trigger type:2
Level:  9 - cloner:2 trigger type:0
Level:  9 - cloner:3 trigger type:2
Level:  9 - cloner:4 trigger type:2
Level: 10 - cloner:0 trigger type:0
Level: 10 - cloner:1 trigger type:0
Level: 10 - cloner:2 trigger type:0
Level: 10 - cloner:3 trigger type:2
Level: 11 - cloner:0 trigger type:2
Level: 11 - cloner:1 trigger type:2
Level: 11 - cloner:2 trigger type:2
Level: 11 - cloner:3 trigger type:2
Level: 11 - cloner:4 trigger type:2
Level: 11 - cloner:5 trigger type:2
Level: 11 - cloner:6 trigger type:0
Level: 11 - cloner:7 trigger type:2
Level: 11 - cloner:8 trigger type:2
Level: 11 - cloner:9 trigger type:0
Level: 11 - cloner:10 trigger type:0
Level: 11 - cloner:11 trigger type:0
Level: 11 - cloner:12 trigger type:0
Level: 12 - cloner:0 trigger type:0
Level: 12 - cloner:1 trigger type:2
Level: 12 - cloner:2 trigger type:2
Level: 12 - cloner:3 trigger type:0
Level: 12 - cloner:4 trigger type:0
Level: 12 - cloner:5 trigger type:0
Level: 13 - cloner:0 trigger type:0
Level: 13 - cloner:1 trigger type:0
Level: 13 - cloner:2 trigger type:0
Level: 13 - cloner:3 trigger type:2
Level: 15 - cloner:0 trigger type:0
Level: 16 - cloner:20 trigger type:2
Level: 16 - cloner:21 trigger type:2
Level: 16 - cloner:22 trigger type:0
Level: 16 - cloner:23 trigger type:2
Level: 16 - cloner:24 trigger type:0
Level: 16 - cloner:25 trigger type:0
Level: 16 - cloner:26 trigger type:0
Level: 17 - cloner:21 trigger type:2
Level: 17 - cloner:22 trigger type:0
Level: 17 - cloner:23 trigger type:0
Level: 17 - cloner:24 trigger type:0
Level: 17 - cloner:25 trigger type:0
Level: 17 - cloner:26 trigger type:0
Level: 17 - cloner:27 trigger type:0
Level: 18 - cloner:0 trigger type:0
Level: 18 - cloner:1 trigger type:0
Level: 19 - cloner:0 trigger type:2
Level: 19 - cloner:1 trigger type:0
Level: 19 - cloner:2 trigger type:0
Level: 20 - cloner:9 trigger type:0
Level: 20 - cloner:10 trigger type:0
Level: 20 - cloner:11 trigger type:0
Level: 21 - cloner:1 trigger type:0
Level: 21 - cloner:2 trigger type:0
Level: 21 - cloner:3 trigger type:0
Level: 21 - cloner:4 trigger type:0
Level: 21 - cloner:5 trigger type:0
Level: 21 - cloner:6 trigger type:0
Level: 21 - cloner:7 trigger type:0
Level: 22 - cloner:8 trigger type:2
Level: 22 - cloner:9 trigger type:0
Level: 22 - cloner:10 trigger type:0
Level: 22 - cloner:11 trigger type:0
Level: 23 - cloner:0 trigger type:0
Level: 23 - cloner:1 trigger type:0
Level: 23 - cloner:2 trigger type:2
Level: 23 - cloner:3 trigger type:2
Level: 23 - cloner:4 trigger type:0
Level: 26 - cloner:0 trigger type:2
Level: 28 - cloner:0 trigger type:2
Level: 29 - cloner:17 trigger type:0
Level: 29 - cloner:18 trigger type:0
Level: 29 - cloner:19 trigger type:0
Level: 29 - cloner:20 trigger type:0
Level: 30 - cloner:0 trigger type:0
Level: 30 - cloner:1 trigger type:0
Level: 30 - cloner:2 trigger type:0
Level: 31 - cloner:4 trigger type:2
Level: 31 - cloner:5 trigger type:0
Level: 32 - cloner:2 trigger type:0
Level: 32 - cloner:3 trigger type:0
Level: 32 - cloner:4 trigger type:0
Level: 32 - cloner:5 trigger type:0
Level: 32 - cloner:6 trigger type:0
Level: 33 - cloner:0 trigger type:0
Level: 33 - cloner:1 trigger type:0
Level: 33 - cloner:2 trigger type:0
Level: 33 - cloner:3 trigger type:0
Level: 35 - cloner:0 trigger type:2
Level: 35 - cloner:1 trigger type:2
Level: 35 - cloner:2 trigger type:2
Level: 35 - cloner:3 trigger type:0
Level: 35 - cloner:4 trigger type:0
Level: 35 - cloner:5 trigger type:2
Level: 36 - cloner:0 trigger type:2
Level: 36 - cloner:1 trigger type:0
Level: 49 - cloner:0 trigger type:0
Level: 50 - cloner:0 trigger type:2
Level: 51 - cloner:0 trigger type:3
Level: 83 - cloner:0 trigger type:0
Level: 83 - cloner:1 trigger type:0
Level: 83 - cloner:2 trigger type:0
Level: 83 - cloner:3 trigger type:0
Level: 83 - cloner:4 trigger type:0
Level: 84 - cloner:0 trigger type:0
Level: 84 - cloner:1 trigger type:0
Level: 84 - cloner:2 trigger type:2
Level: 86 - cloner:0 trigger type:0
Level: 88 - cloner:0 trigger type:0
Level: 88 - cloner:1 trigger type:0
Level: 88 - cloner:2 trigger type:0
Level: 88 - cloner:3 trigger type:0
Level: 88 - cloner:4 trigger type:0
Level: 89 - cloner:0 trigger type:0
Level: 93 - cloner:0 trigger type:0
Level: 93 - cloner:1 trigger type:0
Level: 93 - cloner:2 trigger type:0
Level: 93 - cloner:3 trigger type:2
Level: 93 - cloner:4 trigger type:0
Level: 93 - cloner:5 trigger type:0
Level: 95 - cloner:2 trigger type:0
Level: 95 - cloner:3 trigger type:0
Level: 97 - cloner:0 trigger type:0
Level: 97 - cloner:1 trigger type:0
Level: 97 - cloner:2 trigger type:0
Level: 97 - cloner:3 trigger type:0
Level: 98 - cloner:0 trigger type:0
Level:101 - cloner:1 trigger type:0
Level:101 - cloner:2 trigger type:0
Level:101 - cloner:3 trigger type:2
Level:102 - cloner:0 trigger type:0
Level:105 - cloner:0 trigger type:2
Level:105 - cloner:1 trigger type:2
Level:105 - cloner:2 trigger type:2
Level:106 - cloner:5 trigger type:0
Level:106 - cloner:6 trigger type:0
Level:106 - cloner:7 trigger type:0
Level:106 - cloner:8 trigger type:0
Level:106 - cloner:9 trigger type:2
Level:106 - cloner:10 trigger type:2
Level:106 - cloner:11 trigger type:2
Level:107 - cloner:0 trigger type:0
Level:113 - cloner:0 trigger type:0
Level:117 - cloner:6 trigger type:0
Level:153 - cloner:5 trigger type:2
Level:155 - cloner:4 trigger type:0
Level:155 - cloner:5 trigger type:0
Level:155 - cloner:6 trigger type:0
Level:155 - cloner:7 trigger type:0
Level:155 - cloner:8 trigger type:0
Level:155 - cloner:9 trigger type:2
Level:160 - cloner:0 trigger type:2
Level:160 - cloner:1 trigger type:2
Level:303 - cloner:0 trigger type:0
Level:303 - cloner:1 trigger type:2
Level:303 - cloner:2 trigger type:0
Level:303 - cloner:3 trigger type:0
Level:303 - cloner:4 trigger type:0
Level:303 - cloner:5 trigger type:0
Level:303 - cloner:6 trigger type:0
Level:313 - cloner:0 trigger type:2
Level:320 - cloner:0 trigger type:2
Level:320 - cloner:1 trigger type:2
Level:320 - cloner:2 trigger type:2
Level:321 - cloner:3 trigger type:0
Level:321 - cloner:4 trigger type:2
Level:322 - cloner:0 trigger type:2
Level:322 - cloner:1 trigger type:2
Level:322 - cloner:2 trigger type:2
Level:322 - cloner:3 trigger type:2
Level:322 - cloner:4 trigger type:2
Level:322 - cloner:5 trigger type:2
Level:324 - cloner:0 trigger type:2
Level:332 - cloner:98 trigger type:2
Level:333 - cloner:0 trigger type:2
Level:360 - cloner:4 trigger type:2
Level:360 - cloner:5 trigger type:0
Level:360 - cloner:6 trigger type:0
Level:360 - cloner:7 trigger type:0
Level:360 - cloner:8 trigger type:0
Level:360 - cloner:9 trigger type:0
Level:361 - cloner:0 trigger type:0
Level:361 - cloner:1 trigger type:2
Level:363 - cloner:0 trigger type:0
Level:364 - cloner:0 trigger type:1
Level:365 - cloner:16 trigger type:2
Level:365 - cloner:17 trigger type:0
Level:365 - cloner:18 trigger type:0
Level:368 - cloner:0 trigger type:0
Level:368 - cloner:1 trigger type:0
Level:369 - cloner:0 trigger type:2
Level:369 - cloner:1 trigger type:2
Level:370 - cloner:0 trigger type:0
Level:370 - cloner:1 trigger type:2
Level:371 - cloner:1 trigger type:2
Level:371 - cloner:2 trigger type:0
Level:371 - cloner:3 trigger type:2
Level:371 - cloner:4 trigger type:2
Level:372 - cloner:0 trigger type:0
Level:373 - cloner:26 trigger type:0
Level:373 - cloner:27 trigger type:0
Level:373 - cloner:28 trigger type:0
Level:373 - cloner:29 trigger type:0
Level:373 - cloner:30 trigger type:0
Level:373 - cloner:31 trigger type:0
Level:373 - cloner:32 trigger type:0
Level:373 - cloner:33 trigger type:0
Level:373 - cloner:34 trigger type:0
Level:373 - cloner:35 trigger type:0
Level:373 - cloner:36 trigger type:0
Level:373 - cloner:37 trigger type:0
Level:373 - cloner:38 trigger type:0
Level:373 - cloner:39 trigger type:0
Level:374 - cloner:4 trigger type:2
Level:374 - cloner:5 trigger type:2
Level:374 - cloner:6 trigger type:0
Level:374 - cloner:7 trigger type:0
Level:375 - cloner:2 trigger type:0


I think that 0 and 2 both run down the timer...


I want to automate this change somewhat

in glt for each cloner found:

create a trigger item with the same area as the cloners trigger area
create a timer item with the t1 the same time as the cloners time

put the newly created items immed above or below cloner

//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2

then gut cloner and re arrange variables


I know this is more complicated to make a cloner, but it is also much more extendable..

almost every cloner should have a timer driving it..

the timer can be a free run, or only run if player in trigger box.

what would it look like if the timer even that triggered that cloner was at the end of t2?


free run:
t1 0 free run
t2 100 free run and send event

free run when triggered:
t1 0 free run
t2 100 free run when triggered and send event

immed when triggered then run timer while still triggered:
t1 1 free run after triggered and send event
t2 100 free run

I think I am ready to pull the trigger on all the levels...

backup first...done
convert..done


move variables around
old:
Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)
Ei[][5]  mode
Ei[][6]  create wait
Ei[][7]  create wait counter
Ei[][8]  trigger mode (0=wait, 1=reset, 2=immed)
Ei[][9]  time to live for created objects
Ei[][10] max num of created objects
Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2
Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height
Ei[][21] event

new:
Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)

Ei[][5]  draw mode
Ei[][6]  draw linked timer item num
Ei[][7]  draw linked timer num
Ei[][8]  event

Ei[][9]  time to live for created objects
Ei[][10] max num of created objects

Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height




add button to cloner to choose event and add stuff to make that work...
mostly done..now I need lines in ov overaly...done...



A very common mode (old 0)
timer runs while triggered then clones

could be implemented with either t1 or t2

t1 0 free run (skips immed)
t2 100 free run when triggered and send event

or

t1 100 free run when triggered and send event
t2 0   free run (skips immed)

make a function that returns a float based on the percent of the active timer
done..

add to cloner
Ei[][6]  draw linked timer item num
this could change..
make a function to find float timer ration based on event num
search item type 13 for event num match


I actually think cloner is done..mostly
creator...should I prompt for timer? and trigger..

timer display options.. at least have a way to not display anything..done


if timer value == 0 the timer is off






Another very common mode (old 2)
when triggered clone immediately then holdoff
if continually triggered will clone every period
if retriggered, nothing will happen until holdoff is done

if continually triggered, acts just like first use case

the difference here is when first triggered it clones right away

could be implemented with either t1 or t2

t1 1 free run when triggered and send event
t2 100 free run (just for holdoff delay)

or
t1 100 free run (just for holdoff delay)
t2 1 free run when triggered and send event



what if I made the immediate ones trigger with trigger only?
then it would be simpler..I would lose the auto retrigger stuff though
I can control how many are made with cloner..

going through levels and changing..
up to 10


make trigger boxes easier to see on overlay...

some triggers are less than 0 and greater than 2000
probably auto created...fix with glt...
4 key
9 trigger
14 switch
16 bm
17 bd

Running Global Level Test
l:1 it:9 x<0
l:1 it:9 y<0
l:5 it:9 x<0
l:5 it:9 w<2000
l:13 it:9 x<0
l:13 it:9 y<0
l:13 it:9 w<2000
l:13 it:9 h<2000
l:13 it:9 x<0
l:13 it:9 y<0
l:13 it:9 w<2000
l:13 it:9 h<2000
l:23 it:9 x<0
l:23 it:9 y<0
l:23 it:9 w<2000
l:23 it:9 h<2000
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0

fixed..







I have redidi all the cloner in levels up to 100 so far..

here are my notes:

I can just about always use timer 1 only...

if the old cloner had a trigger box the size of the entire level, the new one doesn't need one
use timer only in this case


if the old cloner waited for player to trigger to get an item, most of the time can do this with just trigger and cloned item limit

to use a cloner to make sure there is always 1 item in an area:
cloner -> timer -> trigger???





thoughts for the creator:

first lose the prompt for trigger...

then make some templates

cloner -> timer
free running timer in t1 that triggers cloner

cloner -> trigger
toggle trigger

cloner -> timer -> trigger
when you want a timed clone only when something triggers





ov set to zero sometimes buggy
start a level in level editor with no enemies...



ov_check_if_valid(type); is called from ov_get_size(void)

lets call it one sooner...

void mwWindow::draw(int draw_only)
{
   if (index == 7) // object viewer
   {
      ov_check_if_valid(type);
      ov_get_size();
      ov_title(x1, x2, y1, y2, legend_line);
      ov_draw_buttons(x1, y1, x2, y2, d);
   }

lets not pass type to it, make it calculate that itself

I think it is fixed...much simpler now:

void mwWindow::ov_check_if_valid(void)
{
   // check if the current object is valid
   int obt = mwWM.mW[7].obt;
   int num = mwWM.mW[7].num;
   if (obt==0)                               mwWM.set_windows(1);
   if ((obt==2) && (!mItem.item[num][0]))    mwWM.set_windows(1);
   if ((obt==3) && (!mEnemy.Ei[num][0]))     mwWM.set_windows(1);
   if ((obt==4) && (!mLift.cur[num].active)) mwWM.set_windows(1);
}




now I have done up to level 200
there are still some old type cloners in the 300's but I don't care, they are all junk levels anyway..




now what was I doing with timer's and such?

block damage has built in timers and quite a bit of display
the numbers and progress bars are not as configurable as the the ones in timer..

I could make some new modes...
on always unless a continous off event is present
off always unless a continous on event is present
these events could be sent with timers

that would take care of the three timed modes

existing modes:
always on
toggle
timed on
timed off
timed on and off



the simplest would be
toggle
on unless trigger
off unless triggered

the second two could be attached to a timer or to a constant trigger

trigger -> damage
timer -> damage
trigger -> timer -> damage


bottom line, timer will not be needed in damage, i will use item timer...
then what about display?

also for block manip i want a way to set blocks based on some flag
some way that is invisible in the game

made it so that I can view and edit block flags for blocks stored in block manip

now I need a flag to use for block manip
i am not using secret, how about that?

#define PM_BTILE_ROPE_MOVE         0b00010000000000000000000000000000
#define PM_BTILE_SECRET            0b00100000000000000000000000000000

do I need to rename it? or just use it

make a new mode in block manip

set all secret to block 1
set all secret to block 2
toggle secret from block 1 to block 2
(how does this differ from normal toggle)

actually all these modes could be the same, I could just have a flag to only apply them to blocks marked secret
and when applying them, do not change the secret flag..

item[][13] = secret flag only


looking at this now:
set all to block 1
set all secret to block 1
set all block 2 to block 1
toggle block 1 to block 2

makes more sense

set all block 2 to block 1 does not need to have secret flag added flag added
if that is what I want then add the flag to block2

the same with toggle 2 and 1..we already are looking for a specfic block..

hell I could even do away with mode 1...just set use mode 2 and make the replacement block have special flags

I think this was all I needed...get rid of 13 and tests..
good...

I think that block manip does everything I want it to..

what about bd?

I wanted to be able to control it with an external timer
do I want to get rid of the internal timer? and the internal display stuff?

bd modes:
0 - Always ON
1 - Toggle
2 - ON Until Triggered
3 - OFF Until Triggered
4 - Timed ON And OFF

item[][0]  = 17 - Block Damage
item[][1]  = event trigger number
item[][2]  = damage draw type
item[][3]  = flags
#define PM_ITEM_DAMAGE_PLAYER   0b00000000000000001
#define PM_ITEM_DAMAGE_ENEMY    0b00000000000000010
#define PM_ITEM_DAMAGE_ITEM     0b00000000000000100
#define PM_ITEM_DAMAGE_PSHOT    0b00000000000001000
#define PM_ITEM_DAMAGE_ESHOT    0b00000000000010000
#define PM_ITEM_DAMAGE_CURR     0b00000000000100000
#define PM_ITEM_DAMAGE_LIFT_ON  0b00000000001000000
#define PM_ITEM_DAMAGE_LIFT_XC  0b00000000010000000
#define PM_ITEM_DAMAGE_LIFT_XF  0b00000000100000000
#define PM_ITEM_DAMAGE_LIFT_XL  0b00000001000000000
#define PM_ITEM_DAMAGE_LIFT_YC  0b00000010000000000
#define PM_ITEM_DAMAGE_LIFT_YF  0b00000100000000000
#define PM_ITEM_DAMAGE_LIFT_YL  0b00001000000000000

item[][4]  = x pos   (2000)
item[][5]  = y pos   (2000)
item[][6]  = field x (2000)
item[][7]  = field y (2000)
item[][8]  = field w (2000)
item[][9]  = field h (2000)
item[][10] = lift number
item[][11] = mode
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val
item[][15] = damage


how many bd do I have out there?

what do I want to do first?

should I add a option to timer to always set trigger when in a timer mode?
I would then use this to control whether or not damage field is on...

my other options are:

- use damage toggle mode and timer to do what I want
(this is the simplest solution, but I worry I can't trust it to be in a specific state)

- add two event inputs to damage, on and off..
(this seems the safest but would require the most changing)


I think I will try option 2:
use damage toggle mode and timers...

see if I can replace all occurances of using the internal timers
mode 2, 3, 4..

what about display??

level 7
on until triggered, off time 60..


I have run into a snag of the first one:
what I want is for the field to be always on, then off when triggered..
the problem is that I want to not count down the off time while still triggered..

while the timer is counting down, reset if triggered..

add a mode to timer:
reset if triggered..

that should do it..

I dont have enough bits for mode fix...

then I will need to convert all the old timers...

ARGH!!

make a list to start with


glt -> timers -> t1 and t2 mode...


l:  5 y:  8  t1_mode:2 t2_mode:0
l:  5 y:  9  t1_mode:2 t2_mode:0
l:  5 y: 10  t1_mode:2 t2_mode:0
l:  6 y:  0  t1_mode:0 t2_mode:1
l:  7 y: 41  t1_mode:1 t2_mode:2
l:  7 y: 42  t1_mode:1 t2_mode:3
l:  8 y: 22  t1_mode:1 t2_mode:0
l:  8 y: 23  t1_mode:2 t2_mode:0
l:  8 y: 24  t1_mode:2 t2_mode:0
l:  8 y: 25  t1_mode:2 t2_mode:0
l:  8 y: 26  t1_mode:1 t2_mode:0
l:  9 y:  3  t1_mode:1 t2_mode:0
l:  9 y:  4  t1_mode:1 t2_mode:0
l:  9 y:  5  t1_mode:2 t2_mode:0
l:  9 y:  6  t1_mode:1 t2_mode:0
l:  9 y:  7  t1_mode:1 t2_mode:0
l: 10 y:  7  t1_mode:2 t2_mode:0
l: 10 y:  8  t1_mode:2 t2_mode:0
l: 10 y:  9  t1_mode:2 t2_mode:0
l: 11 y: 22  t1_mode:2 t2_mode:0
l: 11 y: 23  t1_mode:1 t2_mode:0
l: 11 y: 24  t1_mode:2 t2_mode:0
l: 11 y: 25  t1_mode:2 t2_mode:0
l: 11 y: 26  t1_mode:2 t2_mode:0
l: 12 y: 23  t1_mode:2 t2_mode:0
l: 12 y: 24  t1_mode:2 t2_mode:0
l: 12 y: 25  t1_mode:2 t2_mode:0
l: 12 y: 26  t1_mode:2 t2_mode:0
l: 13 y: 14  t1_mode:0 t2_mode:0
l: 13 y: 15  t1_mode:0 t2_mode:0
l: 13 y: 16  t1_mode:0 t2_mode:0
l: 13 y: 17  t1_mode:2 t2_mode:0
l: 15 y:  8  t1_mode:0 t2_mode:0
l: 16 y: 15  t1_mode:2 t2_mode:0
l: 16 y: 16  t1_mode:2 t2_mode:0
l: 16 y: 17  t1_mode:0 t2_mode:0
l: 16 y: 18  t1_mode:0 t2_mode:0
l: 17 y: 29  t1_mode:0 t2_mode:0
l: 17 y: 30  t1_mode:2 t2_mode:0
l: 17 y: 31  t1_mode:0 t2_mode:0
l: 17 y: 32  t1_mode:2 t2_mode:0
l: 17 y: 33  t1_mode:0 t2_mode:0
l: 17 y: 34  t1_mode:2 t2_mode:0
l: 18 y:  7  t1_mode:0 t2_mode:0
l: 18 y:  8  t1_mode:2 t2_mode:0
l: 19 y:  5  t1_mode:2 t2_mode:0
l: 19 y:  6  t1_mode:2 t2_mode:0
l: 20 y: 33  t1_mode:2 t2_mode:0
l: 20 y: 34  t1_mode:2 t2_mode:0
l: 20 y: 35  t1_mode:2 t2_mode:0
l: 21 y: 17  t1_mode:2 t2_mode:0
l: 21 y: 18  t1_mode:2 t2_mode:0
l: 21 y: 19  t1_mode:2 t2_mode:0
l: 21 y: 20  t1_mode:2 t2_mode:0
l: 21 y: 21  t1_mode:2 t2_mode:0
l: 21 y: 22  t1_mode:2 t2_mode:0
l: 21 y: 23  t1_mode:2 t2_mode:0
l: 22 y:  9  t1_mode:0 t2_mode:0
l: 22 y: 10  t1_mode:2 t2_mode:0
l: 22 y: 11  t1_mode:0 t2_mode:0
l: 23 y:  8  t1_mode:0 t2_mode:0
l: 23 y:  9  t1_mode:2 t2_mode:0
l: 23 y: 10  t1_mode:2 t2_mode:0
l: 29 y:  8  t1_mode:2 t2_mode:0
l: 29 y:  9  t1_mode:2 t2_mode:0
l: 29 y: 10  t1_mode:2 t2_mode:0
l: 29 y: 11  t1_mode:2 t2_mode:0
l: 30 y:  6  t1_mode:2 t2_mode:0
l: 30 y:  7  t1_mode:2 t2_mode:0
l: 30 y:  8  t1_mode:2 t2_mode:0
l: 31 y: 15  t1_mode:0 t2_mode:0
l: 32 y: 12  t1_mode:2 t2_mode:0
l: 32 y: 13  t1_mode:0 t2_mode:0
l: 32 y: 14  t1_mode:2 t2_mode:0
l: 32 y: 15  t1_mode:2 t2_mode:0
l: 32 y: 16  t1_mode:2 t2_mode:0
l: 33 y:  7  t1_mode:0 t2_mode:0
l: 33 y:  8  t1_mode:0 t2_mode:0
l: 33 y:  9  t1_mode:0 t2_mode:0
l: 33 y: 10  t1_mode:0 t2_mode:0
l: 35 y: 33  t1_mode:2 t2_mode:0
l: 35 y: 34  t1_mode:2 t2_mode:0
l: 36 y: 26  t1_mode:0 t2_mode:0
l: 49 y:  6  t1_mode:3 t2_mode:1
l: 49 y:  7  t1_mode:0 t2_mode:0
l: 49 y:  8  t1_mode:1 t2_mode:2
l: 49 y:  9  t1_mode:1 t2_mode:0
l: 49 y: 10  t1_mode:2 t2_mode:0
l: 51 y:  3  t1_mode:0 t2_mode:0
l: 51 y:  4  t1_mode:0 t2_mode:0
l: 51 y:  5  t1_mode:0 t2_mode:0
l: 51 y:  6  t1_mode:0 t2_mode:0
l: 84 y:  4  t1_mode:2 t2_mode:0
l: 84 y:  5  t1_mode:2 t2_mode:0
l: 84 y:  6  t1_mode:2 t2_mode:0
l: 86 y: 13  t1_mode:2 t2_mode:0
l: 88 y: 29  t1_mode:2 t2_mode:0
l: 88 y: 30  t1_mode:2 t2_mode:0
l: 88 y: 31  t1_mode:2 t2_mode:0
l: 88 y: 32  t1_mode:2 t2_mode:0
l: 88 y: 33  t1_mode:2 t2_mode:0
l: 89 y: 10  t1_mode:2 t2_mode:0
l: 93 y:  1  t1_mode:2 t2_mode:0
l: 93 y:  2  t1_mode:2 t2_mode:0
l: 93 y:  3  t1_mode:2 t2_mode:0
l: 95 y:  2  t1_mode:2 t2_mode:0
l: 95 y:  3  t1_mode:2 t2_mode:0
l: 97 y:  0  t1_mode:0 t2_mode:0
l: 97 y:  1  t1_mode:0 t2_mode:0
l: 97 y:  2  t1_mode:0 t2_mode:0
l: 97 y:  3  t1_mode:0 t2_mode:0
l: 98 y:  3  t1_mode:2 t2_mode:0
l:101 y:  3  t1_mode:2 t2_mode:0
l:101 y:  4  t1_mode:2 t2_mode:0
l:102 y:  0  t1_mode:2 t2_mode:0
l:106 y:  6  t1_mode:2 t2_mode:0
l:106 y:  7  t1_mode:2 t2_mode:0
l:106 y:  8  t1_mode:2 t2_mode:0
l:106 y:  9  t1_mode:2 t2_mode:0
l:107 y:  3  t1_mode:2 t2_mode:0
l:113 y:  2  t1_mode:2 t2_mode:0
l:117 y:  1  t1_mode:2 t2_mode:0
l:155 y:  3  t1_mode:2 t2_mode:0
l:155 y:  4  t1_mode:2 t2_mode:0
l:155 y:  5  t1_mode:2 t2_mode:0
l:155 y:  6  t1_mode:2 t2_mode:0
l:155 y:  7  t1_mode:2 t2_mode:0
l:160 y:  5  t1_mode:1 t2_mode:0
l:160 y:  6  t1_mode:1 t2_mode:0
l:320 y:  7  t1_mode:0 t2_mode:0
l:320 y:  8  t1_mode:0 t2_mode:0
l:320 y:  9  t1_mode:0 t2_mode:0
l:321 y:  4  t1_mode:0 t2_mode:0
l:321 y:  5  t1_mode:0 t2_mode:0
l:322 y:  4  t1_mode:0 t2_mode:0
l:322 y:  5  t1_mode:0 t2_mode:0
l:322 y:  6  t1_mode:0 t2_mode:0
l:322 y:  7  t1_mode:0 t2_mode:0
l:322 y:  8  t1_mode:0 t2_mode:0
l:322 y:  9  t1_mode:0 t2_mode:0
l:324 y:  0  t1_mode:0 t2_mode:0
l:332 y:  0  t1_mode:0 t2_mode:0
l:333 y:  0  t1_mode:0 t2_mode:0
l:360 y:  7  t1_mode:0 t2_mode:0
l:360 y:  8  t1_mode:0 t2_mode:0
l:360 y:  9  t1_mode:0 t2_mode:0
l:360 y: 10  t1_mode:0 t2_mode:0
l:360 y: 11  t1_mode:0 t2_mode:0
l:360 y: 12  t1_mode:0 t2_mode:0
l:361 y:  7  t1_mode:0 t2_mode:0
l:361 y:  8  t1_mode:0 t2_mode:0
l:363 y:  5  t1_mode:0 t2_mode:0
l:364 y: 48  t1_mode:0 t2_mode:0
l:365 y: 30  t1_mode:0 t2_mode:0
l:365 y: 31  t1_mode:0 t2_mode:0
l:365 y: 32  t1_mode:0 t2_mode:0
l:368 y:  0  t1_mode:0 t2_mode:0
l:368 y:  1  t1_mode:0 t2_mode:0
l:369 y:  5  t1_mode:0 t2_mode:0
l:369 y:  6  t1_mode:0 t2_mode:0
l:370 y:  7  t1_mode:0 t2_mode:0
l:370 y:  8  t1_mode:0 t2_mode:0
l:371 y:  3  t1_mode:0 t2_mode:0
l:371 y:  4  t1_mode:0 t2_mode:0
l:371 y:  5  t1_mode:0 t2_mode:0
l:371 y:  6  t1_mode:0 t2_mode:0
l:372 y:  0  t1_mode:0 t2_mode:0
l:374 y: 18  t1_mode:0 t2_mode:0
l:374 y: 19  t1_mode:0 t2_mode:0
l:374 y: 20  t1_mode:0 t2_mode:0
l:374 y: 21  t1_mode:0 t2_mode:0
l:375 y:  7  t1_mode:0 t2_mode:0





new set function:


st
l:  5 y:  8  t1_mode:2 t2_mode:0
l:  5 y:  9  t1_mode:2 t2_mode:0
l:  5 y: 10  t1_mode:2 t2_mode:0
l:  6 y:  0  t1_mode:0 t2_mode:1
l:  7 y: 41  t1_mode:1 t2_mode:2
l:  7 y: 42  t1_mode:1 t2_mode:3
l:  8 y: 22  t1_mode:1 t2_mode:0
l:  8 y: 23  t1_mode:2 t2_mode:0
l:  8 y: 24  t1_mode:2 t2_mode:0
l:  8 y: 25  t1_mode:2 t2_mode:0
l:  8 y: 26  t1_mode:1 t2_mode:0
l:  9 y:  3  t1_mode:1 t2_mode:0
l:  9 y:  4  t1_mode:1 t2_mode:0
l:  9 y:  5  t1_mode:2 t2_mode:0
l:  9 y:  6  t1_mode:1 t2_mode:0
l:  9 y:  7  t1_mode:1 t2_mode:0
l: 10 y:  7  t1_mode:2 t2_mode:0
l: 10 y:  8  t1_mode:2 t2_mode:0
l: 10 y:  9  t1_mode:2 t2_mode:0
l: 11 y: 22  t1_mode:2 t2_mode:0
l: 11 y: 23  t1_mode:1 t2_mode:0
l: 11 y: 24  t1_mode:2 t2_mode:0
l: 11 y: 25  t1_mode:2 t2_mode:0
l: 11 y: 26  t1_mode:2 t2_mode:0
l: 12 y: 23  t1_mode:2 t2_mode:0
l: 12 y: 24  t1_mode:2 t2_mode:0
l: 12 y: 25  t1_mode:2 t2_mode:0
l: 12 y: 26  t1_mode:2 t2_mode:0
l: 13 y: 14  t1_mode:0 t2_mode:0
l: 13 y: 15  t1_mode:0 t2_mode:0
l: 13 y: 16  t1_mode:0 t2_mode:0
l: 13 y: 17  t1_mode:2 t2_mode:0
l: 15 y:  8  t1_mode:0 t2_mode:0
l: 16 y: 15  t1_mode:2 t2_mode:0
l: 16 y: 16  t1_mode:2 t2_mode:0
l: 16 y: 17  t1_mode:0 t2_mode:0
l: 16 y: 18  t1_mode:0 t2_mode:0
l: 17 y: 29  t1_mode:0 t2_mode:0
l: 17 y: 30  t1_mode:2 t2_mode:0
l: 17 y: 31  t1_mode:0 t2_mode:0
l: 17 y: 32  t1_mode:2 t2_mode:0
l: 17 y: 33  t1_mode:0 t2_mode:0
l: 17 y: 34  t1_mode:2 t2_mode:0
l: 18 y:  7  t1_mode:0 t2_mode:0
l: 18 y:  8  t1_mode:2 t2_mode:0
l: 19 y:  5  t1_mode:2 t2_mode:0
l: 19 y:  6  t1_mode:2 t2_mode:0
l: 20 y: 33  t1_mode:2 t2_mode:0
l: 20 y: 34  t1_mode:2 t2_mode:0
l: 20 y: 35  t1_mode:2 t2_mode:0
l: 21 y: 17  t1_mode:2 t2_mode:0
l: 21 y: 18  t1_mode:2 t2_mode:0
l: 21 y: 19  t1_mode:2 t2_mode:0
l: 21 y: 20  t1_mode:2 t2_mode:0
l: 21 y: 21  t1_mode:2 t2_mode:0
l: 21 y: 22  t1_mode:2 t2_mode:0
l: 21 y: 23  t1_mode:2 t2_mode:0
l: 22 y:  9  t1_mode:0 t2_mode:0
l: 22 y: 10  t1_mode:2 t2_mode:0
l: 22 y: 11  t1_mode:0 t2_mode:0
l: 23 y:  8  t1_mode:0 t2_mode:0
l: 23 y:  9  t1_mode:2 t2_mode:0
l: 23 y: 10  t1_mode:2 t2_mode:0
l: 29 y:  8  t1_mode:2 t2_mode:0
l: 29 y:  9  t1_mode:2 t2_mode:0
l: 29 y: 10  t1_mode:2 t2_mode:0
l: 29 y: 11  t1_mode:2 t2_mode:0
l: 30 y:  6  t1_mode:2 t2_mode:0
l: 30 y:  7  t1_mode:2 t2_mode:0
l: 30 y:  8  t1_mode:2 t2_mode:0
l: 31 y: 15  t1_mode:0 t2_mode:0
l: 32 y: 12  t1_mode:2 t2_mode:0
l: 32 y: 13  t1_mode:0 t2_mode:0
l: 32 y: 14  t1_mode:2 t2_mode:0
l: 32 y: 15  t1_mode:2 t2_mode:0
l: 32 y: 16  t1_mode:2 t2_mode:0
l: 33 y:  7  t1_mode:0 t2_mode:0
l: 33 y:  8  t1_mode:0 t2_mode:0
l: 33 y:  9  t1_mode:0 t2_mode:0
l: 33 y: 10  t1_mode:0 t2_mode:0
l: 35 y: 33  t1_mode:2 t2_mode:0
l: 35 y: 34  t1_mode:2 t2_mode:0
l: 36 y: 26  t1_mode:0 t2_mode:0
l: 49 y:  6  t1_mode:3 t2_mode:1
l: 49 y:  7  t1_mode:0 t2_mode:0
l: 49 y:  8  t1_mode:1 t2_mode:2
l: 49 y:  9  t1_mode:1 t2_mode:0
l: 49 y: 10  t1_mode:2 t2_mode:0
l: 51 y:  3  t1_mode:0 t2_mode:0
l: 51 y:  4  t1_mode:0 t2_mode:0
l: 51 y:  5  t1_mode:0 t2_mode:0
l: 51 y:  6  t1_mode:0 t2_mode:0
l: 84 y:  4  t1_mode:2 t2_mode:0
l: 84 y:  5  t1_mode:2 t2_mode:0
l: 84 y:  6  t1_mode:2 t2_mode:0
l: 86 y: 13  t1_mode:2 t2_mode:0
l: 88 y: 29  t1_mode:2 t2_mode:0
l: 88 y: 30  t1_mode:2 t2_mode:0
l: 88 y: 31  t1_mode:2 t2_mode:0
l: 88 y: 32  t1_mode:2 t2_mode:0
l: 88 y: 33  t1_mode:2 t2_mode:0
l: 89 y: 10  t1_mode:2 t2_mode:0
l: 93 y:  1  t1_mode:2 t2_mode:0
l: 93 y:  2  t1_mode:2 t2_mode:0
l: 93 y:  3  t1_mode:2 t2_mode:0
l: 95 y:  2  t1_mode:2 t2_mode:0
l: 95 y:  3  t1_mode:2 t2_mode:0
l: 97 y:  0  t1_mode:0 t2_mode:0
l: 97 y:  1  t1_mode:0 t2_mode:0
l: 97 y:  2  t1_mode:0 t2_mode:0
l: 97 y:  3  t1_mode:0 t2_mode:0
l: 98 y:  3  t1_mode:2 t2_mode:0
l:101 y:  3  t1_mode:2 t2_mode:0
l:101 y:  4  t1_mode:2 t2_mode:0
l:102 y:  0  t1_mode:2 t2_mode:0
l:106 y:  6  t1_mode:2 t2_mode:0
l:106 y:  7  t1_mode:2 t2_mode:0
l:106 y:  8  t1_mode:2 t2_mode:0
l:106 y:  9  t1_mode:2 t2_mode:0
l:107 y:  3  t1_mode:2 t2_mode:0
l:113 y:  2  t1_mode:2 t2_mode:0
l:117 y:  1  t1_mode:2 t2_mode:0
l:155 y:  3  t1_mode:2 t2_mode:0
l:155 y:  4  t1_mode:2 t2_mode:0
l:155 y:  5  t1_mode:2 t2_mode:0
l:155 y:  6  t1_mode:2 t2_mode:0
l:155 y:  7  t1_mode:2 t2_mode:0
l:160 y:  5  t1_mode:1 t2_mode:0
l:160 y:  6  t1_mode:1 t2_mode:0
l:320 y:  7  t1_mode:0 t2_mode:0
l:320 y:  8  t1_mode:0 t2_mode:0
l:320 y:  9  t1_mode:0 t2_mode:0
l:321 y:  4  t1_mode:0 t2_mode:0
l:321 y:  5  t1_mode:0 t2_mode:0
l:322 y:  4  t1_mode:0 t2_mode:0
l:322 y:  5  t1_mode:0 t2_mode:0
l:322 y:  6  t1_mode:0 t2_mode:0
l:322 y:  7  t1_mode:0 t2_mode:0
l:322 y:  8  t1_mode:0 t2_mode:0
l:322 y:  9  t1_mode:0 t2_mode:0
l:324 y:  0  t1_mode:0 t2_mode:0
l:332 y:  0  t1_mode:0 t2_mode:0
l:333 y:  0  t1_mode:0 t2_mode:0
l:360 y:  7  t1_mode:0 t2_mode:0
l:360 y:  8  t1_mode:0 t2_mode:0
l:360 y:  9  t1_mode:0 t2_mode:0
l:360 y: 10  t1_mode:0 t2_mode:0
l:360 y: 11  t1_mode:0 t2_mode:0
l:360 y: 12  t1_mode:0 t2_mode:0
l:361 y:  7  t1_mode:0 t2_mode:0
l:361 y:  8  t1_mode:0 t2_mode:0
l:363 y:  5  t1_mode:0 t2_mode:0
l:364 y: 48  t1_mode:0 t2_mode:0
l:365 y: 30  t1_mode:0 t2_mode:0
l:365 y: 31  t1_mode:0 t2_mode:0
l:365 y: 32  t1_mode:0 t2_mode:0
l:368 y:  0  t1_mode:0 t2_mode:0
l:368 y:  1  t1_mode:0 t2_mode:0
l:369 y:  5  t1_mode:0 t2_mode:0
l:369 y:  6  t1_mode:0 t2_mode:0
l:370 y:  7  t1_mode:0 t2_mode:0
l:370 y:  8  t1_mode:0 t2_mode:0
l:371 y:  3  t1_mode:0 t2_mode:0
l:371 y:  4  t1_mode:0 t2_mode:0
l:371 y:  5  t1_mode:0 t2_mode:0
l:371 y:  6  t1_mode:0 t2_mode:0
l:372 y:  0  t1_mode:0 t2_mode:0
l:374 y: 18  t1_mode:0 t2_mode:0
l:374 y: 19  t1_mode:0 t2_mode:0
l:374 y: 20  t1_mode:0 t2_mode:0
l:374 y: 21  t1_mode:0 t2_mode:0
l:375 y:  7  t1_mode:0 t2_mode:0
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0


I think they are all converted..moving on...

now I can make block damage in level 7 do what I want it to do


Running Global Level Test
l:1 y:0  mode:0
l:7 y:0  mode:1
l:7 y:1  mode:0
l:7 y:2  mode:0
l:7 y:3  mode:0
l:7 y:4  mode:0
l:7 y:5  mode:0
l:7 y:6  mode:0
l:9 y:0  mode:3
l:9 y:1  mode:3
l:11 y:0  mode:0
l:11 y:1  mode:3
l:11 y:2  mode:3
l:12 y:0  mode:0
l:12 y:1  mode:0
l:12 y:2  mode:0
l:12 y:3  mode:0
l:12 y:4  mode:0
l:13 y:0  mode:0
l:13 y:1  mode:3
l:15 y:0  mode:0
l:15 y:1  mode:0
l:15 y:2  mode:0
l:15 y:3  mode:0
l:15 y:4  mode:0
l:15 y:5  mode:0
l:15 y:6  mode:0
l:16 y:0  mode:3
l:16 y:1  mode:0
l:16 y:2  mode:3
l:16 y:3  mode:3
l:18 y:0  mode:0
done up to here:

l:20 y:1  mode:3
l:20 y:2  mode:0
l:20 y:3  mode:0
l:20 y:4  mode:3
l:20 y:5  mode:3
l:20 y:6  mode:0
l:20 y:7  mode:0
l:20 y:8  mode:0
l:20 y:9  mode:0
l:20 y:10  mode:3
l:20 y:11  mode:3
l:20 y:12  mode:0
l:20 y:13  mode:0
l:20 y:14  mode:0
l:21 y:0  mode:0
l:22 y:0  mode:0
l:22 y:1  mode:0
l:22 y:2  mode:0
l:22 y:3  mode:0
l:22 y:4  mode:0
l:22 y:5  mode:0
l:24 y:0  mode:3
l:26 y:0  mode:0
l:26 y:1  mode:0
l:28 y:0  mode:0
l:28 y:1  mode:0
l:31 y:0  mode:3
l:32 y:0  mode:3
l:32 y:1  mode:3
l:34 y:0  mode:0
l:34 y:1  mode:0
l:34 y:2  mode:0
l:34 y:3  mode:0
l:35 y:0  mode:3
l:35 y:1  mode:3
l:35 y:2  mode:3
l:35 y:3  mode:3
l:35 y:4  mode:0
l:35 y:5  mode:0
l:36 y:0  mode:3
l:36 y:1  mode:3
l:49 y:0  mode:3
l:49 y:1  mode:1
l:81 y:0  mode:0
l:82 y:0  mode:0



what if I made a new mode for bd...one time on..

when triggered, do the damage, don't toggle anything

then I would not have to use dual timer and toggle for simple one time damage blasts...

also how about on unless triggered..I know I already have that, but how about one without a timer

try the one time first..

mode 5 damage when triggered
this could replace almost everything (except always on)

new proposed modes:
0 always on
1 toggle
2 on till triggered
3 off till triggered

then just make timer capable of constant output

1 - make timer capable of constant event output
normal mode: send event when timer complete
constant: send trigger continoulsy when timer active
added to flags and ov


now do something with it..

change bd mode 2 and 3

these are now the only modes

0 always on
1 toggle
2 on till triggered
3 off till triggered



Running Global Level Test
l:1 y:0  mode:0
l:7 y:0  mode:2 still needed timer
l:7 y:1  mode:0
l:7 y:2  mode:0
l:7 y:3  mode:0
l:7 y:4  mode:0
l:7 y:5  mode:0
l:7 y:6  mode:0
l:9 y:0  mode:1 now mode 3 still no timer
l:9 y:1  mode:1 now mode 3 still no timer
l:11 y:0  mode:0
l:11 y:1  mode:1
l:11 y:2  mode:1
l:12 y:0  mode:0
l:12 y:1  mode:0
l:12 y:2  mode:0
l:12 y:3  mode:0
l:12 y:4  mode:0
l:13 y:0  mode:0
l:13 y:1  mode:1
l:15 y:0  mode:0
l:15 y:1  mode:0
l:15 y:2  mode:0
l:15 y:3  mode:0
l:15 y:4  mode:0
l:15 y:5  mode:0
l:15 y:6  mode:0
l:16 y:0  mode:1
l:16 y:1  mode:0
l:16 y:2  mode:1
l:16 y:3  mode:1
l:18 y:0  mode:0
l:20 y:0  mode:0
l:20 y:1  mode:1
l:20 y:2  mode:0
l:20 y:3  mode:0
l:20 y:4  mode:1
l:20 y:5  mode:1
l:20 y:6  mode:0
l:20 y:7  mode:0
l:20 y:8  mode:0
l:20 y:9  mode:0
l:20 y:10  mode:1
l:20 y:11  mode:1
l:20 y:12  mode:0
l:20 y:13  mode:0
l:20 y:14  mode:0

done
l:21 y:0  mode:0
l:22 y:0  mode:0
l:22 y:1  mode:0
l:22 y:2  mode:0
l:22 y:3  mode:0
l:22 y:4  mode:0
l:22 y:5  mode:0
l:24 y:0  mode:1

l:26 y:0  mode:0
l:26 y:1  mode:0
l:28 y:0  mode:0
l:28 y:1  mode:0


l:31 y:0  mode:3

l:32 y:0  mode:3
l:32 y:1  mode:3

l:34 y:0  mode:0
l:34 y:1  mode:0
l:34 y:2  mode:0
l:34 y:3  mode:0



l:35 y:0  mode:3
l:35 y:1  mode:3
l:35 y:2  mode:3
l:35 y:3  mode:3
l:35 y:4  mode:0
l:35 y:5  mode:0


mode 2 and 3 do not need any changes..




l:36 y:0  mode:3
l:36 y:1  mode:3



l:49 y:0  mode:3
l:49 y:1  mode:1

l:81 y:0  mode:0
l:82 y:0  mode:0
l:82 y:1  mode:0
l:82 y:2  mode:0
l:82 y:3  mode:0

l:83 y:0  mode:3
l:83 y:1  mode:0
l:83 y:2  mode:0
l:83 y:3  mode:0
l:83 y:4  mode:0
l:83 y:5  mode:3
l:83 y:6  mode:3

l:86 y:0  mode:3
l:86 y:1  mode:3
l:86 y:2  mode:2

all done up to level 88 bd example

fixed ov also..

now do something about draw mode..

red rect and spikey floor are good

do they work without timer?
yes, removed a bunch of stuff...


If I want to show progress use the timer...



l:95 y:0  mode:3
l:98 y:0  mode:0
l:98 y:1  mode:0
l:108 y:0  mode:0
l:110 y:0  mode:0
l:153 y:0  mode:0
l:155 y:0  mode:3
l:157 y:0  mode:0
l:157 y:1  mode:0
l:157 y:2  mode:0
l:157 y:3  mode:0
l:157 y:4  mode:0
l:157 y:5  mode:0
l:157 y:6  mode:0
l:157 y:7  mode:0
l:157 y:8  mode:0
l:157 y:9  mode:0
l:157 y:10  mode:0
l:157 y:11  mode:0
l:157 y:12  mode:0
l:157 y:13  mode:0
l:157 y:14  mode:0
l:157 y:15  mode:0
l:157 y:16  mode:0
l:157 y:17  mode:0
l:157 y:18  mode:0
l:157 y:19  mode:0
l:157 y:20  mode:0
l:157 y:21  mode:0
l:157 y:22  mode:0
l:157 y:23  mode:0
l:157 y:24  mode:0
l:157 y:25  mode:0
l:157 y:26  mode:0
l:157 y:27  mode:0
l:157 y:28  mode:0
l:157 y:29  mode:0
l:157 y:30  mode:0
l:157 y:31  mode:0
l:157 y:32  mode:0
l:157 y:33  mode:0
l:157 y:34  mode:0
l:157 y:35  mode:0
l:157 y:36  mode:0
l:157 y:37  mode:0
l:157 y:38  mode:0
l:157 y:39  mode:0
l:157 y:40  mode:0
l:157 y:41  mode:0
l:157 y:42  mode:0
l:157 y:43  mode:0
l:157 y:44  mode:0
l:157 y:45  mode:0
l:157 y:46  mode:0
l:157 y:47  mode:0
l:157 y:48  mode:0
l:157 y:49  mode:0
l:160 y:0  mode:3
l:160 y:1  mode:0
l:160 y:2  mode:3
l:313 y:0  mode:0
l:322 y:0  mode:2
l:322 y:1  mode:2
l:374 y:0  mode:8
l:374 y:1  mode:0
l:374 y:2  mode:0
l:374 y:3  mode:3
l:374 y:4  mode:3
l:375 y:0  mode:2
l:375 y:1  mode:0
l:375 y:2  mode:0
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0



all have been gone through....


moving some things from to do to done...

make level editor zoom mode that fits entire level vertically on screen..done

make block manip show flags for its blocks..done

in visual level select, make hotkey 'L' to start level editor on selected level
does not do as intended when L is a control...use END instead...done


ov set to zero sometimes buggy...i think i fixed it...




bug when adjusting trigger field in ov can't get last x pos..fixed

bug when drawing trigger field in overlay draws twice at wrong size
when ever drawing trigger shape in ov or draw item, etc...fixed by adding custom to draw_trigger

bug -- in level editor can't see trigger box edges on left or top if zero..fixed

bug - block damage does not destroy items..fixed

bug - when cloner is hidden, it shows till run for the first time..fixed
fixed this in draw cloner

bug - when cloner is invincible do not target with explosions..done

bug - player not hurt by damage field...fixed




another trigger emitter, based soley on time
cloner to take a trigger input
damage field to use this new trigger item
block manip also..

trigger emitters:
orb
trigger
-timer
-lift

trigger receivers:
block damage
block manip
lift
-cloner



20230312

mostly done with new event stuff, no new major features planned, just bugs as they pop up

fixed lift prox not showing in level editor again..


make spikes have some intermediate steps...

2 intermediate
0 - off 808
1 - 1/3
2 = 2/3
3 = on 807


0/3 - 1/3 804
1/3 - 2/3 805
2/3 - 3/3 806
3/3       807

find out what item is triggering
similar to how cloner does it..done and it looks good..
I only have one use of this in all levels!




I have a pretty big idea:


Make some more items that control things about the level.

Zones
big rectangular areas of the level that can be hidden or shown
maybe dependant on whether the player is in the zone or not

Field that lights bombs and rockets...

Springs that activate just by proximity...also have abritrary direction..like pinball bumpers




Wrap lines
horizontal or vertical line that instantly transport objects..

make a new item type
type 20 wrap

rectangle with four points..


for example lets just do a horizontal one.

for this we need 2 horizontal lines of the same length
x1, x2 and width

y1 and y2

do we need to specify which is the input and which is the output?

maybe it would be easier to do a rectangle and assume that nothing exists outside it.
all object exist inside and wrap when hitting an edge

optional x and y

optional for different types of objects??


make new item 20 with rectangle..

where do I start?
draw a shape or pick one...
544 for now

made simple PDE item.
make ov

now lets try some functionality

looking good!!

bullets go on forever..
make an option to not include them, or kill them at boundaries
did not even try to make lifts work, they use absolute positions



x and y only?  If I don't want them going off in one axis, either manually kill them or make a wall



make an button for what is affected:

Players
items
enemies
pbul
ebul

item[][3]  = flags
#define PM_ITEM_WRAP_PLAYER   0b000000000000000001
#define PM_ITEM_WRAP_ENEMY    0b000000000000000010
#define PM_ITEM_WRAP_ITEM     0b000000000000000100
#define PM_ITEM_WRAP_PSHOT    0b000000000000001000
#define PM_ITEM_WRAP_ESHOT    0b000000000000010000
#define PM_ITEM_WRAP_XMN      0b000000000000100000
#define PM_ITEM_WRAP_XPL      0b000000000001000000
#define PM_ITEM_WRAP_YMN      0b000000000010000000
#define PM_ITEM_WRAP_YPL      0b000000000100000000



some times things escape from the warp, not sure why and how I can prevent it...

I could have a mode where everything is forced to be within the rectangle, and if not jump it to there...
this would ony work with one wrap


how about check if object is within rectangle


it always seems to move to the other side fine, but once there not so good.
could I move to the other side and add inc??

how about not using any offset +10 -10? only do that when drawing..nah


I want to make this pixel perfect, I'm not sure what is going wrong...


how about check if object is within rectangle, then only check if it leaves...

I think this has to do with returning back to the same line we came from

get some data...


y1:310
y2:430

y 310 - good
move up .5
not caught in proc changed to 309.5

I finally fixed it, by adding xi, yi to h and w at the end of the line

if ((item[i][3] & PM_ITEM_WRAP_YPL) && (yi > 0) && (x >= x1) && (x <= x2) && (y <= y2) && (y+yi > y2)) y -= (h-yi); // moving down
if ((item[i][3] & PM_ITEM_WRAP_YMN) && (yi < 0) && (x >= x1) && (x <= x2) && (y >= y1) && (y+yi < y1)) y += (h+yi); // moving up
if ((item[i][3] & PM_ITEM_WRAP_XPL) && (xi > 0) && (y >= y1) && (y <= y2) && (x <= x2) && (x+xi > x2)) x -= (w-xi); // moving right
if ((item[i][3] & PM_ITEM_WRAP_XMN) && (xi < 0) && (y >= y1) && (y <= y2) && (x >= x1) && (x+xi < x1)) x += (w+xi); // moving left

I think I want to add something to bullets to kill them if they travel too far, or pass through too many wraps...

ladder does not work with wrap, probably due to no yinc..fixed


Now I would like to make something very similar but not aligned with a rectangle..
they could even be at right angles to each other...
It sounds like I am making portals!!

input line x or y
input direction + or -

output line x or y
ouptut direction + or -

one way or 2 way


rename old one wrap rect
new one wrap line


what am I going to do for variables:

i/p
x,y length

o/p
x,y

#define PM_ITEM_WRAP_PLAYER   0b000000000000000001
#define PM_ITEM_WRAP_ENEMY    0b000000000000000010
#define PM_ITEM_WRAP_ITEM     0b000000000000000100
#define PM_ITEM_WRAP_PSHOT    0b000000000000001000
#define PM_ITEM_WRAP_ESHOT    0b000000000000010000
#define PM_ITEM_WRAP_IPXY     0b000000000000100000
#define PM_ITEM_WRAP_IPPM     0b000000000001000000
#define PM_ITEM_WRAP_OPXY     0b000000000010000000
#define PM_ITEM_WRAP_OPPM     0b000000000100000000

I am going to skip this idea for now..


Lets see if I can flesh out the zones idea.


If there are no zones, act like normal.

Zones can have types or modes..

type 0 means do not draw

type 1 means draw always

type 2 means draw only when player is in zone

do I need this? multiplayer will be confusing

what about vertical launch pads




20230401 I have been busy on another project for a while

coming back, it looks like I am in the middle of WRAP, and still cant get it to work as good as I want

then I have some other things to clean up..

20230416

my other project is done for now...

having this break from pm hopefully has reset my obsession...
now that I am back I want to halt all new features and just complete and release the thing...

specifically:
roll back wrap
remove wrap line and wrap rect
remove all instances in levels and remove from PDE...

removed this from bugs as it has been fixed:

prox in lifts is not right, uses prev step speed..fixed
drawing arrows has tracers..it makes no sense to me
it is an artifact from the shape beside it.
tile 488 is a right facing bullet
tile 487 is archwagon
they are both with the boundaries in gimp
none of these flags are used ALLEGRO_MIN_LINEAR ALLEGRO_MAG_LINEAR ALLEGRO_MIPMAP
it only happens at certain bullet speeds:
9.0 no
9.1 yes
9.2 no
9.3 yes
9.4 no
9.5 yes
I don't see it happpening for any other shape
the draw routine for e shots is very straight forward
al_draw_bitmap(mBitmap.tile[t], e[b].x, e[b].y, 0);
I will try to fix it with a hack, but it is very worrying to me
it should not do this..
use tile 328 and 329 instead on 488 and 489..fixed...





20230417

what is hotkey for settings? CTRL SHFT O

make eco_draw an option in settings ..done
remove F2 hot key to toggle eco_draw..done
only show eco draw in bottom frame when on..done






----------------------------------
add bottom message settings page
----------------------------------

in this page I want to show demo bmsg and have live changes



- what variables?

- save variables in cfg



add a bunch of settings for bottom message:
how many lines: 8 (max 20)
float io = 1.0; // initial opacity
float fo = 0.1; // final opacity
float ivs = 0.5; // initial v size
float fvs = 0.1; // final v size
float ihs = 0.5; // initial h size
float fhs = 0.1; // final h size

which game events cause messages

player tile, text or both
enemy  tile, text or both
item   tile, text or both

how close the player has to be to reduce messages



change event 2 to not need a specific item.

old:
mGameEvent.add(2, 0, 0, p, i, 0, 0);
if (ev == 2) // key
{
   custom_drawn = 1;
   bmsg_length += draw_text(" got a ", 15, bmsg_length);

   int c1 =0;  // color
   int tn = 0; // tile_numer
   int k = mItem.item[z2][1] - 1039;
   char tmsg[20] = {0};


new:
mGameEvent.add(2, 0, 0, p, mItem.item[i][1], 0, 0);
if (ev == 2) // key
{
   custom_drawn = 1;
   bmsg_length += draw_text(" got a ", 15, bmsg_length);

   int c1 =0;  // color
   int tn = 0; // tile_numer
   int k = z2 - 1039;
   char tmsg[20] = {0};


it has never come up before, but I do not have colors set for any player except 0
i only set those when needed in netgame
choose unued color?? only looks at active players
I don't think it could hurt to set those colors, will only be used by bmsg settings...
do it in initial setup..done


change:
mPlayer.loc[4].block_damage_item_number

to:
mPlayer.loc[4].block_damage_type

mGameEvent.add(59, 0, 0, p, i, 0, 0); // only do damage noise when taking health..??
does not set in player struct...
fixed all this to senf type item[i][2] in z2 and damage item[i][15] in z4
59 sets mPlayer.loc[4].block_damage_type
58 prints it..


72 health bonus
I want it to show the tile for flowers also...done...


now I am at the point that I want to start adjusting variables..

I might need to make them externally accessible and save them in config

how many lines: 8 (max 20)
float io = 1.0; // initial opacity
float fo = 0.1; // final opacity
float ivs = 0.5; // initial v size
float fvs = 0.1; // final v size
float ihs = 0.5; // initial h size
float fhs = 0.1; // final h size

this works great so far..

increase the max number of lines..done
make live adjustments..done

save in config
make button for defaults



void get_door_tile(int i, int &col, int &type)
{
   col = mItem.item[i][6];

   if (mItem.item[i][13] == 1083) type = 0;
   if (mItem.item[i][13] == 448) type = 1;
   if (mItem.item[i][13] == 0) type = -1;

}

pass these with event...





--------------

20230419

clean up the bitmap drawing routines in bmsg

they should all call one with passed bmp and offset

20230420
items are all on the new plan except I want to do nicer for bonus

928 - banana
929 - apple
930 - white flower
931 - pink flower
932 - blue cherries
933 - carrot
934 - red flower
935 - rainbow

960 - yellow
961 - red
962 - white
963 - pink
964 - blue
965 - orange
966 - green
967 - lt blue

now all of the items are done.

cleaned up the draw bmp and text routines..now there are only two...

next is the health drawing....

commit...its been a long time...

health drawing is done..

now toggles for each type..
this will be a lot...

use event numbers?


remember when I had msgs that showed up on screen where the stuff happened?
20030619 no
20061025 no
20091210 no
20100314 yes



20230422

player text long/short ...done
change buttonp to return 1 if pressed...currently void...done

make toggles for types
how many and where will I show them all?


23 unique


2  key
3  exit
5  door
30 switch
24 bomb
26 rocket

50 player hit a mine

59 raw damage
58 player lost health from block damage

71 player got a purple coin
72 player got a health bonus



43 player got shot by enemy
44 player got hit by enemy
40 player got shot by another player
52 exploded another player

60 player killed enemy with a shot
62 player killed enemy with explosion



54 player got squished
56 player got stuck


80 player joined
81 player quit
90 player died


int filter_event[100];



what about widget toggle? can I make it return 1 if pressed?
right now it returns value

it looks like the return value is never used for togglec...
test by making it void...compiles fine..

now change it to return 1 if pressed...done
maybe do the other toggles later...


combine both bombs into one
24 and 25 done...

combine 40 and 41...also 52 and 53

40 player got shot by another player
41 player shot themself
52 exploded another player
53 player exploded themself


add these to damage
54 player got squished
56 player got stuck


mGameEvent.add(54, x, y, p, 0, 0, 0); 5 calls
mGameEvent.add(56, x, y, p, 0, 0, 0); 1 call


if ((mLoop.frame_num) && (mLoop.frame_num == loc[p].block_damage_holdoff)) mGameEvent.add(58, 0, 0, p, 0, 0, 0);



does stuck and squished trigger every frame? looks like it..

I do custom holdoff for mine and block damage, but not for squished and stuck...
change to handle all the same....

also locked exit can trigger every frame



make stuck (56) send 59 instead, but make z2 type something else...


         if (type == 2) draw_text(" was hurt by spikey floor ", 15, xpos);
         else           draw_text(" was hurt by block damage ", 15, xpos);



mGameEvent.add(59, 0, 0, p, item[i][2], 0, item[i][15]); // only do damage noise when taking health..??

what specific types are used? 2 and ??

      if (var == 0) sprintf(msg, "Draw Type:none         ");
      if (var == 1) sprintf(msg, "Draw Type:Red Rectangle");
      if (var == 2) sprintf(msg, "Draw Type:Spikey Floor ");


if (ha > 0) // lose health
{
   int damage_type = 1; // default
   if (item[i][2] == 2) damage_type = 2;
   mGameEvent.add(59, 0, 0, p, damage_type, 0, item[i][15]); // only do damage noise when taking health..??




now can I add mine to that?

make it type 5
is damage the same scale? an int divided by 100?

mGameEvent.add(59, 0, 0, p, 5, 0, item[i][15]);


this is damage item
float ha = (float)item[i][15]/100; // health adjust

this is mine
mPlayer.syn[p].health -= (float)mItem.item[i][8] / 10;

change mine to use same scale


look in glt for all mines and get range...

looks like 5 10 12 20.....

multiply all by 10....done

adjust slider in ov..done
make default in PDE 50 from 5..done..

fix collision

void mwItem::proc_mine_collision(int p, int i)
{
   mPlayer.syn[p].health -= (float)mItem.item[i][8] / 100;
//   mGameEvent.add(50, 0, 0, p, i, 0, mItem.item[i][8]);
   mGameEvent.add(59, 0, 0, p, 5, 0, mItem.item[i][8]);
}

patch into bmsg..

      if (ev == 58) // player took damage (lost health from block damage, mine, stuck...
      {
         custom_drawn = 1;
         draw_text(" was hurt by ", 15, xpos);
         int damage = (int) mPlayer.loc[z1].block_damage_tally;
         int type = mPlayer.loc[z1].block_damage_type;
         if (type == 1) draw_text(" block damage ", 15, xpos);
         if (type == 2) draw_text(" spikey floor ", 15, xpos);
         if (type == 5) draw_item(mBitmap.tile[456], "mine", 15, xpos, 0, 0);
         draw_health(z1, -damage, xpos);
      }


remove mine holdoff stuff...done
remove 50 from config..done
rename three var in lo player sruct to remove 'block_'...done
when player health sends 58 send type as z2...done...

add stuck...make it type 7

void mwPlayers::proc_player_stuck_in_blocks(int p)
{
//      mGameEvent.add(56, x, y, p, 0, 0, 0);
      mGameEvent.add(59, x, y, p, 7, 0, 100);
   }
}

works
add squished ..make it type 9,,done

pass damage as z4 when player health sends 58


now i only have 18 unique types

      asci(BMSG, mBottomMessage.filter_event[2])
      asci(BMSG, mBottomMessage.filter_event[3])
      asci(BMSG, mBottomMessage.filter_event[5])
      asci(BMSG, mBottomMessage.filter_event[30])
      asci(BMSG, mBottomMessage.filter_event[24])
      asci(BMSG, mBottomMessage.filter_event[26])

      asci(BMSG, mBottomMessage.filter_event[71])
      asci(BMSG, mBottomMessage.filter_event[72])

      asci(BMSG, mBottomMessage.filter_event[40])
      asci(BMSG, mBottomMessage.filter_event[43])
      asci(BMSG, mBottomMessage.filter_event[44])

      asci(BMSG, mBottomMessage.filter_event[60])
      asci(BMSG, mBottomMessage.filter_event[62])
      asci(BMSG, mBottomMessage.filter_event[52])

      asci(BMSG, mBottomMessage.filter_event[80])
      asci(BMSG, mBottomMessage.filter_event[81])
      asci(BMSG, mBottomMessage.filter_event[90])


      asci(BMSG, mBottomMessage.filter_event[58])


2  key
3  exit
5  door
30 switch
24 bomb
26 rocket

71 player got a purple coin
72 player got a health bonus



40 player got shot by another player
43 player got shot by enemy
44 player got hit by enemy

60 player killed enemy with a shot
62 player killed enemy with explosion
52 exploded another player

80 player joined
81 player quit
90 player died

59 raw damage
58 player lost health from block damage

do some renaming

I want a master list of all my events...
some play sounds, some trigger bmsg


rearrange done..now fix bugs...

fuse hiss gone...fixed
for some reason proc_sound was not being called once per frame...

add all message controls then test...

test player hurt player in single player mode...
will need to do multiplayer for that


test enemy hit player..good
test enemy shot player..good

player shot enemy..good
player exploded enemy..good

player enemy collision..good

damage tally, mine, block damage, stuck, squished..good..
make default setting button



20230425
I think I finally have the settings page for bottom message done..
everything is lined up nice and looks good..

I still need to test the muliplayer messages...

what else do I need to finish?


wrap rect 20
wrap line 21
remove wrap PDE..done
remove wrap from levels..done
remove wrap from ov..commented out

change name of global level thingy..done

move test levels from 50 to higher...done...

go through levels and fix additions..

edit text for pmsg shows red ^ for most text...why?
in draw pop msg, when I draw the cursor, I count on char 30 being a blank space that does not count as a space
how can I fix this?
changed to char 96..its a good blank char in font pr8

visual level select to wrap when moving left and right and up and down...done

spelling mistakes premanment..fixed

edit text in trigger demo level..done

make mouse b2 exit settings..done
make mouse able to click on game menu..done
make mouse able to click on visual level select..done



make advanced section of settings
- how to toggle?
- what pages are advanced?


basic

   sprintf(st[0].title,  "Basics");
   sprintf(st[1].title,  "Controls");
   sprintf(st[2].title,  "Netgame");



advanced:
   sprintf(st[3].title,  "Double");
   sprintf(st[4].title,  "Demo");
   sprintf(st[5].title,  "Advanced");
   sprintf(st[7].title,  "Viewport");
   sprintf(st[10].title, "Overlay");
   sprintf(st[11].title, "Message");


debug:
   sprintf(st[6].title,  "Info");
   sprintf(st[8].title,  "Profiling");
   sprintf(st[9].title,  "Logging");

make a way to re-arrange without having to renumber

add to st struct what actual page each one is

another way would be to allow blanks in the list and just not draw them

then they could still keep their numbers

I would just turn on and off ones I don't want to show

yes, this sounds a lot simpler


make the 3 basic pages
Basics
Controls
Netgame

on basic pages

show advanced settings
show debug settings

these will show extra pages and also show more options on single pages

move stdf freq and udp/tcp to advanced on netgame..done

make a button to reset all config values to default (erase config file and reload)

do it on basic page for now, but later maybe have an advanced tab that has
this reset button and the advanced and debug toggles
also make it erase the level editor config mW.pm ..done
make server name look better:
frame it on its own line
edit text...done


make advanced tab part of basic stuff...
also demo

done...
add reset config and advanced and debug toggles..done

move spline test and eco draw somewhere else

add help buttons to settings..done

make message part of default
swap with double


make it so that I can configure system keys like F12, etc...


where can I move eco draw? speed controls, spline test?
I need more tabs in settings...
but another row would mess with height...

do it any way...

make another row, then see how things line up...done
moved crap to misc


newly created podzillas don't work...
also copied ones
why?
existing ones work...
there was a stupid al_fix_div with floats

copied podzilla have wrong size...
why?
fixed bug when savind sel, saved floats as ints...

make mouse wheel scroll in help..done

20230430 6:00 AM
Mom's bday


look at the level done stuff for netgame

single player music plays after level done
right now stop_sound is called in:
   if (mLoop.program_state == 12)
   {
      mSound.stop_sound();

but this is too late

move that call to

void mwLoop::proc_level_done_mode(void)
{
   if (mPlayer.syn[0].level_done_mode == 9) // pause players and set up exit xyincs
   {
      mSound.stop_sound();
that sounds kind of abrupt
can I gradually fade out?
   if (mPlayer.syn[0].level_done_mode == 8) // players seek exit
   {
//      float fade = (float) mPlayer.syn[0].level_done_timer / 60; // 1 to 0 in 60 frames
//      float fade = 0.5 + (float) mPlayer.syn[0].level_done_timer / 120; // 1 to .5 in 60 frames
      float fade = 0.3 + (float) mPlayer.syn[0].level_done_timer / 85; // 1 to .3 in 60 frames
      if (mSound.sound_on) al_set_mixer_gain(mSound.st_mixer, ((float)mSound.st_scaler / 9) * fade);

when players seek exit and it takes 60 frames fade from 1.0 to 0.3
restore mixer levels in start sound..
done...

stimp and warp level done stuff....
level done shows briefly when using warp
I can reduce the time, but what if it breaks things in network level done?
I'm getting a stimp in single player

tested multiplayer LAN 3P 150-153 has warp at end.. all good

temp made stimp and stamp 140frame from 40 for testing

is stamp only used when going back to menu?
right now level done does not stamp, but stimps


stamp is called only once, when changing program state to 1


stimp is called:

single player new game
level done
resume game
run demo


just looking at this, I would think I could remove the level done stimp...
or in level done do both stamp and stimp...
this sounds much more complex...
I think I've got it fixed by removing stimp in level done...
what if I added something the the level done..no

in screen overlay don't show large LEVEL DONE for level done modes < 4
that fixes the bried large LEVEL DONE in warp mode..

I think this is all fixed

fix stimp and stamp times, now 60..done

fix bmsg always on..fixed


look at command line switches in help..done

controls in help...
add help button to control page in settings
done
remove serial key..done
config file..done
title stretched??..fixed..
naviagation..done..




I want to make the system function keys configureable...


first make a list


[F1] fake key

<l14>         [F5] - Zoom Out (decrease scale factor)
<l14>         [F6] - Zoom In (increase scale factor)
<l14>    [F5]+[F6] - Reset Zoom (set scale factor to 1.0)

<l09>         [F7] - Speed Decrease (by 1 frame per second)
<l57>  [SHIFT][F7] - Speed Decrease (by 20 frames per second)
<l89>[CONTROL][F7] - Speed Decrease (by 100 frames per second)

<l09>    [F7]+[F8] - Reset Speed (set frames per second to 40)

<l09>         [F8] - Speed Increase (by 1 frame per second)
<l57>  [SHIFT][F8] - Speed Increase (by 20 frames per second)
<l89>[CONTROL][F8] - Speed Increase (by 100 frames per second)




<l15>        [F10] - Toggle the debug overlay

<l05>[PRINTSCREEN] - Saves a screen shot in the screenshot folder

<l13>        [F12] - Toggle Full Screen Mode


variables for config
I need a good name:
I have game controls, what do I call the others?
other controls

OTHER_CONTROLS_FULLSCREEN

other_control_fullscreen_toggle


function_key_fullscreen
function_key_text_double
function_key_debug_overlay
function_key_fakekey
function_key_printscreen
function_key_zoom_in
function_key_zoom_out

check for all these in function check
if any are set to 0 they are considered disabled


save them in config

edit them in settings...

F12 fullscreen
F11 double
F10 debug overlay

it works, but now I have to make it look good in settings...better

make a way to disable a control...
if press esc then set to zero
done


add names for missing things...
like ~

detect duplicate keys
done

set to defaults..done

center the top thing..done

make size dynamic..done
can adjust num lines and higher ones will not be shown

add more keys
speed
force_save
force_init_background

this is all done..

now I kind of want to make this more accessible

show tab with advanced

show last three with debug...
done

rename to "Function Keys"
show always

rename to "Controls 2"
title "Function Keys"

done...

make a new tab for speed control

add some framing to netgame tab..looks great now...

how about advanced toggle in title?..done

am I done with settings?

what else could I possibly add?

optional resolution in window title
- I can already show it with debug overlay

optional text in bottom frame

main menu level editor shortcut key

level editor ov lock key

change settings page for double...configrable key and default..done

max level num to show in visual level select..done



20230502 done with settings...

moving on...


alt levels...the ones not good enough for the main sequence
move the best ones to 50 and up
move others to > 200
done

when changing max_num_levels, force reload of vls..done


level 7 archwag can get pressed down through floor by lift
making level impossible to complete...
added damage field to block, that should fix it..







how do I make the spikes show progress?

instant mode is when bd is set to toggle
timer has t1 and t2 and both are set to one time output

bd on until triggered
timer mode continuous


there are 2 frames at the end of timer when ratio is very low but timer has not switched yet...
this makes the spike drawing not work nicely

how to fix?

fixed...


spikes only show progress when in modes:
2 on until triggered
3 off until triggered

spikes only show progress when:
curr damage is off and
a timer is counting down to turn them on..


I want to change pristine font to use better looking straight single and double quotes
did for p8 only...looks good...


add timer page to help..done


when sorting items, sort starts by start index...done
will make setting them up so much easier



block damage demo level
display stuff - bd no long has its own display stuff
fix modes - bd no longer has any timer modes
done..

when moving timer with es, display area should move also..done






SHIFT move timer in ov to move display box also

make swicth box move also like key
list of items that all should do that:
4 key
9 trigger
10 msg
13 timer
14 switch
16 manip
17 damage

// does the item type have a secondary position at 6,7?
int mwItem::item_secondary67(int type)
{
   if (type == 4)  return 1; // key
   if (type == 9)  return 1; // trigger
   if (type == 10) return 1; // message
   if (type == 13) return 1; // timer display
   if (type == 14) return 1; // switch
   if (type == 16) return 1; // block manip
   if (type == 17) return 1; // block damage
   return 0;
}

//if ((mItem.item[b][0] == 4) || (mItem.item[b][0] == 9) || (mItem.item[b][0] == 10) || (mItem.item[b][0] == 13) || (mItem.item[b][0] == 16) || (mItem.item[b][0] == 17)) // key, trigger, msg, timer, manip, damage
if (mItem.item_secondary67(mItem.item[b][0]))


is pop msg an exception? yes...

6 and 7 are used for timers shit...


it would be much better if they did not...




verify this:
[10] - pop-up msg
mItem.item[][6]  timer counter
mItem.item[][7]  timer value
mItem.item[][8]  text color
mItem.item[][9]  frame color
mItem.item[][10] msg x pos (100)
mItem.item[][11] msg y pos (100)

this from draw code does not agree:

   mMiscFnx.get_int_3216(mItem.item[i][10], x1, y1);       // get x and y
   mMiscFnx.get_int_3216(mItem.item[i][11], w, h);         // get width and height
   mMiscFnx.get_int_3216(mItem.item[i][13], tc, fc);       // get text and frame colors

the problem is that pmsg uses 6,7,8,9 for its own trigger box

how hard would it be to make it use the event system?

fix the variable description first

mItem.item[][6]  trigger x
mItem.item[][7]  trigger y
mItem.item[][8]  trigger w
mItem.item[][9]  trigger h
mItem.item[][10] msg x and y (packed)
mItem.item[][11] msg w and h (packed)
mItem.item[][12] timer count and val  (packed)
mItem.item[][13] text and frame color (packed)


now where to start?

end result:

mItem.item[][6]  msg x
mItem.item[][7]  msg y
mItem.item[][8]  msg w
mItem.item[][9]  msg h
mItem.item[][10] event trigger
mItem.item[][11]
mItem.item[][12]
mItem.item[][13] text and frame color (packed)


use glt to find how many pmsg use trigger box..


for levels < 100
296 show always
119 use trigger box


for each one that uses a trigger box
- make a trigger item with same area
- make timer item with same time
- link them all together with pmsg


how do I get from here to there?

start with the glt...

make trigger item


wait a tick here...

msg can use trigger box or basic shape....
count that...

lev < 100
415 total
296 show always
71  trigger box
48 no trigger box

revise the plans

mode draw always
do not need trigger or timer

mode draw with trigger
only need trigger event number

mode draw with scroll
need internal timer

I think I will keep the internal timer...I can always set it to zero

It will make some things easier and I can alway override if needed...


basically:
always on
turn on with scroll
turn on with event
delay to turn off (0 to disable)

this way I do not ever need to attach a timer to it

the only ones I will need to modify will be the ones that actually have a trigger box defined
and in those cases, just create a trigger item...


new:
mItem.item[][1] event trigger
mItem.item[][6]  msg x
mItem.item[][7]  msg y
mItem.item[][8]  msg w
mItem.item[][9]  msg h
mItem.item[][10]
mItem.item[][11]
mItem.item[][12] timer count and val  (packed)
mItem.item[][13] text and frame color (packed)


in order to change things I need a temp variable

does every message have the same int in 1? yes 1036
415 < 100
596 < 400

permanently make 1 into event trigger
hard code 1036...

done...

now I can use 1 as trigger event, just like bd and bm

next step...

set up a mode in timer to allow reading of trigger event....

add buttons to ov..done

add code to proc psmg..done

now when event is not zero if set it starts the msg timer...

next would be to create triggers in glt...

back up levels first...


it works as a proof on concept

before I replace 71 trigger things lets think this through...
- none of them should be visible

set all 596 messages to have 1 = 0..done

after setting, change flag


I think I am ready to do it...

make a running list of levels and messages that have been changed


Running Global Level Test
level:  6 y:  2
level:  6 y:  3
good


level:  7 y: 45
level:  7 y: 46
level:  7 y: 47
level:  7 y: 49
good


level:  9 y:  8
level:  9 y:  9
level:  9 y: 10
level:  9 y: 11
level:  9 y: 12


level: 10 y: 10
level: 11 y: 36
level: 11 y: 37
level: 12 y: 30
level: 13 y: 22
level: 13 y: 23
level: 13 y: 24
level: 18 y: 10
level: 20 y: 36
level: 20 y: 37
level: 20 y: 38
level: 20 y: 39
level: 20 y: 40
level: 20 y: 41
level: 20 y: 42
level: 20 y: 43
level: 20 y: 44
level: 20 y: 45
level: 26 y: 15
level: 26 y: 16
level: 26 y: 18
level: 28 y:  9
level: 28 y: 10
level: 29 y: 13
level: 32 y: 18
level: 34 y:  9
level: 36 y: 27
level: 36 y: 28
level: 39 y:  4
level: 44 y:  3
level: 47 y:  3
level: 47 y:  4
level: 55 y:  5
level: 80 y: 10
level: 80 y: 11
level: 80 y: 12
level: 80 y: 13
level: 82 y: 22
level: 82 y: 23
level: 82 y: 33
level: 82 y: 38
level: 83 y: 20
level: 83 y: 21
level: 83 y: 22
level: 83 y: 23
level: 83 y: 27
level: 84 y:  9
level: 84 y: 10
level: 84 y: 11
level: 85 y: 15
level: 85 y: 16
level: 85 y: 17
level: 85 y: 24
level: 85 y: 25
level: 85 y: 26
level: 91 y:  4
level: 91 y:  6
level: 91 y:  7
level: 91 y: 10
level: 97 y: 11
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0

without checking them all I am going to assume everything is good...

what is next?

there should be no need for the flag trigger rect... or the fucntions to draw or adjust it....

removed buttons from ov
now that 6, 7, 8, 9 are not needed for trigger anymore, move the message xywh to there

done

now fixed almost all stuff like that...

what else did you want to rearrange in popmsg?

fixed the checks for moving secondaries in edit selection
in save and fcopy

and in ov map move

make the docs for msg correct...done

also pacth secondary move into ov shift move item...done

A few finishing touches to ov message viewer


If show always, grey out a lot of stuff...
- dont show scroll
- dont show event stuff
- dont shopw timer

right under show always show the timer


show scroll implies that the scroll will trigger the message
if scroll is hidden, do not let it trigger message...
done

if (show always) do not show scroll..done


can I do custom height for item ov??


cursor in edit pmsg text is not very visible
make it blink faster and made custom char 127 that has double underline

done

no sound when taking damage
fixed


20230506 push

is there any reason I could not also set timer display to values not snapped to 20?
do it!!!   done...it was easy
what else could be high res adjust?
trigger
damage

what should never be high res?...things that deal with blocks...
key
switch
block damage

hi-res:
trigger
message
timer display
block damage

made a function in items for these
made it so that you can still snap to blocks when adjusting by holding shift

make a way to align messages with each other...
actually it could be any item that has a secondary 67 position
I was thinking of using group edit
select some items and edit them as a group
this works perfectly with all hires secondary items
x,y,w,h,xc,y2
test it out...
add clear obj list to right click..done...


find a way to add timer to first level...done...


Timer is not in filter list..fixed



it is only used in es when pasting a selection from ft_xxx to regular

Events in the copied section will probably collide with existing event links
this would take some time and effort to sort out after a paste so I want to do it automatically

hi level algorithm

before paste, iterate objects in ft_xx

look for any event recievers or senders

add to link translation table
include

ft_index
original event
new event
index of variable

at each insert, check to see if there is already a link entry from the old to the new event
if yes, use that
if not make a new mapping

then when adding objects check that index of each obj for an entry in the clt table

if there is one, substitute the new event number

the only thing I need to do is extend this table to work with enemies (cloner) and lifts also

add obt_type to table

new table

obt_type
obt_sub_type (for lifts, step num)
obt_num

old_ev
new_ev
var_num

obt (2 = item, 3 = enemy, 4=lift)
num (object_index)
ext (var type, or lift step num)
old_ev
new_ev


item: mItem.item[num][ext]
obt = 2
num = item index
ext = var_num

enemy: mEnemy.Ei[num][ext]
obt = 3
num = enemy index
ext = var_num

lift: mLift.stp[num][ext].val
obt = 4
num = lift index
ext = step index



this was the original that only did items

   // this section is to make any copied pm_event links have new unique pm_events and still linked properly
   int clt[500][4] = { 0 };
   int clt_last = 0; // index

   for (b=0; b<500; b++)       // iterate items in selection
   {
      if ((ft_item[b][0] == 10) || (ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // message, bm or bd
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 1, ft_item[b][1], clt, clt_last);
      }
      if (ft_item[b][0] == 9) // trigger
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
      }
      if (ft_item[b][0] == 13) // timer
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 15, ft_item[b][15], clt, clt_last);
      }
   }


   // items
   for (b=0; b<500; b++)
      if ((ft_item[b][0]) && (mwWM.obj_filter[2][ft_item[b][0]]))
      {
         //int copied = 0;
         for (c=0; c<500; c++) // search for empty place to copy to
         {
            if (mItem.item[c][0] == 0) // found empty
            {
               //copied = 1000+c;
               int lim = 0;
               // copy all 16 variables
               for (y=0; y<16; y++)
                     mItem.item[c][y] = ft_item[b][y];

               // apply offsets
               mItem.item[c][4] += x3;
               mItem.item[c][5] += y3;

               if (erase_out_of_bounds_main)
               {
                  if (mMiscFnx.check_limit(mItem.item[c][4], 0, 1980)) lim = 1;
                  if (mMiscFnx.check_limit(mItem.item[c][5], 0, 1980)) lim = 1;
               }
               else // adjust if out of bounds
               {
                  mItem.item[c][4] = mMiscFnx.enforce_limit(mItem.item[c][4], 0, 1980);
                  mItem.item[c][5] = mMiscFnx.enforce_limit(mItem.item[c][5], 0, 1980);
               }


               // does this copy item have an entry in the clt table?
               for (int i=0; i<clt_last; i++)
                  if (clt[i][0] == b) // found index of source item table
                  {
                     int var_index = clt[i][1]; // var #
                     int ev2 = clt[i][3];       // new ev

                     mItem.item[c][var_index] = ev2;
                  }



new:


int clt[100][5] = { 0 };
int clt_last = 0; // index

do this before lifts, enemies and items paste

clt[0] = obt
clt[1] = num
clt[2] = ext
clt[3] = src_ev
clt[4] = dst_ev







   // this section is to make any copied pm_event links have new unique pm_events and still linked properly
   int clt[100][5] = { 0 };
   int clt_last = 0; // index

//   clt[0] = obt (2=item, 3=enem, 4=lift)
//   clt[1] = num
//   clt[2] = ext (2,3 int var num  4=lift step index
//   clt[3] = src_ev
//   clt[4] = dst_ev

   for (b=0; b<500; b++) // iterate items in ft
   {
      if (ft_item[b][0] == 6) // orb
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 10, ft_item[b][10], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
      }
      if (ft_item[b][0] == 9) // trigger
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 14, ft_item[b][14], clt, clt_last);
      }
      if (ft_item[b][0] == 13) // timer
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 14, ft_item[b][14], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 15, ft_item[b][15], clt, clt_last);
      }
      if ((ft_item[b][0] == 10) || (ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // message, bm or bd
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 1, ft_item[b][1], clt, clt_last);
      }
   }
   for (b=0; b<100; b++) // iterate enemies in ft
      if (ft_Ei[b][0] == 9) // cloner
         clt_last += mTriggerEvent.add_item_link_translation(3, b, 8, ft_Ei[b][8], clt, clt_last);


   for (b=0; b<ft_level_header[5]; b++) // iterate lifts in ft
      for (y=0; y<ft_lift[b][3]; y++) // iterate lift steps in ft
      {
         int step_type = ft_ls[b][y][5] % 31);
         int step_val = ft_ls[b][y][4];
         if ((step_type == 5) || (step_type == 6)) clt_last += mTriggerEvent.add_item_link_translation(4, b, y, step_val, clt, clt_last);
      }



20230508

timer demo level complete

look at when putting items from draw item...done

add a reload help key for editting help..done
lower ? and X for status window...done
add help ? to edit selection..done
add help ? for ge, th and ov..done
make ge controls always show..done


20230510

add jumpworm stuff to ge..done

same as arch

Ei
2 initial dir
10 turn before hole
11 jump before hole
12 jump before wall
7  jump under width
6  jump wait
done these 6

Ef
3 y speed same
6 x speed jump is same as arch x speed

new:
Ei
4 x speed ground (1/)
8 jump wall boost


there are some missing controls already
10 turn before hole
11 jump before hole
12 jump before wall
7  jump under width
6  jump wait
added all these


Is there an easier way to map what controls apply to what objects?
3 dimensional array?
control, obt, type
bool cot[40][2][20] = {0};
done


what if I gave the ge list a better title
Group Edit Object List

do I still want to show how many objects are listed?
what if I have some huge number and it scrolls off the bottom of the screen?
who cares? why would knowing how many objects there are make any difference?
I could make if hidden when it has nothing in the list...??
I tried it and don't like, it, need the right click menu

make all ge controls collapsed by default?..no
make + and - buttons to collapse/expand all...done
make + and - buttons for each control...done
make tinted backgrounds for controls...done and looks great

now ge is finally done...


th help is finally done...

cursor for th should be block, not just plain mouse
Main Action: Add Mark / Remove Marks
Tile Filter: Single Tile / All Matching Tiles / All Connected Matching Tiles
Match Type: Specific Tile Only / All Tiles in Tileset



podzilla and vinepod are very similar

I wonder if I could make vinepod do everything that podzilla does?


If I put cp1 and cp2 at 1/3 and 2/3 position in between initial and extended
that works...


as for speed:
podzilla speed is pixels/frame
vinepod speed is num of frames to get to extended


to convert podzilla speed to vinepod
get podzilla hypot distance
divide by podzilla speed
get time, that can be plugged into vinepod
v=d/t
d=vt
t=d/v

can i make a vinepod have a simple option? ignore cp?


how about the first step is to make them have the same speed

I have this function called re-calc pod that could possibly go away too


pod will just store main and extended pos and time
when time is running


vinepod actually stores extended pos in 9,10

can podzilla do the same?

podzilla could move 5-9 to 15-19 and be just like vinepod

I am really thinking about just doing it....
convert all podzilla to vinepod
then after that I can make some simple if I want

do both do the timer count thing the same?


is speed stored anywhwere in podzilla?

vinepod
//     Ei[e][15] = mode
//     Ei[e][16] = sequence counter
//     Ei[e][17] = sequence limit
//     Ei[e][18] = wait count
//     Ei[e][19] = wait limit
set 17 and 19 direct

podzilla
//     Ei[e][5] = mode
//     Ei[e][6] = sequence counter
//     Ei[e][7] = sequence limit
//     Ei[e][8] = wait count
//     Ei[e][9] = wait limit
set 9 direct
set speed Ef[e][9] direct then calculate Ei[e][7]..time


convert podzillas to use 15-19 instead of 5-9
then add main and extended pos to
Ei[e][3]  = x initial position
Ei[e][4]  = y initial position
Ei[e][9]  = x extended position
Ei[e][10] = y extended position


backup levels
use glt to copy all 5 6 7 8 9 to 15-19
for type 7
done
change podzilla move..done
still working

put main and extended pos in place
main copy from 0, 1
ext run function
done...
backup levels again..done

now what?

change method of running timer....

when leaving mode 0, do the calcs there for xinc, yinc
but first, do I already have the proper time in 17? I should...

this all seems to work...


now what?

am I ready to convert them all to vinepods?
not yet...

what then??

add to vinepod to make it simple...
then test...done

looks great

so to convert to vinepods:
change from 7 to 13
change to simple
change to not show

backup levels again..done

looks like its working great..

I now have no podzilla left at all....


I am thinking of re-arranging the numbers:

   strcpy (enemy_name[0][0],  "empty");
   strcpy (enemy_name[1][0],  "undef");
   strcpy (enemy_name[2][0],  "undef");
   strcpy (enemy_name[3][0],  "ArchWagon");
   strcpy (enemy_name[4][0],  "Bouncer");
   strcpy (enemy_name[5][0],  "JumpWorm");
   strcpy (enemy_name[6][0],  "Cannon");
   strcpy (enemy_name[7][0],  "PodZilla");
   strcpy (enemy_name[8][0],  "TrakBot");
   strcpy (enemy_name[9][0],  "Cloner");
   strcpy (enemy_name[10][0], "undef");
   strcpy (enemy_name[11][0], "Block Walker");
   strcpy (enemy_name[12][0], "Flapper");
   strcpy (enemy_name[13][0], "VinePod");


   strcpy (enemy_name[0][0],  "empty");
c  strcpy (enemy_name[1][0],  "Bouncer");
c  strcpy (enemy_name[2][0],  "Cannon");
   strcpy (enemy_name[3][0],  "ArchWagon");
c  strcpy (enemy_name[4][0],  "BlokWalk");
   strcpy (enemy_name[5][0],  "JumpWorm");
   strcpy (enemy_name[6][0],  "Flapper");
c  strcpy (enemy_name[7][0],  "VinePod");
   strcpy (enemy_name[8][0],  "TrakBot");
   strcpy (enemy_name[9][0],  "Cloner");

do it!

it is a huge change....


used glt to make all 13-7

4-1 and 6-2..done

11-4 and 12-6


now go through the files one at a time and fix:

mwEnemy.cpp..done
mwEnemyArchwagon.cpp..done
mwEnemyCannon.cpp..done
mwEnemyCloner.cpp..done
mwEnemyEditorFnx.cpp..done
mwEnemyFlapper.cpp..done
mwEnemyFnx.cpp..done
mwEnemyJumpworm.cpp..done
mwEnemyTrakbot.cpp..done
mwEnemyVinePod.cpp..done


mwWindowObjectViewer.cpp...done
mwWindow.cpp..done
creator
delete 04 vinepd 216
leave 05 podzilla 204 but rename to vinepod
make simple by default
set cp with thirds
done..

make ov overlays show cp only in !simple done

make ov hide stuff in simple

rearrange things in ov to make it look better

try the doubling of cp's...must be relative to initial?

add trigger input and output to vinepod
where will I find variables for that?
I supposed I could move some of the counters to floats
it would be easiest to move just counters

18 and 19 to 8 and 9

done...

now I should have 18, 19 and 21 free


18 input trigger
19 output trigger

add some flags to help with this bullshit
int trigger box enabled or not
output bullet or not

I think I have everything modified that I need to in: mwTriggerEvent.cpp

vp can be triggered by event now!
make a flag to disable int trigger box..done

vp can now send event!
the only option is at the same time as bullet is fired
I think that shoue be enough

make a flag to disable bullet firing..done


I want to make a common function that gets put the points into an array:

3 places:

move:
      // put variables in spline array
      float pnts[8];
      for (int i=0; i<8; i++) pnts[i] = Ei[e][i+3];

      // fill array of points from the spline
      int np = Ei[e][17]+1; // number of points
      float dest[np*2];
      al_calculate_spline(dest, 8, pnts, 0, np);


draw:

         // put variables in spline array
         float pnts[8];
         for (int i=0; i<8; i++) pnts[i] = Ei[e][i+3]+10;
//      // experimental scaling of control points
//         float d = 1;
//         pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//         pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//         pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//         pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;

         // draw spline path outline
         if (Ei[e][20] & PM_ENEMY_VINEPOD_SHOW_PATH) al_draw_spline(pnts, c2, 0);

         // if anything other than mode 0
         if (Ei[e][15])
         {
            // fill array of points from the spline
            int np = Ei[e][17]+1; // number of points
            float dest[np*2];
            al_calculate_spline(dest, 8, pnts, 0, np);

draw controls

      // put variables in spline array
      float pnts[8];
      for (int i=0; i<8; i++) pnts[i] = mEnemy.Ei[num][i+3]+10;

//      // experimental scaling of control points
//      float d = 1;
//      pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//      pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//      pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//      pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;

      al_draw_spline(pnts, mColor.pc[10], 0);

      // fill array of points from the spline
      float dest[200];
      al_calculate_spline(dest, 8, pnts, 0, 100);



I don't need to keep pnts anywhere

I just need to declare float dest[??]

then pass that to my fucntion..

int np = Ei[e][17]+1; // number of points
float dest[np*2];

vinepod_fill_points_array(int e, int np, float &dest[])
{
   // put variables in spline array
   float pnts[8];
   for (int i=0; i<8; i++) pnts[i] = mEnemy.Ei[num][i+3]+10;


//      // experimental scaling of control points
//      float d = 1;
//      pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//      pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//      pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//      pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;


   al_calculate_spline(dest, 8, pnts, 0, np);

}

do I want to add 10 when I create??

yes..

this works, its not much simpler, but at least it is all in one place

now implement control point multiplier

use a float...
Ef[][6] = 1

in glt make all vinepods:
#define PM_ENEMY_VINEPOD_USE_TRIGGER 0b00000000000100000
#define PM_ENEMY_VINEPOD_FIRE_SHOT   0b00000000001000000
Ef[][6] = 1

make creator also use these defaults

done...

now check how existing vinepods work...they seem to work fine

now finish the help screen for vinepod

trigger string...

help()


make a test example of:

vinepod triggering another vinepod in a chain

vinepod triggering a group of vinepods in a star

vinepod getting out of the way of a shot aimed at it

test invincible with non spline

looks good


I want some helpers to draw symmetrical splines

rotate spline 90 deg

init is the anchor
all other positions are relative


what about bullet speed for vinepod?
should be ef[][7]

fixed a bug....







use glt and find out how many:

lev  4 15 pod
lev 11 20 pod
lev 18 32 pod
lev 20 9  vinepod
lev 23 4  pod
lev 30 5  pod
lev 31 13 pod
lev 35 7  pod
lev 36 12 pod
lev 39 16 pod
lev 40 6  pod
lev 43 2  pod
lev 51 4  pod
lev 52 3  pod
lev 55 4 pod
lev 56 10 pod
lev 94 6 vinepod 7 podzilla
------
163 pod
17 vine

what is stopping me from combining podzilla into vinepod?
worries about performance?


if I made cp1 and cp2 able to be adjusted 0-2000 instead of 0-100
done for cp1, cp2 and ext, why not init?


made a way of muliplying the cp to deal with off level cps


see if I can make flag toggles work in group edit
what are edit options? all on all off random
done...


Redo vinepod demo level..done



make an expandable folder for the vinepod manip buttons:done




I have been having some problems with using the mouse scroll wheel to adjust sliders
in that loop with a mouse button pressed, where does the event loop get processed?
get slider pos
I spent some some time, but cannot understand why it does not work anymore
added a work around, hold mouse scroll button, then instead of scrolling, use arrows to move 1 val at a time
mouse scroll wheel still works good with help and graph...


make spline test not reset values..done
make spline adjust have simple directions, arrow keys mostly
make a spline reset button
all done

I want to do something so that the level editor remembers its last position
what variables are involved?, are they shared with game?
the problem seems to be that the mouse x and y are zero until the mouse is moved
fixed that..made it so that calling mInput.initialize() sets mouse x and y to actual values instead of zero


20230520

In the name of consistancy...
change class instance name from mwWM to mWM..done
shot shots..done
player players..done
widgets widget..done
item items..done





can I make precise move in ov with mouse and arrows
I have done that for enemies
normal = 20 move
CTRL = 1 move
SHIFT = also secondaries
mouse_b3 plus arrows single = pixel any dir
made a helper function to move enemies
works great, only when moving by 20's it no longer snaps to 20's

im thinking of how to implement that


make vinepod move positions snap to 20 or not
right now, SHIFT move init moves all
move init uses 20
move all others uses 1
I think I have it all sorted now:
normal move for all enemies is snap to 20
and also vps extra 3
when CTRL is held, move is 1 pixel
when SHIFT is held move secondaries also



How things are objects are moved by the mouse in object viewer:
---------------------------------------------------------------

Main enemy position:

Default:  Move by 20
CTRL:     Move by 1

Default: main pos only
SHIFT:   secondaries also

If default move of main pos, it will snap to 20's
(but will not snap secondaries, they are still relative to main pos)
I think this is how I wnat to keep it.
If I want to snap secondaries I can just click on them

I am thinking I might want a global snap to control for ov

what would that look like?
where would I store it?
in mW[7].snap

set it to 20 in constructor..
change it in top border...done

now use it...


I am not sure I am getting how this should work..
click on enemy
get mouse_offset
apply to pos
do rounding
see if it actually moved
if yes apply move to secondaries



I think I have this working good for moving main enemy pos:
- snap mouse pos
- get offset from enemy pos
- apply offset to main pos and optionally to secondaries

I think I have this working for all enemy secondaries also
now items..
looks like they are done also

how about lifts??
show step x, y, w, h for lift steps, just like for msg or cp
its coming along..looks like thet are all done..

now make b3 arrow work for all...done
works for:
main enemy
item secondary (only hires)

now make the snap slider thing look better



Can I make block manip copy a rectangular section of blocks
how many variables do I have left?
I could use 13 and 14
new mode:
copy rect area
done...


PDE needs to have enemy numbers fixed..done


adjust crew speed in ge like arch..done

adjust manip src with ov..done

something is fucky with doors
shapes change to 2nd type weirdly and crashes when changing

cannot reproduce on test level
erase door and try again

make mouse not disappear in level editor, ever...done

orb does not show lines to events it is linked to..fixed

modify block walker to make it an arbitrary block it turns into
35586216 - default H Block
done

I want to make the final rocket blastoff scene that I have always wanted to
where do I start?
make a special NPC to show locked up buddies
use enemy data struct, but make new type
this will look like a player but move like arch and jump over gaps
when triggered they will walk to rocket and find their places
how do I make them find nice places and not crowd each other?
new enemy type
what var for color?


now where do I put the custom cutscene?
how do I hook it in?

how about a new program state?

state 30 - cutscene
can get to this state from state 11



step 1 - zoom in on the level until the rocket is as wide as the screen
at this time show the message 'Preparing for take off!'

step 2 - erase everything else on the level

step 3


or
show message prepaing for takeoff

zoom until entire rocket is on screen

show the rocket moving upwards relative to the rest of the level
or the rest of the level moving down with the rocket stationary

when it is gone, switch to another view

just the rocket moving through space, getting smaller

then show level done

to make a bitmap of the rocket...13 x 94 or 260 x 1880

first, determine the zoom size that would have all of the level visible vertically

OK done state 31, zoom to fulscreen height..

state 32:
make large bitmap of rocket


state 33:
show level
erase where rocket is
draw new rocket

state 34:
destroy bitmap
level done




I am dithering between keeping background or rocket...

at the end I still want to use the rocket on the level for level done


how about:
bring all other players to the rocket
make a bitmap of the entire level
erase the rocket from the bitmap
actually erase everything on the level
draw the background bitmap as a layer, shifting downwards to make it look like the rocket is taking off


next..

after rocket has left level, zoom back in on cockpit..done

now make other players in multiplayer gather in rocket.

do this while first zooming in...


make a special place for them on a platform just below the cockpit

find out who is the captain...

the only way to do this is to detect in orb..
then set the player that triggered...done..ugly but done

x13 y6

make the time of the first seek and zoom
zoom and time both have to complete
if time completes first, stop doing xincs
set time to 100

make the second zoom smaller

then after that zoom back to original...done

test this muliplayer


20230522 12:12
push and relocate to garage

It does not work...

program state is not synced across...

its like it does not get triggered at all on clients


why is this so hard?

level done and bullshit like that are so hard for me...

they shouldn't be...

just get it working good on server then send to client...


I think my server rewind could be the cuplrit...I can't even get it to work in a server only netgame....

what did I do to fix it with level done?


I suppose I could make this procedure part of the level done code...not sure what I will gain...



first of all, fix the html docs for the existing level done procedure....
just update them mostly...done


then make some new modes, copying from the states I aleady have


ps 30

ldm 30 - start







   //---------------------------------------
   // 30 - end cutscene new 30
   //---------------------------------------
   if (program_state == 30)
   {
      cutscene_original_zoom = mDisplay.scale_factor_current;
      mDisplay.set_scale_factor((float)(mDisplay.SCREEN_H - BORDER_WIDTH*2)/2000, 0);


      // bring other netgame players home

      // each one has its own place

      int xh = 120;
      int yh = 260;
      for (int p=0; p< NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active)
         {
            float dx = xh - mPlayer.syn[p].x;
            float dy = yh - mPlayer.syn[p].y;

            mPlayer.syn[p].xinc = dx / 100;
            mPlayer.syn[p].yinc = dy / 100;

           // set left right direction
           if (mPlayer.syn[p].xinc > 0) mPlayer.syn[p].left_right = 1;
           if (mPlayer.syn[p].xinc < 0) mPlayer.syn[p].left_right = 0;

           xh += 20;

         }

      cutscene_timer = 100;
      mTriggerEvent.event[99] = 0; // clear trigger event
      program_state++;    // next state
   }


   31 - 29



   if (program_state == 32) 28
   {
      // create bitmap of the background
      cutscene_background = al_create_bitmap(2000, 2000);
      al_set_target_bitmap(cutscene_background);
      al_clear_to_color(al_map_rgba(0,0,0,0));
      al_draw_bitmap(mBitmap.level_buffer, 0, 0, 0);

      // erase the rocket area
      al_draw_filled_rectangle(20, 0, 380, 1980, mColor.Black);
      al_convert_mask_to_alpha(cutscene_background, mColor.Black);


      // actually erase everything else from level
      for (int i=0; i<100; i++) if (mEnemy.Ei[i][0] != 19) mEnemy.Ei[i][0] = 0; // enemies (except crew)
      for (int i=0; i<500; i++) mItem.item[i][0] = 0; // items
      mShot.clear_shots();

      // blocks
      for (int x=16; x<100; x++)
         for (int y=0; y<100; y++)
            mLevel.l[x][y] = 0;
      for (int x=0; x<3; x++)
         for (int y=0; y<100; y++)
            mLevel.l[x][y] = 0;
      for (int x=0; x<100; x++) mLevel.l[x][0] = 0; // top line
      for (int x=0; x<100; x++) mLevel.l[x][99] = 0; // bottom line
      mScreen.init_level_background(0);

      cutscene_timer = 200;
      cutscene_accel = 1.0;
      cutscene_bg_x =  0.0;
      program_state++;
   }


   if (program_state == 34)
   {
      mDisplay.set_scale_factor((float)(mDisplay.SCREEN_H - BORDER_WIDTH*2)/320, 0);
      program_state++;
   }

   if (program_state == 36)
   {
      al_destroy_bitmap(cutscene_background);

      mPlayer.syn[0].level_done_mode = 6;
      mPlayer.syn[0].level_done_timer = 0;
      mPlayer.syn[0].level_done_x = mPlayer.syn[0].x;
      mPlayer.syn[0].level_done_y = mPlayer.syn[0].y;
      mPlayer.syn[0].level_done_next_level = 1;

      mDisplay.set_scale_factor(cutscene_original_zoom, 0);

      program_state = 11;
   }




         if (program_state == 31) // cutscene zoom adjust
         {
            mDisplay.proc_scale_factor_change();

            if (--cutscene_timer < 0) cutscene_timer = 0;

            if (cutscene_timer)
               for (int p=0; p< NUM_PLAYERS; p++)
                  if (mPlayer.syn[p].active)
                  {
                     mPlayer.syn[p].x += mPlayer.syn[p].xinc;
                     mPlayer.syn[p].y += mPlayer.syn[p].yinc;
                  }

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();

            draw_frame();
            al_flip_display();
            if ((abs(mDisplay.scale_factor_current - mDisplay.scale_factor) < .001) && (cutscene_timer == 0)) program_state++;
         }

         if (program_state == 33) // cutscene rocket move
         {

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();


            mScreen.get_new_background(1);

            cutscene_bg_x += cutscene_accel;
            cutscene_accel += 0.1;
            al_draw_bitmap(cutscene_background, 0, cutscene_bg_x, 0);

            mEnemy.draw_enemies();
            mPlayer.draw_players();

            mScreen.get_new_screen_buffer(0, 0, 0);
            mScreen.draw_screen_overlay();
            al_flip_display();

            if (--cutscene_timer < 1) program_state++;


         }

         if (program_state == 35) // cutscene zoom adjust
         {

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();

            mDisplay.proc_scale_factor_change();
            draw_frame();
            al_flip_display();
            if (abs(mDisplay.scale_factor_current - mDisplay.scale_factor) < .001) program_state++;
         }

      }

converted from program_state level_done_mode and it works in netgame...
some bugs to iron out
make a way for scale factor change to take an exact number of frames to get to the target
done..

made it so that the captain player stays on top...

sometimes I get a double free error and everything crashes
when
after the rocket travel...
it happens when a client completes the game
it happens on all machines

put in some debug printfs now I can't reproduce it



had a different crash
server did 45 but not 6
that is set custom scale factor

made it crash finally...all three machines..double free error on ubuntu
between 4 and 5

       printf("test4\n");
       if (cutscene_background) al_destroy_bitmap(cutscene_background);
       printf("test5\n");

al_destroy_bitmap
void al_destroy_bitmap(ALLEGRO_BITMAP *bitmap)

Destroys the given bitmap, freeing all resources used by it. This function does nothing if the bitmap argument is NULL.

As a convenience, if the calling thread is currently targeting the bitmap then the bitmap will be untargeted first. The new target bitmap is unspecified. (since: 5.0.10, 5.1.6)

Otherwise, it is an error to destroy a bitmap while it (or a sub-bitmap) is the target bitmap of any thread.

changed it so that I dont actually destroy it when I am done
I do this when creating it now:
if (!cutscene_background) cutscene_background = al_create_bitmap(2000, 2000);
seems to be working

need to set players x and yinc to zero in mode 30..done

still sometimes getting stuck in endless loop in custom scale routine...
made some adjustments to that...

I think that the rocket scene is done!!

just fixed the scale changing functions and they are looking very good...


20230523 6:00AM push



the door bug is back
item 12
I moved a door

mItem.item[][6]  color
mItem.item[][7]  move type (0=auto, 1=force instant, 2=force move)
mItem.item[][8]  type (0=exit only, 1=linked dest)
mItem.item[][9]  linked destination item
mItem.item[][10] key held flag
mItem.item[][11] door entry type (0=immed, 1=up, 2=down)
mItem.item[][12] draw lines always, never, only when touched
mItem.item[][13] base animation shape


why do I have base animation shape at 13 and also at 1


448 = static
1083 = in
1084 = out


look at what we have with glt.

item[][1]

I also have 972 and -1
972 is the first shape in the animation sequence

this is all so overly complex

I really want to make it simpler

do everything in draw_door

ditched the old ans bullshit, now use frame nums direct, only works when frame_num incrementing
what if I use timer count? done

now I would like to do away with either 1 or 13


lets kill 1 and see what happens

should not be used...

I only have 3 values for 13:
0
448
1083

My plan is to move these to 1 and change the values

0 same
1 448 old static
2 1083 new ans

I think I have it all done...
lets hope the door bug does not return


I think the bug was color!!

if the color is too big the animation seq will be off
what could make the color too big?


bad!
      // snap these item secondaries to 20
      if ((mouse_on_obj) && (obt == 2) && (!mItem.item_secondary67_hires(mItem.item[num][0])))
      {
         mMiscFnx.mw_round(mItem.item[num][6], 20);
         mMiscFnx.mw_round(mItem.item[num][7], 20);
      }

good?
      if ((mouse_on_obj) && (obt == 2) && (mItem.item_secondary67(mItem.item[num][0])) && (!mItem.item_secondary67_hires(mItem.item[num][0]))) )


I think doors are done...




lift step type 5 wait for trigger
calls bn 520
that calls:
if (mTriggerEvent.get_trigger_item(4, num, type, ti_obj_type, ti_num, ti_sub_type))

then calls:

mItem.set_trigger_event(ti_num, 0, 0, ev, 0); // toggle ON trigger
but i think this is a one off that should use the more generic method
this is the only time this function is called


this is what should be called for both:

void mwTriggerEvent::find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)


bn = 520
num = l
type = s
obt = 4

mWidget.button( xa, ya, xb, bts,  520,l,s,4, 0,c1,15,0,  1,0,1,d); ya+=bts; // lift step wait trigger get event





this is the button in lift:

if (mWidget.buttont(xa, ya, xb, bts, 0,0,0,0,   0,c1,15,0,  1,0,1,d, "Set Trigger")) mTriggerEvent.find_event_sender_for_obj(4, l, s, 0);

am I sending the right args?

void mwTriggerEvent::find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)

this is wrong:
mLift.stp[ti_num][ti_obj_ext].val = ev; // set event number in receiver
should be:
mLift.stp[obj_num][obj_ext].val = ev; // set event number in receiver

I think I've got it...


remove button 520..done
remove:done
//void mwItem::set_trigger_event(int i, int ev0, int ev1, int ev2, int ev3)
//{
//   if (item[i][0] == 6) // orb
//   {
//      item[i][10] = ev0;
//      item[i][11] = ev1;
//      item[i][12] = ev2;
//      item[i][13] = ev3;
//   }
//   if (item[i][0] == 9) // trigger
//   {
//      item[i][11] = ev0;
//      item[i][12] = ev1;
//      item[i][13] = ev2;
//      item[i][14] = ev3;
//   }
//   if (item[i][0] == 13) // timer
//   {
//      item[i][13] = ev0;
//      item[i][15] = ev1;
//   }
//}


cleaned up and made more trigger event stuff look good





20230524

Make new level entry item
type 18 - gate
touching it shows simple data
up enters
down more data

what do I do when entering?
same as warp?

yes...

what next?

show something when touching...

do I want a permanently loaded icon for each level?
each level up to 100
what size?

how about dynamically loaded

what is my persitant data storage going to look like?

achievements struct

char name[200]
char desc[2000]
int level
float complete


level meta struct
int level num
int level name
int par time
int unlocked

int completed
int best time
int fewest deaths
int fewest enemies left alive


add level meta

define struct

done


do the dynamic level showing
make temp

without a bunch of duplicated code:
save player x,y
load level and make bitmap
reload original level

try that..

where will I store the bitmap?

2000x2000 in level

I think all this will not play nicely with netgame

preload icons...

100x100

i need a way to tell if any player is touching the gate

what order do these get called in?
proc
draw
touch


added int marked_gate to player struct and removed one spare int

clear it here just like door
void mwPlayer::proc_player_collisions(int p)
{
   float px = syn[p].x;
   float py = syn[p].y;

   // items
   loc[p].potential_bomb_damage = 0;
   syn[p].marked_door = -1; // so player can touch only one door
   syn[p].marked_gate = -1; // so player can touch only one gate


added set to -1 in init player..

seems to be working good now...

20230525

need to return to overworld map when level done
what about menu? return to overworld?

I need to figure out how these states link together...

overworld

play level

finish level

overworld

how about we are always in overworld


when in menu mode if resume is allowed, also return to overworld is allowed too


I think I am going to have to redo the entire menu thing..

menu-overworld-level

menu can be on top of overworld or specific level


I think I have the whole overworld to level and back thing ok in my mind

but where does the main menu apply to all this

when running a level (not overworld)
esc will pause the level and bring up a menu
one of the options will be to quit the current level and go back to the overworld


I want to have both methods coexisting, at least for the start


what I can do to start for now is have all exits take you back to the overworld

then in the overworld you will be at the gate for the level you just completed

added  int gate_level; to mwLevel
set it when entering gate...
in player set start pos if level 1 look for matching gate...

I am thinking of replacing all warps with gates...only ever used on level 1 anyway


I want to save the level icons bitmaps to disk
why?
to speed up the process of loading them
how long does it take now?

m36   sz:200 lev:100 0.8s
e6430 sz:200 lev:100 2.7s

what is the max size of bitmap I can create

how much do I need?
200x200x100 = 4,000,000
2000x2000 = 4,000,000
not that much apparantly

I am only looking at levels 1-99
right now I am using approx 80 levels of 1-99
should I go to 200?

make a bitmap sz*10, sz*10
add icons in a 10x10 grid and dont care about missing ones

new times:
m36   sz:200 lev:100 0.044s
e6430 sz:200 lev:100 0.114s

make level icon size and last level configurable
no..stick with 200 and 100


what is next?

enforce locked..done
show either: locked, unlocked, or completed


do something at level completed

mark level completed
record best times, etc..

where to detect this:
in exit collision

where to put code for this:
mLevel




OK I am at a crossroads here:
I want to save data everytime a level is completed

how am I going to do this?

a file everytime?
a row in a data structure?


int level
double start_timestamp
int completed;
int timer;
int number_players
int enemies_killed
int enemies_left_alive_at_exit
int player_respawns
int purple_coins_collected


in my new plan is there any need for new game, vs next level?

I will always be in the overworld, level 1, or in another level...

when the game starts, level 1 starts and player is put at current level

esc brings up the menu and pauses the game

without breaking too much implement the level_play_data stuff

when do I enter the first stuff?

I could just do it when a level is completed for now...


make 2 functions:

one when level is started and one when level is complete
add variables to level class to track things happening while level is running

when do I run the start function?

I could do it when level is loaded...done

now patch in code to updated variables as game runs...


   level_data_purple_coins_collected = 0;
   level_data_player_respawns = 0;
   level_data_enemies_killed = 0;


   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      mPlayer.syn[p].stat_purple_coins++;
      mLevel.level_data_purple_coins_collected++;
      mGameEvent.add(27, 0, 0, p, 0, 0, 0);
   }

      mGameEvent.add(8, 0, 0, p, 0, 0, 0);  // player death
      syn[p].stat_respawns++;
      mLevel.level_data_player_respawns++;

   mGameEvent.add(42, 0, 0, Ei[e][26], e, type, hbm);
   mLevel.level_data_enemies_killed++;


these three were easy to patch in
I think I will have to do something to account for rewind...
otherwise these will be counted on rewind also...
add this test...
if (!mLoop.ff_state)
OK done...

make some test levels

show time with a decimal..done
purple coins as a fraction of max..done

wow, i think the frame work is coming along nicely

do more with play data.. i do nothing yet...

count number of times level has been completed
average time
total time

now should I make it look nicer?

level name
par time
number of purple coins

frame level?

locked, completed indicators?

more info, cycle pages by pressing down?

I think I want the level icon to be displayed below the gate
title, frame, icon

the max char fot title that can fit in the frame with icon size 200 is 24 char


auto set number of purple coins requires each level to be loaded
do it when creating icons

1 - clear data
2 - create icons (and set tot_purple)
3 - save
done:


could I show more icons?

one for completed
one for time
one for all purple coins

401 dude
197 pc
445 time

I want to do min enemy also

how to find that?

for each level, iterate all exits and find least
100 means 0 so do 100-num and find least

done..now what?

pressing down to cycle pages

make a holdoff...done

make more pages

what else can I show?

do something about the locked, complete stuff

draw gates bigger, double size?

overlay small text

I could make the map just one of the screens
yes, that looks great!


number of info screens will change based on whether the level has been completed or not
0 will always be map
in ready mode

add page to locked to tell what has to be done to unlock

add page to run demo mode

make sure demo mode does not save any achivements


I need a function that starts demo mode when only passed integer level num

it wil need to look in savegame/demo and all files there need to be named:
levxxx.gm

like lev002.gm

there are so many transitions between states
it will take a while to sort them out

if I enter demo mode from a gate
I want to go back to the same gate when done...


I am trying to trace where it goes when level done in demo mode

demo mode is just mode 14 then mode 11

level_done mode is the only way out

at the end, ldm forces mode 12 load new level

I missed something...

how does it get back to settings if called from there

mode 12 set new state 2

      if (mPlayer.syn[mPlayer.active_local_player].control_method == 1) // run demo mode saved game file
      {
         mLoop.new_program_state = 2;
         al_rest(1);
         return; // to exit immediately
      }


it doesnt! it continues demo mode

do I need a mode to reset all this?

mode xx
reload overworld level


when getting player start for level 1, force it to be play level
maybe I should have another variable to keep track of the current level in the overworld
did that and it seems to work good

now I need to make it so that demo's don't actually get achievements..done

what next?

this is huge:

make it so that I am in the overworld by default and the menu is called from there

make a new menu..don't kill the old one

I want some nice transitions from overworld to level and back

I will always have a level loaded, tbis will stay the same
menu will pause level and do menu stuff
this sounds so simple

the menu will be different

new game and start level won't make sense


start server
start client
settings
run demo
help
quit

when playing non overworld level
quit to overworld

when in netgame, bringing up the menu will end netgame (same as before)
I could make it so that the menu does not pause the game
then give the client a smaller list of things they can do..

change controls, color, bmsg, viewport

I would like to have a secondary way to store a level in memory
I could really use it for some cool transitions between overworld and levels
I could have a small running level in the overworld
I could use it to dynamically show levels when I touch the gates


just like messages, draw the overworld level icon last


make a new menu

make a global option old_menu



I want to have a program state that lets me know when I am in overworld
state 11 and level 1


classic mode
choose any level all are unlocked
automatically load next level on completion

story mode
start levels from overworld only
levels are locked by default
automatically go to overworld on level complete


add classic_mode to main

save in config
add settings page
also add reset all data there
also add unlock all levels there
done


now make the menu different if !classic mode

in story_mode make start level 1
where? initial setup.
also there setup the level and make it ready to resume


this is actually working pretty good!
overworld and regular menus do the state thing nicely
remove the text at the top of the level map for overworld
done

add more things to story menu's
made demo work

remove all warps...

they are only for hub world anyway


can I automate it?

in hub, move down 40 y+=40;

old warp level item[i][8] 12

new gate item[i][6] 18

new shape?

now get rid of all others

they all have level 1 as the dest?


change them all to exit

do they need to be stationary?
all warps are staionary
3 = 0;


same when exit..

old 12

new 3
new 8 = enemies left, set to 100
3 1022 1 0

I think it is all done...
now more warps...
should i just kill all the rest?
why not? just erase...
they are all gone
now remove in code
done


next?

make sure gate info is on top of everything
how?
I don't want to mess with draw order

I could do it in draw player

don't I already store something there?
marked gate...
moved draw gate info to its own function
now called from draw_player
works good...



next?

now in story mode, when starting game you are in the menu and overworld is loaded in the background
this is how it should be

make settings shortcut for story also
make seeting line up under main title
done


next..

what else can I add to menu 3?
settings??

what is the purpose of menu 3?
to avoid immediately going to overworld when esc is pressed...
A way of pausing...

the only thing different is the option to quit to overworld
what if I wanted to save the level before quitting to overworld?

I think I should have more options there
not demo
not netgame
add settings and help..done

test in netgame

It works amazingly well!
Either player can start a level with gate
Neither can exit to menu or the netgame ends, but that is how it was before also..

level 100, my final level causes a crash
should I make max levels 100?
moved to level 64
still seems to work

also should I only show gate info for active local player?...soft no...

in classic mode, when I exit, go to the next level
done

bug when playing a level then switching to story mode, you get stuck on that level..fixed

OK lets do some more levels

9...
something is missing in the levels that

the first game move entry is missing...

0 0 0 lev

add cheat demo..done


WTF is going on!

I have a bug in ladder climbing

when the player gets stuck climbing and breaks free he warps a lot...

wrong:
syn[p].y = tx; // set x to passed by pos
syn[p].y -= m; // move in y

fixed
syn[p].x = tx; // set x to passed by pos
syn[p].y -= m; // move in y


9 bomb intro same (has ack 8)
10 dead zone demo does not exit nicely (has ack at end)

the level done stuff runs at the end
but times out when it gets to 10s

11 good and evil works, but times out at 13s (has ack)
12 bucket of bad works, times out right away





what happens when you interrupt a demo called from gate?
you can resume, but control is still with file


this control path is confusing and i would like to make it more clear


demo mode is an int that is set when automatically running random levels

it is not set when only running one demo



when a level ends that is played from file, what happens?

how do we detect that the file level has ended
in rungame key check if a cancel key is pressed
in rungame keycheck if 4 sec past last game move
or the level done thing can proceed..

I want a state dedicated to cleaning up after demo mode
move rungame keycheck to demo and rename..done


make a function to clean up after demo mode is done



test all possible changes

make a small collection of simple levels to test with..


run single demo level from gate
-------------------------------
start from state 11

if (mGameMoves.load_gm(msg))
{
   mLoop.new_program_state = 14;
   //old_program state = 3

in mGameMoves.load_gm(msg)

mLevel.play_level = arr[0][3]; // set play level
mDemoMode.demo_mode_last_frame = arr[entry_pos-1][0];






demo mode called from menu story mode
runs and loops good, cancel with key not good



demo mode called from menu classic mode



I want to look at what gets save at the end of a gm file
and if it makes any difference if you let the timer run out or not
I get an acknowledge if I press a key

which levels do that

maybe I could add a game move just to mark when the exit was touched


I am not sure how setting new_program_state 1 works

this is done when leaving ??

this checks to see where it came from
from settings, from demo, from command line

i need to figure this out better


20230601 what am I doing?

am I done with demo mode

do the docs

looking at transitions
make a generic from any to any


start level variables

what about the variables:
start level
play level
overworld level
demo_restore_level
last_level_loaded


where are they all used? and can it be made simpler?

-------------------
mLevel.start_level
-------------------
saved in config

in classic mode:
it is the level shown on the menu
it is the level used when new_game is run

-------------------
mLevel.play_level
-------------------
in classic and story, it is the level currently being played

in mode 12 next level, it is set to the next level to load and play

demo mode uses if for the currently playing demo level
load_gm set it from gm files loaded

----------------------
mLevel.overworld_level
----------------------
saved in config
- set when active local player touches a gate
- used to set player position when starting overworld level

------------------------
mLevel.last_level_loaded
------------------------
used to keep track of the last level loaded (or saved)

-----------------------
mDemoMode.restore_level
-----------------------
used to save original level when running demo so original level can be restored after demo is done


20230601 7:00 AM

I think that demo mode is done...put all demo files back and push

next is to work on transitions

and making overworld look better

should I rename stimp and stamp?

what do I want them to do?


zoom in from an icon to the level playing
and the reverse

void transition_from_map_to_game(int ix, int iy, int iw, int ih);



void transition_from_game_to_map(int ix, int iy, int iw, int ih);






in level editor mode

void mwScreen::get_new_screen_buffer(int type)
is always called with type 3

this means that WX and WY are set by level editor...



change variable names to these in mDisplay

   int level_display_region_x;
   int level_display_region_y;
   int level_display_region_w;
   int level_display_region_h;

   int screen_display_x;
   int screen_display_y;
   int screen_display_w;
   int screen_display_h;


remove old uses of these:
   int level_display_region_x;
   int level_display_region_y;
   int level_display_region_w;
   int level_display_region_h;

they are actually the same...

   mDisplay.level_display_region_x = mDisplay.level_display_region_x;
   mDisplay.level_display_region_y = mDisplay.level_display_region_y;
   mDisplay.level_display_region_w = SW;
   mDisplay.level_display_region_h = SH;


   maybe what I want to do is remove WX, WY

done..

now I have these variables in mDisplay:

mDisplay.level_display_region_x;
mDisplay.level_display_region_y;
mDisplay.level_display_region_w;
mDisplay.level_display_region_h;

mDisplay.screen_display_x;
mDisplay.screen_display_y;
mDisplay.screen_display_w;
mDisplay.screen_display_h;

they are a bit long...

I have a function:
mDisplay.set_screen_display_variables(void);

that sets:
mDisplay.level_display_region_w;
mDisplay.level_display_region_h;

mDisplay.screen_display_x;
mDisplay.screen_display_y;
mDisplay.screen_display_w;
mDisplay.screen_display_h;

and another function:
mDisplay.set_level_display_reqion_xy();
that sets:
mDisplay.level_display_region_x;
mDisplay.level_display_region_y;

replace other calls to this in stimp and stamp:
done:


void mwScreen::set_map_var(void)
{
   // determine menu_map_size and position
   int y_size = mDisplay.SCREEN_H-160;
   int x_size = mDisplay.SCREEN_W-260;
   if (y_size < x_size) mLogo.menu_map_size = y_size;
   else mLogo.menu_map_size = x_size;
   if (mLogo.menu_map_size < 10) mLogo.menu_map_size = 10;
   mLogo.menu_map_x = mDisplay.SCREEN_W/2-(mLogo.menu_map_size/2);
   mLogo.menu_map_y = 140;



I think I have stimp and stamp working and cleaned up nicely...

now where are they all patched in?

stimp
new game
resume
31 demo start


stamp
back to menu
level done demo
level done default

stamp is called when starting demo mode, and it looks bad
that is beacause starting demo mode calls next level to get the first demo level

how to fix..

starting demo mode or starting level play needs to tak into account where it came from

all these transitions need to do that..


so far I have:
menu to game (stimp)
game to menu (stamp)

level done should do something different
not level done, next level...

it is not going back to the menu..
right now I do stamp and stimp

I want it to do a zoom out to nothing in the center then back with the new level

new functions:

void transition_from_menu_to_game();
void transition_from_game_to_menu();
void transition_from_nothing_to_game();
void transition_from_game_to_nothing();

where used:

void transition_from_menu_to_game();
- 10 new game
- 13 resume game

void transition_from_game_to_menu();
- back to menu

void transition_from_menu_to_game();
- 10 new game
- 13 resume game

void transition_from_game_to_nothing();
- 12 next level demo and normal (before new level is loaded)



when cancelling demo, it zooms back in on last loaded level, but that is sometimes off screen??
in mode 32 I am reloaded old level but did not set player positions

how should I handle this?
demo mode cancel and back to menu
game to nothing
restore level
nothing to menu (does not exist)

I already have 4 transition functions, and I am planning on more...
could I make them more generic?

what are my states?
0 - nothing
1 - game
2 - map
3 - gate icon

void transition_cutscene(int initial, int final)
{

}
done...

now I have:

void mwScreen::transition_cutscene(int i, int f, int num_steps, float delay)
where used:

if (program_state == 1) mScreen.transition_cutscene(1, 2, 60, 0.02); // game to menu
- back to menu

mScreen.transition_cutscene(2, 1, 60, 0.02); // menu to game
- 10 new game
- 13 resume game

mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
- 12 common before load


mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game
- 12 normal end after load
- 31 demo setup after load




now make a transition from gate icon to game

mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

it has to be in next level...

I will be in the overworld level
classic mode = 0;

at next level do nothing at start, but after load do

mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

where is the starting player position on the screen
need the x and y
should I save them when exiting?


I have it figured out:

when using gate to start level...

// gate item locatiom
int x = itemf[i][0];
int y = itemf[i][1];

// offset from gate item to level icon
x += (10 - 100);
y += (12 + 35);

// convert to actual screen pos
mScreen.gate_transition_x = (x - mDisplay.level_display_region_x) * mDisplay.scale_factor_current + mDisplay.screen_display_x;
mScreen.gate_transition_y = (y - mDisplay.level_display_region_y) * mDisplay.scale_factor_current + mDisplay.screen_display_y;


when setting up the transition cutscene after new level is loaded
if (i == 3) // gate
{
   fmsi = 200.0 / 2000.0; // level icon size = 200;
   fmxi = gate_transition_x + px * fmsi;
   fmyi = gate_transition_y + py * fmsi;

do i really need the menu when the level is paused?
that is how it is in classic mode...

but in story mode, I can't go back to the overworld without actually leaving the level

how about the menu in ov-lev is just paused, no other changes

disable it for now...optionally to come back


when leaving level in story mode, go right back to overworld instantly

where does this hook in?



I have so much working good now...

I think I will open a new file and document it



20230604

bug - demo mode in story mode different than in classic
look in next level

this was faulty:

if (mMain.classic_mode)          mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
else if (mLevel.play_level != 1) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate

demo mode in story would run gate..

this does not work either:
if ((!mMain.classic_mode) && (mLevel.play_level != 1)) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate
else                                                   mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing

finally this does what I want:
if ((!mMain.classic_mode) && (mLevel.play_level == 1) && (!mDemoMode.demo_mode_on)) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate
else                                                                                mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing




I really do have a complicated way of going through program states


I think I would like to do something about old_program_state, older_program_state, etc...

what about an array?

program_state[8]

0 is the new_program_state
1 is the current_program_state
2 is older program state
3 is older....


this covers what I already have, but could do more...

throughout the codebase, just set 0

in void mwLoop::proc_program_state(void)

if 0 != 1

do code for change

slide all down in array

leave it with 0 == 1


int state[8] = {0};

replace all new_program_state with program_state[0]

I have it all the variables changed, now to make it work...

coming along nicely

start demo from command line..fixed
quit demo started from command line..fixed

start level from command line and exit to cmd...done

start level editor from command line and exit to cmd...just works

classic mode tests
-------------------------
start game cutscene good
game to menu cutscene...fixed

demo mode from menu
start...good
next level...good
quit....good
in 32 game to nothing
in 1 nothing to menu
that affected command line demo..fixed

demo mode from settings
seems to work, both random and single

overworld in classic mode
starting level
zooms out of overworld then into new level
quitting level zooms out to menu
this looks OK
overworld was never meany for classic but will still work



story mode tests
----------------
settings demo mode seems to work well
demo mode from menu..looks good

demo mode from overworld..needs work

start level from overworld
calls next level


what happens in next level?

it is complicated
pre load transitions
post load transitions

what should happen?

pre load nothing
post load gate to game
show state array in next level


overworld gate to level..good

level back to overworld

pressing esc or menu key...
instead of adding game move, in single player just sets mLoop.state[0] = 1;

then instead of actually going back to the menu, hijack it to go to the overworld

trap it with a test..done

not sure what else I might have broken with all these changes...


test story demo
make starting transition work..done

ending transition...

11 to 32 does 1 to 0
32 to 10 does 2 to 1
10 to 11 none

fixed 11 to 32
now disable 32 to 10

actually send to 12 instead

















starting the tests over:
args


classic mode
------------

start new
back to menu
demo from menu
demo and single from settings
all good...

overworld level in classic
start new game to overworld
back to menu
resume


start game from gate good

demo start from gate


demo return goes through too many transitions


31 that starts demo mode

called from:

setup

random

gate


I have restore_mode...

kind of like called from


gate demo call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 2;
mDemoMode.restore_level = lev;

gate cheat call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 2;
mDemoMode.restore_level = lev;

args call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 0;

settings call:
mLoop.state[0] = 30;
mDemoMode.restore_mode = 3;
mDemoMode.restore_level = mLevel.last_level_loaded;

mLoop.state[0] = 31;
mDemoMode.restore_mode = 3;
mDemoMode.restore_level = mLevel.last_level_loaded;


where else do I set 31?

state[0] = 31

demo random:
mLoop.state[0] = 31;

state[0] = 30
if  (top_menu_sel == 9)  { state[0] = 30; mDemoMode.restore_mode = 1; mDemoMode.restore_level = mLevel.start_level;   return; } // demo mode
so what can I use it for?


31 demo mode start is good

demo mode start from gate exit not good


something is wrong with coming back to overworld
do I keep the old icon position?
do I need to get a new one?

to reproduce:

start level from gate
move to scroll
back to overworld

I think I need to use the existing exact position when icon is source, but when it is desination I need to recalc
I will have to store item num...

that did not work


It always seems to go to the right place
but when it comes back, no

where is it coming back from?

next level, pre load transition 1 to 3

I think I will need to save the wx and wy also

that seems to have fixed it...

mScreen.gate_transition_wx = mDisplay.level_display_region_x;
mScreen.gate_transition_wy = mDisplay.level_display_region_y;


in next level

before load

         else if (mMain.classic_mode)
         {
            mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
         }
         else
         {
            mScreen.transition_cutscene(1, 3, 90, 0.01); // game to icon
            game_to_icon = 1;
         }
      }

after load

      if (game_to_icon)
      {
         mDisplay.level_display_region_x = mScreen.gate_transition_wx;
         mDisplay.level_display_region_y = mScreen.gate_transition_wy;
      }
does not work if I change scale, save and restore that also

done...


now back to testing:

story gate demo end, double transistion
only when level done
good when exiting with keypress


finish:
starts 12
12 does preload transition
sent to 32
32 does transition
sent to 12
OMG!! why?

abort:
starts on 32

I could hook into 12 and send to 32 when done...

seems so overly complicated


is there any way to simplify all of this?

manage the complexity

demo mode from menu ends with overworld



------------------------------

greatly improved console logging to follow states

now lets test again

---------------------------------
arg demo with key cancel..good
----------------------------------
---------  Stage change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:0]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31  0  0  0  0  0  --------  [  56]
[State 32 - Quit and Cleanup Demo Dode]  [drm:0]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 11 31  0  0  0  0  --------  [  56]
[State 1 - Game Menu]

---------------------------------
arg demo with level done..good
---------------------------------
---------  Stage change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:0]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  0  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  0  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  0  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:0]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 12 11 31  0  0  0  --------  [ 427]
[State 1 - Game Menu]

---------------------------------
command line int level esc quit..good
---------------------------------
---------  Stage change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  0  0  0  0  0  --------  [  48]
[State 1 - Game Menu]

---------------------------------
command line int level level done...good
---------------------------------
---------  Stage change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  0  0  0  0  0  --------  [ 233]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 10  0  0  0  0
command line exit
---------  Stage change from 12 to  0  --------   0 12 11 10  0  0  0  0  --------  [ 233]






--------------------------
Classic mode tests
--------------------------

start level from menu and quit with esc to menu

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  1  0  0  0  0  --------  [ 140]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 10  1  0  0  0  --------  [ 140]




start level from menu and quit with esc to menu then resume

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  1  0  0  0  0  --------  [ 213]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to 13  --------  13  1 11 10  1  0  0  0  --------  [ 213]
transition from menu to game
---------  Stage change from 13 to 11  --------  11 13  1 11 10  1  0  0  --------  [ 213]
---------  Stage change from 11 to  1  --------   1 11 13  1 11 10  1  0  --------  [ 572]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 13  1 11 10  1  --------  [ 572]


start level from menu, then level done, then esc to menu

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 290]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 10  1  0  0  0
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 153]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 11 10  1  0  --------  [ 153]



demo mode from menu

---------  Stage change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:1]
---------  Stage change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:70]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:31
---------  Stage change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:31]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 30  1  0  0  --------  [  91]
[State 12 - Next Level]   [play lev:31]  [next lev:0]
12 12 11 31 12 30  1  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:17
---------  Stage change from 12 to 31  --------  31 12 11 31 12 30  1  0  --------  [  91]
[State 31 - Setup Demo Level]  [lev:17]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 30  1  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 11 31 12 30  --------  [  55]
[State 12 - Next Level]   [play lev:17]  [next lev:0]
12 12 11 31 12 11 31 12
pre-load transition
transition from game to nothing
pass:1 - playing demo level:82
---------  Stage change from 12 to 31  --------  31 12 11 31 12 11 31 12  --------  [  55]
[State 31 - Setup Demo Level]  [lev:82]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 11 31  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 12 11 31 12 11  --------  [  46]
[State 32 - Quit and Cleanup Demo Dode]  [drm:1]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 11 31 12 11 31 12  --------  [  46]
[State 1 - Game Menu]
transition from nothing to menu
---------  Stage change from  1 to  0  --------   0  1 32 11 31 12 11 31  --------  [  46]




demo mode from settings

when key cancel it zooms to nothing then reloads level, then back to settings
good



---------  Stage change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:3]
---------  Stage change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:70]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:92
---------  Stage change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:92]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 30  1  0  0  --------  [  70]
[State 12 - Next Level]   [play lev:92]  [next lev:0]
12 12 11 31 12 30  1  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:34
---------  Stage change from 12 to 31  --------  31 12 11 31 12 30  1  0  --------  [  70]
[State 31 - Setup Demo Level]  [lev:34]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 30  1  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 12 11 31 12 30  --------  [  52]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 11 31 12 11 31 12  --------  [  52]
---------  Stage change from  3 to  1  --------   1  3 32 11 31 12 11 31  --------  [  52]
[State 1 - Game Menu]
---------  Stage change from  1 to  0  --------   0  1  3 32 11 31 12 11  --------  [  52]




demo level from settings with key cancel...good

---------  Stage change from  1 to 31  --------  31  1  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  1  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  1  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  1  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 12 11 31  1  0  0  --------  [ 427]
---------  Stage change from  3 to  1  --------   1  3 32 12 11 31  1  0  --------  [ 427]
[State 1 - Game Menu]
---------  Stage change from  1 to  0  --------   0  1  3 32 12 11 31  1  --------  [ 427]



demo level from settings with level done..good

---------  Stage change from  1 to 31  --------  31  1  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  1  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  1  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  1  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 12 11 31  1  0  0  --------  [ 427]
---------  Stage change from  3 to  1  --------   1  3 32 12 11 31  1  0  --------  [ 427]
[State 1 - Game Menu]


overworld in classic mode

start level from gate, then esc pause and resume ...good
---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 272]
[State 12 - Next Level]   [play lev:1]  [next lev:7]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 220]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to 13  --------  13  1 11 12 11 10  1  0  --------  [ 220]
transition from menu to game
---------  Stage change from 13 to 11  --------  11 13  1 11 12 11 10  1  --------  [ 220]
---------  Stage change from 11 to  1  --------   1 11 13  1 11 12 11 10  --------  [ 242]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 13  1 11 12 11  --------  [ 242]



start level from gate, then level done..all good

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [  45]
[State 12 - Next Level]   [play lev:1]  [next lev:70]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 12 11 10  1  0  0  --------  [ 268]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 12 11 10  1  0
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 12 11 10  1  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 12 11 12 11 10  1  --------  [ 327]
[State 12 - Next Level]   [play lev:71]  [next lev:80]
12 12 11 12 11 12 11 10
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 12 11 12 11 10  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 12 11 12 11  --------  [  22]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 11 12 11 12  --------  [  22]


demo from gate, then quit with esc

does not line up when returning to overworld from level

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [ 123]
[State 31 - Setup Demo Level]  [lev:71]  [drm:2]
transition from gate to game
---------  Stage change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  89]
[State 32 - Quit and Cleanup Demo Dode]  [drm:2]
transition from game to gate
---------  Stage change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  89]
[State 12 - Next Level]   [play lev:71]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
post-load transition
---------  Stage change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [ 208]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 32 11 31 11  --------  [ 208]


I thinks this is all part of the same problem I had when returning to gate in single player

I need to find a way to do both

in next level, after the level is loaded, the wx and wx corrwections are made then things line up

i need a way of detecting that we just zoomed in on a gate


bug - change to story mode sometimes freezes game
classic
change start level to > 1
change to story..freezes
fixed by forcing start_level to 1 when setting story mode


I have been doing a lot os tests and all is looking good.


Next to do:

clean up 12 next level

make all debug print statements optional in program state
make sure all is working well..



rename get new screen buffer as it does not use a buffer, it is the display
draw_level_region_to_display get_new_screen_buffer
done...


there is a lot in common with

10 new game
12 next level
31 setup demo mode

see what you can make common

after load level


list them here:





   //---------------------------------------
   // 10 - single player new game
   //---------------------------------------
   if (state[1] == 10)
   {
      printf("[State 10 - New Game]  [lev:%d]\n", mLevel.play_level);


      // load level
      mLevel.set_start_level();





      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 1);            // full reset
         mPlayer.set_player_start_pos(p, 0);   // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;

      mGameMoves.initialize();

      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start

      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      mScreen.transition_cutscene(2, 1, 60, 0.02); // menu to game

      frame_num = 0;
      show_player_join_quit_timer = 0;

      mSound.start_music(0); // rewind and start theme

      mTimeStamp.init_timestamps();

      state[0] = 11;

      // set up mwQuickGraph here
      mQuickGraph[0].initialize(1);
      mQuickGraph[1].initialize(2);


   }



   //---------------------------------------
   // 31 - setup and play demo level
   //---------------------------------------
   if (state[1] == 31)
   {
      int drm = mDemoMode.restore_mode;
      printf("[State 31 - Setup Demo Level]  [lev:%d]  [drm:%d]\n", mLevel.play_level, drm);

      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = 1;
         return;
      }


      // reset players
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 1);           // full reset (start modes 1, 2, 3, 9)
         mPlayer.set_player_start_pos(p, 0);  // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;
      mPlayer.syn[0].control_method = 1; // rungame demo mode



      frame_num = 0;
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      show_player_join_quit_timer = 0;
      mSound.start_music(0); // rewind and start theme

      if (drm == 0) mScreen.transition_cutscene(0, 1, 90, 0.01); // args (nothing to game)
      if (drm == 1) mScreen.transition_cutscene(0, 1, 90, 0.01); // demo mode random (nothing to game)
      if (drm == 2) mScreen.transition_cutscene(3, 1, 120, 0.02); // gate (gate to game)
      if (drm == 3) mScreen.transition_cutscene(0, 1, 90, 0.01); // settings (nothing to game)

      mTimeStamp.init_timestamps();
      state[0] = 11;
   }



   //---------------------------------------
   // 12 - level done (more accurately load next level)
   //---------------------------------------
   if (state[1] == 12)
   {
      printf("[State 12 - Next Level]   [play lev:%d]  [next lev:%d]\n", mLevel.play_level, mPlayer.syn[0].level_done_next_level);

      for (int i=0; i<8; i++) printf("%2d ", state[i]);
      printf("\n");

      // if demo level just ended to get here, immediately send to 32
      if ((state[3] == 31) && (!mDemoMode.demo_mode_on)) // demo level just completed
      {
         state[0] = 32; // demo mode cleanup and exit
         return; // to exit immediately
      }

      if ((state[3] == 10) && (state[4] == 0)) // normal play level started from command line
      {
         printf("command line exit\n");
         state[0] = 0; // exit to dos
         return; // to exit immediately
      }

      mSound.stop_sound();

      mPlayer.syn[0].level_done_mode = 0;

      if (mLog.LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", mPlayer.syn[0].level_done_next_level); mLog.add_log_entry_header(10, 0, msg, 3); }



      // -------------------------------
      // pre load transition
      // -------------------------------

      printf("pre-load transition\n");

      int gate_to_game = 0;
      int game_to_gate = 0;


      // if going to overworld from anything except menu, set game to gate
      if ((mPlayer.syn[0].level_done_next_level == 1) && (state[2] != 1))
      {
         game_to_gate = 1;
         printf("1game to gate set\n");
      }



      // did we just come from 32?
      if (state[2] == 32) // demo mode just ended
      {

      }
      else
      {
         // if going from overworld to any other level, assume gate is used...no transition until after load
         if ((mLevel.play_level == 1) && (mPlayer.syn[0].level_done_next_level != 1)) gate_to_game = 1;

         else if (mMain.classic_mode)
         {
            mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
         }
         else
         {
            mScreen.transition_cutscene(1, 3, 90, 0.01); // game to icon
            game_to_gate = 1;
            printf("2game to gate set\n");
         }
      }







      // if we get here in demo mode, either initially or after level done
      // call mDemoMode.load_random_demo() to load game moves for next demo level
      // this needs to be after the cutscene transitions
      if (mDemoMode.demo_mode_on)
      {
         mDemoMode.load_random_demo();
         return; // to exit immediately
      }







      if ((mLog.LOG_NET) && (mNetgame.ima_client)) mLog.log_ending_stats(mPlayer.active_local_player);
      if ((mLog.LOG_NET) && (mNetgame.ima_server)) mLog.log_ending_stats_server();

      if (mNetgame.ima_server) mNetgame.server_flush();
      if (mNetgame.ima_client) mNetgame.client_flush();

      mGameMoves.blind_save_game_moves(1);

      if (mLog.autosave_log_on_level_done) mLog.save_log_file();

      mLevel.play_level = mPlayer.syn[0].level_done_next_level;


//      if ((mNetgame.ima_client) || (mNetgame.ima_server))
//         for (int p=0; p<NUM_PLAYERS; p++)
//         {
//            // free all the used clients, so they can be re-assigned on the next level
//            // if (mPlayer.syn[p].control_method == 9) mPlayer.syn[p].control_method = 0;
//            // set all clients inactive on server and client, to force them to re-chase and lock on the new level
//            // if ((mPlayer.syn[p].control_method == 2) || (mPlayer.syn[p].control_method == 4)) mPlayer.syn[p].active = 0;
//         }



      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = 1;
         return;
      }



      // reset players
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 2);            // next level reset
         mPlayer.set_player_start_pos(p, 0);   // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;



      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start



      frame_num = 0;
      mNetgame.reset_states();
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      if (mNetgame.ima_server) // set server initial state (for both 2-new game and 5-level done when server)
      {
         mPlayer.syn[0].control_method = 3;

         mNetgame.game_vars_to_state(mNetgame.srv_client_state[0][1]);
         mNetgame.srv_client_state_frame_num[0][1] = frame_num;

         if (mLog.LOG_NET_stdf)
         {
            //   printf("saved server state[1]:%d\n\n", frame_num);
            sprintf(msg, "stdf saved server state[1]:%d\n", frame_num);
            mLog.add_log_entry2(27, 0, msg);
         }
      }

      // save colors in game moves array
      for (int p=0; p<NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active) mGameMoves.add_game_move(0, 1, p, mPlayer.syn[p].color); // [01] player_state and color

      if (mLog.LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", mLevel.play_level);
         mLog.add_log_entry_header(10, 0, msg, 3);
      }

      // reset the viewport so the cutscene lines up
      if (game_to_gate)
      {
         mDisplay.level_display_region_x = mScreen.gate_transition_wx;
         mDisplay.level_display_region_y = mScreen.gate_transition_wy;
         mDisplay.set_scale_factor(mScreen.gate_transition_scale, 1);
      }

      printf("post-load transition\n");

      if (gate_to_game) mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

      // not just come from 32 and classic and not gate to game

      else if ((state[2] != 32) && (mMain.classic_mode)) mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game


//            // did we just come from 32?
//      if (state[2] == 32) // demo mode just ended
//      {
//
//      }
//      else
//      {
//         if (gate_to_game) mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game
//         else
//         {
//            if (mMain.classic_mode) mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game
//         }
//
//      }

      show_player_join_quit_timer = 0;
      mSound.start_music(0); // rewind and start theme
      mTimeStamp.init_timestamps();
      state[0] = 11;
   }



10

      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start

      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mInput.initialize();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;






12
      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start
      mNetgame.reset_states();


      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mShot.clear_shots();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;



31

      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mShot.clear_shots();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;

that looks a little more simplified

still need to straighten out next level transitions....
they are very ugly....


20230605 12:15 AM push







bug - story gate demo end transition does not line up
story gate level start transitions work good
actually they both work, but not the first time..fixed




bug - story menu demo mode ends with overworld instead of menu

---------  State change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:1]
---------  State change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:1]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
pass:1 - playing demo level:86
---------  State change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:86]  [drm:1]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 12 30  1  0  0  --------  [  60]
[State 32 - Quit and Cleanup Demo Dode]  [drm:1]
transition from game to nothing
---------  State change from 32 to  1  --------   1 32 11 31 12 30  1  0  --------  [  60]
[State 1 - Game Menu]
[State 12 - Next Level]   [play lev:86]  [next lev:1]
12 12 32 11 31 12 30  1
pre-load transition
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 12 30  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 12 30  --------  [ 110]
[State 1 - Game Menu]
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12 32 11 31 12  --------  [ 110]



when going to game menu I need a way to know where I came from


in 32 what my drm is 1


I think I need more drm

current:
0 called from args
1 random
2 gate
3 setting

new

10 called from args single
21 menu random
31 settings single
32 settings random
42 gate single





also demo_mode
current
0 off
1 on

new
0 off
1 single
2 random

implement this

do all the drm

both args:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 10;
mLoop.state[0] = 31;

both menu calls:
mDemoMode.mode = 2;
mDemoMode.restore_mode = 21;
mDemoMode.restore_level = mLevel.start_level;
state[0] = 12;

settings single:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 31;
mDemoMode.restore_level = mLevel.last_level_loaded;
mLoop.state[0] = 31;

settings random:
mDemoMode.mode = 2;
mDemoMode.restore_mode = 32;
mDemoMode.restore_level = mLevel.last_level_loaded;
mLoop.state[0] = 12;

gate single:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 42;
mDemoMode.restore_level = lev;
mLoop.state[0] = 31;


those are all done...

now look at all mode refs
removed this line:

do I even need mode 30, all it does is go directly to 12

   //---------------------------------------
   // 30 - start demo mode
   //---------------------------------------
   if (state[1] == 30)
   {
      if (debug_print_state_names) printf("[State 30 - Start Demo Mode]  [drm:%d]\n", mDemoMode.restore_mode);
      //mDemoMode.mode = 1;
      state[0] = 12;
   }

removed it and modified all calls to 30 to now go to 12


looked at all mode refs


now look at all drm refs






// maybe it would be better to list all the places we could jump to from here
// no change - menu
// settings
// overworld
// exit immed

// then list conditions for each

/*

in state 11 there are 2 ways out:
esc
level done
are there any other ways?


could I setup variables to register what happens then?

before starting 11 set:
quit_action
done_action

quit_action
0 quit program
1 menu
2 overworld
3 settings


done_action
0 quit program
1 menu
2 overworld
3 settings
4 next inc level
5 next rand level


I could be on to something here.....

where would I store these variables
mLoop.quit_action
mLoop.done_action


where are all the places I would set these?

command line

2 x
mLoop.state[0] = 31;
mLoop.quit_action = 0;
mLoop.done_action = 0;

1 x
mLoop.state[0] = 10;
mLoop.quit_action = 0;
mLoop.done_action = 0;


classic menu

if (top_menu_sel == 3) // start new game
{
   state[0] = 10;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 4; // next inc level
   top_menu_sel = 4;
   return;
}

if (top_menu_sel == 9) // demo mode
{
   mDemoMode.mode = 2;
   mDemoMode.restore_mode = 21;
   mDemoMode.restore_level = mLevel.start_level;
   state[0] = 12;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 5; // next rand level
   return;
}


story menu

if (top_menu_sel == 2) // start new game
{
   state[0] = 10;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 2; // overworld
   return;
}

if (top_menu_sel == 6) // demo mode
{
   mDemoMode.mode = 2;
   mDemoMode.restore_mode = 21;
   mDemoMode.restore_level = mLevel.start_level;
   state[0] = 12;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 5; // next rand level
   return;
}


do some testing....

some stuff is working great

ov to game and back




20230607

---------------------
command line demo
---------------------
quit works perfectly
done works perfectly

---------  State change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:10]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31  0  0  0  0  0  --------  [  48]
[State 32 - Quit and Cleanup Demo Mode]  [drm:10]  [m:1]
transition from game to nothing
---------  State change from 32 to  0  --------   0 32 11 31  0  0  0  0  --------  [  48]


---------  State change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:10]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 31  0  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:1]
12 12 11 31  0  0  0  0
command line exit
transition from game to nothing
---------  State change from 12 to  0  --------   0 12 11 31  0  0  0  0  --------  [ 427]



----------------------
command line lev start
----------------------
first transition good
quit works perfectly
done works perfectly


---------  State change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from nothing to game
---------  State change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 10  0  0  0  0  0  --------  [  45]
[State 1 - Game Menu] - done_action:0
transition from game to nothing

---------  State change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from nothing to game
---------  State change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 10  0  0  0  0  0  --------  [ 242]
[State 12 - Next Level]   [play lev:70]  [next lev:1]
12 12 11 10  0  0  0  0
command line exit
transition from game to nothing
---------  State change from 12 to  0  --------   0 12 11 10  0  0  0  0  --------  [ 242]




----------------------
story mode start new game
start level with gate
quit to overworld
quit to menu
quit program
----------------------
works good

---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 146]
[State 12 - Next Level]   [play lev:1]  [next lev:5]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [  83]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [  83]
[State 12 - Next Level]   [play lev:5]  [next lev:1]
12 12  1 11 12 11 10  1
pre-load transition
transition from game to gate
2game to gate set
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 11 10  --------  [  40]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 11  --------  [  40]



----------------------
story mode start new game
start level with gate
next level to overworld
----------------------
works good

----------------------
story mode demo from menu
----------------------
works good



quitting demo mode to menu
first 32 goes from nothing to menu
then 1 goes from game to menu

stop 1 from doing that...
set quit_action to 99 in 32


bug, after demo mode starting single player in story starts last loaded level then freezes...
fixed by forcing
if (!mMain.classic_mode) mLevel.start_level = mLevel.play_level = 1;
in 10 new game




----------------------
story mode demo from gate
----------------------
end transition not right

goes back to gate twice?


System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [  94]
[State 31 - Setup Demo Level]  [lev:3]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  68]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  68]
[State 12 - Next Level]   [play lev:3]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [  42]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 32 11 31 11  --------  [  42]
[State 12 - Next Level]   [play lev:1]  [next lev:1]
12 12  1 11 12 32 11 31
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 32 11 31  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 32 11  --------  [  39]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 32  --------  [  39]

C:\pm>

added extra text to next level preload transition:

      if ((!gate_to_game) && (!classic_next_level) && (!mMain.classic_mode) && (!mDemoMode.mode) && (state[2] != 32))



when going back:
it goes back to overworld twice


System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [  45]
[State 31 - Setup Demo Level]  [lev:4]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  30]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  30]
[State 12 - Next Level]   [play lev:4]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [  42]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 32 11 31 11  --------  [  42]
[State 12 - Next Level]   [play lev:1]  [next lev:1]
12 12  1 11 12 32 11 31
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 32 11 31  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 32 11  --------  [  45]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 32  --------  [  45]

C:\pm>


32 dr2 42

42 means return to overworld

set a done action there

done_action 2 = overworld

then in 12...

it starts overworld...good so far


---------------

- I am in overworld
- start demo level

         mDemoMode.mode = 1;
         mDemoMode.restore_mode = 42;
         mDemoMode.restore_level = lev;
         mLoop.state[0] = 31;
         mLoop.quit_action = 2;
         mLoop.done_action = 2;
31
quit demo level
32
transition from game to gate
12
no transitions
load level 1 (overworld)
11 start level 1

11 quit to 1

[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld


in the first 12 change quit_action to 1


      if (quit_action == 2) // overworld
      {
         quit_action = 1;
         if (debug_print_more) printf("change quit_action from 2 to 1\n");
      }


this is working, but is getting very complex...

I am not making much use of done_action...

next bug...after gate demo..play the level..then exit freezes...

it is because level is not being set back to overworld

the last bit of code to fix the last bug broke this...


I have again run out of time...

what to fix next?


moved it to here and now both cases work...

      if (rm == 42) // started from gate, send to overworld with next level and level 1
      {
         mScreen.transition_cutscene(1, 3, 120, 0.02); // game to gate
         mPlayer.syn[0].level_done_next_level = 1;
         state[0] = 12;

         quit_action = 1;
         if (debug_print_more) printf("changed quit_action to 1\n");
      }

it looks like most things in story mode work


story mode setting exit exits program...fixed



demo mode from settings works

demo single from settings esc quit stuck in 32 drm31 m0

change drm from 31 to 32 in setting start single demo...

now seems to work...


so does all stuff in settings work?
story mode demo setting all seems to work

what about starting single, server, and client games from settings??

lets look at single
what do we want it to do?
come back to settings after level done or exit



---------  State change from  1 to  3  --------   3  1  0  0  0  0  0  0  --------  [   0]
---------  State change from  3 to 10  --------  10  3  1  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
---------  State change from 10 to 11  --------  11 10  3  1  0  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 10  3  1  0  0  0  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1 11 10  3  1  0  0  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1 11 10  3  1  0  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1 11 10  3  1  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1  3  1 11 10  3  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1 11 10  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1 11  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [  91]



lets look at classic mode

first fix the classic mode menu


start new game good
resume good
quitting from resume quits program..fixed

demo mode menu start
next level
exit with keypress
exit with level done
all good



settings demo mode
12 pre load transition




bug - in all mouse button click on widgets things
click on button
dont move move
cant click again on button unless mouse if moved

for example:

settings
press play demo level button
quit with esc
can't press again unless mouse is moved slightly

I still get the events mouse down and up


what is happening is the mouse x and y are getting changed
it all works fine in text_double 1 but not anything else..


in mInput.initialize

I get the initial mouse positions, but don't scale them...fixed

   ALLEGRO_MOUSE_STATE state;
   al_get_mouse_state(&state);
   mouse_x = state.x / mDisplay.display_transform_double;
   mouse_y = state.y / mDisplay.display_transform_double;
   mouse_z = state.z / mDisplay.display_transform_double;



settings demo single
no transition

show dif from demo rnd start to demo single start

demo single start:
31 - 11 - 32

demo rnd start
12 - 31 - 11 - 12 - 11 - 32


for demo rnd I am doing the transition in 12

for single it never passes through 12

they both pass through 31...

but after the load...so that doesnt help

or does it?
I am trying to do the post load transition


back to settings demo single preload transition...


I could hook into it in 31...

do I even care?

rand does a zoom from nothing, I want to do the same

it was already there for demo_mode ==2, I just hijacked it to do 1 also

hope this doesn't affect single demo called from gate....

test..it does...
add a test so it doesn't

actually simplified that a lot, now only 2 choices:

      if (mDemoMode.restore_mode == 42) mScreen.transition_cutscene(3, 1, 120, 0.02); // gate (gate to game)
      else                              mScreen.transition_cutscene(0, 1, 90, 0.01);  // all other (nothing to game)


back to testing...

demo mode from settings:
good in both classic and story

args still work?
yes for demo
yes for single level

story mode:
good:

classic mode:
good



advanced:
overworld in classic mode
starting level from gate works
when quitting level goes back to overworld
when completing level, goes to next level, not overworld
when exiting from that level goes back to overworld

classic mode with any level other than overworld
start level and exit to menu with resume
finish level take you to next level
nothing changes start level, except manually changing it

demo from overworld has extra transitions at end


---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [ 269]  --------   [qa:2] [da:2]
[State 31 - Setup Demo Level]  [lev:70]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  36]  --------   [qa:2] [da:2]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
changed quit_action to 1

---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  36]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:70]  [next lev:1] [qa:1] [da:2]
12 12 32 11 31 11 10  1
pre-load transition
game to nothing for classic next level
transition from game to nothing
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [ 390]  --------   [qa:1] [da:2]
[State 1 - Game Menu] - quit_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12 32 11 31 11  --------  [ 390]  --------   [qa:0] [da



added another exception

// -----------------------------------------------------------------------------------------------------
// classic mode and not gate_to_game and not in demo mode
// zoom to nothing before loading next level
// make an exception to not do this if returning to 1 (like when demo ends)
// (mPlayer.syn[0].level_done_next_level != 1))

// -----------------------------------------------------------------------------------------------------
      int classic_next_level = 0;
      if ((!gate_to_game) && (mMain.classic_mode) && (!mDemoMode.mode) && (mPlayer.syn[0].level_done_next_level != 1))
      {
         if (debug_print_more) printf("game to nothing for classic next level\n");
         classic_next_level = 1;
         mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
      }

now it looks good

what else is there to test?


game start from settings?
cannot exit after...


---------  State change from  1 to  3  --------   3  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:0]
---------  State change from  3 to 10  --------  10  3  1  0  0  0  0  0  --------  [   0]  --------   [qa:3] [da:3]
[State 10 - New Game]  [lev:70]  [qa:3] [da:3]
---------  State change from 10 to 11  --------  11 10  3  1  0  0  0  0  --------  [   0]  --------   [qa:3] [da:3]
---------  State change from 11 to  1  --------   1 11 10  3  1  0  0  0  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1 11 10  3  1  0  0  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1 11 10  3  1  0  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1 11 10  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1 11 10  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1 11 10  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1 11  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3


added test to settings for esc pressed on entry to wait for release

single player start from setting works
in classic mode, uses start level, same with story only start level is always 1 in story mode...


I think I have all the transitions working...


netgame has not been tested...
for netgame, we never leave a running game...always in mode 11 or 12...

I want to make the timing something I can change in settings



bug - in menu mouse, when mouse is on menu, keys do not work
even if mouse times out...

added this and now works like it should

if ((mInput.mouse_x > mix1) && (mInput.mouse_x < mix2) && (mInput.mouse_y > miy1) && (mInput.mouse_y < miy2) && (!al_get_timer_count(mEventQueue.mou_timer)))



I have a bad transition return to level 1 in classic mode

classic mode
when on lev 1 can start levels just like in story mode
when exiting go back to level 1

when completing go to next level

but do not change start level unless changed on menu


Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 205]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:3] [qa:2] [da:2]
12 12 11 10  1  0  0  0
pre-load transition
set gate_to_game for post transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 198]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [ 198]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:3]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
pre-load transition
post-load transition
not state[2]=32 and classic
transition from nothing to game
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]



this is what it should be (story mode)


1  3  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:0]
[State 1 - Game Menu] - quit_action:1
---------  State change from  1 to 10  --------  10  1  3  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:2]
[State 10 - New Game]  [lev:1]  [qa:1] [da:2]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  3  1  0  0  0  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to 12  --------  12 11 10  1  3  1  0  0  --------  [  84]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:3] [qa:2] [da:2]
12 12 11 10  1  3  1  0
pre-load transition
set gate_to_game for post transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  3  1  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  3  1  --------  [  39]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  3  --------  [  39]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:3]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]












fix the next level cases:

how many cases are there?

- classic mode gate demo end
- story mode gate demo end

these should be the same

pre: game to gate
post: none

also story mode level done that returns to overworld
also classic mode level done that returns to overworld

all these cases come from a level to overworld


what other cases are not like this?

demo random next level
classic next inc level

these should both be:
pre: game to nothing
post: nothing to game



I think I have simplified that a lot...now test:

start new game in classic mode, force play level to be start level..done


demo mode from menu...


---------  State change from  1 to 12  --------  12  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 12 - Next Level]  [play lev:71]  [next lev:0] [qa:1] [da:5]
12 12  1  0  0  0  0  0
Level to level (no overworld)

pre-load transition:game to nothing
post-load transition:nothing to game

transition from game to nothing
---------  State change from 12 to 31  --------  31 12  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 31 - Setup Demo Level]  [lev:70]  [drm:21]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
---------  State change from 11 to 32  --------  32 11 31 12  1  0  0  0  --------  [  43]  --------   [qa:1] [da:5]
[State 32 - Quit and Cleanup Demo Mode]  [drm:21]  [m:2]
transition from game to nothing
transition from nothing to menu
---------  State change from 32 to  1  --------   1 32 11 31 12  1  0  0  --------  [  43]  --------   [qa:99] [da:5]
[State 1 - Game Menu] - quit_action:99
---------  State change from  1 to  0  --------   0  1

found a new case for 12...menu to demo
menu to nothing then nothing to game

test more...

make a common place for transition speed and length...

it needs to be saved in config...

done...now change all call to transtion...done




test thoroughly....

args..

bug? if in story mode, starting lev from command line starts overworld...
I think I will just leave it like this


args story mode demo good

classic mode start lev from commnad line sets start level...



bug classic mode start level from gate
return transition wrong


---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 101]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:2] [qa:2] [da:2]
12 12 11 10  1  0  0  0
Next level from overworld

pre-load transition:none
post-load transition:gate to game

transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [  44]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [  44]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:2]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
Next level to overworld
Demo mode started from menu

pre-load transition:menu to nothing
post-load transition:none

transition from menu to nothing
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 11 10  --------  [  61]  --------   [qa:1] [da:2]
[State 1 - Game Menu] - quit_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 11  --------  [  61]  --------   [qa:0] [da:2]



the problem is, 2 things matched in 12:
Next level to overworld
Demo mode started from menu

only the first should have matched

quiting back to over world from level passes through menu (1) so it thinks its demo mode started from menu

added test and fixed

// -----------------------------------------------------------------------------------------------------
// previous state == 1, called here from menu
// the only time this happens is when starting demo mode from menu
// -----------------------------------------------------------------------------------------------------
      if ((state[2] == 1) && (mDemoMode.mode == 2))

just a quick check but I think all classic and story is working




20230610

make it so that I can continue on from a demo
press a key and now I am playing
erase all game moves after current, change control method..


it works!

use it to fix lev 12
cut in about 390s
get last coin

done demos for up to level 35




when ! is in lift name it shows up as = and !, nowhere else...

font is pr8

I use that everywhere
there is actually something wrong with that font

rebuilt it with //   mFont.convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
and now it is good

bug - level editor, then play game instantly, then exit...program quits..fixed

make the time in the upper frame do m:ss when > 60s..done



can I make all my gates show the number, name, and small icon






I am thinking about removing the enemies left achievemnet and the level done icon

then I would only have the purple coin and time achivements

I can show if completed some other way..



if a level becomes complete by cheating, unlock it..done


make a group of the first 8 levels on a platform...


unlock all training levels by default


make some more level icons
I want a way to load and draw a level with interrupting the level in progress

duplicate the data structures?

make the draw routine use either?

what do I really need?

blocks
items
enemies
lifts
i can fake players if I need to..

this will also make ft easier...maybe

because they are a class, could I just add another instance
or another array to the exiting instance

start with level



or I could store the full 2000x2000 for each level to make scaled drawing nicer....
this would not work, as I only draw to the level background not screen

just make some different sized icons


advanced enemy info levels:
90-95
center levels...done
titles..done
purple coins..done



bug - spelling error in selection buttons..fixed

bug - crash when move top row in overworld
find out what is causing it
it is in draw_items
fixed for door, now do custon in es_draw_item

bug - edit text for msg can not see cursor
it is because I manually edited 127 in the font bitmap
fixed..open in gimp and draw a line at the bottom of 127...


bug - archwagon arrows do no damage
dammnit I will have to redo lots of demo's!!!
fixed

remove free man from PDE..done

bug - 2 way door creator has one door invisible..fixed

bug - lone door creator causes crash..fixed


15 smash demo is broken falls through lift
level 15 'could not find move step'
fixed

index = 0;

demo mode does not do pass 2
fixed a bug I introduced when trying to nor choose overworld level as demo
confused index with level, renamed to avoid future confusion


101
972
1

11-1
12-1




               mItem.item[c][0] = 1;    // type 1
               mItem.item[c][1] = 2;    // draw type
               mItem.item[c][3] = 0;    // stationary
               mItem.item[c][6] = 13;   // default color = lt blue
               mItem.item[c][8] = 1;    // type: linked exit
               mItem.item[c][11] = 0;   // enter immed
               mItem.item[c][12] = 1;   // always draw line

               if (mMiscFnx.getxy("Destination Door", 2, 1, d) == 1)
               {
                  mItem.item[c][9] = d;  // linked exit

                  mItem.item[d][0] = 1;  // type 1
                  mItem.item[d][1] = 2;  // draw type
                  mItem.item[d][3] = 0;  // stationary
                  mItem.item[d][6] = 13; // default color = lt blue
                  mItem.item[d][8] = 0;  // type: exit only


PDE uses 1 to show tile...
could use creator for this too...


do it...

210
211

209 single door item

bug level editor someimes draws status and selection windows on level buffer instead of screen
I think when drawing blocks in that mode it calls init_level_background and this changes the target bitmap
I explicitly set it back to the backbuffer after and it seems fixed


add the rest of the levels

I have all levels done except 64

it needs some work..

make the rocket npc platforms match npc color


can I make npc crew smaller and call them children?

I can but the scaling looks bad..
I wish I could draw them directly on the screen

I have it working!!

make scale adjust Ef[][8]

I have the npc scale looking great

now I can call them children!!

nice!!

level 64 is done and I have demo for it..
what happens after final cutscene?
level done called??

all good...


now what?

test with multiplayer

set up locked zones and groups


20230614 push

now that I have all the levels and demos done, you know what that means?
No more changing levels!

Now I work on overworld...



what mechanism will I use to lock off areas in the overworld?


use completed levels to set something
when overworld is running emit triggers...

or...

have a master copy of level 1
manually remove blocks and save level

or manually add them when reseting

test that...
x=60
y=26 to 35


how to unlock?
test everytime a level is completed?
then load and resave

keep a local array of locked and unlocked area

force set with every level done


keep a saved array of locked areas
int area_locks[16];
when reset set them all locked (1)

make a function to set clear them all


I think I have the framework in place

int area_locks[16];

void mwLevel::clear_data(void)
{
   for(int i=0; i<16; i++) area_locks[i] = 1;
   set_overworld_barriers();

void mwLevel::set_overworld_barriers(void)
{
   load_level(1, 1, 0); // load level

   int block = 141 | PM_BTILE_ALL_SOLID;

   for(int i=26; i<36; i++)
   {
      if (area_locks[0] == 1) mLevel.l[60][i] = block;
      else                    mLevel.l[60][i] = 0;
   }

   save_level(1); // save level

}



      // check for other things to alter on the ovrworld level

      // unlock area 0

      if (data[4].completed)
      {
         if (area_locks[0] == 1)
         {
            area_locks[0] = 0;
            set_overworld_barriers();
         }
      }


   }





now make the triggers more sophisticated


5 levels in area 0
if all complete...
if > threshold complete..


coming along nicely...

make gates show info upward if ypos > blah  done




start with only training level 1 unlocked

when that is complete,
unlock training level 2 then 3


- unlock all other training levels
- open gate to next lower level

- open gate to area 1

I really think I want an item that hides a rectangular section of the level.



19 - hider
all it does is hide selected area
it is still drawn, just has an extra step of erasing

where should it live?
not in items, has to be at the end of draw order

just before or in draw_scaled_level_region_to_display(0);



store rect pos in secondary
active or not
change with trigger
item number 19, tile 476
special creator


got the basic framework working...
now add active or not

and add a way to change that like with a trigger

item[][2] active or not
item[][3] mode

mode:
0 always show
1 always hide
2 show till triggered
3 hide till triggered
4 toggle when triggered
5 show only when triggered




buttons

mode:
initial show/hide if in mode 4
trigger if in modes 2 3 4


can I use trigger item for 1? i do it with others

used it on level 7 to hide cloner...




I think hider is working well

fix the ov for it...done

remove warp, add gate and hider to filters..done

add hider event receiever to events..done


I was planning on adding hider to overworld to hide unopened areas...

gate shows info downwards and gets cut off...


solutions:
- draw gate info upwards
- draw gate info at screen overlay stage

I have broken something...level done shows overworld while waiting

need to find out where...

is it something to do with hider? no
commented out void mwItem::erase_hider_areas(void) and still happens

breakpoint at level done mode 9 and happens before that...

it draws overworld level at the same size at the level just ended
where does it get it from?, does it load level 1?

yes it does...where and why?

set_overworld_barriers...duh...
where should I do that then?

I suppose I could do it in load level for level 1 only...???

after successfull load of overworld level,
call set_overworld_barriers
edit set_overworld_barriers to just modify and save
reduce greatly the calls to set_overworld_barriers
now only in load_level
clear level data now loads level 1 to set_overworld_barriers
that bug has been fixed

try drawing gate info upwards, always


I am thinking of getting rid of the 200x200 level icons..
the smaller ones work just fine



I have injected draw gate info into the draw sequence....

draw everything else
erase hiders
draw gate info
draw level region to screen
this seems to work...


now make it look nicer..

custom add hider(s) to overworld level

start with one that hides everything below 240

customize it based on area_locks

can I assume that all area lock will be removed in sequence?

when area lock 0 is complete

if (area_lock[0] == 1) // full hider from 240 down
if (area_lock[0] == 0) // hider from 460 down
if (area_lock[2] == 0) // hider from 680 down


then after all that ...

erase all hiders and create a new one


20230618 what am I working on today?
more overworld

I want a custom area message
about what you need to do to enter the area
then after that, stats about the area:
percent complete, etc

I think I want to get rid of the labels above traing level and reduce the height of rows...

now my overworld rows are 8 blocks high, 9 counting the 1 block spacer...

top row, training has bottom block of 9
next row area 1 and 2 bottom block 18..


do they all have the same width of the blocking block?

for testing make it o the pressing C on gate completes level..


now do the dynamic area messsages

Area 1
locked
complete 3 training levels to unlock

or

0/5 complete



how do I make this nice?

recreate everytime

area 2
erase
create
adjust size and color based on text

this is coming nicely, but I can probably make it even more generic



coming along great!!

I want to make the gate tile different colors.. I have 12 blue, but I also want 10 red, 13, lt blue, 11 green,

what colors?

locked - red (or gray?)

ready - lt blue

complete

complete with coins and time purple


locked:
red icon, white text locked


complete and perfect...

make a helper function to show framed text...do I already have one? i do now??

remove the what is locking page, it should be obvious...

cleaning up pages...

count how many purple coins in each area and how many collected..done

now do the same for time...

it looks like time is not being recorded properly

it is always zero

not sure if its because of my cheating way of doing levels

timer works good

the overworld is looking very good


line up message on right side
show actual total coins in messages even if area locked

20230618 push


I am thinking of rearranging the levels again...
I need 6 more levels
then I can fill out area 8 and have 64 past that...


I want to make a dynamic method of putting levels in areas

make an array with all levels in screen order?

area_array[][0] level number
area_array[][0] area
area 0 == training


this is coming nicely
auto fill area array done
use area array for level and area unlock done

next use area array for message stuff

make sob_area_msg(int area, int x, int y, int g1, int g2, int g3, int g4, int g5)

figure out what levels are in the area instead of passing them..done...

added area 8

I want to make a way of umlcoking everything

how about reset is the only things adds all barriers, i think that is the way it is now...


add area msg for extra and advanced

make total only count main areas



20230622

overworld is coming along great, I have all the areas working just like I want

now I want to make huge list of all levels and the status, complete, etc...

I might want some way of recording when I am playing a level and abandon it without completing

I also want a way to save the gm files for levels that beat the par time...nice!!


huge list of levels


try text to console to start...

maybe I could have a dedicated level just for that, it would also help with my time out issue...

make level 99 stats level

now show somethinge there..how? where do I hook it in?

special msg?

sure why not? unless I later think of a better way to do it...

it looks like the area_array is not getting filled...why?

main calls  mLevel.setup_data(); in initial setup

void mwLevel::setup_data(void)
{
   load_data();
   load_level_icons();
}


void mwLevel::load_data(void)
{
   fill_area_array();


I got it!!

fill area array only works if level 1 is loaded!!!

to fix...
save area array like the rest of the data
re-create it only when resetting data...


20230623 push

20230624 now what?

make it so that the calc size happens without drawing the wrong size first..done

customize to only show certain areas..done

totals?

make time display also show hours...
only if min>59

% done
% perfect

do a super fast play mode for demo level completion..done

custom area display variable...or...

Main Game
totals

Training Levels
totals

Extra Levels
totals

Demo Levels
totals

grand totals


I did the area and grand totals and it looks great..

Now I would like to change with up and down


do i have any extra variables in msg?

always have 99 unlocked

now how to link it...

regular message with special text?


now how to adjust show stats based on unlocked areas

if only training, show only training


when I am show the stats message on overworld, it can get cut off by hiders
should I investigate how to make it draw on top of hiders?
...gate draws below...just saying....
I can do it in draw sequence...
that was actually quite easy..


can I make main game only show open areas?

when calling

Level Statistics Full (forced all)
Level Statistics Game Only (game only)
Level Statistics Overworld (as much as is completed)

pass msg_type to rows to do custom columns..done

make

training only overworld

add 2 vlines to title..done

add status to totals (only complete or perfect)..done

bug - gate crashes if level it points to does not exist..fixed
bug - total percents wrong..fixed
bug - different draw routine when drawing level for map..fixed

20230627

I want a gate to level 99 somewhere in overworld
- show detailed info
- relief level for when timer gets too high

or how about when timer gets too high, just do timeout and reload overworld, or whatever world you are in

It would have to be a very large timeout so not to mess with player games...

I could put the detailed stats in settings...

lets do that...done


I am spending a lot of time looking at the starting part of overworld, trying to figure out how to
make it look better and do what I want it to do..

now that I have level stats in settings, I don't need level 99....that will make things simpler

do some clean up of that..

now there is only one call from message and one from settings...
settings does full (1)
message does overworld all (3)

grand totals could use some cleanup...
never show 'level'

when doing full, show all areas, even if locked..done

in overworld all, do not show grand totals until main is done..done

in settings, have options to show all or partial, also move buttons to that page..


bug - why does blue key fall have a huge enemy killed stat
does not happen when running demo from gate
always this number: 2031971
is it in level_data or level_play_data?
now it is hard to reproduce

bug - going from level editor to game...level gets set to some huge number...
no, its when changing speed
start game
no its random...
what have I changed recently...added item type 19
this bug is hard to reproduce...has not occurred for a long time now


bug - in level editor, moving cloner with edit selection broke link from timer to cloner
cloner was in selection, timer was not...
i think the clt made a new event for cloner, even though it did not need to as it was only one event, not a pair
also because it was just a move, not a copy, it did not need to do any clt...
need a way in edit selection to not do clt if move..
nothing happens for clt in putting stuff into ft, only when pasting it out...
can I use copy_mode to track what mode I am in?
it looks like copy mode is always 0 or 1
can I set it to 2 when initiating move?
then from 2 to 1 after first move?
I think I have this working, but need to test more....

bug - in es copy and move doors
doors destinations are screwed up....
moving doors gives them different item numbers, and that is what is used to link doors....
I see no way to fix this, it was always a fragile setup...
Unless I make the links between doors use a different method, independant of item numbers

bug jumpworm tile sometimes leaves artifacts, make sure to draw tile with int not float
sometimes explosion bitmap does the same
changed all enemies to int int now...
see how that looks

void mwEnemy::draw_enemy(int e, int custom, int cx, int cy)
{
   int type = Ei[e][0];
   int x = Ef[e][0];
   int y = Ef[e][1];




bug - in classic mode when completing a level from overworld, next chron level starts
should be back to overworld...???
only do next chron level if not started from overworld
show be fixed..
added pre_lev_loaded

int valid_level_loaded;
int prev_level_loaded;
int last_level_loaded;
int resume_allowed;

int mwLevel::load_level(int level_num, int load_only, int fail_silently)
{
   char msg[1024];
   zero_level_data();

   prev_level_loaded = last_level_loaded;
   last_level_loaded = level_num;
   valid_level_loaded = 0;
   resume_allowed = 0;

void mwItem::proc_exit_collision(int p, int i)
{

         // in story mode exit always goes to overworld
         if (!mMain.classic_mode) mPlayer.syn[0].level_done_next_level = 1;

         if (mMain.classic_mode)
         {
            // in classic mode if level started from overworld, return to overworld
            if (mLevel.prev_level_loaded == 1) mPlayer.syn[0].level_done_next_level = 1;
            // other wise do next level
            else mPlayer.syn[0].level_done_next_level = mLevel.get_next_level(mLevel.play_level);
         }

I might be able to simplify this...try:


        if (mLevel.prev_level_loaded == 1) mPlayer.syn[0].level_done_next_level = 1;           // if started from overworld, return there
        else mPlayer.syn[0].level_done_next_level = mLevel.get_next_level(mLevel.play_level);  // otherwise do next chron level










bug - when player is on a gate and data is shown, then go back to menu and use arrows to change start level
that info shows on other loaded levels and is wrong and sometimes crashes..
reset that value somewhere

void mwItem::proc_gate_collision(int p, int i)
{
   mPlayer.syn[p].marked_gate = i;

fixed by calling mPlayer.init_player(0, 2); in load level

mLevel is 2000 lines long...could I split it into mLevel and mLevelData

what about tracking levels started but not completed?
how could I do that?


struct level_play_data
{
   int level;
   double start_timestamp;
   int timer;
   int completed;
   int number_players;
   int enemies_killed;
   int enemies_left_alive_at_exit;
   int player_respawns;
   int purple_coins_collected;
};

just have a record that is not completed..

set it when exiting to overworld or menu
maybe not menu, because resume is possible
if on menu and resume is possible and a new start level is chosen...
that could work

how many entries do I have set aside space for:
100,000

I don't show anywhere how many I have used.
If the limit is exceeded do I just exceed the array bounds and bad stuff happens?




use a function similar to:
void mwLevel::level_complete_data(int type, int lev)

level_abort_data


what am I going to use this for?

show on advanced

also use elapsed time to add to total, (but not average completed time)


made the function, where to patch it in?

when exiting to overworld...


         if (quit_action == 2)  // overworld
         {
            if (debug_print_more) printf("instead of menu, go to overworld\n");
            mPlayer.syn[0].level_done_next_level = 1;
            state[0] = 12;      // next level
            quit_action = 1;    // menu
            done_action = 2;    // overworld (should never trigger level done from overworld, no exits)


            printf("save abort level data\n");

            mLevel.level_abort_data(mLevel.play_level);

            return;
         }

when level changed with arrow keys in menu and resume true

         if ((top_menu_sel > 100) && (top_menu_sel < 200)) // right pressed on menu item
         {
            top_menu_sel -= 100;
            if (top_menu_sel == 2)
            {
               if ((mLevel.resume_allowed) && (mLevel.play_level != 1)) mLevel.level_abort_data(mLevel.play_level);
               mLevel.next_level(); // next level
            }
         }
         if ((top_menu_sel > 200) && (top_menu_sel < 300)) // left pressed on menu item
         {
            top_menu_sel -= 200;
            if (top_menu_sel == 2)
            {
               if ((mLevel.resume_allowed) && (mLevel.play_level != 1)) mLevel.level_abort_data(mLevel.play_level);
               mLevel.prev_level(); // prev level
            }
         }


when visual level select is called and resume true

int mwVisualLevel::visual_level_select(void)
{

   if ((mLevel.resume_allowed) && (mLevel.play_level != 1)) mLevel.level_abort_data(mLevel.play_level);


change the test for lev != 1 to the function   ..done


now what? I am collecting the info, what do I do with it?
show in detailed stats..done


if lev has been started > 5 times but not completed, offer the option to complete it with demo mode
I need a way to mark if this is the case...

settings...

stats add the buttons for reset and unlock
maybe show number of level data


can I make stats tab show up earlier in tab list? yes..done


where am I going to put classic / story button?

for now, the misc tab is the bext option

I think I need to test all this overworld stuff in multiplayer...






bug - when starting game in story mode, level is loaded and drawn on screen before level data, so hiders are not working...
only in story mode...
changed the order here and now it looks good.
   mLevel.setup_data();
   if (classic_mode) mLevel.set_start_level();
   else mLevel.set_start_level(1);

bug - when I run reset all level data, I end up on level 99
only in story mode, and only the menu level map is set wrong
fixed, by reloading play level after...


bug - when going to a level from overworld, client soon quits after....why??
loses server connection

how do I even start to troubleshoot this?

logs


i think it has something to do with next level....

i think it has something to do with previous state that gets returned to...

on client done_action is set to 0 so client quits at next_level
where does this get set? in menu..

ok back to client loses server connection

it was the goddamn transitions!!!!

works good now that they are set very low...
I will need to do something about that, but for now lets see what else works...or doesn't

overworld works


server and client should not both have to be classic or story...
what the server is determines what next level is called

what if the server has locked areas that the client does not?
the server will overide client

this works well, but levels locked on the server and unlocked on clients, are still unlocked on clients
what if a made a flag in gate that the server could propogate to the client??? or just do nothing...


what happens when client presses ESC? quit the netgame
same for server

what if I made it so that server could return to overworld instead of just quitting..sounds complicated
don't do it for now


so unless I change something, server or client pressing ESC quits the netgame
that should be OK

How hard would it be to do something else?

what if ESC in netgame pauses the player (invul?) and brings up a specific menu...

quit netgame
back to overworld
settings
back to game


I would need some global settings:
pause in netgame
client can return to overworld
invul when paused
everything freezes when paused

see, it gets complicated...

I think I should just leave it as it is

I want to be able to leave my server runnning indefinitley
so I want some sort of reload of level after a long time on one level..

how much time? 1 hour on a single level?
how many game moves? 1 million (999,990)

what do I do? return to overworld

where do I hook this in?
server
done



move level_data to its own folder

mW.pm
level_data

or just get it out of bitmaps

how about data?
also put mW.pm there

data folder created

level_data.pm now lives there
if missing it is recreated

now what about mW.pm ..done

now what about level_icons?

move them there too?

also create ones for visual_level_select?
and only recreate if size changes?

100
200
x




I am having problems recreating level icons

am i trying to do it too early?


it is a goddamn chicken and egg thing
draw level tries to draw icons that are not there yet...

in draw gate added this test:

if (mLevel.level_icon_200[lev]) al_draw_bitmap(mLevel.level_icon_200[lev], lx, ly, 0);

this is working good, but now I want to add vls...

in vls save gridsize in config

when running vls, if grid size does not match saved then recreate icons

vls has been added...

now vls can never do more than 100 levels, because that is all the icons I create


I want to move them to data as well, so they are recreated with release



so now with release...

do I create a data folder??

after all that bullshit...what if I just saved them all full size and drew them scaled...



made a data folder for release and cleaned up both win and lin release scripts
test win...seems to work well

remove beat and quit from simple overworld stats..done
add them to gate pages..done


test_lin .. seems to work...

linux seems to be off by one pixel in the level icon frames..fixed


bug - when player that is not player 0 collects purple coins they do not show on top frame
only on level 128?
works good in single player...redid that level to make rocket's explosion bigger, will need to do new demo
still consistanlty happens...
no coins show collected on frame or on end credits, but show in stats

sometimes they show..some of them do anyway

could it be they are getting collected during a rewind?


i think the error is here:


void mwItem::proc_bonus_collision(int p, int i)
{
   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      if (!mLoop.ff_state)
      {
         mPlayer.syn[p].stat_purple_coins++;
         mLevel.level_data_purple_coins_collected++;
      }
      mGameEvent.add(27, 0, 0, p, 0, 0, 0);
   }
}

should be:


void mwItem::proc_bonus_collision(int p, int i)
{
   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      if (!mLoop.ff_state)
      {
         mLevel.level_data_purple_coins_collected++;
      }
      mPlayer.syn[p].stat_purple_coins++;
      mGameEvent.add(27, 0, 0, p, 0, 0, 0);
   }
}
that seems to have fixed it...


add the demo and cheat thing back...

demo can always be called from gate
after 3 plays and no complete, cheat can be called which is just demo, but saves results

// clear them here so they cannot be saved up
mLevel.skc_trigger_demo = 0;
mLevel.skc_trigger_demo_cheat = 0;

where?
in serial key check..done


where will I put classic/demo mode in settings
how about on stats page, only when advanced
done and looks good...

20230702

it feels like I am getting close...

test more netgame stuff...

what if I start server from command line? does that work? yes


I think the game is working well...

do I have any docs left to do?

how is help?



bug - did I not, at one point edit the pristine font to make quotes and doubel quotes look better?
I think I lost that...fixed

make a new settings tab:

game mode

now game mode and stats look great in settings...

finish help section for mode...done


its getting better....

do a push


make start spawn point individual only spin for correct player....done

make a new mode...no backsies
spawn points can only increase..done

test it out with level 21

what if a player needs to die to spawn at a newer one?


test demo for 21...still works




I am thinking of removing auto door move type


it is just uneccesarily complicated


the door that it is linking to will never change stationary or not

just set it once and forget it...


how many doors and what modes do they have?


item[i][7] = move mode
0-auto
1-force instant
2-force move

item[i][8] = door type
0 - exit only
1 - normal

move type applies to the door you are moving to, right?
yes, but that means that it is set in the door you enter


this means that move type does not means anything in exit only doors, right?
I think so...


595 normal
390 exit only

first of all ignore all exit only

how many normal with auto?
285


all normal with auto...
get destination door and find out if it is stationary

item[][3] == 0 stationary


I think I have converted all doors to not use auto move...


now do stuff when creating...

fixed widget to only allow 1 and 2..done


now in door creator...
make them all 2 move..done


now in door code...remove code:

               int instant_move = 0;


//               if (item[i][7] == 0) // 0 = auto
//                  if (item[li][3]) // if dest is not stat
//                     instant_move = 1;

               if (item[i][7] == 1) instant_move = 1; // 1 = force instant
               if (item[i][7] == 2) instant_move = 0; // 2 = force move

               if (mPlayer.is_player_riding_rocket(p)) instant_move = 1; // 1 = force instant if riding rocket

done....


now if this still all works...
test all levels in demo mode....all demo mode levels still complete successfully....

OK back to help screens..done
also fix DOORS levels..done

you can still change bonus to free man...fixed...




bug - enemy counts like cloner 6 of 0..only sometimes??
it is when the saved current item stuff does not match when a new level is loaded
items and enemies are fixed when creating a new one

it seems like sort is not being called when level is loaded
it should if level editor is running...where can I patch this in?


so why does it not happen on a new load?

how about just patch it in in load level, if level_editor running....

         if (mLoop.level_editor_running)
         {
            mItem.sort_item(1);
            mEnemy.sort_enemy();
         }

this seems to fix it....




bug - level editor dragging window over block check boxes, mouse detects check boxes

I think it is only for draw item block flags



void mwBitmapTools::draw_flags(int x1, int y1, int& num, int& mpow, int view_only, int clear_background, int ignore_mpow)


   if ((mWM.mW[1].draw_item_type == 1)  && (mWM.mW[1].show_flag_details)) mBitmapTools.draw_flags(x1+4,   y1+47, mWM.mW[1].draw_item_num,  mow, 0, 1, 0); // flags
   if ((mWM.mW[1].point_item_type == 1) && (mWM.mW[1].show_flag_details)) mBitmapTools.draw_flags(x1+164, y1+47, mWM.mW[1].point_item_num, mow, 1, 0, 1); // flags



I have d that is passed to:
cm_draw_status_window(int x1, int x2, int y1, int y2, int d, int have_focus)

d is draw only

so I will pass this to
draw_flags(int x1, int y1, int& num, int& mpow, int view_only, int clear_background, int ignore_mpow)

view_only should be the same as draw_only..same with ignore_mpow...

pass d in both case


used by draw item, point item and block selection description
also used 6 times in widgets
void mwBitmapTools::draw_flags(int x1, int y1, int& num, int& mpow, int view_only, int clear_background, int ignore_mpow)


all 6 widget cases use    0, 1, 1
point item and select use 1, 0, 1

draw item uses            0, 1, 0

draw item use does not seem to matter if I use 1 or 0 for last arg


I don't want to mess with this function


lets look at d passed to it

cm_draw_status_window(int x1, int x2, int y1, int y2, int d, int have_focus)
is called only by
void mwWindow::draw(int draw_only)

and is d is always 1, no matter what
what about have focus

actually d is not 1 when mouse is on status window

do I need to make it its own window? ,cause that is too much



how about if any window is moving? or specificaly slection window?
that is an ugly hack, but it might work.


this is what fixed it:

   // this ugly hack is to prevent the draw item block flag toggles from capturing the mouse when moving selection windows over them
   if (mWM.mW[2].moving) d = 1;
   else d = 0;

   // draw item area
   al_draw_text(mFont.pr8, mColor.pc[15], x1 + 24,  y1 + 13, 0, "Draw Item   ");
   al_draw_text(mFont.pr8, mColor.pc[14], x1 + 100, y1 + 13, 0, "mouse");
   al_draw_text(mFont.pr8, mColor.pc[14], x1 + 143, y1 + 13, 0, "b1");
   em_show_item_info(                    x1 + 2,   y1 + 20, 9, mWM.mW[1].draw_item_type, mWM.mW[1].draw_item_num);
   if ((mWM.mW[1].draw_item_type == 1) && (mWM.mW[1].show_flag_details)) mBitmapTools.draw_flags(x1+4, y1+47, mWM.mW[1].draw_item_num, mow, d, 1, 0); // flags


old:
   if ((mWM.mW[1].draw_item_type == 1)  && (mWM.mW[1].show_flag_details)) mBitmapTools.draw_flags(x1+4,   y1+47, mWM.mW[1].draw_item_num,  mow, 0, 1, 0); // flags





what is a nice sensible value for transitions for release

right now I use:
   agci(GAME, mScreen.transition_num_steps, 60)
   agci(GAME, mScreen.transition_delay, 25)

60*25=1500
60*15=900
I like 60, 15

start in story mode...done




I just tried running the game on an old acer travelmate and found some bottlenecks

creating level icons takes 17s

drawing gate items in overworld make that level very slow

the profile said it take 33ms

screen_overlay takes 8ms with cpu graph running 1ms without

flip display takes 4ms

          m36   e6430 4230
ov gates  2ms   7ms   33ms
scr ovrl  0.4   1.0   8ms
flip      0.1   0.5   4ms

could I draw all of the overlay on a huge buffer?
wait a minute?, I already do that with level buffer!!


I draw the gates on level background and now instead of 33ms I get 8ms, much better

what about messages?

how much time do they take?

I would need to run a profile log

I do not have a way of determining how long messages and gates take to draw...

I want to know though...

how can I add more measuring?


only things that get called in draw sequence
make an array of times for draw seq...


draw sequence is looking so good!

I have profiles for all I need and the code is much cleaner and extendable...

now test...

original
-------------------------
       m36  e6430 4230
gate   1.3  5.0   24.0
mssg   0.5  1.7    7.7
ovrl   0.4  1.1    8.0
flip   0.1  0.8    4.4
totl   2.5  9.3   48.0


draw gates moved to background
------------------------------
       m36  e6430 4230
gate   0.0  0.0    0.0
mssg   0.5  1.7    7.7
ovrl   0.4  1.1    8.0
flip   0.1  0.8    6.0
totl   1.2  4.3   25.6


static messages on background also
------------------------------
       m36  e6430 4230
gate   0.0  0.0    0.0
mssg   0.0  0.0    0.0
ovrl   0.4  1.0    8.0
flip   0.1  0.8    1.0
totl   0.6  2.3   12.3

this is great...
with overlay off I get 20% cpu on slowest(4230)



now test on slowest and see if it is playable...

yes, it looks good

lifts still take a bit of time
on "Too Many Lifts" the lift drawing takes 25ms on 4230, but drops to 5 with eco draw

does eco draw do anything besides lifts?
also frame_width on messages

can I turn eco draw on automatically if lifts draw time > 5?
am I always checking profile times? yes
I think I could do that



How about some automated tests?

run demo for all levels and check results...
this can be run superfast
- erase all level_data
- run demos for all levels
- check level_data


run demo for all levels and check cpu usage
this has to be run at 40fps
I am very interested in this one
it needs to be automated
at full speed it will take over 3 hours


first of all, make a method to run through all the demo levels in order, exactly once

make a new function in demomode

I could just do regular demo mode and collect logs


then I could parse the logs and get some data...


----------
profile stats display
added all things in draw sequence

test how that works on slower



level stats, all levels reset and unlocked
------------------------------
       m36  e6430 4230
lstat  1.3  4.0   16.0


not good...

what can I do?

draw it once

draw it directly on screen like it overlay??

made the purple coins draw directly on the screen, they look better that way...done...

how about when player stretches or shrinks, like in door travel
that would look a lot better drawn in screen oeverlay also


to do tomorrow:

level stats on its own bitmap

define a level_stats_bitmap


player shrunk on its own bitmap also

what about lifts?




reload gate icons when screen changes





now when blocks are removed, it could mess up messages drawn on the background
i will just have to adjust...done...

now the levels that I adjusted will probably have to have the demos redone....all done



now that always on messages are drawn on the background

in some levels, they used to hide items behind them.
this can be fixed by making the messages not always on, so they are drawn after other items

also scroll is not shown in level editor


where are messages drawn?

background draws meassages that are always on

draw sequence draws messages that are not always on

what about level editor?
why does the scroll not show in level editor?


this is a confusing mess...

draw background draws all msg that are always on for both level editor and normal

msg that are not always on are drawn in draw sequence


draw_items has been fixed to cycle through everything, not exclude msg
draw item just calls draw msg like all other items
this is the most simple and straight forward way of doing things here


draw sequence
calls draw items, which now draw msgs also
then calls draw msg for all 10 that are not always on
this seems to work..


I think this is fixed...
how it works now:

- always on messages are drawn on level background with blocks

- in draw_items, no exception is made for messages
- in draw_item, no exception is made either, everything is passed to draw_message
- in draw_message, always on are not drawn


- in draw_sequence, messages are drawn with all other items, this calls draw_items, so always on are naturally skipped


- later in draw sequence, only messages are drawn, to make them on top..
this is done by calling draw_message only for item 10, this also skips always on

- this has the effect of drawing some messages more than once, and I would like to avoid that

I could do the first one in draw sequnce to draw all items, except for items

what if I just don't care about drawing messages last of all items?

try that...

It's just crazy enough to work

New Description:

- always on messages are drawn on level background with blocks

- in draw_items, no exception is made for messages
- in draw_item, no exception is made either, everything is passed to draw_message
- in draw_message, always on are not drawn

- in draw_sequence, messages are drawn with all other items, this calls draw_items, so always on are naturally skipped

the only thing I want to do now is skip drawing level stats till later in the draw sequence...done...


define a level_stats_bitmap


void mwLevel::show_level_stats(int x1, int y1, int x2, int frame_width, int &w, int &h, int draw, int msg_type)



   ALLEGRO_BITMAP * level_stats_bitmap;
   int level_stats_bmp_valid;
   int level_stats_bmp_w;
   int level_stats_bmp_h;


whenever check stats is called set not valid


whenever show_level_stats is called, if not valid, create the bitmap


comment out settings one for now and just deal with message...


actually I think the settings one might be easier

            int w=0, h = 0;
            mLevel.show_level_stats(0,0,0,0, w, h, 0, 1); // just get size
            int x1 = cfp_txc - w/2;
            int x2 = cfp_txc + w/2;
            int y1 = ya + 26;
            int y2 = y1 + h;
            al_draw_filled_rectangle(x1, y1, x2, y2, mColor.pc[0]); // erase background
            mLevel.show_level_stats(x1, y1, x2, 0, w, h, 1, 1);






call show_level_stats
- if not valid bitmap loaded, get size and create it

- draw bitmap

do I need to make it recursive?

I think so...


first call is with draw = 1

if not valid bmp
- recursive call to get w, h
- create bitmap with w h
- the rest of the draw shit happens on this bitmap
- bitmap is valid

then draw bitmap

if valid bitmap, then just draw it

instead of running to get size, what if I just drew it on a larger bitmap, then after it is drawn and I know the size, just take the actual used portion of the bitmap...

bmp not valid, make new one

bmp valid, draw

holy crap I think I have that working and looking nice...

now invalidate when completing level, or rebuilding bitmaps..done

need to redraw level background on level 1 when screen changes (menu only?)
probably need to reload level icon bitmaps
no, what was needed in rebuild bitmaps, was to:
mLevel.load_level_icons();
before:
mScreen.init_level_background();

20230705 much is working good, the level data stuff draws on its own custom bitmap now


20230706

time for some tests




level stats on its own bitmap, all levels reset and unlocked
------------------------------
       m36  e6430 4230  scat
drawe  .12   0.4   3.1  .28
lstat  .001 .012  .015  .007
ovrly  .38  .36   1.1   8.2


I now notice that enemies take non-trivial ammount when drawing vinepods
I can actually see it go up and down as they retract
what levels have many vinepods?
do glt and find out

I use 3 spine in level 1 and 6 in level 94
wow! all that work that went into them and I dont use them at all!

level 103 has one vinepod that triggers 12 others
profile that
------------------------------
       m36  e6430 4230  scat
12 vp  1.0   5.0   29   1.7


next question:
what if they were all non-spline? profile that
------------------------------
m36  e6430 4230  scat
0.8  3.6   22

I don't think the spline is why is takes so long, it's probably drawing all the leaves


with that in mind test a level that has lots like incen

I think the length and speed have a huge effect

on lev 70
made a non-spine vine pod that travels the entire width of the screen
time:120 0.27
time:60  0.15

the faster one draws fewer leaves and takes less time

so now what? am I going to try drawing vinepods in overlay mode also?

how hard could it be?


OK I have it working, lets test the speed..

it is added to screen overlay but does it need to be?

i dont think I need the old draw vinepod at all..

bad news...it does not seem to save any time drawing directly to the screen
the leaves look nicer though...
make it so that it is easy to re-enable if needed
done..


now what??

is it my manually drawing all those line segments each frame? probably
approx half for the line segments and half for the leaves

it would be too much work, just move on, but first make it look nice

line size of always show

end circle alignment

all done...



remove eco draw from msgs..done...
auto turn on eco mode when lift draw time > 5
where? in draw lifts? sure why not...
no do it in draw_sequence...done
find a way to not permantntly keep it on
remove from config should do it
reset on new level load also



make draw sequence do it all...done


add some debug options..done

C on gate to complete level
F2 for super fast mode
demo mode alway saves level data
C to switch from demo playback to recording

I think I can make all these part of mwDemoMode

   int demo_debug_complete_level_on_gate_with_fire;
   int demo_debug_running_demo_saves_level_data;
   int demo_debug_convert_playback_to_record_with_fire;
   int demo_debug_super_fast_mode_F2;
all done








make the reload icons faster, if possible
what if I just included fullsize bitmaps for every level with the release

how much would that take?

more importantly, would it make anything faster?
ezpecially on slow machines


separate all icons from the ones needed for vls and see if that is any faster

I think that is already done




I just made a bitmap 20,000 x 20,000 pixels big!
I had to make it a memory bitmap...
saved as a bmp it is 1.17G
actual size disk 1,200,000,054 bytes






It has 100 levels in full resolution


400,000,000 pixels


12/4 = 3 bytes per pixel





I am going to try changing the compression ratio of levels

right now I am using -1 (auto)

I have 142 files with a total size of 406,922



level 1 should be the fastest
size 715,218

level 0 is none
size 54,155,675


did level viewer compare all on m36 with cmp level 1...36s
went back to the default -1 and tested, still 36 seconds
i don't think that is the bottleneck, at least not on m36

loading level icons is vey slow on 4230

it is not slow once they are loaded though
also they are only needed for classic mode!!

I could just ignore them unless they are needed, like when vls is run

or i could use the 100 or 200 icons

those also take a while to generate, I could include them
12M and 3M

how about this?
include the 100 and 200

add a button to regnerate them in settings, also if they are missing, regen them

do not include vls icons, only generate if vls is called


it would be so nice to have more than one slot where a loaded level could reside


I could use one for displaying a level, like while on a gate

I could use one for the paused game in progress

I could use one for the overworld


what kind of sizes are we talking about here?


less than 500K each















right now....


make vls only load on demand
new release, choose classic, then start vls


show vls tile size



I separated vls from the other ones

now regular ones are loaded when?



This is the final simple way that level icons are handled:
----------------------------------------------------------
mwLevel::load_level_icons()

called when:

- mwLevel::setup_data(void)...called from initial setup
- when bitmaps are rebuilt
- at the end of create_level_icons


mwLevel::create_level_icons()
- called in load_level_icons() when the files are not found

If you want them rebuilt, just delete them.
I could easily include these 2 files with a release to speed things up, they are only 12M and 3M



Now what about vls?

put all the data and functions back in vls

ALLEGRO_BITMAP * level_icon_vls[100];
int level_icon_size;
void create_level_icons_vls(void);
void load_level_icons_vls(void);

level_icon_size is saved in config

void create_level_icons_vls(void);
- is called:





This is the way that vls level icons are handled:
-------------------------------------------------

vls called:
int mwVisualLevel::visual_level_select(void)

first checks if vls_loaded:
if (!load_visual_level_select_done) load_visual_level_select();

things that reset 'load_visual_level_select_done'
- rebuild bitmaps
- cycle display transform
- change max level in settings


void mwVisualLevel::load_visual_level_select(void)
{
   load_visual_level_select_done = 1;

   if (grid_size != level_icon_size)
   {
      level_icon_size = grid_size;
      create_level_icons_vls();
   }
   load_level_icons_vls();

void mwVisualLevel::create_level_icons_vls();
- called from load_visual_level_select(void)
- called is not found when running load

void mwVisualLevel::load_level_icons_vls(void)
- called from load_visual_level_select(void)
- called at the end of create_level_icons_vls();








release has no splash screen??
not till you switch to classic mode..weird
made it common in menu....



make default window size on release a fraction of the full screen size, if possible
when I am doing that, I don';t think I have access to that yet...

this is what I do now:

   agci(SCREEN, mDisplay.disp_x_wind, 100)
   agci(SCREEN, mDisplay.disp_y_wind, 100)
   agci(SCREEN, mDisplay.disp_w_wind, 800)
   agci(SCREEN, mDisplay.disp_h_wind, 600)

I am thinking of going with 768 as the min h

lets try 1024x768
this does dtd 2 on auto and the settings are too short

actually a minimum of 400x400 is needed to see the entire settings pages

what happens if you put a huge value for window size?

this is how I left it

   agci(SCREEN, mDisplay.disp_x_wind, 200)
   agci(SCREEN, mDisplay.disp_y_wind, 40)
   agci(SCREEN, mDisplay.disp_w_wind, 1280)
   agci(SCREEN, mDisplay.disp_h_wind, 1024)




edit the release scripts to leave level_icon_bmp_100 and 200..done




release demo plays then back to menu with overworld map, but level icons are blank
gates are not drawn, but why?

when I do the exact same thing in classic mode they are...

classic

transition from menu to nothing
demo rnd - pass:1 index:5 level:7  lf:1948
---------  State change from 12 to 31  --------  31 12  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 31 - Setup Demo Level]  [lev:7]  [drm:21]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
---------  State change from 11 to 32  --------  32 11 31 12  1  0  0  0  --------  [  34]  --------   [qa:1] [da:5]
[State 32 - Quit and Cleanup Demo Mode]  [drm:21]  [m:2]
transition from game to nothing
transition from nothing to menu
---------  State change from 32 to  1  --------   1 32 11 31 12  1  0  0  --------  [  34]  --------   [qa:99] [da:5]
[State 1 - Game Menu] - quit_action:99


Demo mode started from menu

pre-load transition:menu to nothing
post-load transition:none

transition from menu to nothing
demo rnd - pass:1 index:68 level:90  lf:4508
---------  State change from 12 to 31  --------  31 12  1  3  1 32 11 31  --------  [  34]  --------   [qa:1] [da:5]
[State 31 - Setup Demo Level]  [lev:90]  [drm:21]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12  1  3  1 32 11  --------  [   0]  --------   [qa:1] [da:5]
---------  State change from 11 to 32  --------  32 11 31 12  1  3  1 32  --------  [  52]  --------   [qa:1] [da:5]
[State 32 - Quit and Cleanup Demo Mode]  [drm:21]  [m:2]
transition from game to nothing
transition from nothing to menu
---------  State change from 32 to  1  --------   1 32 11 31 12  1  3  1  --------  [  52]  --------   [qa:99] [da:5]
[State 1 - Game Menu] - quit_action:99
---------  State change from  1 to  0  --------   0  1 32 11 31 12  1  3  --------  [  52]  --------   [qa:0] [da:5]



from menu to nothing
demo rnd - pass:1 index:25 level:27  lf:3602
---------  State change from 12 to 31  --------  31 12  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 31 - Setup Demo Level]  [lev:27]  [drm:21]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
---------  State change from 11 to 32  --------  32 11 31 12  1  0  0  0  --------  [  61]  --------   [qa:1] [da:5]
[State 32 - Quit and Cleanup Demo Mode]  [drm:21]  [m:2]
transition from game to nothing
[State 32 - Restore Level:1
transition from nothing to menu
---------  State change from 32 to  1  --------   1 32 11 31 12  1  0  0  --------  [  61]  --------   [qa:99] [da:5]
[State 1 - Game Menu] - quit_action:99



needed to call mLevel.set_start_level();
at the start of story menu, just like I do at the start of classic menu


do I even need to show the overworld map menu on story mode menu?
remove the title 'Overworld', but keep the map, looks empty without it




make sound stop at start of transitions
like when?



demo mode cancel..done



I also see that cpu graph is expensive
it draws directly on the screen, good
but it completely redraw its self every frame
I am thinking of using a temporary bitmap..
every frame just slide it all down 1 pixel and draw the new column
autorange would be affected



20230707 friday

getting very close to finishing now..

the level_icon bitmap thing works good at start

just humor me and test 4230 with levels set to cmp 1
right now it take 17s to create_level_icon_vls
no diff...

the linux version release seems to be working well


training level 5 start behind alwys on msg msg..fixed
check for others, iwent through them all

reduce par times



linux version is not saving level data in proper folder..fixed directory seperators..done


bug - why do all levels show purple coin completed after reset all level data

because the purple coin count happened with creating level icons, do it somehwere else

all I have to do is load each level and the data will be stored automatically

I need to do this at release, or include a copy of level_data.pm

if level_data.pm does not exist recreate it....

copy all with release


make sure before doing a release you do a reset...
also that vls icons are something, lets go with 20 and save 20 in config


when doing reset on 4230 if still takes 17s

that is just the amount of time it takes to open 100 level files


could it be that the way I load does lots of other things, like init_level_background?

try doing custom, that made a dramatic difference, only a second to do all on 4230


try that with creating the icons
does not get better

I think 4230 is just slow at init_level_background


m36    - 8ms
scat   - 18ms
e6320  - 25ms
4230   - 181ms
yes, very slow...

can I do anything about it?

what if I skip drawing blank tiles?

try it...

it definitely made an improvement


create_level_icons_time:
m36   0.559549
scat  0.939
e6420 2.40
4230  6.1

do the old just to compare:
m36   1.14
scat  2.12
e6420 3.54
4230  18.85


what does it look like without the progress bar?

create_level_icons_time:
m36   0.54
scat  0.877
e6420 2.02
4230  6.08

just slightly better, not enugh that I want to keep it that way, I want the progress bar...

average time in level data should only be average of times the level was beat..done





what about the default size for vls level icons

on some smaller screens they seem way too small


it seems to be only multiples of 20, with 20 as the smallest


it might have something to do with the screen double...

I think it looks better now, test on 4230

looks good

what is my default in config? 40
but if the file does not exist, it will be recreated, right?? yes its all good


20230707 push

much is finished





cant set vineopd trigger to another vinepod automatically
newly created vinepods have a big time 120...


changed vinepods to emit event when extend is done, not when firing bullet
maybe I could make that configurable


reset all to defaults does not work in linux
i am trying to run 'del' from the shell...duh
fixed by using bool al_remove_filename(const char *path)

settings tab for transitions with some defaults
also show total time

done
and it works fine on slowest machine

trying to run a profile graph and get a hard crash...line too long?

tmst d-bkgr:[0.0091] d-lift:[0.0690] d-item:[0.7741] d-enem:[0.0822] d-esht:[0.0202] d-psht:[0.0003] d-plyr:[0.0012] d-erhd:[0.0010] d-gnfo:[0.0001] d-lsta:[0.0006] d-buff:[0.0124] d-buff:[0.0118] d-buff:[0.0030] d-ovrl:[0.0873] d-flip:[0.1037] d-totl:[1.1761]
261 char long

tested vinepod profile on slowest and it was good

level viewer is broken?? reset everythings and now it works, not sure why

moved extra levels 70-73 and 101-105 to 300+ along with demo's...done

level 9 needs cosmetic work..done






20230707 9:00PM


I am so ready for a release, all I can think that I need to finish is some minor documenation

like do a better version of history for the help files... that is all..

wow!!

that is all!!!

After I release I will need to redo so much of the videos....

re-arranged the stats message thing on overworld level



what version should I call it?

stick with 7.24 and just increment the number after that?

yes, I think so...

7.24.237


20230710 6:00AM

moved purple coins and npc draw screen direct out of overaly and into draw seq

on training level 2 I notice the hiders are not working nicely..
If I die in area 1, it dissapears until i respawn
If I skip the purple coins in area 1 it is the only thing that shows when I move to area 2
I think I need to remove hiders...done...
what other levels do hiders look stupid?
removed on level 83
7 good
8 good
9 good
11 good
12 good
21 good
22 good
83 good
84 good




settings page for messages goes off bottom when not advanced..fixed


I would like to make settings pages all have the same height, then they would look nicer

what do I have now? 355 full 342 with advanced

I want to make a guaranteed height of each page, then make the entire thing bigger if the tab section gets bigger




I think I have too many poorly named and defined variables,

I want to make:
page_x1
page_x2
page_w
page_y1
page_y2
page_h

these will be used for all pages drawing

then there will be the section above the pages
tab_x1
tab_x2
tab_w
tab_y1
tab_y2
tab_h

these actually have all the x1, x2 and w in common
and they never change, so I should calculate them once at the start
they are already named:

      // set width and x positions
      int cf_w = 400;
      int cf_x1 = (mDisplay.SCREEN_W - cf_w)/2;
      int cf_x2 = cf_x1 + cf_w;

      // set page x size, this has to go before the tab size
      int cfp_x1 = cf_x1 + frame_width;
      int cfp_x2 = cf_x2 - frame_width;
      int cfp_txc = cfp_x1 + (cfp_x2 - cfp_x1) / 2;


OK now I just need to work on the y's and h's



I will make the page h fixed: 360
page_h = 360


then I need to calculate the h for the tab section



this is done...the pages all have a fixed height.



20230721 add game mode to main page and remove that tab entirely...done

add buttons to jump to message and demo page...done


now on to viewport


viewport

make the up and down auto scroll optional and set amount
make the left and right auto scroll optional and set amount

make a scroll option for riding rocket that scrolls in the direction you are moving..
that seems to work..

make all three of these individually customizable


do I still need viewport mode?
0 = force center always (except edges)

1 = not zero
2 gradual, not used anymore


what about when falling?, jumping


these are the variable I have now:

            mDisplay.viewport_mode = 1;
            mDisplay.viewport_show_hyst = 0;
            mDisplay.viewport_x_div = 0.33;
            mDisplay.viewport_y_div = 0.33;

I will keep mode I guess, but it only is bool
0 forces center only


these are new variables


   int auto_up_down_with_controls = 1;
   int auto_left_right_with_controls = 1;
   int auto_rocket_direction = 1;


mDisplay.viewport_up_down_with_controls
mDisplay.viewport_left_right_with_controls
mDisplay.viewport_rocket_direction

they can be on or off
or should I do an amount?

the left right...controls or just facing that direction?

seperated facing driection to its own

experimented with controls for left and right but just adding did not look right.
using the same method I used for rocket seems to work nicely
         if (auto_left_right_with_controls)
         {
            mDisplay.level_display_region_x += mPlayer.syn[p].xinc * 2;


I wonder if this could just be a generic solution for any player motion...


make a test level...



it looks like it is working good exepct that when I am rifing a lift the players xinc and yinc are not set...
I though I did that for bullet stuff...

i guess i didn't:

   // this is here so that motion due to riding lifts is also used for shot tracking
   if (mPlayer.syn[p].player_ride) // if player is riding lift
   {
      int d = mPlayer.syn[p].player_ride - 32; // lift number
      pvx += mLift.cur[d].xinc;
      pvy += mLift.cur[d].yinc;
   }


took that into account....


what wouod happen if I just applied that, like I do with rockets?

what is the move order?

   mShot.move_eshots();
   mShot.move_pshots();
   mLift.move_lifts(0);
   mPlayer.move_players();
   mEnemy.move_enemies();
   mItem.move_items();


lifts move, then players align to lifts



I am trying to figure out why lifts seem to jump around when player is riding them
I print to console in draw player the y positions of lift and player and they are always 20.00 apart

actually it looks the same with the rockets and items that the player is carrying

I also looks the same when I use the old original draw method for player

what is going on?, it would look so nice if this was not the case...
I might have to do with drawing on the level buffer and that is only exact pixels....
how hard would it be to draw lifts direct like all the other objects?
do you think that would solve it?
lifts are different in that they draw with primitives

I do not want to fix this...
I do not have the time


I broke almost all of my demo levels...damn!
what did I gain?..
striaghtened out the player xy move code..but still the lifts shake...

when lift has any h movement player walk animation is static..fixed

am I ready to button all of this up?


should I make a test level...

advance lift test level for all lines of code....

as soon as you are caputered by a lift set y inc to zero


what is my maximum lift speed if I plan to ride the lift? 30?


sometimes I fall through with 30



i:42

Running Global Level Test
l:  2 s: 29
l:  2 s: 29
l:  4 s: 29
l:  4 s: 29
l:  4 s: 29
l: 10 s: 29
l: 10 s: 29
l: 10 s: 29
l: 10 s: 29
l: 10 s: 29
l: 10 s: 29
l: 15 s: 50
l: 15 s:300
l: 15 s: 50
l: 15 s:120
l: 15 s: 72
l: 15 s: 40
l: 15 s: 40
l: 15 s: 80
l: 16 s: 29
l: 16 s: 29
l: 16 s: 29
l: 16 s: 29
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 17 s: 26
l: 19 s: 29
l: 19 s: 29
l: 19 s: 29
l: 19 s: 29
l: 19 s: 29
l: 19 s: 29
l: 20 s: 29
l: 20 s: 40
l: 21 s: 22
l: 21 s: 22
l: 21 s: 24
l: 21 s: 24
l: 21 s: 26
l: 21 s: 26
l: 23 s: 29
l: 23 s: 29
l: 23 s: 29
l: 23 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 24 s: 29
l: 33 s: 29
l: 33 s: 29
l: 33 s: 29
l: 33 s: 29
l: 33 s: 26
l: 34 s: 30
l: 34 s: 32
l: 35 s: 29
l: 35 s: 29
l: 41 s: 29
l: 41 s: 29
l: 41 s: 29
l: 44 s: 29
l: 44 s: 29
l: 44 s: 29
l: 44 s: 29
l: 45 s: 29
l: 49 s: 29
l: 49 s: 29
l: 49 s: 29
l: 49 s: 29
l: 49 s: 29
l: 49 s: 29
l: 49 s: 26
l: 49 s: 26
l: 51 s: 29
l: 51 s: 25
l: 51 s: 29
l: 51 s: 29
l: 53 s: 29
l: 53 s: 29
l: 53 s: 28
l: 53 s: 29
l: 55 s: 29
l: 55 s: 29
l: 55 s: 29
l: 70 s: 30
l: 70 s: 30
l: 70 s: 30
l: 70 s: 30
l: 70 s: 40
l: 70 s: 40
l: 70 s: 40
l: 70 s: 40
l: 98 s: 30
l: 98 s: 30
l: 98 s: 40
l: 98 s: 40


I think I can say that 29 is the max and don't try to exceed that, if you want to ride...

when jumping and hitting lift from below, sometimes pushed through floor...fixed


made a test level and lifts and players seem to play nicely now...

is there anything else I can test?


now back to why things look dumb when lifts are moving..

you know, it is never straight vertical or horizontal, only diagonal looks choppy...test that...

when riding diagonal only..

what about weird speeds? yes that does it on stright ones also...

up and down are perfectly smooth? yes, it is only right and left...

now we might be getting somewhere...


the way y works is it is always clamped to -20 from lift y

x does not work that way, it just syncs the xincs...


what if I saved the x offset relative to the lift?

save it in the player struct, only change when left and right change it

that is just crazy enough to work

but wait, it is aleady excatly the same as lift and the drawing is bad....

try it anyway..

added float player_ride_x_offset;
and removed one spare int


now when player_ride is set, set the offset also

did this and guess what, it still is bad....


now what? give up finally and move on...

wait a tick!

could it be that I am setting the viewport based on the players position then drawing the players?
looked at that and dont think it applies

could it have something to do with the viewport scroll?
if there is no scroll does it still happen?

how to test?

made the viewport .9 .9 and zoomed in when riding lift, still seems jumpy

MOVE ON!!
put it all back together
was anything changed in lifts?..done


I think it is all put back...

now make viewport settings work

the auto scrolling seems rather abrupt, it almost makes me queasy
try to do some gradual accelerated scrolling


I need some variables


after all that I still do not like the automatic scrolling

it is disorienting and makes me dizzy


too bad...

can I make it better?


I hate it less now...

make all these things customizable


I like the left and right things

my max left and right while while running is 4 pix

left and right is soley based on pvx


acceleration with pvx
float im = 0.02;
mDisplay.level_display_region_xinc += pvx * im;

decay with no pvx
if (pvx == 0) mDisplay.level_display_region_xinc *= 0.8; // decay when not moving

// max viewport speed
float mxi = 5;
if (mDisplay.level_display_region_xinc > mxi) mDisplay.level_display_region_xinc = mxi;
if (mDisplay.level_display_region_xinc < -mxi) mDisplay.level_display_region_xinc = -mxi;




after all of that, I played in static mode and liked it


how am I going to present all of these options in settings...

toggle static...

what should I call it?

centered,
static,
viewport disabled?

what variable should I use:

bool viewport_hyst_enabled;


I also want to move all of the viewport variables to mScreen from mDisplay

done...



why dont I just leave viewport mode?

0 static
1 everything else...


ok that is done but not pretty in settings..

now if I am in hyst mode what is optional?

if nothing else is selected the hyst will move when player hits edges
this is not optional, this must always happen


viewport_look_up_down
if enabled the keys up and down move the viewport

viewport_look_player_facing_left_right
if enabled the viewport scrolls in the driection the player is facing (left or right)

viewport_look_player_motion

viewport_look_rocket


I think I have the viewport stuff figured out...


now I need to fix all my demo's!!!!


damn!

why the fuck did I do that?
how do I want to do this?

2 done
3
6 done



I just found a bug in the player code...


when jumping up and hitting block, but trying to get into single opening beside it....it is hard..fixed

i had to redo demos again!!! DAMN

2-12 done and 14



I just found out I cannot let go of rope by pressing down...wtf
added 1 to y when pressing down to drop rope..fixed


now I have 2-14 done
test that they are not screwed up
looks good

do training levels
80-84 9, 25, 37 done

area 1 done

time for a push

lots of levels still left to go...

all levels have been done


lets see if I can beat the record of 7:27 for amazing...


will bombs destroy the vinepod circle?

actually i did 31 beginnings
same at 5:14??


do 23, reduced from 7:57 to 5:58


reduce part times:

15 smash is not a fun level
added a bit more



make sproingies higher in overworld done



show official time at end of level press any thing


added level_done_frame to player syn struct
now show official time only on player that completed
this works but I don't like how it looks...

how about if we are in level done mode, make the top frame time freeze and show the completed time.....

that seems to work...
this assumes that exit is the thing that counts when level is done...this shouls always be the case except for level 64?



made it so that level complete uses the time from player struct..



now I want to thin the number of calls to
void mwLevel::level_complete_data(int type, int lev)

it should be common to exit and 64

i would like to call it from level done mode..



normal (exit)
ldm 9 to 1

how does demo do it?
the same?

it looks like it does

so patch it in in mode 9..done


now it is called:
not exit or orb...

debug C pressed on gate
mode 30
mode 9


now lets see if it works...

also test purple coins and exit at the same time, i think that works now...

bug - sometimes getting purple coin and exit at the same time show coin at end of level but not on stats...fixed




bug, now that some objects are drawn directly to screen, they are sometime invisible when draw just the level...

example:
purple coins only show when game is running
players also

bug - vinepod on overworld shows when it should be hidden
basically everything that draws direct to screen is not hidden with hiders
the only things I notice are the vinepods on overworld
I do not have too many hiders...
What can I do to fix this?


bug - purple coins to show when drawing level...

// this seems to work better
if ((item[i][6] == 3) && (mLoop.state[0] == 11) && (mLoop.frame_num > 0)  ) // purple coin custom draw only when game running

can I do the same for player?

I have the old drawing method if not state 11...seems to work


now vinepods...
currently the shape draws but not the vine

I am going to revert to the old vinepod drawing...reasons:
- the new one is no faster
- the new one draws so clean it looks out of place
- the new one is more complicated
- the new cannot be hidden by hiders



I think that these are all fixed now...what about crew?
crew and player disappears when rocket takes off
come back when zooming in
I think I am doing it the hard way...

now the final cutscene looks better

I think all of this is done now...


save the original zoom and restore it after cutscene..done

also do not restore zoom with transitions..done



bug - when setting triggers for lifts step, item line is not set properly
make test level 63
could not reproduce:
created lift with wait event step
created trigger, timer and orb
from lift step set trigger and can choose any input and line looks good...

created a second lift and it does not work like it should



int mwTriggerEvent::get_trigger_item(int obj_type, int obj_num, int obj_ext, int& ti_obj_type, int& ti_obj_num, int& ti_obj_ext)
what does this want?







   if (obj_type == 4) // lift
   {
      int ti_obj_type, ti_obj_ext, ti_num;
      if (mTriggerEvent.get_trigger_item(4, obj_num, 0, ti_obj_type, ti_num, ti_obj_ext))
      {





this is called by all the items and enemies, but not lifts??



find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)

called by:

     if (mWidget.buttont(xa, ya, xb, bts,  0,0,0,0,   0,c1,15,0,  1,0,1,d, "Set Trigger")) mTriggerEvent.find_event_sender_for_obj(4, l, s, 0);

good so far...

next...


find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)

   if (obj_type == 4) // lift
   {
      int ti_obj_type, ti_obj_ext, ti_num;
      if (mTriggerEvent.get_trigger_item(4, obj_num, 0, ti_obj_type, ti_num, ti_obj_ext))
      {
         int ev = mTriggerEvent.get_unused_pm_event();

         mLift.stp[obj_num][obj_ext].val = ev; // set event number in receiver

         // set event num in sender
         set_event_num_in_sender(ti_obj_type, ti_num, ti_obj_ext, 1, ev);

      }

   }

why am i passing 0

      if (mTriggerEvent.get_trigger_item(4, obj_num, 0, ti_obj_type, ti_num, ti_obj_ext))

looking at it I also have them reversed


int mwTriggerEvent::get_trigger_item(int obj_type, int obj_num, int obj_ext, int& ti_obj_type, int& ti_obj_num, int& ti_obj_ext)
/*
   prompts to select an object that has an event sender

   passed the object that we want to link to (the receiver) int obj_type, int obj_num, int obj_ext
   currently works for items (orb, trigger, timer) enemies (cloner and vinepod) and lift step type 5

   currently only looks for items (orb, trigger, timer 1 and 2)

   want to make work for list step type 6 also
*/

{
   while (mInput.mouse_b[1][0]) mEventQueue.proc(1); // wait for release
   mScreen.init_level_background();
   int tx = mDisplay.SCREEN_W/2;

   int quit=0;
   int mouse_on_item = 0;

   int x2=0, y2=0, itx=0, ity=0;


   // get object position for display
   if (obj_type == 2) // item
   {
      x2 = mItem.item[obj_num][4]+10;
      y2 = mItem.item[obj_num][5]+10;
   }

   if (obj_type == 3) // enemy
   {
      x2 = mEnemy.Ef[obj_num][0]+10;
      y2 = mEnemy.Ef[obj_num][1]+10;
   }

   if (obj_type == 4) // lift
   {
      int l = obj_ext;
      int s = obj_num;
      x2 = mLift.stp[l][s].x + mLift.stp[l][s].w / 2;
      y2 = mLift.stp[l][s].y + mLift.stp[l][s].h / 2;
//      int pms = mLift.find_previous_move_step(l, s);
//      x2 = mLift.stp[l][pms].x + mLift.stp[l][pms].w / 2;
//      y2 = mLift.stp[l][pms].y + mLift.stp[l][pms].h / 2;
   }


   fix this...

fixed:

find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)
   if (obj_type == 4) // lift
   {
      int ti_obj_type, ti_obj_ext, ti_num;
      if (mTriggerEvent.get_trigger_item(4, obj_num, 0, ti_obj_type, ti_num, ti_obj_ext))

to:

      if (mTriggerEvent.get_trigger_item(4, obj_num, obj_ext, ti_obj_type, ti_num, ti_obj_ext))

and:

int mwTriggerEvent::get_trigger_item(int obj_type, int obj_num, int obj_ext, int& ti_obj_type, int& ti_obj_num, int& ti_obj_ext)
   if (obj_type == 4) // lift
   {
      int l = obj_ext;
      int s = obj_num;
      x2 = mLift.stp[l][s].x + mLift.stp[l][s].w / 2;
      y2 = mLift.stp[l][s].y + mLift.stp[l][s].h / 2;
//      int pms = mLift.find_previous_move_step(l, s);
//      x2 = mLift.stp[l][pms].x + mLift.stp[l][pms].w / 2;
//      y2 = mLift.stp[l][pms].y + mLift.stp[l][pms].h / 2;
   }

to:
      int l = obj_num;
      int s = obj_ext;
      x2 = mLift.stp[l][s].x + mLift.stp[l][s].w / 2;
      y2 = mLift.stp[l][s].y + mLift.stp[l][s].h / 2;
      int pms = mLift.find_previous_move_step(l, s);
      x2 = mLift.stp[l][pms].x + mLift.stp[l][pms].w / 2;
      y2 = mLift.stp[l][pms].y + mLift.stp[l][pms].h / 2;
   }

now this works like I think is should


test if I can also use lift sender as source...

that seems to work also...



level editor vinepod triggers are not on the list of things that can auto set

tested:
created vinepod
linked to it from lift...worked good...

linked vinepod to trigger input and that worked good also..
what does not work?
maybe it just seems to not work because you have to mouse over the extended position..


also bug with green line showing path, only in level editor and and only if path shown and only when viewer active..fixed
it was a weird bug with target bitmap...



can I make cannons show the rotation where the bullet will be fired?
right now they just aim at the player...

added to cannon
Ei[][10]  targetted player (-1) if none
set this in move...
I now have the option to do that...
also vinepod uses this as well


bug when player is moving on rope bullets do not trigger motion
what about ladders also?
ladders are good..
made a change to set xinc to + or -3 depending on direction
now the tagetting works, but...
how many demos are broken?

all perfect total best time 2:34:23 same as the old one...

bug - demo for blue key fall has huge # of killed enemies / only sometimes
probably an array out if bounds, hard to fix, because it only occur occasionally...

can I print out the level data and see where the error occurs?
2031791

I never seem to get playdata with that value, just level data..


I found the culprit...

switch block range too large....


find them with glt...fix them manually

add checks in code to prevent from happening again..


should I check all 6, 7, 8, 9?


I should have some automatic repair

just set the bounds to something reasonable

switch, key, block manip, ...???

put in limits at:

mwItem::proc_switch_block_range(int i, int action)
mwItem::proc_key_block_range(int i, int action)
mwItem::bomb_blocks(int i, int t, int dr, float x, float y)

mwLevel::change_block(int x, int y, int block)
mwLevel::is_block_empty(int x, int y, int test_block, int test_item, int test_enemy)


what about block manip?


void mwItem::proc_block_manip(int i)
{
   int et = item[i][1]; // pm_event trigger we are looking for
   if (mTriggerEvent.event[et])
   {
      al_set_target_bitmap(mBitmap.level_background);
      int x1 = item[i][6]/20;
      int y1 = item[i][7]/20;
      int x2 = x1 + item[i][8]/20;
      int y2 = y1 + item[i][9]/20;



I have checked all keys, switches and bm, and they are all not out of bounds
and I have put checks in place...


bug - do better at testing for empty...done
int mwLevel::is_block_empty(int x, int y, int test_block, int test_item, int test_enemy)
   if (test_block) if (mLevel.l[x][y] & PM_BTILE_ALL_SOLID) mpty = 0; // if any of the solids match, it is not empty






I want something like gate info, but in classic mode for start level

Move my spinning name logo to the right side and have level data on the the left


mark out where things are

rename the variable to something better:

currently

where the level display is:

mLogo.menu_map_size
mLogo.menu_map_x
mLogo.menu_map_y

mLogo.mdw_splash_logo_x
mLogo.mdw_splash_logo_y
mLogo.mdw_splash_logo_scale

mLogo.mdw_map_logo_x
mLogo.mdw_map_logo_y
mLogo.mdw_map_logo_scale

mLogo.mdw_logo_x_dec
mLogo.mdw_logo_y_dec
mLogo.mdw_logo_scale_dec



how about:

mLogo.menu_level_display_x
mLogo.menu_level_display_y
mLogo.menu_level_display_size

mLogo.splash_x
mLogo.splash_y
mLogo.splash_scale

mLogo.menu_x
mLogo.menu_y
mLogo.menu_scale

mLogo.menu_x_dec
mLogo.menu_y_dec
mLogo.menu_scale_dec


where is the menu position?

also frame and title draws line of players on each side

I want to keep track of all of these element and have their variables somehwere common



All the drawing is done in zmenu.

zmenu is passed y

zmenu ias called onlt twice and alway with y = 10;
then at the start of zmenu y+=4;

remove the passing and force to 14...later, save that somehwere

then in zmenu, these are called...

      mScreen.frame_and_title(1);
      mLogo.mdw_an(mLogo.mdw_map_logo_x, mLogo.mdw_map_logo_y, mLogo.mdw_map_logo_scale);
      mScreen.draw_level_map_under_menu();

separate the draw line of players to its own function

now I have:

      mScreen.frame_and_title();
      mScreen.draw_line_of_players();
      mLogo.mdw_an(mLogo.mdw_map_logo_x, mLogo.mdw_map_logo_y, mLogo.mdw_map_logo_scale);
      mScreen.draw_level_map_under_menu();


where would be a logical place to store all these screen positions

Logo
Menu
Screem
Display

??




while I am at it, what is the deal with Display and Screen?

what logical separtion do those have?

Display was mostly about the allegro functions to set up the display
670 lines

Screen was more about the actual drawing on that screen
900 lines

ScreenOverlay
1200 lines


what about one class but different source files

I kind of want all the variables related to the display and positions on the display in one common class...


what if Display just has the allegro functions the ortho doubling functions and functions to change display size

then screen has its own size that it gets from display

that is kind of how it is now

so then the logical place for the logo and menu and level icon x, y, size is in screen....





yes, i think so...

what names?

// the size and position of the level display under then menu
mScreen.menu_level_display_x
mScreen.menu_level_display_y
mScreen.menu_level_display_size


// the scale and position of the spinning logo beside the menu
mScreen.menu_logo_x
mScreen.menu_logo_y
mScreen.menu_logo_scale

// the scale and position of the spinning logo in full screen splash mode
mScreen.splash_logo_x
mScreen.splash_logo_y
mScreen.splash_logo_scale

// the decrement to link full screen splash mode to menu logo
mScreen.splash_logo_x_dec
mScreen.splash_logo_y_dec
mScreen.splash_logo_scale_dec

// the position of the menu
mScreen.menu_x
mScreen.menu_y



//-------------------------------------

ok lets do some search and replace:

old:
mLogo.menu_map_x
mLogo.menu_map_y
mLogo.menu_map_size

new:
mScreen.menu_level_display_x
mScreen.menu_level_display_y
mScreen.menu_level_display_size


mLogo.menu_map_x mScreen.menu_level_display_x
mLogo.menu_map_y mScreen.menu_level_display_y
mLogo.menu_map_size mScreen.menu_level_display_size

done and removed from Logo..
also removed all mScreen.prefixes where not necessary


next...

old:
mLogo.mdw_map_logo_x
mLogo.mdw_map_logo_y
mLogo.mdw_map_logo_scale

new:
// the scale and position of the spinning logo beside the menu
mScreen.menu_logo_x
mScreen.menu_logo_y
mScreen.menu_logo_scale

mLogo.mdw_map_logo_x mScreen.menu_logo_x
mLogo.mdw_map_logo_y mScreen.menu_logo_y
mLogo.mdw_map_logo_scale mScreen.menu_logo_scale

done and removed from Logo..
also removed all mScreen.prefixes where not necessary


next...

old:
mLogo.mdw_splash_logo_x
mLogo.mdw_splash_logo_y
mLogo.mdw_splash_logo_scale

// the scale and position of the spinning logo in full screen splash mode
mScreen.splash_logo_x
mScreen.splash_logo_y
mScreen.splash_logo_scale

mLogo.mdw_splash_logo_scale mScreen.splash_logo_scale
mLogo.mdw_splash_logo_x mScreen.splash_logo_x
mLogo.mdw_splash_logo_y mScreen.splash_logo_y

done and removed from Logo..
also removed all mScreen.prefixes where not necessary


next...


mLogo.mdw_logo_x_dec
mLogo.mdw_logo_y_dec
mLogo.mdw_logo_scale_dec

// the decrement to link full screen splash mode to menu logo
mScreen.splash_logo_x_dec
mScreen.splash_logo_y_dec
mScreen.splash_logo_scale_dec



mLogo.mdw_logo_x_dec mScreen.splash_logo_x_dec
done and removed from Logo..
also removed all mScreen.prefixes where not necessary

all that is left is:

// the position and size of the menu
mScreen.menu_x
mScreen.menu_y
mScreen.menu_w
mScreen.menu_h

done..

now look at the line of players

The largest one is pretty much the same height as the menu

change the goddamn zmenu to not have 2 blank spaces at the top
done...


I am trying to figure out why sometimes when I draw tiles, I get a line at the top
like an artifact from the adjacent tile...


tried
ALLEGRO_MIN_LINEAR | ALLEGRO_MAG_LINEAR
but they made the bitmaps fuzzy and they still had the lines

I am looking at:
ALLEGRO_BITMAP_WRAP
but it looks like it is only for version 5.2.8

in windows I am using 5.2.7.1

i don't know hat version I have for linux...

how do I get the latest version?

downloaded the latest version

rebuilt all, but will not run on my pc..

I have gcc version 8.3.0

luckily I was able to go back to 5.2.7.1


fuck it, I don't want to mess with this...





I want something like gate info, but in classic mode for start level

Move my spinning name logo to the right side and have level data on the the left

mark out where things are

Now start making some text display for the current level


Do not display any level stats for level 1 (overworld)


What about the title over the level icon?

Could I just put the name there?

in story mode show no title and no stats...done


find the minimun width of level info

23 char? lets do 25...25*8 = 200;





new sizing algorithm

level_display is no longer centered

lose logo for now...




level_display y and level info y are the same and are directly under the menu

info w is always fixed at 200

added outline around level and now it looks great..

center the level number and name

outline the info area

rearrange items

add stuff like enemy counts. etc...



why don't I just add all these extra fields to level_data??


this is how it is redone

struct level_data
{
   char level_name[200];

   int status;

   int min_respawns;
   int max_purple_coins_collected;
   int tot_purple_coins;
   int min_enemies_left;
   int min_enemies_left_par;
   int max_enemies_killed;

   int times_played;
   int times_beat;
   int times_quit;

   int time_par;
   int time_best;
   int time_worst;
   int time_average;
   int time_total;


this will break a lot of shit!!!

but when all is done it will be better...


make a function that you pass status to and get text and color....

void mwLevel::get_status_text_and_color(int status, int& col, char txt[])
{
   if (status == 0) { sprintf(txt, "Locked");   col = 10; } // red
   if (status == 1) { sprintf(txt, "Ready");    col = 13; } // lt blue
   if (status == 2) { sprintf(txt, "Complete"); col = 12; } // dk blue
   if (status == 3) { sprintf(txt, "Perfect!"); col = 8;  } // purple
}

make a fucntion that calculates all of these fields



I have it all in place and am chasing down bugs...

story mode
erase level data

level_stats display should be lock, unlock, ready but is blank...fixed


when completing first level, shows perfect, but no time recorded...



I want to make a clear distinction...

only level_done and level_abort create play_data entries

then they call calc and that does the rest, including achievements

make it so, then debug...



level complete good

level perfect does not show time


got that working...

now unlocking next level??

I have no idea why it does not work as intended..

calc is called first

I think I have this cleaned up...look harder...

looking good...


add the level name to vls..done



re-did the project organization html page

now all html pages should be up to date

index??

how many levels?

41 main levels
12 extra
8 trainer
1 overworld
2 muliplayer bomb toss
14 advanced demo

over 70..



I am agonizing where the put the spining logo..

beside or under info is not looking good...

how about replacing rhs large player in line of players?

I like how that looks

in story mode, center the level


make it so that level info does not go past bottom of screen
why does outline of level and info dissapear in some sizes?
raise level to match space above menu
done





I want to make the perfect calculation need to have both time and coins in the same run

how does it work now?



make a new status, 4

3 is both achievements done
4 is both done in the same level...

or just modify 3 so that only both at once count
but now the time can be way less than par, beacuse all coins are not collected
should I have 2 times, best and best with all coins?

or should I modify best time to only count if all coins are collected


stage 1 beat level
stage 2 beat level with all coins
stage 3 beat level with all coins < par time

beating level less than par time without all coins collected does not save best time

OK I thinks I have all that figured out_func
now I have 2 times:
overall and all_coins
only all coins counts towards perfect


icon timer fix..done

now I need to fix level stats...
I might need to add a new column...

done

I would also like to modify the area unlocking
when an area is unlocked, unlock all levels in the area
then when 3 of 5 are complete, unlock the next area









level editor is started with:

in menu

mLevel.set_start_level(mWM.mW[1].edit_menu(mLevel.start_level));

in args: twice
mLevel.set_start_level(mWM.mW[1].edit_menu(mLevel.start_level));


this calls:

int mwWindow::edit_menu(int edit_level)
{
   mWM.loop(edit_level);

   return mLevel.last_level_loaded;
}

which calls:

void mwWindowManager::loop(int edit_level)
{
   mLoop.level_editor_running = 1;
   al_show_mouse_cursor(mDisplay.display);
   initialize(edit_level);
   if (mLoop.autosave_level_editor_state) load_mW();
   active = 1;

   mW[5].ge_init_data();

   while (active)
   {
      redraw_level_editor_background();
      if (!cycle_windows(0)) process_mouse();
      process_keypress();
   }

   if (mLoop.autosave_level_editor_state) save_mW();
   mLoop.level_editor_running = 0;
   mLevel.resume_allowed = 0;
   al_hide_mouse_cursor(mDisplay.display);
}

why do I not skip the first call to edit_menu?

done....



see if I can find out why I get artifacts on drawing tiles in some scales

try to get the newest version of allgero and the newest version of gcc

what version is that?

look for notes in pm_docs/dev_setup/

success, I have gcc 12.1 and aleegro version 5.2.8.1


now what was that option??

ALLEGRO_BITMAP_WRAP

I had to set unstable but finally I am testing it and it makes no difference

other things I could try...


try making the sub bitmaps actual stand alone bitmaps

try a border between tiles...

both are not that easy to try...


also what if it is actually the video bitmaps not exactly pixel perefect, try a 0.5 offset???





or....

I load them to video, then draw to M_


what if I reverse this order??

try it for player only

does not seem to have any effect



I think I am down to making a border...but first can you make an example of the bad behaviour?
what is the simplest a5 example I can make??


it kind of looks like it only happens when I am doing a orthographic transform


how hard would it be to do the actual pixel border buffer...




this is the actual one in he game that is bad

c:8 sc:3.375000 x2:643.750000 y:79.000000
c:9 sc:2.531250 x2:697.500000 y:79.000000
c:10 sc:1.898438 x2:742.812500 y:79.000000

I can reproduce it!!!
in the example, I need a scale of 3.375 and dtd of 2
and I need to draw in scaled, rotatated bitmap
no there are easier examples that dont need this





Unexpected behaviour drawing scaled sub bitmaps.

When I draw scaled sub bitmaps, sometimes I get artifacts from pixels outside the sub bitmap region.

This only happens with certain combinations of scale and position, only with video bitmaps, and happens with opengl and d3d.

I have made a small test program to demonstrate this.

Basically what I do in my game is:

- I have a bitmap file that stores tiles I use to draw.
- The tiles are 20x20s pixels and are stored in a grid with no padding.

- I load the bitmap files into an Allgro bitmap.
- I make an array of sub bitmaps from this main bitmap so that I can draw tiles from an indexed array.

This works great 99% of the time.
However, rarely, when a very specific combination of scale and position is used I get artifacts from adjacent tiles.

I have thought of a couple of ways I could fix this:
- store the tiles with padding between them
- instead of sub bitmap, create my array of bitmap by drawing onto each one individually.

I kind of want to keep doing it the way that I do it with sub bitmaps because that method greatly helps me solve another problem.

The problem of quickly restoring the video bitmaps when the display changes.

What I do is:
- When I load the tiles from files, I create a video bitmap and a memory bitmap.
- Then I make sub bitmaps from the video bitmap.
- When the display changes and the video bitmaps are lost, I simply draw the memory bitmap to the video bitmap.

This is a very fast way to restore.


So anyways, before I go down the rabbit hole of testing different solutions, I wanted to see if anyone had any insight into this.
Is this normal behavior?
Is there any simple fix that I have not considered?

I have tried ALLEGRO_MIN_LINEAR and ALLEGRO_MAG_LINEAR but did not like the fuzzy results.

I also tried the new experimental feature ALLEGRO_BITMAP_WRAP, but it did not seem to make any difference.

I can reproduce this with both opengl and d3d.

It only happens with video sub bitmaps.



Edgar says to use 1 pixel padding...I will do that...

Where?

In the source bitmap files.

What should the color of the padding be? 0,0,0,0

Am I going to draw a 1 pixel box around each tile?

Then the spacing will be:
2 pixel betwen tiles
1 pixel from the borders

each tile will be 22x22

then when I make my sub bitmaps, I'll just point at the 20x20 in the middle

How to get there?

make a function to convert tilemap.bmp


just save new:


just realized that my copy bitmap thing will break...it just deals with the entire bitmap...
edit tile attribute will not, it uses tiles...

or I could profile how long it take to copy M_ to video in one big chuck, vs how long it take to do them all seperately
maybe it doesnt take that long


new:

only make M_ full maps
draw to each tile...

when recreating, draw to each tile


new method:
restore tile array time:0.809792
restore tile array time:0.437307

old method:
restore tile array time:0.013486
restore tile array time:0.010335
restore tile array time:0.013285
restore tile array time:0.009972

it is a lot slower....

why is original method called twice?

I don't know...


anyways this new method is a lot slower, so I am going to abandon it and just pad the tilemap...


I going to draw a 1 pixel box around each tile?

Then the spacing will be:
2 pixel betwen tiles
1 pixel from the borders

each tile will be 22x22

then when I make my sub bitmaps, I'll just point at the 20x20 in the middle

How to get there?

make a function to convert tilemap.bmp




I think I hve it all done...

made new tilemaps
added offsets to creating sub bitmaps

I forgot to increase the size of my bitmaps...done

removed all testing of new restore method

OK I think I have that fixed....




work on the bash script make release to include version number..done

mkdir linux_libs/

cp /usr/lib/liballegro_monolith.so.5.2 ./linux_libs/
cp /lib/x86_64-linux-gnu/libOpenGL.so.0 ./linux_libs/

version=7.24.567

fd='purple_martians_'"$version"'_linux'


mkdir "$fd"
mkdir "$fd"/bitmaps
mkdir "$fd"
mkdir "$fd"/bitmaps
mkdir "$fd"/help
mkdir "$fd"/data
mkdir "$fd"/levels
mkdir "$fd"/linux_libs
mkdir "$fd"/logs
mkdir "$fd"/savegame
mkdir "$fd"/savegame/demo
mkdir "$fd"/screenshots
mkdir "$fd"/sel
mkdir "$fd"/snd



cp bitmaps/*       "$fd"/bitmaps
cp help/*          "$fd"/help
cp snd/*           "$fd"/snd
cp levels/level0*  "$fd"/levels
cp linux_libs/*    "$fd"/linux_libs
cp savegame/demo/* "$fd"/savegame/demo

cp data/level_icons_100.bmp "$fd"/data
cp data/level_icons_200.bmp "$fd"/data

cp pm "$fd"/
cp readme_linux "$fd"/
cp license.txt "$fd"/
cp pml "$fd"/
cp lin_install_libs "$fd"/


tar -zcvf ./"$fd".tar.gz ./"$fd"/*


bug - story mode arrow key on top menu item does weird things....fixed



bug - serial key check for IJKL work in client mode

while in game you cannot change keys
server has them...no

its because set controls to custom sets always sets player 0

while the game is running as a client, we are not using player 0

in init player we set a player not 0 to use 0 controls

later I should figure this out....

everything works, so what is there to figure out?

made it so that set_controls_to_custom_sets(
sets active local player instead of zero.
the only time this will not be zero is when a client is playing
this will work, but will not save the changes for the client
after the game they will back to defaults


bug - levels do not unlock in netgame, or at all!!!
wtf did i break? fixed...need to do next level unlocks in both strict and non


do something about strict story mode...make it work and configurable
also it needs to be the same on client and server
even more...levels unlocked need to be controlled by server
this is getting complex....!!!
I think I will just make non strict mode set in code..done


add notes to controller setup about being able to press 2 directions at once is required for game
some joysticks will not allow you to do this
done









reset all level data button takes a long time to complete in linux
it loads the level a few times
void mwLevel::reset_level_data(void)
{
   clear_data();
   save_data();
   level_stats_bmp_msg_type = 0;        // to force recreation
   load_level(mLevel.play_level, 0, 0); // reload play level
}
m36 profile:
clear data time:0.413559
save data time:0.417563

scat profile:
clear data time:6.8
save data time:6.8



m36 profile:
clear data time 1:0.006482
clear data time 2:0.007348
clear data time 3:0.008380
clear data time 4:0.369059

scat profile:
9.2 s on last one...

scat iterate levels only: 0.11
pc check, still 0.11

it is all in calc_level_stat





made it a little better...moved

   check_achievments();
   save_data();
   level_stats_bmp_msg_type = 0;


   from being called every time calc_level_stats is called.
   now called external to that function

   testing on
work laptop and time went from .9 to 0.24

test on others
m36 now 0.35 first then 0.13



lets do more stats:

purple coins only
m36 0.13
scat 0.11

just load level:
m36:
scat: 0.11

just calc_lev_stats
m36:
scat: 0.11

both:

I really don't think I need calc_lev_stats

what does it do?

and even with it enabled, it does not take that much time anymore, not that I can measure...

even on the slowest 4230 it takes 0.5s

I think it was the moving of

   check_achievments();
   save_data();
   level_stats_bmp_msg_type = 0;

out of calc_lev_stats that really made the difference
but now I don't even call calc_lev_stats in the load level loop...

its all good now, unless something else breaks....
final
m36:  0.13
scat: 0.11
4230: 0.5






in netgame make current gate set for all players when any player enters gate??
or should each player keep track of the last gate they touched?
not sure that is what is happening either...look into it later

whst if server is in story mode and client is in classic
server shoud force client to return to overworld..server controls next level

then from overworld client could choose and start level just like client player

the only issue I see is if client or server have different unlocked levels and areas

how does gate work?

   // set current overworld level for active local player
   if (p == mPlayer.active_local_player)
   {
      if (mLevel.overworld_level != lev)
      {
         mLevel.overworld_level = lev;
         mConfig.save();
      }
   }

this should have a different one for each player
it is not stored in player but in level

it is only set locally when active local player touches gate

it is saved in config!!

in set player_start_pos
   if (mLevel.play_level == 1) // hub level
   {
      for (int i=0; i<500; i++)
         if ((mItem.item[i][0] == 18) && (mItem.item[i][6] == mLevel.overworld_level)) item_to_get_start_from = i;
   }

This all should work as expected.
Any client touching a gate should have that stored locally.
And when coming back to hubworld that should be respected..
test and see if this actually happens.

it does not...


story mode 2P game

p1 sits on another gate
p0 completes level

both p end up on same gate as p0

why??

void mwPlayer::set_player_start_pos(int p, int cont)

is called on server to set player position, not on each machine

could this be fixed by puttig that variable in player sync structure??

try it, should not be too hard

   int overworld_last_touched_gate;

mPlayer.syn[0].overworld_last_touched_gate

I think I have it working

test the github 2FA..seems to be working


can I run demo from menu in classic mode
yes, but how to patch it in so it looks nice
also does it work even if level has already been beat
is is triggered from skc
menu selects 666
it does not look like anything stops it from being called, locked, beat...
how about if demo is called from classic menu, then first of all do the current level demo...
I don't really want to add another menu item...
what key interrupts demo?
made it so that could be any key, or just ESC, ENTER, SPACE


replaced demo mode in classic mode with demo current level
seems to fit in nicely...transitions could be better...
make transitions like starting game...
seems to be working now






headless server:

linux only

the ability to run from shell with no screen

./pm -sh


I would also like the ability to compile from shell..done!!

lin_compile

g++ -Wall  -c src/main.cpp -o o/src/main.o
g++ -Wall  -c src/mwBitmap.cpp -o o/src/mwBitmap.o
g++ -Wall  -c src/mwBitmapTools.cpp -o o/src/mwBitmapTools.o
g++ -Wall  -c src/mwBottomMessage.cpp -o o/src/mwBottomMessage.o
g++ -Wall  -c src/mwCodeStats.cpp -o o/src/mwCodeStats.o
g++ -Wall  -c src/mwColor.cpp -o o/src/mwColor.o
g++ -Wall  -c src/mwConfig.cpp -o o/src/mwConfig.o
g++ -Wall  -c src/mwDemoMode.cpp -o o/src/mwDemoMode.o
g++ -Wall  -c src/mwDisplay.cpp -o o/src/mwDisplay.o
g++ -Wall  -c src/mwDrawSequence.cpp -o o/src/mwDrawSequence.o
g++ -Wall  -c src/mwEnemy.cpp -o o/src/mwEnemy.o
g++ -Wall  -c src/mwEnemyArchwagon.cpp -o o/src/mwEnemyArchwagon.o
g++ -Wall  -c src/mwEnemyCannon.cpp -o o/src/mwEnemyCannon.o
g++ -Wall  -c src/mwEnemyCloner.cpp -o o/src/mwEnemyCloner.o
g++ -Wall  -c src/mwEnemyEditorFnx.cpp -o o/src/mwEnemyEditorFnx.o
g++ -Wall  -c src/mwEnemyFlapper.cpp -o o/src/mwEnemyFlapper.o
g++ -Wall  -c src/mwEnemyFnx.cpp -o o/src/mwEnemyFnx.o
g++ -Wall  -c src/mwEnemyJumpworm.cpp -o o/src/mwEnemyJumpworm.o
g++ -Wall  -c src/mwEnemyTrakbot.cpp -o o/src/mwEnemyTrakbot.o
g++ -Wall  -c src/mwEnemyVinePod.cpp -o o/src/mwEnemyVinePod.o
g++ -Wall  -c src/mwEventQueue.cpp -o o/src/mwEventQueue.o
g++ -Wall  -c src/mwFileIterator.cpp -o o/src/mwFileIterator.o
g++ -Wall  -c src/mwFont.cpp -o o/src/mwFont.o
g++ -Wall  -c src/mwGameEvent.cpp -o o/src/mwGameEvent.o
g++ -Wall  -c src/mwGameMoves.cpp -o o/src/mwGameMoves.o
g++ -Wall  -c src/mwGlobalLevelTool.cpp -o o/src/mwGlobalLevelTool.o
g++ -Wall  -c src/mwGraph.cpp -o o/src/mwGraph.o
g++ -Wall  -c src/mwHelp.cpp -o o/src/mwHelp.o
g++ -Wall  -c src/mwInput.cpp -o o/src/mwInput.o
g++ -Wall  -c src/mwItem.cpp -o o/src/mwItem.o
g++ -Wall  -c src/mwItemBombRocket.cpp -o o/src/mwItemBombRocket.o
g++ -Wall  -c src/mwItemDoor.cpp -o o/src/mwItemDoor.o
g++ -Wall  -c src/mwItemEditorFnx.cpp -o o/src/mwItemEditorFnx.o
g++ -Wall  -c src/mwItemKeySwitch.cpp -o o/src/mwItemKeySwitch.o
g++ -Wall  -c src/mwItemMessage.cpp -o o/src/mwItemMessage.o
g++ -Wall  -c src/mwItemStartExitGate.cpp -o o/src/mwItemStartExitGate.o
g++ -Wall  -c src/mwItemTrigger.cpp -o o/src/mwItemTrigger.o
g++ -Wall  -c src/mwLevel.cpp -o o/src/mwLevel.o
g++ -Wall  -c src/mwLevelData.cpp -o o/src/mwLevelData.o
g++ -Wall  -c src/mwLevelDataStats.cpp -o o/src/mwLevelDataStats.o
g++ -Wall  -c src/mwLift.cpp -o o/src/mwLift.o
g++ -Wall  -c src/mwLog.cpp -o o/src/mwLog.o
g++ -Wall  -c src/mwLogGraph.cpp -o o/src/mwLogGraph.o
g++ -Wall  -c src/mwLogo.cpp -o o/src/mwLogo.o
g++ -Wall  -c src/mwLogViewer.cpp -o o/src/mwLogViewer.o
g++ -Wall  -c src/mwLoop.cpp -o o/src/mwLoop.o
g++ -Wall  -c src/mwMain.cpp -o o/src/mwMain.o
g++ -Wall  -c src/mwMainArgs.cpp -o o/src/mwMainArgs.o
g++ -Wall  -c src/mwMenu.cpp -o o/src/mwMenu.o
g++ -Wall  -c src/mwMiscFnx.cpp -o o/src/mwMiscFnx.o
g++ -Wall  -c src/mwMulticolorLine.cpp -o o/src/mwMulticolorLine.o
g++ -Wall  -c src/mwNetgame.cpp -o o/src/mwNetgame.o
g++ -Wall  -c src/mwNetgameClient.cpp -o o/src/mwNetgameClient.o
g++ -Wall  -c src/mwNetgameServer.cpp -o o/src/mwNetgameServer.o
g++ -Wall  -c src/mwPDE.cpp -o o/src/mwPDE.o
g++ -Wall  -c src/mwPlayer.cpp -o o/src/mwPlayer.o
g++ -Wall  -c src/mwQuickGraph.cpp -o o/src/mwQuickGraph.o
g++ -Wall  -c src/mwRollingAverage.cpp -o o/src/mwRollingAverage.o
g++ -Wall  -c src/mwScreen.cpp -o o/src/mwScreen.o
g++ -Wall  -c src/mwScreenOverlay.cpp -o o/src/mwScreenOverlay.o
g++ -Wall  -c src/mwSettings.cpp -o o/src/mwSettings.o
g++ -Wall  -c src/mwShot.cpp -o o/src/mwShot.o
g++ -Wall  -c src/mwSolid.cpp -o o/src/mwSolid.o
g++ -Wall  -c src/mwSound.cpp -o o/src/mwSound.o
g++ -Wall  -c src/mwTally.cpp -o o/src/mwTally.o
g++ -Wall  -c src/mwTimeStamp.cpp -o o/src/mwTimeStamp.o
g++ -Wall  -c src/mwTriggerEvent.cpp -o o/src/mwTriggerEvent.o
g++ -Wall  -c src/mwVisualLevel.cpp -o o/src/mwVisualLevel.o
g++ -Wall  -c src/mwWidget.cpp -o o/src/mwWidget.o
g++ -Wall  -c src/mwWindow.cpp -o o/src/mwWindow.o
g++ -Wall  -c src/mwWindowEditorMain.cpp -o o/src/mwWindowEditorMain.o
g++ -Wall  -c src/mwWindowEditSelection.cpp -o o/src/mwWindowEditSelection.o
g++ -Wall  -c src/mwWindowGroupEdit.cpp -o o/src/mwWindowGroupEdit.o
g++ -Wall  -c src/mwWindowManager.cpp -o o/src/mwWindowManager.o
g++ -Wall  -c src/mwWindowObjectViewer.cpp -o o/src/mwWindowObjectViewer.o
g++ -Wall  -c src/mwWindowTileHelper.cpp -o o/src/mwWindowTileHelper.o
g++  -o pm o/src/main.o o/src/mwBitmap.o o/src/mwBitmapTools.o o/src/mwBottomMessage.o o/src/mwCodeStats.o o/src/mwColor.o o/src/mwConfig.o o/src/mwDemoMode.o o/src/mwDisplay.o o/src/mwDrawSequence.o o/src/mwEnemy.o o/src/mwEnemyArchwagon.o o/src/mwEnemyCannon.o o/src/mwEnemyCloner.o o/src/mwEnemyEditorFnx.o o/src/mwEnemyFlapper.o o/src/mwEnemyFnx.o o/src/mwEnemyJumpworm.o o/src/mwEnemyTrakbot.o o/src/mwEnemyVinePod.o o/src/mwEventQueue.o o/src/mwFileIterator.o o/src/mwFont.o o/src/mwGameEvent.o o/src/mwGameMoves.o o/src/mwGlobalLevelTool.o o/src/mwGraph.o o/src/mwHelp.o o/src/mwInput.o o/src/mwItem.o o/src/mwItemBombRocket.o o/src/mwItemDoor.o o/src/mwItemEditorFnx.o o/src/mwItemKeySwitch.o o/src/mwItemMessage.o o/src/mwItemStartExitGate.o o/src/mwItemTrigger.o o/src/mwLevel.o o/src/mwLevelData.o o/src/mwLevelDataStats.o o/src/mwLift.o o/src/mwLog.o o/src/mwLogGraph.o o/src/mwLogo.o o/src/mwLogViewer.o o/src/mwLoop.o o/src/mwMain.o o/src/mwMainArgs.o o/src/mwMenu.o o/src/mwMiscFnx.o o/src/mwMulticolorLine.o o/src/mwNetgame.o o/src/mwNetgameClient.o o/src/mwNetgameServer.o o/src/mwPDE.o o/src/mwPlayer.o o/src/mwQuickGraph.o o/src/mwRollingAverage.o o/src/mwScreen.o o/src/mwScreenOverlay.o o/src/mwSettings.o o/src/mwShot.o o/src/mwSolid.o o/src/mwSound.o o/src/mwTally.o o/src/mwTimeStamp.o o/src/mwTriggerEvent.o o/src/mwVisualLevel.o o/src/mwWidget.o o/src/mwWindow.o o/src/mwWindowEditorMain.o o/src/mwWindowEditSelection.o o/src/mwWindowGroupEdit.o o/src/mwWindowManager.o o/src/mwWindowObjectViewer.o o/src/mwWindowTileHelper.o  -lallegro_monolith -lz -lnet -lpthread -Wl,-rpath='./linux_libs'



why do I do things in this order?

get_desktop_resolution
create event queue
create display


get_desktop_resolution fails if no display
or rather sets w and h to zero

is there any reason not to move it to display code?

try it...

get_desktop_resolution has been moved from main to display

now move the call to init

actually moved all the functionality to init_display


now do something different if num_display_adapters = 0;

no display, no bitmaps...wow!

now in init_display, if no adapters found do not try to create display...works

now, can I set a variable indicating that no display has been created....

then test for it in many places



removed stuff in enemy that used animation sequence but I think I need to re-enable that...

the server needs to set that and send it out to clients, even if the server does not actually draw it...

server needs to load zz even if headless..done...

removed also bottom msg add

it runs now...


testing with windows version and display disabled

when entering gate to new level client drops but server keeps running



server unexpectedly quits...
during move frame...
items..
probably when bm removes blocks
redid that and it's fixed

now when client respawns, server borks
somewhere in move player
fixed..it was when player was finishing pause mode after respawn

switches and keys...

changed the function mLevel change block and also change bm to use that...


tested bombs, rockets, keys, switches, bm...they all work

test more


client starting level with locked gate (locked on client but unlocked on server)
client borks, but rejoining brings him back to that level...
this is not even related to no display
happens even if server has a display...


how about implementing the flag pm -sh

if no display quit, unless started with this flag...

need a variable for this...

mMain.headless_server

or can I just re-use no_display?

I think I need a new one...

I think I have that working
-sh and -sh <int>

should i try it on linux?
it works....


next...how to make that player not visible....

I can't make it inactive, but how about a new paused mode?


paused_type = 3, do not draw or process

now make it not take part in end of level stats...

I think I've got it..

make a few more shell status things for server...
like when a level is started or completed
when a player joins or quits

done

what is left to for headless server?

test...

what about the locked stuff?

test server starting level that client is locked on...
that does not kill client

how about a server locked level started by client
client freezes and is unresponsive, but does not leave netgame

server unlocked, client locked, server start -- works
server unlocked, client locked, client start -- works
server locked, client unlocked, client start -- client freezes and is unresponsive, but does not leave netgame, if server shoots client off gate, client regains control
server locked, client unlocked, server start -- can't enter


now try in headless mode:
server unlocked, client locked, client start -- works
server locked, client unlocked, client start -- client freezes and is unresponsive, but does not leave netgame, server does not change level...other clients can shoot him off

test with more clients..looks good...


I want to do some remote tests, but....

how will I administer the server, ssh only? that's ok for config stuff, but what about bigger stuff??

C:\pm>pscp -r c:\pm\src\* m@scat:Desktop/pm_client726/src


C:\pm>pscp -r c:\pm\* m@scat:Desktop/pm_client726
all 700M, less than 20s over lan

pscp -r c:\pm\src\* m@96.45.13.253:dev/pm/src



deployed pmh at work

96.45.13.253

top shows 100%, but my cpu measurement shows 3-4% with one client


is there any other way I can monitor my headless server?
I could save log files

i want my headless server to go back to overworld if no clients are connected
maybe after a timeout?

on the headless server should I make all levels unlocked?
should I have the stats reset?

On the headless server, everything should be unlocked



pscp -r c:\pm\data\level_data.pm m@96.45.13.253:dev/pm/data/level_data.pm


looking at client sync graph, it is ony available on server...doh





client disappears after first level...
actually...when client quits...they go back to overworld, but not in a netgame anymore and invisible...
server stays on level...




how do I make adjustments to netgame?


stdf freq?



Tests of netgame on a real internet connection...



late cdats...
client have a bad habit of keys getting stuck

late cdats means that client made a move that was not received in time on the server..

state freq on server 2-3 sometimes even 4


it is adjusted every second like this:

            if (mNetgame.ima_server)
            {
               // auto adjust server state frequency
               if (mPlayer.loc[0].server_state_freq_mode == 1) // 0 = manual, 1 = auto
               {
                  int mcp = mTally[4].get_max()*1000;
                  if (mcp > 100) mcp = 100;
                  mPlayer.loc[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq
               }



what is the only other adjustment?

how far the client lag behind server....

what happens with late cdat causing bad keypresses

in player input comp_move and old_comp_move are local

comp_move needs to be, can't have the server changing that

could I also set old comp_move on server and sync it back?


or another approach, how to limit late cdats

both should be looked at:




on client, if I manually change sync offset....
default: -10

0 to +10 gets me more late cdats

more negative gets me less late cdats

where is this set when done automtically?

it is based on ping

in client fast packet loop
if (mPlayer.loc[p].client_chase_offset_mode) mPlayer.loc[p].client_chase_offset = - mPlayer.loc[p].ping_avg + mPlayer.loc[p].client_chase_offset_auto_offset;


client_chase_offset_auto_offset is always set to -10 unless manually adjusted

maybe I should set the default value to -20 and see if that helps

try it...
it does not seem to do what I want in auto mode
try manual -20

I need more documentation about what netgame control do...


what is the effect and consequneces of adjusting server state frequency?

if I go too low I get base resets
1 is every frame and is too much




if I go too high the corrections will be bigger



I am thinking of showing a very busy graph of a netgame

from the server's point of view

each client and their ping and sync and late cdats

stdf and base resets

I could have the headless server send status data in a packet to another machine that would do nothing but display it



20230825 I have the linux dev setup complete and documented...

I should take the time to clean up the windows dev setup also...
It would probably involve starting from scratch on a clean win 10 install...





client controls get stuck
probably when server throws away last cdats

client will be pressing a control but it will not take effect
or control will get stuck on...

in player input comp_move and old_comp_move are local

comp_move needs to be, can't have the server changing that

could I also set old comp_move on server and sync it back?

I think I should compare clients current comp_move to actual controls instead of last_comp move



            if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
            {
               if (loc[p].fake_keypress_mode) loc[p].comp_move = rand() % 64;
               else set_comp_move_from_player_key_check(p);

// do something here to calculate actual control comp move

               if (loc[p].old_comp_move != loc[p].comp_move)  // player's controls have changed
               {
                  loc[p].old_comp_move = loc[p].comp_move;


I think this is the answer:


            if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
            {
               if (loc[p].fake_keypress_mode) loc[p].comp_move = rand() % 64;
               else set_comp_move_from_player_key_check(p);

               if (loc[p].comp_move != comp_move_from_players_current_controls(p))  // player's controls have changed
               {

                  // in single player, client and server mode, add to game moves array
                  if ((cm == 0) || (cm == 3) || (cm == 4)) mGameMoves.add_game_move(mLoop.frame_num, 5, p, loc[p].comp_move);

int mwPlayer::comp_move_from_players_current_controls(int p)
{
   int cm = 0;
   if (syn[p].left)    cm |= PM_COMPMOVE_LEFT;
   if (syn[p].right)   cm |= PM_COMPMOVE_RIGHT;
   if (syn[p].up)      cm |= PM_COMPMOVE_UP;
   if (syn[p].down)    cm |= PM_COMPMOVE_DOWN;
   if (syn[p].jump)    cm |= PM_COMPMOVE_JUMP;
   if (syn[p].fire)    cm |= PM_COMPMOVE_FIRE;
   if (syn[p].menu)    cm |= PM_COMPMOVE_MENU;
   return cm;
}
void mwPlayer::set_comp_move_from_player_key_check(int p) // doesn't set controls

this seems to work, I have played 10 minutes as a client and not experienced the issue..

the old method workied fine, until...
rewind in conjuction with late cdats dropped by server....

I will call it fixed, unless it breaks something else....


I want to do a start over fresh win10 install thing

can I do it from an existing win10?

done...
now I want to make it easier by making a copy of MimGW folder done...

everything that is needed is in

\\x\mw\docs\aa_mdw_programs\pm\aa_dev_2023


now that I made the change to client input old_compmove netgame seems to be working great....

send version to all and test


Since I padded my tilemaps I have broken copy tiles in level editor....
Do I even care?  A bit..
should I make the padding an option so I can load from old versions?
I have made it work...but there is no option to load 1/2 from older bitmaps




client starting level with locked gate (locked on client but unlocked on server)
client borks, but rejoining brings him back to that level...

could I make clients always able enter any level?

I could make all levels unlocked for netgame

levels locked only affects gate entry

ignore when in netgame?

yes, do that...

ignore locked state when enetring gate in netgame mode....

fixed


client disappears after first level...
actually...when client quits...they go back to overworld, but not in a netgame anymore and invisible...
see if you can reproduce this:

headless server in story mode
join from menu then quit...back to menu...good
join from command line and quit...exit prog..good

headless server in story mode
join on overworld
start level from gate
then client quit
back to overworld and bad player


I need to trace it through the states

single player exit takes you back to overworld

   //---------------------------------------
   // 25 - client exit
   //---------------------------------------
   if (state[1] == 25) // client exit
   {
      mNetgame.client_exit();

      quit_action = 1; // to prevent quitting clients from automatically going to overworld

      state[0] = 1;
   }

this fixed it...





see if I can figure out how to make a wrapper for printf


#include <stdarg.h>

int write_log(int priority, const char *format, ...)
{
    va_list args;
    va_start(args, format);

    if(priority & PRIO_LOG)
            vprintf(format, args);

    va_end(args);
}


this was so easy to do!!!

what can I use it to replace?

all the log stuff....



old:

      if (mLog.LOG_NET_stdf)
      {
         sprintf(msg, "stdf saved server state[1]:%d\n", mLoop.frame_num);
         //printf(msg);
         mLog.add_log_entry2(27, 0, msg);
      }


new:

      if (mLog.LOG_NET_stdf) mLog.add_log_entry2(27, 0, "stdf saved server state[1]:%d\n", mLoop.frame_num);


also add to the log stuff a parameter if I want to print to console


add_log_entry2 occurances 41


this is the first successfull replacement

      if (mLog.LOG_NET_stdf) mLog.add_log_entry3(27, 0, 1, "stdf saved server state[1]:%d\n", mLoop.frame_num);

//      if (mLog.LOG_NET_stdf)
//      {
//         sprintf(msg, "stdf saved server state[1]:%d\n", mLoop.frame_num);
//         //printf(msg);
//         mLog.add_log_entry2(27, 0, msg);
//      }


1 line instead of 6...nice...do more


I am thinking of going one further


I want to have the log id numbers as defines

then do something like:

old:

if (mLog.LOG_NET_stdf) mLog.add_log_entry3(27, 0, 1, "stdf saved server state[1]:%d\n", mLoop.frame_num);

new:

mLog.add_log_entry3(LOG_NET_stdf_num, 0, 1, "stdf saved server state[1]:%d\n", mLoop.frame_num);

then in the function use that number and test
I can also add if I want to print that to the console...I can use this everywhere!!

I am doing this...

how many mLog.add_log_entry2? 29

how many can I switch?


I am down to 15 left...mostly when I want to print to console also... but sometimes when I spend a long complicated time building a string...




in bottom message draw_text...rearrange so msg is last, then make another draw_textf..done..not many use new function...

in log message also extend others that take a char as an arg

82 void mwLog::add_log_entry_position_text(int type, int player, int width, int pos, const char *txt, const char *border, const char *fill)
31 void mwLog::add_log_entry_centered_text(int type, int player, int width, const char *txt, const char *border, const char *fill)
20 void mwLog::add_log_entry_header(int type, int player, const char *txt, int blank_lines)

step 1 rearrange parameters so that txt is last

done...

setp 2 add a f type wrapper to each

done:

step 3 do replacements

26 82 void mwLog::add_log_entry_position_text(int type, int player, int width, int pos, const char *txt, const char *border, const char *fill)
31 31 void mwLog::add_log_entry_centered_text(int type, int player, int width, const char *txt, const char *border, const char *fill)
8 20 void mwLog::add_log_entry_header(int type, int player, const char *txt, int blank_lines)

done and push...

I guess the next big thing I want to do is make a generic funtion for adding log text

so that I can just always call it.


i will include the log category when doing this...

then I wil have a table for each type that I can either print to console or log or both

then I will need a better way to set all of these..

I can include all of my other debug logging also...

I want to have like only one line in code..

log_text or

log_textf(int type, int player, text...)


then an array

bool log_type_action[100][2]

1 = print to console
2 = log to file

then a bunch of human readable DEFINES

LOG_NET = 9
LOG_STDF = 11

etc...


Is this worth doing?

could i also optionally make it show error messages

could I also include bmsg? now I am stretching here..


start by making the defines...






   int LOG_TMR_cpu = 0;
   int LOG_TMR_move_tot = 0;
   int LOG_TMR_move_all = 0;
   int LOG_TMR_move_enem = 0;

   int LOG_TMR_bmsg_add = 0;
   int LOG_TMR_bmsg_draw = 0;
   int LOG_TMR_scrn_overlay = 0;

   int LOG_TMR_draw_tot = 0;
   int LOG_TMR_draw_all = 0;
   int LOG_TMR_sdif = 0;
   int LOG_TMR_cdif = 0;
   int LOG_TMR_rwnd = 0;

   int LOG_TMR_client_timer_adj = 0;
   int LOG_TMR_client_ping = 0;


   tags[40][0] = 1; tags[40][1] = 15; tags[40][3] = 69; sprintf(ctags[40], "gmar"); // game move array (E) [S]
   tags[41][0] = 1; tags[41][1] = 15; tags[41][3] = 77; sprintf(ctags[41], "move"); // move objects    (M) [S]

   tags[44][0] = 1; tags[44][1] = 15; tags[44][3] = 79; sprintf(ctags[44], "tmst"); // timestamp       (O) [CS]

   tags[99][0] = 1; tags[99][1] = 10; // bad tag





Then make an array or struct



struct log_types
{
   char name[40];
   bool log_to_file;
   bool print_to_console;
   bool error_dialog;
};

class mwLog
{
   struct log_types log_type[100];




then initialize it:




void mwLog::addf(int type, int player, const char *format, ...)
{
   char smsg[200];
   va_list args;
   va_start(args, format);
   vsprintf(smsg, format, args);
   va_end(args);

   add(type, player, smsg);
}


void mwLog::add(int type, int player, const char *msg)
{
   if (log_type[type].print_to_console) printf(msg);
   if (log_type[type].log_to_file) add_log_entry2(type, player, msg);
}


call it like this:


mLog.add(LOG_net_cdat, p, "text");

mLog.addf(LOG_net_cdat, p, "text:%d", i);

I am ready to test...

it seems to work... but what about the position text and custom things?


can I get rid of a bunch of calls to


      mLog.add_log_entry_centered_text(10, 0, 76, "+", "-", "");

almost all call have "" as text, and could easily be replaced with position...test it...


add_log_entry_centered_text...have all been removed...



now redo position

create an error type 9 done ....

but when I pass it the fw formatted string....it looks funny...

who cares?


what next?

replace all log net in client and server...


//if (mLog.LOG_NET_stdf) mLog.add_log_entry3(27, 0, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);

mLog.addf(LOG_net_stdf, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);

//      if (mLog.LOG_NET_stdf) mLog.add_log_entry3(27, 0, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
      mLog.addf(LOG_net_stdf, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);


work on the system to turn them on and off and save to disk



I still am not sure about the data structure
how will I store it to disk
log file?

should I pack the action into one int?
001 file
010 print
100 error
then I just need to save one int, and I coud test just one int

then how will I store it?
no human readable just indexed array
only ones that exist...

can I do comments in log file


I have made the widget for settings and it looks great..


now to save...

...

in what order?

I don't seem to be getting any results...

it is a problem with my macro expansion


so now what? how will I solve this?

I don't want to resort to this:

mSettings.overlay_grid[0][0]=0
mSettings.overlay_grid[0][1]=1
mSettings.overlay_grid[0][2]=0
mSettings.overlay_grid[0][3]=0
mSettings.overlay_grid[1][0]=0
mSettings.overlay_grid[1][1]=0
mSettings.overlay_grid[1][2]=0
mSettings.overlay_grid[1][3]=0
mSettings.overlay_grid[2][0]=0
mSettings.overlay_grid[2][1]=0
mSettings.overlay_grid[2][2]=0
mSettings.overlay_grid[2][3]=0
mSettings.overlay_grid[3][0]=0
mSettings.overlay_grid[3][1]=0
mSettings.overlay_grid[3][2]=0
mSettings.overlay_grid[3][3]=0
mSettings.overlay_grid[4][0]=0
mSettings.overlay_grid[4][1]=0
mSettings.overlay_grid[4][2]=0
mSettings.overlay_grid[4][3]=0
mSettings.overlay_grid[5][0]=0
mSettings.overlay_grid[5][1]=0
mSettings.overlay_grid[5][2]=0
mSettings.overlay_grid[5][3]=0
mSettings.overlay_grid[6][0]=0
mSettings.overlay_grid[6][1]=0
mSettings.overlay_grid[6][2]=0
mSettings.overlay_grid[6][3]=0
mSettings.overlay_grid[7][0]=0
mSettings.overlay_grid[7][1]=0
mSettings.overlay_grid[7][2]=0
mSettings.overlay_grid[7][3]=0
mSettings.overlay_grid[8][0]=0
mSettings.overlay_grid[8][1]=0
mSettings.overlay_grid[8][2]=0
mSettings.overlay_grid[8][3]=0


should I do it in a file...

i could call it settings.pm

and put log stuff and other stuff there too:

mBottomMessage.filter_event[41]=1
mBottomMessage.filter_event[42]=1
[SETTINGS]
mSettings.current_page=17
mSettings.show_advanced=1
mSettings.show_debug=1
[OVERLAY]
mSettings.overlay_grid[0][0]=0
mSettings.overlay_grid[0][1]=1
mSettings.overlay_grid[0][2]=0


I think I will do that, but only for logging for now...

make log error not part of net group, not adjustable, always does all three actions

label check boxes:

----- ----- -------
print  log  name


console log to
 print   file

console logfile


I have the settings page looking really nice for net log


now change all of them in code...

working through server

some bug on server when a client quits it prints lots of stats...
when only log_net is on...


went throough all LOG_NET occurances in code and changed to new style LOG_net

removed all references to LOG_NET...done

now search for them one at a time and make sure logging.txt is still accurate

removed old log functions to add text and position and headers...now they are all the new style ones



I think tmr profile logging will have to be different

first of all they all use type 44

and they all have different named things to turn them on

and it really doesn't make sense to print them 40 times per second

so what are you going to do?

force them all to have different numbers, but all within a range?
that could work

do all timer things use 44? yes

   if (mLog.LOG_TMR_move_all) mLog.addf(44, 0, "tmst m-esht:[%0.4f] m-psht:[%0.4f] m-lift:[%0.4f] m-plyr:[%0.4f] m-enem:[%0.4f] m-item:[%0.4f] m-totl:[%0.4f]\n",
                   (t[1]-t[0])*1000, (t[2]-t[1])*1000, (t[3]-t[2])*1000, (t[4]-t[3])*1000, (t[5]-t[4])*1000, (t[6]-t[5])*1000, (t[6]-t[0])*1000);


all have this format:

"tmst tag1:[val1]\n"
"tmst tag1:[val1] tag2:[val2]\n"

then I could give them another number to use for actions

the reason for the other number is to make adding them to a list and setting options easier

new functions:

// for single tags
void mwLog::add_log_tmr1(int type, int p, const char *tag, double dt)
{
   char txt[500];
   sprintf(txt, "%s:[%0.4f]", tag, dt*1000);
   add_log_tmr(type, p, txt);
}

// takes an already formatted string
void mwLog::add_log_tmr(int type, int p, const char *txt)
{
   if (log_types[type].action & LOG_ACTION_PRINT) printf(txt);
   if (log_types[type].action & LOG_ACTION_LOG)
   {
      char tmsg[500];
      sprintf(tmsg, "[%2d][%d][%d]tmst %s\n", 44, p, mLoop.frame_num, txt); // force type 44

      if ((log_msg_pos + strlen(tmsg)) >= NUM_LOG_CHAR) printf("log array full, > %d char\n", NUM_LOG_CHAR);
      else
      {
         memcpy(log_msg + log_msg_pos, tmsg, strlen(tmsg));
         log_msg_pos += strlen(tmsg);
         log_msg[log_msg_pos+1] = 0; // NULL terminate
      }
   }
}

added defines:

#define LOG_tmr_cpu                70
#define LOG_tmr_move_tot           74
#define LOG_tmr_move_all           75
#define LOG_tmr_move_enem          76
#define LOG_tmr_draw_tot           80
#define LOG_tmr_draw_all           81
#define LOG_tmr_bmsg_add           84
#define LOG_tmr_bmsg_draw          85
#define LOG_tmr_scrn_overlay       87
#define LOG_tmr_sdif               90
#define LOG_tmr_cdif               91
#define LOG_tmr_rwnd               92
#define LOG_tmr_client_timer_adj   95
#define LOG_tmr_client_ping        96


added to init:

   i = LOG_tmr_cpu;                 log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_cpu");
   i = LOG_tmr_move_tot;            log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_move_tot");
   i = LOG_tmr_move_all;            log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_move_all");
   i = LOG_tmr_move_enem;           log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_move_enem");
   i = LOG_tmr_draw_tot;            log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_draw_tot");
   i = LOG_tmr_draw_all;            log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_draw_all");
   i = LOG_tmr_bmsg_add;            log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_bmsg_add");
   i = LOG_tmr_bmsg_draw;           log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_bmsg_draw");
   i = LOG_tmr_scrn_overlay;        log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_scrn_overlay");
   i = LOG_tmr_sdif;                log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_sdif");
   i = LOG_tmr_cdif;                log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_cdif");
   i = LOG_tmr_rwnd;                log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_rwnd");
   i = LOG_tmr_client_timer_adj;    log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_client_timer_adj");
   i = LOG_tmr_client_ping;         log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_client_ping");


now make them adjustable in settings...done...


now make them use the new versions...


old:
if (mLog.LOG_TMR_cpu) mLog.add_log_TMR(pt, "cpu", 0);

new:

mLog.add_log_tmr1(LOG_tmr_cpu, 0, "cpu", pt);


I think this one works...

got rid of all old LOG_TMR...



rtextout version

      sprintf(msg, "Waiting for game state from server");
      float stretch = ( (float)mDisplay.SCREEN_W / ((strlen(msg)+2)*8));
      mScreen.rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, 10, stretch, 1, msg);

      sprintf(msg, "SERVER ENDED GAME!");
      float stretch = ( (float)mDisplay.SCREEN_W / (strlen(msg)*8)) - 1;
      mScreen.rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, mPlayer.syn[p].color, stretch, 1, msg);

      sprintf(msg, "LOST SERVER CONNECTION!");
      float stretch = ( (float)mDisplay.SCREEN_W / (strlen(msg)*8)) - 1;
      mScreen.rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, mPlayer.syn[p].color, stretch, 1, msg);

      float stretch = ( (float)mDisplay.SCREEN_W / (strlen(msg)*8)) - 1; // (mDisplay.SCREEN_W / text length*8) -1


make stretch auto...

send -1 for stretch and it will do auto

done...need to test

Now I really want to test everything about the new log system

ok here are the tests:
server dies when logging...
server dies always...fixed bug
size wrong on server quit client message "SERVER ENDED GAME"
fixed with -2 message

all of the new rtextout's work and the replacement jq works...has all been tested..

now test the goddamn log stuff!!

bug in bandwidth

bug in opening log file..

i see nothing

do I need log_net?
yes
log file will not display in viewer without it
why not?
actually it will, but by default, bandwidth entries are hidden



look for any call that uses number instead of constant:

add
addf

done







make load config not save at end, unless file does not exist

done...now whay are there so many save_config at start?

- init_display - saves actual screen size

- set start level


set_scale_factor saves

it is called in load...

how do i fix this?
just ignore all the muliple calls to save...it works....
reverted back to exactly where it was before




add more variables to settings...

mSettings.overlay_grid
mBottomMessage.filter_event

done.. that was easy


make any key stop splash, not just control
done, also mouse button


make reset all settings button also erase settings.pm..done





add rebuild_bitmaps to profile timers

#define LOG_tmr_rebuild_bitmaps    72

i = LOG_tmr_rebuild_bitmaps;     log_types[i].group = 2;   strcpy(log_types[i].name, "LOG_tmr_rebuild_bitmaps");

recreate settings.pm

   double t[8] = { 0 };
   t[0] = al_get_time();


   // rebuild main tiles
   al_set_target_bitmap(tilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_tilemap, 0, 0, 0);

   // rebuild block tiles
   al_set_target_bitmap(btilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_btilemap, 0, 0, 0);

   // rebuild player tiles
   al_set_target_bitmap(ptilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_ptilemap, 0, 0, 0);

   // rebuild door tiles
   al_set_target_bitmap(dtilemap);
   al_clear_to_color(al_map_rgba(0,0,0,0));
   al_draw_bitmap(M_dtilemap, 0, 0, 0);

   t[1] = al_get_time();


   //printf("restore tile array time:%f\n", al_get_time() - t[0]);

   mFont.load_fonts();

   t[2] = al_get_time();


   mLevel.load_level_icons();

   t[3] = al_get_time();

   mScreen.init_level_background();

   t[4] = al_get_time();

   mDisplay.set_display_transform();
   mLogo.logo_text_bitmaps_create = 1;
   large_text_overlay_state = 0;
   text_title_bitmaps_create = 1;
   mScreen.set_map_var();
   mVisualLevel.load_visual_level_select_done = 0;
   mLevel.level_stats_bmp_msg_type = 0;

   t[5] = al_get_time();

   mLog.add_tmrf(LOG_tmr_rebuild_bitmaps, 0, "tiles:[%0.4f] fonts:[%0.4f] icons:[%0.4f] lvbk:[%0.4f] misc:[%0.4f] totl:[%0.4f]\n",
                   (t[1]-t[0])*1000, (t[2]-t[1])*1000, (t[3]-t[2])*1000, (t[4]-t[3])*1000, (t[5]-t[4])*1000, (t[5]-t[0])*1000);


this all works well.

cannot view profile graph if log was made without game running, all y axis (time) will be frame 0...nbd

made the settting pages look even better....


added more logging documentation
profile and graphs are fully documented and tested...

net logging is partially done

bump version and push



I want to do more fine granulatity in all the log_net things

first doc all that it does:

PLAYER ACTIVE, INACTIVE, DIED

network init


First of all separate the network init stuff...

game_init 20 is unused

I could use it, but I want to call it something else...

network_init

now what is left?
PLAYER ACTIVE, INACTIVE, DIED
level started, next level


I am thinking that I want to to have everything in network init....

call it network setup

why did I need three categories before?

maybe have an optional join details?

make network_setup default to print..


now network_setup has almost everything, including most of join

test what that looks like...


Player locked on server needs to be in a header..fixed

ending stats always show...fixed

player died on server, prints many times during rewind..fixed
how about just never log things in a ff??
player died ff repeat...fixed


endings stats for all clients do not show used clients now, because I reuse them and set mode to 0 instead of 8 like I used to....

client does not show when player comes active

client does not show ending stats when quitting


can I combine both bandwidth into a single log entry?
yes, but do not have a way of showing in graph yet....








----------------------------------


add more logging options:

program states

drawing

moving

level done

add stuff to logging to enter stuff without \n

actually I think 'add' does that already...just omit the \n

I now have program_state and transitions done...

I now have move and draw done

level done mode done

for now I am not going to make a custom setting page for these...I will add them to profile by making their group also 2
but then when I am done with them I will make their group 3...


now back to why server dies when going from gate to level...fixed






























figure out netgame

I need more documentation...


add more at the end of client timing sync??

there is some better descriptions of both in ping...


this is what I have set right now:

loc[p].client_chase_offset_auto_offset = -0.02;

mPlayer.loc[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq


how am I going to test, and what am I going to vary?

what is up with the client sync adjust?

It does not work like I want it to...

auto mode you can still adjust the offset
manual mode you cannot adjust anything??


I still am lost at how to adjust these things

at the very least add loc[p].client_chase_offset_auto_offset = -0.02; to config

maybe it should be somewhere else rather than the player struct...


I want to move these from loc struct to netgame class


   double client_chase_offset;
   double client_chase_offset_auto_offset;
   int client_chase_offset_mode; // 0 = manual, 1 = auto

done...

what is the default stdf_freq if not auto?


I want to be able to remotely monitor and control the server

I am thinking of some dedicated packets for this:

server will send a big chunk of data to a monitoring computer
like logs and graphs, but in real time

server will accept control packets from the same computer..

but what would I send to control? stdf freq?

I am thinking that I don't want to ever have stdf freq less than 2

but I am not really able to see what affect I am having..

base resets are the most important thing....

I am not sure why lower stdf freq is desirable.
Is it to reduce the size of corrections?

I have played with stdf of 10 and did not see any problems...
it made the initial join take longer

I want to move stdf freq from loc to netgame, just like cco
done...
also add actual value to config and allow to change in settings...done

bump ver and push




I want to see the client sync graph...figure it out...

      if (log_lines_int[i][0] == 30) // stak line
      {
         int p = log_lines_int[i][1];




   sprintf(msg, "%s %s\n", tmsg1, tmsg2);
   if (mLog.LOG_NET_server_rx_stak) mLog.add_log_entry2(33, p, msg);


change 30 to 33

also needs 10? for player active

x_axis_draw_gridlines_and_labels(0);


fixed a bug in graph...

void mwGraph::x_axis_draw_gridlines_and_labels(int set_size_only)


this while would block, so i added a guard to not do it if labels are not drawn

         // find out if major gridline labels will touch each other....
         if (x_axis_grid_label_draw_on)
         {
            int max_space_between_labels = - 9999;
            while (max_space_between_labels < 10)
            {


Now, here is how client_sync_graph works:

- only can run on server
- need to have LOG_NET_server_rx_stak logging enabled
- (optional) need to have LOG_NET enabled if you want to see when clients became active


Fixed all the help entries related to logs...

segfault when opening log...why?

so many fucking bugs!  arrrghhh!!!

fixed bug in get tag that errored when tag was not found


now moving on:

I was wanting to see how the slow chase happens with larger stdf_freq

LAN e6430 server stdf manual 2
start frame 237, lock 303

LAN e6430 server stdf manual 4
start frame 285, lock 384

LAN e6430 server stdf manual 6
start frame 203, lock 339

LAN e6430 server stdf manual 8
start frame 198, lock 372

LAN e6430 server stdf manual 10
start frame 209, lock 422

so I dont see much with this data, but what I do see is that with larger stdf the graph swings up and down more

what the hell is ping graph and what do I need to do to make it work?

   tags[36][0] = 1; tags[36][1] = 13; tags[36][3] = 84; sprintf(ctags[36], "tmaj"); // timer adjust (T) [C]
   tags[37][0] = 1; tags[37][1] = 13; tags[37][3] = 78; sprintf(ctags[37], "cpng"); // client ping  (N) [C]


with higher stdf_freq   dsysnc really has a cyclic pattern

what can I do about that?

can I make packets used for sync different from stdf...

what if I made ping packets once per frame?

hell I was going to send stdf once per frame!!

wait a tick here! I don't use stdf packets for timing....i use pong...

and they only come once every 2s!!! no wonder my chase loop oscillates


compare:


LAN e6430 server stdf manual 10 ping_freq:20
-22 -17 -23 -18 -23 -18
-39.9 - 40.1 on a 2-3 sec sine wave


LAN e6430 server stdf manual 10 ping_freq:2
-29 -12 -27 -13 -26 -14
-39.5 - 40.4 on a 2-3 sec sine wave


LAN e6430 server stdf manual 10 ping_freq:40 (every frame)

I am getting bad results doing it that way...


what if the server just broadcasts ticks

then the client can lock onto those

the client can reply and then the server will know the client time...

I can also make the tick more accurate


why is the dysnc on a 2s cycle, no matter what ping or stdf freq?
I don't know...


DUH!
client timer adjust is based on stdf dsync

that is where it is adjusted

all ping does is set chase offset....


this seems far more complicated than it needs to be...

I want to adjust time more often than when stdf's are received

otherwise stdf's could be my tick

put the ping back

stick it in with the 1Hz stuff

try stdf freq of 4, fixed and see if you can tweak the loop
the chase has very little cycling


what bad things happen when s1 never goes below 4?

I dont know


lets do another release and try over the internet....

seems to work good with manual stdf of 4, 3, 2

the only bad thing is the non local players seem to jump around a lot

but its pretty much the same with 4, 3, 2


I think that this is just the way that it is....










20230827 where am I at?

trying to put the finishing touches on netgame

the most noticeable thing is other players in a netgame
they jump and warp a lot


can you put a number on it?

can you make it less severe?

I think that faster stdf and less offset would make it look better

how can i measure?

I need to do more monitoring on the client, that is where you see all the jumpiness

how about max player correction for any active player...done

it does not show much difference because....

local client has been updated with local moves since last state
remote ones have not

this does not help, it actually is the opposite

try it with a large stdf and see...

tried with 8
remote cor max up to 40
local cor max up to 20

this actually looks like I'm onto something, or just confirming what I already knew

I want to document all the tools I have for monitoring and measuring netgame...

Starting with this...

wait a minute, should I measure corr after ff?

what am I trying to do here


original method:
get pos now
compare to past corrected pos

new method:
get pos now
compare to past corrected pos then played forward to now

alt:
rewind and get pos
apply and compare


of all the methods new seems best.
it compares now to corrected now


what is client_move_lag

measured on client when applying dif

mPlayer.loc[p].client_move_lag = mLoop.frame_num - client_state_dif_src;

what does it mean?

how far back the base frame is.

how many frames the client has been free running before it is corrected

directly related to stdf freq



what is client_rewind

int ff = mPlayer.loc[p].client_rewind = mLoop.frame_num - client_state_dif_dst; // dst compared to current mLoop.frame_num

measured on client when applying dif

the amount of frames that are ff replayed after a dif is applied

directly related to offset??, yes!!

It seems like I am better understanding this now....

the only thing to adjust on the server is stdf_freq

the only thing client can control is their timing relationship to the server

I was adjusting stdf freq based on max client ping, but maybe I should just make that fixed and adjust client offset

I have some values I am trying to minimize:

client_rewind
client_move_lag
late cdats

speaking of late cdats on the client, could I make that part of syn?

it is not documented??

server sets


change

   int late_cdats;
   int late_cdats_last_sec;

from loc to syn

I want to see them on the client and I don't want to pass them both with specialized packets

add 8 more spare ints to syn...done...

old:
psyn is 2304
tot is 112128

new:
psyn is 2304
tot is 112384

now move from loc to syn...done

now remove from packet exchange..done

now show in client debug grid

BUGS i am pretty sure that server rewind is clearing these....

      // save values we don't want rewound
      int lcd[8][2] = { 0 };
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            lcd[pp][0] = mPlayer.syn[pp].late_cdats;
            lcd[pp][1] = mPlayer.syn[pp].late_cdats_last_sec;
         }

      state_to_game_vars(srv_client_state[0][1]);   // apply rewind state
      mLoop.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
      mLoop.loop_frame(ff);

      // restore
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            mPlayer.syn[pp].late_cdats = lcd[pp][0];
            mPlayer.syn[pp].late_cdats_last_sec = lcd[pp][1];
         }

fixed...

bump version and release...
kill all data and config too..

remove late cdats line, now in grid
add cor to client grid
done


lag also, but maybe rename

think up better names for rewind and lag


client_rewind

int ff = mPlayer.loc[p].client_rewind = mLoop.frame_num - client_state_dif_dst; // dst compared to current mLoop.frame_num

measured on client when applying dif

the amount of frames that are ff replayed after a dif is applied

directly related to offset??, yes!!


other name that might be more descriptive:
client_replay_frames
client_ff_frames


releated to client_lag which is:

measured on client when applying dif

mPlayer.loc[p].client_move_lag = mLoop.frame_num - client_state_dif_src;

what does it mean?

how far back the base frame is.

directly related to stdf freq

how many frames the client has been free running before it is corrected
not exactly??


    +-------------+---------------+
base_frame   state_frame    current_frame

cf-sf = client_rewind
cf-bf = client_lag

what if I showed a graphic representation of this:

record the values when dif is applied

sfd (src frame_delta)
dfd (dst frame_delta)


I just realized that frame span between sfd and dfd is stdf_freq..

I really want to see this graphically in real time on the client


+--+--+
s d c





what if I send the entire game state every frame
always based on state zero

why?

just to see what it does

what kind of bandwidth are we talking here?

would it help with retransmits

how can I easily swap this in for testing?

what do I get before


do this with m36 as server and e6430 as client....

s1:2 no base resets 5kB
s1:1 no base resets 7kB
size 300



base 0
70K
size 3000


make it optional with stdf_freq = 0??


check what actually is going on...

is s1 == 1 everyframe?

no...wtf??

new state:359   s1:2
new state:362   s1:2
new state:365   s1:2
new state:368   s1:2
new state:371   s1:2

new state:393   s1:1
new state:395   s1:1
new state:397   s1:1
new state:399   s1:1
new state:401   s1:1

new state:484   s1:0
new state:485   s1:0
new state:486   s1:0



this is not what I expected, it could explain many things....

if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1)    // is it time to create a new state?

change it so that it does what I expect...

if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1 -1)    // is it time to create a new state?


0 = every frame and no base
1 = every frame
2 = every 2 frame
3 = every 3 frame


new state:191   s1:3
new state:194   s1:3
new state:197   s1:3

new state:200   s1:2
new state:202   s1:2
new state:204   s1:2

new state:226   s1:1
new state:227   s1:1
new state:228   s1:1

new state:250   s1:0
new state:251   s1:0
new state:252   s1:0


new bandwidths:

s1:3 no base resets 5kB
s1:2 no base resets 7kB
s1:1 no base resets 13kB
size 300


base 0
140K
size 3000


lets bump, deploy and test

can I make my headless server still detect serial key check?


it works over the internet with s1=0

each client uses about 140kB/s

still does not look much better with the warping corrections

my nice graphical thing is broken...it depends on the stdf src, which I am setting to zero for base reset reasons...

why do I even care about dif src?

I just liked having something to show on the client...

why not just the time from now to the dest of the dif...

that is crwd or ff


If I leave s1:0

the only other thing I can adjust is the client offset...
and I want to monitor crwd...

I can get 2 with offset > 25

and 1 with < 25


but I cant do < 25 when ping is 30

try local

m36 server and 2 clients
each has 330kps for a total of 670kbps  wow
I guess it depends on the level
that was level 64
level 1 has 135 each for a total of 270


does not seem to make much difference in the warping...
its better I think, but not dramatically better, hard to tell...

what is stsy, cdsy and gmav on server debug grid?




stsy - server stak sync
mPlayer.loc[p].stak_dsync*1000);
when server rx stak, how long did it take from client
not really used, more like a ping time


cdsy - client dsync
mPlayer.loc[p].dsync
calculated by client and passed to server with stak packets


gmav - client game move sync avg last sec
when server processes cdat it compares the time to the current server time
tallies average last sec for each client



I really want to be able to control and monitor the headless server remotely



how?

a seperate program connected with my own custom packet exchange?


or a connected client can just open a debug connection to the server

I want to see the full debug overlay, and be able to control s1 and zc


it would be easier (maybe) to base it off a connected client

put the client in a special inactive state...


or I could make my own connection...
independant of the netgame


I want to write up what I have discovered today. Formally, so I do not have to discover it again later.

First of all the good news. Netgame is working well. As good as possible with the current algorithm.

Now for the bad news.

Not really bad, but there is some warping of non-local clients on other clients games.

It looks like the player is twitching and jumping around.

Its really not that bad, but I spent a lot of time and effort to see if I could get rid of it or at least minimize it.


There are only a few adjustable things in the game.

On the server, the rate the states are sent.

On the the client, the timing offset in relation to the server.


First of all, lets discuss stdf_freq, the rate the server send states to clients.

0 = every frame and no base
1 = every frame
2 = every 2 frames
3 = every 3 frames

The more often they are sent, the less corrections on the clients.

This time I even made a new setting, 0, which in addition to sending states every frame,
also gets rid of the need for a base to make a diff with.

This was attempted to see what would happen.  Here is what happens:
The amount of bandwidth increases almost 10 times.

There might be a slight improvement in the client corrections, but its barely noticeable.
The functionality is left there to experiment with.
All you need to do is manually set stdf_freq to 0;

The end result is that will probably always use manual 1 for stdf_freq.


Next of all is client_offset.

In order for things to run as smooth as possible, with the fewest corrections, client offset should be as low as possible.

In a LAN with low ping times you can set client_offset as low as 5-10;

If you set it too low you will get late_cdats. Where the server gets input too late to be applied.


























-------------------------------------

If I do not need states for making clients difs, could I keep extra for late_cdats

I am not sure what I am talking about here...


I am adjusting client sync to get very close to the server, but as I get too close I get late cdats...


ideally I would get the dif on the frame it was needed, but then my input would be...


what would happen if I kept more states on the server, like 20, enough for 500ms of game time
then late cdats would not be an issue?

but how late of an input would I allow to affect the current state?

am i onto something here or am I just crazy?


what would it take to test?



an array of game states

lets just do 8 for now


   // server's last 8 states for rewinding
   char srv_rewind_state[8][STATE_SIZE];
   int srv_rewind_state_frame_num[8];


now every frame save state

how will I juggle the circular array?

find oldest and overwrite...


in function server rewind...

I will need to keep track of dirty frames

how about earliest new game move

wait..game move is not sorted..i can use that to my advantage

how about looking back

each time a state is made, also store gmep for that frame

then and this get tricky here

cf = 100

I have states from 92-99 stored

take the oldest state
look for new moves that match that state

I could just play back and make new ones, that seems simpler

- load oldest state
- step one frame at a time and save states

this all seems so complex

why do I not make the one that I base these on one frame earlier...

I am so confused....



when server makes a new state it overwrites the old base state

I want it to keep at least one older version

then when rewinding go back to the earliest version

then save newest and bump that to oldest



this is sounding like something that might work...


when server makes a new state save also save it in my new array and overwrite the oldest position



when server rewinds, find the oldest state in the array and load from there


wow! this is so simple and is just crazy enough to work



I need a good way of finding the oldest (min) frame_number

initialize array with mn = std::numeric_limits<int>::max();

     // also save in array

     // find lowest frame number
     int mn = std::numeric_limits<int>::max();
     int indx = 0;
     for (int i=0; i<8; i++)
     {
        if (srv_rewind_state_frame_num[i] < mn)
        {
           mn = srv_rewind_state_frame_num[i];
           indx = i;
        }
     }


     memcpy(srv_rewind_state[indx], srv_client_state[0][1], STATE_SIZE);

OK I have patched it in...lets take it for a ride


my min max bullshit doesn't work

start with zero


what do I want?

when adding I want to remove the lowest

when fetching I want to find the lowest

have -1 as unset....

when adding, do all -1 first, then lowest

when fetching, ignore -1



OK I have patched it in and it works, right up until I get late cdats, then it all goes to hell

do I even need to toss late cdats? they will not be executed...
I do because I want know that they are occuring and I want to be able to play back the save game


I could easily remove this new code I have added....


I was thinking...does this not require the client to also have the previuos state?
no...client base states are different, but are they?

I could test with s1 = 0...

It looks like its a server problem...

when ever the client does a sync offset and catches up to and passes the server the server gets messed up...


it happens when server tries to enter late game move??


I think I might know why?

server rewinds back 8 then replays to apply new input, but it only saves the newest state after the rewind.
it should resave all of them...


the way I have the states in a ring buffer is not needed anymore.

I will be redoing the entire list everytime I rewind

always have the oldest in position 0, then newer until space is gone

I only ever load from the oldest anyway...




load earliest state

ff and save rewind states up for current

play current

save current in rewind and other



reset all rewind states

or I could have a rewind_state_entry_index and reset that to zero


I think I have this new method working, kind of...

remove all traces orf old and save here in the comments..then test more


//int mwNetgame::find_earliest_rewind_state(void)
//{
//   // find lowest frame number
//   int mn = std::numeric_limits<int>::max();
//   int indx = -1;
//   for (int i=0; i<8; i++)
//   {
//      if ((srv_rewind_state_frame_num[i] > -1) && (srv_rewind_state_frame_num[i] < mn))
//      {
//         mn = srv_rewind_state_frame_num[i];
//         indx = i;
//      }
//   }
//   return indx;
//}


//
//void mwNetgame::add_rewind_state(void)
//{
//   int indx = -1;
//
//   // first use all empty slots (-1)
//   for (int i=0; i<8; i++)
//      if (srv_rewind_state_frame_num[i] == -1) indx = i;
//
//
//   if (indx == -1) // no empty's left
//   {
//      // find lowest frame number
//      int mn = std::numeric_limits<int>::max();
//      for (int i=0; i<8; i++)
//         if (srv_rewind_state_frame_num[i] < mn)
//         {
//            mn = srv_rewind_state_frame_num[i];
//            indx = i;
//         }
//   }
//   if (indx == -1)
//   {
//      //show_rewind_states(" -  indx:%d  frame:%d  ERROR! adding server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//   }
//   else
//   {
//      //show_rewind_states(" -  indx:%d  frame:%d  adding server rewind state \n", indx, srv_rewind_state_frame_num[indx]);
//      memcpy(srv_rewind_state[indx], srv_client_state[0][1], STATE_SIZE);
//      srv_rewind_state_frame_num[indx] = srv_client_state_frame_num[0][1];
//   }
//}
//
//
//
//void mwNetgame::load_earliest_rewind_state(void)
//{
//   if (mLoop.frame_num > 0)
//   {
//      int indx = find_earliest_rewind_state();
//      if (indx > -1)
//      {
//         memcpy(srv_client_state[0][1], srv_rewind_state[indx], STATE_SIZE);
//         srv_client_state_frame_num[0][1] = srv_rewind_state_frame_num[indx];
//        // show_rewind_states(" -  indx:%d  frame:%d  loading server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//      }
////      else show_rewind_states(" -  indx:%d  frame:%d  ERROR! loading server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//   }
//}
//

the whole algorithm is flawed...

34 34 -1 -1 -1 -1 -1 -1 frame:34
stdf saved server state[1]:34
stdf rewind to:35
35 35 -1 -1 -1 -1 -1 -1 frame:35
stdf saved server state[1]:35
stdf rewind to:36


rewind to index 0 then play back to current

but it only does the first few....



it might work when setup, but how to get it setup?

do not overwrite oldest? until array is filled?


I have thought about making this whole thing a class...

then I could tell it:

rewind to oldest and play back to current

and I would know how to do this from the start as well as while running


get a very detailed description of how you want it to work

- start out with all 8 rewind slots blank (frame set to -1)

- when server starts, add state from frame 0 to index 0

then every frame:

find the oldest and rewind to that one, ignoring -1's

then set that index to -1 so it can be reused

what if the oldest was always in slot 0?

then rewind to oldest

and as you play back overwrite from 0 up

this sound easy and intuitive:

1 - rewind to earliest (probably always index 0, maybe skip check and rewind to index 0)

2 - erase all other frame numbers (set to -1)

3 - as you play back save all new states


the only problem with this is it will start by rewinding 1 and never grow to more...


how about 0 is current frame and all others are previuos

have a way of poking in new state from the end and shifting all others back one, (and losing earliest)


1 - rewind to earliest
2 - play back and overwrite matching frame numbers
3 - do current loop and push from end, dropping earliest

3 could also be:
- find a place to put newest
- could be a -1, or if no -1 then the earliest

I think this might actually work!!


first of all, do I reset to -1? yes, i do

   for (int i=0; i<8; i++)
   {
      memset(srv_rewind_state[i], 0, STATE_SIZE);
      srv_rewind_state_frame_num[i] = -1;
   }

next, add initial state to index 0

bring back rewind to earliest (not including -1)

do i need multiple find earliest?

when I am rewinding, I want to min, but ignore -1

when I am adding, I want to replace the earliest, but -1 first


make 2 versions...




I think I have this all working...

server is saving states like it should

client can run with positive sync
need to clean it up a bit and do more tests...


cleaned up the code a bit...do some more tests tomorrow



what does it mean if the client dsync goes positive?
it means I can get crwd to zero, where the client does not have to ff after receving states

If I go too far and get crwd -1 then the client is dropped by the server?


tested over internet and it seems very choppy...also takes lots of cpu...

test more....



It is relatively simple to comment out in code:



Here are all the places in the server code:



void mwNetgame::server_rewind(void)
{

//      // load earliest rewind state
//      load_earliest_rewind_state();
//      mLog.addf(LOG_NET_stdf, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);


      // calculate ff (how many frames will need to be replayed in fast forward mode)
      int ff = mLoop.frame_num - srv_client_state_frame_num[0][1];  // almost always equals s1, unless s1 has changed

      // apply rewind state and set frame num
      state_to_game_vars(srv_client_state[0][1]);
      mLoop.frame_num = srv_client_state_frame_num[0][1];

      // fast forward and save rewind states
      for (int i=0; i<ff; i++)
      {
         mLoop.loop_frame(1);
//         add_rewind_state(mLoop.frame_num);
      }

//      show_rewind_states("frame:%d\n", mLoop.frame_num);



server_create_new_state(void)

      // save state as a base for next rewind
      game_vars_to_state(srv_client_state[0][1]);
      srv_client_state_frame_num[0][1] = mLoop.frame_num+1;

//      add_rewind_state(mLoop.frame_num+1);



cdat:

   // find oldest frame
   int of = srv_client_state_frame_num[0][1]; // default
//   int indx = find_earliest_rewind_state(0);
//   if (indx > -1) of = srv_rewind_state_frame_num[indx];



I actually don't think this is a bad idea to save more rewind states

then I could do away with using  srv_client_state[0][1]...but maybe I need it beacuse I need a source and a dest to make a dif??

----------------------------------------

maybe I could encapsulate this in a class owned by netgame

name: state_ring_buffer, state_history

methods:
clear
add_initial
load_earliest_rewind_state
add_rewind_state

----------------------------------------

when sending dif:

on server, after applying moves for current frame, that frame is saved with frame+1 as the base for the next frame
but when the dif is sent to clients, its dest is set to the current frame

i don't know if that is an issue, but it looks funny in the logs when i see:
stdf saved server state[1]:277
tx stdf p:1 [src:275 dst:276] cmp:600 ratio:0.53 [1 packets needed]


on the client:

frame_num++
mNetgame.client_control();
mPlayer.proc_player_input();

so the client will get a new state then process local input

I think this all looks good... I mean, it is working....so it should be correct....

----------------------------------------

made some defines in mwNetgame.h
#define NUM_REWIND_STATES 8
#define USE_REWIND_STATES

test cpu usage

m36 server with 1 client on LAN
8 27%
4 24%
disabled 20%

m36 server with no clients
8 14-16%
4 12-14%
disabled 9-10%


e6420 server with 1 client internet
4 50%
but its doing stdf freq = 1 and base resets every frame



----------------------------------------

test some more

it looks like this new method can get the client a little closer to the server in time

on LAN when crwd is zero it seems to work great

on internet when increased to make crwd one less than normal it seems good, but more than that and it gets really jumpy


what about making s1 = 2 forced..test what happens...

I also notice that the printing to console takes a noticeable amount of cpu


---------------------

so to recap, the saving of more rewind states thing, what has it achieved?

- it allows me to run a client closer in time to the server without getting late cdats

before I had to stay a little behind...

I am so confused as too which way....

And I don't explicitly say in the docs..

can I figure it out with crwd?

if crwd = 0 then difs are arriving exactly on the frame they are needed

if crwd = 1 then difs are arriving 1 frame too late.
because then after applying 1 frame has to be played back

when sync is from -25 to 0   crwd = 1
when sync is from -25 to -50 crwd = 2

when client has to ff it means that the server is ahead, or in other words that the client is behind

so with this data I can say that:

dysnc is 0 when client receives dif exactly when needed
dysnc is negative when client recieves dif before it is needed (then it is applied and fast forwarded)
dysnc is positive when client receives dif after it is needed (this would never work, client would jump ahead)

so then why do I get late cdats when client gets closer to 0?

i think it was when there was not much time between rewind states
but now that that is not an issue...

I want to run the client as close as I can behind the server, so that crwd is zero

this seems to work well on LAN but not internet

do some tests and look at gmav and stuff

-----------
I just had a brainwave

you know how I do logs for netgame? what if I did a huge graph with all the relevant data...

like dsync,


 -------------

 Here is the official client dsync decription



 -------------



Do I want to run the client as close as I can to the server so that rewind is zero?

Are there any drawbacks to this?


test with e6430 as server and 2 clients

server force stdf 1 and 4 rewind states

in a LAN game with ping 0

sync is auto at -20
crwd is 1
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: -20
stsy: 15
gmav: 15


this looks great!

plays beautifully on LAN, even client on other client looks perfect..
cpu 30% on e6430 server with no overlay


now try to reduce sync...

manually lower sync to 10
-------------------------------------
crwd is 1
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: -10
stsy: 6
gmav: 6


manually lower sync to -5 (at zero it bounces between crwd 0 and 1)
-------------------------------------
crwd is 0
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: 5
stsy: 15
gmav: -10


Now try with internet connection
-------------------------------------
ping is 23-28
sync is around -50
constant base resets
probably due to stdf freq = 1
e6430 cpu = 42 no ovrlay

crwd is 2-3
maxcor 6.4
nlcmxcor:12.6

srv shows
cdsy: -50
stsy: 12
gmav: 10

playable, a bit jumpy on non-local client



Now try lowering sync...
-------------------------------------
from -50 to -20

crwd is 1
maxcor 6.4
nlcmxcor:12.6

srv shows
cdsy: -20
stsy: 12
gmav: -15

playable, a bit jumpy on non-local client same as last trial pretty much



Now try with server stdf freq = 2
-------------------------------------
base resets gone (rare)
e6430 cpu = 30 no ovrlay

crwd is 1
maxcor 6.4
nlcmxcor:18.6

srv shows
cdsy: -20
stsy: 38-40
gmav: -13


a bit more jumpy



Go back to auto sync
-------------------------------------
now around -50
crwd is 2
maxcor 6.4
nlcmxcor:18.6

srv shows
cdsy: -47
stsy: 38-40
gmav: 12-14

same as last a bit more jumpy




Now try LAN with stdf freq = 2

it makes nlcmxcor: 12 instead of 6




-----------------------------
final thoughts:

It makes sense that the longer I go between state updates the further out of sync I will get...



I should set stdf_freq as low as possible...

I could even do the same thing I do on the server and keep multiple previous base states, but how much of an issue is it if I send the entire state every frame?

what if I just moved the clients offset so that the bases were not late? i don't think that will work, its a two way thing with the client acknowledging

just because I keep previous states on the client does not mean I have to ff from earlier, i only ff from the dest, not the src


but then on the server what gap should I use?

make a frame and base it on the -2 frame? always?

how much data?

how can I test forcing all zeros everytime?

2 - 7k
1 - 13k
0 - 137k


also what if I based it off the state of the loaded level...

I want to test this...

where can I save that?

it seems like it will use alot less data, like still one packet...

lets see if I can make this work...


I see one potential problem...server and client do not have the same starting point

but they really should...

I think it is mostly the player array....


I could make the server send a special initial state...

or I could figure out how to ensure player struct is always the same after a level load...


lets try number 1


number 2 what is changed?

      syn[p].active = 0;
      syn[p].paused = 0;
      syn[p].control_method = 0;

save before load
set to zero
save copy
restore


what do I need to do for number 1?


make server send its loaded level based on zero....
this is the only safe way...need to make sure they have the same base...



what is the easiest way to do this?

when a client joins have the server send the full zero base...


made a function on server:

void mwNetgame::server_send_base(int p) // send base to a client
{
   char zero[STATE_SIZE];
   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   memset(zero, 0, STATE_SIZE);

   get_state_dif(zero, load_state, dif, STATE_SIZE);

   // compress dif to cmp
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
   int cmp_size = destLen;
   float cr = (float)cmp_size*100 / (float)STATE_SIZE; // compression ratio

   // break compressed dif into smaller pieces
   int num_packets = (cmp_size / 1000) + 1;

   mPlayer.loc[p].cmp_dif_size = cmp_size;
   mPlayer.loc[p].num_dif_packets = num_packets;

   mLog.addf(LOG_NET_stdf, 0, "tx stdf p:%d [src:%d dst:%d] cmp:%d ratio:%3.2f [%d packets needed]\n", p, 0, 0, cmp_size, cr, num_packets);

   int start_byte = 0;
   for (int packet_num=0; packet_num < num_packets; packet_num++)
   {
      int packet_data_size = 1000; // default size
      if (start_byte + packet_data_size > cmp_size) packet_data_size = cmp_size - start_byte; // last piece is smaller

      mLog.addf(LOG_NET_stdf_packets, 0, "tx stdf piece [%d of %d] [%d to %d] st:%4d sz:%4d\n", packet_num+1, num_packets, 0, 0, start_byte, packet_data_size);

      Packet("stdf");
      PacketPut4ByteInt(0); // src frame_num
      PacketPut4ByteInt(0); // dst frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, mPlayer.loc[p].who, p);
      start_byte+=1000;
   }
}



I don't want to break the easy way I had clients go to the next level


- client join, or any time

does client have base 0,0 if not get it

Desktop Resolution: 3840x2160

Variables used to save levels in pml format

mLevel.l       : 40000
mItem.item     : 32000
mEnemy.Ef      :  6400
mEnemy.Ei      : 12800
mLift.cur      :  4480
mLift.stp      : 38400
mItem.pmsgtext :250000
------------:------
total       :384080

Variables used for netgame state exchange

mPlayer.syn         :  2304
mEnemy.Ei           : 12800
mEnemy.Ef           :  6400
mItem.item          : 32000
mItem.itemf         :  8000
mLift.cur           :  4480
mLevel.l            : 40000
mShot.p             :  1200
mShot.e             :  1200
mTriggerEvent.event :  4000
---------:------
total    :112384



mLift.stp      : 38400
mItem.pmsgtext :250000


112384
250000
 38400
-------
400,784

this is what it would take to do the entire game state, so that the client would not even need a copy of the level....
I am not pround of that 250K text file, what else could I do?

for now I just want to patch in this new method...

when the server loads a new level, it will save its base state then send that to clients..once


what will the data structure look like?


there will be one variable for the base state that gets save after server loads level
base_state

client will also use this same variable

there needs to be a way to tell if client has the base

how about a frame number associated with it?

it should be frame 0...if it is less, like -3 then it has not been loaded yet..

char base_state[STATE_SIZE];
int client_base_state_frame_num[8];

when loading level:

mNetgame.game_vars_to_state(mNetgame.base_state); // server's master base state
for (int i=0; i<8; i++) mNetgame.client_base_state_frame_num[i] = -3;

when server sends state:

when client gets state





client gets base...

client chases from zero

when it catches up and applies first state from base it dies on draw player to screen


first of all, make it stay in wait until we get a better base...

done...now it joins a lot faster, but still dies exactly like before






what gets subtratced from what??


when making a dif:
get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);


when applying a dif on client:
apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

void apply_state_dif(char *a, char *c, int size)
{
   for (int i=0; i< size; i++) a[i] -= c[i];
}


when I comment out the player draw direct to screen, the client joins, but has messed up colors for player and others...

blocks and bullets look OK

what is getting screwed up?

either I do not have the proper base, or I am not sending it properly, or, I am not decoding it properly....


lets go through everything again:

I found it!!


This is wrong:
memcpy(base_state, client_state_dif, STATE_SIZE);

This is correct:
memset(base_state, 0, STATE_SIZE);
mNetgame.apply_state_dif(base_state, client_state_dif, STATE_SIZE);


OK lets go back and put things together..



Testing...the amount of data needed increases as the game goes on...the further away from the initial state you get.
what is the busiest level?
little rocket...after a minute i'm up to 4K packets and 160kB/s
160 x 7 = 1.2MB/s



I would like to experiment with saving new client base states after a fixed amount of time. Like 1s 30s 60s etc...
how will I do that?

do I want to go back to where each client had its own base?

It seems like this method is using a lot more cpu

Am I copying a lots of states unneccesarily?

on the client I suppose I could use client_state_base like I always used to...
only now it will be set from base_state...





I have a lot of duplicated states maybe:

why can't I re-use the same ones across client and server?

I am expecially thinking of the [8][2] array

server uses it to keep 2 states for each client

why can't clients also use it?

in the interests of saving memory and being clever I am going to make it much harder to understand...lol

0 is the base
1 is the working copy

copy base from 0 to 1
apply dif to 1
1 to game state


no matter how I do it, each frame I will need to make a copy of the base and apply a dif to it...unless I just overwrite the base and lose it..

will this work?

on the server 1-7 are used
0 is used for local server state (but rewind could replace that...)

on clients 1-7 are not used...they should be...

lets do it....



old names:
   char srv_client_state[8][2][STATE_SIZE];
   int srv_client_state_frame_num[8][2];

   // local client's states
   char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
   int  client_state_buffer_pieces[16];   // to mark packet pieces as received
   char client_state_base[STATE_SIZE];    // last ack state
   int  client_state_base_frame_num;      // last ack state frame_num
   char client_state_dif[STATE_SIZE];     // uncompressed dif
   int  client_state_dif_src;             // uncompressed dif src frame_num
   int  client_state_dif_dst;             // uncompressed dif dst frame_num

   // servers master copy of base state
   char base_state[STATE_SIZE];
   int client_base_state_frame_num[8];

how many?

16 + 3 + 1 = 20



new names:

client_state[8][2]

0 = base
1 = working



[0][0] server and client base

[1-7][0] copy base here on clients then modify
[1-7][1] buffer for building compressed dif from packets

then decompress to temp and apply to 0


I could simplify like this also:

use the 2 unused slots on clients to replace 2 states

base and uncompressed...

I actually think I will be storing client base individually for each client


client_state[8][4] approx 40M

before I redo all the data structures figure out how I'm going to do that...

can I ever go back to the way it was with states...

why did i do this? because over the internet stdf freq of 1 would make me reset base a lot


I would really like to be able to switch between these 2 modes, but that might be too hard..


lets see what I can do with updating the base periodically


on the server it would be as easy as just sending a certain state and saying that it was now the new base...



right now they are all 0-100 0-101, 0-102...etc  what if I sent 100-100 and let the client know that I wanted this to be the new base...but how?

then the client would save that as the new base and reply in stak...

maybe it could be driven by the client...then client will tell the server it wants to start using a new base and from then on the server does...




Another big idea would have been to have the client store a few old states


I want to make a framework where I could do multiple algorithms..

right now task manager says I am using 150M

and 1.2Mbps Network, by my calculations I am using 140MBps so that tracks


I don't think it would be a big deal to make an state array:
client_state[8][3] approx 30M

do it...


client_state[8][3]
client_state_frame[8][3][2]

client_state[8][0] base
client_state[8][1] base copy for modifying


why?? this will make it harder to understand...


OK to start with replace base_state with

state[8][2] will replace srv_client_state[8][2]

do it...

holy shit it still compiles

replace base_state with state[0][0] on server and state[p][0] on client

done...


replace client_base_state_frame_num[8]; state_frame_num[8][0];


OK now I want to replace

   char client_state_base[STATE_SIZE];    // last ack state
   int  client_state_base_frame_num;      // last ack state frame_num

with

state[p][0];
state_frame_num[p][0];

then it will be consistant, all 0's will be base states..done


then I want to make the server uses bases for each client instead of a common one

am I circling back to where I was before?

to start with save in all clients when loading level..done

then when client sends stak...



how about on client when applying % 100 frame, save that as the next base and



I think that the server should be the one that tells the client what to save as a base


the server is always right....

how would that work?

it would have to be a state that we are no longer accepting input for...

why don't we just save a few states on the client as well

the client can have a rolling buffer like the server


suppose the client has the last 4 states received


the server will make states base on the last skip 2 states


make the server rewind thing a class and then make one for the client also

I don't really want to go from a static base, I want it to be a rolling base

what are you going to call it?



state_history
state_buffer
state_ring

mwStateHistory


loop 588

      mNetgame.game_vars_to_state(mNetgame.state[0][1]);
      mNetgame.state_frame_num[0][1] = frame_num;

      mLog.addf(LOG_NET_stdf, 0, "stdf saved server state[1]:%d\n", frame_num);

      mNetgame.game_vars_to_state(mNetgame.mStateHistory.history_state[0]);
      mNetgame.mStateHistory.history_state_frame_num[0] = frame_num;


loop 1033

      mNetgame.game_vars_to_state(mNetgame.state[0][1]);
      mNetgame.state_frame_num[0][1] = frame_num;

      mLog.addf(LOG_NET_stdf, 0, "stdf saved server state[1]:%d\n", frame_num);


      mNetgame.game_vars_to_state(mNetgame.mStateHistory.history_state[0]);
      mNetgame.mStateHistory.history_state_frame_num[0] = frame_num;





done...now on client save a history of states the server sent

like, keep the last 4 or so....


then when receiving a dif, just find the base that matches


then when sending difs, pick a base a few back from the current state...

what will all of this accomplish?
I should be able to send difs every frame, even when I have internet lag.
I will not get base resets, because I will have a few previous bases...


can I use the same state_history object for clients? I don't see why not...


when and where?

client apply dif....

should I only save to history when applied? like exact frame matches?
yes, start with that...

that was so simple, now what?

send acknowledge of last frame


I'm going to have to redo this all over again...

client getting initial state, sending staks, server sending based on staks... but now I will have some wiggle room with multiple history staks...



basically when client staks a certain frame, server can now send from that or newer....


how will it start?

back to client waiting for initial state..



change the part in program_state 21 back....

old:
      if ((mNetgame.state_frame_num[p][0] == 0) && (mLoop.frame_num > 0))
      {
         mPlayer.loc[p].client_last_stdf_rx_frame_num = frame_num + 2000; // set holdoff 200 frames in future so client won't try to drop while syncing
         mLog.add_headerf(LOG_NET_network_setup, p, 0, "Client received base state and initial state");
         state[0] = 11;
      }


original:


      if (frame_num > 0)
      {
         int p = mPlayer.active_local_player;
         // set holdoff 200 frames in future so client won't try to drop while syncing
         mPlayer.loc[p].client_last_stdf_rx_frame_num = frame_num + 200;
         state[0] = 11;
      }

done:


when the server creates a new dif to send:
it need to find an appropriate base to use...

on the server state_frame_num[p][0] should have the frame number of the last acknowledge state
it is set when receiving stak...

use this when creating a state, just like before

but where will i get the actual states from? the same place? yes for now, till something better comes up...


fixed this in serevr rx stak

//   state_frame_num[p][0] = ack_frame_num; // client has acknowledged having this base

   if (ack_frame_num == state_frame_num[p][1]) // check to make sure we have a copy of acknowledged state
   {
      // acknowledged state is new base state
      memcpy(state[p][0], state[p][1], STATE_SIZE);  // copy 1 to 0
      state_frame_num[p][0] = state_frame_num[p][1];

   }
   else // we don't have a copy of acknowledged state !!!
   {
      // see if we can find it in history...if not then reset to zero

//      memset(srv_client_state[p][0], 0, STATE_SIZE); // reset base to all zero
//      srv_client_state_frame_num[p][0] = 0;
//      mPlayer.loc[p].client_base_resets++;


   }


now I need a way to look for it in history...

//   state_frame_num[p][0] = ack_frame_num; // client has acknowledged having this base

   if (ack_frame_num == state_frame_num[p][1]) // check to make sure we have a copy of acknowledged state
   {
      // acknowledged state is new base state
      memcpy(state[p][0], state[p][1], STATE_SIZE);  // copy 1 to 0
      state_frame_num[p][0] = state_frame_num[p][1];

   }
   else // we don't have a copy of acknowledged state !!!
   {
      // see if we can find it in history...if not then reset to zero
      int indx = -1;
      for (int i=0; i<NUM_HISTORY_STATES; i++)
         if (ack_frame_num == mStateHistory.history_state_frame_num[i]) indx = i;

      if (indx > -1)
      {
         memcpy(state[p][0], mStateHistory.history_state[indx], STATE_SIZE);
         state_frame_num[p][0] = ack_frame_num;
      }
      else
      {
         memset(state[p][0], 0, STATE_SIZE); // reset base to all zero
         state_frame_num[p][0] = 0;
         mPlayer.loc[p].client_base_resets++;
      }
   }

here is the whole thing...



now that the server has that, it should be easy to make new difs...

original


   char msg[1024];
   // if last_ack_state_frame == 0 set base to all zeros
   if (srv_client_state_frame_num[p][0] == 0) memset(srv_client_state[p][0], 0, STATE_SIZE);

   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   // put current state in client's state slot 1
   game_vars_to_state(srv_client_state[p][1]);

   // put current mLoop.frame_num
   srv_client_state_frame_num[p][1] = mLoop.frame_num;

   // make a new dif from base and current
   get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);



new
         if (state_frame_num[p][0] == -3) // client does not have initial base state
         {
            char zero[STATE_SIZE] = {0};
            get_state_dif(zero, state[p][0], dif, STATE_SIZE);
            server_send_compressed_dif(p, 0, 0, dif);
         }
         else // normal dif
         {
            // make a new dif from current game state and base for this client
            char current_state[STATE_SIZE];
            game_vars_to_state(current_state);
            get_state_dif(state[p][0], current_state, dif, STATE_SIZE);
            server_send_compressed_dif(p, state_frame_num[p][0], mLoop.frame_num, dif);
         }




ok that part is done also...

now what about load level...


goddamn am I ready to try?

waiting for game state frm server....




-------------------------

20230910

yesterday I did massive 20H session.
changed all of netgame to use a single base created after level load.
it was nice, used 400 to 500 byte packets...
then I tried it on bigger, more complicated levels and it grew to 5-8K
then I though I would resend a new base ocaasionally, but that was too complex
so I ripped it all out started to implement a state history buffer on client as well
that is most done, but not quite working yet.
I also made a new class mwStateHistory that I use for both server rewind and client history


joins then dies


combine log message for rewind and save server state

I don't think I can, they happen as such different times
- rewind
- save state
- send dif

comment out the top 2 for now
combine and make server rx sdak nicer too


done...

client dies on move player??

client joins sometimes with proper cm and same on server
but position is off on client only...


could I have an issue with the server re doing states?

if I get a state from the server, could it later change?  I think it could...

do I need to separate the rewind states from the client base states?

because when rewinding I change them?

server sends dif 98-100

server later changes 98

why was this never an issue before?

because I never dipped into the rewind states to use as bases!!!

how hard will this be to implement?

it was surpisingly easy...

changed to array: mwStateHistory mStateHistory[8];
changed all times server uses it to mStateHistory[0] and client to mStateHistory[p]

client connects nicely now, but dies a few frames later....

I might be doing something wrong in client apply dif...

what are the the 2 states used for?

0 is the base
1 is the new state??

0 should not be overwritten until

in the old method it was called client_state_base
now I call it state[p][0]

I think it is the same:

first make sure base matches dif_src
then apply dif to base
the use base to set vars
the save state (which uses vars to create a new one)
then ff

the state left in base will be the base for next time
or if if does not match, look in history...


this all looks good, so what is going wrong?

it looks like the problem was the server making a new state for the next frame, but not adding 1 to frame when sending and saving

It seems to work smoothtly now...

test and monitor

this looks great on LAN cannot detect any lag...
no maxcor??
tested with 2 clients...no corrections locally and half what I normally got before for non-local client


clients quitting need to clean stuff up so they can rejoin without restarting server....
added mStateHistory[p].initialize(); to mwNetgame::reset_client_state(int p)


lets test on internet

having weird issues

server would not work on e6430 anymore, finally got server to work on scat

e6430 connected and worked good, but m36 would not

rebooted m36 and connected but it messed up the other client...

I now have tested scat server with three clients and it works
but occasionally a client will fuck up and all clients will die hard

sometimes the player colors get messed up too...

do some logging on clients and see what I can see


I found a bug in client, when applying dif, if base does not match then send newest state
it used to just try to apply it anyway...

maybe I should set it to what I have in state[p][0]...???

probably the same....


anyway, I still get crashes that kill all the clients


whatever I did this last time, I made the clients all jumpy....


clients look like they have a huge swing in dsync

dsync is all over the place

but ping is not...

I am basing this on the first stdf packet received in a frame, but maybe I should look at something else....


[28][1][47946]rx stdf piece [1 of 2] [47921 to 47942] st:   0 sz:1000
[28][1][47946]rx stdf piece [2 of 2] [47921 to 47942] st:1000 sz: 148
[28][1][47946]rx stdf piece [1 of 2] [47921 to 47943] st:   0 sz:1000
[28][1][47946]rx stdf piece [2 of 2] [47921 to 47943] st:1000 sz: 149
[28][1][47947]rx stdf piece [1 of 9] [0 to 47944] st:   0 sz:1000
[37][1][47947]timer adjust dsync[-72.81] offset[-51.70] fps_chase[31.447]
[28][1][47947]rx stdf piece [2 of 9] [0 to 47944] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47944] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47944] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47944] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47944] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47944] st:6000 sz:1000
[28][1][47947]rx stdf piece [8 of 9] [0 to 47944] st:7000 sz:1000
[28][1][47947]rx stdf piece [9 of 9] [0 to 47944] st:8000 sz: 279
[28][1][47947]rx stdf piece [1 of 9] [0 to 47945] st:   0 sz:1000
[28][1][47947]rx stdf piece [2 of 9] [0 to 47945] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47945] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47945] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47945] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47945] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47945] st:6000 sz:1000
[28][1][47947]rx stdf piece [8 of 9] [0 to 47945] st:7000 sz:1000
[28][1][47947]rx stdf piece [9 of 9] [0 to 47945] st:8000 sz: 292
[28][1][47947]rx stdf piece [1 of 9] [0 to 47946] st:   0 sz:1000
[28][1][47947]rx stdf piece [2 of 9] [0 to 47946] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47946] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47946] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47946] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47946] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47946] st:6000 sz:1000
[28][1][47948]rx stdf piece [8 of 9] [0 to 47946] st:7000 sz:1000
[37][1][47948]timer adjust dsync[-48.39] offset[-51.70] fps_chase[31.503]
[28][1][47948]rx stdf piece [9 of 9] [0 to 47946] st:8000 sz: 306
[28][1][47948]rx stdf piece [1 of 9] [0 to 47947] st:   0 sz:1000
[28][1][47948]rx stdf piece [2 of 9] [0 to 47947] st:1000 sz:1000
[28][1][47948]rx stdf piece [3 of 9] [0 to 47947] st:2000 sz:1000
[28][1][47948]rx stdf piece [4 of 9] [0 to 47947] st:3000 sz:1000
[28][1][47948]rx stdf piece [5 of 9] [0 to 47947] st:4000 sz:1000
[28][1][47948]rx stdf piece [6 of 9] [0 to 47947] st:5000 sz:1000
[28][1][47948]rx stdf piece [7 of 9] [0 to 47947] st:6000 sz:1000
[28][1][47948]rx stdf piece [8 of 9] [0 to 47947] st:7000 sz:1000
[28][1][47948]rx stdf piece [9 of 9] [0 to 47947] st:8000 sz: 290
[28][1][47949]rx stdf piece [1 of 9] [0 to 47948] st:   0 sz:1000
[37][1][47949]timer adjust dsync[-16.87] offset[-51.70] fps_chase[31.866]
[28][1][47949]rx stdf piece [2 of 9] [0 to 47948] st:1000 sz:1000
[28][1][47949]rx stdf piece [3 of 9] [0 to 47948] st:2000 sz:1000
[28][1][47949]rx stdf piece [4 of 9] [0 to 47948] st:3000 sz:1000
[28][1][47949]rx stdf piece [5 of 9] [0 to 47948] st:4000 sz:1000
[28][1][47949]rx stdf piece [6 of 9] [0 to 47948] st:5000 sz:1000
[28][1][47949]rx stdf piece [7 of 9] [0 to 47948] st:6000 sz:1000
[28][1][47949]rx stdf piece [8 of 9] [0 to 47948] st:7000 sz:1000
[28][1][47949]rx stdf piece [9 of 9] [0 to 47948] st:8000 sz: 295
[28][1][47950]rx stdf piece [1 of 9] [0 to 47949] st:   0 sz:1000
[37][1][47950]timer adjust dsync[-9.54] offset[-51.70] fps_chase[32.297]
[28][1][47950]rx stdf piece [2 of 9] [0 to 47949] st:1000 sz:1000
[28][1][47950]rx stdf piece [3 of 9] [0 to 47949] st:2000 sz:1000
[28][1][47950]rx stdf piece [4 of 9] [0 to 47949] st:3000 sz:1000
[28][1][47950]rx stdf piece [5 of 9] [0 to 47949] st:4000 sz:1000
[28][1][47950]rx stdf piece [6 of 9] [0 to 47949] st:5000 sz:1000
[28][1][47950]rx stdf piece [7 of 9] [0 to 47949] st:6000 sz:1000
[28][1][47950]rx stdf piece [8 of 9] [0 to 47949] st:7000 sz:1000
[28][1][47950]rx stdf piece [9 of 9] [0 to 47949] st:8000 sz: 305
[28][1][47950]rx stdf piece [1 of 9] [0 to 47950] st:   0 sz:1000
[28][1][47950]rx stdf piece [2 of 9] [0 to 47950] st:1000 sz:1000
[28][1][47950]rx stdf piece [3 of 9] [0 to 47950] st:2000 sz:1000
[28][1][47950]rx stdf piece [4 of 9] [0 to 47950] st:3000 sz:1000
[28][1][47950]rx stdf piece [5 of 9] [0 to 47950] st:4000 sz:1000
[28][1][47950]rx stdf piece [6 of 9] [0 to 47950] st:5000 sz:1000
[28][1][47950]rx stdf piece [7 of 9] [0 to 47950] st:6000 sz:1000
[28][1][47950]rx stdf piece [8 of 9] [0 to 47950] st:7000 sz:1000
[28][1][47950]rx stdf piece [9 of 9] [0 to 47950] st:8000 sz: 321
[28][1][47951]rx stdf piece [1 of 1] [47947 to 47951] st:   0 sz: 881
[37][1][47951]timer adjust dsync[1.61] offset[-53.12] fps_chase[32.982]
[28][1][47952]rx stdf piece [1 of 1] [47948 to 47952] st:   0 sz: 886
[37][1][47952]timer adjust dsync[22.51] offset[-53.12] fps_chase[33.743]
[28][1][47953]rx stdf piece [1 of 1] [47951 to 47953] st:   0 sz: 859
[37][1][47953]timer adjust dsync[24.26] offset[-53.12] fps_chase[39.380]
[28][1][47953]rx stdf piece [1 of 1] [47951 to 47954] st:   0 sz: 892
[28][1][47955]rx stdf piece [1 of 1] [47952 to 47955] st:   0 sz: 902
[37][1][47955]timer adjust dsync[26.58] offset[-53.12] fps_chase[43.524]
[28][1][47955]rx stdf piece [1 of 1] [47952 to 47956] st:   0 sz: 904
[28][1][47957]rx stdf piece [1 of 1] [47954 to 47957] st:   0 sz: 852
[37][1][47957]timer adjust dsync[23.39] offset[-53.12] fps_chase[44.486]
[28][1][47958]rx stdf piece [1 of 1] [47954 to 47958] st:   0 sz: 881
[37][1][47958]timer adjust dsync[19.36] offset[-53.12] fps_chase[45.163]
[28][1][47959]rx stdf piece [1 of 1] [47954 to 47959] st:   0 sz: 899
[37][1][47959]timer adjust dsync[17.45] offset[-53.12] fps_chase[45.506]
[28][1][47960]rx stdf piece [1 of 1] [47957 to 47960] st:   0 sz: 832
[37][1][47960]timer adjust dsync[15.31] offset[-53.12] fps_chase[45.755]
[28][1][47961]rx stdf piece [1 of 1] [47958 to 47961] st:   0 sz: 871
[37][1][47961]timer adjust dsync[6.87] offset[-53.12] fps_chase[45.807]
[28][1][47962]rx stdf piece [1 of 1] [47959 to 47962] st:   0 sz: 840
[37][1][47962]timer adjust dsync[8.93] offset[-53.12] fps_chase[45.671]


OK this still might be an issue but the dying still happens....why??


I think it is only a client thing, the server just keeps going


see if I can catch it in move or draw or program state...

now that I enabled move I see a huge square wave from -45 to -70 in the sync graph, but it did not die!!
ping is -30 to -35 approx

it died after move eshots
it died after move players

it has over 100% cpu when it dies

when move only is on I get spikes in dsync


I think the logging to console is causing weird timing shit....

but the crashing happens even with no logging....


This is so weird... when I stand by a bonus, without picking it up, it flickers back and forth, but only on client

what the hell??


maybe it is something on the server...


on the server:
tx stdf 1700 1702
rx stak 1701 1703

which is right?




real example:

server side:


350 rx stak 348 351
350 tx stdf 348 351

351 rx stak 350 352
351 tx stdf 350 352

352 rx stak 350 353
352 tx stdf 350 353

353 rx stak 351 354
353 tx stdf 351 354


why am I getting a reply before I send?

client side:

[30][1][354]--- Client Apply Dif [348 to 351] ---
[30][1][354]Found matching base in history
[30][1][351]dif [348 to 351] applied - rewound [3] frames

[30][1][355]--- Client Apply Dif [350 to 353] ---
[30][1][355]Found matching base in history
[30][1][353]dif [350 to 353] applied - rewound [2] frames

[30][1][356]--- Client Apply Dif [350 to 353] ---
[30][1][356]Found matching base in history
[30][1][353]dif [350 to 353] applied - rewound [3] frames

[30][1][357]--- Client Apply Dif [351 to 354] ---
[30][1][357]Found matching base in history
[30][1][354]dif [351 to 354] applied - rewound [3] frames




On the server, why do I get a reply stak, before I send the stdf...this makes no sense at all...

Other than that, the frame numbers seem to make sense..
server sends on frame 350, but the dif destination is one more 351 because it is the base for the next frame
server uses base 348...why?...because the last stak (also on frame 350) acknowledges 348

On the client:
On frame 354 the dif is applied
client had base 348 in history, applied dif get to frame 351, then ff 3 frames
then somehow it sent stak that arrived and was logged on server before sending initial stdf


I is rock solid on LAN with m36 as server

what if I tried TCP?
had 4230 take up 150% cpu
cant reproduce, maybe base resets?
cpu   TCP UDP
m36   16  14
e6430 11  11
4230  45 44

so all looks good on LAN even with TCP

I want to see if the server does the out of order stuff...

back to UDP also

[33][1][382]rx stak d[-20.1] c[40.0] a:382 c:383 ack state = state[p][0]
[27][0][382]tx stdf p:1 [src:382 dst:383] cmp:606 ratio:0.54 [1 packets needed]

[33][1][383]rx stak d[-20.2] c[40.0] a:383 c:384 ack state = state[p][0]
[27][0][383]tx stdf p:1 [src:383 dst:384] cmp:610 ratio:0.54 [1 packets needed]

[33][1][384]rx stak d[-20.2] c[40.0] a:384 c:385 ack state = state[p][0]
[27][0][384]tx stdf p:1 [src:384 dst:385] cmp:641 ratio:0.57 [1 packets needed]

I just realized I made a mistake and this is nothing!!  I think...

frame 382 stak 382
frame 382 stdf 382-383

frame 383 stak 383
frame 383 stdf 383-384


so back to why stuff is fucking up on WAN...

I don't know?  Is that an answer? Yes, but not very useful....

how about turn on lots of logging and try....it doesn't save when it crashes...damn...


ok look up your notes for running debugger...


on client the shuddering is probably due to corrupted states


so add some logging to figure that out...



where does it hook into history?


void mwNetgame::client_apply_dif(void)

      for (int i=0; i<NUM_HISTORY_STATES; i++) if (client_state_dif_src == mStateHistory[p].history_state_frame_num[i]) indx = i;
      if (indx > -1)
      {
         mLog.addf(LOG_NET_dif_applied, p, "Found matching base in history\n");
         memcpy(state[p][0], mStateHistory[p].history_state[indx], STATE_SIZE);
         state_frame_num[p][0] = client_state_dif_src;

   // save to history
   mStateHistory[p].add_state(mLoop.frame_num);



what can I do?



I think it is unnecasiraly complex to use state[p] for clients previous state...especially now that I have state history

lets see if I can do without it....

on client when I need that I will just query the class and it will tell me the most current base

how about a function that gets you the most recent base


void get_most_recent_base(char * base, int * frame_num)


actually I don't want most recent base...I just want a base that matches or zero

1 line....

   mStateHistory[p].get_base_state(base, base_frame_num, int frame_num);


that really simplified a lot of things on the client....

now how about I kill it all on the server also?...done



I have now freed up the 16 states I used to use...

//   // server's copies of client states
//   char state[8][2][STATE_SIZE];
//   int state_frame_num[8][2];


I still have 4 x 8 in history though...


It seem to work OK...why do I have constant base resets??

void mwStateHistory::get_most_recent_state(char* base, int& base_frame_num)

need to fill in this function...


now having problems with initial state...

it looks like I got muliple complete difs before apply is called...call it from decompress also..done


now I randomly have issues with player going active at join...


server lock works and sets the player active

but for some reason that does not make it back to the client


what if I skip the whole chase and lock thing...i don't use it at level done...


can I make a hotkey to force reset base?

am I adding properly on the client, not replacing existing, but oldest...

I am replacing frame num if it exists and I think that is correct...



My big concern right now is:

Why do I have differences between server and client states? player array....

am i not saving things properly?

do I have wrong bases on server or client?

that is why I want to force re base from zero


but how can I do that?

what if client sends stak with zero?

that should make server rebase from zero, but it probably doesn't


what if server sends with src zero....
that should make client load zero base, apply and save as a new state....

the good news is that initializing state history on the server for 1-7 fixed the weirdness

the bad news is that weirdness is happening....

20230910 10:37 PM

push....


next I want to figure out that weirdness
show what is happening with the history, how wide they are and where I get hits.
see if I can minimize the size of history
see if I can reduce copying of states
test all that is broken

20230911

Muliplayer looks great

I can't even detect any local corrections on clients, even over the internet..

Non local clients are still jumpy

When client is playing ahead it assumes that the other players controls are never active
I could try to predict that the controls will stay the same as they were when the state arrived....
but that would not be accurate....



class mwStateHistory

I want a variable that always has the highest frame number, the lowest frame number and indexes to both

I also want be be able to just get pointers to states instead of making copies


when is the only time that the contents of state history are changed?

initialize and add...

at that time update the variables

   newest_state_frame_num = -1;
   newest_state_frame_index = -1;
   newest_state_pointer = NULL;

   oldest_state_frame_num = -1;
   oldest_state_frame_index = -1;
   oldest_state_pointer = NULL;


here are the rules:

when initialized they have this state:

   newest_state_frame_num = -1;
   newest_state_frame_index = -1;
   newest_state_pointer = NULL;

   oldest_state_frame_num = -1;
   oldest_state_frame_index = -1;
   oldest_state_pointer = NULL;

as soon as one is added they both are set to that...

oldest will never be -1 unless there are no other valid states



I have patched it in for server rewind and it works...the old method made a copy...new method uses the char pointer


now I am looking at: server_send_dif(int frame_num)
if I use pointer here, I will not have the base anymore

I think I should leave this one??

for now


while I am at is I would like to have the class have a values for the last stak state from a client...
used only by server...

what do I use now?

I think I might have found the bug....

server uses most recent and assumes that is the last ack, but it may not be


added:

   int last_ack_state_frame_num;
   int last_ack_state_index;
   char * last_ack_state;

all this works...

now all of server should use the new stuff...


now how about client?

done...



I have now patched all this in and it looks much cleaner, and seems to work...

now test on internet...

client sync is way off like -200??

why?


look at logs...

the server is getting stak, but still sending from zero...

make some logging to see if it is missing the match...


server never adds anything to clients state history....

found the bug in add...

Test Game level 64 on server scat (internet)


now I am playing 8 player game over the internet with a reported ping of 35
7 clients all with fakekey
approx 300kB/s

server is scat and has approx 35% cpu
client m36 has approx 7% cpu
client e6430 has approx 20% cpu
client 4230 have 60-80% but 29(jj) has closer to 100

clients local maxcor is always 0 and is beautiful to play locally
clients non local maxcor can go up to 24 and is quite jumpy

clients crwd is 2-3
gmav 20-40

between 1-2 packets (mostly 1 but sometimes 2)

a few late cdats


e6430 tried manually setting offest to -10 (from -55 auto)
now on e6430 other clients have maxcor of 7 and local player has12 mostly
about the same maxcor on other clients


This is a huge milestone..stuff is working great and it looks simpler...

clean up code a bit and push

done


added good documentation to each function in mwHistory

test some next level stuff

I just played a game where it all got screwed up again

reset base all the time, client sync -200 -400


I can reproduce...

scat server, internet, 8 clients join, do one level done at least to level 64
all fake key, after 1 min:
constant base resets
sync -200 to -300
ping 300-400

resetting base to zero on client or server does not fix...

are base resets the cause or is bad sysnc the cause?



some more data...
when it happens, all clients have constant base resets and cdsy -250 to -270
could this mean is is something on the server, is all clients have the same issue??


one nice thing, since I implemented state history, clients almost always have zero local corrections
even if they rewind a lot, like 12 frames.
I think this is because the local moves always make it to the server and are validated.
But the other clients still have corrections that get a lot worse the more they need to rewind...

so, what could be wrong that is causing this?

turn on a lots of logging and look....


happened around 4:00

on client:

what the hell happened?

why did this dif get applied so many times?

[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames


and also why does everydif get applied more that once...

apply dif is called from stdf and also once everyframe

this is OK maybe, is it needed to be called from stdf, I thought that was needed for join
see if I can remove that one....I did and still seems to join fine



also make it so that apply_dif does not try to do the same dest more than once??

can I do that? yes, i think so, server will never send a dif then send an older one
client should never apply a dif with a dest older than one it has already applied....

but also, why does having it applied again and again cause bigger rewinds?


[30][1][9506]--- Client Apply Dif [9499 to 9503]dif [9499 to 9503] applied - rewound [3] frames
[30][1][9506]--- Client Apply Dif [9499 to 9503]dif [9499 to 9503] applied - rewound [3] frames
[27][1][9507]rx dif complete [9501 to 9504] dsync[-57.4ms] - uncompressed
[30][1][9507]--- Client Apply Dif [9501 to 9504]dif [9501 to 9504] applied - rewound [3] frames
[30][1][9507]--- Client Apply Dif [9501 to 9504]dif [9501 to 9504] applied - rewound [3] frames
[27][1][9508]rx dif complete [9503 to 9505] dsync[-57.4ms] - uncompressed
[30][1][9508]--- Client Apply Dif [9503 to 9505]dif [9503 to 9505] applied - rewound [3] frames
[30][1][9508]--- Client Apply Dif [9503 to 9505]dif [9503 to 9505] applied - rewound [3] frames
[27][1][9509]rx dif complete [9503 to 9506] dsync[-57.9ms] - uncompressed
[30][1][9509]--- Client Apply Dif [9503 to 9506]dif [9503 to 9506] applied - rewound [3] frames
[30][1][9509]--- Client Apply Dif [9503 to 9506]dif [9503 to 9506] applied - rewound [3] frames
[27][1][9510]rx dif complete [9505 to 9507] dsync[-57.7ms] - uncompressed
[30][1][9510]--- Client Apply Dif [9505 to 9507]dif [9505 to 9507] applied - rewound [3] frames
[30][1][9510]--- Client Apply Dif [9505 to 9507]dif [9505 to 9507] applied - rewound [3] frames
[27][1][9511]rx dif complete [9505 to 9508] dsync[-59.5ms] - uncompressed
[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames
[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames
[30][1][9512]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [4] frames
[30][1][9513]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [5] frames
[30][1][9514]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [6] frames
[30][1][9515]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [7] frames
[30][1][9516]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [8] frames
[30][1][9517]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [9] frames
[30][1][9518]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [10] frames
[30][1][9519]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [11] frames
[30][1][9520]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [12] frames
[30][1][9521]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [13] frames
[30][1][9522]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [14] frames
[30][1][9523]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [15] frames
[30][1][9524]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [16] frames
[30][1][9525]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [17] frames
[30][1][9526]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [18] frames
[30][1][9527]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [19] frames
[30][1][9528]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [20] frames
[30][1][9529]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [21] frames
[30][1][9530]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [22] frames
[30][1][9531]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [23] frames
[30][1][9532]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [24] frames
[30][1][9533]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [25] frames
[27][1][9534]rx dif complete [9507 to 9509] dsync[-623.2ms] - uncompressed
[30][1][9534]--- Client Apply Dif [9507 to 9509]dif [9507 to 9509] applied - rewound [25] frames
[27][1][9534]rx dif complete [9508 to 9510] dsync[-623.2ms] - uncompressed
[30][1][9534]--- Client Apply Dif [9508 to 9510]dif [9508 to 9510] applied - rewound [24] frames
[30][1][9534]--- Client Apply Dif [9508 to 9510]dif [9508 to 9510] applied - rewound [24] frames
[27][1][9535]rx dif complete [9508 to 9511] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9511]dif [9508 to 9511] applied - rewound [24] frames
[27][1][9535]rx dif complete [9508 to 9512] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9512]dif [9508 to 9512] applied - rewound [23] frames
[27][1][9535]rx dif complete [9508 to 9513] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9513]dif [9508 to 9513] applied - rewound [22] frames
[27][1][9535]rx dif complete [9508 to 9514] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9514]dif [9508 to 9514] applied - rewound [21] frames
[27][1][9535]rx dif complete [9508 to 9515] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9515]dif [9508 to 9515] applied - rewound [20] frames
[27][1][9535]rx dif complete [0 to 9527] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [0 to 9527]dif [0 to 9527] applied - rewound [8] frames
[30][1][9535]--- Client Apply Dif [0 to 9527]dif [0 to 9527] applied - rewound [8] frames
[27][1][9536]rx dif complete [0 to 9528] dsync[-182.3ms] - uncompressed
[30][1][9536]--- Client Apply Dif [0 to 9528]dif [0 to 9528] applied - rewound [8] frames
[30][1][9536]--- Client Apply Dif [0 to 9528]dif [0 to 9528] applied - rewound [8] frames
[27][1][9537]rx dif complete [0 to 9529] dsync[-167.8ms] - uncompressed
[30][1][9537]--- Client Apply Dif [0 to 9529]dif [0 to 9529] applied - rewound [8] frames
[30][1][9537]--- Client Apply Dif [0 to 9529]dif [0 to 9529] applied - rewound [8] frames
[27][1][9538]rx dif complete [0 to 9530] dsync[-166.6ms] - uncompressed


make sure all clients do things the same
now they do not have any repeats



7:20 = 7 * 60 + 20 = 440 * 40 = 17600

[27][1][17640]rx dif complete [17634 to 17637] dsync[-60.1ms] - uncompressed
[30][1][17640]--- Client Apply Dif [17634 to 17637]dif applied - rewound [3] frames
[27][1][17641]rx dif complete [17635 to 17638] dsync[-60.1ms] - uncompressed
[30][1][17641]--- Client Apply Dif [17635 to 17638]dif applied - rewound [3] frames
[30][1][17642]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17643]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17644]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17645]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17646]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17647]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17648]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17649]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17650]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17651]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17652]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17653]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17654]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17655]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17656]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17657]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17658]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17659]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17660]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17661]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17662]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17663]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[27][1][17664]rx dif complete [17636 to 17639] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17640] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17641] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17642] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17643] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17644] dsync[-606.8ms] - uncompressed
[30][1][17664]--- Client Apply Dif [17637 to 17644]dif applied - rewound [20] frames
[27][1][17665]rx dif complete [0 to 17660] dsync[-101.4ms] - uncompressed
[30][1][17665]--- Client Apply Dif [0 to 17660]dif applied - rewound [5] frames
[27][1][17666]rx dif complete [0 to 17661] dsync[-97.5ms] - uncompressed
[27][1][17666]rx dif complete [0 to 17662] dsync[-97.5ms] - uncompressed
[30][1][17666]--- Client Apply Dif [0 to 17662]dif applied - rewound [4] frames
[30][1][17667]--- Client Apply Dif [0 to 17662] not newer than last dif applied
[27][1][17668]rx dif complete [0 to 17663] dsync[-96.5ms] - uncompressed
[27][1][17668]rx dif complete [0 to 17664] dsync[-96.5ms] - uncompressed
[30][1][17668]--- Client Apply Dif [0 to 17664]dif applied - rewound [4] frames
[27][1][17669]rx dif complete [17660 to 17665] dsync[-83.3ms] - uncompressed
[27][1][17669]rx dif complete [17662 to 17666] dsync[-83.3ms] - uncompressed
[27][1][17669]rx dif complete [17662 to 17667] dsync[-83.3ms] - uncompressed
[30][1][17669]--- Client Apply Dif [17662 to 17667]dif applied - rewound [2] frames
[27][1][17670]rx dif complete [17662 to 17668] dsync[-24.9ms] - uncompressed
[27][1][17670]rx dif complete [17667 to 17669] dsync[-24.9ms] - uncompressed
[30][1][17670]--- Client Apply Dif [17667 to 17669]dif applied - rewound [1] frames
[27][1][17671]rx dif complete [17667 to 17670] dsync[-24.7ms] - uncompressed
[30][1][17671]--- Client Apply Dif [17667 to 17670]dif applied - rewound [1] frames
[27][1][17672]rx dif complete [17667 to 17671] dsync[-14.6ms] - uncompressed
[30][1][17672]--- Client Apply Dif [17667 to 17671]dif applied - rewound [1] frames

what the hell does this look like on the server?


looks like the stdf's were sent on the proper frames....

for some reason they did not arrive for 64-41 - 23 frames * 25ms = 575ms


this could be just a network hiccup...now netgame looks like it will survive it....

I have also reduced a lot of extra apply dif on clients


bump version and push..done


it seems to work now

can I do anything on the server to reduce cpu usage?


do I care?

what was I testing before?

what happens when reducing client offset in a netgame
local maxcor gets worse, but nonlocal???


tried playing on LAN and I think maxcor get better when changing offset from -20 to +5

I want to experiment more with this...


maybe I can reduce offset by one rewind overall, LAN and internet....






server reduce state copying, etc....

do I need to keep a state for each clients base?
or can I just find the ones I want in rewind?

I used to think I needed to keep them separate, but they are all based on the same time...
made at the end of the frame base for next frame


what will this get me?






I've been thinking....

I think I have way more states than I need.

I could probabaly use just one instance of state history...


right now:
client only uses their own numbered instance

when client applies a dif:
gets base from history
appies dif
adds new state to history
sends ack

client never touches anything else in history


server uses 0 for rewind states
server keeps individual history for each client, but I am thinking it could just use the main history


server will still need to keep track of last ack state for each client, but it can do it by just keeping track of the frame number


this will save on the number of states I will need to keep in memory by a factor of 8...
and I don't think it will make the algorithm less intuitive...


If I do this, I will only have one instance of mStateHistory


I will want to add an array like last_ack_frame_num[8]
both server and client will use it
it will indictate a frame_number matching a state in history

this is a big change....



what do I have to do to client?
when it applies a dif, find base from main history instead of particular, then save the new state in the main history...
that should be all that is needed to modify client





what do I have to do to add?

I am going to implement this

step 0 change array to single and fix all refs..done

client:
mStateHistory.get_base_state(base, base_frame_num, client_state_dif_src)
mStateHistory.add_state(mLoop.frame_num);
no changes needed...

server:

server_rewind

no changes..

wait a minute here, could server rewind change frames in history that I am using for client bases?

server rewind to 100
ff to 108 redoing all those states
sends 108 to all clients

back it all up, I am not going to do this....done


So now I am back to where I was before...looking for optimizations to avoid unnecsary state copying



this part here on client.....

makes a copy to modify, can it just overwrite the original?
do I need to keep it?
i don't know...

   // now check if we have a base state that matches dif source
   char base[STATE_SIZE] = {0};
   int base_frame_num = 0;

   // finds and sets base matching 'client_state_dif_src' -- if not found, leaves base as is (zero)
   mStateHistory[p].get_base_state(base, base_frame_num, client_state_dif_src);

   if ((base_frame_num == 0) && (client_state_dif_src != 0))
   {
      int fn = mStateHistory[p].newest_state_frame_num;
      mLog.appf(LOG_NET_dif_not_applied, "[not applied] [base not found] - resending stak [%d]\n", fn);
      client_send_stak(fn);
      return;
   }

// called when client needs a base state to apply a dif to
// searches for a match for passed frame_num
void mwStateHistory::get_base_state(char* base, int& base_frame_num, int frame_num)
{
   if (frame_num == 0) return; // base 0 leave as is
   int indx = -1;
   for (int i=0; i<NUM_HISTORY_STATES; i++) if (frame_num == history_state_frame_num[i]) indx = i;
   if (indx > -1)
   {
      //memcpy(base, history_state[indx], STATE_SIZE);
      base = history_state[indx];
      base_frame_num = history_state_frame_num[indx];
   }
}

-----------

ok I want to leave the optimization for now....

test the goodliness that I now have....

what am I trying to test and measure?

mostly non local maxcor, experimenting with lowering client offset in both LAN and internet games

do a bunch of tests




server:scat
level:64
clients: m36, e6430
network:LAN

ping:0
sync:-20
crwd:1
gmav:40
local maxcor:0
remote maxcor:7

ping:0
sync:+5
crwd:0
gmav:17
local maxcor:0
remote maxcor:1.7 (rarely 3)

this looks better...



network:WAN

ping:30
sync:-50
crwd:2-3
gmav:40
local maxcor:0
remote maxcor:18

ping:30
sync:-20
crwd:1
gmav:12
local maxcor:0
remote maxcor:7


ping:30
sync:+5
crwd:0
gmav:-12
local maxcor:7-12
remote maxcor:7
no bullet sound on server...



----------------

new test setup:
server:scat
level:64 (locked in small area all shooting each other)
clients: m36, e6430, 5x4230
network:WAN

ping:30
sync:-50
crwd:2-3
gmav:40
local maxcor: mostly 0, sometimes 10
remote maxcor:12-18

ping:30
sync:-20
crwd:1
gmav:8-14 (rarely -2)
local maxcor: 0, sometimes 6
remote maxcor:6-12


network:LAN

ping:0
sync:-20
crwd:1
gmav:40
local maxcor:0 (rarely 7)
remote maxcor:7 (rarely 12)

ping:0
sync:+5
crwd:0
gmav:10-15
local maxcor:0 (rarely 5)
remote maxcor:0-6


this looks very playable...

so how should I set offset automatically?

add 5 to ping instead of -20?
try to get crwd == 1?


I have set it to +10, auto...lets see how that works....

network:LAN

ping:0
sync:+10
crwd:0
gmav:9-12
local maxcor:0 (rarely 4)
remote maxcor:6

network:WAN

ping:35
sync:-22
crwd:1-2
gmav:4-15
local maxcor:6 (rarely 12)
remote maxcor:12-18

seems to work OK







-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
look into how often I send stdf, do I ever want it to be less than every frame?
probably not, but I should I test, before removing....
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------

network:WAN
s1 = 2
ping:35
sync:-22
crwd:1-2
gmav:4-15
local maxcor:6 (rarely 12)
remote maxcor:12-18 (rarely 33)

seems to work OK
not as good as 1




client offset

I don't like it when it is set close to a muliple of 25...then crwd bounce between 2 numbers
should be well on one side or another...but how to do this?


force discreet values like +12, -13, -38, -63 ....

then get a range of pings that put it in a group

I could still have an issue where that range check is causing oscillation between 2 discreet values....

ping   offset
0-20   +12
20-45  -13
45-60  -38

basically I want the discreet values to be in the center of the range where crwd changes

testing...

offset crwd
0      0-1
-25    1-2



what would happen if I always had the clients at +10?
I envision that would mean that they get the dif on exactly the frame they need it on


show when reads to history happens
on client it is like crwd, only crwd is for dif dst, this wil be for dif src base lookup

on srvr for each client when making dif how far back do we need to go to get last ack base

on server for rewind it is fixed and always goes back the maximum amount
I would like to have a method of dirty frame and only go back that far...



on server, after rewind and make new dif, set dirty frame to current frame

then whever rxing cdat check if earlier than dirty frame and set dirty frame

then when rewinding only rewind to dirty frame...


implemented and made a new method in mwHistory to do this, now only one line needed in rewind...




// used by server to apply a rewind state that matches sent frame number
// does nothing if:
// sent frame_num less than 1
// sent frame_num is the same as current frame
// if sent frame is not found in history, use oldest frame (if valid)

void mwStateHistory::apply_rewind_state(int frame_num)
{
   if (frame_num < 1) return;

   // how many frames to rewind and replay
   int ff = mLoop.frame_num - frame_num;

   // if same frame as current frame, do nothing
   if (ff == 0)
   {
      mLog.addf(LOG_NET_stdf, 0, "stdf rewind [none]\n");
      return;
   }

   // find index of matching frame
   int indx = -1;
   for (int i=0; i<NUM_HISTORY_STATES; i++) if (frame_num == history_state_frame_num[i]) indx = i;


   if (indx == -1)
   {
      mLog.addf(LOG_NET_stdf, 0, "stdf rewind [%d] not found - ", frame_num);
      indx = oldest_state_index;
      if (indx == -1) mLog.app(LOG_NET_stdf, "oldest frame not valid\n");
      else mLog.appf(LOG_NET_stdf, "using oldest frame [%d]\n", history_state_frame_num[indx]);
   }

   if (indx > -1)
   {
      mLog.addf(LOG_NET_stdf, 0, "stdf rewind to:%d [%d]\n", frame_num, -ff);

      mNetgame.state_to_game_vars(history_state[indx]);
      mLoop.frame_num = history_state_frame_num[indx];

      // fast forward and save rewind states
      for (int i=0; i<ff; i++)
      {
         mLoop.loop_frame(1);
         add_state(mLoop.frame_num);
      }
   }
}





void mwNetgame::server_rewind(void)
{
   double t0 = al_get_time();
   if (mLoop.frame_num >= mStateHistory[0].newest_state_frame_num + server_state_freq - 1) // is it time to create a new state?
   {
      // save values we don't want rewound
      int lcd[8][2] = { 0 };
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            lcd[pp][0] = mPlayer.syn[pp].late_cdats;
            lcd[pp][1] = mPlayer.syn[pp].late_cdats_last_sec;
         }
//      mStateHistory[0].apply_rewind_state(mStateHistory[0].oldest_state_frame_num);
      mStateHistory[0].apply_rewind_state(server_dirty_frame);

      // restore values we don't want reset
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            mPlayer.syn[pp].late_cdats = lcd[pp][0];
            mPlayer.syn[pp].late_cdats_last_sec = lcd[pp][1];
         }
      mPlayer.loc[0].server_send_dif = 1; // set flag to create and send dif at the end of this frame
   }
   mLog.add_tmr1(LOG_TMR_rwnd, 0, "rwnd", al_get_time() - t0);
}




now I would like to know how far back the server has to rewind, this will show me how late the cdats are arriving

I can call it server_rewind or something like that, where will I store it?, does not need to be in player struct...


I'm thinkg of using this:

int client_rewind; // for client to keep track of how many frames it needed to rewind

rename to just rewind and use 0 for server....

done...

now show it in server_debug_grid

then have client send to server in stak


I think this is all working...

when playing an internet game, the server almost never rewinds....
ping 23
dsync -13
crwd 1
srnd 0

making client sync more negative -50 -100 still server does not rewind
only by making client sync more postive does the server rewind occasionally hit...

I am amazed at how close they both are are to zero

I think all this is working good...



now I would like to figure out how to send maxcor from client to server

client has 8 values, one for each player

I would like to send instanatneous values with stak...

but I have 8...

maybe I could send local_


I think I will make 2 things:

local_cor
remote_cor

each time client applies dif, I will calc these

these will not be max, they will be just the instantanous value for that frame


should I make a place in the array to save them, the loc array?

client_local_player_state_correction
client_remote_player_max_state_correction

done...

now how to show in debug_grid...
get max for last sec
use tally..done

make common place to do tallies for server...


mwTally mTally_client_local_player_state_correction_last_sec[8];
mwTally mTally_client_remote_player_max_state_correction_last_sec[8];


these variable names are getting out of hand

client_loc_plr_cor
client_rem_plr_cor

this looks better...


now send them with stak...

good, now I have that on server also....

clean up some stuff in debug array..

server don't show p0 for cdsy, gmav, sgms, base, lcdt, ldls, stsy

fix base reset counter...done...


I would like to do some more tests, but I want to be able to run netem easily...

start documenting it...done


now do some tests with netem to make network worse

I really want to know what some of the thing I measure mean, like:

sgms
stsy
gmav

server:scat
stdf freq:1
level:64
8 players all with fakekey
internet ping (from a client) (27-30)
offset mode: ping +10

added delay with netem:0
actual client ping:(27-30)

cdsy:-15 to -20
srwd:0-1
crwd:1
lcrm:0-12
lcra:0.1
rcrm:8-12
rcra:4
sgms:0
stsy:6-18
gmav:5-13


added delay with netem:10 (20)
actual client ping:(47-50)

cdsy:-37 to -40
srwd:0-2
crwd:2
lcrm:0-22
lcra:0.5 - 1
rcrm:12-22
rcra:6-8
sgms:0 to -1
stsy:6-18
gmav:-10 to 14



added delay with netem:20 (40)
actual client ping:(71-75)

cdsy:-60 to -65
srwd:0-3
crwd:3
lcrm:0-22
lcra:1-3
rcrm:18-25
rcra:9-10
sgms:0 to -1
stsy:6-18
gmav:-10 to 14





added delay with netem:30 (60)
actual client ping:(85-90)

cdsy:-80 to -95
srwd:0-3 (hard to tell)
crwd:3-4
lcrm:0-26
lcra:0-4
rcrm:24-33
rcra:9-16
sgms:0 to -1
stsy:6-18
gmav:-10 to 14





offset mode: +10 (manual, no ping)
added delay with netem:10
actual client ping:(27-30)

cdsy: 10
srwd:1-2
crwd:0
lcrm:0-12
lcra:0-2
rcrm:7-11
rcra:3-4


added delay with netem:10 (20)
actual client ping:(47-50)

cdsy: 10
srwd:2
crwd:0
lcrm:0-18
lcra:2-3
rcrm:12-18
rcra:5-8



added delay with netem:20 (40)
actual client ping:(66-67)

cdsy: 10
srwd:3
crwd:0
lcrm:0-24
lcra:4-5
rcrm:18-30
rcra:5-8

I broke the game!!!
all clients are base resetting every frame
I think it happened after a large network freeze
pings are 275-300 for all clients

they all still have cdsy of 10

I do not know what caused this and what I can do to fix it....
was the pause big enough that the history buffer ran out...

is the whole problem based on the client not chasing to proper frame?

forced resetting base on server or client does nothing...

client quits and rejoins, still has huge ping...

its look like a server thing

what if I remove the netem? from 20 to 0  (40 to 0)
pings are now all 225-250 from 275-300

what on the server could be causing this?

























remove client ping flag, now it just sends once per second like other 1Hz stuf and that should be fine...
also png_timer
done

remove old maxcor and use only new..done







































-----------------------------------------------------------
Now I would like to experiment with different offsets...
-----------------------------------------------------------
I would like a way for the server to tell the client what to use??
would I really now?
how would I do that?
make it part of the player syn

reuse stdf freq change controls on server

what variables?


right now I am still doing + 10 from ping

I never measured what +10 with no ref to ping would do...try that





timer adjust uses strictly this value:

client_chase_offset;   // set point


in fast packet loop when rx pong

         // adjust client chase offset based on ping
         if (client_chase_offset_mode) // auto mode
         {
            client_chase_offset = - mPlayer.loc[p].ping_avg + client_chase_offset_auto_offset;
         }
         else
         {
            //mPlayer.loc[p].client_chase_offset = mPlayer.loc[p].client_chase_offset_auto_offset;
         }



netgame.h

   double client_chase_offset = 0.0;
   double client_chase_offset_auto_offset = -0.02;
   int client_chase_offset_mode = 1; // 0 = manual, 1 = auto


what if I made another mode?
2 - get offset from server
and made it so that the mode was saved in config


still timer adjust would always only use client_chase_offset

when receiving pong if in mode 1, then adjust client_chase_offset

so far this is still how it is already

adjustments in screen overlay are good, manual adjusts directly, auto adjusts the auto_offset

make the mode button also do mode 2 server direct control..done

make it so that the mode is saved in config
actually, save all three...done

now, where to set server


in manual mode it gets the value from config and is only ever changed with buttons
in auto mode it is adjusted when rx pong

in server mode??

how about in timer adjust, just copy from server p0..done

add to syn..done

modify server controls to change it...done

make it so that server rewind does not restore it...done...

now I have control over all clients offset from server

what am I going to do with this?

I have a nasty bug that I want to fix

it just happened again...

what can I do to reproduce it?


8P netgame LAN
forced offset 10

It seems to happen with huge network freezes

but what causes that? and how can I work with it?

make the samba share work again with scat so I can get logs..doesn't work over internet...duh

reproduced with server logging stdf and stak
all i can tell is:
server tx stdfs every frame all based from zero
server rx stak, but they are 10-11 frames old

this could be just a side effect of the client getting stuck too far behind...

lets look in the logs there...

another reproduction...
netem 40 (80)


started at frame 9650 on server
before that tx stdf the rx stak approx 4 frame earlier
after that it still shows it sent stdf every frame, but did not get a stak reply until frame 9677 (27 frames later)

also strange is that it sent stdf for frames 50, 51, 52 based on 46, but then after that starting sending stdf based on zero...
this seems strange because it did this without getting a stak....

looking at this code:

it looks like saving the current state is pushing out the valid base
this may not be optimal, but I don't think it is what is causing the issues....
at the worst, it should trigger a base reset and recover

void mwNetgame::server_send_dif(int frame_num) // send dif to all clients
{
  for (int p=1; p<NUM_PLAYERS; p++)
      if ((mPlayer.syn[p].control_method == 2) || (mPlayer.syn[p].control_method == 8))
      {
         // save current state in history as base for next clients send
         mStateHistory[p].add_state(frame_num);

         char base[STATE_SIZE] = {0};
         int base_frame_num = 0;

         // get client's most recent base state (the last one acknowledged to the server)
         // if not found, leaves base as is (zero)
         mStateHistory[p].get_last_ack_state(base, base_frame_num);

         if (base_frame_num == 0) mPlayer.loc[p].client_base_resets++;

         // make a new dif from base and current
         char dif[STATE_SIZE];
         get_state_dif(base, mStateHistory[p].newest_state, dif, STATE_SIZE);

         // break into packet and send to client
         server_send_compressed_dif(p, base_frame_num, frame_num, dif);
      }
}



now lets look on the client

frame 9646 rx stdf from 9641-9646
then the next stdf was rx'd at 9672

the big gap matches up...

after the big gap

it now has a dysnc of -600 and starts adjusting itself

I don't think the dsync value is correct

how is it calculated again?


void mwNetgame::client_process_stdf_packet(double timestamp)
{
   int p = mPlayer.active_local_player;
   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   int seq = PacketGet1ByteInt();
   int max_seq = PacketGet1ByteInt();
   int sb = PacketGet4ByteInt();
   int sz = PacketGet4ByteInt();


   int client_sync = dst - mLoop.frame_num;      // crude integer sync based on frame numbers
   double dsync = al_get_time() - timestamp;     // time between when the packet was received into the packet buffer and now
   dsync += (double) client_sync * 0.025;        // combine with client_sync





so if i suddenly after a long freeze, get an stdf from the very past....
dsync will be affected

so why can't rejoining fix it?



maybe I am getting a lot of stdf packets and I need to look at them all and only process the newest one..
this is for cases where they build up and I get a lot in one frame
my current method is only use the first one for timing....


how about this?

for client timing:
separate function to search packet buffer for stdf packets
if there are multiple, use the one with the highest dst frame






also, i think it is important that if I decode an old state that i dont apply it if there are newer ones
should I have muliple current difs waiting on the client? no


read packet buffer on client
1st pass



how is packet buffer processed?

in order?







packet buffer only has 200, could I be running into the limit?
I now have an error that prints when full


full fakekey packets/sec packet/frame

client tx 80   2 (one cdat, one stak)
client rx 250  6

server tx 2200 55
server rx 580  14

I should be no where near the 200 packet in the buffer limit...

I want to capture a freeze event and see what the max's are
not much higher

client tx 82
client rx 314

server tx 2527
server rx 585


then I also want to see if a brand new client can re-join
yes they can, but never get ping always zero

so it has somthing to do with the server, something gets screwed up and is not reset by restarting client

do a log when trying to do this...duh...
I still don't know what is going on
ELI5
got dif and applied dsync -12 target 10
then it adjusted timer until it was 10
pings say 300 ...

what could be causing ping to be wrong?

also ping never gets back to server
it is a separte calc


now I do a reset of the client history when server sets up joining client

mPlayer.init_player(cn, 1); // full player reset
mStateHistory[cn].initialize();
restarting one client fixed for everyone...

cannot reproduce...

constant base resets, but I get pings both locally and remotely

I notice on the server I get cpu usage around 80% with constant base resets...
lowering zc from 7 to 5 makes a big difference

what else am I going to try?

what about what stdf packets I am using for timing?

make my own custom timing thing

it makes sense to use the newest stdf for timing
I don't think it can be too new

I could calculate dsync and then get the max of that


new task


in my packet functions

replace 1 2 3 4 byte int put and get...

replace with 1 and 4

how many occurance?

get put
4 12 11
3 0 0
2 2 4
1 13 17

done

3 is dead

1 and 2 have just been renamed

4 uses memcpy

now back to ...


now I have a new method of getting dsync
I am getting the highest number, but I am not sure that is correct...

still locks with constant base resets

I started having these issues when I tried sync of +10

I could try lowering it, but I really want to know how it gets in its loop and how to fix it....

I was able to reproduce even with netem 0


turn on all logging, especially stdf packet and see...


I captured an almost loop at 4966, but it recovered

srvr
4960 rx stak
4987 rx stak
I can see individual stdf pieces sent inbetween these frame

clnt
4960 rx dif complete
4986 rx dif complete
nothing in between
cant tell if stdf packet were rx'd

then it applies the dif and rewinds 25 frames
then the next frame it applies another and rewinds 20 frames

then for sure at 6800

what causes it?


another example

7503

srv
7500 rx stak
7528 rx stak


clt

I don't care as much that is breaks, as much as I care that it doesn't fix itself....

I think it is primarily a sync thing

server sends
7570 tx stdf 0-7571
7571 rx stak 7559 (this has the frame number 7559 so I am pretty sure the client applied it on frame 7559)

client
7573 rx dif 0-7571
7573 rx dif 0-7572
7573 apply dif 0-7572

7559 rx dif 0-7558
7559 apply dif 7558




add logging on client for send stak



changed the order  of client sending stak..used to do it right after applying state, now does it after ff
the only difference will be that stak packet will now send current client frame after rewind, rather than frame after apply dif.
i don't expect that ill fix anything, but the way it was, both frame numbers were always the same
not that I make any use of that frame number anyway...



pushed and recloned on server
erased and redid all clients


next example:

srv
5430 rx stak 5424



the server complains of packet buffer full
tx max 2110 pps / 40 = 52ppf

tried with offset -10 took 20 min but it borked too

also log array full...


I am giving up for now....


20230918 next morning, new thoughts

I have been fighting this one bug for a while now

describe it

when netgame plays for a while, the server gets in this mode where it will send full difs based on zero
I am pretty sure this happens because the client is lagging too far the server and they do not have a common base

why the client lags behind is a mystery to me, it should not do this

the client syncs based on the stdf packets it gets and that seems proper

there just seems to be a lag between the two

I cannot see the lag with dsync, that looks normal, because the client syncs's based on that stream of packets
Is is because that stream of packets is delayed?

my measured ping from both client and server side show around 250-300

could it be that I actually have a network issue, not a netgame issue?

https://serverfault.com/questions/826066/ubuntu-server-weird-latency-jumps-in-lan

what if I try running a ping from command line when this is happening?


what evidence from the logs can I use to pinpoint it is a network issue









-------------
on another note I want to do a nice server graph with loads of lines

basically everything that show in server debug tables and logs

for each frame




new test run, first of day, no netem or ssh just a brand new reboot
scat o:+10 zc:7
ping running on command line from m36 to scat 96.45.15.166
ping 25-27


briefly happened at 15min but only for p7 - m36 and it corrected itself
at the same time I got a missed ping on command line

ran for 60 min no freezes....


next test run:
scat o:+10 zc:7
ssh and netem 20 (40)
ping running on command line from m36 to scat 96.45.15.166
ping 65-67

20 min no bad, increase netem to 30 (60)
ping 85-90

30 min no bad, increase netem to 40 (80)
ping 100-110

missed on ping on commndline m36 around 37:40

40 min no bad, increase netem to 50 (100)
ping 125-140


it did it! at around 43:00

command line ping 380-450 then 'request timed out'

ssh on scat ping 8.8.8.8 time:300ms

removed netem and now ping 8.8.8.8  from scat is 225ms

scat is using 2400kB/s according to pm server

started removing clients and ping went back to 28-30

I have been chasing a ghost all this time! I was a network issue, not a netgame issue!

The symptoms are exactly what I would expect if I suddenly had network latency of 270-300ms





what should I do when log array is full? dump to disk and erase?...yes...done

print more details if packet buffer full...done on server and client

change all LOG_NET_network_setup to LOG_NET...done

make a better correction line on client and remove from cdb..done

look at server_dirty_frame

what happens if dirty_frame is not found when rewinding and nothing is done?




so now that I know what is causing the issue, lets see what it takes to cause it to happen


I suspect it is when too many packets or too much bandwidth
so log that on the server....

I got a occurrance!!

server
cpu 78-82
tx 2400 rx 6-8 total 2408

ping 200-400-600

removing client
(6 clients) 2067
(5 clients) 1715
(4 clients) 1373
(3 clients) broke the spell


lets see if i can reproduce my increase bandwith until it happens



I want more buttons on the server....fixed so that is much easier to do


I want a method to test the bandwidth increase
if I send out extra packets are they ignored by clients? yes

does cpu take into account the time it takes to send packets? yes

int srv_exp_num = 0;
int srv_exp_siz = 0;


I am ready to test!!

I think it is the number of packets....
tx 2700 pps


1400 good
around 1600 I have issues

TCP is much worse
aound 600 I start getting issues


I tested UDP on LAN

16K pps and no issues
12mBps

could it be EIDnet?

I just switched over to e6430 as my server, still on eidnet...
8000pps no issues


I am now sure it is my linux box...


but how? and why



The problem was that Network Manager was managing the interface.

The default qdisc is supposed to be pfifo_fast but was actually something else:

tc qdisc show dev eno1
qdisc fq_codel 0: root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5.0ms interval 100.0ms memory_limit 32Mb ecn


Check which interfaces are being managed by NetworkManager:

nmcli dev status
DEVICE  TYPE      STATE      CONNECTION
eno1    ethernet  connected  Wired connection 1
lo      loopback  unmanaged  --


fix this...

sudo nano /etc/NetworkManager/NetworkManager.conf

add:

[keyfile]
unmanaged-devices=interface-name:eno1



m@scat:~$ systemctl stop NetworkManager
m@scat:~$ systemctl start NetworkManager
m@scat:~$ nmcli dev status
DEVICE  TYPE      STATE      CONNECTION
eno1    ethernet  unmanaged  --
lo      loopback  unmanaged  --

m@scat:~$ tc qdisc show dev eno1
qdisc fq_codel 0: root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5.0ms interval 100.0ms memory_limit 32Mb ecn
m@scat:~$ sudo tc qdisc add dev eno1 root pfifo_fast
m@scat:~$ tc qdisc show dev eno1
qdisc pfifo_fast 8001: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1


now I can get 10,000 pps and 10mBs

does it stay on reboot?


on reboot it does not get a network address at all...

reenabled nm


11641 pps 10mBs

finally ping went to 40-80


I cannot reproduce the problem??

Do I need internet to reproduce?



2800pps and 1.5mBs adds 100 to ping











-----------------------------------------------------------
I also would like to know where in the history my hits or lookups occur.
-----------------------------------------------------------
Does rewind tell me that? No.

on server, rewind tells me the latest cdat rx'd and thus how far I need to rewind
this is aleady what I want


on client, rewind tells me how far the dest is from current frame
I also want to know how far the source is...

I will almost alway be dst-1, because src and dst are one frame apart
I would like to measure and see.

what would I call this?
client_base_rewind?
yes that describes it...

when client looks up a base to apply a dif, also record this

the base frame compared to what?
the current frame?
the oldest frame in history?
the newest frame in history?
the dst frame?












20230920 more testing

NM enabled no changes
scat internet

can get to 14kpps (ep 400) then client drops

then lower to 12kpps (ep 300) and client has trouble  staying connected

then lower to 8kpps (ep 200) and client has trouble  staying connected

It looks like server is send 8k 12k but client never rx more than 2k

first time before locking 12 12

restart server

now ep100 sends 4k but client only rx 2k and pings went to 400

tc qdisc show dev eno1
sudo tc qdisc del dev eno1 root
sudo tc qdisc add dev eno1 root pfifo_fast
tc qdisc show dev eno1



m@scat:~$ tc qdisc show dev eno1
qdisc fq_codel 0: root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5.0ms interval 100.0ms memory_limit 32Mb ecn
m@scat:~$ sudo tc qdisc del dev eno1 root
Error: Cannot delete qdisc with handle of zero.
m@scat:~$ sudo tc qdisc add dev eno1 root pfifo_fast
m@scat:~$ tc qdisc show dev eno1
qdisc pfifo_fast 8001: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1

client still rx only 2k and ping to 400


sudo systemctl stop NetworkManager

m@scat:~$ nmcli dev status
DEVICE  TYPE      STATE      CONNECTION
eno1    ethernet  connected  Wired connection 1
lo      loopback  unmanaged  --
m@scat:~$ sudo systemctl stop NetworkManager
m@scat:~$ nmcli dev status
Error: NetworkManager is not running.
m@scat:~$ tc qdisc show dev eno1
qdisc pfifo_fast 8001: root refcnt 2 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1


client still rx only 2k and ping to 400

what the hell else can I try?

server only sends 1.2k (ep30)

client rx 1.2k and no problems


try increase


at ep34 1400tx

client sometimes get ping in the 200's

same limit as before, but what is causing it?

I thought that qdisc and NM were the culprit, but now I am not sure...

funny thing, at the start, before triggered, I could do 12k 12k


restart scat and try again...


ep200 8kpps no problem

ep300 12kpps client is missing a few
ep400 14kpps client drops

ep300 client can reconnect no prob

ep400 client will not reconnect

now client seems to have a max of 2-4kpps

so i have triggered whatever it was I wanted to trigger...

what if I reboot and disable NM and set pfifo_fast before triggered??

same...


test on LAN...

does not get ip...

sudo systemctl start NetworkManager

ep400 16kpps no prob
ep1000 40kpps no problem



try e6430 on internet

ep300 12kpps starting to miss some on client

restart client and max rx is 2k-4k

IT ALSO HAPPENS ON WINDOWS!!!

now I strongly suspect EIDnet

I am at an impasse

the only way i can test more is if I have another internet connection

If I never trigger this I won't have an issue??

can I fix by restarting server?
no, I still have that lower limit...

during a typical game what are my pps?

worst case, with 7 clients doing full base resets at 10 packets each
70 packets per frame * 40 = 2800pps


1 client, 1 packet for dif * 40 = 40pps



how can i test?

have server send 5000 packets and have clients reply with how many they got



I was thinking, could there be a limit in netgame?, but then I realize it works on LAN.....


what if I do a LAN test, but with netem and see what happens...

also, why does rebooting server remove the limit?, does it time out?  test this...




here is the thing...the server gets stuck in this loop because it is continually sending from state zero
normal operation has max 2 packet dif
7 clients x 2 packets = 14 packets per frame * 40 = 560pps



I have some thought on ways to accomodate this

increase state history to reduce possibilty of zero base difs



- test for packet limits
periodically send a burst to client and see how many got through
- increase s1 to reduce packets

- put all my tx packets in a buffer and send at the end of the frame (i dont think this will do anything)

- put all stdf packets in a buffer, then if too many run send stdf again (this will not help, only increasing s1 will)









I want to start on the server remote control.

design:

a remote machine to display server debug overlay and controls

intended for use mainly on remote headless server

will need a two way packet exchange

it can probably be handled by sending the entire player array, not just the syn part

syn 2304
loc 2688
---------
    4992

packet names
snfo - server info
sctl - server control

I will need some method of setting up connection also

prog start

client machine
have a mode like settings, or help...a self contained program state

- setup connection to server
- read and send packets
- display and control



make a new command line option to connect to remote control server

added to main.h

   int server_remote_control = 0;

made command line -rc set this to 1 and set mode 40



state = 40; server remote control setup
state = 41; server remote control run

now copy from client setup to continue

I have set up network and got a connection

client should not need modification but server will need a new place to save connection that is not part of player struct

actually I think it already does have room for 32 MAX_CLIENTS

somewhere on server I will need to store the connection used for remote control
I think who is what I am looking for...but how do I know which who??

I think I will also need to do the join thing...that is where a connection turns into an actual client

packet cjrc and sjrc

I think I have the join working


now that they are joined I want server to send a packet to the rc

snfo..done


add a few more things to loc so they will get to rmt

   // used only by server remote_control
   int srv_frame_num;
   int srv_stdf_freq;
   int srv_total_game_moves;
   float srv_cpu;


also show what level is currently running..done

show time as frames and also mm:ss ..done

send cpu as raw value and do local q graph..done


this is coming along nicely

I want to make it prettier, but maybe I should implement controls first...

I will need a packet sent from rc to server:

possible things to change:

stdf_freq
zlib_cmp
client offset
extra_packet_num
extra_packet_siz



actually anything I wish to change is also something I am displaying on the remote

should I let the remote overwrite?
or should I just have the remote request to modify and let the server decide?

packet rctl
int stdf_freq_inc;
int zlib_cpm_inc;

etc...

where to start?

make buttons on remote for  s1 freq

I think I have that done...

client_offset mPlayer.syn[0].client_chase_offset
why is this a float?, even worse, a double...


add to loc...
zlib_cmp
epn
eps

   int srv_zlib_cmp;
   int srv_extra_packets_num;
   int srv_extra_packets_size;


mNetgame.zlib_cmp
mNetgame.srv_exp_num
mNetgame.srv_exp_siz


loc 2944
syn 2304

--- 5248

done...

I have all 5 control things implemented

now what?

what are some other things I want to be able to do from remote control

reload current level
warp to overworld

force save log

drop specific player

test max packet
server will send 1000 packets and see how many are rx'd by client
packet burst








restore internet.....done
lab server: 96.45.13.253

update versions and push...done


seemed to run well for 5-10 minute, then started dropping pings
clients disconnected
ssh timed out
command line ping

Reply from 96.45.13.253: bytes=32 time=27ms TTL=56
Reply from 96.45.13.253: bytes=32 time=27ms TTL=56
Reply from 96.45.13.253: bytes=32 time=26ms TTL=56
Reply from 96.45.13.253: bytes=32 time=26ms TTL=56
Reply from 96.45.13.253: bytes=32 time=28ms TTL=56
Request timed out.
Reply from 96.45.13.253: bytes=32 time=25ms TTL=56
Reply from 96.45.13.253: bytes=32 time=25ms TTL=56
Reply from 96.45.13.253: bytes=32 time=24ms TTL=56
Reply from 96.45.13.253: bytes=32 time=22ms TTL=56
Reply from 96.45.13.253: bytes=32 time=25ms TTL=56
Reply from 96.45.13.253: bytes=32 time=27ms TTL=56
Reply from 96.45.13.253: bytes=32 time=27ms TTL=56
Reply from 96.45.13.253: bytes=32 time=27ms TTL=56
Request timed out.
Reply from 96.45.13.253: bytes=32 time=28ms TTL=56
Reply from 96.45.13.253: bytes=32 time=25ms TTL=56
Reply from 96.45.13.253: bytes=32 time=25ms TTL=56
Request timed out.
Reply from 96.45.13.253: bytes=32 time=44ms TTL=56
Reply from 96.45.13.253: bytes=32 time=24ms TTL=56
Reply from 96.45.13.253: bytes=32 time=59ms TTL=56
Reply from 96.45.13.253: bytes=32 time=27ms TTL=56

wtf

seemed to reset after a few minutes
it is on bro-sec-16?? i thought it was 11??
there is also one on bro-sec-11

my home radio on bro-sec-02 is doing the same thing....


ssh into remote and ping 8.8.8.8 no hiccups there....

tried a ping to 8.8.8.8 from home and it timed out for 2 pings exactly when 13.253 did...

I could be me!!!!!
and by that I mean shaw
and by that I mean rogers


to test this...

use two eid connections

one on scat and one at lab


lab - server
client - scat

remote m36




the remote is turning out to need more than 1 packet

my 5400 bytes is only compressing at 25% or worse...

damn, this will complicate things....
not that much actually, reused the buffer that client uses...

it seems to be working better...

could it be that the data is now not so one sided?

I still get times where all the client will go to 400 ping, except scat which is a different eid connection


doing more testing....


server: pmh
7 clients
1 on edit scat

ran for 1H






it might be nice to see some realtime graph on the rmt server
I would like to try to experiment with realtime graphs to see if I can make them faster...
right now it does a complete redraw every frame
I could make qg own its bitmap and just draw new points to that.


then when drawing on screen I would just draw it in 2 sections

I would keep no history, draw the point, then discard

I would not be able to resize like I can now.


but still this might be useful...

lets try making quickgraph2


I still want multiple series
I will need to keep last point, just so that I can draw a line to it


profiling:
m36

170us old cpu draw
4us new cpu add
2us new cpu draw

this is very much faster:

170 / 6 = 28.3 times faster



e6430
400-600us old cpu draw
23-27us new cpu add
7-17us new cpu draw

600 wc more than 10 times faster
50us wc


try on 4320
5000-6000 us old cpu draw
85-700 add
60-600 draw

wc 6000 / 1500
4 times faster

I lose the ability to draw very fine lines because of the intermediate bitmap
I also lose the ability to dynamically resize


cleaned up a bunch of stuff related to quick graphs initialization, adding cpu, and drawing


I want to make qg2 capable of muliple series, it should be simple

I just need an array for the series

each should have color and last point

entry pos will need to manually incremented?
unless I enter all points at once


should I also make series active or not?, why not

what am I going to test it with?

something on the server that has a value for each client

i could just run it on the remote...yes!!

lets do dsync




I am very happy with how remote is working

I have a bunch of graphs scrolling in real time

It is easy to play with sync and find a sweet spot where lcor is mostly zero and rcor is low..

on internet with pings of 28-30 the sweet spot if client offset -20...

I have not had any re-occurances of getting stuck with 280-300 pings

almost all of my test were done with pmh as the server, remote in the lab

m36 was the remote controller on shaw

scat was an eid client

e6430 and 5 x 4320 were the remaining clients...

I got a lot done today: 20230923
- remote working
- quick graph2


big things today 20230924




BUG - things that draw direct to screen draw on top of border
the function:
void mwScreen::draw_scaled_level_region_to_display(int type)
is called 14 times
it draws the border
I want to move that to
mScreen.draw_screen_overlay();
I also want to do a little cleanup
only two calls are for game, the remaining 14 are for level editor
just make it so that frame only gets draw in level editor mode
and change from 3 to 1...done



button for reload level and debug that

I think the problem with my reload button is that is does not survive rewind
I need to put something in the game moves array...

as soon as I set level_done mode


this is how gate does it


      // immediate next level to gate level
      mPlayer.syn[0].level_done_mode = 3;
      mPlayer.syn[0].level_done_timer = 0;
      mPlayer.syn[0].level_done_next_level = lev;

      mLoop.quit_action = 2;
      mLoop.done_action = 2;

I just tested and gates also cause client to immediately quit
when server initiates, not when client initiates


OK look into logs...

I looks like mode 12 level done

quit to cmd beacuse done_action = 0....why?
works fine if game is joined from menu...
added done_action = 1 to -c and -c <ip>
now it seems to work perectly
test more...
add button to rc

I can now reload server levels remotely and it works great






why is client cpu overlay graph not erasing backgrond properly
it has something to do with the sizes....


the cpu graph used for screen_overlay needs to be separate from the one used in remote...done

make the ones used in remote not use any resources unless in remote mode...done

moved the adding of data to remote graphs only happen after receiving snfo, not every frame like before..done


auto range qg2
test with 9 cpu overlay
give it 2 ranges...0-50 and 0-100
toggle with F3 for testing...
after much work I can now range qg2
now..how to do it automatically

could I use a helper like Tally?

build it into the class with custom handlers for each type

autorange_type
0 = none
1 = cpu

then keep a history array like with the other qg

max_min etc...

sound like something I can do with tally...
I have to manually reset tally
rolling average looks good but only has 8


what do I need it to do?

keep a rolling history of min and max

for at least 5 seconds or 200 frames

why don't you extend RollingAverage to let you specify the history number?

It might be a waste, but I could statically create an array of 400, then specify how much to use...done

made qg2 own one RA sized it 200, add data to it...

it seems to work, now what else can I try it on??

dsync
first of all, dsync add 7 data points per frame

I am having a hard time autoranging it

I feel like giving up

some thoughts:

I could not resize the bitmap when changing range, just print old and new range numbers
I could not change range at all, make a mark where data goes out of bounds and maybe print value??

I don't really need auto range

can i disable it mostly? yes





BUG
why do client player shots not sound on the server????
as soon as you click client sync mode server sound stops
I think it has to do with the frame numbers in sound
i think it is because shots get fired only on rewind, not the first time around
this is not a bug





well now what?

do something about sizes and positions of qg2

should I make them store their own positions? yes...

make a function to resize the graphs in remote

It will basically just call init on them

and that will arrange them

next I want button set enable and disable graphs 8 of them...

separate initialize and resize...done



it is coming along, way more polished than yesterday...


still much to do...


20230924 10:00PM new version and push



20230926


I want to also send cpu fron clients to server

change to store cpu per player

its all convoluted now

now it is stored per player, now what?

have clients send their local to server with stak and have server rx and put in loc.cpu...done

now server will auto send to rmtmp

don't make rmt avg it just display raw...



at the end of game_loop...
calc cpu and put in player array with active local player

what about the average...


I should have another place to store it....
local_cpu
and this one can use the rolling average

then I will also use that for remote...





what if I have a whole new method for non-blocking buttons

have a section of code that detects where the mouse is
like a bunch of normal buttons



then have that wrapped in a function that detects if the mouse has just been pressed

then each button wiil be passed if mouse was just pressed...


I could use the keys_held thing I already have...the problem is that sometimes event queue gets processed much faster and just pressed is not detected
I could decouple proc_keys held from proc event queue

that would probably do it, but there would be many places in code I would have to fix...



to start with, make proc take an arg int pch if 1 then do the pch
then change all refs to 1


then figure out where I want to do something different


163 matches...wow

did them all...

the only place I do it different is the main loop...
I call event queue very fast, but proc_keys_held only when 40Hz timer fires...seems to work...hope it doesn't break anything
had to move function key check to get called only from keys held...

this makes the non blocking buttons much easier to implement

old:
if (mWidget.buttont_nb(csx1+2, ya, csx1+2+btw, bth,  0,0,0,0,  0,color,15, 0,  1,0,0,0, "-"))
{
   if (b_press[0] == 0) mPlayer.syn[0].client_chase_offset -= 0.005;
   b_press[0] = 1;
}
else b_press[0] = 0;
if (mWidget.buttont_nb(csx2-btw-4, ya, csx2-2, bth,  0,0,0,0,  0,color,15, 0,  1,0,0,0, "+"))
{
   if (b_press[1] == 0) mPlayer.syn[0].client_chase_offset += 0.005;
   b_press[1] = 1;
}
else b_press[1] = 0;
al_draw_textf(mFont.pr8, mColor.pc[15], csx1+csw/2, ya+2, ALLEGRO_ALIGN_CENTER, "o:%2.0f", mPlayer.syn[0].client_chase_offset * 1000);

new:
if (mWidget.buttont_nb2(csx1+2, ya, csx1+2+btw, bth,  0,0,0,0,  0,color,15, 0,  1,0,0,0, "-")) mPlayer.syn[0].client_chase_offset -= 0.005;
if (mWidget.buttont_nb2(csx2-btw-4, ya, csx2-2, bth,  0,0,0,0,  0,color,15, 0,  1,0,0,0, "+")) mPlayer.syn[0].client_chase_offset += 0.005;
al_draw_textf(mFont.pr8, mColor.pc[15], csx1+csw/2, ya+2, ALLEGRO_ALIGN_CENTER, "o:%2.0f", mPlayer.syn[0].client_chase_offset * 1000);


converted all 3 client overlay buttons also, renamed to nb from nb2, removed all traces of old...

now back to making rmt use them...



20230928

What would make the load level thing so much simpler in remote is to have one button for vls that reloads that level
don't need to show current load level

I want some way to force clients to reconnect...why?

just to get new player slots...and new bullet config?

I am not sure if I really want to do that...I would need somehow to make the server tell the client to do that...
sounds too complicated...

But I do want some way for server remote to be able to change bullet config

if I make it part of the player struct, it will automatically get synced

either method seems messy, hacky

I shouldn't worry about changing the rules in the middle of a netgame, clients will never be able to play back anyway, they dont have all the game moves...

move these to player struct

   agci(NETWORK, mShot.deathmatch_shots, 0)
   agci(NETWORK, mShot.deathmatch_shot_damage, 5)
   agci(NETWORK, mShot.suicide_shots, 0)

can I come up with better names:

player_vs_player_shots
player_vs_player_shot_damage
player_vs_self_shots


player_vs_player_shots
0 = none
1 = yes
2 = self also

do I even need to do this?
it is a part of mShots, and I am sure I sync that...yes, the 2 arrays but not that part...


move to player struct

player_vs_player_shots
player_vs_player_shot_damage
player_vs_self_shots

done...
remove all mentions of old ...done


test....


after this I should be able to change on server and have it propogate to clinets
make sure it is not killed by server rewind
done


redo send rtcl packet
instead of ever increasing parameters, just two...typr and val,

can still send packet with all, but not call

maybe I should change that as well


make some defines in netgame.h

inc version and push

20230929

vls on remote crashes when moving to new level, but only if vls is started on level 1
fixed

remote stops receiving packets, i think it is because it receives so many without replying
make a keep alive to send a packet every now and then
count how long it has been since last sending one...
12000 / 40 = 300s = 5 min

client shows cpu on top of other stuff...fixed


make it so that ESC still quits in fakekey mode..done

//               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey)) loc[p].comp_move = rand() % 64;
//               else set_comp_move_from_player_key_check(p);

               set_comp_move_from_player_key_check(p);
               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey))
                  if ((!mInput.key[loc[p].menu_key][0]) && (!mInput.key[ALLEGRO_KEY_ESCAPE][0])) loc[p].comp_move = rand() % 64;

player paused after death, lit bomb with detonators, does not check if dead player was holding detonator
fix this and verify it works like you expect
make test level
have player hold det and die
have player hold det while other player dies
all dets go back to bombs...
fixed




still testing...

add rctl to make all clients fake key

now it is part of player loc

if I move it to syn, local clients will not be able to set it, it will be overwritten by server....hmmm


add to syn and give it the option to override local

do I even need local?

im not ready to kill it yet...

should it also apply to server player??

I think all I have left is to set it via remote control

done...now that works too...

what else do I want to do via remote?
drop players?
force players to rejoin, why?


test that all demos still play...they do!

dies hard when starting demo....any type...
fixed by initializing graphs...




figure out how to make the new OTH logging things fit on the settings screen nicely
change the order of file and console
make middle section with the list of types changeable
then I can have all three in one settings tab....
done and removed profiling tab...


Can I remove server state freq?
or at least the auto part?
mNetgame.server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq
I went ahead and removed all traces....now always 1
should I make it permanent? yes...
removed all traces...
now states are created every frame


what about client offset?
should I let each client choose that automatically? basically same as ping...

should I make remote able to force clients to server offset control?
when not active, just go back to what they were using before

client offset:
still has 3 modes
0 manual
1 auto (ping -10)
2 server override


I want to make server overide like fakekey...
make it a part of loc[0]..done

make is so that remote can toggle it...

client cannot set it, only server can

where is it set on client?

2 places places, but would like to change

timer_adjust

client rx pong

now they are both in timer adj

I think I have it all working...test more...




if you are a headless server, you should be in story mode with all levels unlocked

if you are a client, you should have all levels unlocked, but after testing found that it does not error

this is not ideal, but is needed to prevent errors like:
client cannot enter locked level
test this...
server in story mode

server all unlocked
1 client not all unlocked...
1 client all unlocked
both can enter locked and unlocked levels
locked areas follow server
locked levels follow local


server locked
1 client not all unlocked...
1 client all unlocked
both can enter locked and unlocked levels
locked areas follow server
locked levels follow local


server in classic mode
all unlocked
what happens at level done?
back to overworld
but that is because the level was started from overworld
start from another level
tried force from rmt...same back to overworld
tried start level from command line, then goes to next


I think that I should always start headless server in story...

make a way to set this and view this from remote? or force story and all unlocked for sh

force story and all unlocked for sh.....done
make it so that sh always saves logs, simple ones
made a common sh setup that sets story mode, unlocks all levels and sets logging...


what does timestamp class do??

- saves start of frame
which is then used by cpu, server dsync and server stak_dsync
these could easily be replaced

used by move enemy to tally move times for each enemy type...

removed all traces of mwTimeStamp





testing

level 64 on pmh
7 clients
no fakekey


fakekey
390 kbps
2 packets





pings to 25-30
offset 20
rcora 3-4
rwnd 0 1

added nt 10 (20)
increased pings to 45-50
offset 45
game still works great...
rcora 6-7
rwnd 0 2


added nt 20 (40)
increased pings to 65-70
offset 65
rcora 9-11
rwnd 0 3


added nt 30 (60)
increased pings to 85-90
offset 85
rcora 14-16
rwnd 0 4

added nt 40 (80)
increased pings to 100-110
offset -115
rcora 17-20
rwnd 0 5

50

60
pings 145-155
rcora 25-35
rwnd 0 7
base resets start
2000 kbps

70 constant base resets


0 LAN
ping 0.1 -0.2
sync 5
rcora 1.0 -1.2
rwnd 0 0

so how do I set offset automatically

ping +5


LAN 0 +5

internet 25-30 -20



offset = 5-ping


ping is not very reliable on client
if client has high cpu time, pings will be altered

its this huge block of time that the main processing takes that affect my packet delivery

fast packet loop helps in that I am rxing packets the entire time I am waiting,
but that does not help for the huge amount of time I am doing things...


20231001

I am looking at threads again.


High level view of what I am trying to accomplish.


When my program has high 'cpu' this means that the game loop is taking a high percentage of the time available.

The frame fregueny is 40Hz which means each frame has at most 25ms to complete.

If it takes 20ms to complete, I call that 20/25 * 100 = 80%

That means that my packet processing is frozen for 20ms.

Normally this is not an issue, as the data cannot be used until the next frame anyway.

But when I am using these packets for timing, like measuring ping, this delay causes issues.

I had already identified this problem and implemented what I called 'fast_packet_loop'

This ran as fast as the system would let it, as opposed to the main game loop that only ran at 40Hz.

This was effective when my 'cpu' was low, and I had a lot of wait time.

Fast packet loop would run then.

So what I want to do now, is have fast_packet_loop run in its own thread.

It will continually listen for packets.

But then what?

Any variables that it touches will need to be protected by a mutex.

I need to think out what is going to be shared...


lets call it fast packet thread



exclusive use of fpt
--------------------
reading packets and putting them in pb
responding immediately to pings
recording times


shared
------
packet buffer

time_vars


when ever fpb has a new packets to read:
- lock pb
- add packets

if time packets
lock time_vars
modify
unlock time_vars

- unlock pb


is libnet thread safe?
by that I mean if am reading a packet in one thread, and another thread is trying to send, will that cause locks?

could I avoid this by making flt the only place packets are sent also?

this would add complexity, but would prevent race conditions

I could add another packet_buffer or modify the existing one to also queue packets for sending

then when I want to send_packets:
lock buffer
add data
unclock buffer

this could be done without too much fuckery
make a wrapper function to do that


to start with, I should make sure that there are no reads outside of fast packet loop

int ClientReceive(void *data);
client_fast_packet_loop
client_flush

remote_join
loop 1000
fixed this to use buffer

process_snfo_packets




int ServerReceive(void *data, int *sender);
server_fast_packet_loop
server_flush


also I have different fast_packet_loops for client and server, need to make only one


made a common funtion to find empty and display error if it cant...

need to make type numbers uniquie for client and server...


         if (packet_buffers[i].type == 1) cdat_count++;
         if (packet_buffers[i].type == 2) stak_count++;
         if (packet_buffers[i].type == 3) cjon_count++;
         if (packet_buffers[i].type == 4) cjrc_count++;
         if (packet_buffers[i].type == 5) rctl_count++;

         if (packet_buffers[i].type == 11) stdf_count++;
         if (packet_buffers[i].type == 12) sjon_count++;
         if (packet_buffers[i].type == 13) sjrc_count++;
         if (packet_buffers[i].type == 14) snfo_count++;


done...


now what more can I do to make fast_packet_loop commmon for server and client?

I have now made it common...

where is it called from:

mNetgame.client_fast_packet_loop();
Client Wait For Join
Client Wait for Initial State
Remote Control - Waiting for server reply
main loop outside of 40Hz
remote control loop

mNetgame.server_fast_packet_loop();
main loop outside of 40Hz


I propose to replace all these calls with:

mNetgame.fast_packet_loop();

do it...done


now the next thing might be to make common the read packet buffer calls

mNetgame.client_read_packet_buffer();
Client Wait For Join
Client Wait for Initial State
Remote Control - Waiting for server reply
remote control loop
client control

mNetgame.server_read_packet_buffer(void)
server_control

replace with proc_packet_buffer

done...

now all packet reading is soley done with mNetgame.fast_packet_loop();
except for server and client flush...
this is the only way that packets get into packetbuffer


now all processing of packets in packetbuffer is done by
proc_packet_buffer....

except for timer adj that reads all stdf....what aboout that?


what is your goal here?


make packet buffer have a mutex,

so I can add packets in another thread

and read them in the main thread

then I will make the fast packet loop in its own thread


I am thinking of making packet_buffer a class

that might make it easier to control access with mutexes

when reading out...
- lock
- read into packetbuffer
- process
- unlock

made packet buffer a class...

now I want to do something about timer_adj


add this to class


   // iterate all stdf packets, calc dysnc, then get max dysnc
   float max_dsync = -1000;
   int stdf_count = 0;



   // iterate all stdf packets stored in the packet buffer
   for (int i=0; i<200; i++)
      if ((mPacketBuffer.buf[i].active) && (mPacketBuffer.buf[i].type == 1))
      {
         stdf_count++;
         int dst = 0;
         memcpy(&dst, mPacketBuffer.buf[i].data+8, 4);

         // calc dysnc
         float csync = (float)(dst - mLoop.frame_num) * 0.025;   // crude integer sync based on frame numbers
         float dsync = al_get_time() - mPacketBuffer.buf[i].timestamp + csync;  // add time between now and when the packet was received into packet buffer

         if (dsync > max_dsync) max_dsync = dsync;
      }

done:



now, what accesses the values outside the class?
you know I could make that private...done...nothing does...

what variables does this class touch outside itself?


fast:
mPlayer.loc[p].ping = t2 - t0;                    // calc current ping
mRollingAverage[1].add_data(mPlayer.loc[p].ping); // send to rolling average
mPlayer.loc[p].ping_avg = mRollingAverage[1].avg; // get back average
also LOG


I think this is the only part I need to wory about...
this is the only thing I will be running in another thread

the rolling average should not matter, these are the only 2 calls to it

but what about:
mPlayer.loc[p].ping
mPlayer.loc[p].ping_avg

this is the only thing that writes to it, (i think)
and if other things read it while updating, it should not matter...

so what do I need to lock with a mutex?

fast and read

is that all?

fast will always be in its own thread
read will always be in main thread...

this means that the read_and_proc will need to be replaced with just read

also when do I start the thread?

after network is initialize?


created mutex and guarded fast and read...

now what?
start thread...
where do I define and start thread??
in the same class?


I am getting weird crashes...time to look for variable that might be shared...

what can I do about ping?

I can still add to average in the thread, but to put into player vars, I should do elsewhere
how about in proc?

I have removed the player refs in fast packet loop

added:
mwRollingAverage RA[8];

these are set in fast like this:
RA[mPlayer.active_local_player].add_data(al_get_time() - t0);

then added to player in read like this:
for (int p=0; p<NUM_PLAYERS; p++)
{
   mPlayer.loc[p].ping = RA[p].last_input;
   mPlayer.loc[p].ping_avg = RA[p].avg;
}

this made no difference, tested without threads and it works fine


next I think sending packets might be the culprit

definitely both threads could be sending at the same time....

do I need to make a buffer for transmit, like I did with send?
make it run in its own thread also?

then make it so that only one can be active at a time?


also the way that I process packets from the buffer....
I copy them back into the packet structure, again this is shared....

first of all, how can I not do that?

use the actual buffer variable??





         memcpy(mNetgame.packetbuffer, buf[i].data, 1024);
         mNetgame.packetsize = buf[i].packetsize;
         mNetgame.set_packetpos(4);
         if (mNetgame.ima_server)
         {
            if (buf[i].type == 1) mNetgame.server_proc_cdat_packet(buf[i].timestamp);
            if (buf[i].type == 2) mNetgame.server_proc_stak_packet(buf[i].timestamp);
            if (buf[i].type == 3) mNetgame.server_proc_cjon_packet(buf[i].who);
            if (buf[i].type == 4) mNetgame.server_proc_cjrc_packet(buf[i].who);
            if (buf[i].type == 5) mNetgame.server_proc_rctl_packet();
         }
         if (mNetgame.ima_client)
         {
            if (buf[i].type == 11) mNetgame.client_process_stdf_packet(buf[i].timestamp);
            if (buf[i].type == 12) mNetgame.client_process_sjon_packet();
            if (buf[i].type == 13) mNetgame.client_process_sjrc_packet();
            if (buf[i].type == 14) mNetgame.client_process_snfo_packet();
         }
         buf[i].active = 0;






I have redone all of the read functions

old:

   char PacketGetByte(void);
   void PacketReadString(char*);
   int PacketGetInt1(void);
   int PacketGetInt2(void);
   int PacketGetInt4(void);
   double PacketGetDouble(void);

new:
   char PacketGetByte(int i);
   void PacketReadString(int i, char* s);
   double PacketGetDouble(int i);
   int PacketGetInt4(int i);
   int PacketGetInt2(int i);
   int PacketGetInt1(int i);

now they are members in mwPacketBuffer and work with that data...

changed all....


now that means that when I read from packet buffer, I do not need any shared data from mNetgame...

do I need to go further and make my sending packet buffer?


maybe I should just test it first...

works good as is

now enable thread:

still has issues


what is next?

tx packet buffer

with its own buffer and thread?
also with priority!!


build packet
lock
add packet
unlock

send packet thread
if any packets to send:
lock
send all packets in priority order
unlock




I am going to rename some things


void proc_rx_buffer(void);
// called in main program to process and empty the rx packet buffer

void add_to_rx_buffer(void);
// called in spearate thread to add any waiting packets to the rx packet buffer

rx_buf


i gave them their own mutexes, but do i need that?

shouldn't they use the same mutex?

I am also trying to make only one thing use netgame at a time

when I add stuff to the tx_buffer I am not using netgame...


I do not need to use packetbuffer at all to send

void mwNetgame::ClientSend(void *data, int len)

I am using tx_mutex to prevent both read and write from tx_buff at the same time

OK,,,

now I need to build packets on a temp variable

this works so well with the tx packet buffer, I am going to remove the old method permanently

now what?


server rmt is broken

I am sure I broke the bandwidth counters

see is I can remove more manual packet sending

check out ping

do timing of how long i spend with mutex locks


add timestamp to rx buffer to see how long it takes from packet rx to packet proc
same for tx

resuse existing timestamp, already set when added


when proc_rx buffer at start on client or server code the delay can be up to 20ms

when proc_rx buffer immediately it is typically 1-5 us

longer delays occur when there are multiple packets in the buffer
like when sending base from zero

I think I should use it for ping as well, and modify it so that pings are always processed first

I will need to give ping a number


no prioritize my rx proc and tx send loops to do pings first

add to tx buffer

modify to also add type int so I can prioritize

should I make defines for all the packet types and just send as an int?



20231003

I just realized...my function, get_max_dsync relies on there being stdf packets in the buffer, and relies on reading them once per frame
I will need to rethink this...


what if I process rx ping packets in the buffer instantly, but all others once per frame?


I am thinking about building the state buffer from packets and how the packets might arrive out of order

maybe I could do that differently...

in the rx buffer only:
- by default keep all stdf pieces
- do not autamatically put them in the buffer
- once per frame:
- find the max dst of any that are complete, just by comparing dst, seq, and max
decode and apply that
erase any older pieces



I am trying to profile the times but it is not as simple as it seems...
with multiple threads and blocking mutexs...


I need some profile timers that add up over the course of the frame...

could I use Tally?

I have found that proc_rx_buffer is called almost 100,000 times per frame and can take 20ms to 40ms
but this is run in its own thread...

more importantly, does this cause any blocking when I try to call it from main thread?

i want to measure that too...

Ok I seem to be able to measure things...

can I add something to packet buffer class to let me know if I have any packets in the buffer?

I am thinking of not even getting the lock if there are no packets


rx_buf_has_packets
rx_buf_has_ping_packets

these could be set whenever adding a packet

then when packet processing occurs they could be tested and cleared when done

this is getting complex, maybe too much so

all I want if for ping to immediate get processed and send a reply

but then to do something different for other packets?  why?


do i think stdf will break?

do I need timing from stdf packets...

i should:
- fix the timing from stdf packets
- try processing all packets immed
- fix the blocking that this creates (maybe by only processing from other thread it won't)

I think this will not work...processing stdf from the other thread will cause race issues...

just process pings and send replies instantly, dont put in queue at all...

kind of like how it used to be...





I reverted a lot of this all back to the original....

rx packets buffer is emptied once per frame

ping packets are processed immediately instead of being added to buffer
I use a temp buffer 199 to pass packets for immediate processing


it works but still takes a lot of cpu

profile again...

client takes a lot of cpu


removed PT and add_rx takes 9 ms
but add rx does not take up main cpu time....it runs in another thread
main cpu thread takes 3-4ms
add_rx is called 10K times per frame on e6430 and 25k times per frame on m36

try adding a delay in the thread...thread is not running this, I am in the the main thread

OK, ignoring that for now, lets measure proc_rx_buffer
I think it might be blocked??

proc_rx_buffer never takes more than 1ms

what is cauing cpu spikes?

add_rx_buf is going to 30ms but should be in own thread...

on task manager all cpus go high

try limit in thread

al_rest(0.001) (1ms) about 20 calls per frame

al_rest(0.0001) (.1ms) runs wide open

compare this to running in main loop...




main loop
------------
game cpu 2-3

task manager cpu 27%
cpu1 80
cpu2 0
cpu3 0
cpu4 20

calls to rx buf
10K
total 9ms
avg .8us




thread
----------
game cpu 5-10ms


task manager cpu 74%
cpu1 80
cpu2 80
cpu3 70
cpu4 80

calls to rx buf
10-20K
total 12-25ms
avg 1.2 ms


test adding rx_buf_has_packets..not much different


main loop
------------
game cpu 2-4

task manager cpu 26-28%
cpu1 80
cpu2 0
cpu3 0
cpu4 20

calls to rx buf
11K
total 9ms
avg .8us



thread
----------
game cpu 4-6ms spike 10

task manager cpu 75%
cpu1 95
cpu2 75
cpu3 75
cpu4 72

calls to rx buf
10-20K
total 12-25ms
avg 1.2 ms



I don't want to use so much cpu...

test with thread throttle to 1ms




thread (1ms)
----------
game cpu 5-8 ms spike 18

task manager cpu 50%
cpu1 60
cpu2 60
cpu3 60
cpu4 0

calls to rx buf
~20
total .1 to .6ms
avg 4-20 us



stuff got a lot better, but not game cpu

test throttling tx thread also


thread (both 1ms)

game cpu 2-4 ms spike 5

task manager cpu 27%
cpu1 60 (50-80)
cpu2 0
cpu3 30-40
cpu4 0

calls to rx buf
~20
total .1 to .6ms
avg 4-20 us


this seems to do a lot better

but I am running my fast packet threads at 1ms
because that is the best I can do with the timer I have


I don't even know how reliable that is across platforms

I suppose I could test it....


I want to try a timer...
done

timer can do .5ms

try .1 ms
looks like that works also...


but it seems to take a lot of cpu in task manager




thread with timer(1ms)

game cpu 3-5 ms spike 10

task manager cpu 98%
cpu1 100
cpu2 95
cpu3 95
cpu4 95

calls to rx buf
~18
total .1ms
avg 4-6 us











thread with timer( .1ms)

game cpu 3-5 ms spike 10

task manager cpu 98%
cpu1 100
cpu2 100
cpu3 95
cpu4 95

calls to rx buf
~150
total .3ms
avg 1-2 us








I was able to reduce the ammount of time spent in the rx_buffer in two ways:

I could put al_rest in the thread, or I could use an al_timer_event to set a variable

both cases seemed to solve some problems,
the problem of the thread getting executed so many times that:
- the mutex was usually locked
- cpu usage for that thread was high

but this method caused the task manager cpu to almost peak..

after doing some more research, this naive method is called spin-locking, or busy-locking and is a waste of resources


I think what I want to use it a thread condition.....

kind of like what I was starting to implement with:
int rx_buf_has_packets = 0;


ALLEGRO_COND *al_create_cond(void)


I need to wait for something before allowing add_to_rx to continue

what is that something and how often do I check for that?

is this a chicken and egg thing?

how do I check without locking something?


maybe I don't have the problem fully defined


I only want to wait when receiving packets


net_query
Prototype
int net_query(CHANNEL *channel);
Purpose
This function checks to see if there is data waiting to be read from the channel.

Parameters
channel is the channel to query.

Return value
Returns nonzero if data is waiting, zero if not.

Example
if (net_query (chan)) get_data(chan);

how would I use this?

do this as a test in the outermost loop


lets try to use it for UDP client rx..

client:
len = net_receive(ServerChannel, data, 1024, NULL);


for (int n=0; n<ClientNum; n++)
   if (ClientChannel[n])
      len = net_receive(ClientChannel[n], data, 1024, NULL);


so I am thinking of doing this in a very fast loop

int data_waiting = 0;

if ((ima_client) && (net_query(ServerChannel)) data_waiting = 1;

if (ima_server)
   for (int n=0; n<ClientNum; n++)
      if ((ClientChannel[n]) && (net_query(ClientChannel[n]))) data_waiting = 1;


but then what?

set the flag?

I don't think I am getting any better here

I don't want to check as fast as the processor will let me.

I just want a way of timing the calls without wasting time...

I don't think that this condition variable will do what I want, I will still spin lock checking that....







Using very short allegro timers in separate thread and getting lots of cpu usage in task manager.


I am trying to use an allegro timer to control how often I check for packets in a thread dedicated just to checking for and reading packets into a buffer.

It works as expected, but takes up almost 100% cpu for all 4 cores (I'm looking in windows task manager)






The whole reason I started this....

I used to check for packets once per frame (in my case 25ms)
This was/is fine for game state info, as I can't really use it any earlier anyway.


But I also send packets that I use to control the timing relationship between the master and the clients.
These packets I want to receive and process immediately, not wait until the end of the 25ms game loop.

So what I did was to continually look for and process packets in the wait time at the end of every frame.
This improved the accuracy of timing when I received the packets.

loop()
{
   if (game_loop_event_timer)
   {
      get input
      move
      draw
   }

   fast_packet_proc()

}


But there was still a problem.

When the time it takes to process and draw a frame increases, the wait time at the end of the frame decreases.
And that is the only time I was checking for new packets.
If it took 20ms to process a frame, I only had 5ms left to recieve packets.
And then my timing was considerably less accurate.




So I looked into and implemented a separate thread to look for and process packets.
If it is a timing packet, it is processed immediately.
Otherwise is is added to a buffer and processed at the start of the next frame.




That worked, but I am having some issues about timing.

Initially the thread ran as fast as it could:

void *mwPacketBuffer::rx_thread_func(ALLEGRO_THREAD *thr, void *arg)
{
   mPacketBuffer.add_to_rx_buffer();
}

Sometimes it would run 10,000 times per frame!
Besides the wasted time and resources, it also ran so fast, it barely left any time the mutex's were unlocked.



So I experimented with ways to throttle it down to a more reasonable time

Instead of 10,000 times per frame, I would be happy if it only ran 250 times
That way I could measure time to .1ms or 100us

Initially I just simply tried al_rest()

Then I tried using a timer.


thr_timer = al_create_timer(0.0001);    // .1ms
al_register_event_source(event_queue, al_get_timer_event_source(thr_timer));
al_start_timer(thr_timer);
if (ev.timer.source == thr_timer) thr_proc = 1;

void *mwPacketBuffer::rx_thread_func(ALLEGRO_THREAD *thr, void *arg)
{
   while (1)
   {
//      al_rest(0.001);
//      mPacketBuffer.add_to_rx_buffer();

      if (mEventQueue.thr_proc)
      {
         mPacketBuffer.add_to_rx_buffer();
         mEventQueue.thr_proc = 0;
      }
   }
}


It seems to work and my game seems to runs fine, but in windows task manager all four cores peg out at nearly 100%

Is this normal for allegro timers?
Am I using them wrong?
Is it because the timer interval is so small? (100us)

I really want to find a way to limit the thread from running wide open at 10,000 iterations per frame, that also doesn't take up so much cpu time.

Also any other advice or pointers would be greatly appreciated!

I am really new to threads, this is the first time I have actually used them for something other than simple example programs.





-----------------------------


tx buffer...

that could benefit from the tx_buf_empty


I don't even know why I am bothering with a tx buffer?

why don't I just send immediatley?

I used to do that...

what possible benefit could I have from enqueing?



I now send packets immediately

I am having weird issues with seconf client joining, or is it just 4230?

just 4230...sync is funny


that comes from stdf packets, does it not??



-----------------
testing al_rest()


al_rest(0.001)
54%
90 20 90 20

timer 0.001
75%
95 95 95 20


put the print back in but only print once per second


al_rest(0.001)
50%
5 95 75 20
(on e6420 I get 1000 per second, but on m36 I only get 500)


timer 0.001
75%
25 95 80 95



lets try 0.0005

timer 0.0005
75%
95 90 20 95
both about 2000/s

al_rest(0.0005)
70-75%
95 90 5 95
(on both system runs wide open m36 1M/s, e6420 500k/s



lets try 0.0001

timer 0.0001
70%
95 95 95 10
both about 9000/s

al_rest(0.0001)
70-75%
95 90 5 95
(on both system runs wide open m36 1M/s, e6420 500k/s



just to get more data:
0.005


timer 0.005
50%
95 20 20 80
m36 200/s, e6420 199/s

al_rest(0.005)
25%
40 0 60 0
m36 160/s, e6420 199/s



0.01


timer 0.01
50%
95 20 20 80
m36 100/s, e6420 100/s

al_rest(0.01)
25%
60 0 40 0
m36 91/s, e6420 99/s



Timer    expected    al_rest                  al_timer
value    calls/sec   cpu  actual calls/sec    cpu  actual calls/sec
-------------------------------------------------------------------
0.01     100         25   90-99               50%  100
0.005    200         25   160-199             50%  200
0.001    1000        50   500-1000            75%  1000
0.0005   2000        75   1,000,000           75%  2000
0.0001   10000       75   1,000,000           70%  9000





I am now thinking that signals might help...
I was reading about how condition variables can be used to pause a thread.
Then I would need to use some external method to set the condition variable with the allegro timer..
I think I would need to check the event_loop and it would all be based on how often I check that....
probably back to square 1



Hell I could even just do it myself with repeated call to al_get_time(), although would hammering that call in its own thread be any better?


      static double t0 = al_get_time();
      double t1 = al_get_time();
      if (t1-t0>0.001)
      {
         t0 = t1;
         mPacketBuffer.add_to_rx_buffer();
      }


my timer 0.005
50%
99 10 95 0
m36 200/s, e6420 200/s


my timer 0.001
50%
99 10 95 0
m36 1000/s, e6420 1000/s



my timer 0.0005
50%
99 10 95 0
m36 2000/s, e6420 2000/s


my timer 0.0001










void _al_win_rest(double seconds)
{
   if (seconds <= 0)
      return;

   Sleep((DWORD)(seconds * 1000.0));
}


void _al_unix_rest(double seconds)
{
   struct timespec timeout;
   double integral;
   double frac;

   frac = modf(seconds, &integral);
   timeout.tv_sec = (time_t)integral;
   timeout.tv_nsec = (suseconds_t)(frac * 1e9);
   nanosleep(&timeout, 0);
}




another big question?

why do I wait until the start of the frame to proccess rxed packets?
what would happen if I processed them as I got them?
like, why do I even bother with putting them in a buffer?
Well one reason is the variables that processing modifies, would need to be protected with mutexes...



20231007

I have some other things I think I broke:
- one client works ok but when second one joins:
2nd client has no ping
1st client's dsync goes to hell



make sure that all ping packets use the proper player number...


void mwNetgame::client_send_ping(void)
{
   char data[1024] = {0};
   sprintf(data, "ping");
   int pos = 4;
   mPacketBuffer.PacketPutDouble(data, pos, al_get_time());
   mPacketBuffer.add_to_tx_buffer(data, pos, 0);
   // printf("%d ping server\n", mLoop.frame_num);
}


detour:
remove all add_to_tx_buffer
now all packets are sent with ServerSend and ClientSend and they all use the new method of creating packets

make sure all packets are received the same...

ClientReceive is good
ServerReceive is good

what about packet_buffer?
things are received into packet_buffer...
what else could i do?

packet_buffer is not thread safe
but as long as the only thing using it is my thread, it should be OK?

nothing that sends uses it...double check


I need my own packet read that checks the header and I can pass a data struct to...
then I will not need packet_buffer

this has all been removed from mNetgame.h
//   char packetbuffer[1024];
//   int packetsize;
//   int packetpos;
//   void set_packetpos(int pos);
//   int get_packetpos(void);
//   void Packet(const char *id);
//   int PacketRead(const char *id);
//
//   void PacketPutDouble(double);
//   double PacketGetDouble(void);


Hopefully this has simplified things....

now back to tracing pings and player nums

void mwNetgame::client_send_ping(void)
{
   char data[1024] = {0}; int pos;
   mPacketBuffer.PacketName(data, pos, "ping");
   mPacketBuffer.PacketPutDouble(data, pos, al_get_time());
   ClientSend(data, pos);
   // printf("%d ping server\n", mLoop.frame_num);
}


// receives all waiting packets and puts them in the rx buffer
void mwPacketBuffer::add_to_rx_buffer(void)
{
   char data[1024] = {0};

   double t0 = al_get_time();

   if (PM) al_lock_mutex(rx_mutex);

   mTally[2].add_data(al_get_time() - t0);

   int who = -1;
   if (mNetgame.ima_server)
      while(mNetgame.ServerReceive(data, &who))
         add_to_rx_buffer_single(data, who);


void mwPacketBuffer::add_to_rx_buffer_single(char *data, int who)
{
   // process these immediately and do not add to buffer
   if (PacketRead(data, "ping"))
   {
      memcpy(rx_buf[199].data, data, 1024);
      rx_buf[199].packetpos = 4;
      mNetgame.server_proc_ping_packet(199);
      return;
   }


void mwNetgame::server_proc_ping_packet(int i)
{
   int who = mPacketBuffer.rx_buf[i].who;
   int p = mNetgame.get_player_num_from_who(who);
   if (p != -1)
   {
      //printf("rx ping from p:%d - tx pong\n", p);

      double t0 = mPacketBuffer.PacketGetDouble(i);
      double t1 = al_get_time();

      char data[1024] = {0}; int pos;
      mPacketBuffer.PacketName(data, pos, "pong");
      mPacketBuffer.PacketPutDouble(data, pos, t0);
      mPacketBuffer.PacketPutDouble(data, pos, t1);
      ServerSendTo(data, pos, who);
   }
}


ima stop right here and not use buffer 199 to pass data...

the problem is, all my packet put and get, just read from the buffer

could I have both methods?

one that takes the buffer index and one that just takes raw data and pos?

is that unneccesairily complex?

it looks like it is only the readers...the writers already are like that...

It was not that complex, the only one I had to change was get double


void mwPacketBuffer::add_to_rx_buffer_single(char *data, int who)
{
   // process these immediately and do not add to buffer
   if (PacketRead(data, "ping"))
   {
      mNetgame.server_proc_ping_packet(data, who);
      return;
   }

void mwNetgame::server_proc_ping_packet(char *data, int who)
{
   int p = mNetgame.get_player_num_from_who(who);
   if (p != -1)
   {
      //printf("rx ping from p:%d - tx pong\n", p);

      int pos = 4;
      double t0 = mPacketBuffer.PacketGetDouble(data, pos);
      double t1 = al_get_time();

      mPacketBuffer.PacketName(data, pos, "pong");
      mPacketBuffer.PacketPutDouble(data, pos, t0);
      mPacketBuffer.PacketPutDouble(data, pos, t1);
      ServerSendTo(data, pos, who);
   }
}







Now that I have that done, the problem seems to be fixed

more clients do not screw up...

test with even more...

OK it looks like everything is working

now try to enable thread...



al_rest(0.002) // target 500
s 333
c 500
e6430 25%
4230 50%
pings are either 3 or 6


no thread
s 155K
c 100-900K
e6430 25%
4230 50%
pings are 0.1 4 10...


al_rest(0.001) // target 1000
s 500
c 1000
e6430 27%
4230 54%
pings are either 2 or 4


my al_rest(0.001) // target 1000
s 1000
c 1000
e6430 40%

all other clients dropped with high cpu
e6430 has over 100 cpu frequently but has not droppped

this happens even with one client...test like that and see what is slowing it down

reduced to 0.01 and still bad...



I am thinking that I might try C++ threads

why?

because then maybe I can use thread sleep...


OK here are the results:


class mwPacketBuffer
{
   public:

   int thread_running = 0;
   std::thread t1;



mwPacketBuffer::mwPacketBuffer()
{
   init_packet_buffer();
   rx_mutex = al_create_mutex();

   if (PT) t1 = std::thread(&mwPacketBuffer::crx_thread_func, this);

}


void mwPacketBuffer::crx_thread_func(void)
{
   while (1)
   {
      if (thread_running) mPacketBuffer.add_to_rx_buffer();
      std::this_thread::sleep_for(std::chrono::microseconds(1000));
//      std::this_thread::sleep_for(std::chrono::milliseconds(1));
   }
}



if I try to go less than 1000us i get no delay at all

so here are the results at 1ms
s 1000
c 1000
e6430 27%
4230 55%
pings are usually 1 or 2 sometimes up to 8


and here are the wide open results
s 800k
c 150 - 900k
e6430 48%
4230 95%
pings are 0.1 or 0.2
4230 quits due to lost server and high cpu



------------------------
this is better if I can get it to work at 1ms

I figured out how to quit nicely

now I want to use c++ mutex


OK done

now I want to see if it works in linux....


yes... I have an 8 player game with remote also
lev 64 full fakekey

server and clients doing 1ms packet buffer checks

looks like c++ threads is doing its job.

very similar to what al_threads and al_rest was doing except I couldn't set al_rest to 1000, m36 only did 500, but all the rest did 1000

I want to be able to change between the different methods easily...

cthread
athread
nthread

thread_type 0=none 1=al 2 =c++


ok I can switch between them now

lets do a final comparison on pmh



------------------------
no threads
-----------------------
pmh  175k 700ms 4us
6430 800k 700ms 0.8us
4230  90k 400ms 5us

task manager cpu
6430 26
4230 55

game cpu
pmh 24
6430 12
4230 40

pings 18-35

fakekey number are about the same


---------------------------------
allegro threads 1ms with al_rest
---------------------------------

pmh  1K 6ms  6us
6430 1K 16ms 16us
4230 1K 30ms 30us

task manager cpu
6430 25
4230 58

game cpu
pmh 24
6430 12
4230 40

pings 20-40

fakekey numbers are about the same


---------------------------------
C++ threads 1ms
---------------------------------

pmh  1K 8ms  8us
6430 1K 16ms 16us
4230 1K 35ms 35us

task manager cpu
6430 25
4230 58

game cpu
pmh 24
6430 12
4230 40

pings 20-40

fakekey numbers are about the same


so with all these different methods, i don't see much difference



---------------------------------
allegro threads 1ms with my al_get_time
---------------------------------
clients use so mucg gcpu that they do not stay connected



so if I do not see any improvemnet on using threads as opposed to my original method, should I just go back to that?

I want to put a couple more calls to fast packet stuff in the middle of my game loop...


I am looking at what low level shit libnet does under the hood...
first of all, what driver does it use?


   // detect drivers in the internet class
   drivers = net_detectdrivers(net_classes[NET_CLASS_INET].drivers);
   drivernames = net_getdrivernames(drivers);

   NetworkDriver = drivernames[0].num; // use first detected driver



implemented a test to see if any data is waiting

int mwNetgame::is_data_waiting(void)
{
   int data_waiting = 0;

   if (mNetgame.ima_server)
   {
      if (TCP)
      {
         for (int n=0; n<ClientNum; n++)
            if ((ClientConn[n]) && (net_query_rdm(ClientConn[n]))) data_waiting = 1;
      }
      else // UDP
      {
         for (int n=0; n<ClientNum; n++)
            if ((ClientChannel[n]) && (net_query(ClientChannel[n]))) data_waiting = 1;
      }
   }

   if (mNetgame.ima_client)
   {
      if (TCP)
      {
         if (net_query_rdm(ServerConn)) data_waiting = 1;
      }
      else // UDP
      {
         if (net_query(ServerChannel))  data_waiting = 1;
      }
   }
   return data_waiting;
}

does not seem to make anything faster or better

I have some more data on that...

running with no thread:
check runs about 720Hz takes abput 1.1ms total and 1.6 us avg


m36
chck:720Hz tot:1.1ms avg:1.6us
proc:40    tot:0.1ms avg:2.8us


e6430
chck:720Hz tot:1.8ms avg:2.6us
proc:40    tot:0.3ms avg:7us

720Hz = 18 per frame

compare this with no check:


m36
proc:720    tot:0.6ms avg:0.9us

e6430
proc:720    tot:1.5ms avg:2.3us


why 720Hz??

I was getting hundreds of thousands last time it was unlocked

I don't know wtf nut now its better:



no check:

m36
proc:1.4M    tot:840ms avg:0.6us

e6430
proc:1M      tot:777ms avg:0.75us


check:

m36
chck:1.7M  tot:875ms avg:1.2us
proc:42    tot:0.1ms avg:2.9us

e6430
chck:600k  tot:800ms avg:1.3us
proc:41    tot:0.7ms avg:17us



this is looking good

should I just remove all TCP?

I never use it and it just complicates things

yes, I should do that.....

start with client....

TCP/UDP has been removed!!!


what would it look like with the thread wide open now?

do c++ with no limit...






I have done much more experimenting and here is what I have found:

Allegro threads with al_rest() work like I would expect. They do not spin lock and waste cpu time.
The down side is that I cannot seem to get lower than 1 ms with al_rest() and 2ms on a windows 10 machine.

I experimented with C++ 11 std:threads and got very similar results
I used std::this_thread::sleep_for() but I was again not able to get better that 1ms.

I am pretty sure its limited by the underlying system.

My method of:

static double t0 = al_get_time();
double t1 = al_get_time();
if (t1-t0 > 0.001)

turned out to be the worst of all.
It could actually do times less than 1ms, but the high cpu usage caused everything else to break.

So I will proabably stick with running the packet checking thread at 1000Hz, which is not so bad.

Or I will go back to the old method, of checking as fast as it will go, but only in the wait time after processing the game loop.

I have actually added a few more manual packets checks in the middle of the game loop to help.



It is really a shame though that it does not seem possible to throttle the speed of the thread past a certain point.

1000Hz (or 1ms) seems to be the limit.  But yet when there is no limit it can run at 200kHz (5us) to over 1MHz (<1us)




c++ check no limit:

m36
chek:700k      tot: 970ms avg:1.3us
proc:42        tot:.078ms avg:1.9us

6430 (uses 50% tcpu)
chek:650k      tot: 950ms avg:1.4us
proc:41        tot: 1.4ms avg:34us

4230 (uses 100% tcpu)
chek:164k      tot: 846ms avg:5us
proc:250       tot: 14ms  avg:34us





try c++ check limit 100us on linux


200us
add_rx_buf checked:3753 tot_ctime:  9.3768ms  avg_ctime:  2.4985us  proc:42 tot_ptime:  0.1838ms  avg_ptime:  4.3755us
add_rx_buf checked:3753 tot_ctime:  9.3989ms  avg_ctime:  2.5044us  proc:41 tot_ptime:  0.1801ms  avg_ptime:  4.3921us
add_rx_buf checked:3754 tot_ctime:  9.4023ms  avg_ctime:  2.5046us  proc:43 tot_ptime:  0.1973ms  avg_ptime:  4.5880us

100us
add_rx_buf checked:6491 tot_ctime:  8.3674ms  avg_ctime:  1.2891us  proc:42 tot_ptime:  0.1552ms  avg_ptime:  3.6959us
add_rx_buf checked:6499 tot_ctime:  8.2620ms  avg_ctime:  1.2713us  proc:42 tot_ptime:  0.1258ms  avg_ptime:  2.9943us
add_rx_buf checked:6500 tot_ctime:  8.2576ms  avg_ctime:  1.2704us  proc:42 tot_ptime:  0.1250ms  avg_ptime:  2.9759us

10us
add_rx_buf checked:15751 tot_ctime: 19.9012ms  avg_ctime:  1.2635us  proc:40 tot_ptime:  0.1302ms  avg_ptime:  3.2549us
add_rx_buf checked:15749 tot_ctime: 19.8932ms  avg_ctime:  1.2631us  proc:41 tot_ptime:  0.1220ms  avg_ptime:  2.9754us
add_rx_buf checked:15747 tot_ctime: 19.9158ms  avg_ctime:  1.2647us  proc:42 tot_ptime:  0.1244ms  avg_ptime:  2.9620us


1us
add_rx_buf checked:18219 tot_ctime: 34.9331ms  avg_ctime:  1.9174us  proc:38 tot_ptime:  0.1522ms  avg_ptime:  4.0053us
add_rx_buf checked:18223 tot_ctime: 35.0056ms  avg_ctime:  1.9210us  proc:42 tot_ptime:  0.1736ms  avg_ptime:  4.1336us
add_rx_buf checked:18215 tot_ctime: 35.0842ms  avg_ctime:  1.9261us  proc:41 tot_ptime:  0.1601ms  avg_ptime:  3.9042us



no limit...

add_rx_buf checked:535547 tot_ctime:983.9508ms  avg_ctime:  1.8373us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
add_rx_buf checked:535127 tot_ctime:983.9828ms  avg_ctime:  1.8388us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
add_rx_buf checked:535681 tot_ctime:983.9105ms  avg_ctime:  1.8367us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
add_rx_buf checked:535749 tot_ctime:983.9031ms  avg_ctime:  1.8365us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
add_rx_buf checked:535727 tot_ctime:983.8707ms  avg_ctime:  1.8365us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
[10][0][1677]|        Server received initial 1234 packet from '70.75.230.31:24785'     |
[10][0][1677]|        Server opened channel for `70.75.230.31:24785' and sent reply     |
add_rx_buf checked:525691 tot_ctime:984.1130ms  avg_ctime:  1.8720us  proc:0 tot_ptime:  0.0000ms  avg_ptime:  0.0000us
[10][0][1682]+--------------------------------------------------------------------------+
[10][0][1682]|        Server received join request from e6430 requesting color:8        |
[10][0][1682]|        Server replied with join invitation:                              |
[10][0][1682]+--------------------------------------------------------------------------+
add_rx_buf checked:404262 tot_ctime:988.5307ms  avg_ctime:  2.4453us  proc:37 tot_ptime:  0.1870ms  avg_ptime:  5.0541us
add_rx_buf checked:404047 tot_ctime:987.6136ms  avg_ctime:  2.4443us  proc:38 tot_ptime:  0.1880ms  avg_ptime:  4.9473us
add_rx_buf checked:403807 tot_ctime:987.6706ms  avg_ctime:  2.4459us  proc:42 tot_ptime:  0.1900ms  avg_ptime:  4.5230us
add_rx_buf checked:404099 tot_ctime:987.7178ms  avg_ctime:  2.4442us  proc:42 tot_ptime:  0.1892ms  avg_ptime:  4.5052us


timeBeginPeriod(1)

https://stackoverflow.com/questions/13397571/precise-thread-sleep-needed-max-1ms-error

https://github.com/jhu-cisst/cisst/blob/master/cisstOSAbstraction/code/osaSleep.cpp


its the same thing as when I went down this rabbit hoel 20 years ago. timing is difficlut.

I am just going to live with what I get and I think that 1ms is good enough.


So now I two options:

- no thread, wide open
- thread capped at 1ms
or I could run a training session and dynamically adjust the timer value until it was not wide open

that is pretty much all I want, not wide open...


I have some other bugs to work on,

like why does the game lose server connection when adjusting screen size?


lets see if I can dynamically adjust the time of the thread

and check how it is working


I want to store how fast the thread is running, but where?

not player struct, I dump everything there...

how about in a mTally owned by mPacketBuffer

I will store the number of times the thread has been run and reset it every second

I could move the check to packet buffer also..done


rx_buf chek:3187 tot:0.213ms  avg:0.067us  proc:0 tot:0.000ms  avg:0.000us twus:250.344090
add_rx_buf chek:3334 tot:0.224ms  avg:0.067us  proc:0 tot:0.000ms  avg:0.000us twus:237.826885
add_rx_buf chek:3493 tot:0.235ms  avg:0.067us  proc:0 tot:0.000ms  avg:0.000us twus:225.935541
add_rx_buf chek:3615 tot:0.239ms  avg:0.066us  proc:0 tot:0.000ms  avg:0.000us twus:214.638764
add_rx_buf chek:3750 tot:0.251ms  avg:0.067us  proc:0 tot:0.000ms  avg:0.000us twus:203.906826
add_rx_buf chek:3912 tot:0.265ms  avg:0.068us  proc:0 tot:0.000ms  avg:0.000us twus:193.711484
add_rx_buf chek:4054 tot:0.264ms  avg:0.065us  proc:0 tot:0.000ms  avg:0.000us twus:184.025910
add_rx_buf chek:4408 tot:0.104ms  avg:0.024us  proc:0 tot:0.000ms  avg:0.000us twus:174.824615
add_rx_buf chek:4575 tot:0.104ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:166.083384
add_rx_buf chek:4775 tot:0.101ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:157.779215
add_rx_buf chek:5000 tot:0.106ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:149.890254
add_rx_buf chek:5148 tot:0.110ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:142.395741
add_rx_buf chek:5329 tot:0.118ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:135.275954
add_rx_buf chek:5538 tot:0.130ms  avg:0.024us  proc:0 tot:0.000ms  avg:0.000us twus:128.512157
add_rx_buf chek:5749 tot:0.124ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:122.086549
add_rx_buf chek:6000 tot:0.128ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:115.982221
add_rx_buf chek:6165 tot:0.132ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:110.183110
add_rx_buf chek:6381 tot:0.144ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:104.673955
add_rx_buf chek:6624 tot:0.153ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:99.440257
add_rx_buf chek:6833 tot:0.145ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:94.468244
add_rx_buf chek:7079 tot:0.152ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:89.744832
add_rx_buf chek:7273 tot:0.155ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:85.257590
add_rx_buf chek:7549 tot:0.168ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:80.994711
add_rx_buf chek:7784 tot:0.166ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:76.944975
add_rx_buf chek:7987 tot:0.175ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:73.097727
add_rx_buf chek:8249 tot:0.175ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:69.442840
add_rx_buf chek:8492 tot:0.191ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:65.970698
add_rx_buf chek:8745 tot:0.222ms  avg:0.025us  proc:0 tot:0.000ms  avg:0.000us twus:62.672163
add_rx_buf chek:8994 tot:0.191ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.538555
add_rx_buf chek:9248 tot:0.198ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.561627
add_rx_buf chek:8998 tot:0.193ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.389709
add_rx_buf chek:9248 tot:0.198ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.420223
add_rx_buf chek:8997 tot:0.202ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:59.241234
add_rx_buf chek:9249 tot:0.199ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.279173
add_rx_buf chek:8998 tot:0.192ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.093131
add_rx_buf chek:9249 tot:0.201ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:56.138475
add_rx_buf chek:9082 tot:0.193ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:58.945399
add_rx_buf chek:9081 tot:0.210ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:58.798035
add_rx_buf chek:9080 tot:0.213ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:58.651040
add_rx_buf chek:9081 tot:0.215ms  avg:0.024us  proc:0 tot:0.000ms  avg:0.000us twus:58.504412
add_rx_buf chek:9082 tot:0.197ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.358151
add_rx_buf chek:9081 tot:0.197ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.212256
add_rx_buf chek:9078 tot:0.195ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:58.066725
add_rx_buf chek:9160 tot:0.195ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:57.921558
add_rx_buf chek:8911 tot:0.192ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:60.817636
add_rx_buf chek:9160 tot:0.197ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:57.776755
add_rx_buf chek:8921 tot:0.190ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:60.665592
add_rx_buf chek:9158 tot:0.195ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:57.632313
add_rx_buf chek:8923 tot:0.190ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:60.513928
add_rx_buf chek:9155 tot:0.196ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:57.488232
add_rx_buf chek:8934 tot:0.195ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:60.362644
add_rx_buf chek:9160 tot:0.197ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:57.344511
add_rx_buf chek:8932 tot:0.190ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:60.211737
add_rx_buf chek:9160 tot:0.195ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:57.201150
add_rx_buf chek:8917 tot:0.193ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:60.061208
add_rx_buf chek:9164 tot:0.199ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:57.058147
add_rx_buf chek:8999 tot:0.193ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.911055
add_rx_buf chek:9250 tot:0.199ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:56.915502
add_rx_buf chek:8997 tot:0.194ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:59.761277
add_rx_buf chek:9250 tot:0.197ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.773213
add_rx_buf chek:8999 tot:0.192ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.611874
add_rx_buf chek:9249 tot:0.199ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.631280
add_rx_buf chek:8999 tot:0.193ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.462844
add_rx_buf chek:9249 tot:0.197ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.489702
add_rx_buf chek:8998 tot:0.192ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:59.314187
add_rx_buf chek:9249 tot:0.198ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.348478
add_rx_buf chek:8999 tot:0.193ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:59.165901
add_rx_buf chek:9250 tot:0.197ms  avg:0.021us  proc:0 tot:0.000ms  avg:0.000us twus:56.207606
add_rx_buf chek:8997 tot:0.206ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:59.017987
add_rx_buf chek:9250 tot:0.214ms  avg:0.023us  proc:0 tot:0.000ms  avg:0.000us twus:56.067087
add_rx_buf chek:9080 tot:0.202ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.870442
add_rx_buf chek:9083 tot:0.195ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.723266
add_rx_buf chek:9082 tot:0.197ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.576457
add_rx_buf chek:9083 tot:0.198ms  avg:0.022us  proc:0 tot:0.000ms  avg:0.000us twus:58.430016

linux works but not goddamn windows

skip this auto adjust...

I will either do 1000 in thread or no thread







no thread server 4230
140k
60 tcpu
95 thread
25 thread
50 gcpu


C++ 1000 server 4230
900
55 tcpu
75 thread 1
35 thread 2
47 gcpu

not much goddamn difference



no thread server 6430
6M
27 tcpu
90 thread 1
10 thread 2
0  thread 3
0  thread 4
10 gcpu

C++ 1000 server 6430
990
25 tcpu
70 thread 1
40 thread 2
0  thread 3
0  thread 4
10 gcpu

not much goddamn difference


no thread server m36
12M
12 tcpu
100 thread 1
10  thread 2
10  thread 3
9 threads nothing
3 gcpu


C++ 1000 server m36
980
12 tcpu
100 thread 1
10  thread 2
10  thread 3
9 threads nothing
3 gcpu

not much goddamn difference


so if there is barely any difference....am going to use threads or not?

threads:
stable speed
does not run wide open
more complex

no threads:
simpler
runs faster

lets go with not...

maybe make it possible to alter without recompiling


so now what else?

is joining having issues?
does not seem to be


what happens when screen is adjusted

I lose my stream of stdf's??


how long does it that take to recreate all bitmaps?

m36  100ms
6430 200ms
4230 700ms

the worst are tiles and icons

anyway, what I want to know is why communication dies after this delay...it should recover...


do some logs with m36 server and 6430 client


from the client logs, it looks like it just stopped receiving stdf packets
1715 last stdf


around 1638 started getting full difs
but they were not applied because they were in the future
then more full difs came but still in the future...

..just a thought.. when that happens, why don't I just jump to the future?
what do I gain by waiting for my simulation to catch up??

this seems to work great!!!

I am very happy with that


now can I do something about join?
it is fine...

I want to combine:

both server exits..done
both server inits..done

both client exits..done
both client inits..done










stak sends dsync avg to server


I want to trace what actually uses dsync

there are like 40 refs, most not usefull, so I rename the ones in the player struct to

pdsync
pdsync_avg

now only 15 refs

pdsync
set on client in timer adj
also added to RA at same time
also pdsync_avg set

pdsync_avg
set on client in timer adj
use for timer adj
sent to server in stak


server uses pdsync to lock client
but that is the one that client sent and has been averaged already

what can I do to uncomplicate this?







#define PM_GAMEMOVE_TYPE_PLAYER_ACTIVE    1
#define PM_GAMEMOVE_TYPE_PLAYER_INACTIVE  2
#define PM_GAMEMOVE_TYPE_CLIENT_JOIN      3
#define PM_GAMEMOVE_TYPE_CLIENT_QUIT      4
#define PM_GAMEMOVE_TYPE_MOVE             5
#define PM_GAMEMOVE_TYPE_LEVEL_DONE_ACK   8

is there a level done move? 6

I could not find one...

maybe there used to be....










local server quits

this is the only thing that ever enters: PM_GAMEMOVE_TYPE_CLIENT_QUIT

      // ----------------------------------------------------------------------------------------
      // local server quitting
      // ----------------------------------------------------------------------------------------
      if ((mNetgame.ima_server) && (data1 == 0))
      {
         // first set all connected clients to inactive
         for (int p=1; p<NUM_PLAYERS; p++)
            if (mPlayer.syn[p].control_method == 2)
            {
               add_game_move2(frame + 2,  PM_GAMEMOVE_TYPE_CLIENT_QUIT,     p, 0);
               add_game_move2(frame + 10, PM_GAMEMOVE_TYPE_PLAYER_INACTIVE, p, 64);
            }
         // then set server to inactive in future
         add_game_move2(frame + 10, PM_GAMEMOVE_TYPE_PLAYER_INACTIVE, 0, 64);
         return;
      }

then when gma is processed that calls:

case PM_GAMEMOVE_TYPE_CLIENT_QUIT:      proc_client_quit_game_move(x); break;

void mwGameMoves::proc_client_quit_game_move(int x)
{
   if (mNetgame.ima_server)
   {
      int p = arr[x][2];  // player number
      mPlayer.syn[p].control_method = 8;
   }
}

then it will be synced to client...


void mwNetgame::client_proc_player_drop(void)
{
   int p = mPlayer.active_local_player;
   if (mPlayer.syn[p].control_method == 8)
   {
      mPlayer.loc[p].quit_reason = 92;
      mLog.log_ending_stats_client(LOG_NET_ending_stats, p);
      mScreen.rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, 10, -2, 1, "SERVER ENDED GAME!");
      al_flip_display();
      mInput.tsw();
      mLoop.state[0] = 1;
   }



#define PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER  0
#define PM_PLAYER_CONTROL_METHOD_DEMO_MODE      1
#define PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE 2
#define PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL   3
#define PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL   4
#define PM_PLAYER_CONTROL_METHOD_CLIENT_THAT_SERVER_QUIT_ON 8
#define PM_PLAYER_CONTROL_METHOD_CLIENT_USED    9

I have done all the control moves also....


I am going to push, and to make release versions



So I did and all things are looking good...



Kaileb found a bug about jumping up through a solid block when there is a semi-solid below

it is very easy to reproduce..

level 18


I do not have any time to look into it now

I made this one change and it does not do it anymore
all demo play back good except for 51 - cannon bees


fix that demo level

old time:2:21

cut in time:1:05

done

new time 2:20



            float oy = syn[p].y;

            int y = syn[p].y;

            int ym20 = y % 20;

            if (ym20 < 19)
            {

               syn[p].yinc = 0;              // kill downwards motion
               syn[p].y = y - ym20;          // align with floor

            }


//            syn[p].yinc = 0;                  // kill downwards motion
//            syn[p].y = y - (y % 20);          // align with floor

//            printf("player moving down and collison:%f   %f  %d\n", oy, syn[p].y, ym20);













can I remote control a server that is not headless? I sure can!!

20231010 9:30 AM
new version 7.24.1010.2
push and release










20231017 back from vacation


had trouble with netgame and davis's router

he had to bind a specific port and ip to one computer to get it to work

testing at home:

all clients initiate with 24785 as the port, so does server

when clients join, the server shows them having 24785, unless it is the second or greater one from my home then they have other ports...

I have upnp setup on my home router, but it does not look like it is doing anything

the three entries in the list are not ones that I am using for clients


what else do I want to check?

test other routers and locations

I could test at customers homes!!!


I want to make logging for connections and attempts


What do I want to see?

From the server's POV

YYYMMDDHHMMSS timestamp

IP, port, hostname

1 - server rx connection attempt and sent reply to initiate channnel
2 - server rx cjon and reply with sjon
3 -


the becoming active thing seems to never get called...

do I always have my clients active?

when server send sjon it sets up the client as active.
I just tested by setting it to inactive, and the lock thing happened...
Is this just unnessary?  wow, I wonder for how long....


I am going to leave off the inactive for now

but what does this all mean?


can I still tell if the client connection attempt fails?


I guess if the connection attempt 1 occurs on the server, but then the server never gets the cjon....

does this ever fill up the client slots on the server?

I never had an issue, but I also never checked...


So basically the server connection log I want is:

was it successfull?
how long was the session?
how many keys pressed?


was it successfull could be answered by if I get an accompanying cjon after the connection attempt

how long was the session will need to look at multiple logs


I am thinking of making a separate log for the server that just keeps track of these things.
Connections and how long they last.




Test the game with multiple router setups....

find out what it take to make it work....


My router Nighthawk r7000 seems to work for all clients at home
but does it work if I disable uPnp?


try other routers, but use second internet connection



e6430 eidnet direct - yes
e6430 eidnet beacon 6 - no
see if I can find a setting on the router that will allow it


enabled uPNP and DLNA .. no change

what did work was port forwarding
for a specific LAN client
UDP
WAN 1-65000
LAN 1-65000

left Wan Connection as is...1_TR069_INTERNET_OTHER_R_VID_0
actually it is not edittable....



On my router:
Hardware version: R7000P
Firmware version: v1.3.1.64_10.1.36

no port forwarding...
UPNP On
Advertisment period: 30 min
Advertisment time to live: 4 hops

there are three entries in the list, but none that look like anything related to pm
tcp 16816 16816 192.168.1.106
udp 16816 42831 192.168.1.106
udp 56147 56147 192.168.1.118

106 is hop
118 is not connected when I looked
UDP port 56147 does not match any common things

turned off UPNP and it still works on R7000


I dont have any other router to try right now...

should bring home calix and r195 to test

also test tethered to phone...


calix
------------
factory default
ping works
pm doesnt work
upnp is on by default
firewall has high security by default and even turning it off has no effect

port forwarding is what makes it work
on calix I set up a specific LAN IP (or name) UDP 1-65000 to any external IP
also on calix I can do application forwarding, but it still only works for one LAN client

calix also has a DMZ section that might work for a server

R195
-----
factory defaults
ping works, pm not
port forward
src:96.45.13.253
dst: 192.168.1.213
UDP 1-65000
reboot
does not work....
try DMZ
does not work either....
give up


right arrow on menu does not advance level past 10...fixed, set to 199







server full does not get displayed, instead tries to load level 000
I think I fixed this, need to test...


Stats msg on overworld with frame 1, text lines up differently in linux

level 1
w48 h14

also see level 96
h:17
h:13

I do not see the issue on scat, maybe 1 line lower at best...

what version opengl??

display flags both are the same:
WINDOWED
OPENGL
RESIZEABLE

display options:
OPENGL 4.5 (scat)
OPENGL 3.3 (6510)

that would be the difference....

I am not going to fight with this, it works in direct x and open gl 4, but not opengl 3



20231022 bump version and do new release





20231119

bug - playing back muliplayer games does not work


m36 server
e6430 client


player 1 never goes active...

what is different between playback and normal play



I have found out one thing:
The client will never be able to play back.
This is just the way things are since I no longer sync gamne moves to clients.


The server should have all the game moves though and should be able to play back.

changed this code:

old:

void mwGameMoves::proc_client_join_game_move(int x)
{
   if (mNetgame.ima_server)
   {
      int p = arr[x][2];  // player number
      int c = arr[x][3];  // color
      mPlayer.syn[p].control_method = PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE;
      mPlayer.syn[p].color = c;
   }
}


new:

void mwGameMoves::proc_client_join_game_move(int x)
{
   int p = arr[x][2];  // player number
   int c = arr[x][3];  // color
   mPlayer.syn[p].active = 1;
   mPlayer.syn[p].control_method = PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE;
   mPlayer.syn[p].color = c;
}


now it will play back properly, if the client joins....

what about when the active happens on frame 0?

how can I test that?

complete a level...

overworld would be the easiest


it does not work...

the function that looks for game moves that match current frame number, starts on frame 1

this is why the actives never get processed....

it works fine for all other modes, because the player array is only reset with mode 2
but in file play the player array is reset with mode 1...

these active and color game moves are only needed in file play

make an exception in file play mode to read them also...works...

or when enetering these active game moves, make them on frame 1...
yes...do that instead

old: if (mPlayer.syn[p].active) mGameMoves.add_game_move(0, PM_GAMEMOVE_TYPE_PLAYER_ACTIVE, p, mPlayer.syn[p].color);
new: if (mPlayer.syn[p].active) mGameMoves.add_game_move(1, PM_GAMEMOVE_TYPE_PLAYER_ACTIVE, p, mPlayer.syn[p].color);


void mwLoop::setup_common_after_level_load(void)
{
   if (!mDemoMode.mode)
   {
      // save colors in game moves array
      for (int p=0; p<NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active) mGameMoves.add_game_move(1, PM_GAMEMOVE_TYPE_PLAYER_ACTIVE, p, mPlayer.syn[p].color);
      mLog.add_headerf(LOG_NET, 0, 1, "LEVEL %d STARTED", mLevel.play_level);
   }
}

done and it works...

what about multiple joins and quits?

the join needs to reset the joining players position..done...it seems to work now, should I upload to server and test there?



changed to this:

void mwGameMoves::proc_client_join_game_move(int x)
{
   int p = arr[x][2];  // player number
   int c = arr[x][3];  // color

   if (!mNetgame.ima_server) // for demo playback only
   {
      mPlayer.init_player(p, 1);           // type 1 full reset
      mPlayer.syn[p].active = 1;
      mPlayer.set_player_start_pos(p, 0);  // set starting position
   }

   mPlayer.syn[p].control_method = PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE;
   mPlayer.syn[p].color = c;
}



this whole thing is kind of complex, but is it more complex than it needs to be?


what if I just had active and inactive

and did not care about join and quit?


I just want some way at the beginning of gm to tell what players are active and what color they are...
The way that I have it now seems the easiest, one gm for each...
assume all are off unless explicitly stated

what the hell do I do with join that I could not do with active?

PM_GAMEMOVE_TYPE_CLIENT_JOIN is only refernced 4 times in the entire project...
PM_GAMEMOVE_TYPE_CLIENT_QUIT is also only refernced 4 times in the entire project...



OK i removed all that shit, but I still have a bug I think...


I think it is all related to preparing a level for a player to enter it...


Cases:
single player new game
single player level done

client new game (joins an already playing level on the server)
- get sjon
- load level
- get first dif

the client will get most stuff from the server in the player struct
does not need the player color sent at all, that will come from the server
can I also make the self bullet thing do that?, it already does

The client should not really do anything manually to the player array..
Maybe at the very start initialize everything, but after that, just let difs set everything


I think I have all program state defines done...


testing...

It seems to work, but the issue I now have is that the headless server will only save when level is done..

that is normal, as expected

also the headless server levels have player 0 active

lets do some more experimenting....


I think what I need to do is have player 0 active but paused and invisible just like on the server
I think I will make a special game move for this

OK that seems to work

now how do I make that player not have the focus in multiplayer playback


I think I have that convoluted mess done...

Now I am having issues with clients joining and immediately being dropped...why??

what order do I do things?

It seems like it happens when starting a new level..

I thinks it has to do with where the player structure gets reset, in particular mPlayer.loc[p].client_last_stdf_rx_frame_num

can I monitor this?


Of course, now I cant make it happen...


detail the new level stuff for client

in next level player_reset mode 2 is called which should reset client_last_stdf_rx_frame_num to zero....




Clean up load and setup level

I think I have a lot of duplication in setting up a level to play
server new game and client new game do a lot of custom things
that could be covered by:

int mwLoop::load_and_setup_level_load(int level)
void mwLoop::setup_level_after_load(void)
void mwLoop::setup_players_after_level_load(int type)
void mwLoop::setup_common_after_level_load(void)

I want to do this in the interest of less code duplication
to make things simpler and easier to understand


PM_PROGRAM_STATE_NEXT_LEVEL
      mLevel.play_level = mPlayer.syn[0].level_done_next_level;
      if (load_and_setup_level_load(mLevel.play_level)) state[0] = PM_PROGRAM_STATE_MAIN_GAME_LOOP;
      else state[0] = PM_PROGRAM_STATE_MENU;


PM_PROGRAM_STATE_SINGLE_PLAYER_NEW_GAME
      if (!mMain.classic_mode) mLevel.start_level = mLevel.play_level = 1;
      if (load_and_setup_level_load(mLevel.play_level)) state[0] = PM_PROGRAM_STATE_MAIN_GAME_LOOP;
      else state[0] = PM_PROGRAM_STATE_MENU;


PM_PROGRAM_STATE_DEMO_SETUP_AND_RUN
      if (load_and_setup_level_load(mLevel.play_level))
      {
         state[0] = PM_PROGRAM_STATE_MAIN_GAME_LOOP;
         if      (mDemoMode.restore_mode == 42) mScreen.transition_cutscene(3, 1); // gate to game
         else if (mDemoMode.restore_mode == 22) mScreen.transition_cutscene(2, 1); // menu to game (single)
         else                                   mScreen.transition_cutscene(0, 1); // all other (nothing to game)
      }
      else state[0] = PM_PROGRAM_STATE_MENU;



PM_PROGRAM_STATE_SERVER_NEW_GAME

      mLog.add(LOG_OTH_program_state, 0, "[PM_PROGRAM_STATE_SERVER_NEW_GAME]\n");
      if (!mNetgame.ServerInitNetwork())
      {
         mNetgame.ServerExitNetwork();
         state[0] = PM_PROGRAM_STATE_SERVER_EXIT;
         return;
      }


      mLevel.set_start_level();

      // reset players
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 1);           // full reset
         mPlayer.set_player_start_pos(p, 0);  // set starting position for all players, active or not
      }

      mPlayer.syn[0].active = 1;
      mPlayer.syn[0].control_method = PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL;
      strncpy(mPlayer.loc[0].hostname, local_hostname, 16);

      mGameMoves.initialize();
      frame_num = 0;
      mNetgame.reset_states();
      mShot.clear_shots();

      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      initialize_graphs();


      // add initial special game moves

      mGameMoves.add_game_move(0, PM_GAMEMOVE_TYPE_LEVEL_START, 0, mLevel.play_level);

      // save colors in game moves array
      for (int p=0; p<NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active) mGameMoves.add_game_move(0, PM_GAMEMOVE_TYPE_PLAYER_ACTIVE, p, mPlayer.syn[p].color); // 1 - player_state and color

      mLog.add_headerf(LOG_NET, 0, 1, "LEVEL %d STARTED", mLevel.play_level);

      mScreen.player_text_overlay_timer = 0;

      mSound.start_music(0); // rewind and start theme
      state[0] = PM_PROGRAM_STATE_MAIN_GAME_LOOP;



now:
PM_PROGRAM_STATE_SERVER_NEW_GAME

      mLog.add(LOG_OTH_program_state, 0, "[PM_PROGRAM_STATE_SERVER_NEW_GAME]\n");
      if (!mNetgame.ServerInitNetwork())
      {
         state[0] = PM_PROGRAM_STATE_SERVER_EXIT;
         return;
      }

      if (!load_and_setup_level_load(mLevel.play_level)) state[0] = PM_PROGRAM_STATE_SERVER_EXIT;


now do client ...


PM_PROGRAM_STATE_CLIENT_LEVEL_SETUP
   if (state[1] == PM_PROGRAM_STATE_CLIENT_LEVEL_SETUP)
   {
      mLog.add(LOG_OTH_program_state, 0, "[PM_PROGRAM_STATE_CLIENT_LEVEL_SETUP]\n");

      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = PM_PROGRAM_STATE_CLIENT_EXIT;
         return;
      }

      for (int p=0; p<NUM_PLAYERS; p++)
         mPlayer.set_player_start_pos(p, 0);     // get starting position for all players, active or not

      mGameMoves.initialize();

      frame_num = 0;
      mNetgame.reset_states();
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      mLog.add_headerf(LOG_NET, 0, 1, "LEVEL %d STARTED", mLevel.play_level);

      mScreen.player_text_overlay_timer = 0;
      mSound.start_music(0);
      state[0] = PM_PROGRAM_STATE_CLIENT_WAIT_FOR_INITIAL_STATE;
   }


new:

      if (load_and_setup_level_load(mLevel.play_level)) state[0] = PM_PROGRAM_STATE_CLIENT_WAIT_FOR_INITIAL_STATE;
      else state[0] = PM_PROGRAM_STATE_CLIENT_EXIT;

there, that has simpliifed things a bit...

20231121 new version and push




Do I have the savegame thing fixed on headless server?

it saves and is playable, but...

- does not save until level is done..that is the way it should be
- not easy to get off headless server, need commandline scp and specific filename
- no way to tell if it is new record

i propose to add hostname to game moves thing, like color...

this will not be easy...

why not go all the way?

make 'name' field

8 char fixed length

used in place of 'player x'

used to display wherever 'player x' would be displayed or hostname in muliplayer

this is a very ambitious, labour intensive change...



Make my own file transfer thing, between server and client so that the server can push a file to the client
like, logs, savegames, even levels.



document how to set up assocations in windows so the clicking on a .gm file plays it...





How about on headless server, if no clients are playing a level, go back to overworld.

This could be a configurable setting...

It would solve the issue of the server getting stuck on a level and any client joining needs to finish that level.

I think I have that working

I don't have it optional, but do I really want/need to?

Is is saving gm?

Where does that happen?

I will need to manually do it....


I want to clean up auto_save_game and blind save game move...make it more consistant naming and add for my new server reload...



In log I have:

   int autosave_log_on_program_exit = 0;
   int autosave_log_on_game_exit = 0;
   int autosave_log_on_level_done = 0;

   int autosave_game_on_game_exit = 0;
   int autosave_game_on_level_done = 0;



void mwLog::save_log_file(void)


   void save_gm_txt(char *sfname);
   void save_gm_gm(char *sfname);
   void save_gm();
   void blind_save_game_moves(int d);




new:

   int autosave_log_on_level_done = 0;
   int autosave_log_on_level_quit = 0;
   int autosave_log_on_program_exit = 0;

   int autosave_game_on_level_done = 0;
   int autosave_game_on_level_quit = 0;
   int autosave_game_on_program_exit = 0;


do this and put them in the proper class

log is done....


now save game:

   int autosave_game_on_level_done = 0;
   int autosave_game_on_level_quit = 0;
   int autosave_game_on_program_exit = 0;

they are all moved to mGameMoves

now make sure I have three checkboxes in setting...done

now go through all cases:


void mwGameMoves::autosave_game_moves(int d)
{
   int do_save = 0;
   if ((d == 1) && (mGameMoves.autosave_game_on_level_done))       do_save = 1;
   if ((d == 2) && (mGameMoves.autosave_game_on_level_quit))       do_save = 1;
   if ((d == 3) && (mGameMoves.autosave_game_on_program_exit))     do_save = 1;
   if (d == 4) do_save = 1;
   if (do_save)
   {
      char lev[80];
      sprintf(lev, "-lev%d", mLevel.play_level);
      char filename[80];
      struct tm *timenow;
      time_t now = time(NULL);
      timenow = localtime(&now);
      if (d == 1) strftime(filename, sizeof(filename), "level_done_%Y%m%d-%H%M%S", timenow);
      if (d == 2) strftime(filename, sizeof(filename), "game_exit_%Y%m%d-%H%M%S",  timenow);
      if (d == 3) strftime(filename, sizeof(filename), "bad_exit_%Y%m%d-%H%M%S",   timenow);
      if (d == 4) strftime(filename, sizeof(filename), "force_save_%Y%m%d-%H%M%S", timenow);
      strcat(filename, lev);
      save_gm(filename);



1 is called like this:
if (mGameMoves.autosave_game_on_level_done) mGameMoves.autosave_gm(1);

2 is called like this:
if (mGameMoves.autosave_game_on_level_quit) mGameMoves.autosave_gm(2);


3 is called like this:

fast exit:
if (mGameMoves.autosave_game_on_program_exit) mGameMoves.autosave_gm(3);

main:
if (mGameMoves.autosave_game_on_program_exit) mGameMoves.autosave_gm(3);

4 is called like this:
mGameMoves.autosave_gm(4);



changed to this:

void mwGameMoves::autosave_gm(int d)
{
   char lev[80];
   sprintf(lev, "-lev%d", mLevel.play_level);
   char filename[80];
   struct tm *timenow;
   time_t now = time(NULL);
   timenow = localtime(&now);
   if (d == 1) strftime(filename, sizeof(filename), "level_done_%Y%m%d-%H%M%S", timenow);
   if (d == 2) strftime(filename, sizeof(filename), "game_exit_%Y%m%d-%H%M%S",  timenow);
   if (d == 3) strftime(filename, sizeof(filename), "bad_exit_%Y%m%d-%H%M%S",   timenow);
   if (d == 4) strftime(filename, sizeof(filename), "force_save_%Y%m%d-%H%M%S", timenow);
   strcat(filename, lev);
   save_gm(filename);
}


now this:

void mwGameMoves::autosave_gm(int d)
{
   char description[40];
   if (d == 1) sprintf(description, "level_done_");
   if (d == 2) sprintf(description, "level_quit_");
   if (d == 3) sprintf(description, "program_exit_");
   if (d == 4) sprintf(description, "manual_save_");

   char timestamp[40];
   struct tm *timenow;
   time_t now = time(NULL);
   timenow = localtime(&now);
   strftime(timestamp, sizeof(timestamp), "%Y%m%d-%H%M%S", timenow);

   char lev[20];
   sprintf(lev, "-lev%d", mLevel.play_level);

   char filename[120];
   sprintf(filename, "%s%s%s", description, timestamp, lev);
   save_gm(filename);
}


OK this is looking a lot better...

now I want to filter just quitting to menu...
I think the only time I want to do that is when there is an actual game in progress, not just from settings to menu
I compromised and only save gm when there is something to save

now what do I also want to do?

check when level is completed to see if a new record has been set and save gm


looks like I will need to add to this function some tests

void mwLevel::add_play_data_record(int lev, int type)


what am I checking for?

better than best time?
better that par time?

both?

1 - save any better than par
2 - save only if better than prev best
3 - save if better than prev best and better than par


for now I will do 3


time_best
time_best_all_coins

this complicates things....


do I also need to save the best times from my demos?


in client mode, is there any reason to save demo? It will not be playable...


How hard would it be to do a file transfer with my packets?

I would need a new type of packet...

and build my own custom retry until they are all received mechanism..


it would be from server to client only
- send logs, savegames
- could even send the compressed level before starting, but why??


when triggered on server, get the file and

how am i going to encode the filename:

in a header...

what packets type will I use?

SFIL
CFAK

I will need to declare a chunk of memory to hold the pieces...

Why not use something like another state?


Make a list of files to transfer on the server
The server will go through the list and send them one at a time..

How much room on the list? 20 to start with

What does each entry need?

filename and client to send to

make it part of the server class

struct file_to_send
{
   int active;
   int who;
   char * name;
};

constructor:

   for (int i=0; i<20; i++)
      files_to_send[i].active = 0;


active:
0 - inactive
1 - has file waiting to send
>1 - sent file, waiting for reply


now in:
void mwNetgame::server_control()

make it call a fucntion every frame...

void server_proc_files_to_send(void);

now what does my data_struct look like?


I have a filename that could be up to 256 char

should I send the first packet with nothing but the filename?

how will I know that that all the packets belong to one group?

can I use server frame num just like before?  I think that would work...all packets are being sent on the same frame...


could I just add a 256 byte char to the data? and possibly some other meta data, like where to store it?

Here is what I think I should do...

- copy the file into memory
- add the filename and other metadata
- compress and send


on the client side:
- decompress
- parse metadata
- save file


pass the file size with the metadata, so that I know how big of a buffer to create...

how am I going to do this?

outside the compressed data? yes...

as part of the header...

I need a persistant place to store packet data as it arrives...and it will need to have a fixed size...


   // local client's buffer for building compressed sfil from packets
   char client_sfil_buffer[100000];
   int  client_sfil_buffer_pieces[100];   // to mark packet pieces as received




now I need a way to send just the filename and let the client choose the path

I don't know if I want them to end up in the same dir on both ends...
wait, I think I do!

try that...it works



holy shit, I am able to transfer a file!!

there is much cleanup and refining still to do...

in ack, how do I know what I am acking?

I am using frame_number on client, but server does not know that...

what if a made a unique random 4 byte integer to identify files I and sending?
Is this overkill? Is it necessary? Are there easier ways to do it?

when adding file to list generate a unique ID..done

I have the ack done...

now what?

when to use this

to send to clients...

patch one in...

It is coming along nicely...


does it work in linux? try headless server...no way to force save...

how about on server, if client quits, try to save and send file before quitting....
the client immediately quits, don't think that will work...


or make it so that the client can request the file to be sent
I want to make this work...

yet another packet...
crfl
client request file
when the server gets this, it does a force save and sends the files to the client

client initiates with skc

I think that works....


now lets try on headless server...

I think it works...


now what is a good test?

4 clients

it works exactly like I had hoped it would...

now what?

I would love to be able to do it when a client quits
but that would mean I need to do a delay instead of letting the client quit immediately

add another state...done...

i think it is all working good now....



now I need to clean it up and make things optional that need to be...

client gets gm file from server
- on client quit
- on level done

I think this should follow the existing flags.

savegame on level quit

if the client has 'mGameMoves.autosave_game_on_level_quit' set
it should request the file from the server

done...

when level_done on client and 'mGameMoves.autosave_game_on_level_done' set....


how about when sending the request to the server, it only replies to that client? is that possible...
probably not...
the only time the request is sent is when the client quits, or client sends with skc
the other time, the server sends and does not know if the client wants it or not....
I could make it part of syn and then the server would know....
now the server will be doing it all the time at level done...

right now the server does it whenever autosave is called...

I also want to make optional the saving of the gm text version

I think I have all this stuff working, but I need to figure out how to make it all optional....

I really want to make the copying to clients optional on a per client basis...

that would require the server to know the clients preferences

I think the only one that really matters here is the level_done

but I also want to be able to do it if a new record is attained...

how about par, local_best, all_time_best

I also really want to do some multiplayer best...

and figure out how to layer record
like have a special interface for that
hotkeys for different speeds
customizable punch in options





------------------------

I am going to try to make mutiplayer layer recording work....

original:

   if (demo_debug_convert_playback_to_record_with_fire)
   {
      // in single demo mode, 'C' key will allow player to take over and start playing level from current position
      if ((mode == 1) && (mInput.key[ALLEGRO_KEY_C][0]))
      {
         key_used = 1;
         mode = 0;
         mPlayer.syn[0].control_method = PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER;

         // erase all game moves that have a higher frame number than current
         for (int x=0; x<GAME_MOVES_SIZE; x++)
         {
            if (mGameMoves.arr[x][0] >= mLoop.frame_num)
               for (int y=0; y<4; y++)
                  mGameMoves.arr[x][y] = 0;
         }

         // set new entry pos by finding index of max frame
         int max_i = 0, max_f = 0;
         for (int x=0; x<GAME_MOVES_SIZE; x++)
            if (mGameMoves.arr[x][0] > max_f)
            {
               max_f = mGameMoves.arr[x][0];
               max_i = x;
            }
         mGameMoves.entry_pos = max_i + 1;
      }
   }

I want a way to know that I am still in demo record mode even though i have left it...


I will need some tools for demo levels...

- reorder game moves in chron order
- remove a player
- show player ranges
- change player colors
- add player inactive at a certain frame


if more than one player is active and cm 1 they will both enter game moves into the gm array
make a test so only alp can do this...done

how will I do the demo recorder

A window that hovers over the main game....


Multitrack demo recorder...

slider at the bottom showing the time line

and also showing what players are active for what time ranges

where do I fit it into the state...
something like a menu...

#define PM_PROGRAM_STATE_DEMO_RECORD                    7

make a horizontal scroll bar with all players active time visible
make clicking on bar set that time...


experimenting with one player with 2 different active section...
p0 does not work
other players ok but continued from last pos...probably not what I want...
I know when clients reconnect they definitely start from start block
fixed so that when player cuts in, if they are not active, they are reset first


now I want to seek to a certain place in the demo and show it...

why do players not playback properly when ff??

its like the players do not go inactive, but they do when actually playing...



It has to do with the control method...what do I even use PM_PLAYER_CONTROL_METHOD_DEMO_MODE for?

could I use another method to tell if I am in demo mode?

like the actual mode?


I need to rethink how this all works...

only one player should ever be PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER and active at the same time
- that is the one that is getting local input
- it should also always be active local player

when playing back a demo:
- all active players should be PM_PLAYER_CONTROL_METHOD_DEMO_MODE

unless one is recording, then that one should be PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER

This is all done and now works...

now make zoom work..done

now show some game moves around the current time...done

now what?

can I implement a play button?...yes!!

what about a record button?

move the game moves to just above the timeline

I can play back demo 23 but it does not look right in demo record

it looks like in my ff setup I actually start on frame 1 instead of zero
no that is not it
why?

the only differnce is that new demos make player 0 active on frame 1
old demos do that on frame 0
so that might get missed, but why does it play properly, just not in demo record??

do I manually make player 0 active in the normal method?
yes I do, changing that fixed it...

I have different versions of gm files then....

some make the player active on frame 0 and some on frame 1

this is inconsistant and I want it fixed....

I would like to make it so that game moves on frame zero are processed, the fact that they might get skipped is unacceptable...

The complication is that the first thing the game loop does is increment the frame...
I did that for some netgame timing issues and don't want to go down the rabbit hole of fixing that..

so what are my options?
- leave it as is and do not process any frame 0 game moves? ...all the new stuff works this way

The only things that would need to be changed are all my existing demo levels....
But if I manually make player0 active when setting up a level, it should not make a difference...


I had to make my own ff loop, it turns out that the frame++ was in the wrong place...


   int target_fn = mLoop.frame_num;
   mLoop.frame_num = 0;
   mLoop.ff_state = 1;
   while (mLoop.frame_num < target_fn)
   {
      mLoop.frame_num++;
      mGameMoves.proc();
      mLoop.move_frame();
   }
   mLoop.ff_state = 0;


now all seems well....

I want to make a speed control widget, how about just a slider?

as far as record goes how about this?

punch in buttons (or keys)

when playing

what would they look like?

slider to choose player
record button

can be presed on its own, or when playing already...

other notes, if gm does not have an ack at the end my thing just keeps going....not true, just does not do level done stuff...

I really want to see the player array for debug reasons...done


remember how I wanted to know if I was in demo record mode? I can by checking state

need to enter inactive game move when esc quitting from record....
the problem is that I can't use escape for some reason
found the reason!!!! normal demo mode keycheck was eating esc...

need to remove 0 0 0 0 game moves after sorting

what is the best way to do that?



are there default colors for players

0 = purple
1 = red

etc...where do they come from??

get unused color?

initial setup:

   mPlayer.syn[1].color = 10;
   mPlayer.syn[2].color = 11;
   mPlayer.syn[3].color = 12;
   mPlayer.syn[4].color = 13;
   mPlayer.syn[5].color = 14;
   mPlayer.syn[6].color = 15;
   mPlayer.syn[7].color = 9;


make speed persist for demo recording..done

sort before save...done

fixed zero remove...done

make selecting player num, automatically set default color...done

show overlay in frozen mode..done

don't show bottom message and jq...done

when changing player num also make it alp


purple coins in multiplayer does not register as complete, coins got by different players

I should show in the top frame current_player_pc / all_players_purple_coins / total purple coins




make more tools like
- erase all move past a point
- insert and delete single game moves


show/hide/resize:
timeline
game moves list
player array
play sections

time display in time as well as frames..done

mark level done
I will need to actually play level for that to happen...

make a function that plays the gm and finds level_done

also look for acks

make a way to select a section or player from the timeline

could I make an array of found sections?

create an array of sections found...

int active
int player_num
int player_color
int start_frame
int end_frame

int player_sections[20][5]


when record is pressed
- it records from current time
- it records for player (rec_player_num)
- it uses rec_player_color
- if the player is not active, it inserts player active game move
- all game moves for that player num to end of gm file are erased

make some toggles at the top of the screen to show/hide various elements


make a way of showing if an actual player inactive gm was found or just ran to end of level...
section[9] -- end type
0 - none
1 - inactive


show if any deaths occur in timeline
do this at the same time as finding level done
I woud like to see activity...
draw when game moves happen so you can see idle sections
then draw deaths on top of that...
maybe only do for active segment...??

detect if active game moves happen on frame 0 -- maybe optionally fix...

show more data for current section:

should I do a bitmap for each section?
that sound very expensive and complex
just count deaths
level dones
acks

store that all in sections
add 3 more to sections
deaths
level_done
ack


I have broken my game... cant play normally now...why???
where does it die?
is is like the frame number never increments?? no it was never drawing...flip...fixed


should I remove all ack from demo's?
is there a point to keeping them?
when I am playing back I should just handle it automatically...
either no acks at all and let it time out....
or immediately skip in super fast mode...

I think I can make my super fast do all demos now...
don't use main loop, make my own custom playback for that.....done
removed press key to record demo
how about also super fast mode
all done....

make a fix button for current section...
- changes first active to 1 if not already...
- removes acks

I want to have something like glt only for demo levels....

load then do things....

- show frame numbers for all player active gm's

- find the time between level done and ack

- find ones with no acks

I have now manually fixed all demo levels to have player 0 active on frame 1 instead of zero

time between level done and ack ... 84 to 155


I don't think it really matters

I need to make a way to save the demo with the exact same filename

I should make sure I back things up first....

make save_gm take a fully qualified path, do all of the file and path manipulation before calling it...
test on linux..seems to work...

fixed all that

changed load_gm a lot, now separate load_gm_prompt and removed all that from regular load...

looks a lot cleaner...


pm C:\pm\savegame\lev005_3p_55s.gm
pm savegame\lev005_3p_55s.gm
these both work from command line


what if I saved the pvp and pvs shots as game moves?

I could do it in one gm

#define PM_GAMEMOVE_TYPE_SHOT_CONFIG              9

      int f = arr[x][0]; // frame
      int t = arr[x][1]; // type
      int p = arr[x][2]; // player
      int v = arr[x][3]; // value

p = bitfield of pvs and pvp
v = shot values

Why do I want to do this?
- I already have the ability to change these on the fly with remote server, but I have no way of recording these in gm files
- it would be a cleaner file format...

add the functionality to game moves...


void mwGameMoves::add_game_move_shot_config(int frame)
{
   arr[entry_pos][0] = frame;
   arr[entry_pos][1] = PM_GAMEMOVE_TYPE_SHOT_CONFIG;

   arr[entry_pos][2] = 0;
   if (mPlayer.syn[0].player_vs_player_shots) arr[entry_pos][2] |= 0b01;
   if (mPlayer.syn[0].player_vs_self_shots)   arr[entry_pos][2] |= 0b10;

   arr[entry_pos][3] = mPlayer.syn[0].player_vs_player_shot_damage;

   entry_pos++;
}

void mwGameMoves::proc_game_move_shot_config(int i)
{
   mPlayer.syn[0].player_vs_player_shots = 0;
   mPlayer.syn[0].player_vs_self_shots = 0;

   if (arr[i][2] & 0b01) mPlayer.syn[0].player_vs_player_shots = 1;
   if (arr[i][2] & 0b10) mPlayer.syn[0].player_vs_self_shots = 1;

   mPlayer.syn[0].player_vs_player_shot_damage = arr[i][3];
}


done...


now move these from demo to game_moves

void mwDemoMode::demo_swap(int i, int j)
void mwDemoMode::demo_remove(int i)
void mwDemoMode::demo_sort(void)


the pieces are coming into place....

next I want to insert or remove a specific game move and then save the gm file

make sure this is all working fine then try to do the convert to using gm for pvp setting

once that is all working fine, then I could load and save gm in binary mode instead of text...???




I might need to rethink insert game move...
do I need a specific index?
I could just add it to the end like a regular move, then call sort....
i think this might be better, it will probably move anyway when sorted...

could I also do the same with remove? just set to zero and sort
actually remove is only called by sort!


tested add and remove and they seem to be working
remove takes the index
add just adds to the end
I think I can get rid of insert

maybe make a function that removes ack
or maybe actually use it to have a pause at the end of a complete level



20231201

add the shot config game move....
backup demos first

just out of curiousity, print the values for all demos

GDT lev:[ 2] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 3] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 4] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 5] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 6] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 7] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 8] ----pvs:0 pvs:0 dmg:5
GDT lev:[ 9] ----pvs:0 pvs:0 dmg:5
GDT lev:[10] ----pvs:0 pvs:0 dmg:5
GDT lev:[11] ----pvs:1 pvs:1 dmg:5
GDT lev:[12] ----pvs:1 pvs:1 dmg:5
GDT lev:[13] ----pvs:1 pvs:1 dmg:5
GDT lev:[14] ----pvs:1 pvs:1 dmg:5
GDT lev:[15] ----pvs:0 pvs:0 dmg:5
GDT lev:[16] ----pvs:0 pvs:0 dmg:5
GDT lev:[17] ----pvs:0 pvs:0 dmg:5
GDT lev:[18] ----pvs:1 pvs:1 dmg:5
GDT lev:[19] ----pvs:1 pvs:1 dmg:5
GDT lev:[20] ----pvs:1 pvs:1 dmg:5
GDT lev:[21] ----pvs:0 pvs:0 dmg:5
GDT lev:[22] ----pvs:1 pvs:1 dmg:5
GDT lev:[23] ----pvs:0 pvs:0 dmg:5
GDT lev:[24] ----pvs:1 pvs:1 dmg:5
GDT lev:[25] ----pvs:0 pvs:0 dmg:5
GDT lev:[26] ----pvs:1 pvs:1 dmg:5
GDT lev:[27] ----pvs:0 pvs:0 dmg:5
GDT lev:[28] ----pvs:1 pvs:1 dmg:5
GDT lev:[29] ----pvs:1 pvs:1 dmg:5
GDT lev:[30] ----pvs:1 pvs:1 dmg:5
GDT lev:[31] ----pvs:0 pvs:0 dmg:5
GDT lev:[32] ----pvs:1 pvs:1 dmg:5
GDT lev:[33] ----pvs:1 pvs:1 dmg:5
GDT lev:[34] ----pvs:0 pvs:0 dmg:5
GDT lev:[35] ----pvs:1 pvs:1 dmg:5
GDT lev:[37] ----pvs:0 pvs:0 dmg:5
GDT lev:[38] ----pvs:1 pvs:1 dmg:5
GDT lev:[39] ----pvs:0 pvs:0 dmg:5
GDT lev:[40] ----pvs:1 pvs:1 dmg:5
GDT lev:[41] ----pvs:1 pvs:1 dmg:5
GDT lev:[42] ----pvs:0 pvs:0 dmg:5
GDT lev:[43] ----pvs:1 pvs:1 dmg:5
GDT lev:[44] ----pvs:1 pvs:1 dmg:5
GDT lev:[45] ----pvs:0 pvs:0 dmg:5
GDT lev:[46] ----pvs:0 pvs:0 dmg:5
GDT lev:[47] ----pvs:0 pvs:0 dmg:5
GDT lev:[48] ----pvs:0 pvs:0 dmg:5
GDT lev:[49] ----pvs:0 pvs:0 dmg:5
GDT lev:[50] ----pvs:0 pvs:0 dmg:5
GDT lev:[51] ----pvs:1 pvs:1 dmg:5
GDT lev:[52] ----pvs:1 pvs:1 dmg:5
GDT lev:[53] ----pvs:0 pvs:0 dmg:5
GDT lev:[54] ----pvs:0 pvs:0 dmg:5
GDT lev:[55] ----pvs:0 pvs:0 dmg:5
GDT lev:[56] ----pvs:0 pvs:0 dmg:5
GDT lev:[57] ----pvs:0 pvs:0 dmg:5
GDT lev:[64] ----pvs:0 pvs:0 dmg:5
GDT lev:[80] ----pvs:0 pvs:0 dmg:5
GDT lev:[81] ----pvs:0 pvs:0 dmg:5
GDT lev:[82] ----pvs:0 pvs:0 dmg:5
GDT lev:[83] ----pvs:0 pvs:0 dmg:5
GDT lev:[84] ----pvs:0 pvs:0 dmg:5
GDT lev:[85] ----pvs:0 pvs:0 dmg:5
GDT lev:[86] ----pvs:0 pvs:0 dmg:5
GDT lev:[87] ----pvs:0 pvs:0 dmg:5
GDT lev:[88] ----pvs:0 pvs:0 dmg:5
GDT lev:[89] ----pvs:0 pvs:0 dmg:5
GDT lev:[90] ----pvs:0 pvs:0 dmg:5
GDT lev:[91] ----pvs:0 pvs:0 dmg:5
GDT lev:[92] ----pvs:0 pvs:0 dmg:5
GDT lev:[93] ----pvs:0 pvs:0 dmg:5
GDT lev:[94] ----pvs:0 pvs:0 dmg:5
GDT lev:[95] ----pvs:0 pvs:0 dmg:5
GDT lev:[96] ----pvs:0 pvs:0 dmg:5
GDT lev:[97] ----pvs:0 pvs:0 dmg:5
GDT lev:[98] ----pvs:0 pvs:0 dmg:5

now can I load all demos and save without the extra header
done..

all demo levels have the extra 3 ints in the header removed and all play back perfectly

Now I want to test to see how things are working up to this point...

headless server
make sure games are saved and sent to clients and are playable
test also with changing the shot config in the middle of the game and make sure that plays back properly as well

I am concerned about how things work if player 0 is not active
headless server will have p0 active but hidden

can other demos have p0 inactive? test if that will work...

test if setting all demos to 0 0 5 makes them still playable

there were 3 levels that did not complete so I manually editted them...

20231202
try playing demos created on headless server
looks like it works


there is no shot config game move...

where do I need to set it?
same place as player active...done

that seems to work...

now can I do a change in the middle of a game...

I think I can and I think it is working...

does it go active on the correct frame?

should I make the server read it from game moves array? that would be better...did that...



If it is changed on a client by the server, does that get saved in the clients config as the new default?
yes, it looks like it does
how can I avoid this?

just like the player color, if overridden by the server, I want to restore it...

load config is already called from client exit network

where does it get saved?

now I cant seem to reproduce it...

in demo mode when a player leaves the game they still show??
actually I think that is working properly

but if a client leaves the game and other players are still active, they will not have the proper inactive game moves...
this is exactly how it should be.....

what about when player 0 is not active?
I think player zero always needs to be active

single player, always p0
normal netgame, p0 always active (if server quits, game is done)
headless netgame, same only p0 is hidden (not inactive, just never shown and never interacts with the level)
in demo mode, when would p0 be inactive? only when I was step recording...
add tag in step recording to show that player is hidden



make a different tag for the start of the filename when copied from server
it just blindly copies, I will need to change it on the server...
while I am at it, should I change the filename format to have the timestamp first?
I think I will...done
made more changes to the way that works
now when ever I call to save gm i pass the desc text with it...

they all call save_gm and that is what sends the files to all active clients


dont save gm for level 1, ever....
or if in demo mode
done...hope it doesn't interfere with other stuff....


can I remove the manual setting p0 active when starting demo?
still shows on frame 0, until frame 1 hides it...
is this really a big deal?
what if I just make demo record rewind to frame 1?
i think I need to add    current_frame_num = 1;
I think it is fixed and will stay like this..


show cpu usage when running...make custom like the other loop...
done

I want to be able to see the actual frames_per_second set, if not set to 40....

make toggles to turn off sections

cleaned up level_done real nice...

why does it still flicker when playing?

fixed I think, extra flip!!!

what gets call with refresh?
level_done??


where do I keep track of level done?

I don't need it for each segment, there can only be one

   void find_level_done(void);
   int level_done_frame = -1;
   int level_done_player = -1;



can I do a save as with file select?
I don't think I was ever able to get that working in windows file save dialog...

file stuff
load new file
save (overwrite)
save with timestamp new filename
save prompt for filename

these all look good...
when saving with these, make the current filename the saved name when done

having trouble adding extra players


20231203

-------------------------------------------
I want to view game moves list for one player only
by filtering out game moves from other players

this has turned out to be harder than I thought.

I am thinking of making a separate filtered array
done....
---------------------------

I would like to be able to scroll the game moves list
then the current time would also move
...?? maybe??
---------------------------

also being able to select a certain game move with mouse and
- delete
- edit
---------------------------

---------------------------

make ending recording optionally add inactive move
- if recording and esc pressed
- if stop is pressed
---------------------------



what is set colors from gm and why do I need it?
also set default color??
I don't know why?

disabled all of both, lets see what happens

sections are not colored properly

could I make color a property of section?
it is, but I am filling it wrong..fixed
I now have permanently removed set player colors



make frame/time apply to section details also..done



---------------------------

frame and title the record section
record player number
record player color
these can be set by setting current section
or modified manually
done
---------------------------

add to section
- number of game moves
- last game move
show in section details
done....


int arr[10000][4];
when setting a section active,load this...


why does a player going inactive not show in demo record?

it does, but the file needs to be reloaded??...no

I think it is only if that player is the active_local_player....fixed by testing if active_local_player is active in draw player...

make it so that add inactive game move erases all game moves after...done
need to test, but first fix...single list clamps to end...fixed



I have got a lot of things done...
I want to go back to testing and seeing how easy it is to use...



usage...start playing new level and save...


in demo record
-load that demo
-set rec to p1, leave col as red
with current frame set to 1 press record
when done, hit esc and get taken back to main menu

this gets saved automatically on quit

neither player has inactive game move

added player 2 with color while at frame 100

looks good

last frame for p2 was 700
added inactive at frame 710 and manually saved

still all good...

lets try taking over for a player...


set rec player to 0 and played, then pressed record to take over
it worked, but again, pressing esc, sent me back to main menu...


I have a var 'play' that lets me know when I am playing, but do I have something for record?
I would like to trap the esc in that mode....

actually I just moved the esc test at the bottom of the loop to inside..
now the loop gets frist crack at it and it saves inactice just like it should..

however it still quits to main menu, see if can trap that...done...

noice, now what to test?


I would like a punch in record option...
when set, and in play mode, any key press starts recording

--------------------------------------
make timeline set mouse detection wider..done
--------------------------------------
make settable number of lines in gm_list
--------------------------------------
reduce line spacing and clear background for checkboxes
--------------------------------------
all done

I think I have punch in mode working!!!

noice!!!!

do some more tests....


bug - when a new player joins they do not join at the correct spawn point....
maybe after death it is good, but I need to to get start pos when joining also...


void mwPlayer::set_player_start_pos(int p, int cont)

if cont == 0 the force to use start index 0

there are 8 calls to set_player_start_pos()
and all but one force index 0;

the only one that does not it coming back after death....

is this the way that I want it?


I don't think so...

I want all player to use the current spawn point, even if they are just joining.
it make no sense to have them ignore the current one and start at index 0, then by touching that it will now become current...


I am going to remove this behaviour and see if any demos break...they are all single player so they should not....

they all seem to play back properly

now it works in playback, but not in demo record...fixed

when saving, update the filename and load again..

add to section buttons...delete all game moves past level done...done

make a reload button

I can erase from position to end by adding inactive move then removing it...

this seems to be working well...it is easy to use...

the timeline gets in the way of recording sometimes


made it so that the screen stuff is hidden when recording...
make that optional

add time/frame to one line section details...done

when changing player 0 it gets saved to the config, I would like to not do that....





20231204

still left to do:

gm list
- scrollable
- actions can be performed on list item

I need to make the second gm_list to just have links to the first..done, that was easy!!


make a helper button to set game move type from only the allowed types...












make a nice way to call demo record, maybe a button from demo page in settings

automatic way to clean up at the end of the level....

if I add ack, how far in the future should they be?

I think the way it is now, demos are ending because mLoop,frame is way past last frame...
if this was not the case, then I would see level done stuff....

line up things on the overlay a little better...

add frame + and - buttons to move just a little bit
also rewind


make a frame for gm_list...



I need to combine all and one into a single function

how about making all also copy to lnk_gm, but just copy everything regardless of player number...



20231207

step 1 - combine both lists into one (all and single)
done...

step 2 - make a frame with controls
done...


I would like a marker in gm_list to show:
- last gm_entry
- last gm_entry for current player

I want some frame control buttons

I dont things I want them on the gm_list...probably with the play and rec buttons

rew to start
+- frame

then I will need to show that value there also....

right now I just show it on the timeline

done...

next to do, finish the edit gm controls...

show fps and have fps controls


I have some weird bugs...
game moves are doubled but show the same??
RIGHT was not showing...fixed




20231209

- put header at bottom of gm list instead of top...done

- finish edit gm move dialog..done

- click on gm list sets current frame..done

- scrollwheel on gm_list scrolls list??..no

- limit frame in edit gm...done

- += 10 and 100 in main controls like edit gm..done

- more checks
like if more than 1 active or inactive

test how far adding ack in future works

make the entire demo play thing not use the main loop

this would probably cleanup a lot of the confusing program state change things

- resizable timeline..done

add current section += to title bar...done




back to testing....

bug - player joined the game shows when players go active on frame 1...fixed

bug - shot config is not getting saved with new level??
or maybe it is getting erased by p0 start from begining?

bug - make insert gm use current player..done





when to add ack?

l64 with end cutscene...does not play cutscene if no ack

added ack at 1000f after level done


I think I have some manual fuckery when demo level does level done for when I was playing them fast...
especially for cutscene in lev64

I am thinking again about making the demo playing stuff its own loop...



it can be called from:
command line
menu
settings
in a level (overworld)

it needs to be able to return to where it came from

transitions are all messed up anyway...when did that happen?

this is not something I want to get into now...


can I make a routine to automatically remove players shots that do not hit anything?

can I make a more fair method for players shots?


right now there are 50 shared

each player could have a quota....

1 - 20
2 - 25
3 - 16
4 - 12
5 - 10
6 - 8
7 - 7
8 - 6

it would only come into effect if the array is full....

in that case the player with the most active shots loses their oldest shot...

I would need to keep track of the frame that shots were fired on....

add 1 int...i should also do this for enemies

when they are processed (once per frame),

or when needed...

make a function that finds the player with the most active shots
and then find the oldest one in that group


what if I repurpose active!!

it will now have the frame number of the shot


this was so easy to achieve

actually I just find the oldest frame number across all players

demos still play properly


20231211

add enemy shot count like for player
this broke 3 demo levels
27
34
44





add tracer line for player...looks cool
redo section details, maybe a more section



make menu line up better for edit gm
show last line before popping up menu
edit controls in frame...
pop up menu for type...
did a bunch of messing around with edit gm and it looks good...


bug - after leaving demo record mode and playing game I cant exit...

I think I know how to detect shots that never kill any enemies
I am now saving the frame number of when the shot was fired

if it is destoryed by a wall or edges of the screen, make a note and mark it as unused

what about trigger that detects shots?
do they ever get destroyed?

I will need to create an array
- whenever a player shot is fired add it to the array
- it will need frame fired, player number, and used
- by default used = 0
- test all the times it could get used and mark if it is...
- make a function to that, or igore if not in demo record mode

how many shots? size of array...10,000

types:
1 - shot hit enemy
2 - shot hit player
3 - shot detected by orb
4 - shot detected by trigger


I did not take into account when pressing fire is used to grab something...
can't erase those

is it only items?

what can I do about that?


ranges when fire is pressed:
if at any time during that range, player is holding item, then mark that initial fire press as used

every frame,

if (mPlayer.syn[p].carry_item)

find the previous ups that matches player




this does not detect game moves when fire is pressed, only when shots are fired



how about modifiying each ups entry?

right now frame is when a bullet was fired
add another frame for when fire is released

then if at any time while fire is help, player carry is true, then mark that range as used...

or


I think I missed even one more...when it hits a breakable block...

this is turning out to be way complex than I thought

when I remove fire that causes a shot, sometimes now a fire press shorly after that causes a shot, when it did not before...


a brand new idea...

- run through the game moves list for a player and generate sections where fire is pressed
each of these sections will have:
- frame start (the first frame that fire is pressed)
- a guarantee that the frame before that did NOT have fire pressed
- frame end (the last frame in the run that fire was pressed)
- a guarantee that the next frame after that did NOT have fire pressed

- player number
- was a shot initiated?
- did the shot get used?
- did a carry happen any time within the range?


then later when removing...

if a carry happened anytime within the range - do not do anything

if no carry
if not shot initiated - delete range
if shot initiated and not used - delete range

this is getting very complex!!

can I extend and use ups??

what if I call it fhs? fire held sections
f1
f2
p
pc
ps
psu

I think I might be able to get rid of fired and just go with used....
holy shit, this worked this first time I tested it...
I want to simplify it...
combine 4 5 and 6


done!! wow!

it does not work perfectly

check out level 11 8P

I think the many shots are because of continually picking up and dropping a bonus...


demo levels that do not play back properly
27 - gauntlet

35 and 44 are broken by new eshot method...


when I click play all...
it does a seek to frame (last_frame)
so if I do not have game move past level_done, it will not register as done

the more I think about it, this is how I want to do all my demos, with a custom loop, instead of the main one...

make a button to set ack move at level_done +1

fix broken demo levels...leave enemy shots at new mode..

lev023-4P-235.gm - when removing unused fire sections level done is broken...why??
lev064-8P - level done shows 4262? but should be much earlier


--------------------------
20231217 ok time for a big one...remove demo play from the main program state stuff and make it its own loop...
why?
to umcomplicate the main program_state thing, it seems like there are so many exceptions to make it do demo also...



I will need to create 2 blocking functions:
- one to play a single demo and return when done
- one to play random demos in a loop until told to stop


do the single demo one...


do it from the call to run it from menu..done...

next from settings..done but transitions don't work...from nothing

next from gate...

how is that triggered? skc??

make a common load_and_setup_level_load(int level)

but there are so many different options for each...

int mwLoop::load_and_setup_level_load(int level)

int mwLoop::load_and_setup_level(int level, int type)

ok now in single I have menu, settings, gate...what is left? command line

now I have all the single calls handled by the new method
- zero transitions still do not work..fixed!!

now  want to do the random multiple stuff...called from story mode menu and settings
make key check return 0 for nothing 1 for exit 2 for next level...done

now hook in the settings random..done...

now remove all traces of the old shit...nice!!
lots done in loop


I think that I have this all sorted

now make a pause after a level is done to see the end of level_stats...


need to add a move marker to the end of gm files, one past the level done frame

if there is no game move past level done, the level will not get marked as complete


I could make a special move that has no effect except to mark the end of the level

I could detect level_done...

where do I do these things?
playing back all levels for records
playing back to watch...

fixed records to do level done or last frame + 200
now I can remove last placeholder ack at level end +1

now playing back to watch

80f

then 600

200 = 5s

ok this is done also...

now all the levels do not need any markers, just run erase past level done....

do it for lev 2-10..done

now make the cont rnd do a pause also..doen needs test...


make an auto method to fix levels
- erase past level done
- remove usused fire sections
- remove doubled game moves


- remove doubled game moves ---
method...

first do a sort

then player by player...

- find game move and store it
- find next game move
-- if dif- new game move
-- if sam- erase game move

I think I've got it...


now I have 6 levels that fail tests...


level 24 old copy good, new one fails after running fhs
it has a player hit??
do I detect player hits?

level 42, fhs breaks it
level 49, fhs breaks it



level 27, old copy fails also
level 35, old copy fails also
level 44, old copy fails also

I can now try to figure out why...or I can just re-do them

what about others??


other
23 fhs breaks it...
64 now 1:46?? just the way its recorded...







27 has been redone
35 was bad due to eshots...redo..done
44 done




I really need to find out why fhs is still breaking things...

level 24
just come out of yellow door and shoot on frame 1415
but it looks like the shot was not actually fired until 1416

FIRE was pressed when the player was paused from door move...
one frame later player was not paused and that's when the shot was actually fired.

the mark_used did not detect beacuse the start frame was not exactly when the shot was fired
This is rare, but I think I can fix it by searching for the range, instead of the exact start

void mwDemoMode::mark_player_shot_used(int p, int f, int type)
{
   // mark that a shot was used for this section
//   for (int i=0; i<fhs_indx; i++)
//      if ((fhs[i][1] == f) && (fhs[i][0] == p)) fhs[i][3] = type;

   for (int i=0; i<fhs_indx; i++)
      if ((p == fhs[i][0]) && (f >= fhs[i][1]) && (f < fhs[i][2])) fhs[i][3] = type;




new 24 - 5668
old 24 - 5867 5 sec longer 2:26

done..

now see if i can fix 42...no fhs still breaks it
49??


42 and 49 fhs breaks
other 23
are those the only levels that it does


I want to see why?

chnged this to have a wider range >= on f2
   for (int i=0; i<fhs_indx; i++)
      if ((p == fhs[i][0]) && (f >= fhs[i][1]) && (f < fhs[i][2])) fhs[i][3] = type;


still bad...


go through line by line a see where it diverges
23 player 1
2240 shot down



I think I get it...

there are a couple of close fires and some that don't trigger a shot...

I remove one unused and now another that did not previously trigger a shot now does, and causes the next to not fire due to a time out...

orig
2192 shot down (but not used)
2195 fire pressed but no shot (item carried though)
2198 shot right and kill enemy

after
2192 shot removed
2195 shot down and item carried
2198 fire pressed but no shot, not enough cool down time


how can i detect and avoid this?

add to section, shot fired
then later if no shot fired then there is an issue

if section starts are closer than 4 frames...

if a section used to fire a used shot and now after changes it doesn't...

make a list of used shots and check after removing if they are still the same...


should I add a few things?
- shot fired
- shot used
- carry detected

---

I could remove sections one at a time and test if level done changes


Removing section:656  p:2  975-976   ild:6219 ld:6219
Removing section:657  p:2  978-980   ild:6219 ld:6219
Removing section:658  p:2  981-983   ild:6219 ld:6219
Removing section:660  p:2  989-990   ild:6219 ld:0
Error removing section!!-------------------------
Removing section:661  p:2  992-993   ild:0 ld:6219
Error removing section!!-------------------------
Removing section:663  p:2  998-999   ild:6219 ld:6219
Removing section:664  p:2  1001-1002   ild:6219 ld:0
Error removing section!!-------------------------
Removing section:667  p:2  1014-1015   ild:0 ld:0
Removing section:669  p:2  1021-1023   ild:0 ld:0
Removing section:671  p:2  1028-1030   ild:0 ld:0
Removing section:672  p:2  1032-1033   ild:0 ld:0
Removing section:673  p:2  1036-1037   ild:0 ld:0
Removing section:675  p:2  1059-1060   ild:0 ld:0


but they do no seem to trigger the issue...

do not play sounds arrgh!!..fixed...

lev23, remove


make tools to remove


pop up menu on section
put all buttons there that relate to section
now add more like:
- find unused fire sections
- remove unused fire sections
- remove duplicates

done...



now I want something like section details, but for the entire file

and a popup menu to do things to the entire file...


start with filename

loaded file:

I think I have made the record controls window unneccsary, I will not delete it yet, just hide it..done


now after all these changes back to the issue at hand:
why does p1 fhs break it but does not detect on line at a time?


I think it works when run through the long way, but I need to test and keep track of stuff...



lev023-4P-235.gm
4151 moves

p0
1081 moves
640 after removing

l23-m0
total 3708

p2
1124 moves
721 after remove


l23-m02
total 3305


p3
984 moves
722 after remove


l23-m023
total 3043

p1
960 moves
531 after remove (also ld cleared)

545 after remove with test (ld good)

did it again, now down to 524 (ld good)

why does it work like this, but not the long way??



with test remove:

file and path selected:C:\pm\savegame\l23-m023.gm
326 - total fire held sections ----------------
247 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
32 - player carry
Removing section:3  p:1  732-734   ild:6219 ld:6219
Removing section:4  p:1  736-738   ild:6219 ld:6219
Removing section:5  p:1  1002-1004   ild:6219 ld:6219


960 moves, then remove dup and 545

then run again:

86 - total fire held sections ----------------
11 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
28 - player carry
Removing section:8  p:1  1351-1355   ild:6219 ld:6219
Removing section:19  p:1  2198-2200   ild:6219 ld:6219
Removing section:21  p:1  2212-2213   ild:6219 ld:6219
Removing section:22  p:1  2215-2217   ild:6219 ld:6219
Removing section:23  p:1  2229-2231   ild:6219 ld:6219
Removing section:52  p:1  3293-3294   ild:6219 ld:6219
Removing section:55  p:1  3330-3331   ild:6219 ld:6219
Removing section:66  p:1  3648-3649   ild:6219 ld:6219
Removing section:79  p:1  4081-4083   ild:6219 ld:6219
Removing section:81  p:1  4094-4095   ild:6219 ld:6219
Removing section:83  p:1  4100-4102   ild:6219 ld:6219


545 moves, then remove dup and 524

run again:

75 - total fire held sections ----------------
0 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
28 - player carry


and the level done is still there!!

now why does this not work when not testing after ever remove

this part is the same:

file and path selected:C:\pm\savegame\l23-m023.gm
326 - total fire held sections ----------------
247 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
32 - player carry

Error! - After removing all sections, level done has changed from 6219 to 0
79 - total fire held sections ----------------
7 - unused fire held sections
46 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
26 - player carry


79 - total fire held sections ----------------
7 - unused fire held sections
46 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
26 - player carry



---------
I still have no idea why checking for level done after each remove is different than not doing that.

what does check for level done do?
- seek to 0 (reloads level and resets player data)
- play until level done found

manually check for divergence


2192


add to game move list pop up menu - dump to console..done

original

file and path selected:C:\pm\savegame\l23-m023.gm
[345][ 2184][5][1][ 9] P1 MOVE [L  D  ]
[346][ 2185][5][1][41] P1 MOVE [L  D F]
[347][ 2186][5][1][ 9] P1 MOVE [L  D  ]
[348][ 2188][5][1][41] P1 MOVE [L  D F]
[349][ 2189][5][1][ 8] P1 MOVE [   D  ]
[350][ 2191][5][1][10] P1 MOVE [ R D  ]
[351][ 2192][5][1][42] P1 MOVE [ R D F]
[352][ 2193][5][1][10] P1 MOVE [ R D  ]
[353][ 2195][5][1][42] P1 MOVE [ R D F]
[354][ 2196][5][1][10] P1 MOVE [ R D  ]
[355][ 2198][5][1][34] P1 MOVE [ R   F]
[356][ 2200][5][1][ 2] P1 MOVE [ R    ]
[357][ 2202][5][1][34] P1 MOVE [ R   F]
[358][ 2203][5][1][ 2] P1 MOVE [ R    ]
[359][ 2205][5][1][34] P1 MOVE [ R   F]
[360][ 2206][5][1][ 2] P1 MOVE [ R    ]
[361][ 2209][5][1][34] P1 MOVE [ R   F]
[362][ 2210][5][1][ 2] P1 MOVE [ R    ]
[363][ 2211][5][1][ 1] P1 MOVE [L     ]
[364][ 2212][5][1][33] P1 MOVE [L    F]
[365][ 2213][5][1][ 1] P1 MOVE [L     ]
[366][ 2215][5][1][33] P1 MOVE [L    F]
[367][ 2216][5][1][41] P1 MOVE [L  D F]
[368][ 2217][5][1][ 9] P1 MOVE [L  D  ]
[369][ 2219][5][1][41] P1 MOVE [L  D F]
[370][ 2220][5][1][ 9] P1 MOVE [L  D  ]
[371][ 2222][5][1][41] P1 MOVE [L  D F]
[372][ 2224][5][1][ 9] P1 MOVE [L  D  ]
[373][ 2226][5][1][41] P1 MOVE [L  D F]
[374][ 2227][5][1][ 9] P1 MOVE [L  D  ]

bad remove

326 - total fire held sections ----------------
247 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
32 - player carry
Error! - After removing all sections, level done has changed from 6219 to 0
[345][ 2184][5][1][ 9] P1 MOVE [L  D  ]
[346][ 2185][5][1][ 9] P1 MOVE [L  D  ]
[347][ 2186][5][1][ 9] P1 MOVE [L  D  ]
[348][ 2188][5][1][ 9] P1 MOVE [L  D  ]
[349][ 2189][5][1][ 8] P1 MOVE [   D  ]
[350][ 2191][5][1][10] P1 MOVE [ R D  ]
[351][ 2192][5][1][10] P1 MOVE [ R D  ]
[352][ 2193][5][1][10] P1 MOVE [ R D  ]
[353][ 2195][5][1][42] P1 MOVE [ R D F]
[354][ 2196][5][1][10] P1 MOVE [ R D  ]
[355][ 2198][5][1][34] P1 MOVE [ R   F]
[356][ 2200][5][1][ 2] P1 MOVE [ R    ]
[357][ 2202][5][1][ 2] P1 MOVE [ R    ]
[358][ 2203][5][1][ 2] P1 MOVE [ R    ]
[359][ 2205][5][1][ 2] P1 MOVE [ R    ]
[360][ 2206][5][1][ 2] P1 MOVE [ R    ]
[361][ 2209][5][1][ 2] P1 MOVE [ R    ]
[362][ 2210][5][1][ 2] P1 MOVE [ R    ]
[363][ 2211][5][1][ 1] P1 MOVE [L     ]
[364][ 2212][5][1][33] P1 MOVE [L    F]
[365][ 2213][5][1][ 1] P1 MOVE [L     ]
[366][ 2215][5][1][33] P1 MOVE [L    F]
[367][ 2216][5][1][41] P1 MOVE [L  D F]
[368][ 2217][5][1][ 9] P1 MOVE [L  D  ]
[369][ 2219][5][1][ 9] P1 MOVE [L  D  ]
[370][ 2220][5][1][ 9] P1 MOVE [L  D  ]
[371][ 2222][5][1][ 9] P1 MOVE [L  D  ]
[372][ 2224][5][1][ 9] P1 MOVE [L  D  ]
[373][ 2226][5][1][ 9] P1 MOVE [L  D  ]
[374][ 2227][5][1][ 9] P1 MOVE [L  D  ]

good remove:

[345][ 2184][5][1][ 9] P1 MOVE [L  D  ]
[346][ 2185][5][1][ 9] P1 MOVE [L  D  ]
[347][ 2186][5][1][ 9] P1 MOVE [L  D  ]
[348][ 2188][5][1][ 9] P1 MOVE [L  D  ]
[349][ 2189][5][1][ 8] P1 MOVE [   D  ]
[350][ 2191][5][1][10] P1 MOVE [ R D  ]
[351][ 2192][5][1][10] P1 MOVE [ R D  ]
[352][ 2193][5][1][10] P1 MOVE [ R D  ]
[353][ 2195][5][1][42] P1 MOVE [ R D F]
[354][ 2196][5][1][10] P1 MOVE [ R D  ]
[355][ 2198][5][1][34] P1 MOVE [ R   F]
[356][ 2200][5][1][ 2] P1 MOVE [ R    ]
[357][ 2202][5][1][34] P1 MOVE [ R   F]
[358][ 2203][5][1][ 2] P1 MOVE [ R    ]
[359][ 2205][5][1][ 2] P1 MOVE [ R    ]
[360][ 2206][5][1][ 2] P1 MOVE [ R    ]
[361][ 2209][5][1][ 2] P1 MOVE [ R    ]
[362][ 2210][5][1][ 2] P1 MOVE [ R    ]
[363][ 2211][5][1][ 1] P1 MOVE [L     ]
[364][ 2212][5][1][33] P1 MOVE [L    F]
[365][ 2213][5][1][ 1] P1 MOVE [L     ]
[366][ 2215][5][1][33] P1 MOVE [L    F]
[367][ 2216][5][1][41] P1 MOVE [L  D F]
[368][ 2217][5][1][ 9] P1 MOVE [L  D  ]
[369][ 2219][5][1][ 9] P1 MOVE [L  D  ]
[370][ 2220][5][1][ 9] P1 MOVE [L  D  ]
[371][ 2222][5][1][ 9] P1 MOVE [L  D  ]
[372][ 2224][5][1][ 9] P1 MOVE [L  D  ]
[373][ 2226][5][1][ 9] P1 MOVE [L  D  ]
[374][ 2227][5][1][ 9] P1 MOVE [L  D  ]






again with more logging....


file and path selected:C:\pm\savegame\l23-m023.gm
326 - total fire held sections ----------------
247 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
32 - player carry
Removing section:3  p:1  732-734   ild:6219 ld:6219
Removing section:4  p:1  736-738   ild:6219 ld:6219
Removing section:5  p:1  1002-1004   ild:6219 ld:6219
Removing section:6  p:1  1006-1008   ild:6219 ld:6219
Removing section:7  p:1  1010-1011   ild:6219 ld:6219
Removing section:8  p:1  1013-1014   ild:6219 ld:6219
Removing section:9  p:1  1016-1017   ild:6219 ld:6219
Removing section:11  p:1  1042-1044   ild:6219 ld:6219
Removing section:12  p:1  1046-1047   ild:6219 ld:6219
Removing section:13  p:1  1050-1051   ild:6219 ld:6219
Removing section:14  p:1  1074-1077   ild:6219 ld:6219
Removing section:15  p:1  1079-1080   ild:6219 ld:6219
Removing section:16  p:1  1082-1084   ild:6219 ld:6219
Removing section:18  p:1  1113-1115   ild:6219 ld:6219
Removing section:20  p:1  1120-1121   ild:6219 ld:6219
Removing section:21  p:1  1123-1125   ild:6219 ld:6219
Removing section:22  p:1  1127-1129   ild:6219 ld:6219
Removing section:23  p:1  1144-1146   ild:6219 ld:6219
Removing section:24  p:1  1148-1150   ild:6219 ld:6219
Removing section:25  p:1  1152-1153   ild:6219 ld:6219
Removing section:26  p:1  1155-1157   ild:6219 ld:6219
Removing section:27  p:1  1159-1161   ild:6219 ld:6219
Removing section:28  p:1  1216-1218   ild:6219 ld:6219
Removing section:29  p:1  1220-1221   ild:6219 ld:6219
Removing section:30  p:1  1223-1225   ild:6219 ld:6219
Removing section:32  p:1  1230-1233   ild:6219 ld:6219
Removing section:33  p:1  1236-1239   ild:6219 ld:6219
Removing section:34  p:1  1242-1246   ild:6219 ld:6219
Removing section:35  p:1  1248-1251   ild:6219 ld:6219
Removing section:36  p:1  1253-1256   ild:6219 ld:6219
Removing section:37  p:1  1310-1312   ild:6219 ld:6219
Removing section:38  p:1  1314-1315   ild:6219 ld:6219
Removing section:39  p:1  1317-1319   ild:6219 ld:6219
Removing section:40  p:1  1336-1338   ild:6219 ld:6219
Removing section:41  p:1  1340-1342   ild:6219 ld:6219
Removing section:42  p:1  1344-1348   ild:6219 ld:6219
Removing section:44  p:1  1357-1361   ild:6219 ld:6219
Removing section:45  p:1  1363-1366   ild:6219 ld:6219
Removing section:46  p:1  1368-1371   ild:6219 ld:6219
Removing section:47  p:1  1373-1376   ild:6219 ld:6219
Removing section:48  p:1  1378-1381   ild:6219 ld:6219
Removing section:49  p:1  1384-1387   ild:6219 ld:6219
Removing section:53  p:1  1404-1408   ild:6219 ld:6219
Removing section:54  p:1  1410-1412   ild:6219 ld:6219
Removing section:55  p:1  1455-1458   ild:6219 ld:6219
Removing section:56  p:1  1491-1493   ild:6219 ld:6219
Removing section:58  p:1  1499-1500   ild:6219 ld:6219
Removing section:59  p:1  1502-1503   ild:6219 ld:6219
Removing section:61  p:1  1617-1618   ild:6219 ld:6219
Removing section:62  p:1  1627-1628   ild:6219 ld:6219
Removing section:63  p:1  1630-1631   ild:6219 ld:6219
Removing section:64  p:1  1633-1634   ild:6219 ld:6219
Removing section:65  p:1  1637-1645   ild:6219 ld:6219
Removing section:66  p:1  1647-1650   ild:6219 ld:6219
Removing section:68  p:1  1951-1952   ild:6219 ld:6219
Removing section:70  p:1  1958-1959   ild:6219 ld:6219
Removing section:72  p:1  1997-1999   ild:6219 ld:6219
Removing section:73  p:1  2001-2002   ild:6219 ld:6219
Removing section:74  p:1  2008-2009   ild:6219 ld:6219
Removing section:75  p:1  2011-2012   ild:6219 ld:6219
Removing section:76  p:1  2014-2016   ild:6219 ld:6219
Removing section:77  p:1  2018-2020   ild:6219 ld:6219
Removing section:78  p:1  2032-2034   ild:6219 ld:6219
Removing section:79  p:1  2036-2038   ild:6219 ld:6219
Removing section:80  p:1  2040-2042   ild:6219 ld:6219
Removing section:81  p:1  2095-2097   ild:6219 ld:6219
Removing section:82  p:1  2099-2101   ild:6219 ld:6219
Removing section:84  p:1  2162-2164   ild:6219 ld:6219
Removing section:85  p:1  2166-2168   ild:6219 ld:6219
Removing section:86  p:1  2169-2170   ild:6219 ld:6219
Removing section:87  p:1  2172-2174   ild:6219 ld:6219
Removing section:88  p:1  2175-2177   ild:6219 ld:6219
Removing section:89  p:1  2178-2180   ild:6219 ld:6219
Removing section:90  p:1  2182-2183   ild:6219 ld:6219
Removing section:91  p:1  2185-2186   ild:6219 ld:6219
Removing section:92  p:1  2188-2189   ild:6219 ld:6219
Removing section:93  p:1  2192-2193   ild:6219 ld:6219
Removing section:96  p:1  2202-2203   ild:6219 ld:6219
Removing section:97  p:1  2205-2206   ild:6219 ld:6219
Removing section:98  p:1  2209-2210   ild:6219 ld:6219
Removing section:101  p:1  2219-2220   ild:6219 ld:6219
Removing section:102  p:1  2222-2224   ild:6219 ld:6219
Removing section:103  p:1  2226-2227   ild:6219 ld:6219
Removing section:106  p:1  2236-2238   ild:6219 ld:6219
Removing section:108  p:1  2243-2244   ild:6219 ld:6219
Removing section:109  p:1  2247-2248   ild:6219 ld:6219
Removing section:110  p:1  2250-2252   ild:6219 ld:6219
Removing section:111  p:1  2254-2256   ild:6219 ld:6219
Removing section:112  p:1  2258-2260   ild:6219 ld:6219
Removing section:114  p:1  2292-2294   ild:6219 ld:6219
Removing section:115  p:1  2295-2297   ild:6219 ld:6219
Removing section:116  p:1  2299-2300   ild:6219 ld:6219
Removing section:117  p:1  2302-2304   ild:6219 ld:6219
Removing section:118  p:1  2320-2321   ild:6219 ld:6219
Removing section:119  p:1  2323-2325   ild:6219 ld:6219
Removing section:121  p:1  2330-2332   ild:6219 ld:6219
Removing section:122  p:1  2334-2336   ild:6219 ld:6219
Removing section:123  p:1  2360-2362   ild:6219 ld:6219
Removing section:124  p:1  2364-2365   ild:6219 ld:6219
Removing section:125  p:1  2368-2369   ild:6219 ld:6219
Removing section:126  p:1  2371-2373   ild:6219 ld:6219
Removing section:127  p:1  2375-2377   ild:6219 ld:6219
Removing section:128  p:1  2379-2381   ild:6219 ld:6219
Removing section:129  p:1  2401-2404   ild:6219 ld:6219
Removing section:130  p:1  2406-2407   ild:6219 ld:6219
Removing section:131  p:1  2410-2411   ild:6219 ld:6219
Removing section:132  p:1  2413-2415   ild:6219 ld:6219
Removing section:133  p:1  2417-2419   ild:6219 ld:6219
Removing section:134  p:1  2421-2423   ild:6219 ld:6219
Removing section:135  p:1  2438-2441   ild:6219 ld:6219
Removing section:136  p:1  2443-2445   ild:6219 ld:6219
Removing section:137  p:1  2447-2448   ild:6219 ld:6219
Removing section:138  p:1  2450-2452   ild:6219 ld:6219
Removing section:139  p:1  2454-2456   ild:6219 ld:6219
Removing section:140  p:1  2458-2460   ild:6219 ld:6219
Removing section:141  p:1  2476-2478   ild:6219 ld:6219
Removing section:142  p:1  2480-2482   ild:6219 ld:6219
Removing section:143  p:1  2484-2485   ild:6219 ld:6219
Removing section:144  p:1  2487-2489   ild:6219 ld:6219
Removing section:145  p:1  2491-2493   ild:6219 ld:6219
Removing section:147  p:1  2498-2500   ild:6219 ld:6219
Removing section:148  p:1  2502-2503   ild:6219 ld:6219
Removing section:149  p:1  2506-2507   ild:6219 ld:6219
Removing section:150  p:1  2875-2878   ild:6219 ld:6219
Removing section:151  p:1  2880-2882   ild:6219 ld:6219
Removing section:152  p:1  2884-2886   ild:6219 ld:6219
Removing section:153  p:1  2888-2890   ild:6219 ld:6219
Removing section:154  p:1  2893-2895   ild:6219 ld:6219
Removing section:155  p:1  2929-2931   ild:6219 ld:6219
Removing section:156  p:1  2933-2935   ild:6219 ld:6219
Removing section:157  p:1  2937-2938   ild:6219 ld:6219
Removing section:158  p:1  2940-2942   ild:6219 ld:6219
Removing section:159  p:1  2944-2946   ild:6219 ld:6219
Removing section:161  p:1  2951-2953   ild:6219 ld:6219
Removing section:162  p:1  2955-2957   ild:6219 ld:6219
Removing section:165  p:1  2984-2985   ild:6219 ld:6219
Removing section:166  p:1  2987-2988   ild:6219 ld:6219
Removing section:167  p:1  2990-2992   ild:6219 ld:6219
Removing section:168  p:1  2993-2995   ild:6219 ld:6219
Removing section:169  p:1  2997-2998   ild:6219 ld:6219
Removing section:170  p:1  3000-3002   ild:6219 ld:6219
Removing section:171  p:1  3004-3005   ild:6219 ld:6219
Removing section:172  p:1  3007-3009   ild:6219 ld:6219
Removing section:174  p:1  3014-3015   ild:6219 ld:6219
Removing section:175  p:1  3018-3019   ild:6219 ld:6219
Removing section:176  p:1  3022-3023   ild:6219 ld:6219
Removing section:177  p:1  3025-3027   ild:6219 ld:6219
Removing section:178  p:1  3029-3030   ild:6219 ld:6219
Removing section:179  p:1  3032-3033   ild:6219 ld:6219
Removing section:180  p:1  3035-3037   ild:6219 ld:6219
Removing section:181  p:1  3039-3040   ild:6219 ld:6219
Removing section:182  p:1  3042-3044   ild:6219 ld:6219
Removing section:183  p:1  3046-3048   ild:6219 ld:6219
Removing section:184  p:1  3050-3052   ild:6219 ld:6219
Removing section:185  p:1  3055-3057   ild:6219 ld:6219
Removing section:186  p:1  3059-3061   ild:6219 ld:6219
Removing section:188  p:1  3066-3068   ild:6219 ld:6219
Removing section:190  p:1  3073-3075   ild:6219 ld:6219
Removing section:192  p:1  3080-3081   ild:6219 ld:6219
Removing section:193  p:1  3083-3085   ild:6219 ld:6219
Removing section:194  p:1  3086-3087   ild:6219 ld:6219
Removing section:195  p:1  3094-3100   ild:6219 ld:6219
Removing section:196  p:1  3103-3105   ild:6219 ld:6219
Removing section:197  p:1  3119-3121   ild:6219 ld:6219
Removing section:198  p:1  3122-3124   ild:6219 ld:6219
Removing section:199  p:1  3126-3128   ild:6219 ld:6219
Removing section:200  p:1  3130-3132   ild:6219 ld:6219
Removing section:201  p:1  3134-3136   ild:6219 ld:6219
Removing section:203  p:1  3142-3143   ild:6219 ld:6219
Removing section:204  p:1  3145-3147   ild:6219 ld:6219
Removing section:206  p:1  3178-3180   ild:6219 ld:6219
Removing section:208  p:1  3185-3186   ild:6219 ld:6219
Removing section:209  p:1  3188-3190   ild:6219 ld:6219
Removing section:211  p:1  3225-3227   ild:6219 ld:6219
Removing section:212  p:1  3229-3231   ild:6219 ld:6219
Removing section:214  p:1  3236-3238   ild:6219 ld:6219
Removing section:215  p:1  3240-3241   ild:6219 ld:6219
Removing section:216  p:1  3243-3245   ild:6219 ld:6219
Removing section:226  p:1  3276-3278   ild:6219 ld:6219
Removing section:228  p:1  3283-3284   ild:6219 ld:6219
Removing section:229  p:1  3286-3287   ild:6219 ld:6219
Removing section:230  p:1  3289-3291   ild:6219 ld:6219
Removing section:232  p:1  3297-3298   ild:6219 ld:6219
Removing section:233  p:1  3300-3301   ild:6219 ld:6219
Removing section:234  p:1  3303-3305   ild:6219 ld:6219
Removing section:235  p:1  3307-3309   ild:6219 ld:6219
Removing section:236  p:1  3319-3321   ild:6219 ld:6219
Removing section:240  p:1  3333-3335   ild:6219 ld:6219
Removing section:244  p:1  3426-3427   ild:6219 ld:6219
Removing section:245  p:1  3429-3430   ild:6219 ld:6219
Removing section:246  p:1  3432-3434   ild:6219 ld:6219
Removing section:247  p:1  3436-3437   ild:6219 ld:6219
Removing section:248  p:1  3439-3441   ild:6219 ld:6219
Removing section:255  p:1  3522-3524   ild:6219 ld:6219
Removing section:256  p:1  3526-3527   ild:6219 ld:6219
Removing section:258  p:1  3533-3534   ild:6219 ld:6219
Removing section:259  p:1  3537-3538   ild:6219 ld:6219
Removing section:260  p:1  3541-3543   ild:6219 ld:6219
Removing section:262  p:1  3651-3654   ild:6219 ld:6219
Removing section:263  p:1  3673-3676   ild:6219 ld:6219
Removing section:265  p:1  3699-3701   ild:6219 ld:6219
Removing section:266  p:1  3703-3705   ild:6219 ld:6219
Removing section:267  p:1  3733-3735   ild:6219 ld:6219
Removing section:268  p:1  3737-3739   ild:6219 ld:6219
Removing section:269  p:1  3741-3744   ild:6219 ld:6219
Removing section:274  p:1  3799-3800   ild:6219 ld:6219
Removing section:275  p:1  3803-3804   ild:6219 ld:6219
Removing section:280  p:1  3832-3834   ild:6219 ld:6219
Removing section:281  p:1  3836-3838   ild:6219 ld:6219
Removing section:283  p:1  3871-3872   ild:6219 ld:6219
Removing section:284  p:1  3874-3876   ild:6219 ld:6219
Removing section:285  p:1  3878-3882   ild:6219 ld:6219
Removing section:286  p:1  4064-4066   ild:6219 ld:6219
Removing section:287  p:1  4068-4070   ild:6219 ld:6219
Removing section:288  p:1  4072-4073   ild:6219 ld:6219
Removing section:289  p:1  4075-4076   ild:6219 ld:6219
Removing section:291  p:1  4081-4083   ild:6219 ld:6219
Removing section:292  p:1  4085-4086   ild:6219 ld:6219
Removing section:293  p:1  4088-4089   ild:6219 ld:6219
Removing section:295  p:1  4094-4095   ild:6219 ld:6219
Removing section:297  p:1  4100-4102   ild:6219 ld:6219
Removing section:299  p:1  4107-4108   ild:6219 ld:6219
Removing section:300  p:1  4110-4111   ild:6219 ld:6219
Removing section:301  p:1  4113-4114   ild:6219 ld:6219
Removing section:302  p:1  4116-4118   ild:6219 ld:6219
Removing section:304  p:1  4123-4124   ild:6219 ld:6219
Removing section:305  p:1  4126-4127   ild:6219 ld:6219
Removing section:306  p:1  4129-4131   ild:6219 ld:6219
Removing section:307  p:1  4133-4134   ild:6219 ld:6219
Removing section:308  p:1  4136-4137   ild:6219 ld:6219
Removing section:309  p:1  4139-4140   ild:6219 ld:6219
Removing section:310  p:1  4142-4144   ild:6219 ld:6219
Removing section:311  p:1  4146-4147   ild:6219 ld:6219
Removing section:312  p:1  4149-4151   ild:6219 ld:6219
Removing section:313  p:1  4153-4154   ild:6219 ld:6219
Removing section:314  p:1  4156-4158   ild:6219 ld:6219
Removing section:315  p:1  4160-4161   ild:6219 ld:6219
Removing section:316  p:1  4163-4164   ild:6219 ld:6219
Removing section:317  p:1  4167-4168   ild:6219 ld:6219
Removing section:318  p:1  4170-4171   ild:6219 ld:6219
Removing section:319  p:1  4174-4175   ild:6219 ld:6219
Removing section:320  p:1  4177-4179   ild:6219 ld:6219
Removing section:321  p:1  4181-4182   ild:6219 ld:6219
Removing section:322  p:1  4184-4186   ild:6219 ld:6219
Removing section:323  p:1  4188-4190   ild:6219 ld:6219
Removing section:324  p:1  4192-4194   ild:6219 ld:6219
Removing section:325  p:1  4196-4197   ild:6219 ld:6219
Error! - After removing all sections, level done has changed from 6219 to 0
[344][ 2183][5][1][ 8] P1 MOVE [   D  ]
[345][ 2184][5][1][ 9] P1 MOVE [L  D  ]
[346][ 2185][5][1][ 9] P1 MOVE [L  D  ]
[347][ 2186][5][1][ 9] P1 MOVE [L  D  ]
[348][ 2188][5][1][ 9] P1 MOVE [L  D  ]
[349][ 2189][5][1][ 8] P1 MOVE [   D  ]
[350][ 2191][5][1][10] P1 MOVE [ R D  ]
[351][ 2192][5][1][10] P1 MOVE [ R D  ]
[352][ 2193][5][1][10] P1 MOVE [ R D  ]
[353][ 2195][5][1][42] P1 MOVE [ R D F]
[354][ 2196][5][1][10] P1 MOVE [ R D  ]
[355][ 2198][5][1][34] P1 MOVE [ R   F]
[356][ 2200][5][1][ 2] P1 MOVE [ R    ]
[357][ 2202][5][1][ 2] P1 MOVE [ R    ]
[358][ 2203][5][1][ 2] P1 MOVE [ R    ]
[359][ 2205][5][1][ 2] P1 MOVE [ R    ]
[360][ 2206][5][1][ 2] P1 MOVE [ R    ]
[361][ 2209][5][1][ 2] P1 MOVE [ R    ]
[362][ 2210][5][1][ 2] P1 MOVE [ R    ]
[363][ 2211][5][1][ 1] P1 MOVE [L     ]
[364][ 2212][5][1][33] P1 MOVE [L    F]
[365][ 2213][5][1][ 1] P1 MOVE [L     ]
[366][ 2215][5][1][33] P1 MOVE [L    F]
[367][ 2216][5][1][41] P1 MOVE [L  D F]
[368][ 2217][5][1][ 9] P1 MOVE [L  D  ]
[369][ 2219][5][1][ 9] P1 MOVE [L  D  ]
[370][ 2220][5][1][ 9] P1 MOVE [L  D  ]
[371][ 2222][5][1][ 9] P1 MOVE [L  D  ]
[372][ 2224][5][1][ 9] P1 MOVE [L  D  ]
[373][ 2226][5][1][ 9] P1 MOVE [L  D  ]
[374][ 2227][5][1][ 9] P1 MOVE [L  D  ]
[375][ 2229][5][1][41] P1 MOVE [L  D F]
[376][ 2231][5][1][ 9] P1 MOVE [L  D  ]
[377][ 2233][5][1][41] P1 MOVE [L  D F]
[378][ 2234][5][1][ 9] P1 MOVE [L  D  ]
[379][ 2236][5][1][ 9] P1 MOVE [L  D  ]
[380][ 2238][5][1][ 9] P1 MOVE [L  D  ]
[381][ 2240][5][1][41] P1 MOVE [L  D F]
[382][ 2241][5][1][ 9] P1 MOVE [L  D  ]
[383][ 2243][5][1][ 9] P1 MOVE [L  D  ]






326 - total fire held sections ----------------
247 - unused fire held sections
47 - enemy hits
0 - player hits
0 - breakable blocks
0 - orb detect
0 - trg detect
32 - player carry
Removing section:3  p:1  732-734   ild:6219 ld:6219
Removing section:4  p:1  736-738   ild:6219 ld:6219
Removing section:5  p:1  1002-1004   ild:6219 ld:6219
Removing section:6  p:1  1006-1008   ild:6219 ld:6219
Removing section:7  p:1  1010-1011   ild:6219 ld:6219
Removing section:8  p:1  1013-1014   ild:6219 ld:6219
Removing section:9  p:1  1016-1017   ild:6219 ld:6219
Removing section:11  p:1  1042-1044   ild:6219 ld:6219
Removing section:12  p:1  1046-1047   ild:6219 ld:6219
Removing section:13  p:1  1050-1051   ild:6219 ld:6219
Removing section:14  p:1  1074-1077   ild:6219 ld:6219
Removing section:15  p:1  1079-1080   ild:6219 ld:6219
Removing section:16  p:1  1082-1084   ild:6219 ld:6219
Removing section:18  p:1  1113-1115   ild:6219 ld:6219
Removing section:20  p:1  1120-1121   ild:6219 ld:6219
Removing section:21  p:1  1123-1125   ild:6219 ld:6219
Removing section:22  p:1  1127-1129   ild:6219 ld:6219
Removing section:23  p:1  1144-1146   ild:6219 ld:6219
Removing section:24  p:1  1148-1150   ild:6219 ld:6219
Removing section:25  p:1  1152-1153   ild:6219 ld:6219
Removing section:26  p:1  1155-1157   ild:6219 ld:6219
Removing section:27  p:1  1159-1161   ild:6219 ld:6219
Removing section:28  p:1  1216-1218   ild:6219 ld:6219
Removing section:29  p:1  1220-1221   ild:6219 ld:6219
Removing section:30  p:1  1223-1225   ild:6219 ld:6219
Removing section:32  p:1  1230-1233   ild:6219 ld:6219
Removing section:33  p:1  1236-1239   ild:6219 ld:6219
Removing section:34  p:1  1242-1246   ild:6219 ld:6219
Removing section:35  p:1  1248-1251   ild:6219 ld:6219
Removing section:36  p:1  1253-1256   ild:6219 ld:6219
Removing section:37  p:1  1310-1312   ild:6219 ld:6219
Removing section:38  p:1  1314-1315   ild:6219 ld:6219
Removing section:40  p:1  1336-1338   ild:6219 ld:6219
Removing section:41  p:1  1340-1342   ild:6219 ld:6219
Removing section:42  p:1  1344-1348   ild:6219 ld:6219
Removing section:44  p:1  1357-1361   ild:6219 ld:6219
Removing section:45  p:1  1363-1366   ild:6219 ld:6219
Removing section:46  p:1  1368-1371   ild:6219 ld:6219
Removing section:47  p:1  1373-1376   ild:6219 ld:6219
Removing section:48  p:1  1378-1381   ild:6219 ld:6219
Removing section:49  p:1  1384-1387   ild:6219 ld:6219
Removing section:53  p:1  1404-1408   ild:6219 ld:6219
Removing section:54  p:1  1410-1412   ild:6219 ld:6219
Removing section:55  p:1  1455-1458   ild:6219 ld:6219
Removing section:56  p:1  1491-1493   ild:6219 ld:6219
Removing section:58  p:1  1499-1500   ild:6219 ld:6219
Removing section:59  p:1  1502-1503   ild:6219 ld:6219
Removing section:61  p:1  1617-1618   ild:6219 ld:6219
Removing section:62  p:1  1627-1628   ild:6219 ld:6219
Removing section:63  p:1  1630-1631   ild:6219 ld:6219
Removing section:64  p:1  1633-1634   ild:6219 ld:6219
Removing section:65  p:1  1637-1645   ild:6219 ld:6219
Removing section:66  p:1  1647-1650   ild:6219 ld:6219
Removing section:68  p:1  1951-1952   ild:6219 ld:6219
Removing section:70  p:1  1958-1959   ild:6219 ld:6219
Removing section:72  p:1  1997-1999   ild:6219 ld:6219
Removing section:73  p:1  2001-2002   ild:6219 ld:6219
Removing section:74  p:1  2008-2009   ild:6219 ld:6219
Removing section:75  p:1  2011-2012   ild:6219 ld:6219
Removing section:76  p:1  2014-2016   ild:6219 ld:6219
Removing section:77  p:1  2018-2020   ild:6219 ld:6219
Removing section:78  p:1  2032-2034   ild:6219 ld:6219
Removing section:79  p:1  2036-2038   ild:6219 ld:6219
Removing section:80  p:1  2040-2042   ild:6219 ld:6219
Removing section:81  p:1  2095-2097   ild:6219 ld:6219
Removing section:82  p:1  2099-2101   ild:6219 ld:6219
Removing section:84  p:1  2162-2164   ild:6219 ld:6219
Removing section:85  p:1  2166-2168   ild:6219 ld:6219
Removing section:86  p:1  2169-2170   ild:6219 ld:6219
Removing section:87  p:1  2172-2174   ild:6219 ld:6219
Removing section:88  p:1  2175-2177   ild:6219 ld:6219
Removing section:89  p:1  2178-2180   ild:6219 ld:6219
Removing section:90  p:1  2182-2183   ild:6219 ld:6219
Removing section:91  p:1  2185-2186   ild:6219 ld:6219
Removing section:92  p:1  2188-2189   ild:6219 ld:6219
Removing section:93  p:1  2192-2193   ild:6219 ld:6219
Removing section:97  p:1  2205-2206   ild:6219 ld:6219
Removing section:98  p:1  2209-2210   ild:6219 ld:6219
Removing section:101  p:1  2219-2220   ild:6219 ld:6219
Removing section:102  p:1  2222-2224   ild:6219 ld:6219
Removing section:103  p:1  2226-2227   ild:6219 ld:6219
Removing section:106  p:1  2236-2238   ild:6219 ld:6219
Removing section:108  p:1  2243-2244   ild:6219 ld:6219
Removing section:109  p:1  2247-2248   ild:6219 ld:6219
Removing section:110  p:1  2250-2252   ild:6219 ld:6219
Removing section:111  p:1  2254-2256   ild:6219 ld:6219
Removing section:112  p:1  2258-2260   ild:6219 ld:6219
Removing section:114  p:1  2292-2294   ild:6219 ld:6219
Removing section:115  p:1  2295-2297   ild:6219 ld:6219
Removing section:116  p:1  2299-2300   ild:6219 ld:6219
Removing section:117  p:1  2302-2304   ild:6219 ld:6219
Removing section:118  p:1  2320-2321   ild:6219 ld:6219
Removing section:119  p:1  2323-2325   ild:6219 ld:6219
Removing section:121  p:1  2330-2332   ild:6219 ld:6219
Removing section:122  p:1  2334-2336   ild:6219 ld:6219
Removing section:123  p:1  2360-2362   ild:6219 ld:6219
Removing section:124  p:1  2364-2365   ild:6219 ld:6219
Removing section:125  p:1  2368-2369   ild:6219 ld:6219
Removing section:126  p:1  2371-2373   ild:6219 ld:6219
Removing section:127  p:1  2375-2377   ild:6219 ld:6219
Removing section:128  p:1  2379-2381   ild:6219 ld:6219
Removing section:129  p:1  2401-2404   ild:6219 ld:6219
Removing section:130  p:1  2406-2407   ild:6219 ld:6219
Removing section:131  p:1  2410-2411   ild:6219 ld:6219
Removing section:132  p:1  2413-2415   ild:6219 ld:6219
Removing section:133  p:1  2417-2419   ild:6219 ld:6219
Removing section:134  p:1  2421-2423   ild:6219 ld:6219
Removing section:135  p:1  2438-2441   ild:6219 ld:6219
Removing section:136  p:1  2443-2445   ild:6219 ld:6219
Removing section:137  p:1  2447-2448   ild:6219 ld:6219
Removing section:138  p:1  2450-2452   ild:6219 ld:6219
Removing section:139  p:1  2454-2456   ild:6219 ld:6219
Removing section:140  p:1  2458-2460   ild:6219 ld:6219
Removing section:141  p:1  2476-2478   ild:6219 ld:6219
Removing section:142  p:1  2480-2482   ild:6219 ld:6219
Removing section:143  p:1  2484-2485   ild:6219 ld:6219
Removing section:144  p:1  2487-2489   ild:6219 ld:6219
Removing section:145  p:1  2491-2493   ild:6219 ld:6219
Removing section:147  p:1  2498-2500   ild:6219 ld:6219
Removing section:148  p:1  2502-2503   ild:6219 ld:6219
Removing section:149  p:1  2506-2507   ild:6219 ld:6219
Removing section:150  p:1  2875-2878   ild:6219 ld:6219
Removing section:151  p:1  2880-2882   ild:6219 ld:6219
Removing section:152  p:1  2884-2886   ild:6219 ld:6219
Removing section:153  p:1  2888-2890   ild:6219 ld:6219
Removing section:154  p:1  2893-2895   ild:6219 ld:6219
Removing section:155  p:1  2929-2931   ild:6219 ld:6219
Removing section:156  p:1  2933-2935   ild:6219 ld:6219
Removing section:157  p:1  2937-2938   ild:6219 ld:6219
Removing section:158  p:1  2940-2942   ild:6219 ld:6219
Removing section:159  p:1  2944-2946   ild:6219 ld:6219
Removing section:161  p:1  2951-2953   ild:6219 ld:6219
Removing section:162  p:1  2955-2957   ild:6219 ld:6219
Removing section:165  p:1  2984-2985   ild:6219 ld:6219
Removing section:166  p:1  2987-2988   ild:6219 ld:6219
Removing section:167  p:1  2990-2992   ild:6219 ld:6219
Removing section:168  p:1  2993-2995   ild:6219 ld:6219
Removing section:169  p:1  2997-2998   ild:6219 ld:6219
Removing section:170  p:1  3000-3002   ild:6219 ld:6219
Removing section:171  p:1  3004-3005   ild:6219 ld:6219
Removing section:172  p:1  3007-3009   ild:6219 ld:6219
Removing section:174  p:1  3014-3015   ild:6219 ld:6219
Removing section:175  p:1  3018-3019   ild:6219 ld:6219
Removing section:176  p:1  3022-3023   ild:6219 ld:6219
Removing section:177  p:1  3025-3027   ild:6219 ld:6219
Removing section:178  p:1  3029-3030   ild:6219 ld:6219
Removing section:179  p:1  3032-3033   ild:6219 ld:6219
Removing section:180  p:1  3035-3037   ild:6219 ld:6219
Removing section:181  p:1  3039-3040   ild:6219 ld:6219
Removing section:182  p:1  3042-3044   ild:6219 ld:6219
Removing section:183  p:1  3046-3048   ild:6219 ld:6219
Removing section:184  p:1  3050-3052   ild:6219 ld:6219
Removing section:185  p:1  3055-3057   ild:6219 ld:6219
Removing section:186  p:1  3059-3061   ild:6219 ld:6219
Removing section:188  p:1  3066-3068   ild:6219 ld:6219
Removing section:190  p:1  3073-3075   ild:6219 ld:6219
Removing section:192  p:1  3080-3081   ild:6219 ld:6219
Removing section:193  p:1  3083-3085   ild:6219 ld:6219
Removing section:194  p:1  3086-3087   ild:6219 ld:6219
Removing section:195  p:1  3094-3100   ild:6219 ld:6219
Removing section:196  p:1  3103-3105   ild:6219 ld:6219
Removing section:197  p:1  3119-3121   ild:6219 ld:6219
Removing section:198  p:1  3122-3124   ild:6219 ld:6219
Removing section:199  p:1  3126-3128   ild:6219 ld:6219
Removing section:200  p:1  3130-3132   ild:6219 ld:6219
Removing section:201  p:1  3134-3136   ild:6219 ld:6219
Removing section:203  p:1  3142-3143   ild:6219 ld:6219
Removing section:204  p:1  3145-3147   ild:6219 ld:6219
Removing section:206  p:1  3178-3180   ild:6219 ld:6219
Removing section:208  p:1  3185-3186   ild:6219 ld:6219
Removing section:209  p:1  3188-3190   ild:6219 ld:6219
Removing section:211  p:1  3225-3227   ild:6219 ld:6219
Removing section:212  p:1  3229-3231   ild:6219 ld:6219
Removing section:214  p:1  3236-3238   ild:6219 ld:6219
Removing section:215  p:1  3240-3241   ild:6219 ld:6219
Removing section:216  p:1  3243-3245   ild:6219 ld:6219
Removing section:226  p:1  3276-3278   ild:6219 ld:6219
Removing section:228  p:1  3283-3284   ild:6219 ld:6219
Removing section:229  p:1  3286-3287   ild:6219 ld:6219
Removing section:232  p:1  3297-3298   ild:6219 ld:6219
Removing section:233  p:1  3300-3301   ild:6219 ld:6219
Removing section:234  p:1  3303-3305   ild:6219 ld:6219
Removing section:235  p:1  3307-3309   ild:6219 ld:6219
Removing section:236  p:1  3319-3321   ild:6219 ld:6219
Removing section:240  p:1  3333-3335   ild:6219 ld:6219
Removing section:244  p:1  3426-3427   ild:6219 ld:6219
Removing section:245  p:1  3429-3430   ild:6219 ld:6219
Removing section:246  p:1  3432-3434   ild:6219 ld:6219
Removing section:247  p:1  3436-3437   ild:6219 ld:6219
Removing section:248  p:1  3439-3441   ild:6219 ld:6219
Removing section:255  p:1  3522-3524   ild:6219 ld:6219
Removing section:256  p:1  3526-3527   ild:6219 ld:6219
Removing section:258  p:1  3533-3534   ild:6219 ld:6219
Removing section:259  p:1  3537-3538   ild:6219 ld:6219
Removing section:260  p:1  3541-3543   ild:6219 ld:6219
Removing section:263  p:1  3673-3676   ild:6219 ld:6219
Removing section:265  p:1  3699-3701   ild:6219 ld:6219
Removing section:266  p:1  3703-3705   ild:6219 ld:6219
Removing section:267  p:1  3733-3735   ild:6219 ld:6219
Removing section:268  p:1  3737-3739   ild:6219 ld:6219
Removing section:269  p:1  3741-3744   ild:6219 ld:6219
Removing section:274  p:1  3799-3800   ild:6219 ld:6219
Removing section:275  p:1  3803-3804   ild:6219 ld:6219
Removing section:280  p:1  3832-3834   ild:6219 ld:6219
Removing section:281  p:1  3836-3838   ild:6219 ld:6219
Removing section:283  p:1  3871-3872   ild:6219 ld:6219
Removing section:284  p:1  3874-3876   ild:6219 ld:6219
Removing section:285  p:1  3878-3882   ild:6219 ld:6219
Removing section:286  p:1  4064-4066   ild:6219 ld:6219
Removing section:287  p:1  4068-4070   ild:6219 ld:6219
Removing section:288  p:1  4072-4073   ild:6219 ld:6219
Removing section:289  p:1  4075-4076   ild:6219 ld:6219
Removing section:292  p:1  4085-4086   ild:6219 ld:6219
Removing section:293  p:1  4088-4089   ild:6219 ld:6219
Removing section:299  p:1  4107-4108   ild:6219 ld:6219
Removing section:300  p:1  4110-4111   ild:6219 ld:6219
Removing section:301  p:1  4113-4114   ild:6219 ld:6219
Removing section:302  p:1  4116-4118   ild:6219 ld:6219
Removing section:304  p:1  4123-4124   ild:6219 ld:6219
Removing section:305  p:1  4126-4127   ild:6219 ld:6219
Removing section:306  p:1  4129-4131   ild:6219 ld:6219
Removing section:307  p:1  4133-4134   ild:6219 ld:6219
Removing section:308  p:1  4136-4137   ild:6219 ld:6219
Removing section:309  p:1  4139-4140   ild:6219 ld:6219
Removing section:310  p:1  4142-4144   ild:6219 ld:6219
Removing section:311  p:1  4146-4147   ild:6219 ld:6219
Removing section:312  p:1  4149-4151   ild:6219 ld:6219
Removing section:313  p:1  4153-4154   ild:6219 ld:6219
Removing section:314  p:1  4156-4158   ild:6219 ld:6219
Removing section:315  p:1  4160-4161   ild:6219 ld:6219
Removing section:316  p:1  4163-4164   ild:6219 ld:6219
Removing section:317  p:1  4167-4168   ild:6219 ld:6219
Removing section:318  p:1  4170-4171   ild:6219 ld:6219
Removing section:319  p:1  4174-4175   ild:6219 ld:6219
Removing section:320  p:1  4177-4179   ild:6219 ld:6219
Removing section:321  p:1  4181-4182   ild:6219 ld:6219
Removing section:322  p:1  4184-4186   ild:6219 ld:6219
Removing section:323  p:1  4188-4190   ild:6219 ld:6219
Removing section:324  p:1  4192-4194   ild:6219 ld:6219
Removing section:325  p:1  4196-4197   ild:6219 ld:6219
[344][ 2183][5][1][ 8] P1 MOVE [   D  ]
[345][ 2184][5][1][ 9] P1 MOVE [L  D  ]
[346][ 2185][5][1][ 9] P1 MOVE [L  D  ]
[347][ 2186][5][1][ 9] P1 MOVE [L  D  ]
[348][ 2188][5][1][ 9] P1 MOVE [L  D  ]
[349][ 2189][5][1][ 8] P1 MOVE [   D  ]
[350][ 2191][5][1][10] P1 MOVE [ R D  ]
[351][ 2192][5][1][10] P1 MOVE [ R D  ]
[352][ 2193][5][1][10] P1 MOVE [ R D  ]
[353][ 2195][5][1][42] P1 MOVE [ R D F]
[354][ 2196][5][1][10] P1 MOVE [ R D  ]
[355][ 2198][5][1][34] P1 MOVE [ R   F]
[356][ 2200][5][1][ 2] P1 MOVE [ R    ]
[357][ 2202][5][1][34] P1 MOVE [ R   F]
[358][ 2203][5][1][ 2] P1 MOVE [ R    ]
[359][ 2205][5][1][ 2] P1 MOVE [ R    ]
[360][ 2206][5][1][ 2] P1 MOVE [ R    ]
[361][ 2209][5][1][ 2] P1 MOVE [ R    ]
[362][ 2210][5][1][ 2] P1 MOVE [ R    ]
[363][ 2211][5][1][ 1] P1 MOVE [L     ]
[364][ 2212][5][1][33] P1 MOVE [L    F]
[365][ 2213][5][1][ 1] P1 MOVE [L     ]
[366][ 2215][5][1][33] P1 MOVE [L    F]
[367][ 2216][5][1][41] P1 MOVE [L  D F]
[368][ 2217][5][1][ 9] P1 MOVE [L  D  ]
[369][ 2219][5][1][ 9] P1 MOVE [L  D  ]
[370][ 2220][5][1][ 9] P1 MOVE [L  D  ]
[371][ 2222][5][1][ 9] P1 MOVE [L  D  ]
[372][ 2224][5][1][ 9] P1 MOVE [L  D  ]
[373][ 2226][5][1][ 9] P1 MOVE [L  D  ]
[374][ 2227][5][1][ 9] P1 MOVE [L  D  ]
[375][ 2229][5][1][41] P1 MOVE [L  D F]
[376][ 2231][5][1][ 9] P1 MOVE [L  D  ]
[377][ 2233][5][1][41] P1 MOVE [L  D F]
[378][ 2234][5][1][ 9] P1 MOVE [L  D  ]
[379][ 2236][5][1][ 9] P1 MOVE [L  D  ]
[380][ 2238][5][1][ 9] P1 MOVE [L  D  ]
[381][ 2240][5][1][41] P1 MOVE [L  D F]
[382][ 2241][5][1][ 9] P1 MOVE [L  D  ]
[383][ 2243][5][1][ 9] P1 MOVE [L  D  ]



the first one without test removed this:
Removing section:96  p:1  2202-2203   ild:6219 ld:6219

the second one did not..

Removing section:93  p:1  2192-2193   ild:6219 ld:6219
Removing section:97  p:1  2205-2206   ild:6219 ld:6219
Removing section:98  p:1  2209-2210   ild:6219 ld:6219

WHY???!!!!

just the fact of playing back the level sets unused sections used...!!!!
this is a good thing! it breaks much less..

so an used section that might be scheduled for removal
then the section before it is removed
then the test for level done is run, playing back the level
now the section after might be marked as used!!


I want to make more stats at the same time as level done..
also how many ememies killed, how many coins, etc... I think I have this already
level_stats??



but I want to check them after I remove sections

add frame and title to timeline
add pop-up menu to timeline
add hide/show while play/record to transport menu

now all demo level play back perfectly

no sound with playallforrecords..done

can I do the auto thing with gdt...see if it breaks things
42 and 49 still have issues

look at them manually

42

Removing section:59  p:0  3638-3642
Removing section:61  p:0  3647-3650
Removing section:62  p:0  3651-3653
Removing section:63  p:0  3655-3659
Removing section:64  p:0  3661-3664
Removing section:69  p:0  3708-3710
Removing section:71  p:0  3715-3717
Removing section:72  p:0  3718-3720
Removing section:72  p:0  3718-3720   ild:14974 ld:0 ----  Error!
Removing section:73  p:0  3721-3722
Removing section:73  p:0  3721-3722   ild:0 ld:14974 ----  Error!
Removing section:74  p:0  3724-3725
Removing section:74  p:0  3724-3725   ild:14974 ld:0 ----  Error!
Removing section:75  p:0  3727-3728
Removing section:75  p:0  3727-3728   ild:0 ld:14974 ----  Error!
Removing section:79  p:0  3743-3745
Removing section:80  p:0  3746-3748
Removing section:82  p:0  3779-3781
Removing section:84  p:0  3791-3793
Removing section:86  p:0  3833-3834
Removing section:88  p:0  3838-3839

Removing section:173  p:0  5542-5543 ld:14974
Removing section:175  p:0  5645-5646 ld:14974
Removing section:176  p:0  5648-5649 ld:14974
Removing section:177  p:0  5651-5652 ld:14974
Removing section:180  p:0  5660-5661 ld:14974
Removing section:181  p:0  5663-5665 ld:14974
Removing section:183  p:0  6092-6095 ld:14974
Removing section:184  p:0  6097-6098 ld:14974
Removing section:184  p:0  6097-6098   ild:14974 ld:0 ----  Error!
Removing section:185  p:0  6100-6101 ld:0
Removing section:185  p:0  6100-6101   ild:0 ld:14974 ----  Error!
Removing section:186  p:0  6103-6104 ld:14974
Removing section:186  p:0  6103-6104   ild:14974 ld:0 ----  Error!
Removing section:188  p:0  6109-6111 ld:0
Removing section:189  p:0  6272-6274 ld:0
Removing section:191  p:0  6280-6282 ld:0
Removing section:192  p:0  6283-6284 ld:0
Removing section:195  p:0  7705-7706 ld:0
Removing section:196  p:0  7708-7709 ld:0
Removing section:197  p:0  8088-8090 ld:0
Removing section:198  p:0  8092-8094 ld:0
Removing section:199  p:0  8095-8097 ld:0


what am I going to do to fix this?


can I add an execption? like dont erase a specific index? or frame range?



or if removing it causes error add it back...


I finally got l42 to work by manually excepting some indexes
do 49 also..done


now all level have been done...

re do level 49 single



















20231226

weird bug when tossing lit exploding bomb upward and it hits ceiling then ttl gets set...why??

idk why it gets set, but I fixed it by never checking ttl for lit bombs...

test demos...all good


make a new helper function:

add shot at current frame...

makes sure that current frame has a game move with fire...
and that the next frame has one with fire off
and that if fire is active before, remove it...

it would be nice to have range tools also:

seperate widget...
start frame
end frame
then some tools
- erase range
- erase fire from range
- remove dup
- add rapid fire
- move range +/1 frame


20231227

I have been working in recording demos for a long time now...
what is my end game for this project...



clean up the source file and break it into some smaller files...



when stopping record, do the sort and stuff..done

why does draw look different for player and purple coins?
in the process of fixed this...
drawing end cutscene rocket move looks choppy...
when in demo mode
is there any other way to look at it besides that??
temp door looks good...
made draw_sequence not do anything in ldm mode 27 or if no display...
now back to draw player...

this fixed that issue...
      int old_draw_method = 1;
      if (mLoop.state[0] == PM_PROGRAM_STATE_MAIN_GAME_LOOP) old_draw_method = 0;
      if (mLoop.state[0] == PM_PROGRAM_STATE_DEMO_RECORD) old_draw_method = 0;
      if (syn[0].level_done_mode == 27) old_draw_method = 1;
      if (old_draw_method)
      {

what else get drawn directly on screen?
purple coins
now that is fixed also..






copy from one player to another, where did that go??

section, file?

gm list...

make it go from current section to record player....


make insert fire move at current pos, on the pop-up menu for sectiom

add insert game move at current pos

20231231

add shift at current pos, shifts everything after +1 or -1 frame

show path for current player
- how?
iterate the level and record player positions in array
but then how will I draw it? and match the level?

I could just make a new level overlay and draw on it...

---

move all overlay to halfway pos, in mode 5


I am in the middle of re-making level 55, ancient ruins


20240210

Move some of demo record into its own file (now demo_mode is 2700 lines)
split mwDemoMode(2800) into mwDemoMode(400)  and mwDemoRecord (2000)
...done

Make the display of num of active enemy and player shots in the top frame optional? no just disable...done...

Make the showing of frame number on player bullet optional, maybe only in demo_record
if (!(mLoop.state[1] == PM_PROGRAM_STATE_DEMO_RECORD))
done....


Does purple coin draw funny in demo mode playback?
yes

how can I tell when demo mode is playing?

int mwItem::draw_bonus(int i, int x, int y, int shape)
{
   if ((item[i][6] == 3) && (mLoop.frame_num > 0)) // purple coin
   {
      if (mLoop.state[0] == PM_PROGRAM_STATE_MAIN_GAME_LOOP) return 1; // purple coin custom draw when game running
      if ((mLoop.state[0] == PM_PROGRAM_STATE_DEMO_RECORD) && (mDemoRecord.play)) return 1;
      if (mDemoMode.mode) return 1; // demo mode is playing
   }
   return 0;
}
fixed....


Make a nice way to start demo_record mode (now its just SHIFT-D)
Advanced section of settings demo page...done
Disabled the keyboard shortcut in top_menu...done

Finish level 55, ancient ruins
is 55 in the main rotation? no.
put down in words what you are trying to achieve here...
I spent some time looking at it and I am at a loss....
I reverted it!!


remove lower frame text, 'running saved game' for demo record mode...done
make time bubbles for timeline show on bottom done
same with level done done
then make game moves list lower done
context pop up menu for timeline



20140211

figure out what is happening with autosaving...I think it is in a not complete state....






start with with -c
exit to menu
start server from menu
cannot use esc to quit
actually cannot use esc to quit server at any time

actually its even worse, running server has no local control at at all!! WTF why?




this gets called every loop:

i want to modify it, this is the original


void mwPlayer::proc_player_input(void)
{
   for (int p=0; p<NUM_PLAYERS; p++)
   {
      if (syn[p].active) // cycle all active players
      {
         int cm = syn[p].control_method;
         if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) || (cm == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL) || (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL))
         {
            if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
            {
               set_comp_move_from_player_key_check(p);

               // even in fakekey mode allow ESC or menu
               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey))
                  if ((!mInput.key[loc[p].menu_key][0]) && (!mInput.key[ALLEGRO_KEY_ESCAPE][0])) loc[p].comp_move = rand() % 64;

               if (loc[p].comp_move != comp_move_from_players_current_controls(p))   // player's controls have changed
               {
                  if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) && (p == active_local_player))
                     mGameMoves.add_game_move(mLoop.frame_num, PM_GAMEMOVE_TYPE_PLAYER_MOVE, p, loc[p].comp_move); // add to game moves array

                  // in client mode, send cdat packet, and apply move directly to controls
                  if (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)
                  {
                     mGameMoves.add_game_move(mLoop.frame_num, PM_GAMEMOVE_TYPE_PLAYER_MOVE, p, loc[p].comp_move); // add to game moves array
                     mNetgame.client_send_cdat_packet(p);
                     set_controls_from_comp_move(p, loc[p].comp_move);
                     if (syn[p].menu) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_PREEXIT1; // menu key pressed
                     mLog.addf(LOG_NET_cdat, p, "tx cdat - move:%d\n", loc[p].comp_move);
                  }



               }
            }
         }
      }
      else if (syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL) // client waiting for server to make it active
      {
         if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT; // give them an escape option
      }
   }
}


first of all put this test outside the loop:
it makes no sense inside the loop

if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes




void mwPlayer::proc_player_input(void)
{
   if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         if (syn[p].active) // cycle all active players
         {
            int cm = syn[p].control_method;

            // these are the only local control methods
            if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) || (cm == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL) || (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL))
            {
               set_comp_move_from_player_key_check(p);

               // even in fakekey mode allow ESC or menu
               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey))
                  if ((!mInput.key[loc[p].menu_key][0]) && (!mInput.key[ALLEGRO_KEY_ESCAPE][0])) loc[p].comp_move = rand() % 64;

               if (loc[p].comp_move != comp_move_from_players_current_controls(p))   // player's controls have changed
               {
                  mGameMoves.add_game_move(mLoop.frame_num, PM_GAMEMOVE_TYPE_PLAYER_MOVE, p, loc[p].comp_move); // add to game moves array

                  // in client mode, also send cdat packet, and apply move directly to controls
                  if (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)
                  {
                     mNetgame.client_send_cdat_packet(p);
                     set_controls_from_comp_move(p, loc[p].comp_move);
                     if (syn[p].menu) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_PREEXIT1; // menu key pressed
                     mLog.addf(LOG_NET_cdat, p, "tx cdat - move:%d\n", loc[p].comp_move);
                  }
               }
            }
         }
         else if (syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL) // client waiting for server to make it active
         {
            if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT; // give them an escape option
         }
      }
}


final version:

void mwPlayer::proc_player_input(void)
{
   if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         if (syn[p].active) // cycle all active players
         {
            int cm = syn[p].control_method;
            if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) || (cm == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL) || (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)) // these are the only local control methods
            {
               set_comp_move_from_player_key_check(p);

               // fakekey mode
               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey))
               {
                  // even in fakekey mode allow ESC or menu
                  if ((!mInput.key[loc[p].menu_key][0]) && (!mInput.key[ALLEGRO_KEY_ESCAPE][0])) loc[p].comp_move = rand() % 64;
               }


               if (loc[p].comp_move != comp_move_from_players_current_controls(p))   // player's controls have changed
               {
                  mGameMoves.add_game_move(mLoop.frame_num, PM_GAMEMOVE_TYPE_PLAYER_MOVE, p, loc[p].comp_move); // add to game moves array

                  // in client mode, also send cdat packet, and apply move directly to controls
                  if (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)
                  {
                     mNetgame.client_send_cdat_packet(p);
                     set_controls_from_comp_move(p, loc[p].comp_move);
                     if (syn[p].menu) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_PREEXIT1; // menu key pressed
                  }
               }
            }
         }
         else if (syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL) // client waiting for server to make it active
         {
            if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT; // give them an escape option
         }
      }
}







clients are losing server connnection more than usual, look into why
of course now they won't do it...
why would a client lose server connection?
only reason I can see is last stdf rx > 200 frames
mPlayer.loc[p].client_last_stdf_rx_frame_num
this gets set whenever a new stdf packet is received by client
it gets reset to 0 with new level player init
it gets set to frame+200 when client joins



client loses server connection

[10][0][138526]+--------------------------------------------------------------------------+
[10][0][138526]|        Server received join request from m36 requesting color:10         |
[10][0][138526]|        Server replied with join invitation:                              |
[10][0][138526]+--------------------------------------------------------------------------+
[10][0][138925]+--------------------------------------------------------------------------+
[10][0][138925]|                                                                          |
[10][0][138925]|                             NEXT LEVEL:80                                |
[10][0][138925]|                                                                          |
[10][0][138925]+--------------------------------------------------------------------------+
logs/20240211-133721-[1][pmh].txt saved
Never save demo for overworld
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[10][1][204]+--------------------------------------------------------------------------+
[10][1][204]|                                                                          |
[10][1][204]|                Server dropped player:1 (last stak rx:3)                  |
[10][1][204]|                                                                          |
[10][1][204]+--------------------------------------------------------------------------+
[10][1][205]+--------------------------------------------------------------------------+
[10][1][205]|                                                                          |
[10][1][205]|                Server dropped player:1 (last stak rx:3)                  |
[10][1][205]|                                                                          |
[10][1][205]+--------------------------------------------------------------------------+


and what is even worse is that the client ends up in a weird limbo state

not single player, not client....


lets try to track this down:

made this change

void mwNetgame::server_proc_player_drop(void)
{
   if (mLoop.frame_num > 300) // don't even try until this far into the game
   {
      // check to see if we need to drop clients
      int drop_frame_limit = mLoop.frame_num - 200;

      for (int p=1; p<NUM_PLAYERS; p++)
         if ((mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE) && (mPlayer.loc[p].server_last_stak_rx_frame_num < drop_frame_limit))
         {
            mGameMoves.add_game_move(mLoop.frame_num + 4, PM_GAMEMOVE_TYPE_PLAYER_INACTIVE, p, 71); // make client inactive (reason no stak for x frames)
            mLog.add_headerf(LOG_NET, p, 1, "Server dropped player:%d (last stak rx:%d)", p, mPlayer.loc[p].server_last_stak_rx_frame_num);
         }
   }
}



now I want to fail properly on the client if it does trigger


new test:





rx stak p:1 ack:[545] cur:[547] dsync:[-29.6] chase:[40.4]
rx stak p:1 ack:[546] cur:[548] dsync:[-28.6] chase:[40.5]
rx stak p:1 ack:[547] cur:[549] dsync:[-28.7] chase:[40.5]
[10][0][549]+--------------------------------------------------------------------------+
[10][0][549]|                                                                          |
[10][0][549]|                             NEXT LEVEL:80                                |
[10][0][549]|                                                                          |
[10][0][549]+--------------------------------------------------------------------------+
logs/20240212-071555-[1][pmh].txt saved
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
rx stak p:1 ack:[-1] cur:[1] dsync:[1685.4] chase:[70.0]
rx stak p:1 ack:[-1] cur:[2] dsync:[3398.5] chase:[70.0]
rx stak p:1 ack:[-1] cur:[3] dsync:[5111.9] chase:[70.0]
rx stak p:1 ack:[-1] cur:[4] dsync:[5111.9] chase:[70.0]
rx stak p:1 ack:[-1] cur:[5] dsync:[5111.9] chase:[70.0]
rx stak p:1 ack:[-1] cur:[16] dsync:[-145.8] chase:[31.1]
rx stak p:1 ack:[-1] cur:[17] dsync:[-154.0] chase:[30.4]
rx stak p:1 ack:[-1] cur:[18] dsync:[-154.0] chase:[30.4]
rx stak p:1 ack:[12] cur:[19] dsync:[-159.7] chase:[30.0]
rx stak p:1 ack:[14] cur:[20] dsync:[-162.4] chase:[29.8]
rx stak p:1 ack:[15] cur:[21] dsync:[-161.3] chase:[29.9]





actually I think I am going about this all wrong!!!

the client is the one that initiates the LOST SERVER CONNECTION


I just did a test and the client quit immediately but the server did di do the drop until 10s later!!!




rx stak p:1 ack:[268] cur:[270] dsync:[-38.2] chase:[39.8]
rx stak p:1 ack:[269] cur:[271] dsync:[-39.3] chase:[39.7]
rx stak p:1 ack:[270] cur:[272] dsync:[-39.7] chase:[39.7]
rx stak p:1 ack:[271] cur:[273] dsync:[-39.5] chase:[39.7]
rx stak p:1 ack:[-1] cur:[1] dsync:[812.4] chase:[70.0]
rx stak p:1 ack:[-1] cur:[2] dsync:[812.4] chase:[70.0]
[10][0][274]+--------------------------------------------------------------------------+
[10][0][274]|                                                                          |
[10][0][274]|                             NEXT LEVEL:80                                |
[10][0][274]|                                                                          |
[10][0][274]+--------------------------------------------------------------------------+
logs/20240212-071905-[1][pmh].txt saved
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
rx stak p:1 ack:[-1] cur:[3] dsync:[812.4] chase:[70.0]
rx stak p:1 ack:[-1] cur:[4] dsync:[1663.5] chase:[70.0]
rx stak p:1 ack:[-1] cur:[5] dsync:[2513.4] chase:[70.0]
rx stak p:1 ack:[-1] cur:[6] dsync:[2513.4] chase:[70.0]
rx stak p:1 ack:[-1] cur:[7] dsync:[3356.0] chase:[70.0]
rx stak p:1 ack:[275] cur:[275] dsync:[4196.1] chase:[70.0]
[10][1][301]+--------------------------------------------------------------------------+
[10][1][301]|                                                                          |
[10][1][301]|                Server dropped player:1 (last stak rx:4)                  |
[10][1][301]|                                                                          |
[10][1][301]+--------------------------------------------------------------------------+
[10][1][302]+--------------------------------------------------------------------------+
[10][1][302]|                                                                          |
[10][1][302]|                Server dropped player:1 (last stak rx:4)                  |
[10][1][302]|                                                                          |
[10][1][302]+--------------------------------------------------------------------------+
[10][1][303]+--------------------------------------------------------------------------+
[10][1][303]|                                                                          |
[10][1][303]|                Server dropped player:1 (last stak rx:4)                  |
[10][1][303]|                                                                          |
[10][1][303]+--------------------------------------------------------------------------+
[10][1][304]+--------------------------------------------------------------------------+
[10][1][304]|                                                                          |
[10][1][304]|                Server dropped player:1 (last stak rx:4)                  |
[10][1][304]|                                                                          |
[10][1][304]+--------------------------------------------------------------------------+
[10][1][305]+--------------------------------------------------------------------------+
[10][1][305]|                                                                          |
[10][1][305]|                Server dropped player:1 (last stak rx:4)                  |
[10][1][305]|                                                                          |
[10][1][305]+--------------------------------------------------------------------------+
[10][1][305]+--------------------------------------------------------------------------+
[10][1][305]|        Player:1 became INACTIVE!                                         |
[10][1][305]+--------------------------------------------------------------------------+
[10][0][306]+--------------------------------------------------------------------------+
[10][0][306]|                                                                          |
[10][0][306]|               Headless Server with no clients! - Reload                  |
[10][0][306]|                                                                          |
[10][0][306]+--------------------------------------------------------------------------+
[10][0][316]+--------------------------------------------------------------------------+
[10][0][316]|                                                                          |
[10][0][316]|                              NEXT LEVEL:1                                |
[10][0][316]|                                                                          |
[10][0][316]+--------------------------------------------------------------------------+
logs/20240212-071913-[80][pmh].txt saved
saved:savegame/20240212-071913-[80]-autosave on level done.gm
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+


from the client, but did not die...

[27][1][1349]rx dif complete [1344 to 1347] - uncompressed
[27][1][1349]rx dif complete [1344 to 1348] - uncompressed
[33][1][1349]tx stak p:1 ack:[1348] cur:[1349]
[10][0][1349]+--------------------------------------------------------------------------+
[10][0][1349]|                                                                          |
[10][0][1349]|                             NEXT LEVEL:80                                |
[10][0][1349]|                                                                          |
[10][0][1349]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [1348 to 1349] - uncompressed
[33][1][1]tx stak p:1 ack:[-1] cur:[1]
[27][1][2]rx dif complete [1348 to 1350] - uncompressed
[33][1][2]tx stak p:1 ack:[-1] cur:[2]
[33][1][3]tx stak p:1 ack:[-1] cur:[3]
[27][1][4]rx dif complete [-1 to 2] - uncompressed
[27][1][6]rx dif complete [-1 to 3] - uncompressed
[27][1][7]rx dif complete [-1 to 4] - uncompressed
[27][1][9]rx dif complete [-1 to 5] - uncompressed
[27][1][11]rx dif complete [-1 to 6] - uncompressed
[27][1][13]rx dif complete [-1 to 7] - uncompressed
[27][1][14]rx dif complete [-1 to 8] - uncompressed
[27][1][15]rx dif complete [9 to 9] - uncompressed
[27][1][15]rx dif complete [9 to 10] - uncompressed


there is some concerning stuff here:

still receiving dif from last level...

why is client sending -1?



[33][1][411]tx stak p:1 ack:[408] cur:[411]
[27][1][412]rx dif complete [406 to 409] - uncompressed
[30][1][412]----- Apply dif [406 to 409] [applied] [rewound [3] frames]
[33][1][412]tx stak p:1 ack:[409] cur:[412]
[27][1][413]rx dif complete [407 to 410] - uncompressed
[30][1][413]----- Apply dif [407 to 410] [applied] [rewound [3] frames]
[33][1][413]tx stak p:1 ack:[410] cur:[413]
[10][0][413]+--------------------------------------------------------------------------+
[10][0][413]|                                                                          |
[10][0][413]|                             NEXT LEVEL:80                                |
[10][0][413]|                                                                          |
[10][0][413]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [408 to 412] - uncompressed
[27][1][1]rx dif complete [409 to 413] - uncompressed
[30][1][1]----- Apply dif [409 to 413] [33][1][1]tx stak p:1 ack:[-1] cur:[1]
[not applied] [base not found] - resending stak [-1]
[27][1][2]rx dif complete [410 to 414] - uncompressed
[30][1][2]----- Apply dif [410 to 414] [33][1][2]tx stak p:1 ack:[-1] cur:[2]
[not applied] [base not found] - resending stak [-1]
[30][1][3]----- Apply dif [410 to 414] [33][1][3]tx stak p:1 ack:[-1] cur:[3]
[not applied] [base not found] - resending stak [-1]
[30][1][4]----- Apply dif [410 to 414] [33][1][4]tx stak p:1 ack:[-1] cur:[4]
[not applied] [base not found] - resending stak [-1]
[30][1][5]----- Apply dif [410 to 414] [33][1][5]tx stak p:1 ack:[-1] cur:[5]
[not applied] [base not found] - resending stak [-1]
[27][1][6]rx dif complete [0 to 2] - uncompressed
[30][1][6]----- Apply dif [0 to 2] [applied] [rewound [4] frames]
[33][1][6]tx stak p:1 ack:[2] cur:[6]
[30][1][7]----- Apply dif [0 to 2] [not applied] [not newer than last dif applied]
[30][1][8]----- Apply dif [0 to 2] [not applied] [not newer than last dif applied]
[27][1][9]rx dif complete [-1 to 3] - uncompressed
[30][1][9]----- Apply dif [-1 to 3] [not applied] [dif not valid]
[27][1][10]rx dif complete [-1 to 4] - uncompressed
[30][1][10]----- Apply dif [-1 to 4] [not applied] [dif not valid]
[27][1][11]rx dif complete [2 to 5] - uncompressed
[30][1][11]----- Apply dif [2 to 5] [applied] [rewound [6] frames]
[33][1][11]tx stak p:1 ack:[5] cur:[11]
[27][1][12]rx dif complete [2 to 6] - uncompressed
[30][1][12]----- Apply dif [2 to 6] [applied] [rewound [6] frames]
[33][1][12]tx stak p:1 ack:[6] cur:[12]


changed order so stak gets sent after  [not applied]
ran again and captured a drop!


[27][1][72540]rx dif complete [72534 to 72537] - uncompressed
[30][1][72540]----- Apply dif [72534 to 72537] [applied] [rewound [3] frames]
[33][1][72540]tx stak p:1 ack:[72537] cur:[72540]
[27][1][72541]rx dif complete [72534 to 72538] - uncompressed
[30][1][72541]----- Apply dif [72534 to 72538] [applied] [rewound [3] frames]
[33][1][72541]tx stak p:1 ack:[72538] cur:[72541]
[10][0][72541]+--------------------------------------------------------------------------+
[10][0][72541]|                                                                          |
[10][0][72541]|                             NEXT LEVEL:80                                |
[10][0][72541]|                                                                          |
[10][0][72541]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [72534 to 72539] - uncompressed
[27][1][1]rx dif complete [72536 to 72540] - uncompressed
[30][1][1]----- Apply dif [72536 to 72540] [not applied] [base not found] - resending stak [-1]
[33][1][1]tx stak p:1 ack:[-1] cur:[1]
[30][1][2]----- Apply dif [72536 to 72540] [not applied] [base not found] - resending stak [-1]
[33][1][2]tx stak p:1 ack:[-1] cur:[2]
[27][1][3]rx dif complete [72538 to 72541] - uncompressed
[30][1][3]----- Apply dif [72538 to 72541] [not applied] [base not found] - resending stak [-1]
[33][1][3]tx stak p:1 ack:[-1] cur:[3]
[30][1][4]----- Apply dif [72538 to 72541] [not applied] [base not found] - resending stak [-1]
[33][1][4]tx stak p:1 ack:[-1] cur:[4]
[30][1][5]----- Apply dif [72538 to 72541] [not applied] [base not found] - resending stak [-1]
[33][1][5]tx stak p:1 ack:[-1] cur:[5]
[30][1][6]----- Apply dif [72538 to 72541] [not applied] [base not found] - resending stak [-1]
[33][1][6]tx stak p:1 ack:[-1] cur:[6]
[27][1][7]rx dif complete [0 to 72542] - uncompressed
[30][1][7]----- Apply dif [0 to 72542] [applied] [jumped ahead 72535 frames]
[33][1][72542]tx stak p:1 ack:[72542] cur:[72542]
[10][1][72542]+--------------------------------------------------------------------------+
[10][1][72542]|        Local Player Client 1 Lost Server Connection!                     |
[10][1][72542]|        last_stdf_rx:[7]                                                  |
[10][1][72542]+--------------------------------------------------------------------------+
[10][0][72542]+--------------------------------------------------------------------------+
[10][0][72542]|                    Shutting down the client network                      |
[10][0][72542]+--------------------------------------------------------------------------+
[10][0][72542]+--------------------------------------------------------------------------+
[10][0][72542]|                                                                          |
[10][0][72542]|                              NEXT LEVEL:1                                |
[10][0][72542]|                                                                          |
[10][0][72542]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+

I think I can see the problem:
client applied dif and jumped ahead 72535 frame

not sure what that means or how it happened, but it is wrong....


lets start simple:

after a new level when client gets dif and base does not match, it replies with stak -1
why -1, why not zero...



fixed to not send zero anymore




[33][1][72019]tx stak p:1 ack:[72016] cur:[72019]
[27][1][72020]rx dif complete [72015 to 72017] - uncompressed
[30][1][72020]----- Apply dif [72015 to 72017] [applied] [rewound [3] frames]
[33][1][72020]tx stak p:1 ack:[72017] cur:[72020]
[10][0][72020]+--------------------------------------------------------------------------+
[10][0][72020]|                                                                          |
[10][0][72020]|                             NEXT LEVEL:80                                |
[10][0][72020]|                                                                          |
[10][0][72020]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [72015 to 72018] - uncompressed
[30][1][1]----- Apply dif [72015 to 72018] [not applied] [no bases found] - resending stak [0]
[33][1][1]tx stak p:1 ack:[0] cur:[1]
[27][1][2]rx dif complete [72016 to 72019] - uncompressed
[27][1][2]rx dif complete [72016 to 72020] - uncompressed
[30][1][2]----- Apply dif [72016 to 72020] [not applied] [no bases found] - resending stak [0]
[33][1][2]tx stak p:1 ack:[0] cur:[2]
[27][1][3]rx dif complete [72017 to 72021] - uncompressed
[30][1][3]----- Apply dif [72017 to 72021] [not applied] [no bases found] - resending stak [0]
[33][1][3]tx stak p:1 ack:[0] cur:[3]

[30][1][4]----- Apply dif [72017 to 72021] [not applied] [no bases found] - resending stak [0]
[33][1][4]tx stak p:1 ack:[0] cur:[4]

[30][1][5]----- Apply dif [72017 to 72021] [not applied] [no bases found] - resending stak [0]
[33][1][5]tx stak p:1 ack:[0] cur:[5]

[27][1][6]rx dif complete [0 to 2] - uncompressed
[30][1][6]----- Apply dif [0 to 2] [applied] [rewound [4] frames]
[33][1][6]tx stak p:1 ack:[2] cur:[6]

[30][1][7]----- Apply dif [0 to 2] [not applied] [not newer than last dif applied]

[27][1][8]rx dif complete [0 to 3] - uncompressed
[30][1][8]----- Apply dif [0 to 3] [applied] [rewound [5] frames]
[33][1][8]tx stak p:1 ack:[3] cur:[8]

[27][1][9]rx dif complete [0 to 4] - uncompressed
[30][1][9]----- Apply dif [0 to 4] [applied] [rewound [5] frames]


I would love to have a way to get the server logs to the client, especially on headless server...
I can do that now but it requires actually looking on the server, finding the exact filename, then typing that into a scp command on the client

like this:


-rw-rw-r--  1 m m  1580 Feb 13 06:28 '20240213-062833-[80][pmh].txt'
-rw-rw-r--  1 m m  1426 Feb 13 06:29 '20240213-062952-[1][pmh].txt'
-rw-rw-r--  1 m m  1580 Feb 13 06:29 '20240213-062954-[80][pmh].txt'
-rw-rw-r--  1 m m  1437 Feb 13 06:56 '20240213-065619-[1][pmh].txt'
-rw-rw-r--  1 m m  1593 Feb 13 06:56 '20240213-065625-[80][pmh].txt'
m@pmh:~/dev/purple_martians/logs$


C:\pm>pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240213-065625-[80][pmh].txt c:\pm\logs
pscp: wildcard '20240213-065625-[80][pmh].txt' matched no files

this works:

C:\pm>pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240213* c:\pm\logs
20240213-003741-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%
20240213-065625-[80][pmh] | 1 kB |   1.6 kB/s | ETA: 00:00:00 | 100%
20240213-053743-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%
20240213-065619-[1][pmh]. | 1 kB |   1.4 kB/s | ETA: 00:00:00 | 100%
20240213-023742-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%
20240213-013742-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%
20240213-062952-[1][pmh]. | 1 kB |   1.4 kB/s | ETA: 00:00:00 | 100%
20240213-062833-[80][pmh] | 1 kB |   1.5 kB/s | ETA: 00:00:00 | 100%
20240213-062831-[1][pmh]. | 1 kB |   1.4 kB/s | ETA: 00:00:00 | 100%
20240213-062954-[80][pmh] | 1 kB |   1.5 kB/s | ETA: 00:00:00 | 100%
20240213-033742-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%
20240213-043742-[1][pmh]. | 1 kB |   1.3 kB/s | ETA: 00:00:00 | 100%

quotes either "" or '' do not help

the problem is the [] in the filename...this works:

C:\pm>pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240213-065625-*.txt c:\pm\logs
20240213-065625-[80][pmh] | 1 kB |   1.6 kB/s | ETA: 00:00:00 | 100%

pscp -ls -pw zaiden m@96.45.13.220:dev/purple_martians/logs
gets a listing of all files in dir...







20240213

I got one!

[10][0][10454]|        Purple Martians Version 7.24.240211.0                             |
[10][0][10454]|        Allegro Version: 5.2.8.1                                          |
[10][0][10454]|        Date and time: 2024-02-13  17:47:04                               |

client:


[27][1][10613]rx dif complete [10605 to 10608] - uncompressed
[27][1][10613]rx dif complete [10605 to 10609] - uncompressed
----- Apply dif [10605 to 10609] [applied] [rewound [4] frames]
[33][1][10613]tx stak p:1 ack:[10609] cur:[10613]
----- Apply dif [10605 to 10609] [not applied] [not newer than last dif applied]
[27][1][10615]rx dif complete [10606 to 10610] - uncompressed
----- Apply dif [10606 to 10610] [applied] [rewound [5] frames]
[33][1][10615]tx stak p:1 ack:[10610] cur:[10615]
[27][1][10616]rx dif complete [10609 to 10611] - uncompressed
[27][1][10616]rx dif complete [10609 to 10612] - uncompressed
----- Apply dif [10609 to 10612] [applied] [rewound [4] frames]
[33][1][10616]tx stak p:1 ack:[10612] cur:[10616]
[10][0][10616]+--------------------------------------------------------------------------+
[10][0][10616]|                                                                          |
[10][0][10616]|                             NEXT LEVEL:81                                |
[10][0][10616]|                                                                          |
[10][0][10616]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
----- Apply dif [-1 to -1] [not applied] [dif not valid]

[27][1][2]rx dif complete [10612 to 10614] - uncompressed
----- Apply dif [10612 to 10614] [not applied] [no bases found] - resending stak [0]
[33][1][2]tx stak p:1 ack:[0] cur:[2]
----- Apply dif [10612 to 10614] [not applied] [no bases found] - resending stak [0]
[33][1][3]tx stak p:1 ack:[0] cur:[3]

[27][1][4]rx dif complete [10612 to 10615] - uncompressed
----- Apply dif [10612 to 10615] [not applied] [no bases found] - resending stak [0]
[33][1][4]tx stak p:1 ack:[0] cur:[4]


[27][1][5]rx dif complete [10612 to 10616] - uncompressed
----- Apply dif [10612 to 10616] [not applied] [no bases found] - resending stak [0]
[33][1][5]tx stak p:1 ack:[0] cur:[5]
----- Apply dif [10612 to 10616] [not applied] [no bases found] - resending stak [0]
[33][1][6]tx stak p:1 ack:[0] cur:[6]
----- Apply dif [10612 to 10616] [not applied] [no bases found] - resending stak [0]
[33][1][7]tx stak p:1 ack:[0] cur:[7]
----- Apply dif [10612 to 10616] [not applied] [no bases found] - resending stak [0]
[33][1][8]tx stak p:1 ack:[0] cur:[8]
----- Apply dif [10612 to 10616] [not applied] [no bases found] - resending stak [0]
[33][1][9]tx stak p:1 ack:[0] cur:[9]


[27][1][10]rx dif complete [0 to 10617] - uncompressed
----- Apply dif [0 to 10617] [applied] [jumped ahead 10607 frames]
[33][1][10617]tx stak p:1 ack:[10617] cur:[10617]


[10][1][10617]+--------------------------------------------------------------------------+
[10][1][10617]|        Local Player Client 1 Lost Server Connection!                     |
[10][1][10617]|        last_stdf_rx:[10]                                                 |
[10][1][10617]+--------------------------------------------------------------------------+
[10][0][10617]+--------------------------------------------------------------------------+
[10][0][10617]|                    Shutting down the client network                      |
[10][0][10617]+--------------------------------------------------------------------------+
[10][0][10617]+--------------------------------------------------------------------------+
[10][0][10617]|                                                                          |
[10][0][10617]|                              NEXT LEVEL:1                                |
[10][0][10617]|                                                                          |
[10][0][10617]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+



server:


pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240213* c:\pm\logs

there are no good logs on the server

rx stak p:1 ack:[10606] cur:[10612] dsync:[-106.2] chase:[40.0]
rx stak p:1 ack:[10609] cur:[10613] dsync:[-106.9] chase:[39.9]
rx stak p:1 ack:[10610] cur:[10615] dsync:[-108.5] chase:[39.8]
rx stak p:1 ack:[10612] cur:[10616] dsync:[-106.6] chase:[39.9]
rx stak p:1 ack:[0] cur:[2] dsync:[33069.5] chase:[70.0]
rx stak p:1 ack:[0] cur:[3] dsync:[33069.5] chase:[70.0]
[10][0][10616]+--------------------------------------------------------------------------+
[10][0][10616]|                                                                          |
[10][0][10616]|                             NEXT LEVEL:81                                |
[10][0][10616]|                                                                          |
[10][0][10616]+--------------------------------------------------------------------------+
logs/20240213-174652-[1][pmh].txt saved
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
rx stak p:1 ack:[0] cur:[4] dsync:[66245.6] chase:[70.0]
rx stak p:1 ack:[0] cur:[5] dsync:[99418.1] chase:[70.0]
rx stak p:1 ack:[0] cur:[6] dsync:[132589.6] chase:[70.0]
rx stak p:1 ack:[0] cur:[7] dsync:[132589.6] chase:[70.0]
rx stak p:1 ack:[0] cur:[8] dsync:[165758.8] chase:[70.0]
rx stak p:1 ack:[0] cur:[9] dsync:[198921.4] chase:[70.0]
rx stak p:1 ack:[10617] cur:[10617] dsync:[232083.4] chase:[70.0]
[10][1][301]+--------------------------------------------------------------------------+
[10][1][301]|                                                                          |
[10][1][301]|                Server dropped player:1 (last stak rx:5)                  |
[10][1][301]|                                                                          |
[10][1][301]+--------------------------------------------------------------------------+



I will need to make better logging on the server....


but what can I tell from this occurrance?

from the client side...
level 81 started frame set to 0

still getting difs from the previous level, rejecting them for not having base, resending stak saying we have base 0

eventually gets a dif from previous level based on zero but far in the future

when it applies this, it jumps very far in the future, then client quits due to no dif recieved for a long time...

how can this be prevented?


add LOG_NET_stak and LOG_NET_stdf to headless server and try again...



tried many time in a row and would not fail

here is s successfull one:

client:

[33][1][2979]tx stak p:1 ack:[2978] cur:[2979]
[27][1][2980]rx dif complete [2977 to 2979] - uncompressed
----- Apply dif [2977 to 2979] [applied] [rewound [1] frames]
[33][1][2980]tx stak p:1 ack:[2979] cur:[2980]
[27][1][2981]rx dif complete [2978 to 2980] - uncompressed
----- Apply dif [2978 to 2980] [applied] [rewound [1] frames]
[33][1][2981]tx stak p:1 ack:[2980] cur:[2981]
[10][0][2981]+--------------------------------------------------------------------------+
[10][0][2981]|                                                                          |
[10][0][2981]|                             NEXT LEVEL:80                                |
[10][0][2981]|                                                                          |
[10][0][2981]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [2979 to 2981] - uncompressed
[27][1][1]rx dif complete [2980 to 2982] - uncompressed
----- Apply dif [2980 to 2982] [not applied] [no bases found] - resending stak [0]
[33][1][1]tx stak p:1 ack:[0] cur:[1]
----- Apply dif [2980 to 2982] [not applied] [no bases found] - resending stak [0]
[33][1][2]tx stak p:1 ack:[0] cur:[2]
----- Apply dif [2980 to 2982] [not applied] [no bases found] - resending stak [0]
[33][1][3]tx stak p:1 ack:[0] cur:[3]
[27][1][4]rx dif complete [0 to 2] - uncompressed
----- Apply dif [0 to 2] [applied] [rewound [2] frames]
[33][1][4]tx stak p:1 ack:[2] cur:[4]
[27][1][5]rx dif complete [0 to 3] - uncompressed
----- Apply dif [0 to 3] [applied] [rewound [2] frames]
[33][1][5]tx stak p:1 ack:[3] cur:[5]
----- Apply dif [0 to 3] [not applied] [not newer than last dif applied]
[27][1][7]rx dif complete [0 to 4] - uncompressed
----- Apply dif [0 to 4] [applied] [rewound [3] frames]
[33][1][7]tx stak p:1 ack:[4] cur:[7]
[27][1][8]rx dif complete [3 to 5] - uncompressed
----- Apply dif [3 to 5] [applied] [rewound [3] frames]
[33][1][8]tx stak p:1 ack:[5] cur:[8]
----- Apply dif [3 to 5] [not applied] [not newer than last dif applied]
[27][1][10]rx dif complete [4 to 6] - uncompressed
----- Apply dif [4 to 6] [applied] [rewound [4] frames]
[33][1][10]tx stak p:1 ack:[6] cur:[10]
[27][1][11]rx dif complete [5 to 7] - uncompressed

server:



[27][0][2978]stdf rewind [none]
[27][0][2978]stdf save state:2979
[27][1][2978]tx stdf p:1 [s:2977 d:2979] cmp:135 ratio:0.12 [1 packets needed]
[33][1][2979]rx stak p:1 ack:[2978] cur:[2979] dsync:[-24.6] chase:[40.5]
[27][0][2979]stdf rewind [none]
[27][0][2979]stdf save state:2980
[27][1][2979]tx stdf p:1 [s:2978 d:2980] cmp:135 ratio:0.12 [1 packets needed]
[33][1][2980]rx stak p:1 ack:[2979] cur:[2980] dsync:[-22.1] chase:[40.7]
[27][0][2980]stdf rewind [none]
[27][0][2980]stdf save state:2981
[27][1][2980]tx stdf p:1 [s:2979 d:2981] cmp:135 ratio:0.12 [1 packets needed]
[33][1][2981]rx stak p:1 ack:[2980] cur:[2981] dsync:[-21.8] chase:[40.8]
[27][0][2981]stdf rewind [none]
[27][0][2981]stdf save state:2982
[27][1][2981]tx stdf p:1 [s:2980 d:2982] cmp:138 ratio:0.12 [1 packets needed]
[10][0][2981]+--------------------------------------------------------------------------+
[10][0][2981]|                                                                          |
[10][0][2981]|                             NEXT LEVEL:80                                |
[10][0][2981]|                                                                          |
[10][0][2981]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 80 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][0][1]stdf save state:2
[27][1][1]tx stdf p:1 [s:0 d:2] cmp:1538 ratio:1.37 [2 packets needed]
[33][1][2]rx stak p:1 ack:[0] cur:[1] dsync:[9300.7] chase:[70.0]
[33][1][2]rx stak p:1 ack:[0] cur:[2] dsync:[9300.7] chase:[70.0]
[27][0][2]stdf rewind [none]
[27][0][2]stdf save state:3
[27][1][2]tx stdf p:1 [s:0 d:3] cmp:1539 ratio:1.37 [2 packets needed]
[33][1][3]rx stak p:1 ack:[0] cur:[3] dsync:[9300.7] chase:[70.0]
[27][0][3]stdf rewind [none]
[27][0][3]stdf save state:4
[27][1][3]tx stdf p:1 [s:0 d:4] cmp:1542 ratio:1.37 [2 packets needed]
[33][1][4]rx stak p:1 ack:[2] cur:[4] dsync:[9298.1] chase:[70.0]
[33][1][4]rx stak p:1 ack:[3] cur:[5] dsync:[9295.5] chase:[70.0]
[27][0][4]stdf rewind [none]
[27][0][4]stdf save state:5
[27][1][4]tx stdf p:1 [s:3 d:5] cmp:178 ratio:0.16 [1 packets needed]
[33][1][5]rx stak p:1 ack:[4] cur:[7] dsync:[9289.7] chase:[70.0]
[27][0][5]stdf rewind [none]
[27][0][5]stdf save state:6
[27][1][5]tx stdf p:1 [s:4 d:6] cmp:194 ratio:0.17 [1 packets needed]
[33][1][6]rx stak p:1 ack:[5] cur:[8] dsync:[9283.8] chase:[70.0]
[27][0][6]stdf rewind [none]
[27][0][6]stdf save state:7
[27][1][6]tx stdf p:1 [s:5 d:7] cmp:201 ratio:0.18 [1 packets needed]
[33][1][7]rx stak p:1 ack:[6] cur:[10] dsync:[9275.2] chase:[70.0]
[27][0][7]stdf rewind [none]
[27][0][7]stdf save state:8
[27][1][7]tx stdf p:1 [s:6 d:8] cmp:181 ratio:0.16 [1 packets needed]
[33][1][8]rx stak p:1 ack:[7] cur:[11] dsync:[9264.8] chase:[70.0]
[27][0][8]stdf rewind [none]
[27][0][8]stdf save state:9
[27][1][8]tx stdf p:1 [s:7 d:9] cmp:180 ratio:0.16 [1 packets needed]
[33][1][9]rx stak p:1 ack:[8] cur:[14] dsync:[9250.2] chase:[70.0]
[27][0][9]stdf rewind [none]
[27][0][9]stdf save state:10
[27][1][9]tx stdf p:1 [s:8 d:10] cmp:187 ratio:0.17 [1 packets needed]
[33][1][10]rx stak p:1 ack:[9] cur:[15] dsync:[-84.3] chase:[35.8]
[27][0][10]stdf rewind [none]
[27][0][10]stdf save state:11
[27][1][10]tx stdf p:1 [s:9 d:11] cmp:204 ratio:0.18 [1 packets needed]
[27][0][11]stdf rewind [none]
[27][0][11]stdf save state:12
[27][1][11]tx stdf p:1 [s:9 d:12] cmp:195 ratio:0.17 [1 packets needed]
[33][1][12]rx stak p:1 ack:[11] cur:[17] dsync:[-96.2] chase:[34.8]
[27][0][12]stdf rewind [none]
[27][0][12]stdf save state:13
[27][1][12]tx stdf p:1 [s:11 d:13] cmp:194 ratio:0.17 [1 packets needed]
[33][1][13]rx stak p:1 ack:[12] cur:[18] dsync:[-107.6] chase:[33.9]
[27][0][13]stdf rewind [none]
[27][0][13]stdf save state:14
[27][1][13]tx stdf p:1 [s:12 d:14] cmp:199 ratio:0.18 [1 packets needed]
[33][1][14]rx stak p:1 ack:[13] cur:[19] dsync:[-116.4] chase:[33.2]
[27][0][14]stdf rewind [none]
[27][0][14]stdf save state:15
[27][1][14]tx stdf p:1 [s:13 d:15] cmp:167 ratio:0.15 [1 packets needed]
[27][0][15]stdf rewind [none]
[27][0][15]stdf save state:16
[27][1][15]tx stdf p:1 [s:13 d:16] cmp:168 ratio:0.15 [1 packets needed]
[27][0][16]stdf rewind [none]
[27][0][16]stdf save state:17
[27][1][16]tx stdf p:1 [s:13 d:17] cmp:182 ratio:0.16 [1 packets needed]
[33][1][17]rx stak p:1 ack:[16] cur:[21] dsync:[-123.3] chase:[32.6]
[27][0][17]stdf rewind [none]
[27][0][17]stdf save state:18
[27][1][17]tx stdf p:1 [s:16 d:18] cmp:203 ratio:0.18 [1 packets needed]
[33][1][18]rx stak p:1 ack:[17] cur:[22] dsync:[-126.8] chase:[32.4]
[27][0][18]stdf rewind [none]
[27][0][18]stdf save state:19
[27][1][18]tx stdf p:1 [s:17 d:19] cmp:206 ratio:0.18 [1 packets needed]
[27][0][19]stdf rewind [none]
[27][0][19]stdf save state:20





lets try again to get a failed one:


could not do it...

what could prevent this?


when client tries to apply dif, could I test what level it is from?
I would need to add that info to the dif, and dif pieces


I could test if the dif I am applying is a lot in the future...
but I need to do this if joining late....


I could set the last dif rx...wait, don't I already do this?
maybe I could set, last dif applied frame number instead?

what I keep track of is:

mPlayer.loc[p].client_last_stdf_rx_frame_num = mLoop.frame_num;      // client keeps track of last stdf rx'd and quits if too long

this is the frame number before the jump!!

what if I change it to last dif applied frame number? (the destination)

I think that might just be the answer!!

I won't have to set the holdoff in the future anymore...

I think the rest of the stuff will sort itself out...

if I get late difs from previous level and jump way into the future...then what...it will fix itself?
probably not....difs after that will not be applied because thet are earlier....

so I still need a way to prevent late difs from a previous level...or have the client ignore them...

even if I add the level num to the dif, that would not prevent server reloading the same level...




20240214

I want to implement this:

what if I change it to last dif applied frame number? (the destination)

I just want a way to have the client ignore difs from the previous level

right now, this is the only way to detect that this bad behaviour is happening...

why is it not reproducible for long periods of time?


describe it simply

difs from the previous level are still arriving
they fail because of no matching base on the client
client sends stak of 0 to request dif from 0 and sometimes gets one, but still from old level
then the client applies that dif, does a huge jump into the future, then drops when testing last stdf rx frame

this must mean that the client is ahead of the server...
the client is looking for difs from the new level, but the server is still on the old level


I think this could be fixed with some kind of level identifier

each dif piece would need to have the same id


how do I do it now?

how does a dif piece know what level it is from?

soley by dest frame

   int seq     = mPacketBuffer.PacketGetByte(i);
   int max_seq = mPacketBuffer.PacketGetByte(i);
   int sb      = mPacketBuffer.PacketGetInt4(i);
   int sz      = mPacketBuffer.PacketGetInt4(i);

   mLog.addf(LOG_NET_stdf_packets, p, "rx stdf piece [%d of %d] [%d to %d] st:%4d sz:%4d\n", seq+1, max_seq, src, dst, sb, sz);
   mPlayer.loc[p].client_last_stdf_rx_frame_num = mLoop.frame_num;      // client keeps track of last stdf rx'd and quits if too long
   memcpy(client_state_buffer + sb, mPacketBuffer.rx_buf[i].data+22, sz);   // put the piece of data in the buffer

   client_state_buffer_pieces[seq] = dst;                     // mark it with destination mLoop.frame_num
   int complete = 1;                                          // did we just get the last packet? (yes by default)
   for (int i=0; i< max_seq; i++)
      if (client_state_buffer_pieces[i] != dst) complete = 0; // no, if any piece not at latest frame_num

   if (complete)
   {
      // uncompress client_state_buffer to dif
      uLongf destLen = sizeof(client_state_dif);
      uncompress((Bytef*)client_state_dif, (uLongf*)&destLen, (Bytef*)client_state_buffer, sizeof(client_state_buffer));


I only have 24 bytes for the header of my stdf packets
do I though?

what am I limiting my payload to 1024? do I need to
also what if I just made my 1000 piece slightly smaller?

what do I do with sfil?
I make a unique id...

That would not really work here, I don't care about the packets within the sequence, just the overall level they came from...


I could just simply use the level_num.
Then when applying dif on the client, if they come from a different level just completely ignore them...
The only problem with this is when a level is restarted...



What about when a client changes level...as soon as that happens ignore any more dif from the prev level, but how?



how about a flag on the client?
since starting a new level, have we received a valid dif?





I got a hit!!!!

[27][1][56153]rx dif complete [56148 to 56150] - uncompressed
----- Apply dif [56148 to 56150] [applied] [rewound [3] frames]
[33][1][56153]tx stak p:1 ack:[56150] cur:[56153]
[27][1][56154]rx dif complete [56149 to 56151] - uncompressed
----- Apply dif [56149 to 56151] [applied] [rewound [3] frames]
[33][1][56154]tx stak p:1 ack:[56151] cur:[56154]
[27][1][56155]rx dif complete [56149 to 56152] - uncompressed
----- Apply dif [56149 to 56152] [applied] [rewound [3] frames]
[33][1][56155]tx stak p:1 ack:[56152] cur:[56155]
[27][1][56156]rx dif complete [56151 to 56153] - uncompressed
----- Apply dif [56151 to 56153] [applied] [rewound [3] frames]
[33][1][56156]tx stak p:1 ack:[56153] cur:[56156]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
----- Apply dif [56151 to 56153] [not applied] [not newer than last dif applied]
[10][0][56191]+--------------------------------------------------------------------------+
[10][0][56191]|                                                                          |
[10][0][56191]|                             NEXT LEVEL:81                                |
[10][0][56191]|                                                                          |
[10][0][56191]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
----- Apply dif [-1 to -1] [not applied] [dif not valid]
[27][1][9]rx dif complete [56152 to 56154] - uncompressed
[27][1][9]rx dif complete [56152 to 56155] - uncompressed
[27][1][9]rx dif complete [56152 to 56156] - uncompressed
[27][1][9]rx dif complete [56152 to 56157] - uncompressed
[27][1][9]rx dif complete [56152 to 56158] - uncompressed
[27][1][9]rx dif complete [56152 to 56159] - uncompressed
[27][1][9]rx dif complete [0 to 56160] - uncompressed
[27][1][9]rx dif complete [0 to 56161] - uncompressed
[27][1][9]rx dif complete [0 to 56162] - uncompressed
----- Apply dif [0 to 56162] [applied] [jumped ahead 56153 frames]
[33][1][56162]tx stak p:1 ack:[56162] cur:[56162]
[10][1][56162]+--------------------------------------------------------------------------+
[10][1][56162]|        Local Player Client 1 Lost Server Connection!                     |
[10][1][56162]|        last_stdf_rx:[9]                                                  |
[10][1][56162]+--------------------------------------------------------------------------+
[10][0][56162]+--------------------------------------------------------------------------+
[10][0][56162]|                    Shutting down the client network                      |
[10][0][56162]+--------------------------------------------------------------------------+
[10][0][56162]+--------------------------------------------------------------------------+
[10][0][56162]|                                                                          |
[10][0][56162]|                              NEXT LEVEL:1                                |
[10][0][56162]|                                                                          |
[10][0][56162]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+

C:\pm>


pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240215-17* c:\pm\logs

pscp -ls -pw zaiden m@96.45.13.220:dev/purple_martians/logs













20240216 2010

I GOT ONE!!


----- Apply dif [204 to 207] [applied] [rewound [4] frames]
[33][1][211]tx stak p:1 ack:[207] cur:[211]
----- Apply dif [204 to 207] [not applied] [not newer than last dif applied]
[10][0][212]+--------------------------------------------------------------------------+
[10][0][212]|                                                                          |
[10][0][212]|                             NEXT LEVEL:81                                |
[10][0][212]|                                                                          |
[10][0][212]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [205 to 208] - uncompressed
----- Apply dif [205 to 208] [not applied] [no bases found] - resending stak [0]
[33][1][1]tx stak p:1 ack:[0] cur:[1]
[27][1][2]rx dif complete [207 to 209] - uncompressed
----- Apply dif [207 to 209] [not applied] [no bases found] - resending stak [0]
[33][1][2]tx stak p:1 ack:[0] cur:[2]
[27][1][3]rx dif complete [207 to 210] - uncompressed
----- Apply dif [207 to 210] [not applied] [no bases found] - resending stak [0]
[33][1][3]tx stak p:1 ack:[0] cur:[3]
[27][1][4]rx dif complete [207 to 211] - uncompressed
----- Apply dif [207 to 211] [not applied] [no bases found] - resending stak [0]
[33][1][4]tx stak p:1 ack:[0] cur:[4]
----- Apply dif [207 to 211] [not applied] [no bases found] - resending stak [0]
[33][1][5]tx stak p:1 ack:[0] cur:[5]
----- Apply dif [207 to 211] [not applied] [no bases found] - resending stak [0]
[33][1][6]tx stak p:1 ack:[0] cur:[6]
[27][1][7]rx dif complete [0 to 212] - uncompressed
----- Apply dif [0 to 212] [applied] [jumped ahead 205 frames]
[33][1][212]tx stak p:1 ack:[212] cur:[212]
[10][1][212]+--------------------------------------------------------------------------+
[10][1][212]|        Local Player Client 1 Lost Server Connection!                     |
[10][1][212]|        last_stdf_rx:[7]                                                  |
[10][1][212]+--------------------------------------------------------------------------+
[10][0][212]+--------------------------------------------------------------------------+
[10][0][212]|                                                                          |
[10][0][212]|                             NEXT LEVEL:81                                |
[10][0][212]|                                                                          |
[10][0][212]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[27][1][1]rx dif complete [0 to 213] - uncompressed
[27][1][1]rx dif complete [0 to 2] - uncompressed
[27][1][1]rx dif complete [0 to 3] - uncompressed
[27][1][1]rx dif complete [0 to 4] - uncompressed
[27][1][1]rx dif complete [0 to 5] - uncompressed
[27][1][1]rx dif complete [0 to 6] - uncompressed
[27][1][1]rx dif complete [0 to 7] - uncompressed
[27][1][1]rx dif complete [0 to 8] - uncompressed
[27][1][1]rx dif complete [0 to 9] - uncompressed
[27][1][1]rx dif complete [0 to 10] - uncompressed
[27][1][1]rx dif complete [0 to 11] - uncompressed
[27][1][1]rx dif complete [0 to 12] - uncompressed
[27][1][1]rx dif complete [0 to 13] - uncompressed
[27][1][1]rx dif complete [0 to 14] - uncompressed
[27][1][1]rx dif complete [0 to 15] - uncompressed
[27][1][1]rx dif complete [0 to 16] - uncompressed
[27][1][1]rx dif complete [0 to 17] - uncompressed
[27][1][1]rx dif complete [0 to 18] - uncompressed
[27][1][1]rx dif complete [0 to 19] - uncompressed
[27][1][1]rx dif complete [0 to 20] - uncompressed
[27][1][1]rx dif complete [0 to 21] - uncompressed
[27][1][1]rx dif complete [0 to 22] - uncompressed
[27][1][1]rx dif complete [0 to 23] - uncompressed
[27][1][1]rx dif complete [0 to 24] - uncompressed
----- Apply dif [0 to 24] [applied] [jumped ahead 23 frames]
[33][1][24]tx stak p:1 ack:[24] cur:[24]
[27][1][25]rx dif complete [0 to 291] - uncompressed
----- Apply dif [0 to 291] [applied] [jumped ahead 266 frames]
[33][1][291]tx stak p:1 ack:[291] cur:[291]
[10][1][291]+--------------------------------------------------------------------------+
[10][1][291]|        Local Player Client 1 Lost Server Connection!                     |
[10][1][291]|        last_stdf_rx:[25]                                                 |
[10][1][291]+--------------------------------------------------------------------------+
[10][0][291]+--------------------------------------------------------------------------+
[10][0][291]|                    Shutting down the client network                      |
[10][0][291]+--------------------------------------------------------------------------+
[10][0][291]+--------------------------------------------------------------------------+
[10][0][291]|                                                                          |
[10][0][291]|                              NEXT LEVEL:1                                |
[10][0][291]|                                                                          |
[10][0][291]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+

C:\pm>


pscp -pw zaiden m@96.45.13.220:dev/purple_martians/logs/20240216-200* c:\pm\logs



[27][0][205]stdf rewind [none]
[27][0][205]stdf save state:206
[27][1][205]tx stdf p:1 [s:203 d:206] cmp:136 ratio:0.12 [1 packets needed]
[33][1][206]rx stak p:1 ack:[204] cur:[209] dsync:[-111.6] chase:[40.4]
[27][0][206]stdf rewind [none]
[27][0][206]stdf save state:207
[27][1][206]tx stdf p:1 [s:204 d:207] cmp:136 ratio:0.12 [1 packets needed]
[33][1][207]rx stak p:1 ack:[205] cur:[210] dsync:[-112.6] chase:[40.3]
[27][0][207]stdf rewind [none]
[27][0][207]stdf save state:208
[27][1][207]tx stdf p:1 [s:205 d:208] cmp:136 ratio:0.12 [1 packets needed]
[33][1][208]rx stak p:1 ack:[207] cur:[211] dsync:[-108.4] chase:[40.6]
[27][0][208]stdf rewind [none]
[27][0][208]stdf save state:209
[27][1][208]tx stdf p:1 [s:207 d:209] cmp:135 ratio:0.12 [1 packets needed]
[27][0][209]stdf rewind [none]
[27][0][209]stdf save state:210
[27][1][209]tx stdf p:1 [s:207 d:210] cmp:136 ratio:0.12 [1 packets needed]
[27][0][210]stdf rewind [none]
[27][0][210]stdf save state:211
[27][1][210]tx stdf p:1 [s:207 d:211] cmp:136 ratio:0.12 [1 packets needed]
[33][1][211]rx stak p:1 ack:[0] cur:[1] dsync:[552.6] chase:[70.0]
[33][1][211]rx stak p:1 ack:[0] cur:[2] dsync:[1214.9] chase:[70.0]
[27][0][211]stdf rewind [none]
[27][0][211]stdf save state:212
[27][1][211]tx stdf p:1 [s:0 d:212] cmp:3346 ratio:2.98 [4 packets needed]
[33][1][212]rx stak p:1 ack:[0] cur:[3] dsync:[1877.9] chase:[70.0]
[33][1][212]rx stak p:1 ack:[0] cur:[4] dsync:[2540.0] chase:[70.0]
[27][0][212]stdf rewind [none]
[27][0][212]stdf save state:213
[27][1][212]tx stdf p:1 [s:0 d:213] cmp:3344 ratio:2.98 [4 packets needed]
[10][0][212]+--------------------------------------------------------------------------+
[10][0][212]|                                                                          |
[10][0][212]|                             NEXT LEVEL:81                                |
[10][0][212]|                                                                          |
[10][0][212]+--------------------------------------------------------------------------+

new file....

[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 81 STARTED                              |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[33][1][1]rx stak p:1 ack:[0] cur:[5] dsync:[2540.0] chase:[70.0]
[33][1][1]rx stak p:1 ack:[0] cur:[6] dsync:[3198.2] chase:[70.0]
[27][0][1]stdf save state:2
[27][1][1]tx stdf p:1 [s:0 d:2] cmp:2221 ratio:1.98 [3 packets needed]
[33][1][2]rx stak p:1 ack:[212] cur:[212] dsync:[3854.6] chase:[70.0]
[27][0][2]stdf rewind [none]
[27][0][2]stdf save state:3
[27][1][2]tx stdf p:1 [s:0 d:3] cmp:2235 ratio:1.99 [3 packets needed]
[27][0][3]stdf rewind [none]
[27][0][3]stdf save state:4
[27][1][3]tx stdf p:1 [s:0 d:4] cmp:2236 ratio:1.99 [3 packets needed]
[27][0][4]stdf rewind [none]
[27][0][4]stdf save state:5
[27][1][4]tx stdf p:1 [s:0 d:5] cmp:2271 ratio:2.02 [3 packets needed]
[27][0][5]stdf rewind [none]
[27][0][5]stdf save state:6
[27][1][5]tx stdf p:1 [s:0 d:6] cmp:2271 ratio:2.02 [3 packets needed]
[27][0][6]stdf rewind [none]
[27][0][6]stdf save state:7
[27][1][6]tx stdf p:1 [s:0 d:7] cmp:2274 ratio:2.02 [3 packets needed]
[27][0][7]stdf rewind [none]
[27][0][7]stdf save state:8
[27][1][7]tx stdf p:1 [s:0 d:8] cmp:2273 ratio:2.02 [3 packets needed]
[27][0][8]stdf rewind [none]
[27][0][8]stdf save state:9
[27][1][8]tx stdf p:1 [s:0 d:9] cmp:2270 ratio:2.02 [3 packets needed]
[27][0][9]stdf rewind [none]
[27][0][9]stdf save state:10
[27][1][9]tx stdf p:1 [s:0 d:10] cmp:2268 ratio:2.02 [3 packets needed]
[27][0][10]stdf rewind [none]

skip...all the same

[27][0][492]stdf save state:493
[27][1][492]tx stdf p:1 [s:0 d:493] cmp:2252 ratio:2.00 [3 packets needed]
[27][0][493]stdf rewind [none]
[27][0][493]stdf save state:494
[27][1][493]tx stdf p:1 [s:0 d:494] cmp:2251 ratio:2.00 [3 packets needed]
[27][0][494]stdf rewind [none]
[27][0][494]stdf save state:495
[27][1][494]tx stdf p:1 [s:0 d:495] cmp:2252 ratio:2.00 [3 packets needed]
[27][0][495]stdf rewind [none]
[10][1][495]+--------------------------------------------------------------------------+
[10][1][495]|                                                                          |
[10][1][495]|               Server dropped player:1 (last stak rx:294)                 |
[10][1][495]|                                                                          |
[10][1][495]+--------------------------------------------------------------------------+
[27][0][495]stdf save state:496
[27][1][495]tx stdf p:1 [s:0 d:496] cmp:2253 ratio:2.00 [3 packets needed]
[27][0][496]stdf rewind [none]
[10][1][496]+--------------------------------------------------------------------------+
[10][1][496]|                                                                          |
[10][1][496]|               Server dropped player:1 (last stak rx:294)                 |
[10][1][496]|                                                                          |
[10][1][496]+--------------------------------------------------------------------------+
[27][0][496]stdf save state:497
[27][1][496]tx stdf p:1 [s:0 d:497] cmp:2252 ratio:2.00 [3 packets needed]
[27][0][497]stdf rewind [none]
[10][1][497]+--------------------------------------------------------------------------+
[10][1][497]|                                                                          |
[10][1][497]|               Server dropped player:1 (last stak rx:294)                 |
[10][1][497]|                                                                          |
[10][1][497]+--------------------------------------------------------------------------+
[27][0][497]stdf save state:498
[27][1][497]tx stdf p:1 [s:0 d:498] cmp:2254 ratio:2.01 [3 packets needed]
[27][0][498]stdf rewind [none]
[10][1][498]+--------------------------------------------------------------------------+
[10][1][498]|                                                                          |
[10][1][498]|               Server dropped player:1 (last stak rx:294)                 |
[10][1][498]|                                                                          |
[10][1][498]+--------------------------------------------------------------------------+
[27][0][498]stdf save state:499
[27][1][498]tx stdf p:1 [s:0 d:499] cmp:2253 ratio:2.00 [3 packets needed]
[27][0][499]stdf rewind [none]
[10][1][499]+--------------------------------------------------------------------------+
[10][1][499]|                                                                          |
[10][1][499]|               Server dropped player:1 (last stak rx:294)                 |
[10][1][499]|                                                                          |
[10][1][499]+--------------------------------------------------------------------------+
[10][1][499]+--------------------------------------------------------------------------+
[10][1][499]|        Player:1 became INACTIVE!                                         |
[10][1][499]+--------------------------------------------------------------------------+
[27][0][499]stdf save state:500
[27][0][500]stdf rewind [none]
[10][0][500]+--------------------------------------------------------------------------+
[10][0][500]|                                                                          |
[10][0][500]|               Headless Server with no clients! - Reload                  |
[10][0][500]|                                                                          |
[10][0][500]+--------------------------------------------------------------------------+
[27][0][500]stdf save state:501
[27][0][501]stdf rewind [none]
[27][0][501]stdf save state:502
[27][0][502]stdf rewind [none]
[27][0][502]stdf save state:503
[27][0][503]stdf rewind [none]
[27][0][503]stdf save state:504
[27][0][504]stdf rewind [none]
[27][0][504]stdf save state:505
[27][0][505]stdf rewind [none]
[27][0][505]stdf save state:506
[27][0][506]stdf rewind [none]
[27][0][506]stdf save state:507
[27][0][507]stdf rewind [none]
[27][0][507]stdf save state:508
[27][0][508]stdf rewind [none]
[27][0][508]stdf save state:509
[27][0][509]stdf rewind [none]
[27][0][509]stdf save state:510
[27][0][510]stdf rewind [none]
[27][0][510]stdf save state:511
[10][0][510]+--------------------------------------------------------------------------+
[10][0][510]|                                                                          |
[10][0][510]|                              NEXT LEVEL:1                                |
[10][0][510]|                                                                          |
[10][0][510]+--------------------------------------------------------------------------+
p


I don't really see much difference now that I have the server log...
wait...I see that the client is sending stak from the next level before the server has changed levels
or more precisely, the server is rx stak from the client






20240217

I think I want to redo some core aspects of netgame

server will still drop client if it doesnt get a stak reply after a certain time
this is what I want to happen.

client will respond to every dif sent??
why?

client needs a way to tell how long it has been since it successfully applied a dif

if client receives a dif in the far future, should it just blindly apply it?

then if a client receives one in the past should it blindly apply that also?


I think I want to change the last stdf rx to lat stdf applied frame number

change it when you get one way in the future and also one in the past


-------------------
what if server had a level seq number
everytime a new level was started it was incremented
server would send this with dif

client would not try to apply dif unless that matched

flesh it out:

make it an 8 bit unsigned int, it doesn't matter if it rolls over
do this only so it can be sent as a byte with the stdf packet

add server_level_seq to psyn
only for server player 0
set to 0 when server started
increment whenever a level changes

add this to the dif meta data

on client do not apply dif if it does not match

that sounds like something that would work...


added to syn:
   int server_lev_seq_num;

set when server started:
mPlayer.syn[0].server_lev_seq_num = 0;

level done server section:
if (++mPlayer.syn[0].server_lev_seq_num > 255) mPlayer.syn[0].server_lev_seq_num = 0;


server send stdf packet
      char data[1024] = {0}; int pos;
      mPacketBuffer.PacketName(data, pos, "stdf");
      mPacketBuffer.PacketPutInt4(data, pos, src);
      mPacketBuffer.PacketPutInt4(data, pos, dst);
      mPacketBuffer.PacketPutByte(data, pos, packet_num);
      mPacketBuffer.PacketPutByte(data, pos, num_packets);
      mPacketBuffer.PacketPutByte(data, pos, mPlayer.syn[0].server_lev_seq_num);
      mPacketBuffer.PacketPutInt4(data, pos, start_byte);
      mPacketBuffer.PacketPutInt4(data, pos, packet_data_size);


void mwNetgame::client_proc_stdf_packet(int i)
{
   int p       = mPlayer.active_local_player;
   int src     = mPacketBuffer.PacketGetInt4(i);
   int dst     = mPacketBuffer.PacketGetInt4(i);
   int seq     = mPacketBuffer.PacketGetByte(i);
   int max_seq = mPacketBuffer.PacketGetByte(i);
   int sls     = mPacketBuffer.PacketGetByte(i); // server level sequence num
   int sb      = mPacketBuffer.PacketGetInt4(i);
   int sz      = mPacketBuffer.PacketGetInt4(i);


I might also have to make client zero for initial connection

or send as part of join....

void mwNetgame::server_send_sjon_packet(int who, int level, int frame, int player_num, int player_color)
{
   char data[1024] = {0}; int pos;
   mPacketBuffer.PacketName(data, pos, "sjon");
   mPacketBuffer.PacketPutInt4(data, pos, level);
   mPacketBuffer.PacketPutInt4(data, pos, frame);
   mPacketBuffer.PacketPutByte(data, pos, player_num);
   mPacketBuffer.PacketPutByte(data, pos, player_color);
   mPacketBuffer.PacketPutByte(data, pos, mPlayer.syn[0].server_lev_seq_num);
   ServerSendTo(data, pos, who);
}

OK this seems to work

test out on remote server



it is a chicken and egg thing

server has changed seq, but client has not....

how exactly do I do that anyway?

try this:

      if (mNetgame.ima_client)
      {
         mNetgame.ClientFlush();
         mLog.log_ending_stats_client(LOG_NET_ending_stats, mPlayer.active_local_player);
         if (++mPlayer.syn[0].server_lev_seq_num > 255) mPlayer.syn[0].server_lev_seq_num = 0;
      }
      if (mNetgame.ima_server)
      {
         mNetgame.ServerFlush();
         mLog.log_ending_stats_server(LOG_NET_ending_stats);
         if (++mPlayer.syn[0].server_lev_seq_num > 255) mPlayer.syn[0].server_lev_seq_num = 0;
      }





this seems to work, but when I reload level in rc, it never goes back to the overworld
levels just increment after that....

what happens when reload is called:

server limits always calls reload like this:
if (reload) server_reload(1); // to overworld

this is how the other call happens:
if (type == PM_RCTL_PACKET_TYPE_server_reload) server_reload((int)val);


this code here in exit could be better

if (mLevel.prev_level_loaded == 1) mPlayer.syn[0].level_done_next_level = 1;                   // if started from overworld, return there
else mPlayer.syn[0].level_done_next_level = mLevel.get_next_level(mLevel.play_level, 199, 1);  // otherwise do next chron level


how about, if in story mode instead

if (!mMain.classic_mode) mPlayer.syn[0].level_done_next_level = 1;                             // in story mode all exits return to overworld
else mPlayer.syn[0].level_done_next_level = mLevel.get_next_level(mLevel.play_level, 199, 1);  // otherwise do next chron level

this should work..tested and it seems to work...


now what?

I still want to change the way a client quits



old...

void mwNetgame::client_proc_stdf_packet(int i)
{
   int p       = mPlayer.active_local_player;
   int src     = mPacketBuffer.PacketGetInt4(i);
   int dst     = mPacketBuffer.PacketGetInt4(i);
   int seq     = mPacketBuffer.PacketGetByte(i);
   int max_seq = mPacketBuffer.PacketGetByte(i);
   int sls     = mPacketBuffer.PacketGetByte(i); // server level sequence num
   int sb      = mPacketBuffer.PacketGetInt4(i);
   int sz      = mPacketBuffer.PacketGetInt4(i);

   if (sls != mPlayer.syn[0].server_lev_seq_num) printf("stdf from wrong seq! rx:%d should be:%d\n", sls, mPlayer.syn[0].server_lev_seq_num);
   else
   {

      mLog.addf(LOG_NET_stdf_packets, p, "rx stdf piece [%d of %d] [%d to %d] st:%4d sz:%4d\n", seq+1, max_seq, src, dst, sb, sz);
      mPlayer.loc[p].client_last_stdf_rx_frame_num = mLoop.frame_num;      // client keeps track of last stdf rx'd and quits if too long



client_last_stdf_rx_frame_num

new:

mPlayer.loc[p].client_last_dif_applied_frame_num

frame number saved when dif applied

checked just like it used to be...

this seems to work and is simpler

now what?


should I do a test of clients and see if I can get them to drop?

If all this works I want to clean up the details...

I am having weird issues....

make sure all are at the latest version....


I think I am having the same issues I was having months ago...
when I put too much data, too many packets, I get a real degraded service...like 600-700ms ping


when it happens i get constant base resets
700,000 B/s


I have server running in lab 96.45.13.220
home network 96.45.15.155

1 rc
4 c
level 6


idle:
ping 30-50
160 kB/s
204 p/s

fakekey:
ping 30-50
190-200 kB/s
300-400 p/s

full stupid: (after 1-2 minutes)
ping 900-1000
800 kB/s
880 p/s

try again with only 2 clients and 1 rc
dropped 2 clients
now:
ping: 30-50
90 kB/s
122 p/s
ran for well over 10 minutes with no issue


do I have any weird QOS shit on my router? qos is disabled

add one more client:

one would not connect but the other did:
now:
ping: 30-50
120 kB/s
203 p/s
this has run for a while and seems stable....


can't add another, 4230jj will not connect, yet it can ping the server
I can see the connection attempt on the server but 4230jj times out waiting for a reply...

i tried to reload current level and all clients died...could be when server tried to send a huge gm file to each client

a 3.8M file with 40minutes of 3-4 player fakekey...

that would require how many 1K payloads?   3,800,000M / 1000 = 3,800 packets....


You know, I could work on this program forever...but I want to finish...


I should put a size limit in file transfer...

lets say 200 packets is the limit, I could send files up to 200K with that....

Finish up the recent changes...
sjon and ssln..should be done

make a new release....

when a brand new client connects to server on the client all levels are locked
how hard would this be to fix?
the problem is that there is only one copy of the level locks, the local copy....

how about in netgame mode, all are unlocked
right now if server has locked what happens? It looks the same on the client
but both c and s can enter locked levels
done...



bug...key bindings should only be in player 0....
they only affect the local player
there will never be time when any other than 0 are needed
I think I have it done



bug - wont run on scat anymore
missing GLIBC_2.35, GLIBC_2.33 GLIBC_2.34
it used to run great on scat, maybe it was the recent updates....

its because I built the release on 22.04 (pmh) and I an trying to run it on 20.04 (scat)
what a bunch of bullshit!!!!

u20 2.31
u22 2.35

what if I built it on scat?

what the hell else does it not work on?

I can build on 2.31 u20 and it seems to work on newer, but not the other way around...




headless server, how do I make it save logs...
I can't quit with CTRL-C in the terminal or kill the process...the log will not get saved
I have to make a level done happen, (or reload level?...yes)


sometimes weird artifacts show in level background, like msg from previous level??
have not seen this happen for a long time


I want some way to show off all the multiplayer demos...
put the other folder in demo and call it multiplayer tas..done
tas escape rocket not all purple coins??..fixed

Where do I have the IP hard coded into the game?
config? yes






new release 240217.2

running 7P + 1R
lev 83

170 kbps
320 pps
ran 12 min with no bad thing happening

lev 83 is kind of a simple level
dif size 400-500

lets try a complex level...

lev 17

lost jj
now have 6P + 1R

dif size 1800-2400

430 kbps
500 pps

then I lost mint
disbaled screen lock and got them both back


now:

530-580 kbps
640-660 pps
1800-2100 dif size

it seems stable

some of the clients have large cpu usage


server did a segfault trying to copy file

logs/20240218-082950-[17][pmh].txt saved
saved:savegame/20240218-082950-[17]-autosave on level done.gm
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 1 STARTED                               |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
starting file transfer [savegame/20240218-082950-[17]-autosave on level done.gm]
Segmentation fault (core dumped)
m@pmh:~/dev/purple_martians$
moved the size check from send to add to array...should be fixed


I ran a LAN game and the sync was always -140 wtf???
I did it again and they seem to work fine now...







20240228

Have the server log information about client sessions

how? a separate log?
when they connect is easy but when they disconnect is not

should I build it into the server?

add something like connection to connection less UDP?

what about server end stats? that is close to what I want


I want to know:
- when someone attempts to connect
- when someone connects
- how long the session is
- how many keys pressed
- when they disconnect and why
- how many level done
- how many level done that they cause


How about when a connection attempt is made a file gets saved.
YYYYMMDDHHMMSS_IP:PORT

and some kind of unique identifier that netgame keeps track of


netgame keep an array of these


when connection is made an entry is created
then every frame after that is is checked
if it goes away then the record is logged

what do I call these?

connections? sessions? client_sessions?

client_sessions

what to save?

timestamp...what format...

can I use an integer?

   char filename[256];
   struct tm *timenow;
   time_t now = time(NULL);
   timenow = localtime(&now);
   strftime(filename, sizeof(filename), "logs/%Y%m%d-%H%M%S", timenow);


I suppose I could just use a timestamp like this as the start

then use the other al_time for duration like I always do...


al_get_time
double al_get_time(void)
Return the number of seconds since the Allegro library was initialised. The return value is undefined if Allegro is uninitialised. The resolution depends on the used driver, but typically can be in the order of microseconds.

that seems too complicated...I really want to just save seconds since epoch for both
but now that seem complicated....

I want to save it in a way that I can easily sort and print later


how about a long string:

YYYYMMDDHHMMSS_IP_PORT


what is the max size it could be:

YYYYMMDDHHMMSS_xxx.xxx.xxx.xxx_123456789 (41 char)

lets go with 64 char

int active;
int who;

char session_name[64];
char host_name[16];

double start_time;
double end_time;
double duration;

int controls_pressed;
int levels_done;
int levels_done_by_this player;
int enemies killed;
int deaths;



next:

when connection attempt is made

in server listen when rx 1234 and reply with 5678

add a new entry to the list

at this point we have:

ip address
who (ClientNum)
timestamp

what if I add a status int to the struct

I suppose I could use active...no

status
1 = rx 1234 and sent 5678
2 = rx cjon

10 = server full
4 = client quit
5 = client dropped by server


I want a fucntion that scans this list every frame to check status, etc.....why, what will it do?

detects that the player associated with a session is not active any more
detects that a session never went from status 1 to status 2 after a period of time


void mwNetgame::server_check_client_sessions(void)
called from void mwNetgame::server_control()

so it run every frame

iterates all active sessions
this is the only place that removes active sessions
when it does that, it creates a log entry

now what?

I am worried that the log entries will not get saved if the server quits unexpectedly

right now they do not get saved unless the player goes inactive

what would fix this?

I could have a unique filename and save and resave

save at the end of every level done

make a way of telling if we detected an definite end vs abort...

1st remove : from session_name when added
2nd use session_name as filename
3rd the actual saving was easy, i do not check if the file exists already, i just overwrite....

now I want some more details in the file, like if it has a definite end


status
1 = rx 1234 and sent 5678
2 = rx cjon

10 = server full
20 = server did not receive cjon from client after 10s

30 = player became inactive
40 = server quit

50 = server dropped
lets see if I can detect when server drops client
I went down a real rabbit hole here about quit reason
server adds game move player inactive and reason 71
but I don't think anything uses that...
found another way to do it...

now I want to save all active when next level

I think I have all that done, now I need to test it

it looks like it is working...

levels done gets counted even with gates

levels done by this player gates are not counted...NBD

now what?

shots fired..needs to be counted at level done

removed the code in game move player inactive loc server rmt client inactive
where the player struct got initialized...
this was messing with the stuff I wanted to keep track of...
I'm sure that I initialize before I use them again...yes when rx cjon and setting up new player...

what else do I want to add?

total bytes rx and tx

avg tx_kbps and rx_kbps

max in 1s

max in 1 frame

avg ping?

dammit...all these are not synced to server...but the server keeps track also does it not? yes!!!

BYTES TRANSMITTED
%d Total
%d avg per sec
%d Max per frame

BYTES RECEIVED
%d Total
%d avg per sec
%d Max per frame



Adding Log Entry for Session Index:0 - Filename:logs/session/20240218185329_192.168.1.109_24785.txt
Filename:logs/session/20240218185329_192.168.1.109_24785.txt
Host Name:e6430
Player Num:1
Duration:9.4s
Next Levels:1
Exits Activated:0
cdat's Received:82
Respawns:0
Shots Fired:15
Enemy Hits:0
Player Hits:0
Self Hits:0
Purple Coins:0
TX Total Bytes:117583
TX Total Packets:386
RX Total Bytes:20260
RX Total Packets:456
TX Max Bytes/Frame:3460
RX Max Bytes/Frame:108
TX Max Packets/Frame:4
RX Max Packets/Frame:4
Active:0
Status:30 - Player became inactive

what next...avg ping??

move this to MiscFnx

mItem.chrms(mDemoMode.last_frame, msg));

also make one to display k and m for bytes
done...


finish session logs...what is left?

avg_ping..no easy way to do that

make bandwidth look nice..done
make DateStamp, IP, Port on line by themselves...done

make optional
were...just dont save?
for the calls throughout the code:
if (mLog.log_types[LOG_NET_session].action) session_check_active();
and do print optional...done

make session logs always on for headless server..done

speed control save in config or reset with program start
make sure that server does not do anything but 40!!!

changed it so that locking frame speed in settings forces the speed to 40

now make it so that starting server forces 40 as well and client...done

make the reset with program start optional...


what are the options?

now matter what always revert to 40 on program start (read from config)

checkbox reset speed to default on program start...
only show if unlocked default if checked

only when unchecked and unlocked is speed saved in config
done....



make optional
server sending gm to client

added to game moves:
int server_send_gm_to_clients = 1;
save in config
add to settings
force on for headless server
all done...


what gm folders are used for demo...meh
use just the demo that contains TAS...done



are log files saved with single quotes around them?
not session but regular logs...

tested on windows and I don't see quotes

I think I have figured it out:

the quotes are because bash needs to escape or quote [ and ]

total 188
drwxr-xr-x  3 m m  4096 Feb 19 12:43  ./
drwxrwxrwx 16 m m  4096 Feb 19 11:41  ../
-rw-rw-r--  1 m m  8543 Feb 19 11:49 '20240219-114905-[1][pmh].txt'
-rw-rw-r--  1 m m  7932 Feb 19 11:53 '20240219-115338-[17][pmh].txt'
-rw-rw-r--  1 m m  4601 Feb 19 11:53 '20240219-115359-[17][pmh].txt'
-rw-rw-r--  1 m m 42446 Feb 19 12:05 '20240219-120523-[6][pmh].txt'
-rw-rw-r--  1 m m  1137 Feb 19 12:05 '20240219-120524-[1][pmh].txt'
-rw-rw-r--  1 m m 22500 Feb 19 12:17 '20240219-121731-[17][pmh].txt'
-rw-rw-r--  1 m m   876 Feb 19 12:17 '20240219-121731-[1][pmh].txt'
-rw-rw-r--  1 m m  2483 Feb 19 12:17 '20240219-121752-[17][pmh].txt'
-rw-rw-r--  1 m m 66357 Feb 19 12:43 '20240219-124319-[30][pmh].txt'
drwxr-xr-x  2 m m  4096 Feb 19 11:49  session/
m@pmh:~/dev/purple_martians/logs$ cp 20240219-124319-\[30\]\[pmh\].txt test.txt
m@pmh:~/dev/purple_martians/logs$ ll
total 256
drwxr-xr-x  3 m m  4096 Feb 19 13:03  ./
drwxrwxrwx 16 m m  4096 Feb 19 11:41  ../
-rw-rw-r--  1 m m  8543 Feb 19 11:49 '20240219-114905-[1][pmh].txt'
-rw-rw-r--  1 m m  7932 Feb 19 11:53 '20240219-115338-[17][pmh].txt'
-rw-rw-r--  1 m m  4601 Feb 19 11:53 '20240219-115359-[17][pmh].txt'
-rw-rw-r--  1 m m 42446 Feb 19 12:05 '20240219-120523-[6][pmh].txt'
-rw-rw-r--  1 m m  1137 Feb 19 12:05 '20240219-120524-[1][pmh].txt'
-rw-rw-r--  1 m m 22500 Feb 19 12:17 '20240219-121731-[17][pmh].txt'
-rw-rw-r--  1 m m   876 Feb 19 12:17 '20240219-121731-[1][pmh].txt'
-rw-rw-r--  1 m m  2483 Feb 19 12:17 '20240219-121752-[17][pmh].txt'
-rw-rw-r--  1 m m 66357 Feb 19 12:43 '20240219-124319-[30][pmh].txt'
drwxr-xr-x  2 m m  4096 Feb 19 11:49  session/
-rw-rw-r--  1 m m 66357 Feb 19 13:03  test.txt
m@pmh:~/dev/purple_martians/logs$ cp 20240219-124319-\[30\]\[pmh\].txt test[123].txt
m@pmh:~/dev/purple_martians/logs$ ll
total 324
drwxr-xr-x  3 m m  4096 Feb 19 13:03  ./
drwxrwxrwx 16 m m  4096 Feb 19 11:41  ../
-rw-rw-r--  1 m m  8543 Feb 19 11:49 '20240219-114905-[1][pmh].txt'
-rw-rw-r--  1 m m  7932 Feb 19 11:53 '20240219-115338-[17][pmh].txt'
-rw-rw-r--  1 m m  4601 Feb 19 11:53 '20240219-115359-[17][pmh].txt'
-rw-rw-r--  1 m m 42446 Feb 19 12:05 '20240219-120523-[6][pmh].txt'
-rw-rw-r--  1 m m  1137 Feb 19 12:05 '20240219-120524-[1][pmh].txt'
-rw-rw-r--  1 m m 22500 Feb 19 12:17 '20240219-121731-[17][pmh].txt'
-rw-rw-r--  1 m m   876 Feb 19 12:17 '20240219-121731-[1][pmh].txt'
-rw-rw-r--  1 m m  2483 Feb 19 12:17 '20240219-121752-[17][pmh].txt'
-rw-rw-r--  1 m m 66357 Feb 19 12:43 '20240219-124319-[30][pmh].txt'
drwxr-xr-x  2 m m  4096 Feb 19 11:49  session/
-rw-rw-r--  1 m m 66357 Feb 19 13:03 'test[123].txt'
-rw-rw-r--  1 m m 66357 Feb 19 13:03  test.txt
m@pmh:~/dev/purple_martians/logs$























server did a segfault, but clients keep going???
need to investigate....seems good now, maybe speed was off?
clients all quit with lost server connection

rc did not...

when server quit, client all switched to 'Please Wait For Server Synchronization'
then after a timeout went to 'LOST SERVER CONNECTION'


question? is there still a chase and lock thing?
i don't think so...
when server rx cjon, it immediately makes the player active

this code is what is doing it:

void mwScreen::draw_client_debug_overlay(int &cx, int &cy)
{
   if (!mPlayer.syn[p].active)
   {
      rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2-32, mPlayer.syn[p].color, 2, 1, "Please wait for server syncronization");
      rtextout_centref(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2,    mPlayer.syn[p].color, 4, 1, "[%2.1f]", abs(mNetgame.client_chase_offset - mPlayer.loc[p].pdsync)*1000);
   }

it is not need and I will remove it...


but then the question is: player is being made inactive, but client does not catch this?


follow it through...

server quits, just like every other player it enters an inactive game move


removed these commented lines, just like above, client is not inactive and waiting


void mwPlayer::proc_player_input(void)
{
   if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
   {
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         if (syn[p].active) // cycle all active players
         {
            int cm = syn[p].control_method;
            if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) || (cm == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL) || (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)) // these are the only local control methods
            {
               set_comp_move_from_player_key_check(p);

               // fakekey mode
               if ((loc[p].fake_keypress_mode) || (syn[0].server_force_fakekey))
               {
                  // even in fakekey mode allow ESC or menu
                  if ((!mInput.key[loc[p].menu_key][0]) && (!mInput.key[ALLEGRO_KEY_ESCAPE][0])) loc[p].comp_move = rand() % 64;
               }


               if (loc[p].comp_move != comp_move_from_players_current_controls(p))   // player's controls have changed
               {
                  mGameMoves.add_game_move(mLoop.frame_num, PM_GAMEMOVE_TYPE_PLAYER_MOVE, p, loc[p].comp_move); // add to game moves array

                  // in client mode, also send cdat packet, and apply move directly to controls
                  if (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)
                  {
                     mNetgame.client_send_cdat_packet(p);
                     set_controls_from_comp_move(p, loc[p].comp_move);
                     if (syn[p].menu) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_PREEXIT1; // menu key pressed
                  }
               }
            }
         }
//         else if (syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL) // client waiting for server to make it active
//         {
//            if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT; // give them an escape option
//         }
      }
   }
}


then server sends this to all clients


      if (mNetgame.ima_server)
      {
         if (p == 0) // server quitting
         {
            // first set all connected clients to inactive
            for (int p=1; p<NUM_PLAYERS; p++)
               if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE)
               {
                  mPlayer.syn[p].control_method = PM_PLAYER_CONTROL_METHOD_CLIENT_THAT_SERVER_QUIT_ON; // what does this even do?
                  add_game_move2(frame + 10, PM_GAMEMOVE_TYPE_PLAYER_INACTIVE, p, 64);
               }





There is a bit of a mess between when inactive game moves are added and inactive game moves are executed

Are they both trying to set quit_reasons??

Reason is part of the game move and should be set when entered...

When executed it should just be copied to player struct

done and game exit is much simpler..incomplete but who cares?




trace what happens when client loses server connection

it should go back to menu, not keep playing

this is good:
start client from cmd
stop server nicely
client 'server ended game'
press and and quit to cmd

start client from menu
stop server nicely
client 'server ended game'
press and and quit to menu



start client from cmd
stop server badly
client 'lost server'
press and and quit to cmd

start client from menu
stop server badly
client 'lost server'
press and and quit to menu

all these worked well...client was in classic mode and level was overworld

m36 as sh

fixed the state it was setting from MENU to CLIENT_EXIT

void mwNetgame::client_proc_player_drop(void)
{
   int p = mPlayer.active_local_player;
   if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_THAT_SERVER_QUIT_ON)
   {
      mPlayer.loc[p].quit_reason = PM_PLAYER_QUIT_REASON_SERVER_ENDED_GAME;
      mLog.log_ending_stats_client(LOG_NET_ending_stats, p);
      mScreen.rtextout_centre(mFont.bltn, NULL, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, 10, -2, 1, "SERVER ENDED GAME!");
      al_flip_display();
      mInput.tsw();
      mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT;
   }





update the copyright date on the web pages
and in the help screens
done





demo mode does not stop sound when done
discovered from settings demo choose and run single
there are 5 places that demo can be run from:
gate on overworld
(in this case the overworld level needs to be reloaded and run after)
single from menu
single from settings
single from cmd (prompt)
single from cmd (file)
these all are working good now.....



is there something screwy about demo 37 ending?
the file looks fine...is it because there is a respawn?

I recorded a new one and it is the same

why??


what about it makes it not get the exit


tested on level 2, when death occurs in a demo playback the end is messed up...


do I only have one level where that happens ever?




81 training level 2
has a death but no weirdness at the end
death at 8s
level done at 53s


37 sacrifice
has a death at 5s
level done at 13.3
then a few seconds later the player spawns at the start block and touches the exit again

does that a few times

what does the death pause code look like?

I don't see anything weird there

void mwPlayer::proc_player_health(int p)
{
   if (syn[p].health < 1)
   {
      syn[p].health = 0;

      if (!mLoop.ff_state)
      {
         mGameEvent.add(8, 0, 0, p, 0, 0, 0);  // player death
         mLog.add_headerf(LOG_NET, p, 0, "PLAYER:%d DIED!", p);
         mLevel.level_data_player_respawns++;
         syn[p].stat_respawns++;
      }

      mScreen.set_player_text_overlay(p, 3);

      loc[p].health_display = 200;
      syn[p].paused = 100;
      syn[p].paused_type = 1;
   }
}


void mwPlayer::proc_player_paused(int p)
{
   if (syn[p].paused_type == 1) // frozen after player dies, until the timer runs out
   {
      syn[p].carry_item = 0;
      if (--syn[p].paused > 0)
      {
         // shrink player
         syn[p].draw_scale -= 0.25;
         if (syn[p].draw_scale < 0) syn[p].draw_scale = 0;

         // rotate player
         if (syn[p].left_right) syn[p].draw_rot += 5;
         else                   syn[p].draw_rot -= 5;
      }
      else // frozen done
      {
         syn[p].paused = 0;
         syn[p].old_health = 100;
         syn[p].health = 100;
         syn[p].left_xinc = 0;
         syn[p].right_xinc = 0;
         syn[p].xinc = 0;
         syn[p].yinc = 0;
         set_player_start_pos(p);
      }
   }
}



OK then, where else can I look?
what does the end of 81 look like?
last_move 2117
level_done 2136
no ack....

level 37

level_done 634
ack at 633
wtf? that doesn't sound right

removed that and it works!!!!

lets look at the test level37 i created...
level done 671
ack at 927

removed the game moves after level done and it works fine now...


maybe that is my issue...
i don't look for input after level done, so why do I have game moves after that?

does this also apply to levels that don't have deaths?
it looks like it does...

why does recording demo's do that?
should i run a sanitizer before saving level?



maybe I should make sure that any levels I have do not have game moves after level done....



GDT lev:[ 2] ----
GDT lev:[ 3] ----
GDT lev:[ 4] ----
GDT lev:[ 5] ----
GDT lev:[ 6] ----
GDT lev:[ 7] ----
GDT lev:[ 8] ----
GDT lev:[ 9] ----
GDT lev:[10] ----
GDT lev:[11] ----
GDT lev:[12] ----
GDT lev:[13] ---- level not done 11248 is done, why not show in demo???
GDT lev:[14] ----
GDT lev:[15] ----
GDT lev:[16] ----
GDT lev:[17] ----
GDT lev:[18] ----
GDT lev:[19] ----
GDT lev:[20] ----
GDT lev:[21] ----
GDT lev:[22] ----
GDT lev:[23] ----
GDT lev:[24] ----
GDT lev:[25] ----
GDT lev:[26] ----
GDT lev:[27] ----
GDT lev:[28] ----
GDT lev:[29] ----
GDT lev:[30] ----
GDT lev:[31] ----
GDT lev:[32] ----
GDT lev:[33] ----
GDT lev:[34] ----
GDT lev:[35] ----
GDT lev:[37] ----
GDT lev:[38] ----
GDT lev:[39] ----
GDT lev:[40] ----
GDT lev:[41] ----
GDT lev:[42] ---- ack (ld 14974)
GDT lev:[43] ----
GDT lev:[44] ----
GDT lev:[45] ----
GDT lev:[46] ----
GDT lev:[47] ----
GDT lev:[48] ----
GDT lev:[49] ---- ack
GDT lev:[50] ----
GDT lev:[51] ----
GDT lev:[52] ----
GDT lev:[53] ----
GDT lev:[54] ----
GDT lev:[55] ----
GDT lev:[56] ----
GDT lev:[57] ----
GDT lev:[64] ----
GDT lev:[80] ----
GDT lev:[81] ----
GDT lev:[82] ----
GDT lev:[83] ----
GDT lev:[84] ----
GDT lev:[85] ----
GDT lev:[86] ----
GDT lev:[87] ----
GDT lev:[88] ----
GDT lev:[89] ----
GDT lev:[90] ----
GDT lev:[91] ----
GDT lev:[92] ----
GDT lev:[93] ----
GDT lev:[94] ----
GDT lev:[95] ----
GDT lev:[96] ----
GDT lev:[97] ----
GDT lev:[98] ---- works fine

Error opening file:C:\pm\savegame\demo\TAS
GDT lev:[98] ---- level not done


GDT lev:[ 4] ----
GDT lev:[ 5] ----
GDT lev:[ 6] ----
GDT lev:[ 8] ----
GDT lev:[ 9] ----
GDT lev:[10] ----
GDT lev:[11] ---- ack
GDT lev:[12] ----
GDT lev:[13] ----
GDT lev:[16] ----
GDT lev:[17] ----
GDT lev:[18] ----
GDT lev:[19] ----
GDT lev:[23] ----
GDT lev:[29] ----
GDT lev:[30] ----
GDT lev:[31] ----
GDT lev:[32] ----
GDT lev:[41] ----
GDT lev:[64] ---- ack


level 49


6289 lf:6381 ldm:0 ldf:0
6290 lf:6381 ldm:0 ldf:0
6291 lf:6381 ldm:0 ldf:0
6292 lf:6381 ldm:0 ldf:0
6293 lf:6381 ldm:9 ldf:6292
6294 lf:6381 ldm:8 ldf:6292
6295 lf:6381 ldm:8 ldf:6292
6296 lf:6381 ldm:8 ldf:6292
6297 lf:6381 ldm:8 ldf:6292
6298 lf:6381 ldm:8 ldf:6292
6299 lf:6381 ldm:8 ldf:6292
6300 lf:6381 ldm:8 ldf:6292
6301 lf:6381 ldm:8 ldf:6292
6302 lf:6381 ldm:8 ldf:6292
6303 lf:6381 ldm:8 ldf:6292
6304 lf:6381 ldm:8 ldf:6292
6305 lf:6381 ldm:8 ldf:6292
6306 lf:6381 ldm:8 ldf:6292
6307 lf:6381 ldm:8 ldf:6292
6360 lf:6381 ldm:7 ldf:6292
6361 lf:6381 ldm:7 ldf:6292
6362 lf:6381 ldm:7 ldf:6292
6363 lf:6381 ldm:7 ldf:6292
6364 lf:6381 ldm:7 ldf:6292
6365 lf:6381 ldm:7 ldf:6292
6366 lf:6381 ldm:7 ldf:6292
6367 lf:6381 ldm:7 ldf:6292
6368 lf:6381 ldm:7 ldf:6292
6369 lf:6381 ldm:7 ldf:6292
6370 lf:6381 ldm:7 ldf:6292
6371 lf:6381 ldm:7 ldf:6292
6372 lf:6381 ldm:7 ldf:6292
6373 lf:6381 ldm:7 ldf:6292
6374 lf:6381 ldm:6 ldf:6292
6375 lf:6381 ldm:5 ldf:6292
6376 lf:6381 ldm:4 ldf:6292
6377 lf:6381 ldm:3 ldf:6292
6378 lf:6381 ldm:2 ldf:6292
6379 lf:6381 ldm:2 ldf:6292
6380 lf:6381 ldm:2 ldf:6292
6381 lf:6381 ldm:2 ldf:6292
6382 lf:6381 ldm:2 ldf:6292
6383 lf:6381 ldm:2 ldf:6292
6384 lf:6381 ldm:2 ldf:6292
6385 lf:6381 ldm:2 ldf:6292
6386 lf:6381 ldm:2 ldf:6292
6387 lf:6381 ldm:2 ldf:6292
6388 lf:6381 ldm:1 ldf:6292
6389 lf:6381 ldm:0 ldf:6292
6390 lf:6381 ldm:0 ldf:6292
6391 lf:6381 ldm:0 ldf:6292
6392 lf:6381 ldm:0 ldf:6292
6393 lf:6381 ldm:0 ldf:6292
6394 lf:6381 ldm:0 ldf:6292
6395 lf:6381 ldm:0 ldf:6292

found the fix

added: if (mPlayer.syn[0].level_done_mode == 1) mode = 0;

void mwDemoMode::run_loop(int ti, int tf, int restore_level)
{
   mScreen.transition_cutscene(ti, tf); // initial to final (game)
   while (mode)
   {
      mEventQueue.proc(1);
      if (mEventQueue.program_update)
      {
         mEventQueue.program_update = 0;
         mDisplay.proc_scale_factor_change();
         mLoop.frame_num++;


         if (mPlayer.syn[0].level_done_mode)
         {
            if (mPlayer.syn[0].level_done_mode == 1) mode = 0;
            if (mLoop.frame_num > mPlayer.syn[0].level_done_frame + 280) mode = 0; // 280 frames past level done (80) for seek and 5s more
         }
         else if (mLoop.frame_num > last_frame + 400) mode = 0; // 10s past last game move


what was happening was the keypress after level done made level_done get to zero before that test could pass

fix level 49 and 42 remove all after level_done..done
how about TAS 11 and 64...done


all is looking good...why does 13 not show done in demo_record and other places yet play fine??

GDT lev:[13] ---- level not done 11248 is done, why not show in demo???


last move is 11049


11248
11049
-----
  199

the problem was in the function:

increased...
if (mLoop.frame_num > mDemoMode.last_frame + 400) done = 1;



void mwDemoRecord::find_level_done(void)
{
   level_done_frame = 0;
   level_done_player = -1;

   seek_to_frame(0, 0);

   mLoop.ff_state = 1;
   int done = 0;
   while (!done)
   {
      mLoop.frame_num++;
      mGameMoves.proc();
      mLoop.move_frame();
      if (mPlayer.syn[0].level_done_mode)
      {
         level_done_frame  = mPlayer.syn[0].level_done_frame;
         level_done_player = mPlayer.syn[0].level_done_player;
         done = 1;
      }
      if (mLoop.frame_num > mDemoMode.last_frame + 400) done = 1;
   }
   mLoop.ff_state = 0;
}
this is all done

20240220 I will need to make new release....done

should I make a new youtube channel just for purple martians?
https://www.youtube.com/channel/UCSUTVur0deQa5_eYUhGjQlw
yes...it is done...
now make a goddamn video!



just curious?
what happens in a netgame if demo is tried to start from gate?
on server it starts...I will need to disable this
disable the demo page if client or server...done

down held on gate prevents multiple triggering, work great but not in netgame...

its because down_held is saved in item...

could I save it in player struct?

not trivially

what if i set controls by incrementing value, instead of just on off...

if on,  inc
if off, set to 0

tests would all be the same

except now I could test for 1 meaning just pressed...

look into this...

itsa not that easy....
that state is not really saved...it is pulled from game moves

what if I made each player keep the last cmp_move

then I could test current comp move against old_comp move and I could tell if a control has just been pressed



where should I do this? not in player controls...maybe in get stuff from game_moves
I will need a variable old_cmp_move...does it need to be syn or loc?

why am I doing this?

I want to be able to see if controls are held, just like with keys and mouse buttons

I don't want to do it by actually reading the keys, but by the controls set from game moves array

It will need to be on a per player basis, so it will need to be in the player struct...

If there are other things that need to tell if a key in held, they can use this also



---------------


here is what I am thinking:

proc_player_input - rename it to something to reflect that it only does local player input

proc_game_moves_array - sets players controls from game moves array

            // ------------------------------
            // process player input
            // ------------------------------
            mPlayer.proc_player_input();

            // ------------------------------
            // process game games array
            // ------------------------------
            mGameMoves.proc();

i was thinking of storing something like cmp_move and old_cmp_move for each player, but based on the actual game move controls, not the keys pressed


- add 4 more ints to player syn...
- use 2 of them, for ctrl_bitf and old_ctrl_bitf
- set them every frame in proc game moves (or after) for every player


test like this:

if ((ctrl_bits && PM_COMPMOVE_DOWN) && (!(old_ctrl_bit && PM_COMPMOVE_DOWN)))

i could even have a shortcut function

bool is_ctrl_just_pressed(int p, int ctrl)


what do I have to do to increase state_size? just do it?

new size:
#define STATE_SIZE 112480

// a bitfield of the 6 controls
int ctrl_bitf;
int old_ctrl_bitf;


added at the end of gamemove proc

   // at this point all the players' controls are set for the frame
   // save them in bitf
   for (int p=0; p<NUM_PLAYERS; p++)
      if (mPlayer.syn[p].active)
      {
         mPlayer.syn[p].old_ctrl_bitf = mPlayer.syn[p].ctrl_bitf; // move current to old
         mPlayer.syn[p].ctrl_bitf = mPlayer.comp_move_from_players_current_controls(p); // get new
      }




bool mwPlayer::if_players_ctrl_just_pressed(int p, int ctrl)
{
   if ((syn[p].ctrl_bitf & ctrl) && (!(syn[p].old_ctrl_bitf & ctrl))) return true;
   else return false;
}


test

if (mPlayer.if_players_ctrl_just_pressed(0, PM_COMPMOVE_UP)) printf("UP JUST PRESSED\n");


try to use for down on gate

old:

   if (mPlayer.syn[p].down)
   {
      if (!item[i][8])   // if down not held
      {
         if (++mLevel.display_page > 5) mLevel.display_page = 0;
      }
      item[i][8] = 1;    // set down held
   }
   else item[i][8] = 0;  // set down not held


new:

if (mPlayer.if_players_ctrl_just_pressed(p, PM_COMPMOVE_DOWN)) if (++mLevel.display_page > 5) mLevel.display_page = 0;

why are we using not synced level_display page?

mLevel.display_page

why don't we use the old item[i][8] from gate?

this now works perfectly!!!


now lets see if I can replace fire_held


this is all of it...


   if (mPlayer.syn[p].fire)
   {
      if (mPlayer.syn[p].fire_held == 0) // fire button pressed, but not held
      {
         mPlayer.syn[p].fire_held = 1;
         if (mPlayer.syn[p].shot_wait_counter < 1 )
         {
            mPlayer.syn[p].stat_shots_fired++;

            int b = find_empty_pshot();
            if (b != -1)
            {
               mShot.p[b].active = mLoop.frame_num;
               mShot.p[b].player = p;
               mShot.p[b].x = x;
               mShot.p[b].y = y + 1;
               mShot.p[b].xinc = 0;
               mShot.p[b].yinc = 0;

               if (mPlayer.syn[p].left_right) mShot.p[b].x = x+4;
               else mShot.p[b].x = x-3;

               if      (mPlayer.syn[p].up)    mShot.p[b].yinc = -bs;
               else if (mPlayer.syn[p].down)  mShot.p[b].yinc =  bs;
               else                           mShot.p[b].xinc = (mPlayer.syn[p].left_right*bs*2) - bs;

               // if this line is not here player cannot shoot breakable blocks when directly in front of them (when facing right/left??
               if ((!mPlayer.syn[p].up) && (!mPlayer.syn[p].down) && (mPlayer.syn[p].left_right)) mShot.p[b].x -=1;

               // initial move
               mShot.p[b].x += mShot.p[b].xinc;  // xinc
               mShot.p[b].y += mShot.p[b].yinc;  // yinc

               mPlayer.syn[p].shot_wait_counter = mPlayer.syn[p].shot_wait;
               mPlayer.syn[p].fire_held = 1;

               mGameEvent.add(1, x, y, p, b, 0, 0);
            }
            //else printf("player shot array full!\n");
         }
      }
   }
   else mPlayer.syn[p].fire_held = 0;  // fire is not pressed


this is done as well....
fire_held has been removed

is there anything else that gets toggled?

door keep track of when key is held, but I don't think that would work here...


test all levels after these changes
wendy does not work...why?

i dunno? everything else does, that's weird.....
did a bunch of tests, it is only that level...fixed it with a few added shots
back to exactly the same time as before...all level tests good

20240221 making a new release...

bug - the gate pages flicker badly sometimes in between pages - why


I have some weird bugs...

check size of state...that looks right
112480

both speeds look good, both are on the same version

is something weird going on?

like what?


packet exchange?

where do I need to change things when I change that size??
I thought it was just STATE_SIZE...

maybe something else different is going on...





test...get prev version

version 0220.1 works perfectly m36 to e6430
version 0221.1 works perfectly m36 to e6430

so why do I have issues with my dev setup??


e6430 version 0221.1 STATE_SIZE 112480
m36   version 0221.1 STATE_SIZE 112480


now it seems to work with any issues WTF!!
m36 dev to pm_client24

pages between server and client are weird, beacuse they might have different status between them
what if server sets a higher page then client?

fixed by making all have status 2 (complete) if status is less than that (0 locked and 1 ready)
this way the pages will always be the same between server and client
seems to be working properly

test with headless server...

new version first...


20240222 making a new release...



client quit, server keeps trying to drop it every frame
added active check in player drop...that looks better...
also server keeps trying to send difs...added active check there too...


looking through server code I found server_lock_client...it is called but I don't think it does anything

removed:

void mwNetgame::server_proc_stak_packet(int i)
{
...
   // inactive client chasing for lock
   if ((!mPlayer.syn[p].active) && (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE)) server_lock_client(p);
void server_lock_client(int p);

void mwNetgame::server_lock_client(int p)
{
   // inactive client chasing for lock
   float sync = mPlayer.loc[p].pdsync * 1000;
   printf("Server Lock Client:%d a:%d cm:%d dsync:%4.2f\n", p, mPlayer.syn[p].active, mPlayer.syn[p].control_method, sync);
   if ((sync > -200) && (sync < 30)) mPlayer.loc[p].sync_stabilization_holdoff++;
   else mPlayer.loc[p].sync_stabilization_holdoff = 0;
   if (mPlayer.loc[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
   {
      mGameMoves.add_game_move(mLoop.frame_num + 4, PM_GAMEMOVE_TYPE_PLAYER_ACTIVE, p, mPlayer.syn[p].color);
      mPlayer.loc[p].sync_stabilization_holdoff = 0;
      mLog.add_headerf(LOG_NET, p, 0, "Player:%d has locked and will become active in 4 frames!", p);
   }
}

also changed this:

old:

void mwNetgame::server_proc_cjon_packet(int i)
{
...

   // find empty player slot
   int cn = 99;
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((mPlayer.syn[p].active == 0) && (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER))
      {
         cn = p;
         break;
      }

new:

void mwNetgame::server_proc_cjon_packet(int i)
{
...

   // find empty player slot
   int cn = 99;
   for (int p=1; p<NUM_PLAYERS; p++)
      if (!mPlayer.syn[p].active)
      {
         cn = p;
         break;
      }



the gate pages still do not work nicely with headless server

they seem to work fine with local server....

could it have to do with the delay of a real server?

does headless server set ima_server?...it must....

i bet it also sets PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL

that means it processes local input here:

void mwPlayer::proc_player_input(void)
{
   if ((syn[0].level_done_mode == 0) || (syn[0].level_done_mode == 5)) // only allow player input in these modes
      for (int p=0; p<NUM_PLAYERS; p++)
         if (syn[p].active) // cycle all active players
         {
            int cm = syn[p].control_method;
            if ((cm == PM_PLAYER_CONTROL_METHOD_SINGLE_PLAYER) || (cm == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL) || (cm == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)) // these are the only local control methods
            {

but this should not be an issue...it wouldn't hurt to disable this anyway for headless server player....

where is my hidden attribute?

it could also be because the server does not actually draw the gate it never checks the limits...YES! that was it....

new release

7.24.022.3

It looks like I finally have the gate display problem fixed!!

Now unless I find more bugs, I guess I am moving on to recording video's


this looks like a mess still....

- why do I not have all cases set: mPlayer.syn[p].active = 0;

- why do they exit by settting: mLoop.state[0] = PM_PROGRAM_STATE_MENU;
would not server or client exit be better?

is the demo mode one even used?

comment it out and see...







to start with add active



void mwGameMoves::proc_game_move_player_inactive(int x)
{
   int p = arr[x][2]; // player number
   mPlayer.loc[p].quit_reason = arr[x][3];
   mPlayer.loc[p].quit_frame  = mLoop.frame_num;

   if (mPlayer.syn[p].active)
   {
      if (!mLoop.ff_state) mLog.add_headerf(LOG_NET, p, 0, "Player:%d became INACTIVE!                              ", p);

      // ------------------------------------
      // player in run demo mode became inactive
      // ------------------------------------
      if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_DEMO_MODE)
      {
         //printf("demo mode player:%d inactive\n", p) ;

         mPlayer.syn[p].active = 0;
         // only quit if no players left active
         int still_active = 0;
         for (int p=0; p<NUM_PLAYERS; p++)
            if (mPlayer.syn[p].active) still_active = 1;
         if (!still_active) mLoop.state[0] = PM_PROGRAM_STATE_MENU;
      }

      // ------------------------------------
      // local server player quit
      // ------------------------------------
      if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_SERVER_LOCAL)
      {
         // printf("Local Server Player Quit :%d\n", mLoop.frame_num);
         if (!mLoop.ff_state) mLog.log_ending_stats_server(LOG_NET_ending_stats);
         mLoop.state[0] = PM_PROGRAM_STATE_MENU;
      }

      // ------------------------------------
      // remote server quit
      // ------------------------------------
      if ((mNetgame.ima_client) && (p == 0))
      {
         // printf("Remote Server Quit :%d\n", mLoop.frame_num);
         mLoop.state[0] = PM_PROGRAM_STATE_MENU;
      }

      // ------------------------------------
      // remote player quit (server only)
      // is this really server only? would it not also apply to client on another client?
      // ------------------------------------


      if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE)
      {
         //printf("Remote Player Quit :%d\n", mLoop.frame_num);
         if (!mLoop.ff_state) mLog.log_ending_stats_client(LOG_NET_ending_stats, p);
         mPlayer.syn[p].active = 0;
      }
      mScreen.set_player_text_overlay(p, 0);
      mGameEvent.add(7, 0, 0, p, 0, 0, 0);
   }
}


new:


void mwGameMoves::proc_game_move_player_inactive(int x)
{
   int p = arr[x][2]; // player number
   mPlayer.loc[p].quit_reason = arr[x][3];
   mPlayer.loc[p].quit_frame  = mLoop.frame_num;

   if (mPlayer.syn[p].active)
   {
      if (!mLoop.ff_state) mLog.add_headerf(LOG_NET, p, 0, "Player:%d became INACTIVE!                              ", p);
      mPlayer.syn[p].active = 0;

      if (mNetgame.ima_server)
      {
         if (p == 0) // local server player quit
         {
            // printf("Local Server Player Quit:%d\n", mLoop.frame_num);
            if (!mLoop.ff_state) mLog.log_ending_stats_server(LOG_NET_ending_stats);
            mLoop.state[0] = PM_PROGRAM_STATE_SERVER_EXIT;
            return;
         }
         else // client quit on server
         {
            // printf("Client Quit on Server:%d\n", mLoop.frame_num);
            if (!mLoop.ff_state) mLog.log_ending_stats_client(LOG_NET_ending_stats, p);
         }
      }

      if (mNetgame.ima_client)
      {
         if (p == 0) // server quit on client
         {
            // printf("Remote Server Quit:%d\n", mLoop.frame_num);
            mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT;
         }
         else // a client quit
         {

            if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_CLIENT_LOCAL)
            {
               // printf("Local Client Quit:%d\n", mLoop.frame_num);
               mLoop.state[0] = PM_PROGRAM_STATE_CLIENT_EXIT;
               return;
            }

            if (mPlayer.syn[p].control_method == PM_PLAYER_CONTROL_METHOD_NETGAME_REMOTE) // remote client quit
            {
               // printf("Remote Client Quit:%d\n", mLoop.frame_num);

            }
         }
      }

      mScreen.set_player_text_overlay(p, 0);
      mGameEvent.add(7, 0, 0, p, 0, 0, 0);
   }
}

test all types...it seems to work....


I am thinking of making player_text_overlay use variables in the player structure

void mwScreen::set_player_text_overlay(int p, int type)
{
   player_text_overlay_timer = player_text_overlay_timer_reset_val;
   player_text_overlay_type = type;
   player_text_overlay_player = p;
}


all I would need is:
player_text_overlay_timer
player_text_overlay_type



right now they do not always propogate to clients...and there can ony be one active at a time

I am worried if I do too many it might affect drawing time...


measure...


ok how?

m36 player died 40us spkie to 80
4230 baseline 300 spikes to 600

worst case x8 2.4ms to 4.8ms

I could also make it so that only the most recent one shows in case of multiples


use 2 var in player struct....

i want to change where server makes player active when rx cjon...
server should insert game move to do this...why?..so it is like all the other times that happens
done...
actives show on clients, just like they did before
because they are part of the player struct, but bottom msh do not, beacuse the client never gets the active game move. it only happens on the server
this is fine...

still seems to work...

what about the time it takes to do all these?

ignore it for now? turn off with eco_draw?

it looks like eco_draw is only for lifts
wouldn't it be nice to make eco_draw kick in when any cpu usage gets over 80%?
just leave it all for now


make button on remote control not double press (server fakekey)...
it actually works as it should.
it just looks like it is flickering beacuse it takes some time for the result to come back from the server


20240223 another release....










































































































































































