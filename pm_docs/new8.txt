20221228

New running log of changes to the project...

The old one was over 40,000 lines and 1M char...


do a line count:

24525 code only
8006 empty
4979 comment
4557 code and comment
----------------
42067 total


where do I use proc_controllers?
108 matches

not in client anymore since I removed the blocking...

client does not exit when connection fails...fixed first part...

now what about waiting for initial state from server?

break it on the server and test how client responds

did it not used to say waiting for server in a few places?


I have made a nice way to quit while waiting for initial state....

I should make all the ways to exit from client go to a state that cleans up....i think I did...

client still will not rejoin until program is restarted....fixed...it was a strange issue with packetpos needing to be reset to 0


later make sure that server cleans up at exit like client, and try to restart....

also make sure that TCP still works...



Now I think I am finally ready to try some fast ping packets


OK I have the packet passing...what should I do about it?


when server receives pong do some timing

ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   1.2 ms
ping time:   1.6 ms
ping time:   1.6 ms
ping time:   0.5 ms
ping time:   1.3 ms
ping time:   0.9 ms
ping time:   1.1 ms
ping time:   1.5 ms
ping time:   1.0 ms
ping time:   1.5 ms
ping time:   0.7 ms
ping time:   0.6 ms
ping time:   0.6 ms

this is round trip UDP on LAN

switching to WAN


96.45.15.187


I am going to send the ts with the packet and add client ts also...
how do I add a double to a packet?

I could turn it into a char array like I do with state...


im guessing sizeof double is 8...

double test = 1.23;

memcpy(packetbuffer+pos, test,  8);





   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;




before I do this in a packet, lets just try to do it in a regular way....



void PacketPutDouble(double *d)
{
   memcpy(packetbuffer+packetsize, d, 8);
	packetsize+=8;
}

double PacketGetDouble(void)
{
   double d[2];
   memcpy(d, packetbuffer+packetpos, 8);
	packetpos+=8;
	return *d;
}



use this:
char packetbuffer[1024];

make a function to stick something in it and another fucntion to get it out....




char packetbuffer1[1024] = {0};
int packetsize1 = 0;
int packetpos1 = 0;

void PacketPutDouble1(double d)
{
   double dd[2] = {0};
   dd[0] = d;
   memcpy(packetbuffer1 + packetsize1, dd, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d[2] = {0};
   memcpy(d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d[0];
}

void temp_test(void)
{
   double t0 = 0.000123;
   printf("1 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);

   PacketPutDouble1(t0);
   printf("2 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);


   double t1 = PacketGetDouble1();
   printf("3 - ps:%d pp:%d sot:%d t1:%f\n", packetsize1, packetpos1, sizeof(t1), t1);


this shit works!!!


the problem I was having is that memcopy does not like to be passed plain variables, it wants pointers...
so I made an array of the variable tyope I wanted and only use the first element...

found this:


double in=2.132;
char arr[12] = {};
memcpy(arr,&in,sizeof(in));

char arr2[12] = ...;
double out;
memcpy(&out,arr2,sizeof(out));

void PacketPutDouble1(double d)
{
   memcpy(packetbuffer1 + packetsize1, &d, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d = 0;
   memcpy(&d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d;
}

that works too!

now put it in the packets....done...

now try


C:\pm>pm -s

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Local address of channel:24785
Network initialized - channel mode (UDP)
Server successfully initialized

Server received initial 1234 packet from '192.168.1.116:24785'
Server opened channel for `192.168.1.116:24785' and sent reply
ping time:   0.7 ms
ping time:   0.7 ms
ping time:   0.4 ms
ping time:   1.3 ms
ping time:   0.3 ms
ping time:   1.1 ms
ping time:   1.0 ms
ping time:   1.2 ms
ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.4 ms
ping time:   1.1 ms
ping time:   0.4 ms
ping time:   0.6 ms
ping time:   0.5 ms
Shutting down the server


now try internet:


Server received initial 1234 packet from '70.75.228.155:24785'
Server opened channel for `70.75.228.155:24785' and sent reply
ping time:  30.6 ms
ping time:  25.7 ms
ping time:  21.7 ms
ping time:  26.7 ms
ping time:  20.7 ms
ping time:  31.1 ms
ping time:  26.3 ms
ping time:  27.9 ms
ping time:  24.1 ms
ping time:  27.8 ms
ping time:  25.9 ms
ping time:  35.6 ms
Shutting down the server


OK I've got something

now try TCP

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Network initialized - connection mode (TCP)
Server successfully initialized

Connection received from 70.75.228.155:63272
ping time:  34.1 ms
ping time:  48.3 ms
ping time:  24.3 ms
ping time:  23.1 ms
ping time:  23.7 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  27.4 ms
ping time:  32.7 ms
ping time:  25.6 ms
ping time:  30.6 ms
ping time:  28.6 ms
ping time:  31.7 ms
ping time:  70.3 ms
Shutting down the server

not that much of a difference...

Now how can I use this to monitor and adjust timing..

Now that I can receive stdf any time, I want to know exactly when I am receiving them

this will be a client thing

when client gets an stdf, compare to the latest frame start

it was about 23ms after frame start...

soon, timestamp fills up.. I should make one global timestamp called frame_start....
I am amazed at how stable the timer is, fps adjust very rarely has anything to do...

now lets try fine tuning the sync...


I can get it down to 5-10 instead of 22 with fine tuning, but it does not make the game more playable on WAN
LAN still looks great

the problem on WAN is the corrections make it look really jumpy
try s1 = 2...



it work so good on LAN, whay not WAN, why so many jumpy corrections??

I need to look into the timing closer

maybe running just in time to get difs as needed is not the right approach

If I got difs for a frame that I has already rendered...
I could replay with the local controls for that frame that has already occured...
this would mean I am running ahead of the the server
controls that I am currently pressing are not as old on the server


If I got difs for a frame that I had not rendered yet...
i would hold off till then and apply it
this would mean I am running behind the server
controls that I am currently pressing are even older on the server



I will need to experiment with both

20221219 11:22PM ..push



I have some thoughts...

I want to know where in the client frame are the stdf's rx'd and where are they used..


Make a graphical overlay for the game

sliding bar to show sync and stuff

controls also...

timestamp bar in screen overlay
what am I going to show?

where will i get the data for that

should I clear old timestamps every second?

yes and I should do somthing in there about doing some nice averages and min max

later...


now I want to have some timestamps that do not get saved, only for current frame...
I have one for frame start, but I also want one for stdf rx..


what if I log these so that I can make a nice graph and look at them?? maybe later...


what I am seeing is the stdf being rx'd right after draw in the frame


where in the frame does the client use stdf?

at the very start...

- input
- move
- draw


what if I measured the timestamp difference between stdf packet being received and it being used by the client?

that is the critical timing anyway, is it not?



I want to solve the client sync thing....
I want to be able to control where in the frame the stdf is rx'd
this is proving to be harder than I thought

OK I think I figured out how to do that...

now I want to see if I can have some on screen controls

they will need to be non-blocking


run them from debug screen overlay

first can I show mouse??..yes

button works but blocks on mouse press....
made a non_blocking version


         static int pres = 0;
         if (mdw_buttont_nb(100, yyy, 200, 16,  0,0,0,0,  0,14,15, 0,  1,0,1,0, "Inc"))
         {
            if (pres == 0) printf ("incd\n");
            pres = 1;
         }
         else pres = 0;




now make a global to control the client dsync....done


when adjusting chase too close the connection is lost
the client gets difs too late to apply and does nothing??

cleaning up the logging...

removed call to apply dif from rx packet thing
now only called in the loop every frame and when waiting for intial state

logs look much better now...

I can tell the we are receiving stdf's too late..

they fail all the time when trying to apply, but that is normal.

what I should do is check when they are completed if there is any chance they can be used....
if they are late then I should raise some errors...already done....but addedd to log...
in client debug screen if server_sync = -1

and stays there for 100 frames server will drop

should client reply at all, all it has is stak...and we are not acknowledging anything...

we ack when we get a bad base, should we ack when we get a bad dest??...yes...done...



now sync can go to -1 and client stays connected

I should have something on the client to tell when te last applied dif is.

I am thinking about the nice little graph that shows dsync...
It could also display last diff applied....

added to player1

   int client_last_diff_applied;


That works...


now I want to make a nice little display for the client.

graph
buttons
chase_offset
last_dif
draw in red if last_dif > 2


for the actual value, lets take if from

added to player1 struct...
   double dsync;


OMG that looks great...

now what??

that is about the only thing that I can adjust and monitor on the client....
it sends cdats when they occurs
it processes stdfs just before it has to apply them...

this client dsync is such an important number that I wonder if I should sync it back to the server.
I could add it to stak....

on the client


move all of these to player1

double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;
double client_chase_offset = 0.010;

done...

I actually did not need these and removed them...
double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;

still wondering about adding dsync to stak so server has it....

It was as easy as adding one line on the client:

   PacketPutDouble(players1[p].dsync);

   and one on the client...

   players1[p].dsync            = PacketGetDouble();

add display it in server debug...done...


now what?

do some things for server...like?

buttons to change s1 and s2

graph to show when clients cdats arrive in relation to current frame...

s1 and s2 are already part of the player1 struct...

done...


I want to know at what position in the frame do cdats arrive at, and how many frames behind....

crudely looking in the logs -2 and rarely -3 for a WAN game....
-1 for a LAN game....this might be unavoidable...

if the round trip ping is around 30 then one way would be 15...

I want to know exactly what it is and see if adjusting the client offset can do anything about it....


so how to measure?


server fast packet loop already marks cdats with timestamp when they arrive

so go to where they are processed...




I still don't like how the frame_number are processed!!
I really want to fix it but I am scared of what it will break....

---------------
- current:
---------------
timer_triggers_event

input
move
draw
inc frame

wait until triggered again...


---------------
what I want:
---------------
timer_triggers_event

inc frame
input
move
draw

wait until triggered again...

this would mean that for the entirety of the frame, the frame number is the same

not
change frame number
wait
do stuff

the wait would be at the end....


goddamn it!! I don't care what I have to fix...I'm going to make it so that is how it is...

one consequence is there will never be a frame 0...I know somethings depend on that....

or rather any setup that is done before the first loop will be done on frame 1....


it is done, these are the first lines

mwPS.frame_num++;
update_animation();

lets see what still works...

single player seems good....level done too

server and client seem to work...omg...

This will have more of an effect on some timer things I am doing....




[1457]cdat 1455  gc:-2 0.016008
[1458]cdat 1456  gc:-2 0.012546
[1459]cdat 1457  gc:-2 0.008733
[1460]cdat 1458  gc:-2 0.013411
[1461]cdat 1459  gc:-2 0.015866
[1462]cdat 1460  gc:-2 0.016015
[1463]cdat 1461  gc:-2 0.008641
[1464]cdat 1462  gc:-2 0.012660
[1465]cdat 1463  gc:-2 0.016165
[1466]cdat 1464  gc:-2 0.016065
[1467]cdat 1465  gc:-2 0.008550
[1468]cdat 1466  gc:-2 0.016006
[1469]cdat 1467  gc:-2 0.013687
[1470]cdat 1468  gc:-2 0.010922
[1471]cdat 1469  gc:-2 0.011143
[1472]cdat 1470  gc:-2 0.015377
[1473]cdat 1471  gc:-2 0.011053
[1474]cdat 1472  gc:-2 0.013461
[1476]cdat 1473  gc:-3 0.023695
[1477]cdat 1474  gc:-3 0.023571
[1477]cdat 1475  gc:-2 0.015960
[1478]cdat 1476  gc:-2 0.016023
[1479]cdat 1477  gc:-2 0.008565
[1480]cdat 1478  gc:-2 0.015372
[1481]cdat 1479  gc:-2 0.011239
[1482]cdat 1480  gc:-2 0.015975
[1483]cdat 1481  gc:-2 0.016240
[1484]cdat 1482  gc:-2 0.013693
[1485]cdat 1483  gc:-2 0.013712
[1486]cdat 1484  gc:-2 0.016219
[1487]cdat 1485  gc:-2 0.006484
[1488]cdat 1486  gc:-2 0.010268
[1489]cdat 1487  gc:-2 0.016290
[1490]cdat 1488  gc:-2 0.016250
[1491]cdat 1489  gc:-2 0.005989
[1492]cdat 1490  gc:-2 0.016332
[1493]cdat 1491  gc:-2 0.016286
[1494]cdat 1492  gc:-2 0.011335
[1496]cdat 1493  gc:-3 0.015332
[1496]late cdat dropped p:1 c:1493  state:1494  tally:5
[1496]cdat 1494  gc:-2 0.015881
[1497]cdat 1495  gc:-2 0.011157
[1498]cdat 1496  gc:-2 0.016283
[1500]cdat 1497  gc:-3 0.018602
[1500]cdat 1498  gc:-2 0.016122
[1501]cdat 1499  gc:-2 0.016274
[1502]cdat 1500  gc:-2 0.016290
[1504]cdat 1501  gc:-3 0.022777
[1504]cdat 1502  gc:-2 0.015344
[1505]cdat 1503  gc:-2 0.016394
[1506]cdat 1504  gc:-2 0.013682
[1507]cdat 1505  gc:-2 0.005452
[1508]cdat 1506  gc:-2 0.016448
[1509]cdat 1507  gc:-2 0.008965
[1510]cdat 1508  gc:-2 0.013958
[1511]cdat 1509  gc:-2 0.012853
[1512]cdat 1510  gc:-2 0.012440
[1513]cdat 1511  gc:-2 0.010386
[1514]cdat 1512  gc:-2 0.015350
[1515]cdat 1513  gc:-2 0.002899
[1516]cdat 1514  gc:-2 0.015026
[1517]cdat 1515  gc:-2 0.010401
[1518]cdat 1516  gc:-2 0.012886
[1519]cdat 1517  gc:-2 0.012882
[1520]cdat 1518  gc:-2 0.015386
[1521]cdat 1519  gc:-2 0.012910
[1522]cdat 1520  gc:-2 0.015355
[1523]cdat 1521  gc:-2 0.007923
[1524]cdat 1522  gc:-2 0.012935
[1525]cdat 1523  gc:-2 0.012978
[1526]cdat 1524  gc:-2 0.015520
[1527]cdat 1525  gc:-2 0.012827
[1528]cdat 1526  gc:-2 0.015430
[1529]cdat 1527  gc:-2 0.015545
[1530]cdat 1528  gc:-2 0.012892
[1531]cdat 1529  gc:-2 0.012998
[1532]cdat 1530  gc:-2 0.014326
[1533]cdat 1531  gc:-2 0.012941
[1534]cdat 1532  gc:-2 0.015566
[1535]cdat 1533  gc:-2 0.008016
[1537]cdat 1535  gc:-2 0.015592
[1538]cdat 1536  gc:-2 0.015593
[1539]cdat 1537  gc:-2 0.000435
[1540]cdat 1538  gc:-2 0.015559
[1541]cdat 1539  gc:-2 0.015597
[1542]cdat 1540  gc:-2 0.015425
[1543]cdat 1541  gc:-2 0.008001
[1544]cdat 1542  gc:-2 0.014422
[1545]cdat 1543  gc:-2 0.008050
[1546]cdat 1544  gc:-2 0.015639
[1547]cdat 1545  gc:-2 0.015657
[1548]cdat 1546  gc:-2 0.010277
[1549]cdat 1547  gc:-2 0.015553
[1550]cdat 1548  gc:-2 0.013098
[1551]cdat 1549  gc:-2 0.008058
[1552]cdat 1550  gc:-2 0.015317
[1553]cdat 1551  gc:-2 0.016250
[1554]cdat 1552  gc:-2 0.016115
[1555]cdat 1553  gc:-2 0.006201
[1556]cdat 1554  gc:-2 0.016057
[1557]cdat 1555  gc:-2 0.013614
[1558]cdat 1556  gc:-2 0.011243
[1559]cdat 1557  gc:-2 0.013781
[1560]cdat 1558  gc:-2 0.015270
[1561]cdat 1559  gc:-2 0.016355
[1562]cdat 1560  gc:-2 0.016313
[1563]cdat 1561  gc:-2 0.005983
[1564]cdat 1562  gc:-2 0.016292
[1565]cdat 1563  gc:-2 0.016259
[1566]cdat 1564  gc:-2 0.016243
[1568]cdat 1565  gc:-3 0.021811
[1568]late cdat dropped p:1 c:1565  state:1566  tally:6
[1568]cdat 1566  gc:-2 0.010779
[1569]cdat 1567  gc:-2 0.013561
[1570]cdat 1568  gc:-2 0.013822
[1571]cdat 1569  gc:-2 0.013807
[1572]cdat 1570  gc:-2 0.016112
[1573]cdat 1571  gc:-2 0.013626
[1574]cdat 1572  gc:-2 0.011389
[1575]cdat 1573  gc:-2 0.008685
[1576]cdat 1574  gc:-2 0.014161
[1577]cdat 1575  gc:-2 0.013923
[1578]cdat 1576  gc:-2 0.013768
[1579]cdat 1577  gc:-2 0.011336
[1580]cdat 1578  gc:-2 0.013763
[1581]cdat 1579  gc:-2 0.013759
[1582]cdat 1580  gc:-2 0.016342
[1583]cdat 1581  gc:-2 0.013814
[1584]cdat 1582  gc:-2 0.009788
[1585]cdat 1583  gc:-2 0.015957
[1586]cdat 1584  gc:-2 0.015287
[1587]cdat 1585  gc:-2 0.012783
[1588]cdat 1586  gc:-2 0.012283
[1589]cdat 1587  gc:-2 0.014804
[1590]cdat 1588  gc:-2 0.009828
[1591]cdat 1589  gc:-2 0.012939
[1592]cdat 1590  gc:-2 0.014961
[1593]cdat 1591  gc:-2 0.014743
[1594]cdat 1592  gc:-2 0.015493
[1595]cdat 1593  gc:-2 0.015486
[1596]cdat 1594  gc:-2 0.015339
[1597]cdat 1595  gc:-2 0.015183
[1598]cdat 1596  gc:-2 0.012898
[1599]cdat 1597  gc:-2 0.012872
[1600]cdat 1598  gc:-2 0.015144
[1601]cdat 1599  gc:-2 0.015399
[1602]cdat 1600  gc:-2 0.015535
[1603]cdat 1601  gc:-2 0.015149
[1604]cdat 1602  gc:-2 0.015224
[1605]cdat 1603  gc:-2 0.015317
[1606]cdat 1604  gc:-2 0.015380
[1607]cdat 1605  gc:-2 0.015513
[1608]cdat 1606  gc:-2 0.015421
[1609]cdat 1607  gc:-2 0.013009
[1610]cdat 1608  gc:-2 0.015586
[1611]cdat 1609  gc:-2 0.013025
[1612]cdat 1610  gc:-2 0.009968
[1613]cdat 1611  gc:-2 0.012802
[1614]cdat 1612  gc:-2 0.015206
[1615]cdat 1613  gc:-2 0.013571
[1616]cdat 1614  gc:-2 0.010078
[1617]cdat 1615  gc:-2 0.013467
[1618]cdat 1616  gc:-2 0.011040
[1619]cdat 1617  gc:-2 0.008677
[1620]cdat 1618  gc:-2 0.013720
[1621]cdat 1619  gc:-2 0.008645
[1622]cdat 1620  gc:-2 0.016253
[1623]cdat 1621  gc:-2 0.013690
[1624]cdat 1622  gc:-2 0.010371
[1625]cdat 1623  gc:-2 0.016220
[1626]cdat 1624  gc:-2 0.016234
[1627]cdat 1625  gc:-2 0.013284
[1628]cdat 1626  gc:-2 0.016230
[1629]cdat 1627  gc:-2 0.016302
[1630]cdat 1628  gc:-2 0.013344
[1631]cdat 1629  gc:-2 0.013923
[1632]cdat 1630  gc:-2 0.014303
[1633]cdat 1631  gc:-2 0.011076
[1634]cdat 1632  gc:-2 0.016218
[1636]cdat 1634  gc:-2 0.016113
[1637]cdat 1635  gc:-2 0.016295
[1638]cdat 1636  gc:-2 0.011313
[1639]cdat 1637  gc:-2 0.011073
[1640]cdat 1638  gc:-2 0.009382
[1641]cdat 1639  gc:-2 0.015344
[1642]cdat 1640  gc:-2 0.013728
[1643]cdat 1641  gc:-2 0.011338
[1644]cdat 1642  gc:-2 0.012676
[1645]cdat 1643  gc:-2 0.016255
[1646]cdat 1644  gc:-2 0.016330
[1647]cdat 1645  gc:-2 0.011304
[1648]cdat 1646  gc:-2 0.012836
[1649]cdat 1647  gc:-2 0.016026
[1650]cdat 1648  gc:-2 0.013793
[1651]cdat 1649  gc:-2 0.011195
[1652]cdat 1650  gc:-2 0.015942
[1653]cdat 1651  gc:-2 0.013636
[1654]cdat 1652  gc:-2 0.013275
[1655]cdat 1653  gc:-2 0.013769
[1656]cdat 1654  gc:-2 0.015110
[1657]cdat 1655  gc:-2 0.010577
[1658]cdat 1656  gc:-2 0.016374
[1659]cdat 1657  gc:-2 0.011284
[1660]cdat 1658  gc:-2 0.010566
[1661]cdat 1659  gc:-2 0.015398
[1662]cdat 1660  gc:-2 0.015214
[1663]cdat 1661  gc:-2 0.012801
[1664]cdat 1662  gc:-2 0.007925
[1665]cdat 1663  gc:-2 0.014823
[1666]cdat 1664  gc:-2 0.012664
[1667]cdat 1665  gc:-2 0.012927
[1668]cdat 1666  gc:-2 0.007893
[1669]cdat 1667  gc:-2 0.013443
[1670]cdat 1668  gc:-2 0.015582
[1671]cdat 1669  gc:-2 0.000908
[1672]cdat 1670  gc:-2 0.009900
[1673]cdat 1671  gc:-2 0.013594
[1674]cdat 1672  gc:-2 0.015531
[1675]cdat 1673  gc:-2 0.010952
[1676]cdat 1674  gc:-2 0.013435
[1677]cdat 1675  gc:-2 0.013549
[1678]cdat 1676  gc:-2 0.008466
[1680]cdat 1677  gc:-3 0.019645
[1680]cdat 1678  gc:-2 0.002917
[1681]cdat 1679  gc:-2 0.008503
[1682]cdat 1680  gc:-2 0.016072
[1683]cdat 1681  gc:-2 0.011123
[1684]cdat 1682  gc:-2 0.003675
[1685]cdat 1683  gc:-2 0.013604
[1686]cdat 1684  gc:-2 0.015596
[1687]cdat 1685  gc:-2 0.016052
[1688]cdat 1686  gc:-2 0.015212
[1689]cdat 1687  gc:-2 0.016168
[1690]cdat 1688  gc:-2 0.011074
[1691]cdat 1689  gc:-2 0.013681
[1692]cdat 1690  gc:-2 0.013463
[1693]cdat 1691  gc:-2 0.011137
[1694]cdat 1692  gc:-2 0.011156
[1695]cdat 1693  gc:-2 0.000906
[1696]cdat 1694  gc:-2 0.009721
[1697]cdat 1695  gc:-2 0.016065
[1698]cdat 1696  gc:-2 0.010847
[1699]cdat 1697  gc:-2 0.008499
[1700]cdat 1698  gc:-2 0.015868
[1701]cdat 1699  gc:-2 0.013527
[1702]cdat 1700  gc:-2 0.012817
[1703]cdat 1701  gc:-2 0.013946
[1704]cdat 1702  gc:-2 0.015312
[1705]cdat 1703  gc:-2 0.016129
[1706]cdat 1704  gc:-2 0.016215
[1707]cdat 1705  gc:-2 0.001235
[1708]cdat 1706  gc:-2 0.016209
[1709]cdat 1707  gc:-2 0.016298
[1710]cdat 1708  gc:-2 0.016262
[1711]cdat 1709  gc:-2 0.006192
[1712]cdat 1710  gc:-2 0.015423
[1713]cdat 1711  gc:-2 0.015889
[1714]cdat 1712  gc:-2 0.013694
[1715]cdat 1713  gc:-2 0.013802
[1716]cdat 1714  gc:-2 0.013334
[1717]cdat 1715  gc:-2 0.011154
[1718]cdat 1716  gc:-2 0.016351
[1719]cdat 1717  gc:-2 0.016319
[1720]cdat 1718  gc:-2 0.002903
[1721]cdat 1719  gc:-2 0.015321
[1722]cdat 1720  gc:-2 0.013337
[1723]cdat 1721  gc:-2 0.013783
[1724]cdat 1722  gc:-2 0.016235
[1725]cdat 1723  gc:-2 0.016357
[1726]cdat 1724  gc:-2 0.015293
[1727]cdat 1725  gc:-2 0.016391
[1728]cdat 1726  gc:-2 0.012899
[1729]cdat 1727  gc:-2 0.011115
[1730]cdat 1728  gc:-2 0.015705
[1731]cdat 1729  gc:-2 0.013571
[1732]cdat 1730  gc:-2 0.013652
[1733]cdat 1731  gc:-2 0.013832
[1734]cdat 1732  gc:-2 0.015658
[1735]cdat 1733  gc:-2 0.013765
[1736]cdat 1734  gc:-2 0.010355
[1737]cdat 1735  gc:-2 0.015423
[1738]cdat 1736  gc:-2 0.012726
[1739]cdat 1737  gc:-2 0.005048
[1740]cdat 1738  gc:-2 0.015540
[1741]cdat 1739  gc:-2 0.010319
[1742]cdat 1740  gc:-2 0.007640
[1743]cdat 1741  gc:-2 0.002646
[1744]cdat 1742  gc:-2 0.010272
[1745]cdat 1743  gc:-2 0.020515
[1746]cdat 1744  gc:-2 0.015403
[1747]cdat 1745  gc:-2 0.012900
[1748]cdat 1746  gc:-2 0.007992
[1749]cdat 1747  gc:-2 0.015303
[1750]cdat 1748  gc:-2 0.010310
[1751]cdat 1749  gc:-2 0.007921
[1752]cdat 1750  gc:-2 0.012557
[1753]cdat 1751  gc:-2 0.015826
[1754]cdat 1752  gc:-2 0.016052
[1755]cdat 1753  gc:-2 0.011077
[1756]cdat 1754  gc:-2 0.013468
[1757]cdat 1755  gc:-2 0.016045
[1758]cdat 1756  gc:-2 0.016096
[1759]cdat 1757  gc:-2 0.011004
[1760]cdat 1758  gc:-2 0.015371
[1761]cdat 1759  gc:-2 0.011178
Shutting down the server
savegame/game_exit_20221230-183937-lev150.txt - saved
logs/20221230-183937-[150][m36].txt saved

C:\pm>







so how to combine those two numbers


and do they even still make sense?


Now, if I get one I can assume by the time it gets added it will be the next frame...
or this frame because by the time it is processed the frame has incremented

so when I get one that says -2 on frame 1730 for example...
that mean the cdat is for 1728, 2 frame ago...


now that the start of frame timer can be trusted, I should use that to go back and find out exactly when the packet arrived in relation to the frame start.

then I can make a composite number of how late it is...

WAN

[244]cdat 242  gc:-2 0.016242 -33.757700ms
[245]cdat 243  gc:-2 0.013527 -36.472500ms
[246]cdat 244  gc:-2 0.001073 -48.926800ms
[247]cdat 245  gc:-2 0.013675 -36.325100ms
[248]cdat 246  gc:-2 0.008515 -41.484700ms
[249]cdat 247  gc:-2 0.013653 -36.346700ms
[250]cdat 248  gc:-2 0.003773 -46.226500ms
[251]cdat 249  gc:-2 0.013406 -36.593600ms
[252]cdat 250  gc:-2 0.013678 -36.322400ms
[253]cdat 251  gc:-2 0.013635 -36.364900ms
[255]cdat 252  gc:-3 0.018778 -56.222400ms
[256]cdat 253  gc:-3 0.013594 -61.405500ms
[256]cdat 254  gc:-2 0.013532 -36.468100ms
[257]cdat 255  gc:-2 0.013844 -36.155600ms
[258]cdat 256  gc:-2 0.008631 -41.369000ms
[259]cdat 257  gc:-2 0.011310 -38.690000ms
[260]cdat 258  gc:-2 0.013817 -36.183400ms
[261]cdat 259  gc:-2 0.012976 -37.023800ms
[262]cdat 260  gc:-2 0.006389 -43.610600ms
[263]cdat 261  gc:-2 0.011331 -38.669100ms
[264]cdat 262  gc:-2 0.013452 -36.548300ms
[265]cdat 263  gc:-2 0.003223 -46.777400ms
[266]cdat 264  gc:-2 0.008756 -41.244300ms
[267]cdat 265  gc:-2 0.011006 -38.994200ms
[268]cdat 266  gc:-2 0.016051 -33.949000ms
[269]cdat 267  gc:-2 0.013857 -36.143100ms
[270]cdat 268  gc:-2 0.008706 -41.294100ms
[271]cdat 269  gc:-2 0.011205 -38.794700ms
[272]cdat 270  gc:-2 0.013796 -36.204100ms
[278]cdat 276  gc:-2 0.006955 -43.044900ms



LAN 10ms

[352]cdat 351  gc:-1 0.012526 -12.474100ms
[353]cdat 352  gc:-1 0.011416 -13.583900ms
[354]cdat 353  gc:-1 0.012495 -12.505200ms
[355]cdat 354  gc:-1 0.012518 -12.481800ms
[356]cdat 355  gc:-1 0.011462 -13.538200ms
[357]cdat 356  gc:-1 0.013423 -11.577100ms
[358]cdat 357  gc:-1 0.013426 -11.573700ms
[359]cdat 358  gc:-1 0.012400 -12.599700ms
[360]cdat 359  gc:-1 0.012547 -12.453300ms
[361]cdat 360  gc:-1 0.013429 -11.570900ms
[362]cdat 361  gc:-1 0.012374 -12.626400ms
[363]cdat 362  gc:-1 0.013445 -11.554800ms
[364]cdat 363  gc:-1 0.013457 -11.543500ms
[365]cdat 364  gc:-1 0.012394 -12.606000ms
[366]cdat 365  gc:-1 0.012999 -12.001300ms
[367]cdat 366  gc:-1 0.012964 -12.036300ms
[368]cdat 367  gc:-1 0.011328 -13.672500ms

LAN 2ms

[573]cdat 572  gc:-1 0.021599 -3.400600ms
[574]cdat 573  gc:-1 0.021587 -3.412900ms
[575]cdat 574  gc:-1 0.020520 -4.480400ms
[576]cdat 575  gc:-1 0.020883 -4.117200ms
[577]cdat 576  gc:-1 0.021548 -3.452300ms
[578]cdat 577  gc:-1 0.020530 -4.470000ms
[579]cdat 578  gc:-1 0.021555 -3.445200ms
[580]cdat 579  gc:-1 0.021530 -3.469900ms
[581]cdat 580  gc:-1 0.020455 -4.545000ms
[582]cdat 581  gc:-1 0.021507 -3.493000ms
[583]cdat 582  gc:-1 0.021511 -3.489000ms
[584]cdat 583  gc:-1 0.019713 -5.286600ms
[585]cdat 584  gc:-1 0.021510 -3.490400ms
[586]cdat 585  gc:-1 0.021510 -3.489900ms
[587]cdat 586  gc:-1 0.020450 -4.550300ms
[588]cdat 587  gc:-1 0.021512 -3.488100ms



I want to have server stats on cdat_rx time
tally for 1s and do average and max min
same for late cdats

OK I have done that...big surprise...nothing seems to effect when cdats are received on server, except for client dsync....


the only thing I can do to get cdats to the server faster, would be to let the client move ahead of the server in time....
but then the client would always get difs that were too late to apply....

what if I let the client rewind?
and apply the local moves from the last frame?

that would mean I would have to keep the clients local moves...it would only be one move per frame max...

this is just crazy enough to maybe work.....

client stores all its game moves in it's own local array....
when client get a dif that is in the past:
apply then play back to current...



right now I have the server in the lead, the client lags behind just enough so I can get the current state from the server and apply it.
If I let the client pass the server, the server will be able to get cdats with less delay, but who knows what else might happen??

I think it's worth a try....

1 - make client put stuff in its own local game_moves array

2 - remove the part in rx stdf where we ignore late difs

3 - modify apply dif to allow late ones

this is a tricky bit of code here....

   // check to see if frame_nums match and its time to apply dif or if initial state when mwPS.frame_num == 0
   if ((mwPS.frame_num != client_state_dif_dst) && (mwPS.frame_num != 0))
   {


first of all if the match then do it
second of all if mwPS.frame_num == 0 do it
third of all...
if newer than last applied dif....

what is the varaible for the last applied dif mwPS.frame_num? 'client_state_base_frame_num'

so check if the dest of the dif_dest on deck is newer than that

if (client_state_dif_dst > client_state_base_frame_num) // we have dif with a newer dest than previous

omg I am ready to try it....

well it looks like I can run a game succesfully with negative sync... lets try it on WAN


client has all been put back together nicely...
still to do on client
look into chase multiplier...seems to work good but I have not examined it
automatically set chase amount, but based on what?
should it be a sliding scale, or a fixed number?

on server I have issues if I try to lower s1
raising it is OK but when I lower it, server becomes unresponsive and will not accept new connections

show more about the clients on the server...but what and why??

profile using timestamps certain functions...

move
draw
rewind
send stdf
receive packets

move packetbuffer code and functions to packet file


testing...making the client -40 seemed to make the game a lot smoother....


calculate and show ping on client and server...


server tx ping from 'loop' with current time

client rx ping and tx pong with passed time and current time

server rx pong
calc rt
return passed ts in pang

client rx pang
calc rt


ok now where to store it...

player1
   double ping;

put it on the bottom for client

in server it will be part of debug array



flush client and server on level done


when does client show red...removed

how about auto setting clients offset to ping....

but I would need to get an average ping
I only read it every 2s

how about reading it one per second and keep a 10s rolling average....

at the start of when a client joins
use default of zero to start...
get 8 pings in 2s for avg then use that to adjust
then do the rolling replace one every 2 sec

is this overkill...maybe...

but just blindly plugging one ping into offset is bad also

should have some limits....
+20 absolute max, why would you even want to go positive?
-50 to -80 somehwere around there for the min need to test...




try experimenting with different s1 and s2
3 1 - default

I'm getting late cdats and stuff from 4230's but not scat or e6430
the sync on them is jumping around a lot...
I could probably benefit from some code profiling....


20221231 9:26 AM

make the client initiate ping, as it is the one that needs it.
where?
how about from a timer?
too complex, just do it like the server does...
done...

now make way for client to do more right after join...

how about make the cyclic buffer of ping to average first....

then make a method to add new pings

then make a way that the average is calultaed

then make a way that when the buffer is not full, its pings mopre often...

struct ping_buffer

int num_filled;
int new_index;
double ping[8];
double avg;

initially:
num_filled = 0;
index = 0;
all are 0;

as added:
num_filled++
index++

num_filled can be greater than index

when doing avg

loop and add from 0 to num filled, or max if full

then divide and set avg...


do I need to do it in a struct? probably not the besy way...

double ping_array[8];
double ping_avg;
int    ping_num_filled;
int    ping_index;

make a new file ping_buffer.cpp

clear in client init..done

now make a function to add...done...

now where am I going to save this?

player1

ping_avg

ok that's done...now make it run faster until filled...

done...

now maybe toss out the highest and lowest for average....

experiment with different values of s1 and s2

right now I have been using 3 and 1

re do the client sync graph for the server, especially since I now use dsync

what did I use before?

stak packet on server prints this log line:

sprintf(tmsg1, "rx stak sync:[%d] chase:[%d] ack_fn:%d cli_fn:%d", players1[p].server_sync, players1[p].client_chase_fps, ack_frame_num, client_frame_num );

[30][1][318]rx stak sync:[1] chase:[39] ack_fn:316 cli_fn:317 set new base

I want to add dsync and remove unneeded things...why do I have 2 fn that are always the same??

change client_chase_fps to double from int....

its main use is to get back to the server to be displayed

OK I have parsed it from the log lines in graph...

but the problem is that the data for the graph is an integer array....

for now, multiply by 10...

redo sync to display in ms

I can come back to this later....
when I get this done I can examine chase better.....

OK, Ive been thinking...
I want to make the tag parsing thing a separate function...done
replaced 8-10 calls

Also this sync graph would probably be better on the client.

The server only has data when it receives stak....

what can I do to make the graph look better??

it is not frames anymore, but ms...

better....

can I auto range based on the data shown?...yes...

my stak log line can bee too long

[30][3][500]rx stak syn:[4] dsy:[12405.5] chs:[70.0] afn:496 cfn:496 failed to set base! cl:499

[30][4][6180]rx stak syn:[-2] dsy:[-113.3] chs:[31.7] afn:6177 cfn:6182 failed to set base! cl:6179
[30][3][6182]rx stak syn:[-2] dsy:[-104.8] chs:[33.0] afn:6179 cfn:6184 failed to set base! cl:6181
[30][4][6182]rx stak syn:[-2] dsy:[-104.6] chs:[32.6] afn:6177 cfn:6184 failed to set base! cl:6181
[30][2][6183]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6185 failed to set base! cl:6181
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183


failed to set base! cl:6183
change to
fail base set:6183

saved 9 char

more:
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183

[30][2][6184]rx stak s[-2] d[-100.0] c[33.0] af:6179 cf:6186 fail set base:6183

saved 20 char



can I make some buttons in graphs?  at the top of the legend scale lock or autorange..
auto/manual
manual +/-



I really want to make the graphs simpler...

wouldn't it be nice to have a common function for all of them?

they all seem to have common x axis...frames, seconds, minutes, etc.....


what is the data needed to describe a graph?

screen coordinates x1, y1, x2, y2, w, h
these are in the standard computer screen format: x1,y1 is upper left corner

graph x axis
start and end data values

graph y axis
start and end data values

can get range from these.

an array of data used to plot points on the graph

data[][0] = x
data[][1] = y

can I make this an object?

why?

so it encaspulates it's own data and methods

I will call it to draw itself
optionally draw legends and gridlines
process mouse input on the graph

class mw_graph

make a new file and lets do this....


I don't get why I am having such a hard time mapping one range to another....
am i doing the wrong things??
I don't need to map the data range to the axis range!
I need to map the axis range to the screen range!!!!

   double xm = screen_w / x_axis_rng;
   double ym = screen_h / y_axis_rng;

   for (int i=0; i<data_points; i++)
   {
      float x = screen_x1 + (data[i][0]-x_axis_min) * xm;
      float y = screen_y2 - (data[i][1]-y_axis_min) * ym;
      al_draw_rectangle(x, y, x+1, y+1, mColor.pc[10], 1);
   }


now what??

should I put some mouse_controls in?
yes...

ist show mouse...

2nd show mouse position and convert to values...

this will mean I have to call this in a loop and process event queue....

done...
now I want an autoscale button
one for x and y and one for each also...

done...


what now?

can you do a nice title...

set a minimum x axis range....

butttons for nice axis management:
auto/manual
of just auto button
+ and - to adjust scale
for each min and mix??

not sure if this will be that usefull

implement mouse_drag...
x only or x and y?
can you set a scale conevrsion varaible for x axis and y axis
do it on the fly..it was easy...
mouse drag works beautifully




            // graph position under mouse (mx1) needs to stay the same

            // change range?? then find min and max to ensure same pos??


            // what if i calulated scaler, then changed that, then worked backwards from there
//            double x_scaler =  x_axis_rng / screen_w;
//            x_scaler *= 1.1;
//            x_axis_rng = x_scaler * screen_w; // convert range back

            // now how do I adjust min so that current pos is the same

            // old distance from current pos to min * scaler  ????

//
//            // old distance from curent position to min
//            double old_offset = mx1 - x_axis_min;
//
//            printf("old_offset:%f\n", old_offset);
//
//
//            // get original scale
//            double x_scaler =  x_axis_rng / screen_w;
//
//            printf("orignal_scale:%f\n", x_scaler);
//
//
//
//            // change scale
//            x_scaler *= 1.1;
//
//
//            printf("new_scale:%f\n", x_scaler);
//
//
//            printf("old range:%f\n", x_axis_rng);
//
//            // convert range
//            x_axis_rng = x_scaler * screen_w;
//
//            printf("new range:%f\n", x_axis_rng);
//
//
//
//            printf("old offset:%f\n", old_offset);
//
//            // scale to new
//            double new_offset = old_offset * 1.1;
//
//
//            printf("new offset:%f\n", new_offset);
//
//
//
//            printf("old min:%f\n", x_axis_min);
//
//            // set min from original position and new offset
//            x_axis_min = mx1 - new_offset;
//
//
//            printf("new min:%f\n", x_axis_min);
//
//            // set max1
//            x_axis_max = x_axis_min + x_axis_rng;
//
//
//


            double old_offset = mx1 - x_axis_min;     // old distance from curent position to min
            double new_offset = old_offset * 1.1;     // scale to new
            x_axis_min = mx1 - new_offset;            // set min from original position and new offset
            x_axis_rng *= 1.1;                        // convert range
            x_axis_max = x_axis_min + x_axis_rng;     // set new max


holy shit that is beautiful!!

mouse drag (x axis)
mouse wheel zoom (x axis)
mouse drag zoom in (x and y axis)

do something about mouse drag when off screen, clamp to edges done...

try y drag move...awesome...

try y zoom wheel...wicked...

now if I added lock buttons on the x and y axis to prevent this

will it lock both scroll and zoom??

for x axis

zoom lock..


I want scroll bars...

do an x one first


I think I am readt to start thinking about some limits....

limit the axis ranges....

make all changes to the axis ranges go through a common function so limit will only need to be tested once
done...
it works, but seems a little weird when drag turns into resize...
drag normally moves both start and end
if one does not move, it turns into a resize...
the alternative would be to do nothing, no drag move allowed if it would change range

I can live with it for now...


now make some ways to drag the scroll bar...

make scrollbar variables part of class...done

int x_axis_scrollbar_x1;
int x_axis_scrollbar_x2;
int x_axis_scrollbar_w;

int x_axis_scrollbar_bar_x1;
int x_axis_scrollbar_bar_x2;

int x_axis_scrollbar_y1;
int x_axis_scrollbar_y2;

moved draw into its own function


figure out the offset...data does not start till 40...done...


now I have 5 ways to adjust the scroll bar with the mouse and its looking pretty good...

sometimes I can adjust past data max and stuff breaks...
a_axis min can be more the max...this should not happen...

there is some chicken and egg things going on with enforce limits...

testing for min max
testing for wrong order

I need to test both min and max to see if they are in range

I also want to add another test...minimum range...

I should find the smallest difference between x values and make the minum range 10 of those...

for now, lets just set a static value and test..

if both max and min are stuck near the top separate them by minimum range...

this all looks good...

now I want to do some y ranging


   bool x_axis_lock_scroll;
   bool x_axis_lock_zoom;

   bool y_axis_lock_scroll;
   bool y_axis_lock_zoom;
   bool y_axis_lock_auto_zoom;



y_axis_lock_zoom
done for drag rect and mouse wheel
not done for drag scroll...still changes zoom...fixed

y_axis_lock_scroll

y_axis scrollbars

y axis is reversed, which poses some issues
how am I going to deal with that? at what point do I flip the axis...
x1 is smaller than x2 when drawing on the screen
but when the mouse moves they are oppposite...
make the data reveser
y2 is min, y1 is max...
im thinking of doing it all upside down...
y1 is lower

I just made the scrollbar y1 and y2 reversed....

I have implemented all scrollbar functionality to y scroll bar...
make the highlight look better, align better, color, size, different mouse_pointer....done...



now back to the locking...

enforce zoom lock on y scroll bar..done...


what does it mean if scroll is locked and zoom is not? does that even make sense??
it could mean that the x_min is locked, but not x_max and scroll


can change   min max rng
no lock       1   1   1
zl            1   1   0
sl            0   1   1
zl + sl       0   0   0


what about autoscale y depending on what is on screen

what if I made zoom_lock have 3 values

0 off
1 lock
2 auto

rignt click on axis or scrollbar for options..

mouseover text ...

mouse crosshairs

jump to nearest data position and show data for that...

I want a way to store the units for each axis...
call a fucntion to set msg

right click on stuff to popup menu....done


20230103 back to work...

what are the main things left to do on graph?

units, axis labels, gridlines

nice bounding boxes for all the graph elements
(optional) title and (optional)space for it (probably above but not married to it)

y axis labels (could be on left or right side)
y axis scrollabr (left or right)

x axis labels (could be on top or bottom)
x axis scrollabr (could be up or down)

all of these things are optional

reset range should turn auto off....

need to stack things on the axis...

gridlines and labels
axis label
scrollbar
these should all dynamically size...
then when that is all done, I will have the size of the entire graph area
maybe I can rename that to graph_x y etc... and the other to plot...

graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

these are the main ones that are set outside the class....
then after the width of all the things in the axes are calculated...
then what is left over will be for the plot

call resize at the beginning....

these will never be changed internally:
graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

find out the width needed for axes...

set:
plot_x1
plot_y1
plot_x2
plot_y2
plot_w
plot_h





make a function to auto set positions... for each axis...

void x_axis_draw(void) // does gridlines, labels, axis title and scroll bars

int x_axis_get_size(void) // returns the size needed by x_axis


start with gridlines and labels...
make them all optional




I now have:

void x_axis_draw(void);
void x_axis_get_size(void);
void x_axis_draw_legend(void);
void x_axis_draw_gridlines_and_labels(void);
int  x_axis_draw_scrollbar(void);
void x_axis_proc_scrollbar(void);


called from main draw:

void mwGraph::x_axis_draw(void)
{
   x_axis_draw_gridlines_and_labels();
   x_axis_draw_legend();
   x_axis_draw_scrollbar();
}


I also have:

void mwGraph::process_input(void)
{
   x_axis_proc_scrollbar();

which also calls:

void mwGraph::x_axis_proc_scrollbar(void)
{
   int sb = x_axis_draw_scrollbar();


how are draw and proc called?
like this externally:
mG[0].draw();
mG[0].process_input();

I will probabaly change that later, do I really need to separarte them?

for now I have other things to do:

get the variables for each x_axis element done


int x_axis_label_draw_on;
int x_axis_label_tick_size;
int x_axis_label_text_size;
int x_axis_label_draw_size;



1st get axis sizes
2nd set plot size and pos
3rd set axis pos

do I need a spearate value for actual size, vs stored size
so I can restore if turned on and off...

I think the x axis is looking really good...now work on the y axis

I am very happy with how these look

next I want to have the option of small text on legends
done and now I have a much nicer method for drawing those...


next, I want to always put labels on origins...

done, but sometimes overwrite other axis labels..



make a function to display axis values...

why can't I put mouse on point on the edge of plot?? fixed
also fixed when point text box is draw off screen...

implment units for axis...

x_axis_value_type..

0 = none
1 = time in frames...

this will have a large impact...

depending on the current displayed range,
the units for an axis will change..

the max value displayed could be used to set the units in some cases...n other cases the range...

like for time (frames)
could be frames, sec, minutes...
depending on what range is shown

this will change:
x axis legend
gridlines and labels
point text box...

I need a main title for the legend:
Time
then I need another for units

I could make a type...

type 0 - do nothing
type 1 - customized for frames

made a type..


if 1, where do I check it??

depending on the range I need to set units, divider and legend

where does that naturally happen?
draw
set size and pos
input

none of these actually

how about enforce axis limits?


and what am I going to be setting?

if type 1
use range to set
legend text
divider
units text

add divider...


----------------------

make labels also able to have font
start with x..done
and also reduce space between labels and legend..done

now do y...done...


it gets kind of messy at the origin when I draw labels there that conflict with the auto ones...and the x and y sometimes confict too...

remove x, keep y.. actually fixed origin still conficts with auto...remove (comment out) both for now...








I am happy with this


should I try it on some real data??

what would happen if I tried more data? like a real bandwidth graph...


what if I made the array larger, to include more players


or I could put them all in the main array but tag them with different series...

or I could make an entirely new graph and overlay the data...

all these things I am thinking of would have a common x axis...

should I try to put everything in one array and tag it by series?
or should I have multiple arrays?

with any method, I need to make sure the data is in order



how about a three dimensional array

point[series][x][y]


I want an int for series and doubles for the other two..

looks like a structure

max needed would be 16 if I do 8tx and 8rx



each instance of my class will get this:


struct data_seri
{
   double data[10000][2];
   int num_data;
   int active;
   int color;
   char name[1024];
};
data_seri series[20] = {0};

use like this:
series[0].data[i][0]

wow! that was surpisingly easy to get 8 tx rate lines...

next I need a series legend and the ability to toggle series on and off while the graph is running...

I want to be able to have many other things shown as well...


when setting unlocked, make sure to set autrange off also...

I want to make a nice gui setup for changing things....

like a page of toggles and checkmarks...

maybe some sliders and buttons too..

show legend like:

series number - series name - show the color and line style - click to toggle

bug--scrollbar does not like negative data

removed clear screen from calling loop, handle it internally

I am calling axis_get_size_and_arrange_pos() externally every loop, do I need to?..yes
so call it internally then...
from draw, or proc input?  proc input...

now I only call 3 things externally and one is only in case the user resized the screen...

mG[0].set_graph_pos(0,0, SCREEN_W, SCREEN_H/2-10);
mG[0].draw();
mG[0].process_input();

now back to showing legend for multiple series.......



figure out how to draw dashed line...

https://www.allegro.cc/forums/thread/615463
https://www.allegro.cc/forums/thread/615415



It looks like I can only do al_draw_soft_line on a bitmap, drawing directly to the backbuffer has weird results

so lets try to figure out hpw to do that...


make a bitmap the same size as graph

now make all my draw stuff draw on that, but all coordinates will need to be adjust to 0,0 for graph_x and y

there were surprisingly few references to those..mostly in adjust x amd y axis...

now that I am drawing onto a bitmap instead of the backbuffer, the drawing looks a lot blockier...yay! :(
text looks fine, but the high level primitives (lines) suck...

the gridlines are terriblly blocky and missing in places...

what a goddamn hassle to try to draw dashed lines

there is no godamn reason for it...



how hard would it be to revert now?
and either:
- only draw the plot lines on its own bitmap, or
- figure out how to use soft lines with backbuffer

reverted...

try to figure out how to use soft lines with backbuffer

- does soft line return x and y that make sense?? yes...


if I store all the x and y in an array then draw them outside the function that seems to work...go fig...





now how im I going to implement this?

ideally I would like to call something very similar to draw_line

al_draw_line(100, 110, 200, 110, mColor.pc[15], 1);
mw_draw_line(100, 110, 200, 110, col1, col2);


here it is:

int mw_p[10000][2] = {0};
int mw_i = 0;

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t state, int x, int y)
{
   if (mw_i < 10000)
   {
      mw_p[mw_i][0] = x;
      mw_p[mw_i][1] = y;
      mw_i++;
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, int c1, int c2)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   mw_i = 0;
   al_draw_soft_line(&v1, &v2, (uintptr_t)NULL , mw_FirstFunction , mw_StepFunction , mw_DrawFunction);

   int cycle = 0;
   for (int i=0; i<mw_i; i++)
   {
      int x = mw_p[i][0];
      int y = mw_p[i][1];

      int c = c1;
      if ((cycle % 8) < 4) c = c2;
      cycle++;

//      al_draw_filled_circle(x, y, 1, mColor.pc[c]);
      al_draw_filled_rectangle(x-0.5, y-0.5, x+0.5, y+0.5, mColor.pc[c]);

//   printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
      //al_put_pixel(p[i][0], p[i][1], mColor.pc[p[i][2]]);
   }
}


I am thinking about doing it slightly different...

make my array contain only line segements of the same color

then use the regular al_draw_line to draw those segments...

then I would have less draw calls, and I could use the thickness of lines


values to send to draw:
cycle total
cycle 0 col (default color)

// cycle & total < val color = c1
cycle 1 val
cycle 1 col

8, 15, 4, 10

then when drawing, draw 1 to 0, 2 to 1...etc...

I have it all implemented except for the thinning of call to al_draw_line
it would make it more complicated and im not sure it is needed...

not that complicated

now I need to ensure the last point is not skipped...


int mw_p[10000][3] = {0};
struct mw_state
{
   int num_points;
   int cycle_total;
   int cycle_tally;
   int default_color;
   int c1_val;
   int c1_col;
   int c2_val;
   int c2_col;
};

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t ms1, int x, int y)
{
   struct mw_state* ms = (struct mw_state*) ms1;
   if (ms->num_points < 10000)
   {
      // get color from cycle
      int col = ms->default_color;
      int mod = ms->cycle_tally++ % ms->cycle_total;
      if (mod < ms->c1_val) col = ms->c1_col;
      if (mod < ms->c2_val) col = ms->c2_col;

      // always set these, in case we get to the end and the point is skipped beacuse of duplicate colors
      mw_p[ms->num_points][0] = x;
      mw_p[ms->num_points][1] = y;

      // should i add this point?
      if ((ms->num_points == 0) || (col != mw_p[ms->num_points-1][2])) // if first point, or color different from previous
      {
         mw_p[ms->num_points][2] = col;
         ms->num_points++;
      }
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, float thickness, int cycle_total, int default_color, int c1_val, int c1_col, int c2_val, int c2_col)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   struct mw_state ms;
   ms.num_points = 0;
   ms.cycle_total = cycle_total;
   ms.default_color = default_color;
   ms.c1_val = c1_val;
   ms.c1_col = c1_col;
   ms.c2_val = c2_val;
   ms.c2_col = c2_col;

   al_draw_soft_line(&v1, &v2, (uintptr_t)&ms, mw_FirstFunction, mw_StepFunction, mw_DrawFunction);

   // ensure last point was not skipped, due to duplicate color
   mw_p[ms.num_points][2] = mw_p[ms.num_points-1][2];
   ms.num_points++;


   for (int i=1; i<ms.num_points; i++)
   {
      int x1 = mw_p[i-1][0];
      int y1 = mw_p[i-1][1];
      int x2 = mw_p[i][0];
      int y2 = mw_p[i][1];
      int c =  mw_p[i][2];
      al_draw_line(x1, y1, x2, y2, mColor.pc[c], thickness);
      //printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
   }
}

that was the final iteration...now try it in action!!

see how long it takes...
it is literally 1000 times slower....

plot time: 0.000210   lines drawn:152
plot time: 0.227604   lines drawn:156

I commented out the drawing part...
its not the drawing part, its the call to soft line...

this is useless, but at least now I know it

I just wasted 6 hours on this...

can I make my own code that will do it better?


pass it 2 vertexes
and a span like this:

   int c0_len;
   int c1_col;
   int c1_len;
   int c1_col;

it will create an array of points

point 0 = vertex 1
next point

what math will you use?

total x span
total y span
total length

length of span / color_span = divider

divide xspan and yspan by divider to get incs

do incs and add vertex points...

this is my first hacked together implementaion and it works...
before I go any further, speed test it....


void mw_draw_line2(int x1, int y1, int x2, int y2, float thickness)
{
   int color_span = 10;

   double line_xspan = x2-x1;
   double line_yspan = y2-y1;
   double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

   double div = line_span / color_span; // number of spans

   double xinc = line_xspan / div;
   double yinc = line_yspan / div;

   int xa = x1;
   int ya = y1;

   int xb = xa+xinc;
   int yb = ya+yinc;


   int c = 15;

   while (xa < x2)
   {
      al_draw_line(xa, ya, xb, yb, mColor.pc[c], thickness);
      if (c == 15) c = 10;
      else if (c == 10) c = 15;
      xa+=xinc;
      ya+=yinc;
      xb+=xinc;
      yb+=yinc;
   }
}


plot time: 0.000283   lines drawn:156


I'm back baby! as proof of concept it works and is just as fast as the al_draw_line...

now clean it up....

what if I kept the remainder of the color shift for the next line, that would make the graph look awesome...

I could keep a static int 'distance travelled' and use mod for the cycling repeats

3 colors, just like last one

this will mean a major rewrite of how I do the getting of lines..

it is so simple now because the span is always the same

8 red
3 blue
4 yellow


get inc from main period (14)
get inc from main to 2   (3)
get inc from 2 to 3      (4)

distance_travelled

start with the args...
 int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col))

I have a beautiful three color version working, but no carry over for color shift

plot time: 0.000990   lines drawn:156
plot time: 0.000983   lines drawn:156
plot time: 0.000986   lines drawn:156

now it takes almost 1ms...should I be worried?

it depends on how small the color line segments are


now how will i make this work in the plot? how will I keep track of color?

negative values for color?

2 values for color?

if second one is 0 just draw normally






if (series[s].color2 == 0) al_draw_line(ox, oy, x, y, mColor.pc[series[s].color1], 1.0);
else                       mw_draw_line(ox, oy, x, y, 1.0, 8, series[s].color1, 10, series[s].color2, 0, 0);

wait how??



I think I do want to implement the color shift across lines...when lines are too short, sometimes they dont show at all...


when I zoom in and get more color segments it really slows down...

do all lines draw every time? yes

try thinning....

did the test for x_axis min...works but i want to draw a line to the first offscreen data points

mak a function to get that....

get lowest x and highet x index on screen...
for each series
cycle the dat

that is done...

can I make a way to adjust the color shift span based on size?
I also could make the color shift carry over...

add clicking on series legend....
put series legend in y axis lineup...??
what order? can I assume...

now I want to try the color shift carry over


remainder as a fraction of position in the total color cycle...

maybe there is an easier way...


startxy endxy

get a unit for 1 pixel diagonally converted to x and y

then I can pick any spot on the line and do x,y

then start drawing the line sequence before the actual line

seg1
get ab_positin
static double line_color_offset = 0;
find un


I have finally done it, after much, much work....



20230108 sunday morning

I have the multi-colored line thing working,
the complicated part was the bit where I keep the color sequence going over multiple calls.
this was important so that a graphline made of short segments has a consistant color pattern
and doesn;t just restart the pattern for every line.

to do today...



pop up menu to adjust stuff on series legend, like line size.
config screen that stays overlaid while you change things and see immediate results

move position of mouse over box...done
make only one call to process input and draw
maybe don't redraw every frame, only when changed

when is draw called on its own??
a few times when adjusting things...

when is proc_input called...only externally
added draw to proc_input...seems to work
I still call draw() every frame...

pop up menus...made one for series and cleaned up a bit...

series_legend...

need to make it to fit with all...
series_legend_type
0 autofill
1 8 player array

why does not having at least 1 series initialized cause crash?
range is set to zero and enforce range loops forever
fixed it with an error message if no data
I just need to make sure to set up at least one series when loading data...

or call mG[0].set_series_legend_type(0);
and auto detect...done...

make it so that any arbitrary series can be turned on and off..done...

now do I even need a special mode for type 1...yes...

now on to the big one:
figure out why with short color sequences, especially at the end I have gaps before the first line

what I have discovered is that the color wrap does not work if the end occurs in the first sequence


actually it never works at all...
the next lines always start somwhere in segment 0


where do I use store and use lco?
store it outside the call, the call uses and modifies it

fixing lco made things better...

does not like when c = 0;

when b = 0, it triggers a call to regular line draw..no its when b_col = 0;


trouble shoot c = 0;



in all my checks I am comparing the x and y values separately,
would it not be easier to somehow check the vector...
that is how it is specified...
10 vector units of one color, 5 of another

line is 100 vector pixels

0-9 are one color

10-14 are another

then convert those to x and y at the very last step...

this sounds a lot easier....


I have xa ya xb yb....
I want za and zb, each is just the number of pixels we are on the current line

start:

za = 0; // or previous color shift index
zb = za + c0_val;
do line checks

if (zb < 0)           // off line completely
if (za > line_length) // off line completely

else
if (za<0) adjust za to zero
if (zb>line_length) adjust to line length.

that did not take very long...

test...

c = 0
a = 0
b = 0

all work fine... but the total cannot be zero....
patched into the graph...

now lets make bandwidth graph do its thing

that took like 10 minutes...wow...


now lets do the other one...

client sync actually has 3 graphs...
active
sync
chase

not only that, it has 8 players * 3 graphs

this should be fun...
do three different graphs

0 active
1 sync
2 chase

OK that all works, but now I need to customize the graphs
default values are nice, but I want more control...

like on the active graph, I want to set and lock the y ranges...


now I want to slave the x ranges to a different graph


x_axis_slave

100 slave to 0
101 slave to 1...etc..

where to check...proc x scroll bar...done

now I also need to make sure plot_x1 lines up for all slaved plots...
still need to make these work together


make a copy of original bad method in note then erase it//done

try a version with only 2 colors to see if its faster...less segements by 1/3 but not faster...













/*
original bad mnethod, actually the second....

// returns 1 if end adjust...
int check_and_draw(double x1, double y1, double x2, double y2, double xa, double ya, double xb, double yb, double line_xinc, double line_yinc, int col, float thickness, int &segments_drawn, int &lco)
{
   char t[1024] = {0};
   sprintf(t, "\n");


   int skip = 0;
   int start_adj = 0;
   int end_adj = 0;

   // these checks mean that the segment is entirely not on the line
   if (((line_xinc > 0) && (xb < x1)) || ((line_xinc < 0) && (xb > x1))) skip = 1; // xb before line start
   if (((line_xinc > 0) && (xa > x2)) || ((line_xinc < 0) && (xa < x2))) skip = 2; // xa after line end
   if (((line_yinc > 0) && (yb < y1)) || ((line_yinc < 0) && (yb > y1))) skip = 1; // yb before line start
   if (((line_yinc > 0) && (ya > y2)) || ((line_yinc < 0) && (ya < y2))) skip = 2; // ya after line end

   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (((line_xinc > 0) && (xa < x1)) || ((line_xinc < 0) && (xa > x1))) start_adj = 1; // xa is before line start
      if (((line_yinc > 0) && (ya < y1)) || ((line_yinc < 0) && (ya > y1))) start_adj = 1; // ya is before line start

      if (((line_xinc > 0) && (xb > x2)) || ((line_xinc < 0) && (xb < x2))) end_adj = 1; // xb is after line end
      if (((line_yinc > 0) && (yb > y2)) || ((line_yinc < 0) && (yb < y2))) end_adj = 1; // yb is after line end

      if (start_adj)
      {
         sprintf(t, "start_adj\n");
         xa = x1;
         ya = y1;
      }
      if (end_adj)
      {
         int xlo = abs(x2-xb);
         int ylo = abs(y2-yb);

         if (xlo>ylo) lco = xlo;
         else         lco = ylo;

         sprintf(t, "end_adj - lco:%d\n", lco);
         xb = x2;
         yb = y2;
      }


      printf("%s   drawn at xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f\n", t, xa, ya, xb, yb);


      al_draw_line(xa, ya, xb, yb, mColor.pc[col], thickness);
      segments_drawn++;



   }

  // if (skip == 2) end_adj = 1;

   return end_adj;
}



int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
  // printf("mw_dl x1:%f y1:%f x2:%f y2:%f\n", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion

   int segments_drawn = 0;

   if (c1_col == 0) al_draw_line(x1, y1, x2, y2, mColor.pc[c0_col], thickness);
   else
   {
      int color_span = c0_val + c1_val + c2_val;
      printf("\nlco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span

      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_span != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         // one unit of these are one unit of vector move
         double line_xinc = line_xspan / line_span;
         double line_yinc = line_yspan / line_span;

         int section = 0;

         while (!done)
         {
            printf("\nSection:%d\n", section);


            // draw first segment
            double xa = x1 + ((section * color_span) - line_color_offset) * line_xinc; // start position for drawing
            double ya = y1 + ((section * color_span) - line_color_offset) * line_yinc;
            double xb = xa + c0_val * line_xinc;
            double yb = ya + c0_val * line_yinc;

            printf("1st segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
            if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = color_span - c1_val - c0_val - lco;
            }
            if (!done)
            {
               // draw second segment
               xa = x1 + ((section * color_span) - line_color_offset + c0_val) * line_xinc; // start position for drawing
               ya = y1 + ((section * color_span) - line_color_offset + c0_val) * line_yinc; // start position for drawing
               xb = xa + (c1_val) * line_xinc;
               yb = ya + (c1_val) * line_yinc;
               printf("2nd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
               if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c1_col, thickness, segments_drawn, lco))
               {
                  done = 1;
                  line_color_offset = color_span - c1_val - lco;
               }
               if (!done)
               {
                  // draw third segment
                  xa = x1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_xinc; // start position for drawing
                  ya = y1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_yinc; // start position for drawing
                  xb = xa + (c2_val) * line_xinc;
                  yb = ya + (c2_val) * line_yinc;
                  printf("3rd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
                  if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c2_col, thickness, segments_drawn, lco))
                  {
                     done = 1;
                     line_color_offset = color_span - lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}
*/

good method....




int check_and_draw(double x1, double y1, double line_length, double line_xinc, double line_yinc, double za, double zb, int col, float thickness, int &segments_drawn, int &lco)
{
   int debug_print = 0;
   char t[1024] = {0};
   sprintf(t, "\n");
   int skip = 0;
   int end_adj = 0;
   // these checks mean that the segment is entirely not on the line
   if (za > line_length) skip = 1; // za after line end
   if (zb < 0)           skip = 1; // zb before line start
   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (za < 0) // za is before line start
      {
         if (debug_print) sprintf(t, "start_adj\n");
         za = 0;
      }
      if (zb > line_length) // zb is after line end
      {
         lco = line_length - zb;
         if (debug_print) sprintf(t, "end_adj - lco:%d\n", lco);
         zb = line_length;
         end_adj = 1;
      }
      double xa = x1 + za * line_xinc; // convert to screen coordinates
      double ya = y1 + za * line_yinc;
      double xb = x1 + zb * line_xinc;
      double yb = y1 + zb * line_yinc;
      if (debug_print) printf("%s   drawn at za:%3.0f zb:%3.0f\n", t, za, zb);
      al_draw_line(xa, ya, xb, yb, mColor.pc[col], thickness);
      segments_drawn++;
   }
   return end_adj;
}

int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
   int debug_print = 0;

   if (debug_print) printf("\nmw_dl x1:%3.1f y1:%3.1f x2:%3.1f y2:%3.1f ", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion
   int segments_drawn = 0;

   int color_span = c0_val + c1_val + c2_val;
   if ((color_span < 1) || ((c1_col == 0) && (c2_col == 0))) al_draw_line(x1, y1, x2, y2, mColor.pc[c0_col], thickness);
   else
   {
      if (debug_print) printf("lco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span
      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_length = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_length != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         double line_xinc = line_xspan / line_length; // one unit of these are one unit of vector move
         double line_yinc = line_yspan / line_length;
         int section = 0;
         while (!done)
         {
            if (debug_print) printf("Section:%d\n", section);
            double section_z_start = ((section-1) * color_span) - line_color_offset;

            double za = section_z_start;   // start position for drawing 1st segment
            double zb = za + c0_val;
            if (debug_print) printf("1st segment za:%3.0f zb:%3.0f ", za, zb);
            if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = lco - c2_val - c1_val;
            }
            if (!done)
            {
               za = section_z_start + c0_val;   // start position for drawing 2nd segment
               zb = za + c1_val;
               if (debug_print) printf("2nd segment za:%3.0f zb:%3.0f ", za, zb);
               if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c1_col, thickness, segments_drawn, lco))
               {
                   done = 1;
                   line_color_offset = lco - c2_val;
               }
               if (!done)
               {
                  za = section_z_start + c0_val + c1_val;   // start position for drawing 3rd segment
                  zb = za + c2_val;
                  if (debug_print) printf("3rd segment za:%3.0f zb:%3.0f ", za, zb);
                  if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c2_col, thickness, segments_drawn, lco))
                  {
                      done = 1;
                      line_color_offset = lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}




add pop up menu to plot area or series legend to thin number of segments or change to solid color.
changing from a segmented line to solid only make a small change

show hide segments drawn and time taken..




amke y xais arrange customizable...

if axis slaved, make it so the plot_x1 follows master
gridlines and label are always anchored to plot

on slaves, don't show x axis legends



remove y scrollbar for active...

put dsync on bottom and make it the master

active on top

make a y axis label type for active

slave series legend...just copy x_axis_slave

thin out player active....done

make it so that you can still see series legend on slave and change things, but only master can change active...

make it so that number of points on series legend is optional....done
also plot time optional

hide and show series legend from main plot popup menu...done

main plot pop up menu..done


fix the double drawing nonsense on the scroll bars....

remove from draw because proc calls draw...
double shit is gone, but now I have no mouse cursors

they are fixed but the mouse over is done....

make nice colors match...done


make units from pointer data and stuff work nicely wit ha few new types



I have a bigger issue...

I cant quite figure out in what order to do all the things....

I have moved everything in the draw function....

but that is bad because sometimes I call that recursively when moving stuff...


I need to separate the draw from the input....

also what about the checking of variables??


lets start with the most obvious

draw_plot() and
process_mouse_on_plot() (which also draws on plot)

obviously the plot area has to be drawn first, then the stuff on top, or it will never be seen

I should merge these two....
and have a draw only option for when I have call to it recursively

void proc_plot_area(int draw_only)
{
   draw

   if ()!draw_only)

   proc mouse on graph

}


do the same with scrollbars

have one entry point and an option to draw only...

then have draw itself have an option to draw only

void mwGraph::y_axis_proc_scrollbar(void)
{
      int sb = y_axis_draw_scrollbar(0);

now I have one entry point:
mG[].proc_graph(void)

all it does is call:
draw_graph(int draw_only)

and that calls:

x_axis_get_size_and_arrange_pos();
y_axis_get_size_and_arrange_pos();
enforce_axis_limits();

al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color+224]); // erase plot background
al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color], 2); // frame plot

x_axis_draw();
y_axis_draw();


x_axis_proc_scrollbar(draw_only);
y_axis_proc_scrollbar(draw_only);

proc_plot_area(draw_only);

draw_title(0);
draw_series_legend();

this seems to work pretty good

can I refine it? yes I can...

void mwGraph::draw_graph(int draw_only)
{
   al_show_mouse_cursor(display);
   if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2))
      al_set_system_mouse_cursor(display, ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT);

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


it looks really good now....

make nice title and colors for bandwidth..done
make bandwidth have option for 2 graph (tx and rx)..done
make a way to slave y axis range also...done...

make units for all types look good...

y axis
tx = 1
rx = 2
dsync = 3
FPS = 4

done....


add reset all to plot menu

add resize slider in between graphs...done...added to bandwidth...

make is so when x_axis_slave, can't even slide x axis a little bit...done

make it so if y legend does not fit on screen, auto set to smaller font...


make a way to not draw x_axis labels and reclaim space....

I think I might need to properly separate gridline and labels
right now I kind of lump them together

I still want to draw them together, but the variable used to control whether tey are draw or not are overly complicated


this is what I have now:
int  x_axis_label_draw_on;
int  x_axis_label_font;
int  x_axis_label_draw_size;
int  x_axis_label_tick_size;
int  x_axis_label_text_size;
int  x_axis_label_text_draw;
int  x_axis_label_color;

change to:
int x_axis_grid_draw_on
int x_axis_grid_color
int x_axis_grid_labels_draw_on
int x_axis_grid_labels_font
int x_axis_grid_labels_color
int x_axis_grid_labels_draw_size
int x_axis_grid_labels_tick_size
int x_axis_grid_labels_text_size


this is done and it works way better

add one more...
int x_axis_grid_draw_to_top_of_other_graph...why bother...

removed the lock, unlock, auto button...

now clean up the y axis the same way...

old
int y_axis_label_draw_on;
int y_axis_label_font;
int y_axis_grid_label_draw_size;
int y_axis_label_tick_size;
int y_axis_label_text_size;
int y_axis_label_text_draw;
int y_axis_label_color;

new
int y_axis_grid_draw_on
int y_axis_grid_color
int y_axis_grid_label_draw_on
int y_axis_grid_label_font
int y_axis_grid_label_color
int y_axis_grid_label_draw_size
int y_axis_grid_label_tick_size
int y_axis_grid_label_text_size

fixed some weirdness in void mwGraph::y_axis_get_size_and_arrange_pos(void)
now it's much simpler

add reset to main menu...done...



add x_axis_top_graph_gridline...done...

now it matter in what order thing are drawn in
the graph that draws the gridlines, needs to be last or the other plots will overwrite them
also when thet are draw, they draw on top of everything else....
not sure if this was a good idea...removed....


how about the mouse position on any graph is sent to the others so they can show that x position on their graph too...

how will I go about linking them?

make a series number that they can share
if the mouse is diplaying a point, send that to all others in the same series

all others look for shared values when they don't have mouse...

each graph could have a

if graph does not have the mouse, they are listening
if graph does have the mouse, they sending


all I need to link is x_cursor_pos...

any of the linked ones can set all other linked ones...


code:
if mouse on plot, set x_cursor_pos on all others..
if mouse not on plot read x_cursor pos...

this could work...

vars

int linked_group_id;
double x_axis_cursor_pos;

ok fine, try it




x_axis_cursor_pos = -99999;

if mouse is on graph, but not on plot set all local and remote to dont show value

if mouse is not on graph at all, read and use value from local

if mouse is on plot, set local and send to all linked

have a common place to draw....



i need a function that you pass it only an x position
and you get:

0 = no data at that x point
1 = scaled y position at that point
2 = closest point (less tham threshold)

this is getting complicated....

i could have mutiple y matches for x at the destination

keep it simple...

do only the line....done

         else // show mouse position
         {
            col = 15;
            x = mI.mouse_x;
            y = mI.mouse_y;
            draw_point_data(x, y, mx1, my1, col, f3, -1);
         }
         if (linked_group_id)
         {
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = x;
         }


      } // end of mouse on plot area
      else // mouse not on plot area
      {
         if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2)) // not on plot, but on graph
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = 99999; // set all linked cursors to not valid

         if (x_axis_cursor_pos > -99998)
            al_draw_line(x_axis_cursor_pos, plot_y1, x_axis_cursor_pos, plot_y2, mColor.pc[15], 0); // draw if valid
      }



that is done...now add it to bandwidth graph...done....



test graph on weak clients...it seems really slow  can take up to 800ms to plot
in that case I could automatically reduce the x range....


is there anything else in the logs I could graph?




make a client sync graph from the clients point of view:
fps chase
dsysnc
ping
what log line am I basing this on?

the server only has data when the client sends stak but the client should have much more data than that...


it looks like the client only adjust timer when rxing stdf....

I thought it would happen more often...but what does it have to sync with?

I suppose we could use ping...

I want to do a ping vs dsync from the client's pov


there are three things on the client...

ping
sync target
acually sync

I think a graph of those might be insightful

where does it happen and what are the vars again??


in client_fast_packet_loop:
players1[active_local_player].ping = t2 - t0;
ping_array_add(players1[active_local_player].ping);
I should add a log entry for this...

then what?

void client_timer_adjust(void)
{
   int p = active_local_player;
   double dsync = players1[p].dsync - players1[p].client_chase_offset; // adjust for target offset
   double fps_adj = dsync * 100; // make the change bigger

   float fps_chase = frame_speed + fps_adj;
   if (fps_chase < 10) fps_chase = 10; // never let this go negative
   if (fps_chase > 70) fps_chase = 70;
   al_set_timer_speed(fps_timer, ( 1 / fps_chase));
   players1[p].client_chase_fps = fps_chase;
}




where is offset calculated...

in ping array add....

places for log inputs:
- stdf rx (dysnc, fps_chase) this is already done...
- add ping... (ping_curr, ping avg, offset)


add one in timer adjust....


36 tmaj // timer adjust
37 cpng // client ping


sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", dsync, players1[p].client_chase_offset, fps_chase);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(36, p, msg);

sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping, players1[p].ping_avg);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(37, p, msg);


OK I have some log lines, now lets make a graph....




I need a way to get value for y axis....


just throw a values and it will know how to print it...

i think I started one of those already....
char* mwGraph::y_axis_get_val_text(double val, int units)


dsync is huge at the start....how about we don't actually use it to set fps until after initial state is received and chase starts....




clean up the number formating stuff+...

int y_axis_type
set for different types

y_axis_type
y_axis_legend
y_axis_units
y_axis_divider

The name you give to legend, should not ever automatically change
however the units may depending on type...

at init:
set name, units name, divider,

now I only have types 1 and 2 that change units
they do that in enforce_axis_limits(5)


all the rest should be handled in:
char* mwGraph::y_axis_get_val_text(double val, int units)

this should not change units, just print formating

type 3 for all ms
type 4 for FPS

check where thet are all set...done...



now what else can I monitor??

on the server, late cdat dropped


d 3-1 30s 1c

e 3-1 at 15s 3-1 ic




why? on my latest test graph, do the 2 graphs not line up vertically?

im guessing something to do with enforce limits.....
can i disable it for x axis on slaves...
made it so that plot can start before data....
this broke scrollbars, now ends are past...
2 ways to fix...
adjust only scrollbar ends to b not past data max...
adjust data max be larger
add new variable data display max and min
set clip...

try set_clip...

also disable slaving of series legend tied to x axis slaving...done


make it so that you can see status of things in menu...
make the main menu do everything
like locking x and y axis and show status of locking...
Y axis: free move / locked / auto range
unlock/lock Y axis
set y ais auto range..

done and it looks way better...

can you also lock x axis?
autoscroll does not make sense for x axis, but lock would be nice so I could zoom and move y without moving x...

I don't think I need menus for scroll bars any more, comment out for now....

added this....

   // min, max, and range for min and max displayable range (used for limits on axis, instead of using data)
   double x_disp_min;
   double x_disp_max;
   double x_disp_rng;
   double y_disp_min;
   double y_disp_max;
   double y_disp_rng;


cleaned up the scroll bar code a lot...





am I drawing scroll bars twice?


proc_plot_area calls

x and y axis_draw
then draws plot

x and y axis_draw call grid and labels, legend and scroll bars
this seems like too much...

where are they arranged?

down the fucking rabbit hole!!

proc_graph -> draw_graph ->

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


this all works but seems overly complicated

gridlines and labels have always had to be drawn before plot...
well...I don't want to separate gridlines and labels...
but they need to be done after old plot is erased and before data is plotted...
make it a part of draw plot??

this is the way it is now:
void mwGraph::proc_plot_area(int draw_only)
{
   al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color+224]); // erase plot background
   al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mColor.pc[title_frame_color], 2);         // frame plot

   x_axis_draw();
   y_axis_draw();

   draw_plot_area();

I want to replace
   x_axis_draw();
   y_axis_draw();


with just the labels and gridlines

leaving legend and scroll bars for somehwere else...done...much better now...

bool mouse_on_graph;
bool mouse_on_scrollbar;

done...awesome!!

make x axis use get text...done


still have issues with labels, now the first one less than 0 does not show.....



I'm sure its my rounding function

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 =  nr + (in - tmp);
   if (nr2 < 0) nr2 -= nr; // hack because negatives were rounding too high
   printf("in:%f  nr:%f  nr2:%f\n", in, nr, nr2);
   return nr2;
}

what is it supposed to do?

round 'in' up to the nearest 'nr'

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 = (in - tmp) + nr;
   if (tmp < 0) nr2 -= nr; // hack because negatives were rounding too high
   //printf("in:% 5.1f  out:% 5.1f  tmp:% 3.1f\n", in, nr2, tmp);
   return nr2;
}
this is the fix....nice...
auto reduce legend font if too tall, also clip so it won't exceed graph..done for y and x
make x legend do name and units like y....done

make split bar invisible until mouse over...
remove top padding for graph....


20220110 1:11PM

graph is done....


put chase and ping into main log thing

make sure the other graphs still work nice

separate the load part of each graph
fail gracefully if no data found..


how to check for no data...


I could use
void mwGraph::calc_data_range(void)
yes...but need to set series first...done...

now do the same for bandwidth graph...


erased all the old graph stuff from z_logs.cpp...1500+ lines gone
now the entire z_logs.cpp is around 1500 lines...

made it very easy to load graphs....

from log file viewer:
log_bandwidth_graph(int num_lines, int both);
log_client_server_sync_graph(int num_lines);
log_ping_graph(int num_lines);

from anywhere else:
log_bandwidth_graph(load_log_lines_array_from_static_file("logs/a.txt"), 0);
log_client_server_sync_graph(load_log_lines_array_from_static_file("logs/a.txt"));
log_ping_graph(load_log_lines_array_from_static_file("logs/e.txt"));

I use this function in 4 places:
int load_log_lines_array_from_static_file(const char* f));
it loads:
extern char log_lines[NUM_LOG_LINES][100]; // for log file viewer
extern int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer

this makes things much simpler...



now clean up the other 2 graphs:

bandwidth
make nice splitter
why no x gridlines on upper
done...

client sync...looks good...

now the only thing left is the three way splitter...done

bug... when x axis is locked, disable x scroll bar...done....

we are way further along now.....

can I call the graph thing done? yes...

now what?

log:
when the server gets late cdats?
the current s1 and s2 values on the server...
when clients base is reset

how about some code profiling...

draw_time
move time
decompress time

I am going to make the busiest level I can imagine...

how do I get the default menu back on level editor after I come back...done...

bug on graph.. y axis scroll bars draw off their range. it was a bug I inadvertantly introduced when making type 3 for active...fixed...



what do I have for my timer thing...

I have 10,000 of these

struct timestamp
{
   int frame0;
   int frame1;
   int frame2;
   int type;
   double t0;
   double t1;
   double t2;
};


how was i supposed to use them?

void add_timestamp(int type, int f1, int f2, double t1, double t2)
{
   if (timestamps_index < 9998)
   {
      timestamps[timestamps_index].frame0 = mwPS.frame_num;
      timestamps[timestamps_index].frame1 = f1;
      timestamps[timestamps_index].frame2 = f2;
      timestamps[timestamps_index].type   = type;
      timestamps[timestamps_index].t0     = al_get_time();
      timestamps[timestamps_index].t1     = t1;
      timestamps[timestamps_index].t2     = t2;

      timestamps_index++;
   }
}

            add_timestamp(1, 0,0,0,0);
            timestamp_frame_start = al_get_time();

            proc_timer_adjust();

            proc_scale_factor_change();

            if (ima_server) server_control();
            if (ima_client) client_control();

            proc_player_input();
            proc_game_moves_array();

            if (players[0].level_done_mode) proc_level_done_mode();
            else
            {
               //add_timestamp(5, 0,0,0,0);
               move_frame(0);
               //add_timestamp(6, 0,0,0,0);
            }

            if (players1[0].server_send_dif) server_send_stdf();



//            if (get_delta(mwPS.frame_num,   3, mwPS.frame_num,   4, res)) printf("time in draw: %5.1f us\n", res*1000000);
//            if (get_delta(mwPS.frame_num,   1, mwPS.frame_num,   2, res)) printf("time in move: %5.1f us\n", res*1000000);
//
//            if (get_delta(mwPS.frame_num-2, 1, mwPS.frame_num-1, 1, res)) printf("total fram time: %5.1f us\n", res*1000000);




now that I have the mwPS.frame_num inc at the very start of every frame it should make timing easier.


I don't know why I have multiple frame numbers in the structure

most of the time I just use the current frame number and the current timestamp


so lets do it...

take some times and plot them...

I want to have a log entry every frame

how many timestamps per frame?

lets say 10, that would give me 1000 frames or 250s or just over 4 min...

that's a good start

time for a new log entry...44

holy shit that was fast!
I got some profile timestamps, made a new log entry and made a dual graph to view them both: draw time and move time
It only took about 1H to do all that, because of all the framework I have in place...nice...

I can't wait to profile more things....

but I am going to do a push, then get a hot drink...

20230110 10:15PM


do a timer for server send stdf
one for each client...or all together?

they will all be on the same frame, but with different player numbers

I can probably do this one in line, without the timer struct...

use tag 45...

more data...like was the base reset? how many packets...

[45][1][169]tmst [1.368000] [0] [835] [1]
[45][1][172]tmst [1.355800] [0] [792] [1]
[45][1][175]tmst [1.369900] [0] [800] [1]
[45][1][178]tmst [1.347400] [0] [704] [1]
[45][1][181]tmst [1.367600] [0] [804] [1]
[45][1][184]tmst [1.369800] [0] [799] [1]

I could plot all these on the same graph if /1000 for 3...do it...

20230111 7:41AM


I want to make a different, easier way to get these profiling timestamps into a graph..


Maybe I could tag each one like td:[] tm:[] stdf:[]

then I will need a tag reader than can get the text before...

I can have multiple log file lines that all have the code 45 tmst

they can all go on the same graph beacuse they all have the same units

I have the very basic framwork in place....


I want to make a new gui element.
I will act exactly like button toggle but will look different
[] - name


I have the logging options page looking really good...
what other pages?

sound, color, splash screen

controllers

netgame options

make multiple tabbed pages...

this should be fun

in the end it will be so much easier to add new options, so many more that I have not even thought about....

make it look good...


I think I have all the functionality for controls except for set indivual

now I need to make it look good..


make the list of keys more centered but still left justified
add a button to the left of each key, 'new' which prompts to set that one control

I want my own function to redraw all keys....done...

what is the maxiumun text length of key_names[]? 11 PRINTSCREEN
make it so that this displays nicely....
press new control is 17....

page for controllers is setup and looks great!!

next, nextgame??
all the controls are in place and working...now make it look good...


display server name and give a text description

Server Name: ....

Clients must have the server name or IP address set here.


OK...config page for netgame is done...


This is looking very nice...how are you going to patch it into the game_menu?
I think I should have an overall larger background and title:

Like 'Configuration'

make it a fixed width of 400,400


do I need a large size for the frame, tabs, and title??

Yes, obviosly....

OK what am I going to name them?

Do I have an actual minimun size for the useable pages?

can I go up from there??

sure why not?

add tab height and title height

that should do it...


I don't know where am going to patch it into the menu...
it seems like it is already pretty busy...

put it on the options menu for now and have a hotkey to bring it up any time from any menu....ok...
CTRL SHIFT O


i like it....

when it gets full I will need to have a second row of tabs...


I have changed my mind...


I want to start with the full outer size and then shrink it as I move in...

what are my varaible going to be called?


this is all I have for now:



   int cfp_x1 = 200;
   int cfp_y1 = 200;
   int cfp_x2 = 600;
   int cfp_y2 = 600;
   int cfp_txc = cfp_x1 + (cfp_x2 - cfp_x1) / 2;



I think I will keep these vars...

entire thing:
cf_x1
cf_w
cf_x2
cf_y1
cf_y2
cf_h

then I will figure out the borders, tab height, title height, and then finally set:

cfp_x1
cfp_w
cfp_x2
cfp_y1
cfp_y2
cfp_h

for the display area of the pages


goddamn this looksg good...


what else can I add?

sound
color
splash screen


today:
finish basic page..done
make advanced page
add help buttons to pages...
think about re-arranging menus to make simpler

do I have enough tabs??..yes


what wil go on advanced?
speed
disable timed demo mode...
show hysteris box...

what is left on the options menu that I don't have in config pages?

   strcpy (global_string[8][3], "Netgame Options");
   strcpy (global_string[8][4], "<-Change Color->");
   strcpy (global_string[8][5], "Controller Setup");
   strcpy (global_string[8][6], "Speed:40fps");
   strcpy (global_string[8][7], "Sound:Off");
   strcpy (global_string[8][8], "Sound Effects Volume:9");
   strcpy (global_string[8][9], "Sound Track Volume:9");
   strcpy (global_string[8][10], "Logging Options");
   strcpy (global_string[8][11], "Splash Screen:ON");
   strcpy (global_string[8][12], "Save Demo");
   strcpy (global_string[8][13], "Run Demo");
   strcpy (global_string[8][14], "Configuration Pages");
   strcpy (global_string[8][15], "end");

speed
save demo
run demo

I could have a tab just for demo...
run
save
disable timed demo
options for auto save

yes, do this...then options menu can go away totally and be replaced with config pages on main menu....

Maybe it could be renamed to 'Settings'...that seems more generic and apt and standard...done

here is the thing...

running demo from these pages is not as simple as just calling a function...

we are in menu, then in config, how to get back to where the game runs??

we have to:
- set next program mode
- quit config
- quit zmenu


I guess this all depends on where config_pages is called from...

lets make sure it is always called from zmenu...
then we can figure out how to handle return...
called from:
args
zmenu CTRL O
game_menu options 14

for now just do CTRL O

if I can make config pages return something...

maybe the zmenu was not better choice..another layer deep...

make the CTRL O call option 14 then deal with it there for now in game menu

maybe I am doing this wrong...maybe config pages ahould be another program_state

something that I can return to, like command line and zmenu

that seem a little less hacky...

from menu, leave menu and do configpages..from there do run games...

   if (program_state == 3) config_pages();  // this blocks


ok it gets there, but how does it get back??

replace OPTIONS MENU with SETTING and then it will come back there...


coming back from playing demo does not come back to config, it come back to menu...why??


it seems like a lot of things set old_program_state...too many


like for instance it is set when rungame_key_check exits...it is set to 1...why?  how does it know what called it?

where are the places it should be set?


0 when delared
then if called from command line it will know where to go

1 when starting game_menu

2 when starting demo mode

3 when starting config...

those are the only places it should be set....

it is used when leaving a running game to determine where to go back to....




This is what actually is in place:

int old_program_state = 1;

when game_menu() starts
old_program_state = 1;



when demo_mode loads a level and plays it
new_program_state = 14;
old_program_state = 2;

if demo mode fails to load level
new_program_state = 1;
old_program_state = 1;


when config starts rungame
new_program_state = 14;
old_program_state = 3;

when config ends with ESC
new_program_state = 1;
old_program_state = 1;

rungame_key_check
new_program_state = 1;
does not set old....


OK this is looking a little better...


start game, start config, rungame from file...

exit with any key..goes back to config...good

exit with ESC key..skips past config to menu...fix this
added this in rungame_key_check to eat ESC
while (mI.key[ALLEGRO_KEY_ESCAPE][0]) proc_controllers();

now it does stimp and goes back to config....
from there you can run another file...

this all works great...

but when you leave config for menu, stimp is called again...
happens every time config to menu....fixed
if (program_state != 3) stamp();


that was the last thing from options menu...time to retire it....

and at the same time...call it settings...
settings_pages


top_men_sel == 7 // settings

CTRL SHIFT O from zmenu as a shortcut

commented out all option menu stuff in game menu

returns to setting selection when leaving config..

wow! all of this works so good...

I will miss wacthing the title screen change immediatley when changing player color....


should I alway have that background behind settings_pages?yes
the only other possible thing would be a partially played demo level....
do it...
call frame and title and make sure settings is centered also....done...

you know what would be amazing?
If I could center the title 'Settings' on the menu item 'Settings'
how do I know where that is?
set_map_vars()
done....
now can I show the menu text only....done

now hide the mouse when leaving settings..done

rename...done...

now make that goddamn demo_mode time able to be disabled



what variables?


demo_mode_countdown_val;
demo_mode_countdown_reset;

demo_mode_enabled

int demo_mode_enabled = 1; when declared

then set to zero:
if resume allowed
if any menu key is moved
if demo mode times out and starts


i suppose I could read this value from config file

default it to 1 and if player turns it off in config...

the problem is...any time config file is read, it gets turned back on...

make a separate config file varibale and only use it to set the global one once at startup..

this is getting confusing!!

demo_mode_config_enable

extern int demo_mode_config_enable;
now use it in initial_setup() to set  demo_mode_enabled
this is all done!!!

next, demo mode....
when trying to exit, it quits the current level and immediately plays next....

in rungame_key_check:

      new_program_state = 1;
      if (old_program_state == 2) old_program_state = 1; // don't send back to demo mode if cancelled

this seems to have fixed it....



now, does it work from settings....yes, but it comes back to menu, not settings...big deal....
when demo mode starts it sets old_program_state to 2..in this way we do not know what started demo mode
it could be menu or settings

do I want yet another variable to track this?
some humor 'older_program_state'

used only when starting demo mode
3 from settings
1 from menu

then when demo mode is cancelled from rungame_key_check it can set the appropriate place to return to...

new_program_state = 1;
if (old_program_state == 2) old_program_state = older_program_state; // don't send back to demo mode

done and it works perfectly....

now to make demo tab look nicer.. looking pretty good!!!


now how many things call zmenu? only one: top
old ones:
options
logging
netgame
controller



put speed on advanced tab...done

also by default make the speed locked, disabling function key
also speed is never saved to config file

add DEMO MODE overlay transparency option to demo tab...and config file...done

add other hysteris mode stuff somewhere


now that I have everything from option menu on the settings page....

I have so many more things I want to put there....

but first...

lets see what it would take to get more tabs....

and a second row....

maybe an optional second row...

erased options menu...now game menu is <70 lines

going through code and removing unneeded references to global_string....


why don;t I make a struct for each tab...then make an array of structs
done and its looking good...



I want to see how hard it is to draw a filled polygon with allegro primitives....

float v[4][2] = {0};

v[0][0] = 100;
v[0][1] = 100;

v[1][0] = 100;
v[1][1] = 200;

v[2][0] = 200;
v[2][1] = 200;

v[3][0] = 200;
v[3][1] = 100;

al_draw_filled_polygon(*v, 4, mColor.pc[14]);

this is all it takes....

now use that to draw tabs....done...

that looks so much better...


now what?

rename the logging netplay things and add more....


now I have game_menu down to 25 lines!!!

// z_game_menu.cpp
#include "pm.h"
void game_menu(void)
{
   old_program_state = 1;
   if (!splash_screen_done) { splash_screen(); splash_screen_done = 1; }
   if (!resume_allowed) load_level(start_level, 0);
   if (top_menu_sel < 3) top_menu_sel = 3;
   while (top_menu_sel != 1)
   {
      top_menu_sel = zmenu(7, top_menu_sel, 10);
      if  (top_menu_sel == 1)  { program_state = 0;                                           return; } // exit
      if  (top_menu_sel == 2)  { visual_level_select(); top_menu_sel = 3;                             } // visual level select
      if ((top_menu_sel == 4) && (resume_allowed)) { new_program_state = 13;                  return; } // resume game
      if  (top_menu_sel == 3)  { new_program_state = 10;  top_menu_sel = 4;                   return; } // start new game
      if  (top_menu_sel == 5)  { new_program_state = 20;                                      return; } // host network game
      if  (top_menu_sel == 6)  { new_program_state = 24;                                      return; } // join network game
      if  (top_menu_sel == 7)  { new_program_state = 3;                                       return; } // settings
      if  (top_menu_sel == 8)  { play_level = edit_menu(start_level); new_program_state = 10; return; } // level editor
      if  (top_menu_sel == 9)  { new_program_state = 2;  older_program_state = 1;             return; } // demo mode
      if  (top_menu_sel == 10)                                                                help(""); // help
      if (top_menu_sel == 102) if (++start_level > 399) start_level = 399; // start level inc
      if (top_menu_sel == 202) if (--start_level < 1) start_level = 1;     // start level dec
      if (top_menu_sel > 100) { set_start_level(start_level); load_level(start_level, 0); top_menu_sel = 2; }
   }
}



these are the config names:
LOGGING_NETPLAY);
LOGGING_NETPLAY_JOIN);
LOGGING_NETPLAY_PLAYER_ARRAY);
LOGGING_NETPLAY_bandwidth);
LOGGING_NETPLAY_cdat);
LOGGING_NETPLAY_game_move);
LOGGING_NETPLAY_sdat);
LOGGING_NETPLAY_sdak);
LOGGING_NETPLAY_stdf);
LOGGING_NETPLAY_stdf_all_packets);
LOGGING_NETPLAY_stdf_when_to_apply);
LOGGING_NETPLAY_show_dif1);
LOGGING_NETPLAY_show_dif2);


extern int L_LOGGING_NETPLAY;
extern int L_LOGGING_NETPLAY_JOIN;
extern int L_LOGGING_NETPLAY_PLAYER_ARRAY;
extern int L_LOGGING_NETPLAY_bandwidth;
extern int L_LOGGING_NETPLAY_cdat;
extern int L_LOGGING_NETPLAY_game_move;
extern int L_LOGGING_NETPLAY_sdat;
extern int L_LOGGING_NETPLAY_sdak;
extern int L_LOGGING_NETPLAY_stdf;
extern int L_LOGGING_NETPLAY_stdf_all_packets;
extern int L_LOGGING_NETPLAY_stdf_when_to_apply;
extern int L_LOGGING_NETPLAY_show_dif1;
extern int L_LOGGING_NETPLAY_show_dif2;


I want to make this simpler:

variables:
LOG_NET_xxx

config
CLOG_NET

and make them all lower case after the _

replace:

L_LOGGING_NETPLAY_
LOG_NET_

do it: 75 replaced  still compiles


now replace
LOGGING_NETPLAY
CLOG

wait why??
they can have the exact same name, i do it all the time in config..same variable name and config name
OK

replace
LOGGING_NETPLAY
LOG_NET

OK done.. now do lower case for JOIN and PLAYER_ARRAY

ok that's all done too:

demo mode is not on by default...fixed...


keep a list in to do of other things to add to settings....


many of them will require:
- making a global variable
- saving it in config
- making a way to change it in settings

how about 'send stat to console'

made a lot of those....




what do I call the hyst thing?
lakitu
viewport

lets go with viewport

do a global for viewport_type

0 = force to be in the center of the screen all the time, except when near edges of course...
1 = regular hysteresis
2 = slowly changing hysteresis

added these globals:

int viewport_mode = 1;
int viewport_show_hyst = 0;
int viewport_x_div = 8;
int viewport_y_div = 12;


20230213 6:24AM Friday the 13th
I have taken the entire week off work so far, I probably will take today also...
I have gotten a lot done...
what are some of my next plans?

make links to graphs??? from settings..and log_file_viewer..done




settings - add more stuff
program state - clean up and make simpler
see if I can make level done part of program state...




add timers and LOG_TMR tags for the packets related...

how many do I want?

move
draw
stdf send (server only)
dif unpack (client only)
rewind time (client or server)

LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd
first of all, make these global variables, then save in config, then add toggle in setting...all done
now just patch them into the code where log entries are entered...





make options on logs to never save log files....
I am so annoyed when shit gets saved and I dont want it to....


i am thinking of 2 different types of timestamps


one would be used to profile sections of code...

like move, draw, stdf etc....


each will have a tag like

tmst move:[]


then my tagging system will find them all and apply the label to the series.....

I will have as many or as few as I want, and when I run the graph it will automatically show the ones present

the other type of timestamp would show things in relation to frame start...I can think about that later....

I am excited to do this one....

use these to start:
LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd

I want to make global double t0 just to make the code look cleaner


now make a graph....

looking good....

make a us y axis type....already done, but store data as ms...al_get_time * 1000 print wih %0.4f


looking good...

now make this graph so it can be called with its own file select....


then put it on a button in settings....

this looks awesome....

how about saving log when coming back to menu or config, instead of having to quit game..

options:

save log on program exit
save log on game quit
save log on level done
save log manually only
save log now

do it...




I redid all of the config with macro's..
it took a while but it is so much shorter and easier
to do a config value, i need 1 set and one get, before I need 3 for get and 2 for set
I should really test each one to make sure they are working....
erase config file and see!!
looks good...
color does not stick...fixed...


in program_mode 12 - level done

added: if (autosave_log_on_level_done) save_log_file();

this was here:
blind_save_game_moves(1) - level done

this checks to see if autosave is on and labels the save file accordingly...
I guess this is OK

what else calls blind save??


blind_save_game_moves(2) - game_exit
at the end of main...we should change this to when leaving running game...that seems much more useful...

blind_save_game_moves(3) - bad exit

fast_exit and

void function_key_check(void)
{
   if (mI.key[ALLEGRO_KEY_F4][3])
   {
      blind_save_game_moves(3);
      save_log_file();



-----------

log files for now...

put checks for program exit in fast exit and end of main....done...

look for occurances of save_log_file...good

now just find an entry point for leaving a running game...


resume_allowed...no...

when leaving program_mode 11 to 1 or 3

done...




I think all cases ahould be covered now...

occ of blind_save_game_moves();

blind_save_game_moves(3); F4         only if game_exit set
blind_save_game_moves(3); fast exit  only if game_exit set
blind_save_game_moves(2); game quit  only if game_exit set
blind_save_game_moves(1); level done only if level done set

occ of save_log_file()
F4           only if program exit set
fast exit    only if program exit set
end of main  only if program exit set
game quit    only if game_exit set
level done   only if level done set

looking good....





lets try some log tmr and view on graph...nice....

tmst back:[0.0060] lifts:[0.0207] items:[0.5058] enem:[0.0101] ebul:[0.0001] pbul:[0.0001] play:[0.0035] buff:[0.0111] ovrl:[0.1171] flip:[0.1415]
tmst back:[0.0053] lifts:[0.0197] items:[0.5073] enem:[0.0097] ebul:[0.0001] pbul:[0.0002] play:[0.0033] buff:[0.0112] ovrl:[0.1181] flip:[0.1382]
tmst back:[0.0060] lifts:[0.0206] items:[0.5062] enem:[0.0096] ebul:[0.0002] pbul:[0.0001] play:[0.0034] buff:[0.0108] ovrl:[0.1169] flip:[0.1311]

its 150 char

lets log it...



20230114 8:44 AM

working on timestamp logging today....at least for now...

have move and draw done
total and all individual..

now work on graph and pop up values...
show series and accurate units

units done
series name done


I have this stupid bug that is annoying me....

I have text drawing routines I have made that can take either 'font' pristine or 'f3' pixel gosub

I have been making good use of:
al_get_text_dimensions(f3, text, &bx, &by, &bw, &bh);

I have no problems with the width but the bh and by sometimes do strange things...

mostly by

I want to do some experiment with these fonts to see if I can make a solution

I just want my text to line up consistantly

what is the character range?

pristine 32-127
pixel_gosub 32-127


what is the max and min for bx, by, bw, bh


the built in font has all 0 0 8 8...nice

how did stuff not break when I changed to pristine??
why does it still draw with 8 8 like the old one....




int al_get_font_line_height(const ALLEGRO_FONT *f)

font and font0 are 8
f3 is 9??? WTF

looking into it: almost everything I care about in f3 is 5 high
exceptions:
Q - 6
{} () | $ are 7

also all the ones that are bh5 are also by4...this would cover 99% of what I do with them....


so to make some code common.....

do not use al_get_text_dimensions for height...
you can us it for width, that seems to be fine

have my own custom get text_height thing...
for font or font0, always return 0 8
for f3 always return -4 5

void mw_get_text_height(ALLEGRO_FONT *f, int by, int bw)
{
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

this is just craxy enough to work!

what can I do to test it?

make an example that shows the problem...


function that you send a char, font, color, x, y and it prints that in a nice bounding box with 1 pixel border.
then test that funtion with various fonts and text strings....

I think I got it!

2 steps:
- use my function to get text dimensions
- use bx and by when drawing text
this seems to work for all cases

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

void draw_text_in_box(const char* txt, ALLEGRO_FONT *f, int x, int y, int color, int type)
{
   int bx, by, bw, bh;

   if (type == 0) // the regular method
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2, y+2, 0, txt);
   }
   if (type == 1) // use bx, by to offset text
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2-bx, y+2-by, 0, txt);
   }

   if (type == 2) // use my method to force by offset and bh size
   {
      mw_get_text_dimensions(f, txt, bx, by, bw, bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mColor.pc[color], 1);
      al_draw_textf(f, mColor.pc[color], x+2-bx, y+2-by, 0, txt);
   }
}


void temp_test(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(mColor.pc[0]);

   ALLEGRO_FONT *f = font;

   for (int j=0; j<3; j++)
      for (int i=0; i<3; i++)
      {
         if (i == 0) f = font;
         if (i == 1) f = font0;
         if (i == 2) f = f3;

         draw_text_in_box("Hellg", f, 100, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("Hello", f, 150, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("emmem", f, 200, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("e{3}",  f, 250, 100 + i*20 + j*100, 10, j);
      }
}


lets try it out...

where to put my function...in z_fnx...

fixed draw point...perfect...

now lets go through graph, and fix all.....

basically just search for al_get_text_dimensions

make series legend text x + 1
what if I load that font with no kerning???


it is loaded with no kerning...

force bx for that font?? yes...and bw...remember, this font is suppose to be 8x8

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
    // first get from the allegro method
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);

   // then override for my nefarious purposes!
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; bx = 0; bw = 8*strlen(txt); }
   if (f == font0) { by = 0; bh = 8; }
}


done all the mw_get_text_dimensions in mwGraph....

I should add some code to see if labels are touching each other because they are too close...
try x axis first....i have it working....
labels can only be powers of 10....that is fine...
what would the whole thing look like if I used this to set major instaed of bewyeen 2 and 20...gave up...

oh this is done...

now what the hell was I doing before?

just added move profiling...


better auto colors in graph...
make a function to set colors...just skip 0....done....

now fix the goddam 2 line drawing bug....done...

take a break and come back for more....


now I want to go inside the move enemy and break down individual types..same with draw....


Hysterisis window following player
lots of options there

can I make the hyst div number make more sense?

its a fraction of screen size...

2 is max

how about 1/num * 2 that was 1 will be widest

20 min 1/20 * 2 == .1

save as float from 0.01 to 1

when using it do 1/num and divide by 2....

i use it to divide SCREEN_W and H so now I can just muliply instead...done...

this settings page works, but could use some polish






make a header of mwGraph and move header there


what have you done?

made z_mwGraph.h

put the class declaration there
and at the end of the class declaration:
extern mwGraph mG[10];



// z_mwGraph.cpp
#include "pm.h"
#include "z_mwGraph.h"
mwGraph mG[10];


then the only other source file that needed access was z_log.cpp and all I had to do was add
// zlog.cpp
#include "pm.h"
#include "z_mwGraph.h"


wow, that was easy...

z_mwGraph.h 250 lines
z_mwGraph.cpp 1850 lines

viewport page on settings completely done....

zoom is not saved...well it is, but when getting loaded it always loads 1...
I should make sure of that then remove it from config file...not yet, just disabled and forced to 1.0 instant on load

Disable speed settings including function keys
Speed testing abilites.

is speed save to config file? no and I don't think it should be
I do want a variable to unlock speed changes though...

int speed_control_lock = 1;


done...


I have all the stuff in place for display trandform double, just need to make it look nice...


20230114 9:45PM...push



I don't think I can profile the individual enemies and items as easy....

so what else can I do...





20230115 11:11

so this morning I chose to do something completely different...
something meta....

source code stats!!!

Purple Martians Source Code Line Counts [2023-01-15  11:11:11]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[  2378][  1597][  1387][   385][   175][   210][   606] - z_log.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
--------------------------------------------------------
[ 46138][ 33787][ 28655][  8526][  3394][  5132][  8957] - Total





Purple Martians Source Code Line Counts [2023-01-15  11:27:00]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2435][  1623][  1411][   388][   176][   212][   636] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
--------------------------------------------------------
[ 46195][ 33813][ 28679][  8529][  3395][  5134][  8987] - Total


sorted by code size



why the fuck do I still have z_map.cpp??


// zmap.cpp

#include "pm.h"

void set_map_position()
{

//  1   9   2
//      |
// -----+-----
//      |
//  4   |   3

   int alp = active_local_player;

   int px1 = players1[alp].sbx1;
   int py1 = players1[alp].sby1;
   int px2 = players1[alp].sbx2;
   int py2 = players1[alp].sby2;

//   printf("gmo:%d mx:%d my:%d px1:%d py1:%d px2:%d py2:%d\n",game_map_on, map_x, map_y, px1, py1, px2, py2);
   switch (game_map_on)
   {
      case 0:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
      break;
      case 1:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         // check to see if player is covered by the map
         if ((px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 2;
      break;
      case 2:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (py1 < map_y + map_size))  game_map_on = 1;
      break;
      case 3:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px2 > map_x)
          && (py2 > map_y))  game_map_on = 4;
      break;
      case 4:
         map_x = BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px1 < map_x + map_size)
          && (py2 > map_y))  game_map_on = 3;
      break;
      case 9:
         map_x = SCREEN_W/2 - map_size/2;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 4;
      break;
   }
}

void next_map_mode()
{
   int old_game_map_on = game_map_on;
   switch (game_map_on)
   {
      case 0: game_map_on = 1; break;
      case 1: game_map_on = 2; break;
      case 2: game_map_on = 3; break;
      case 3: game_map_on = 4; break;
      case 4: game_map_on = 9; break;
      case 9: game_map_on = 0; break;
   }
   set_map_position();
   if (old_game_map_on == game_map_on) game_map_on = 0;
}

void next_map_size()
{
   int smin = 0;
   if (SCREEN_H < SCREEN_W) smin = SCREEN_H;
   else smin = SCREEN_W;

   if (new_size == smin /4) new_size = smin/3; // 1/3
   else if (new_size == smin /3) new_size = smin/2; // 1/2
   else if (new_size == smin /2) new_size = smin/4; // 1/4
   else  new_size = smin /3; // if for some reason none of these match
}

void draw_map()
{
   if (game_map_on)
   {
      // process the size change gradually
      if (map_size < new_size)
      {
         map_size+=30;
         if (map_size > new_size) map_size = new_size;
      }
      if (map_size > new_size)
      {
         map_size-=60;
         if (map_size < new_size) map_size = new_size;
      }
      set_map_position();
      al_draw_scaled_bitmap(level_buffer, 0,0, 2000, 2000, map_x, map_y, map_size, map_size, 0);
   }
}

kill it!!!

a few more tweaks then I am done....

Purple Martians Source Code Line Counts [2023-01-15  11:41:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2404][  1620][  1405][   391][   176][   215][   608] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
-------------------------------------------------------- - totals
[ 46055][ 33720][ 28587][  8519][  3386][  5133][  8949] - 44 files

done!!!!...

just for comparison, what does code blocks say?

47 files
45856 - total
26651 - code only
 4834 - code and comment
 8899 - blank
 5472 - comment

manually add
26651 - code only
 4834 - code and comment
-------
31485

what files does it get that I don't




got to move on.....






make sure all logging entries throughtout the code have appropriate if statements
list them...


extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_game_move;
extern int LOG_NET_sdat;
extern int LOG_NET_sdak;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_show_dif1;
extern int LOG_NET_show_dif2;

--------------------------------------------------------
LOG_NET [10]
--------------------------------------------------------

8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()


6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()


1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()




   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }


   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }


   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }



1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL

server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked



--------------------------------------------------------
LOG_NET_player_array [26]
--------------------------------------------------------
1 x server_control() [26]

--------------------------------------------------------
LOG_NET_bandwidth [23][24]
--------------------------------------------------------
1 x process_bandwidth_counters() [23][24]

--------------------------------------------------------
LOG_NET_cdat [35]
--------------------------------------------------------
1 x server_proc_cdat_packet() [35]
1 x proc_player_input() // when client sends cdat [35]

--------------------------------------------------------
LOG_NET_game_move
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdat
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdak
--------------------------------------------------------
not used


--------------------------------------------------------
LOG_NET_stdf
--------------------------------------------------------
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]
1 x client_process_stdf_packet() dif decompressed [27]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]
1 x server_proc_stak_packet() [30]

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   //---------------------------------------
   // server new game
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }



--------------------------------------------------------
LOG_NET_stdf_all_packets
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received [28]
1 x server_send_stdf() // when sending an individual stdf packets to a client [28]


1 x client_timer_adjust() [36]
   sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", players1[p].dsync*1000, players1[p].client_chase_offset*1000, fps_chase);
   if (LOG_NET_stdf_all_packets) add_log_entry2(36, p, msg);

1 x ping_array_add() [37]
   sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping*1000, players1[p].ping_avg*1000);
   if (LOG_NET_stdf_all_packets) add_log_entry2(37, p, msg);

--------------------------------------------------------
LOG_NET_stdf_when_to_apply
--------------------------------------------------------
1 x client_apply_diff() [29]
   sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);



--------------------------------------------------------
LOG_NET_show_dif1
--------------------------------------------------------
all in fnx

--------------------------------------------------------
LOG_NET_show_dif2
--------------------------------------------------------
all in fnx

void show_state_dif(char *a, char *b) 430 lines..has not been used in a while....

maybe its time for all that to go away.....gone...now remove the LOG_NET...done...


what about the ping... what is it used for??
is it only for ping_graph?

Make this list also show the log entry type number....
also removed game_move, sdat, sdak...











---------------------------------------------------------------------------------
-------------   The official list of how logging works: -------------------------
---------------------------------------------------------------------------------
extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_client_ping;
extern int LOG_NET_client_timer_adj;
extern int LOG_NET_server_rx_stak;

--------------------------------------------------------
LOG_NET [10] [both]
--------------------------------------------------------
8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()

6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()

1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()

   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11] [both]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL
server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked

--------------------------------------------------------
LOG_NET_player_array [26] [server]
--------------------------------------------------------
1 x server_control()

--------------------------------------------------------
LOG_NET_bandwidth [23][24] [both]
--------------------------------------------------------
1 x process_bandwidth_counters()

--------------------------------------------------------
LOG_NET_cdat [35] [both]
--------------------------------------------------------
1 x server_proc_cdat_packet()
1 x proc_player_input()

--------------------------------------------------------
LOG_NET_stdf [27][29] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() dif received and decompressed [27]
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]

   //---------------------------------------
   // 12 - level done [27]
   //---------------------------------------
   //---------------------------------------
   // server new game [27]
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }

--------------------------------------------------------
LOG_NET_stdf_all_packets [28] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received
1 x server_send_stdf() // when sending an individual stdf packets to a client

--------------------------------------------------------
LOG_NET_stdf_when_to_apply [29] [client]
--------------------------------------------------------
1 x client_apply_diff()

--------------------------------------------------------
LOG_NET_client_timer_adj [36] [client]
--------------------------------------------------------
1 x client_timer_adjust()

--------------------------------------------------------
LOG_NET_client_ping [37] [client]
--------------------------------------------------------
1 x ping_array_add()

--------------------------------------------------------
LOG_NET_server_rx_stak [30] [server]
--------------------------------------------------------
1 x server_proc_stak_packet() [30]


the only area that I still am not sure about is 27 and 29 for stdf...
a lot of these things all fall under the stdf blanket...
but it would be nice to have the option of not filling the log with unneeded stuff...

what is the point of logging that dif was received if I don't say if it was successfully appllied?



here is what I would like to see in great detail:

1 - server decides to make new dif (this is when the base it uses comes due)

2 - server rewinds to previous saved state

3 - server plays back a set number of frames (and applies all late input)

4 - server saves a new state

5 - server plays a set number of states to get back to where it was originally

6 - server set a flag to send stdf

7 - goes back into the game loop and continues the current frame (processes input, moves frame, draws frame, then sends stdf to clients)

why the delay here? why can't I send it sooner?
I am already delayed by having to rewind and make a new state....
Nothing in the state I am sending will change by playing this current loop....

The way I am doing it now is waiting for the worst possible time to do that.

I have waited for the timer to fire, then I send based on the old state
I don't even get fresh input...

What I think I should do is: (server only)

play the frame to the end (draw also?) ...no... everything but draw
get all the input
process all the client packets
move the frame...

then...before draw...do the server thing if needed....

rewind, make new state, apply lost stuff (you realize this means you will replay the frame you just played...???)

then send the stdf, then draw...


I just had a thought...what if all I do is send the stdf before I draw?

would that have the same effect??

also if I could process all client input before I make the dif that should be good also....



one at a time....
on the server, when do I process cdats.....
right at the top of the frame...I cannot make that any sooner...

second...
I already send the stdf before draw...

you were saying.....

what about when the client sends pings....literally at the end of the game_loop right before the free time....

could I be rewinding and replaying in the background?...idk

i think it is time for some tests....

ping graph needs 36 and 37 tmaj and ping




show in debug overlay, how much time it took to process the last frame
basically how much free time....
as a percentage...

50% means it took 20ms...

done...


do some more testing....











I would like a scrolling real time graph to show on debug overlay...
oh really, and would you like some gold and silver with that?


come on it will be fun and will look so cool....

make it a class kind of like ping buffer...

all you need to do it pass it values once a frame

then call it to draw itself


it will only keep a certain ammount of history then throw stuff away.


use it to show, ping, dysnc, cpu, draw, move...


1 pixel per frame....


similar to mWgraph

it doesn't even have to have any history...it can just slide over the bitmap and draw a new pixel...

what am I going to call it?

class qGraph

what about the series size, this should be a lot samller than mwGraph...after all it is quick graph...

4 series max
1000 data points max

implicit x axis is frames and should be an int

1000 / 40 = 25 sec

yaxis will be a double

how about

double data[1000][4]

the index is the x axis

or this...

   struct data_series
   {
      double data[1000];
      int active;
      int color1;
      int color2;
      char name[256];
   };
   data_series series[4] = {0};

this expects new data every frame

when it gets data the old data is pushed down one.

draw is called independantly


y axis will be scaled manually or auto
for now lets start with manual...


I will call draw from srceen overlay..done
I will add data at the end of game loop
where am I going to set this up..new game...done


I don't think I want store x and y in the class...just pass x and y with draw...

the object must know its size though

should we put some data in?

it is working!!

in single player what else can I show but cpu??

client can do ping, dysnc, cpu

I think they should be on separate graphs...

make one just for cpu

auto range from 100 to 50 to 25

OK, challenge accepted


make type variable and type 1 == cpu

make y_axis_min, y_axis_max, y_axis_rng

its just fucking beautiful!!
I love it so much!!

cant wait to make it work on client with dsync and ping....

I could still do it on m36...just make something else the server....

OK lets do this...done....


the cpu makes use of the timestamp buffer, which fills up pretty soon...
change it to just use standard timstamps in the main loop....


then try again...

it 11:30 at night....just a little longer....

fixed cpu...now lets get this to as many clients as I can...

11:57 push



20230117 6:0AM

thing are going slower no that I am back to work....

add more options to pm -t
-t   type 1 exe only
-tl  type 2 exe and levels
-tr  type 3 delete everything first and do release
-ta  type 4 abslutely everything

cleaned up this part of the code...works nicely now...

lets do a full release to all...done


not much time...

what graph can I run on client to see what is using all cpu??

profile

level 29 single player on m36

draw from 500 to 800us

move 95% 30us BUT! spikes to 2000 and once to 4000!!!

I need to know what...

did the move_all profiling and found spikes on player (2ms) and enemy (2-4ms)






implement the per enemy and per item timers...

can I use the timer buffer??

I might have 100 thing to time...

put each enemy in a bin...

      timestamps[i].frame0 = 0;
      timestamps[i].frame1 = 0;
      timestamps[i].frame2 = 0;
      timestamps[i].type   = 0;
      timestamps[i].t0     = 0;
      timestamps[i].t1     = 0;
      timestamps[i].t2     = 0;


I think I will precalc each time...


then add a timestamp like
frame0 - current frame
frame1 - enemy number
frame2 - enemy type
t0 - delta time

then at the end, calculate, enter log entry and erase them all...

LOG_TMR_enem added...

I need to know how many enemies cause the number...



It looks like I have a problem with enemy deathcount...
walk through what happens....


enemy killed by player bullet...

void enemy_bouncer(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return; // to stop rest of execution
   }

in enemy killed:
Ei[e][0] = 99; // set type to death loop


in enemy_move:
case 99: enemy_deathcount(e); break;


void enemy_deathcount(int e)
{
   int EXint = al_fixtoi(Efi[e][0]);
   int EYint = al_fixtoi(Efi[e][1]);
   Efi[e][14] += Efi[e][13]; // rot inc
   Efi[e][12] = al_fixmul(Efi[e][11], Efi[e][12]); // scale inc

   Efi[e][0] += Efi[e][2]; // xinc
   Efi[e][1] += Efi[e][3]; // yinc

   Ei[e][1] = zz[0][ Ei[e][3] ]; // draw current ans shape
   // dec and check countdown timer
   if (--Ei[e][30] < 0) // create bonus
   {
      Ei[e][0] = 0; // kill enemy
      for (int c=0; c<500; c++)
         if (item[c][0] == 0) // find empty
         {
            for (int y=0; y<16; y++) item[c][y] = 0; // clear item
            item[c][0] = 2;           // type - bonus
            item[c][1] = Ei[e][24];  // flower shape
            item[c][2] = 1; // draw mode normal
            item[c][3] = -1; // carryable
            item[c][4] = EXint;
            item[c][5] = EYint;
            item[c][6] = 1; // bonus type 1 - health
            item[c][7] = Ei[e][25];  //  life
            item[c][8] = 0;

            item[c][14] = 800; // time to live

            itemf[c][0] = al_itofix(item[c][4]);
            itemf[c][1] = al_itofix(item[c][5]);
            itemf[c][2] = al_itofix(0);
            itemf[c][3] = al_itofix(0);
            break; // end loop
         }
   }
}

looks like its only the first frame of 99...

tmst arch:[0.3217] cann:[0.3111] trak:[0.6000] clon:[0.1750] flap:[0.4810]
tmst arch:[0.3043] cann:[0.3444] trak:[0.7000] clon:[0.1500] flap:[0.4333]
tmst arch:[0.3522] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6050] dth1:[1600.6000]
tmst arch:[0.2957] cann:[0.3333] trak:[0.7000] clon:[0.2000] flap:[0.5050] dth1:[0.1000]
tmst arch:[0.3000] cann:[0.3111] trak:[0.6000] clon:[0.1500] flap:[0.4800] dth1:[0.1000]
tmst arch:[0.4174] cann:[0.5000] trak:[0.8000] clon:[0.3250] flap:[0.5750] dth1:[0.3000]
tmst arch:[0.3565] cann:[0.3556] trak:[0.7000] clon:[0.1750] flap:[0.5400] dth1:[0.1000]
tmst arch:[0.3261] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3087] cann:[0.3444] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.2000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.8000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.6000] clon:[0.2000] flap:[0.4750] dth1:[0.1000]
tmst arch:[0.3609] cann:[0.3667] trak:[0.7000] clon:[0.2000] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3222] trak:[0.8000] clon:[0.1250] flap:[0.5300] dth1:[0.1000]
tmst arch:[0.3783] cann:[0.4333] trak:[0.9000] clon:[0.3750] flap:[0.6400] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.3778] trak:[0.6000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3667] trak:[0.7000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.4222] trak:[0.7000] clon:[0.2000] flap:[0.5000] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3889] trak:[0.8000] clon:[0.1750] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3667] trak:[0.7000] clon:[0.1750] flap:[0.5000] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3889] trak:[0.7000] clon:[0.2250] flap:[0.5500] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst arch:[0.3913] cann:[0.4556] trak:[0.8000] clon:[0.2750] flap:[0.6200] dth1:[0.2000]
tmst arch:[0.3304] cann:[0.3444] trak:[0.6000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst mpty:[0.2000] arch:[0.3000] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6500]
tmst arch:[0.3217] cann:[0.3556] trak:[0.6000] clon:[0.1750] flap:[0.5000]
tmst arch:[0.3304] cann:[0.3667] trak:[0.8000] clon:[0.1750] flap:[0.6050]

I think it might be one of these....

//      if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);


3 should not exist...field


         case 60: case 62: case 64: // enemy killed
            al_play_sample(snd[8], 0.5, 0, 1.2, ALLEGRO_PLAYMODE_ONCE, NULL);
         break;



its definitely in bmsg...not the sound part though...

is it every call to create new bmsg??.. i think it is...disable this bullshit and see what happens...

much better... now lets try a busy level...

copy all to clients

now I found that drawing the screen overlay takes almost 25ms on 4230 ClientSend
on e6430 it only takes 2.5ms


there are definitely some things to look at....

can I make screen overlay take less?
how much do graphs take?


bottom msg
why does it take so much when creating a new one?
displaying them all does not take so much...



gtg its linzies 18th!!

20230118 6:45AM



run profile graph with screen overlay on/off

could it be that the temp_bitmap created is a memory bitmap??

won't know till I profile...







made profiling page in settings
button to open most recent graph
button to run game from that page
done


some duplicate labels are messing up profile graphs...

all draw have d- prefix
all move have m- prefix
all move enemy now have m- prefix


all profile to add new bmsg




making sounds have its own header...


moved all externs and function prototypes to  .h

// ------------------------------------------------
// ---------------- sound -------------------------
// ------------------------------------------------
extern ALLEGRO_VOICE *voice;
extern ALLEGRO_MIXER *mn_mixer;
extern ALLEGRO_MIXER *se_mixer;
extern ALLEGRO_MIXER *st_mixer;
extern ALLEGRO_SAMPLE *snd[20];
extern ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
extern ALLEGRO_AUDIO_STREAM *pm_theme_stream;
extern int fuse_loop_playing;
extern int sample_delay[8];
extern int st_scaler;
extern int se_scaler;
extern int lit_item;
extern int sound_on;

// z_sound.h
void start_music(int resume);
void stop_sound(void);
void proc_sound(void);
void load_sound(void);
void set_se_scaler(void);
void set_st_scaler(void);
void sound_toggle(void);



moved all declarations to sound.cpp

ALLEGRO_VOICE *voice = NULL;
ALLEGRO_MIXER *mn_mixer = NULL;
ALLEGRO_MIXER *se_mixer = NULL;
ALLEGRO_MIXER *st_mixer = NULL;
ALLEGRO_SAMPLE *snd[20];
ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
ALLEGRO_AUDIO_STREAM *pm_theme_stream;
int fuse_loop_playing;
int sample_delay[8];
int se_scaler=5;
int st_scaler=5;
int lit_item;
int sound_on = 1;


then every file that needs access includes z_sound.h

that seems to work good.....

did the same with z_log...




I am profiling bmsg...

add 1.4-2.2ms
draw 7us


now lets try to change somethings...

see what type of bitmap is created...


there is a global variable:
ALLEGRO_BITMAP *bmsg_temp;

every time new_bmsg is called:
bmsg_temp = al_create_bitmap(800, 20); // create a temp bitmap to build a single line
al_destroy_bitmap(bmsg_temp); // destroy the temp bitmap

why do I bother?? it is always the same size...
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE

I will try to create it in create bitmap

still 1.6 to 1.9ms

next....

maybe its my dtextout...does nothing except double text size, but it uses a temp bitmap...

comment out and speed test..still 1.1 to 1.3...


how about instead of all these temp bitmaps, I just draw on the final...pass a pointer to it to al the subfunctions


al_set_target_bitmap(bmsg_bmp[bmsg_index]);
al_clear_to_color(al_map_rgb(0, 0, 0));

//al_draw_bitmap(bmsg_temp, (400 - (bmsg_length/2)), 0, 0); same as 0

al_convert_mask_to_alpha(bmsg_bmp[bmsg_index], al_map_rgb(0, 0, 0)) ;
al_set_target_backbuffer(display);


so just pass (bmsg_bmp[bmsg_index]);

I don't think that was what was slowing it down

I think it was:
- the dtextout using a temp bitmap to doubel text size
- the call to set alpha..

i fixed the text thing by creating another font that is size 16..
have not figured out the alpha yet...

i think I need to bring bacj the temp bitmap, if for no other reason than:
I need to make it centered, but can't do that until I am finished drawing...
like I said, I dont think that was the bottleneck...

changed from
al_clear_to_color(al_map_rgb(0, 0, 0));
to
al_clear_to_color(al_map_rgba(0, 0, 0, 0));

now it works better...


first add spikes to 700us then around 100-150us...10x better...

not sure why first one is different

print bmsg when adding and compare to profile graph...


why when I draw a tile it takes ~6us but when I draw text, it takes ~100us

it makes no sense to me...



when I use the built in 8x8 font I get the first spike to 50us then around 10-15us

maybe the problem all along has been the truetype font

can I convert it to a bitmap type font?


I sure as fuck am going to try...

first of all print the pristine char set...



I only care about 32-127


now that I have done that, they seem to draw very fast....
no big spike on start, max for everything in add bmsg is 34us..draw text is typically 10us
I am very happy with that...I'll need to put it all back together

put the code here in the comments for future reference...




//   convert pristine ttf font to bitmap font so I can draw it faster 16x16 version



   ALLEGRO_BITMAP *b = al_create_bitmap(290, 110);
   al_set_target_bitmap(b);

   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);

   al_clear_to_color(bg1);

   int y = 2;
   for (int b=32; b<128; b+=16)
   {
      int x = 2;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*18, y, x+a*18+16, y+16, bg2);
         al_draw_textf(font2, t, x+a*18, y, 0, "%c", a+b);
      }
      y+=18;
   }

   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);

   al_save_bitmap("bitmaps/Pristine_16.bmp", b);


   al_flip_display();
   tsw();



//   convert pristine ttf font to bitmap font so I can draw it faster 8x8 version
//
//   ALLEGRO_BITMAP *b = al_create_bitmap(162, 62);
//   al_set_target_bitmap(b);
//
//   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
//   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
//   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);
//
//   al_clear_to_color(bg1);
//
//   int y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//   al_set_target_backbuffer(display);
//   al_draw_bitmap(b, 0, 0, 0);
//
//   al_save_bitmap("bitmaps/new_p_8.bmp", b);
//
//
//   al_flip_display();
//   tsw();
//
//
//   ALLEGRO_BITMAP* tmp234 = al_load_bitmap("bitmaps/new_p_8.bmp");
//   if (!tmp234) mI.m_err((char*)"Can't load bitmaps//new_p_8.bmp");
//   else
//   {
//      al_destroy_font(font);
//      int ranges[] = {32, 127};
//      font = al_grab_font_from_bitmap(tmp234, 1, ranges);
//      if(!font) mI.m_err("Failed to load font from bitmaps/Pristine.ttf");
//      al_destroy_bitmap(tmp234);
//   }
//
//
//   al_set_target_backbuffer(display);
//   al_clear_to_color(bg2);
//   al_flip_display();
//
//   y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//
//
//
//   al_flip_display();
//   tsw();
//
//




OK that should be done for now....

I have other things to profile...like screen overlay...lets see if that got any better now that I have fonts fixed....





20230120 2:00AM
profile screen overlay..


make a way to disable bmg in settings...done
hostname is not getting saved...done




on m36 as client
cpu 120us
sync 230us
cbuttons 43us


none of that seems excessive....


I want to know what happens when player paused due to death...

scrn overlay takes a huge hit in jq...
why don't I get jq when clients join quit?? i do...

what can I do to make jq faster??

5ms then 1.5, 1.5, 1.5 then 5ms
spikes once to 6.7 at start and end..

its that fucking convert mask to alpha!!
265us spike then 35 then 164 spike near end...

why is it sooo slow? why do I need it?

same thing as bmsg....

old:
al_clear_to_color(al_map_rgb(0,0,0));
al_draw_text(font0, mColor.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);
al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

new:
al_clear_to_color(al_map_rgba(0,0,0,0));
al_draw_text(font0, mColor.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);

now it is transparent and really fast...



find all occurances of: al_convert_mask_to_alpha and see if they are needed...

25 matches...

ignore one that are not in a fast loop..
6 in bitmap.cpp
4 in file when loading from file..
7 in logo
mw_text for 'created by' fixed...
title..fixed

2 x void draw_large_text_overlay(int type, int color)..fixed
3 x void idw(int txt, int x, int y, float x_scale, float y_scale)

some when loading my new fonts...can I do that before I save?
does not seem to save in bmp format, i still need to call

al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)) in bmp after loading and before loading font from it...

here is my new routine:

void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size)
{
   // converts ttf fonts to bitmap font to draw faster and have consistant size
   sprintf(msg, "bitmaps/%s", ttf_filename);
   ALLEGRO_FONT *cf = al_load_ttf_font(msg, char_size, ALLEGRO_TTF_NO_KERNING | ALLEGRO_TTF_MONOCHROME | ALLEGRO_TTF_NO_AUTOHINT);
   if(!cf)
   {
      sprintf(msg, "Failed to load font from bitmaps/%s", ttf_filename);
      m_err("Failed to load font from bitmaps/Pristine.ttf");
   }
   else printf("loaded font %s\n", msg);

   int bw = 1;                 // border width
   int step0 = char_size+bw;   // step size between char
   int step1 = char_size;      // char size
   int bmp_w = (16 * step0) + bw;
   int bmp_h = (6  * step0) + bw;

   ALLEGRO_BITMAP *b = al_create_bitmap(bmp_w, bmp_h);
   al_set_target_bitmap(b);

   al_clear_to_color(al_map_rgb(255, 0, 0));  // set entire bitmap to red, this will be the background color separating the glyphs

   int y = bw;
   for (int b=32; b<128; b+=16)
   {
      int x = bw;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*step0, y, x+a*step0+step1, y+step1, al_map_rgb(0, 0, 0)); // clear glyph background
         al_draw_textf(cf, al_map_rgb(255, 255, 255), x+a*step0, y, 0, "%c", a+b);
      }
      y+=step0;
   }
   al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)); // does not actually save in bmp format :(
   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);
   sprintf(msg, "bitmaps/%s", bmp_filename);
   al_save_bitmap(msg, b);
   al_destroy_font(cf);
}

convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_16.bmp", 16);

and here is how I load them...

   ALLEGRO_BITMAP* tmp = al_load_bitmap("bitmaps/Pristine_8.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_8.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font);
      int ranges[] = {32, 127};
      font = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font) m_err("Failed to load font from bitmaps/Pristine_8.bmp");
      al_destroy_bitmap(tmp);
   }

   tmp = al_load_bitmap("bitmaps/Pristine_16.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_16.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font2);
      int ranges[] = {32, 127};
      font2 = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font2) m_err("Failed to load font from bitmaps/Pristine_16.bmp");
      al_destroy_bitmap(tmp);
   }


back to looking for al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;

should be all good...

I have a couple of functions that are not used anymore:

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col);
void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col);

ill list them here then delete them...



/*

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // can show mirror image text when scales are negative
   // used only mdw logo animation
//   int sw = strlen(txt1) * 8;      // string length in pixels
//   int sh = 8;                     // string height in pixels


   int bbx1, bby1, bbw1, bbh1;
   al_get_text_dimensions(f1, txt1, &bbx1, &bby1, &bbw1, &bbh1);

//   printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);

   // scale the scale...
   x_scale *=  24 / (float) al_get_font_line_height(f1);
   y_scale *=  24 / (float) al_get_font_line_height(f1);

   int sw = bbw1;
   int sh = bbh1;



   ALLEGRO_BITMAP *temps = NULL;
   temps = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temps);
   al_clear_to_color(al_map_rgb(0,0,0));


//   al_draw_text(font,mColor.pc[col], 0, 0, 0, txt1 );

   al_draw_text(f1, mColor.pc[col], 0-bbx1, 0-bby1, 0, txt1);


   al_convert_mask_to_alpha(temps, al_map_rgb(0, 0, 0)) ;


   int flags = 0;
   if (x_scale < 0) flags |= ALLEGRO_FLIP_HORIZONTAL;
   if (y_scale < 0) flags |= ALLEGRO_FLIP_VERTICAL;

   // offset x pos if scale is negative
   if (x_scale < 0) x -= abs( (int) ((float)sw * x_scale) );

   // offset y pos if scale is negative
   if (y_scale < 0) y -= abs( (int) ((float)sh * y_scale) );

   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temps, 0, 0, x, y, fabs(x_scale), fabs(y_scale), 0, flags);
   al_destroy_bitmap(temps);
}

void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // used only by bottom message and level done
   int sw = strlen(txt1) * 8;      // string length in pixels
   int sh = 8;                     // string height in pixels

   ALLEGRO_BITMAP *temp = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));

   int dw = (int) ((float)sw * x_scale);
   int dh = (int) ((float)sh * y_scale);

   al_draw_text(font, mColor.pc[col], 0, 0, 0, txt1);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

   al_set_target_backbuffer(display);
   al_draw_scaled_bitmap(temp, 0, 0, sw, sh, x-dw/2, y, dw, dh, 0);

   al_destroy_bitmap(temp);
}
*/


20230120 7:00AM

well I think I have that sorted out...


now back to things that were slowing down on profile...


I was in client with the three things in screen overlay...


240us sync_ping
130us CPU
100   client grid
90    debug common
44    cbuttons
it all adds up to about 700us


when running as client everything added up (cpu) takes about 1ms, draw and move

if i turn off the debug overlay everything is around 400us





clients still around 90-100%

ran the profile graph on a client and 22ms spent in draw and 17 was screen overlay


what to do about that?

make it adjustable somehow. I want to see cpu

sync 7ms
cpu 4ms
c_grid 2.3
dbug_com 1.5

the width of the qGraph determines how many points are drawn...
right now I am using 200 for width which gives me 5s

should I make this adjustable?

set ranges based on how large the screen is?

I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...


20230221 5:00AM
pm -? show commandline options...done




show_debug_overlay to have more options:

0-off
1-minimal
2-medium
3-all

mimimal
cpu only

medium
cpu and sync (client only)

all


make list of things that can be shown:
- cpu
- client sync and ping
- client grid
- server grid

common list of text
more list of text...






I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...

the way I have it now is is only measures send to one client...
and it only add a log entry when it actually sends...
what I want to do is move it to here:

from loop:
if (players1[0].server_send_dif) server_send_stdf();

and add a log entry every frame...
that way I will get the total time, and zero's when nothing happens

between this and rewind, I should have all the main server stuff profiled...done


log cpu (total time spent processing each frame)

calc where?

right now screen_overlay does it...is this what I want??
this is not actually at the end of the frame is it?
no...it is at the end of loop where it is added to qG

            if (proc_frame_skip()) draw_frame();

            double pt = al_get_time() - timestamp_frame_start;
            double cpu = (pt/0.025)*100;
            qG[0].add_data(0, cpu);

literally the last thing...
this is where I should add the log entry also...
LOG_TMR_cpu

done...


ready for some more tests??
looking good...

bug..why does it fail at level done when trying to load next level and getting level 0?

it looks like next_level is only set when player touches exit or warp...
I think some clients are missing this...

fix when I get back....

got to go to a first aid class on a saturday...oh well..8H OT..

push..





20230121 4:30PM
moved all settings related stuff to z_settings.cpp and z_settings.h

e_mWindow.h done
z_player.h done


now I am down to 1300 lines in pm.h...little by little, I am chipping away at it....


added to player array:

   int level_done_next_level;

find occ of next_level and replace with players[0].level_done_next_level....done

that should fix that....


I think I am back to the testing part of things....
send out to all


the dsync on clients has a bit of a strange pattern

on e6430 one peak at +60-500us then a few at -2.3ms

on 4230 4 around +1ms then 1 at -15ms

why is this happening?

what does it all mean?

what happens on a pattern of 5 frames?

I think its the timer adjust...the patterns match...

can I make it less aggressive....



I am dealing with very small values here...

I have usually kept fps at 40 and set timer with 1/40

I could just as easily set timer with 0.025

1 / 40.00 = 0.0250000
1 / 40.10 = 0.024937
            0.000063 or 63us

1 / 40.00 = 0.0250000
1 / 40.01 = 0.0249937
            0.0000063 or 6.3us

my adjustments seem really small


maybe I need to print all the numbers used in my calc

make a new log entry for now...temp...









I want to make a PID loop...


I have an output I can measure: dsync
I have a setpoint I am trying to achieve: offset
I have a variable I can use to control the process: fps


first of all I want to graph these...
then I will try to plug in a new PID algorithm


make a new graph just for this....
client only

in the interests of it all fitting on the same graph I will use fps_adjust as my control

and I will make fps adjust the value added or subtracted to 0.025....

all my values will be in ms to 3 deciaml places...

make a new log entry...done...


now I can easily plot...

   float mv = players1[p].dsync;                 // measured value
   float sp = players1[p].client_chase_offset;   // set point
   float err = sp - mv;                          // error = set point - measured value



my control loop currently is just P, err*100 = P

to get the integral I will need a running total...

simply add and subtract the error....

why do I have doubts this will work?

beacuse when it ramps up the I will grow really fast...

2 ways to solve this...
- set limits on i
- gradually decay i


first of all I need a global variable to keep a running total...

done...



what if the problem is that the things I am trying to sync are inherently unstable....

what if I took an average of dsync and used that...


how often do I get dsync?

with every dif so 2-3 frame...


what if I just took a running average, like ping?


I can still show the instantaneous ones, but use the average to set chase speed

this needs to be fast for initial chase though...


try it....



make ping_buffer have a header file and be self contained...then add dsync...

add dsync_avg to player1 array..done


add call when calc



I think I have stumbled upon something amazing...all this bullshit happens when we need 2 packets...

each packet causes its own timer adjust, and one is definitely later than the other...duh...


how can I make it not do that?

have a variable last stdf_packet frame and check it...
already had var...check it now and only do one timer adj per frame based on first stdf rx'd..done

still getting some wild oscilliations


lets also try starting offset at 0 instead of +10ms


set ia to zero.
how long does it take for mv to climb to zero line?
then with overshoot how long to cross back down?

pa = 100
mv  = 748-727 = 21
mv  = 793-727 = 66

mva = 762-727 = 35
mva = 805-727 = 78


pa = 60

mv  = 428-384 = 44
mv  = 456-384 = 72

mva = 442-384 = 58
mva = 471-384 = 87



make client offset update faster at start of chase..
it seems to take a while to actually change off zero...
352-259 = 93 frames

i cant run ping graph...i broks it..fixed
691-622 = 69

still does not seem to send first ping till mwPS.frame_num>0 (initial state rx?)


this is getting complicated...is is worth it to send pings while still in setup?
while still in setup stdf packets are being processed and timer is being adjusted...
might as well be based on a real setpoint based on a real ping...
while in setup the loop happens very fast and mwPS.frame_num is not incremented...

need another way to trigger sending pings...


how about in loop, after the main 11 is done, send client ping if flag is set.

then I can set this flag in 11 like normal, and also in setup based on a timer...

if (players1[active_local_player].client_ping_flag)
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

make a new timer png_timer..done...

now the event timer is the only thing that sets the flag...
it works, but still no pings for the first bit...

why the fuck not??

log...
all on frame 0:
got reply
send and rx join
start level..

then on frame 152
152 game state updated
162 tmaj
165
166
172
...
240
243
244 ping!!!

this is a long delay...

also client does not show when they became active??
not in log anyway

so back to the issue at hand:

after client gets initial state, it starts the main loop and and chases, while inactive
there is a long pause here before the first ping is received...

why?


show on console the frames when ping is sent..

191026 initial state
191028 ping
191047 ping
191067 ping
191087 ping
191107 ping
191128 ping

in logs
191108 1st ping received 24ms
191129 2nd ping received 28ms


I am sending them, but it appears that the first 4 are lost??

what a subtle bug!!!
on server, when rxing ping and replying, it looks up who from player_num and fails if player is not active yet!!

int get_player_num_from_who(int who)
{
   for(int p=0; p<NUM_PLAYERS; p++)
//      if ((players[p].active) && (players1[p].who == who)) return p;
      if (players1[p].who == who) return p;
   return -1;
}

still the same

console:
652 initial state
671 ping
691 ping
711 ping
731 ping
752 ping

log
732 1st ping
753 2nd ping

still missing first 4 pings...


more console logging:

049 init state
069 send ping
089 send ping
109 send ping
129 send ping
130 rx pong
150 tx ping
151 rx pong

as far as I can tell server is not sending reply...

add console logging on server and look into who...


I think I forgot to send most recent compile to server...it works now...


ping graph dumps a bunch of shit to console...fixed

make it so that once init state is rx, do a one time send ping by setting flag...

OK I think I have that one thing figured out....

clean up and move on...

this is how I handle client ping sends:

made a timer:
png_timer = al_create_timer(.5);   // 2 fps

made a variable in player1 array:
players1[].client_ping_flag

when timer event fires:
if (ev.timer.source == png_timer) players1[active_local_player].client_ping_flag = 1;

in the main loop just after every thing else:
if ((players1[active_local_player].client_ping_flag) && (ima_client))
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

in client setup, when initial state is received:
players1[active_local_player].client_ping_flag = 1;

the only thing I might like to add later is a method of slowing the ping timer...
maybe I don't need to...2 packets per second is hardly anything

now I want to make the ping and sync graph easier to use..

first of all...
make a button on logging to load most recent file in log file viewer..done
then remove profile button from that page...done
then put both pages adjacent...done

now, how do I make ping sync graph better?

I can do most stuff with generic profile graph
tmaj and ping

the only nice thing about the specific one is that it has ping also...

make it all use profile...

ping uses 37
old tmaj uses 36

tmr uses 44

do both for now:

LOG_NET_client_timer_adj 36
LOG_NET_client_ping 37

new:
LOG_TMR_client_timer_adj
LOG_TMR_client_ping

now both graphs can co-exist....


after all this messing around, I have not come to any real conclusions

client sync is still pretty much what it used to be...


now can I finally look at what changing s1 and s2 do?


server_rewind is called and it determines if it is time to make a new state and send dif...

if the current mwPS.frame_num matches the mwPS.frame_num of the last saved base+s1+s2....

then it is time....

- rewind to the last saved base
- play forward s1 frames
- save new state
- play forward s2 frames




random demo game is very not random...
always starts with trigger...
add this: srand((unsigned) time(&t)); // done
checkbox to test opacity on demo...done
when starting stuff from demo save config first so it comes back to the same page..done



next on my simulation
keep client and server frame numbers different
when server is in rewind do not move client fn...

when server makes new state, jump to clients side and receive and rewind it...



what happens if I set s2 to 0??

LAN seem to work with no issues...
WAN i get a few late cdats and some noticeable corrections

tried s2 == 1
WAN was about the same...






I never use the 4 states in this array:
// server's copy of last stdf state
extern char srv_stdf_state[4][STATE_SIZE];
extern int srv_stdf_state_frame_num[4];

I only ever use [1]


I should remove it and make it a flat array....

do I use all 8 of these?

extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

they are server only, so is 0 unused?

I would have to say I think it is

so for server only iI can use 0

I am currently using:
srv_stdf_state[1]
srv_stdf_state_frame_num[1]

I propose to use:
srv_client_state[0][1]
srv_client_state_frame_num[0][1]

I am 99% sure I can do this...so do it...but doc all that you do....

7 occ of
pm..done
main...done
fnx memset..done

loop: 2 places....
old:
game_vars_to_state(srv_stdf_state[1]);
srv_stdf_state_frame_num[1] = mwPS.frame_num;

new:
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;

server 1:
//mwPS.frame_num = srv_stdf_state_frame_num[1]; // set rewind frame num
//state_to_game_vars(srv_stdf_state[1]);   // apply rewind state
mwPS.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
state_to_game_vars(srv_client_state[0][1]);   // apply rewind state

server 2:
//game_vars_to_state(srv_stdf_state[1]);
//srv_stdf_state_frame_num[1] = mwPS.frame_num;
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;


4 more in server:
if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
sprintf(msg, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
if (cdat_frame_num < srv_client_state_frame_num[0][1])
printf("[%d]late cdat dropped p:%d c:%d  state:%d  tally:%d\n", mwPS.frame_num, p, cdat_frame_num, srv_client_state_frame_num[0][1], players1[p].late_cdats);



it still seems to work...remove all traces...

I would like to put all netgame stuff in its own file...

n_netgame.cpp
n_netgame.h

do it...done...



20230124 6:15AM

I have some thoughts about what I would like to monitor:
I want to be able to see how much the clients need to rewind
in LAN test they are exact or 1






I think I have an idea about what s2 is for..
its so that the difs sent are not the most current







remove from player1 struct??
there is no field anymore...

//   float field_damage_tally;
//   int field_damage_holdoff;
//   int field_damage_enemy_number;




but is it used for other stuff?  like mine or block damage?
idk
yes, used for block damage, but not mine...


game_event(59
called only when block_damage is taking health from player

game_event(57
not called at all

game_event(50
mine collison

convert the bit in health to work with block_damage
OK I fixed all that, but that was not what I planned to do...


I wanted to add client_rewind to player1...done and added to client debug grid...done
LAN always 0 or 1..even when increasing s1 and s2...
WAN always 1 or 2..even when increasing s1 and s2... (ping ~27)



20230125 2:20AM


add some sort of manual sync control to client

Like I can set to manual, or the value for auto..

I want to experiment with changing offset and seeing how my clients rewinds come out..


what variables?, should I put it in settings? yes, and also live control..

players1[p].client_chase_offset

currently set in add ping:

players1[p].client_chase_offset = - players1[p].ping_avg;

also in debug overlay


double client_chase_offset;
double client_chase_offset_auto_offset;
int client_chase_offset_mode; // 0 = manual, 1 = auto

add button /auto/manual done
make button adjust ping offset in that mode..done...

now make a way to view client rewind in real time..I can see it in debug grid just fine...


in LAN mode, if I increase a few ms, I no longer jump from 0 to 1, I stay steady on 1

in WAN mode with a ping of 20-30, if I add or subtract a few I can force mostly 1 or 2 for rewind

what have I learned from this?

idk...


I am trying to figure out the effect of changing client sync offset

what effect does it have on when server receives cdat?  I guess I actually have to press keys to see that!

when client is doing rewind of 2 server say game move sync is 0


s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

I think I am on to something here...

try this with different s1 and s2 values

s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

s1:3 s2:2
crwd sgms
2    0
1    -1
0    -2

s1:4 s2:2
crwd sgms
2    0
1    -1
0    -2

that did not seem to change anything...
how is sgms calculated?

void server_proc_cdat_packet(double timestamp)
{
   players1[p].server_game_move_sync = cdat_frame_num - mwPS.frame_num;


what does this tell me?

at what point of sgms are cdats considered late and not applied?
when they are earlier than last saved server state...

lets try to make that happen...

when client moves ahead of server with a positive offset
and sgms gets to -3 then I get late cdat errors...

changing s1 did not seem to affect this...


on client, when I adjust dsync too high it ramps...see if I con find out why...


It looks like my raw calclution of dsync...when it goes over 25, it subtracts 25....

   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   players1[p].client_sync = dst - mwPS.frame_num;               // crude integer sync based on frame numbers

   if (players1[p].client_last_stdf_rx_frame_num != mwPS.frame_num)       // this is the first stdf received for this frame
   {
      players1[p].client_last_stdf_rx_frame_num = mwPS.frame_num;         // client keeps track of last stdf rx'd and quits if too long
      players1[p].dsync = al_get_time() - timestamp;                 // time between when the packet was received into the packet buffer and now
      players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot
      dsync_array_add();
      client_timer_adjust();
   }


the problem is that csync goes to 1 for only one frame

the problem is much deeper than that....
the client has no way of dealing with a future dif...
it just applies it, and that has the effect of the client jumping forward in time

yes abandon this line of questioning, I don't really care about this case...or do I?

what would happen if I did not apply till the next frame??

I think I have that fixed, and it seems to work...


I need to change to docs...

now why did i do that again?


to see what happens to sgms and crwd...ok let see...


crwd now goes to -1 and -2, never got less than zero before...
sgms now to -3 and -4....

when sgms goes to -3 (in s1:3 s2:1) late cdats happen constantly

lets try changing s2....

when s2 goes to 2 late cdats stop...
then increasing client offset till sgms = 4
late cdats again...

I think I found out something...

s2 affects late cdats...

lets do a grid compare again..

WAN with 20-30ms ping


s1:3 s2:0
offs crwd sgms late cdats
-40  2    0
-15  1    -1  rare
+10  0    -2  constant
+80       -6  game done

s1:3 s2:1
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same
          -6    game done


s1:3 s2:2
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same game done


s1:3 s2:3
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    none
+54  0/-2 -4    rare
+80  0/-3 -5    constant
+86       -6    game done


s1:3 s2:4
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5    rare game done


OK now what if I try changing s1:

leave s2 at 1

s1:1 s2:1
offs crwd sgms late cdats base resets
-40  2    0
-15  1    -1
+10  0    -2   rare
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5



with s1 set at 1, I get constant base resets 7K dif size 7 packets 290kBs or 2.3Mbps
lets just throw this one out...its sending dif every frame...

OK so lets start with the minimum s1 of 2
now around 30kBs or 0.24Mpbs

s1:2 s2:1
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   occ/rare   occ/rare
+35  0/-1 -3   constant   const
+54  0/-2 -4   lost server


s1:2 s2:2
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   rare       const
+50  0/-2 -4   const      const
+55  lost server

s1:2 s2:3
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   0          const
+50  0/-2 -4   rare       const
+55  lost server


redo 3
around 21kBps or 0.17Mbps


s1:3 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    const      0
+40  0/-2 -3    const      occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    rare       0
+40  0/-2 -3/-4 most       occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 0          0
+25  0/-1 -3    0          0
+40  0/-2 -3/-4 0          occ
+45  0/-2 -4    0          const
+68       -5    const      const
+80 lost server

now do 4
15kBps or 0.12Mbps


s1:4 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+20  0    -2/-3 occ        0
+30  0/-1 -3    const      0
+50  0/-2 -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+40       -3/-4 rare       0
+50       -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+50       -4    0          0
+65       -4/-5 rare       occ
+70       -5    const      const
+95       -6
+110 lost server



OK... there is alot of data:

its 7:30 so I don't have time to analyze

very briefly

s1
min:2
best 3-4


s2
min:0
best 1-3

3 2 will probalby be best...

experiment with auto sync at 1/2 round trip ping....



20230126 3:00AM

So see if you can do so sort of summary...

s1
controls the frequency or sending difs
1 sends them every frame, should not use, every dif will be full size
2 sends every other frame, occasional base resets are common
3 base reset are very rare


s2
how much the client can lag server without late cdats..
1-3 works probably use 2..


there are probably other things that these affect, that I have not been able to measure yet
I assume that the longer I take to rewind and resnd, the more jarring the corrections will be..

I need some way of measuring that...


how long from sending a cdat, does the client need to wait before it gets a dif with that cdat...
that sounds so simple, how will I measure it

client rx dif for frame 98-100, current client frame = 102...

client rewinds to 100 and ff 2..

so that worst case is a move made on frame 98 does not get back to client until 102...

something like that, lets look at some real data from a log...

3871 tx cdat
3873 dif applied 3867-3871

just that one line:
3873 dif applied 3867-3871

tells me that at worst case 3873-3867 = 6 frames before making a move and getting the official dif from server

this was in mode 4 3..

try in mode 2 3











side track:

why does server rack up a shitload of base resets, waiting for client to join?

make finer tuning of stdf shit in log

I would like to be able to filter out all unsuccessful dif applied
there are a lot of them

maybe a different tag for succesfull vs unsuccesful

27 and 29


extern int LOG_NET_dif_applied;
extern int LOG_NET_dif_not_applied;

replace
extern int LOG_NET_stdf_when_to_apply;

done...the logging is much more better...



mode 2 3 gets 4...this is better yes?

should I calculate and show on client?


where? when dif applied
saved where?

new var
int client_move_lag;

done...now experimeting with that..
I would assume that lower is better..

I have found that when s1 = 2
I need to adjust offset so dsync is about -12 (half frame) or I get base resets...

should I show somewhere on client the base resets?

I already have players1[p].client_base_resets++; on the server
re use it for clients...done..now in debug grid



so, is that what I should do for offset?  aim for - 1/2 frame??

ping  offset
0-12   -12
12-37  -37


changing the offset changes move_lag also...


I have one setup that should work good but the corrections are quite jarring:
s1:2 s2:2
move_lag:2
dsync +12
sgms -2
no late cdat
no base reset

this one has much less jarring corrections:
s1:2 s2:2
move_lag:3
dsync -12
sgms -1
jno late cdat
no base reset

also good is
s1:3 s2:1
move_lag:5
dsync -35
sgms 0
jno late cdat
no base reset

many settings work
also good
s1:2 s2:1

maybe the move_lag is not all important...
it can be longer, as long as the prediction and the actual are not too far off...

I might just be as good as I can get...

set offset so that dsync is about 12-14 ms independant of ping

figure out how to test on worse networks...

why does reducing s1 cause bad problems on server?
kicks client and wont let new one connect

when the new one tries to connect:
server log shows stak reply that client fails base set, has base from previous game


am I not resetting something on server?
when that happens on server, server resets its copy of client base state to zero..
am I not resetting that on client?


reset_states()
client_state_dif_src = -1; // -1 will never match a mwPS.frame_num
client_state_dif_dst = -1;

this will mark if we have not received a state yet, or the state is a bad decompress



server keeps old last acked state for client

need to reset that on server when client quits or is dropped....done

changed this:
void client_apply_diff(void)
{
   int p = active_local_player;

   // check if valid dif
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1))
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
//      if (mwPS.frame_num == 0)
//      {
//         printf("initial state - dif_src:%d dif_dts:%d  cbsfn:%d \n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
//      }
//      if ((client_state_dif_dst > client_state_base_frame_num) || (mwPS.frame_num == 0)) // stored dif with a new dest, or initial state (frame 0)



      if ((client_state_dif_dst > client_state_base_frame_num)) // stored dif has a newer dest
      {

OK with that cleaned up..back to why reducing s1 is bad...does not seem to be bad any more, maybe test more...


when client does level done and starts new level...
it is not waiting for initial state...that is the way it should be
it is still getting stdfs from last level...? at least it is smart enough not to try tp apply them

on the server, do I need to reset client states at level done??

in level done reset_states is called....

clientlog:
------------------
1    client rx dif from 22122 to 22124
     client says wrong client base and replies with 0 for client base
4    client rx dif from 0-22126
4-10 client doesnt apply...too early
11   client rx dif from 0-3

then we are back on track..


server log:
------------------
22122 tx 22120-22122
22123 rx stak  22122
22124 tx 22122-22124
22125 rx stak  0
22125 server drop player sync>100
22126 tx 0-22126
22127 NEXT LEVEL
3     tx 0-3
4     rx stak 3

then we are back on track..

OK what can I do about this?
nothing right now...its time for work...

20230126 7:37AM
20230127 4:24 AM

why do I want to do something about it? it works
I don't like how the server tries to drop the client


I don't like how the client is still getting difs from the previous level.
It is just a natural consequence of the client being ahead of the server..

What if on the client, I check to see if dif_src is much larger than current frame number?
Won't this also catch initial state? Maybe not...is not initial state dif_src == 0?

if (client_state_dif_src - mwPS.frame_num > 100)


I have rewritten the client_apply_dif() again..


this time I have front loaded all the tests and added one for  if (client_state_dif_src - mwPS.frame_num > 100)
it only seems to catch when level done and client is ahead of server...


void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - mwPS.frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d mwPS.frame_num:%d\n", client_state_dif_src, mwPS.frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // stored dif has a newer dest
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }

            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);

               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = mwPS.frame_num - client_state_dif_dst; // dst compared to current mwPS.frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", mwPS.frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (mwPS.frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (mwPS.frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));


                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mColor.pc[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

                  // for initial state only
                  if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);

                  players1[p].client_last_dif_applied = mwPS.frame_num;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = mwPS.frame_num - client_state_dif_src;

                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}

this is a log of how it works


[31][1][2272]dif [2267 to 2269] not applied - not newer than current [2269]
[27][1][2273]rx dif complete [2269 to 2271] sync[-2] dsync[-35.9ms] - decompressed
[30][1][2273]dif [2269 to 2271] applied - rewind [2] frames
[31][1][2274]dif [2269 to 2271] not applied - not newer than current [2271]
[27][1][2275]rx dif complete [2271 to 2273] sync[-2] dsync[-36.7ms] - decompressed
[30][1][2275]dif [2271 to 2273] applied - rewind [2] frames
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                              NEXT LEVEL:151                              |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 151 STARTED                             |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[31][1][1]dif is not valid - src:-1 dst:-1
[27][1][2]rx dif complete [2273 to 2275] sync[2273] dsync[56839.2ms] - decompressed
[31][1][2]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:2
[31][1][3]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:3
[31][1][4]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:4
[31][1][5]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:5
[31][1][6]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:6
[31][1][7]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:7
[31][1][8]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:8
[27][1][9]rx dif complete [0 to 3] sync[-6] dsync[-136.1ms] - decompressed
[31][1][9]Resetting client base state to zero
[30][1][9]dif [0 to 3] applied - rewind [6] frames
[31][1][10]dif [0 to 3] not applied - not newer than current [3]
[31][1][11]dif [0 to 3] not applied - not newer than current [3]
[27][1][12]rx dif complete [3 to 5] sync[-7] dsync[-168.9ms] - decompressed
[30][1][12]dif [3 to 5] applied - rewind [7] frames
[31][1][13]dif [3 to 5] not applied - not newer than current [5]
[31][1][14]dif [3 to 5] not applied - not newer than current [5]
[31][1][15]dif [3 to 5] not applied - not newer than current [5]
[27][1][16]rx dif complete [5 to 7] sync[-9] dsync[-210.9ms] - decompressed
[30][1][16]dif [5 to 7] applied - rewind [9] frames
[31][1][17]dif [5 to 7] not applied - not newer than current [7]
[31][1][18]dif [5 to 7] not applied - not newer than current [7]
[27][1][19]rx dif complete [7 to 9] sync[-10] dsync[-243.8ms] - decompressed
[30][1][19]dif [7 to 9] applied - rewind [10] frames
[31][1][20]dif [7 to 9] not applied - not newer than current [9]
[31][1][21]dif [7 to 9] not applied - not newer than current [9]
[31][1][22]dif [7 to 9] not applied - not newer than current [9]
[27][1][23]rx dif complete [9 to 11] sync[-12] dsync[-285.9ms] - decompressed



windows wants to do an update so I am going to do a push first


then go through code and make sure dif is not spelled diff
and that state and dif refer to the proper things...


'state' refers the the entire game state, typically put into a char array of size STATE_SIZE
'dif' is when 2 states are subtracted, resulting in the diference between the 2

difs are then compressed, optionally broken into packet sized pieces and sent from server to clients

when a client has all the pieces of a dif, and the state on which it is based,
it applies the dif to its base state, recreating the server state..

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

removed this... i don't think it ever applies... in the previous line mwPS.frame_num will be set to something non-zero

                  // for initial state only
            //      if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);




re did the netgame docs for client_apply_dif()

time for work:

20230127 7:25AM


what do I want to do next?

make the auto offset run at - 1/2 frame

figure out how to test with bad network...


document:
void client_fast_packet_loop(void)
void server_fast_packet_loop(void)

extern struct packet_buffer packet_buffers[200];
struct packet_buffer
{
   int active;
   int type;
   double timestamp;
   int who;
   int packetsize;
   char data[1024];
};



files I want to have for netgame

netgame_client_state

netgame_client_sync

netgame_client_control_change

netgame_fast_packet_loop

netgame_state (describes state and dif)







fixed a bug in STATE_SIZE
old:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

new:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

the totals are the same, but the individual value for itemf was wrong..


I have netgame_state_and_dif complete...

next finish netgame_client_state..done...
now make a few links from one to the other....
did reset to zero -> state copmpression methods...
stak...done
state..done

next do:

netgame_client_control_change...done

netgame_client_sync



I just found something I didn't realize

      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


I though that the client used the server's local frame number when calculating sync
it doesn't...

what it uses is the dst frame number, which, depending on s2 is NOT the server's local frame number

what does this all mean?

is my sync not what I thought it is?

the client is syncing to the dst frame of the state....


why do I even need s2 is my question??

could I not handle that by just moving clients sync offset??




try this by making s2 = 0 and running some tests...


if s2 == 0 then dst == server local frame num...




LAN (ping 0.1-0.2)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  5        3    2    0          0
-45  4        2    1    0          0 - playable
-20  3        1    0    0          0 - very playable
+5   2        0    -1   0          0 - very playable
+30  2        0/-1 -2   const      0



4.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  6        3    2    0          0
-45  5        2    1    0          0 - playable
-20  4        1    0    0          0 - very playable
+5   3        0    -1   0          0 - very playable
+30  3        0/-1 -2   const      0






WAN (ping 22-27)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  5        3    1    0          0
-38  4        2    0    0          0 - playable
-13  3        1    -1   very rare  0 - playable (better)
+12  2        0    -2   const      some


WAN (ping 22-27)
5.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  6        3    1    0          0
-38  5        2    0    0          0
-13  4        1    -1   very rare  0
+12  2        0    -2   const      0


conclusions:


I think I could do without s2: not sure why I had it in the first place....



am I ready to test degraded network?



yes!!



tried clumsy 0.3rc4-win64a on win7 e6430
failed to open device 577


linux...


tc and netem


Linux  tc & netem

The most low-level and feature-rich at the same time is Linux Network Emulator (netem). If you are using one of the most common Linux distributions(Fedora, OpenSuse, Gentoo, Debian, Mandriva, Ubuntu) you already have it enabled in the kernel. It comes along with another built-in utility Traffic Control(tc). There is no UI, just CLI, the way most of Linux users like it.

Obviously the sky is the limit in terms of functionality with this tool. I would provide some examples, just to give you a hint:

tc qdisc add dev eth0 root netem delay 100ms

What happens here:

    tc qdisc  what Traffic control is doing under the hood is configuring the kernel packet scheduler.
    add  operation of appending new rule, after the test you probably would want to execute `del` operation.
    dev eth0  the device on which the rule would be applied.
    root  apply it on the egress (outbound traffic) qdisc
    netem  use the network emulator
    delay  network metric to be modified
    100ms  value to be set on this metric

So overall this adds a delay of 100ms to outbound traffic.

This is how can you set it up to simulate 5 percent of packet loss, 2 percent of packet corruption and 1% of duplication:

tc qdisc add dev eth0 root netem loss 5%tc qdisc change dev eth0 root netem corrupt 2%tc qdisc change dev eth0 root netem duplicate 1%

Not enough? Here comes more:

tc qdisc change dev eth0 root netem delay 10ms reorder 25%

With this rule, 25 percent of packets will get sent immediately, others will be delayed by 20ms.

And so on, I think you have got the idea. In the end if you want to delete these traffic shaping rules, just execute:

tc qdisc del dev eth0 root

Check out the manual to get more information.

It is installed on scat Ubuntu 20.04.5 LTS

the line I need to use is:

sudo tc qdisc add dev eno1 root netem delay 100ms

first of all test with 40



set up 40ms delay on outgoing traffic:
--------------------------------------
sudo tc qdisc add dev eno1 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev eno1 root


How can I use netem on incoming traffic?

You need to use the Intermediate Functional Block pseudo-device IFB . This network device allows attaching queuing discplines to incoming packets.

 # modprobe ifb
 # ip link set dev ifb0 up
 # tc qdisc add dev eth0 ingress
 # tc filter add dev eth0 parent ffff: \
   protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
 # tc qdisc add dev ifb0 root netem delay 750ms



set up 40ms delay on incoming traffic:
--------------------------------------
sudo modprobe ifb
sudo ip link set dev ifb0 up
sudo tc qdisc add dev eno1 ingress
sudo tc filter add dev eno1 parent ffff: protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
sudo tc qdisc add dev ifb0 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev ifb0 root

















can I do some sort of max correction measurement on the client?
like actually measure the difference between the local and the server
lets use players x pos.. beacuse y might be on the ground...


how to do this??


good, now what to do with it?

get the max and avg

no, just the max, but reset every 2-3 sec

   float xcor_max;
   int xcor_reset_frame;


this works...


the max correction I can get is when I am manuall running back and forth, fakekey has much less corrections

the max possible would be if I was running in one direction and changed the same frame I got a correction...i think...

test manually for now by running back and forth

I think the max is achieved by running in one direction than changing
that way I get multiples of 4, the max x speed of the player




LAN (40ms) 20in 20out

s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  6        3    0    0          0           12
-35  5        2    -1   0          0           8
-20  4        1    -1   0          0           4
+5   3        0    -2   yes        0

s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  nan      3    0    0          const       12
-45  4        2    0    0          0           8
-20  3        1    -1   0          0           4
+5   2        0    -2   yes        0



LAN (60ms) 30in 30out

s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  6/7      2/3  -1    0          0           12
-45  6        2    -1    0          0           8 - playable
-36  6        2    -1/-2 yes        0           4 late cdats  start

s1:3 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  5/6      2/3  -1    0          occ         12 base resets stop
-45  5        2    -1    0          0           8 - playable
-36  5        2    -1/-2 yes        yes         4 late cdats and base resets start

s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
at no time do base resets stop...
late cdats start at -35



LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable



LAN (100ms) 50in 50out
s1:5 late cdats start at -76
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-80  9        4    -1    0          0           16 - playable

now I want to test with random shittienes...

lets do 30 20 on both in and out

from 10-50 delay

its still playable at -80 on s1:5


I can't wait to test dropped packets and corrupt packets

duplicates should not be a problem, but corrupt? I have nothing to stop bad shit from happening...

reset cor_max on level start...with player stuff...done...

don't reset offset mode and offset...

how am I going to set this up?

- use ping average

first of all, how should I set s1:?

actually even before that, does s2 really not do anything useful?

go back to an exmaple




LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable


try this with different s2 values...


sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms




LAN (80ms) 40in 40out

then
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

now:
s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
base resets stop at -73 and start again at -1

base resets start at -81



I am so confused...


I should make a training sequence to get this info automatically

It should cycle through the values for offset and see where base resets and late cdats happens...



how can I do this?

start server on s1:3

redo all these test manually and this time:

measure when br and lc start and stop...




sudo tc qdisc change dev eno1 root netem delay 0ms
sudo tc qdisc change dev ifb0 root netem delay 0ms


LAN (0ms)
s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-25  3/4      1/2   0    0          0
-15  3        1     0    0          0           4
0    2/3      0/1   -1   0          0           4
25   2        -1/0  -2   yes        0

late cdats start >+25 stop: n/a
base reset start lose sever before than happens


ping / 25

>100 = 4
>75  = 3
>50  = 2
>25  = 1

s1 = 2+(ping/25)

2 for LAN

3-5 for internet

first of all, find settings to get no base resets
s1 and offset

I guess even before that, go back to why lowering s1 can drop client and prevent reconnecting
I though I had it fixed but it still happens...

on client in the join procedure it look s like it never gets initial state


on server the first drop was for last stak rx > 100 (fix spelling!!!)


maybe on the server the rewind thing gets broken...

   int s1 = players1[0].s1;
   int s2 = players1[0].s2;
   int s3 = s1+s2;

   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
   {


   if (mwPS.frame_num >= srv_client_state_frame_num[0][1] + s3)

I think that fixed that...lets see if I can lower s2 to 0 also...
looks good....


now how can I do a training session?

makes sense for newly joining clients, but not server

run training session on client....



ramps through the offset values by fives
starts at 0 and decreases until -100

stays on each for 1s

how many late_cdats
how many base_reset

---------------


I still want to know if changing s2 does anything

sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms


LAN (80ms) 40in 40out
s1:4 s2:0
base resets
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
start at -100 and increase
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


here is some great evidence...changing s2 from 0 to 1 definitely affected late cdats
but...did it really???
it just put a 25ms offset on dsync!!!



test some more...

why are base resets so cyclic?










LAN (100ms) 50in 50out
s1:5 s2:0
base resets never
late cdats start at -76

LAN (100ms) 50in 50out
s1:4 s2:0
base resets always
late cdats start at -76

LAN (90ms) 45in 45out
s1:5 s2:0
base resets never
late cdats start at -66

LAN (90ms) 45in 45out
s1:4 s2:0
base resets (16 on)
-90 to -76
-66 to -50
late cdats start at -66


LAN (80ms) 40in 40out
s1:5 s2:0
base resets never from -100 to +40
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


LAN (70ms) 35in 35out
s1:4 s2:0
base resets: never from -100 to 0
late cdats start at -46

LAN (70ms) 35in 35out
s1:3 s2:0
base resets: (20 on)
-95 to -75
-70 to -50
-55 to -25
-20 to 0
late cdats start at -46


LAN (60ms) 30in 30out
s1:4 s2:0
base resets: never
late cdats start at -36

LAN (60ms) 30in 30out
s1:3 s2:0
base resets: (9 on)
-86 to -75
-61 to -49
-36 to -25
-11 to 0
late cdats start at -36



LAN (50ms) 25in 25out
s1:4 s2:0
base resets: never
late cdats start at -26

LAN (50ms) 25in 25out
s1:3 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at -26


LAN (40ms) 20in 20out
s1:3 s2:0
base resets: never
late cdats start at -16

LAN (40ms) 20in 20out
s1:2 s2:0
base resets: (16 on)
91-75
66-50
41-25
16-0
late cdats start at -16


LAN (30ms) 15in 15out
s1:3 s2:0
base resets: never
late cdats start at -6

LAN (30ms) 15in 15out
s1:2 s2:0
base resets: (6 on)
-81 to -75
-56 to -50
-31 to -25
-6 to 0
late cdats start at -6


LAN (20ms) 10in 10out
s1:2 s2:0
base resets: never
late cdats start at +4

LAN (20ms) 10in 10out
s1:1 s2:0
base resets: (21 on)
-96 to -75
-71 to -50
-46 to -25
-21 to 0
late cdats start at +4


LAN (10ms) 5in 5out
s1:2 s2:0
base resets: never
late cdats start at +14

LAN (10ms) 5in 5out
s1:1 s2:0
base resets: (11 on)
-86 to -75
-61 to -50
-36 to -25
-11 to 0
late cdats start at +14

LAN (0ms) 0in 0out
s1:2 s2:0
base resets: never
late cdats start at +24

LAN (0ms) 0in 0out
s1:1 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at +24


what is the correlation of those two variables?

ping 100 needs s1:5 offset < -76  (4 + 25)
ping 90  needs s1:5 offset < -66  (4 + 16)
ping 80  needs s1:5 offset < -56  (4 + 7)
ping 70  needs s1:4 offset < -46  (3 + 20)
ping 60  needs s1:4 offset < -36  (3 + 9)
ping 50  needs s1:4 offset < -26  (3 + 2)
ping 40  needs s1:3 offset < -16  (2 + 16)
ping 30  needs s1:3 offset < -6   (2 + 6)
ping 20  needs s1:2 offset < +4   (1 + 21)
ping 10  needs s1:2 offset < +14  (1 + 11)
ping  0  needs s1:2 offset < +24  (1 + 2)

so, given an input, ping, formula for s1

                    ping/20
 0 < ping < 20 = 2    0
20 < ping < 40 = 3    1
40 < ping < 60 = 4    2
60 < ping < 80 = 5    3

s1 = 2 + (ping/20)

will never be less than 2



formula for offset

ping  offset
0  -> 10
10 -> 0
20 -> -10
30 -> -20

offset = (10-ping)

I can easily do this on the client
offset = (10-ping)


on the server though...

take the average client ping?
worst client ping?

set s1 from that?


but I don't want to change it too often

is once per second too often??

first of all, do the client auto stuff...done


now where to do the calc on the server



first of all, what the hell?


server sets:

            double t0 = PacketGetDouble();
            double t1 = al_get_time();
            players1[p].ping = t1 - t0;

when rxing both ping and pang...that cant be right....

cli tx ping
srv rx ping then tx pong
cli rx pong then tx pang
srv rx pang

it should be only when server rx's pang..it makes no sense to do it after rxing ping...


client does a nice average for its local ping..that doesn't help me..

server need to keep track of maximum and reset somehow...

make a var in player struct....

20230129 5:49 AM

I made a lot of progress yesterday...

I am pretty sure that s2 is not needed, all it does is adjust where in the cycle the dif is sent,
so all it really does give an offset to dsycn on the client...

I did a lot of tests, made some new measurements, and made some automatic adjustments..

I should add some of this info to the docs...


what am I going to do with client offset?

10-ping...
did I not alreay have -ping
yes I did...

so if I make the offset +10 by default that should so it. It will stay there unless changed..
that takes are of that...

now for for the other one...

everytime server gets a pang packet, it calculates the ping for that client
at the same time, it checks that ping value only against max client ping and sets if higher

if (players1[p].ping > players1[0].server_max_client_ping) players1[0].server_max_client_ping = players1[p].ping;

then in the once per second timer area, if server...
use that max client ping to set s1, then reset max client ping

if (ima_server)
{
   int cmp = players1[0].server_max_client_ping*1000;
   players1[0].server_max_client_ping = 0;
   if (cmp > 100) cmp = 100;
   players1[0].s1 = 2 + cmp/20; // use client max ping to set s1

this looks like it is finished, as long as it keeps working as good as it has...


so now what?


what are sc cs and rt in server debug grid?
are they used?
how are they calculated


void server_proc_stak_packet(void)
{
   int p                        = PacketGet1ByteInt();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;

   int sfn1 = ack_frame_num;
   int cfn = client_frame_num;
   int sfn2 = mwPS.frame_num;

   players1[p].sc_sync = sfn1 - cfn; // packet stdf from s to c  sfn1-cfn
   players1[p].cs_sync = cfn - sfn2; // packet stak from c to s  cfn-sfn
   players1[p].rt_sync = sfn2 - sfn1; // round trip to server back to server through client via stdf and stak


all three of them are only used to show in server debug grid, and I don't recall them ever being useful...

lets kill them...done...

make a new switch -tl to copy src dir only to linux...


done...

now just run pm -tu, then recompile on ubuntu..

now I can complie and run on linux with F9...not sure why I could not run on linux before, except command line...
still can't just click on the executable in linux though...


anyway, now that I have that done lets check out the new server debug grid


what is lcls...late cdats last second...makes sense...
lets hide if for now...


when server displays dsync for clients, where does it come from?
client sends it to server with stak packet

what is gmav on server for each client...
// client game move sync avg last sec
the amount of time between server getting cdat and when it should be applied...???

pretty much follows offset on client....
when client offset is 10ms, gmav is -10...etc...i think ill keep it for now....but hide it



what is server_sync used for?

server keeps track of it for each client when stak packet received

void server_proc_stak_packet(void)
{
   int p                        = PacketGet1ByteInt();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;
   server_lock_client(p);



server uses it to lock clients when first joining

void server_lock_client(int p)
{
   if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
   {
      if ((players1[p].server_sync > -2) && (players1[p].server_sync < 5)) players1[p].sync_stabilization_holdoff++;
      else players1[p].sync_stabilization_holdoff = 0;
   }
   if (players1[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
   {
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      players1[p].sync_stabilization_holdoff = 0;

      sprintf(msg,"Player:%d has locked and will become active in 4 frames!", p);
      if (LOG_NET_join) add_log_entry_header(11, 0, msg, 0);
   }
}


server uses it to drop clients if it goes over 100

         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
         }


I now have dsync, which does pretty much the same thing, only higher resolution..
it is calculated on the client and passed to server with stak packet....

just for the sake of making things simpler, could I replace server_sync with the dsync that I get from clients?

why do I need both?


right now, server does not get anything for server_sync until it gets stak packet from client, this should not change anything...


lets run a log and look at the stak packets rx'e by server...especially when joining and level done...



first try to replace in the locking part....

what ranges should I use?

max +30  +0.03
min -150 -0.15
try that...


it seems to work but I should try it on some shitty networks....

where does it show waiting for sync?
it show it on the client (duh!) and uses the varaible client_sync...

on the client,

calculated in rx_stdf:
players1[p].client_sync = dst - mwPS.frame_num;                        // crude integer sync based on frame numbers

then used to calculate higher resolution dsync:
players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot

then after that it is used only to display...
log entries,
client debug grid
"Please wait for server sync" overlay

I think I want make it only used for a few lines in rx stdf
then after that, just use dsync...
client_sync is gone....

back to server sync...

test with 40 30 on both

it joined...


try 80 on both (160)

it still joined...
I think the target was 150 (160-10) so try 90 90 (180)

now it fails...

lets try setting the limit to 0.2 or (200)

that works, it finally joined with a ping of 200

reduced stabilization time to 10 frames...

OK moving on to removing server_sync....

do I even need to drop players with a huge sync??
how about I take a page from the join stuff and make it so that it has to be over the value for a specified number of frames?
or just don't do it...lets try not doing it....

//         if ((players[p].active) && (players1[p].server_sync > 100))
//         {
//            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
//            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)
//
//            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
//            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
//         }
server_sync is completely gone....


that all seems to work...


bug...can't quit on client while waiting for sync

after getting initial state it goes to mode 11, the normal running mode...
but the client is not active yet, until the server says it is....
all I want is a way out of this mode...

added this to control....

      else if (players[p].control_method == 4) // not active and control method 4 is a client waiting for server to make it active
      {
         if (mI.key[ALLEGRO_KEY_ESCAPE][1]) new_program_state = 25; // give them an escape option
      }

there do not seem to be any other escape routes in client setup...

if the network setup fails, it will just timeout...

what about when waiting for a join invitation?
it normally never fails, but lets make it fail then make a way out...done
nothing is shown, except on the console, but that's ok

can I add one to the network setup?
especially the part where it waits for a response...done

now fix what you broke....done...


moving right along... now what?

remove s2....

should I rename s1?

im doing documnenataion and would like to call it something else..

i used to call it stdf freq

how about dif_freq?
i like that
server_state_frequency would be more accurate
it does rewinds and makes states even when it has no clients...


ok

server_state_frequency it is....

find all s1 and replace...

also kill s2..

...........


more testing, with corrupted and missing packets

more documentation... did a lot of doc......



I don't think I need to send the client ping when the client joins...it should be fine just doing it with just the 2 Hz png_timer
the timer is constantly running, and therefore the flag is set..
only gets cleared if it actually send a ping...

ima_client gets set when sjon is rx'd

while waiting for initial state we are not in mode 11 yet

as soon as innitial stae is rx'd flag is set and we are in mode 11

but!!.. ping is not sent in game loop, it is sent just past it on the outside..

so ping will be sent with 2 Hz timer as soon as ima_client is set when sjon is rx'd
the extra one when initial state is rx'd is still not needed...

OK I'm convinced...kill it...


I don't think I want to save players1[0].server_state_freq in config file anymore...
after all, i dysnalically set it...
just make sure it has a sane value...

at the same time, also lose zlib compression...I have never once changed it...done...

what about TCP/UDP? leave it for now, but its very experimental

Actually I would have liked to experiment with zlib_cmp...
I should make i changeable as the game is running...but no need to set it in config though...

-------------------------


next...


while gointg through the code, i realize...

why do I have two states for every client?

I only keep one previous state...

the other one is only used as a temp storage when making difs...

make sure this is the case, then remove it..

15 occurances:
2 define and declare
4 for clear

that leaves 9
4 time server only [0]
all cases where I use it for the server:
I use [0][1]


I know why!!

I don't actually overwrite the old state until I get an ack for the new one....

OK, just leave it....

experiment with zlib_cmp...I would really like to see it in real time...
i still like 7 the best








can I make a general rolling average algorithm...

then just make instances of it?

what would that look like?
a class


OK, I think I have the class done, now how to patch it in...

lets do cpu...

I need to choose which one I'm going to use and initialize it somewhere....you don't even have to initialize!

make cpu graph show inst and avg...but make text use avg...

looking good...

I add data in loop..
I draw in graph screen overlay

I am spending far too much time on this...
be done with CPU...
in the very middle: CPU: just liek it used to be, then min and max on each side...
CPU is done!!


now redo ping with new RollingAverage

0 = CPU
1 = PING
2 = DSYNC
right in ping array was where the avg was used...move it...done

I think ping is done
next dsync..done...

now remove ping_buffer and all traces of it...done...

nice...now I have a nice rolling average I can use when I want...

I should send dsync _avg to server instead of raw...done

remove the adjustments to s1..just comment out..done
but then I would like to be able to view state_freq...put it in debug grid....done






can I let client know when late cdats happen, so I might adjust offset to prevent it??
the only way would be to add it to stdf packet and that is pretty much full...
I think I use 1022/1024 bytes already


      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


4 stdf
4
4
1
1
4
4
1000
--
1022

do I need 4 bytes for start_byte and packet data size?


what is tha max the could be

well packet_data_size would be 1000 max

what is the data range of a 2byte int?

2^16 = 63356
or +/- 32768

what is the max data size we are prepared to handle? do I have a limit somewhere?

I'm putting it in a buffer the size of a state so that is not a limit...

I don't see anything on the server that would limit it...
it just breaks it into 1000byte pieces...

ok, i only use 1 byte for num_packets so I have a limit of 256 there....

on the client, I have client_state_buffer_pieces[i]

int  client_state_buffer_pieces[16];   // to mark packet pieces as received

so there is my only limit so far and it would be trivial to increase...

start_byte could be 16,000 if I used 16 packets...
still easily fit into 2 bytes...

should I do it?

reduce to 2 bytes...

then I would have 6 extra...
what do I want to send?  how about late_cdats_last_sec...
what is the max that could be?
40 fps could be 40 late cdats...hell I could just use 1 byte for that...
lets just do that...done

OK now client has late_cdats_last_sec...what is he going to do about it?

when not zero, show a warning on the screen in red...

can I make rtextout_centre take an arbitrary font?

11 occurances...
9 uses...2 i just used...
converted...also that fixed edit server name having the wrong font...

I think I will just put this error message on the bottom frame...I like it there better....done...






make the mouse disappear if not moved and and appear if moved
I could put this in the event processing loop...

make a 5s timer...
if the event timer fires (times out), hide the mouse...
if the mouse is moved, show the mouse and reset timer
this worked on my first try...

   mou_timer = al_create_timer(5);    // 5s
   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mou_timer));
   // start timers
   al_start_timer(mou_timer);

   if (ev.type == ALLEGRO_EVENT_MOUSE_AXES)
   {
      al_set_timer_count(mou_timer, 0);
      al_show_mouse_cursor(display);
   }
   if (ev.timer.source == mou_timer) al_hide_mouse_cursor(display);

done......

it is 5:44PM on Jan 30, 2023

I took today opff work due to being sick with a headache...

got a lot done...

next up on the things to do, test more with shitty networks...





there is some stuff that should be cleaned up in program states...

when client exits, it has its own special state 25 where it cleans up, then goes to state 1.

server does not have this...just goes to 1...

in 1:
         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();

            if (autosave_log_on_game_exit) save_log_file();
            if (autosave_game_on_game_exit) blind_save_game_moves(2);

            stop_sound();
            if (program_state != 3) stamp();

            program_state = old_program_state; // go back to the state that called 0,1,2 or 3
         }
      }
      new_program_state = 0;

in 25:

   //---------------------------------------
   // 25 - client exit
   //---------------------------------------
   if (program_state == 25) // client exit
   {
      client_exit();
      new_program_state = 1;
   }

in the interests of making them both them same...

should I make them both like client, or both like server??



both like client...

add a new state then..

19 is server_exit

now find places where the server would exit...


I think I still want to keep:

         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();


and use 19 and 25 for errors in setup...

not sure what I gained here...at least its more consistant looking


now back to doc...where was I? server_setup...??





I have an urge to figure out more exactly what is going on with the timing loop in netgame...


I can picture the server making and sending the state on a specific frame

I will draw a rectangle with time on the y axis like normal

then I will draw a rectangle below it show the clients frame and the offset is determined ny the ping and offset...

I need pictures, diagrams..



go back to your data...

when you increase offset evetually you get late cdat on the server, right?? yes...



that would mean that increasing offset, makes the clients less ahead of the server..

dsync > 0   client gets difs for future frames
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client gets difs for past frames

as the dsync decreases the client has to rewind, meaning that it got a past dif, meaning that the client is further ahead of the server...

dsync > 0   client is further behind
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client is further ahead

so... when offset increases, the client is further behind, until late cdats happen







could I actually do these graphs in real time, based on the real data??

server would should a rectangle the size of stdf freq frames...
server would show when it got stak replies and cdats...



I would need persistant data over the course of a state

sending a new state would reset the variable...

start_frame_num
start_frame_ms
num_frames
num_ms

sdak_rx_ms - how many milliseconds to get the reply from the client
cdat_rx_ms - cdat offset from frame start...


do I already do this with sgms? server game move sync?
measure how far off the cdats are from when they are needed?

I do...

on the sever, I maeasure that and it it always the neagtive of dysnc on the server

for ping 0..clients dsync 10 gmav -10

so I already have this...

what am I trying to figure out here?

Do i just want some nice pictures to help me understand?


from the server's point of view:

see the entire state to state block.
see when sdaks come back..
see when client input arrives..
see how far the client is running ahead/behind

from the client's point of view..
show timing relation to server, (dsync)

I don't think I am getting anything new here...

this is all information I already have...

I think the most important thing is to set state_freq first.
make that as fast as possible, without getting base resets
right now I am just setting that based on ping...

would it be any better if I set it based on how long it takes to get stak replies?
they are pretty much the same thing as pings...??

then after that set the client offset...

I really can't see any improvements to be made...

I think I might be getting a little lost here...

I think I need to officially stop messing with the netgame stuff...
I am afraid that there might be a few improvements I could do that if I don't do it now I never will...

the only improvement I could possibly think of, is when in the loop are dif's made and sent...

I went down that rabbit hole once, it was very complicated and I never came to any resolution...

at most, I could save part of a frame in time...maybe...

here is the old description:

In the game loop, 'server_send_stdf()' is called after 'move()' but before 'draw()'

It is important that it is in this place in the game loop.

It cannot be called before move...why not??

Was it because in the old way, frame numbers changing was a big issue?

Now the frame numbers are the same in both places.

the state needs to be made at a very specific place in the loop, you can't just move it before or after the input has been applied and moves made

I don't think it really matters at all now, but I would like to test it.....later

now that I think about it, why do I make a state before input is applied for a frame?

I don't know, but it smells wrong...

rewind 3
play 3
make state
do input
move
send dif
draw

back to top



what do you think it should look like, and why?

rewind and get all missed input
do input for this frame
move

make and send state

draw


what if I did the rewind for input independant of the make and send state?

and only do it if there is actually something to rewind for...

I could do it every frame. if I remember, it was not expensive in cpu time..

but why? what are you trying to achieve?

premature optimization when you don't even think there is a problem?

the problem I thought I saw was the server replaying and making states early in the frame.
then still applying local input and doing the move after...

I thought this would result in the state being made and sent to the clients just before it changed as opposed to just after it changed...
that still seems true..


but the way I have things set up, after loading a state, both client and server still expect to play that frame out...

what if I changed it to:

server saves states after all input and moves are done for mwPS.frame_num
then when loading them the first thing that shoud be done is to increment the frame number and start at the top of the loop.

basically I would be changing the states behaviuor from:
frame:100 starting state
to:
frame:100 ending state



OK this is the final time we go over this:


frame++ (100)

server control
 - check for client input and put in game moves array (could get client input for 100 here)
 - time to make state? rewind and replay then make new state for 100 (before any processing of 100)

local input for 100
game moves array input

move 100

send stdf for 100 (pre move)

draw 100


the first thing I notice is that there is no reason to wait until after move to send the state
nothing about the state will change...

the second thing...
the rewind, replay, and make state are at the start of the frame after the previous frame pause...


a thought....

----------------

top of frame

frame++

if it is time to make a new state:

at the start of the frame:
- check for more client input
- do the rewind

do local and game move input...

move the frame

make the state and send it with the frame number for the next frame

draw the frame

----------


all that would be required to make this change is:
- move the part where the state gets made to the send part
- date the frame to the future...

a state would still refer to a frame that has not been processed yet...
the starting state of a frame...

the benefit would be that I am not waiting till the next frame to send a state from the previous...


I think I have convinced myself to do this:

I was very easy to implement...


the first thing I noticed is that late cdats happen at the normal +10 offset...

changing to -10 fixed that..

that would make sense as my timing has shifted by the entire wait period...


should I redo all my time testing? yes


put back the manual adjust of state_freq...



I am loving this new way....

on the server I monitor cdsync and gmav
they can both run in low single didgits


I was working on some tools to help me understand in finer detail what is happening with
the different offsets and state_frequency settings...

I still kind of want to understand this better.


I was wondering if I could remove the ping stuff...
the only reason is to simplify things...

I was thinking of using the stdf-stak exchange..
then the server could calculate ping and send it to clients..

but...
client only replies when applying the dif..

nevermind...it is fine the way that it is..




Could I show a nice rectangular graphical representaition on the server...
Show the width of the state_freq
show when cdats mostly come in
show the client sync
show when sdak was recieved...

does this even make any sense?

the data I would need to keep..

once per state save

start frame
end frame
when was stak rx'd (in finer resolution than 1 frame)
client offset
all the client cdat sync times..

I could just start with frame and stak rx...

make stak rx time and use fine detail


I made stak_dsync and am testing..


something weird..

on LAN (ping < 1)
state_freq = 1

no matter how I adjust client offset, I never get base resets...
saem with 20ms

lets try 30..finally I get some..

stak_dsync is not what I think it should be

I want it to be a positive number in ms
of how far after the frame start i receive stak...
it will probably be very similar to raw ping

I don't seem to be getting anywhere with this


OK lets do something easier, maybe...make a class for last_sec...

what uses it?

lots...
late_cdats_last_sec
game_move_dsync_avg_last_sec
frames_skipped_last_sec
timer_adjust_last_sec

bandwidth counters..
also do frame as well as last sec..

what does each one have in common?
they need a tally, a running total

optional:
number of entries
average
min
max

OK do it...
first what are you going to call it?

mwPerSecond


while implementing, I realized, it doesn't have to be per second
it could be any arbitrary period..
whenever calc is called

also I realized I want to fix the naming of my classes

I want them all to begin with mw then use CamelCase

what do I have so far?

e_mWindow
z_mwGraph
z_qGraph
z_mwRollingAverage
z_mwPerSecond


this is what I want:

mwWindow
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

I want the file name for the cpp and h to be the same as the class name...

start with an easy one: qGrapgh

remove files from project
rename
add files to project

done:
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

window is huge...do it later...


i think tally is ready to implement...

lets try late_cdats_last_sec...

it looks like there are 3 varaibles used in player struct..

   int late_cdats;
   int late_cdats_last_sec;
   int late_cdats_last_sec_tally;

I will keep:
   int late_cdats;
   int late_cdats_last_sec;


this is where I add:

      players1[p].late_cdats++;
      //players1[p].late_cdats_last_sec_tally++;
      mwT[0].add_data(1);

this is where I initialize:

      players1[p].late_cdats = 0;
      mwT[0].initialize();

this is where I tally:
                     players1[p].late_cdats_last_sec = mwT[0].get_tally();
                     //players1[p].late_cdats_last_sec = players1[p].late_cdats_last_sec_tally;
                     //players1[p].late_cdats_last_sec_tally = 0;



OK this one works...

now these:

mwT[1]

   int frames_skipped;
   int frames_skipped_last_sec;
   int frames_skipped_last_sec_tally;

mwT[2]
   int timer_adjust;
   int timer_adjust_last_sec;
   int timer_adjust_last_sec_tally;



            players1[active_local_player].frames_skipped_last_sec = mwT[1].get_tally();
//            players1[active_local_player].frames_skipped_last_sec = players1[active_local_player].frames_skipped_last_sec_tally;
//            players1[active_local_player].frames_skipped_last_sec_tally = 0;

            players1[active_local_player].timer_adjust_last_sec = mwT[2].get_tally();
//            players1[active_local_player].timer_adjust_last_sec = players1[active_local_player].timer_adjust_last_sec_tally;
//            players1[active_local_player].timer_adjust_last_sec_tally = 0;



      players1[p].frames_skipped = 0;
      players1[p].frames_skipped_last_sec = 0;
      mwT[1].initialize();

      players1[p].timer_adjust = 0;
      players1[p].timer_adjust_last_sec = 0;
      mwT[2].initialize();


those two are done...this is going well...
can't wait to do more...



now for a more difficlut one

mwT[3].initialize();


game_move_dsync_avg_last_sec

   double game_move_dsync; // current value
   double game_move_dsync_max; // never used
   double game_move_dsync_avg_last_sec;
   double game_move_dsync_avg_last_sec_tally;
   double game_move_dsync_avg_last_sec_count;


                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
                     {
                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
                        players1[p].game_move_dsync_avg_last_sec_count = 0;
                     }

   // calculate game_move_dsync
   players1[p].game_move_dsync = ( (double) players1[p].server_game_move_sync * 0.025) + timestamp_frame_start - timestamp;
   mwT[3].add_data(players1[p].game_move_dsync);
//   players1[p].game_move_dsync_avg_last_sec_tally += players1[p].game_move_dsync;
//   players1[p].game_move_dsync_avg_last_sec_count +=1;



                     players1[p].game_move_dsync_avg_last_sec = mwT[3].get_avg();
//                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
//                     {
//                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
//                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
//                        players1[p].game_move_dsync_avg_last_sec_count = 0;
//                     }



server max client ping...
mwT[4].initialize();

               if (players1[0].server_state_freq_mode == 1) // 0 = manual, 1 = auto
               {
                  int mcp = players1[0].server_max_client_ping*1000;
                  players1[0].server_max_client_ping = 0;
                  if (mcp > 100) mcp = 100;
                  //players1[0].server_state_freq = 2 + mcp/20; // use max_client_ping to set server_state_freq
                  players1[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq
               }


OK I think I have all those done:

should I test them??

what about bandwidth?
leave for now...



I am thinking about reanmeing functions in server send state...


now:
void server_create_new_state(void) // rewids and sets flag

void server_send_stdf(void) // craetes new state

void server_send_stdf(int p) // send stdf to a specific client


new:

server_rewind...done
server_create_new_state..done
server_send_dif..done



I want to do some tests...

with lots of clients..


I was a little concerned when running a game with 40ms lag
I saw what looked like quite huge corrections.
On one client to another.
Viewing a client with fake key on another client looked very jumpy...




OK I have some serious bugs here


some clients simply cannot connect:
they either fail at sync with a high number till they time out
or they never get the initial state...

why? what is going on??


it looks like they have a very high cpu..

it looks like draw it taking >20ms

but then clients cannot connect after that

and on server

state_freq is an enormous number....

log when it is set...

or just print...

fixed a bug the tally max code used by max client_ping
now if no enries, the max returned is zero, not min double!

deploy to server and test...better


Now running profile on client
draw
8 ms lift
7 ms screen overlay
2 ms item

this is on level 13 which has 15 lifts...not even close to a max...

also it seems to take a long time to chase...



on client, the time inbetween init state and first timer adjust

1-3 frame

level 150
m36   3f -6
      2f +3

4230l 1f +39
      1f +25



level 13
m36   2f +5
      2f +12


4230l 1f +177
      3f +175

I can't see what might be causing this in the logs or profile


could it be redraw tiles in client_apply_dif?
profile it...does not look like the culprit

are you sure about this?

the time in between the initial state received and the first timer adjust...

look at timer_adjust...it never fires....

I just had a client that never connected. could not catch up...
It looks like when it is trying to go faster, it has even less time process the frame...
but more importantly, I don't think that skip drawing frame ever triggers!


old:
int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

   if ((mwPS.frame_num+0) < al_get_timer_count(fps_timer)) // skip drawing frame


it appears that in single player and client that fn is one less than timer

do I care?

i use the raw timer event to flag that it is time to process a frame...


should I keep them in sync? should timer always match the current frame?


the only thing I use the actual timer value for is deciding if I skip drawing

void set_frame_nums(int fn)
{
   // reset mwPS.frame_num and fps_timer count
	mwPS.frame_num = fn;
   al_set_timer_count(fps_timer, fn);
   reset_animation_sequence_frame_nums(fn);
}


at the start of loop i check to see if the counter is too far ahead

void proc_timer_adjust(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num+1)
   {
      players1[active_local_player].timer_adjust++;
      mwT[2].add_data(1); // add to tally
      al_set_timer_count(fps_timer, mwPS.frame_num+1);
      printf("Adjusted timer - fn:%d timer:%d\n", mwPS.frame_num, (int) al_get_timer_count(fps_timer));
   }
}


then later in the loop if check it again to see if I skip drawing:

int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}


these conflict and are unccesarily complicated...

do it once..



int proc_frame_skip(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num) // skip drawing frame
   {
      al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

this has the effect of forcing timer to always have the value of frame number

the timer will fire and event an increment the timer

the loop will increment mwPS.frame_num

if, while processing the loop, the timer increments again, the loop will not be drawn

if, when starting the loop the timer is ahead of frame, frame will still be processed, but draw will be skipped.

when the test to draw is performed, if timer is ahead, it will be set to current......is this part necessary?
wont that speed up the game enough to catch up?

I want to try this without the reset timer...

the one thing I am not checking for is if the timer is behind mwPS.frame_num
we don't want to stop or slow the game to catch up to the timer (i think?)
so we should move the timer ahead to the actual mwPS.frame_num...
not sure if this ever happens though...

first:
comment out timer adjust (it never fired anyway)...
change
int proc_frame_skip(void)
{
   int draw_frame = 1;
   if (al_get_timer_count(fps_timer) > mwPS.frame_num)
   {
      draw_frame = 0;
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
   }
   al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
   return draw_frame;
}

mwPS.frame_num is the reference.
set the timer from this, not the other way around

why do I get to a place where clients cannot join server?
the only thing I can do is reset the server
clients stall at waiting for initial state...

client log shows that they cannot apply dif from over 100 frames in the future..
if (client_state_dif_src - mwPS.frame_num > 100)
fixed...
if ((client_state_dif_src - mwPS.frame_num > 100) && (mwPS.frame_num != 0))


now I want to make a much more minimal overlay
just show cpu and fsls in border...
done

still at 70% cpu on level 13
state_freq and zlib_cmp make no difference...

its still draw lift at 8ms

can I improve on that?
removed draw lift lines and got about 4ms

removed the drawing of 10 shrinking rounded filled rectangles
less than 1ms

I know it looks nice, but is there a less expensive way of drawing it?

same with lift lines...is every frame neccesary?

maybe I could measure if lifts draw time > 5ms then go to a simpler draw method...

draw lift lines every other frame...

etc...

go back to the original method of drawing lift lines
only when drawing background..

when do I do this:

switches, bombs, keys, block manip, client_apply_dif

I don't know if I can go back to this...
I just checked and I don't think lift lines ever change...

why is this such a change, did I not notice it before?

maybe I could make a global reduce cpu thingy..

don't I already have that with drawing less??


I think I broke stuff!

client does not play nice on cleint anymore  :(

I like it on m36 0ms...
and on e6430...

but on 4230j it does not seem to skip frames gracefully...


to test this....


make a function that adds delay in the draw stuff.
like pct_y

seems to work ok in single player...
but the terminology is a liitle off

FPS set..good
FPS actual..not really..
FPS skipped..just skipped drawing is all, not actually skipped...

have a look at this...

on the 1 Hz timer:
actual_fps = mwPS.frame_num - last_fps_frame_num;
last_fps_frame_num = mwPS.frame_num;

why? what good is this?

just use:
frames_skipped_drawing_total
frames_skipped_drawing_last_sec
done...

maybe actual fps had some use in speed testing?
it just records the number of times the game loop has been processed in the last 1s

something funny is going on...why does it record less when a frame skip happens?

when I change the timer count, do I also reset when the tick happens?

i think I should not be correcting the timer


when timer > frame then skip

but if i don't do any corections it will be the same next frame....


how about this:

at the start of the game loop:
fn++
timer event has fired and incremented timer_fn

before anything else...
if we are already behind at this point:
correct timer to match frame
flag this frame as not to be drawn

if we are on the same frame:
process as normal

then test to see if we are behind after processing...
if so, skip drawing, but do not correct timer..

so there will be two types:

one at frame start
one after processing

give this a try...

no luck...


I have made a big mess here...
this should not be complicated....



can I do a timestamp when the event fires then compare it with when the frame starts..

print timestamp on 1Hz timer...see if that is actually 1Hz
it is not...maybe its my stupid way of calling al_rest...

I should do something else to pause...

same with 40hz



am I all fucked up here?

timers do not seem to be firing when I think they should

I could be that I am doing things that pause them more than the period of the timer....


for example, if draw takes more that 25ms how do I handle that?

my network code needs the rest of the stuff to run at 40hz


even if I draw every other frame, when I do draw, the draw time being over 25ms will mess up my nice timing...


could I figure out a way to split the draw between 2 frames?


I think I should just put all this back together and abandon the idea of skipping draw frames for now....
It just does not work nicely

if I go over 80% cpu, I should enable econ_draw...



how much can I remove?

do I even care at all what the timer count is?

all I need is the timer event firing...

I'm gonna say no and remove it...



fix animation sequence...you know what I mean..

this has been this this way for over 25 years

I don't want to embed frame numbers in it anymore..

how does it work now?

   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count

what I need to do is:

make 2 the tally count and inc evey frame
if 2 > 3 then next shape and 2 = 0;

old:
void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

  // printf("update_animation :%d\n", mwPS.frame_num);


   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
         if ((mwPS.frame_num - zz[2][y]) > zz[3][y])
         {
            zz[2][y] = mwPS.frame_num;                     // set counter
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
}

new:

void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = count tally
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

   // printf("update_animation :%d\n", mwPS.frame_num);

   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
      {
         if ((++zz[2][y]) > zz[3][y])
         {
            zz[2][y] = 0;                             // reset tally
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
      }
}

yay that has been there for far too long!

next I want to get rid of set_frame_nums();

at least in the game for now...done

now is there anything that reads timer?

yes, some stuff in level editor...I want to get rid of it too...

these no longer exist:
al_get_timer_count
al_set_timer_count
set_frame_nums()
proc_frame_skip()

so much simpler...

now I have removed all safeguards against cpu > 100%

bad things will happen!!

what do you want to do?

put draw in economy mode...

draw half the things one frame and half the next...but where do I draw the line?


   get_new_background(1);
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   get_new_screen_buffer(0, 0, 0);
   draw_screen_overlay();
   al_flip_display();




everything has to:

   get_new_background(1);
   get_new_screen_buffer(0, 0, 0);
   al_flip_display();


optional
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   draw_screen_overlay();


int draw_seq[20]

0 = always
1 = odd frames
2 = even frames



I am tempted to make a acreen overlay that shows these times:

then go through the list from max to min and put one in each column...



I want to max this a class

mwDrawSequence

mwDS

only one instance

has an array for times, min, max, avg and draw sequence

everytime something is actually drawn the time is measured


it look horrible!!

lets rethink this:


odd:
   sprintf(name_long[0], "get_new_background");

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");

even

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");


There is a lot of flickering no matter what I do.

I could make screen_overlay use its own bitmap.....

it is one of the biggest culprits

and in screen overlay, QuickGraph uses a lot

measure it..

or just disable it...


I think I am just going to leave stuff the way it is.

sure the screen overlay take lots of cpu, but you can just turn it off...

lets test...




I would like to make things optional in the debug screens

make a grid in settings:

number of debug levels across the top

things that can be shown is a list to the left

then a grid of check boxes.

different one for client and server:



server:

CPU graph
screen info
debug grid
bandwidth
draw timers
adjustment buttons


put text cpu in bottom display for all...far right...done


                    mode 0 mode 1 mode 2 mode 3
debug grid
cpu graph
sync graph
display info
bandwidth stats
draw timers
adjustment buttons
fps
player pos


overlay_grid[10][4]

overlay_grid[0][0]  debug grid on for mode 0
overlay_grid[0][1]  debug grid on for mode 1
overlay_grid[0][2]  debug grid on for mode 2
overlay_grid[0][3]  debug grid on for mode 3

overlay_grid[1][3]  cpu graph on for mode 0
...
...


can set the number of modes from 2 to 4




I think I have most of the client server stuff done...

there is also file play and demo mode to straighten out

push for now...



I want to straighten out the functions in screen overlay





























void show_player_stat_box(int tx, int y, int p)
void show_level_done(void)
void draw_screen_overlay(void)
void set_player_joint_quit_display(int p, int type, int time)
void show_player_join_quit(void)
void sdg_show_column(int col, int &x, int y)
void sdg_show(int x, int y) // server debug grid
void cdg_show(int x, int y) // client debug grid

void draw_top_frame(int p)

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)

void draw_top_display(void)



The very top is

void draw_screen_overlay(void)

it calls:

   show_level_done();
   draw_top_display();
   draw_bmsg();
   show_player_join_quit();


I want it to also call:

draw_top_frame
draw_bottom_frame

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)


and remove top_display...



I want to combine draw_top display text stuff and debug display stuff...

can I call it
draw_on_screen_overlay

it will have sections for server, client, file, common
it will call debug overlays
misc text overlays
waiiting to join
demo mode overlay...

just rename top_display to draw_on_screen_overlay




that was a lot of rearranging...hopefully it's better now:

void draw_screen_overlay(void)
{
   int p = active_local_player;
   int cx = BORDER_WIDTH;
   int cy = BORDER_WIDTH+72;

   al_set_target_backbuffer(display);

   if (LOG_TMR_scrn_overlay) t0 = al_get_time();

   show_level_done();

   draw_bmsg();

   show_player_join_quit();

   draw_top_frame(p);
   draw_bottom_frame(p);

   draw_common_debug_overlay(p, cx, cy);

   if (ima_server)                     draw_server_debug_overlay(p, cx, cy);
   if (ima_client)                     draw_client_debug_overlay(p, cx, cy);
   if (players[0].control_method == 1) draw_demo_debug_overlay(p, cx, cy);

   if (LOG_TMR_scrn_overlay) add_log_TMR(al_get_time() - t0, "scrn_overlay_all", 0);
}

do some testing and make sure demo mode is working
display stuff draws on border...fixed...
demo mode misc...good..

single player..good

fix pos and backgrounf for draw profile timers..done..
test client...
fix bandwidth...done
why is packets per sec rx so high?? fixed

what about the space after the debug grid?
if not used can be move everything else up?

I guess it all depends on what order I draw things in..

first:
debug grid
specific misc

last:
display
timers
bandwidth


common does in this order:
display
profile
cpu

client does in this order:
debug grid
sync graph
snyc adjust
misc
bandwidth

server does in this order:
debug grid
adjust
misc
bandwidth

demo does in this order:
misc


so if I just switch common to after specific, then make debug grid part of the cy stuff....


OK this is all looking good

If everything is on, this is the order it shows in:
debug grid
misc
bandwidth
display
profile

I just have server left to do:
make debug grid like client..done...

server adjust widget... where should i put it?

on the right like client?

just above cpu...done..


the only thing I still want to test is where late cdats are drawn in flashing on bottom frame...

I need to manually adjust offset till I get late..done and it lokks great..

in demo mode stuff overwrites the player array...fixed...

now in settings:
make a default button
reduce the number of debug states

the samllest screen size that the entire settings thing fits on is 400x400..


I am finally done with all this debug overlay stuff...it looks pretty good too.

Now to clean up that mess I made with the drawing....

In loop it is fine, just one call to mwDW

The class takes care of
drawing
profiling and averaging
printing screen overlay of results
plus all the optional stuff that didn't work out as planned

It all looks good...logging annd overlay work...the rest has been disabled...


An important question I need to ask?  Do you feel lucky, punk?

I have disabled all frame skipping.  I expect bad things to happen if cpu hits 100%.

What actually happens? Should I try to do something about it?

My rationale was mostly this:

99% of the time, the reason we will not be able to draw is that the draw function takes too long.
It is exceeding rare that the other part of the code is the limiting factor.

I still want to do soemthing about it though...

But what?

I have made it possible to disable with fine control all the bad things in screen overlay.

What about drawing every other frame, just doing the frame skip like we used to?
I can have a mode where I draw thing as simple as possible..

I would like to automatically play all the demo levels and record info about what timing profiles they have...
not every frame, but lets say the average of the last 10s

then I could try out some new economical draw routines

One that comes to mind right away is lifts.

I could draw lifts using much less resource than I do now.


I should just make a global int eco_draw...

be able to toggle it on and off and see what I can do...

I have made a global;
extern int eco_draw;
saved in config
toggle with F2
display on bottom frame...

yay!

now lets test it in draw lifts..


level 155 with 39 lifts with 37 steps each
1400 circles

4.7 ms 3 circles
2.4 ms 1 circle
1.3 ms 0 circles

stick in on 0 for now and test rects..

0.19 1      filled rect
0.20 1      filled rounded rect
0.51 10 not-filled rounded rects and 1 filled not-rounded

that is quite an impressive change..

total:
4.96 original
0.99 eco

5 times faster...


lets try this shit on a 4230
level 13
8.5 ms original
1.5 ms eco_draw

level 155
125 ms original
26 ms eco_draw

nice... now what else can I try to eco?

I think pmsg are a resource hog....

lets make a test level...copy 1...

level 154 has 105 messages
1.99 ms original
1.62 ms force all frame sizes over 1 to be 1

when the text is commented out
0.58 orig
0.19 eco

1.44 for text alone


what can I do?

I could draw them only once...
make a bitmap, draw the frame and text, then just draw the bitmap in the future...

maybe I could pre_calc line_height, so I don't have to do it every time


removing just the call to al_draw_multiline_text:
0.65 orig
0.28 eco_draw

1.34 just for al_draw_multiline_text:

I don't think that I can optimize this any further...
unless I predraw on bitmaps...

test on 4230...
level 154 with draw disabled
15 ms orig
5 ms eco_draw

draw enabled:
29 ms orig
19 ms eco_draw

it takes 14ms to draw text alone...


what are some other candidates?

things that draw rectangles, especially rect with diag lines
make a level with block damages and 10x10 rects...

level 157
50 block damage with 10x10 rect with diag...
1.15  ms orig
thats not too bad....
33 ms on 4230


what about vinepods?
they draw the entire vine every frame
level 158
10 vinepods
0.01 stationary
1.46 when fully extended

4230:
0.2 ms stationary
41  ms when fully extended

what about explosions??

figure out how to tell how much cpu time an explosion takes
- time drawing the circles
- time erasing blocks

so far the only thing I have been able to eco draw is
lifts
lift_lines
message frames



I am thinking that I should just say fuck it to the old 4230...I don't care if the game will run on it.

I still need to do something though when cpu hits 100%

what specs are the 4230's

64 bit win7 sp1
core2 T5500 @ 1.66GHz
2G RAM
Intel Mobile 945 Express
256M video memory







testing...


e6403 server on eidnet
ping 25-30


client 1 - m36
getting late cdats, no matter what offset I use

client 2 - scat
getting late cdats on server, but server never show any for late cdats last sec..
and client does not show any because lcls is what is being sent back and server thinks it is zero...


on server cdsy is about -35 for both clients, this seems normal
gmav of 4-8 for m36 and follows offset changes
but gmav is always zero for scat?

am i missing some things here, only done for first client?

the game is jumpy as ecxpected, late cdats and all...

but why?


I am using a tally for late_cdats last sec, and guess what?...I need one for each player

make them then...
extern mwTally mwT_late_cdat_last_sec[8];

extern mwTally mwT_game_move_dsync_avg_last_sec[8];



I think the late cdats can be explained by gmav


when offset is 10+ping sometimes it varies and you get late cdats
increasing to 20 gave more of a buffer and no more late...
well they were very rare....

look into this more...

I'm thinking that with state_freq 2 there is a pretty small window that client input can arrive in...

I want to make some logs and investigate...

make a function that returns a complimetary contrasting color.

use when you want to draw on the frame...

test it with version...looks good, now used whenever I draw on the frame.. I like it better that the yellow I was using before..







I want to get rid of the old proc_controllers();

136 matches..

I think most of the time, I am waiting for input, or a key to be released ...

in those case, a straight replacement with mwEQ.proc_event_queue would work...

other times, the menu_timer_block thing is being used...


down to 135...


I going to do a global replace for things like... while () proc_controllers()

proc_controllers()
mwEQ.proc_event_queue()
proc_event_queue_menu()


this is a replacement for when I want a timer

      while (!program_update) mwEQ.proc_event_queue();
      program_update = 0;

but then I'll never get the 3's to fire.. use 0 instead



in visual_level I also want the controls to be checked

add these two lines to peq...
no, I don't think I will...
   // only do key check for active local player


   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);

   if I want to do that I'll just make a wrapper
   that does both...

   for menu and visual level select...


    while (!menu_update) mwEQ.proc_event_queue();
    menu_update = 0;




e_bitmap.cpp done and checked
e_fnx.cpp done and checked
e_lift.cpp done
e_pde.cpp done
e_sliders.cpp done
e_visual_level.cpp
mwGraph.cpp
z_args.cpp done
z_log.cpp done
z_log.cpp done  // can't cancel splash screen??


edit_pmsg_text looks a little funny


0   - proc_controllers()
147 - mwEQ.proc_event_queue()
17  - proc_event_queue_menu()

officially gone!!!
void proc_controllers(void)
{
   int menu_timer_block=1;
   mI.key[ALLEGRO_KEY_PRINTSCREEN][0] = 0; // hack to make PRINTSCREEN key work properly
   key_pressed_ASCII = 0;

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if ((ev.type == ALLEGRO_EVENT_TIMER) && (ev.timer.source == mnu_timer)) menu_timer_block = 0;
            else proc_events(ev);
         }
      }
   }

   proc_keys_held();
   function_key_check();

   // only do key check for active local player
   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);
}


key_pressed_ASCII does not work as 'press any key' beacuse it only has a value for the frame it was pressed on..

I can't use it to cancel splash screen anymore until i added a hack

when the event happens, I now also trigger the menu_update and it works!!

   if (ev.type == ALLEGRO_EVENT_KEY_CHAR)
   {
      key_pressed_ASCII = ev.keyboard.unichar;
      serial_key_check(key_pressed_ASCII);
      menu_update = 1;
      //printf("key_pressed_ASCII:%d\n", key_pressed_ASCII);
   }

go the fuck to bed!!


20230205 11:46 PM


20230207 4:52 AM

still can't escape from level editor

145 - mwEQ.proc_event_queue()

what are my key array things?
0 = pressed
1 = pressed last frame
2 - just pressed this frame
3 - just released this frame


do I need to document the program flow for level editor?

I would be nice...
and I can rename mWindow also...

done..now mwWindow
decided not to change all >500 referneces to mW[] that can stay



so what is the process of level editor?

it is started by calling:
edit_menu(start_level)

edit_menu sets some stuff up, then does this loop

   while (mW[8].active)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) cm_process_mouse();
      cm_process_keypress();
   }


cm_redraw_level_editor_background();
- mwEQ.proc_event_queue
- does the delay (currently by calling mwEQ.proc_event_queue and waiting on program_update)
- gets new background
- draws lifts, enemies, items
- draws overlay specific to mode
- gets new screen buffer


if (!mw_cycle_windows(0)) cm_process_mouse();
- processes and draws all active windows for this mode
- if the mouse is not on any window, process mouse for background



cm_process_keypress();
custom handler for em and ovw
but mostly all ESC tries to quit the entire level editor

I have simplified this now...
- still have a custom handler for em and ovw
- in any other mode ESC quits
that seems to work good now

removed up and down from ovw

em_keypress custom...all it did was check for hotkeys for lists...removed...

so now it is even simpler:
cm_process_keypress();
- runs custom handler for ovm
- checks for ESC in all modes for quit
- runs the exit dialog for last chance to abort or save before quit


I think that is all I have time for today...

add this to level_editor_process.txt and push...





I think there is something in zz animation sequence used by enemy killed that I need to fix...done

I want a new name for zoom full screen

how about selection edit?

main edit
selection edit
group edit
object viewer
tile helper


I like it...

how to rename:

file:

old e_editor_zfs
new e_edit_selection


the prefices I have...

em
ge
ovw
use es where I used to use zfs

I think it is all done...

rename group_edit_windows to just group_edit
that was easy, I think it was mostly just the filename...

now object_viewer_windows to just object_viewer

done...

now I have:
e_editor_main.cpp
e_edit_selection.cpp
e_group_edit.cpp
e_object_viewer.cpp

and the prefixes:
em_
es_
ge_
ov_



changed the behaviour of cm_redraw_level_editor_background..

old:
mwEQ.proc_event_queue and block, waiting for program_update
draw

new:
mwEQ.proc_event_queue
if program_update, draw
no blocking...

seems to work good


I want to make the file mwWindow only have functions from that specific class

any common files put in a seperate file e_mw_common.cpp


what calls draw?
.draw(
only one thing:
- cycle windows


how about from within the class? none!

nice! so there is only one single point of entry...

well cycle windows probbaly has many, it draws them all...

calls to cycle_windows(int draw_only)
- 1 call in editor_main (main loop)           (draw_only = 0)
- 2 calls when moving or resizing windows     (draw_only = 1)
- 1 call when blocked in tmenu                (draw_only = 1)
- 1 call when re-arranging ge list items      (draw_only = 1)
- 1 call running lifts                        (draw_only = 1)
- sliders has 2 calls when moving slider bars (draw_only = 1)

OK, this is all coming together....







I was thinking about making a mwWindowManager class to handle all of the windows as a group...

I am not sure what I would gain from that...

what functions would be a part of it:

void cm_get_block_position_on_map();
void cm_process_scrolledge(void);
void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
void cm_get_new_box(void);
void cm_redraw_level_editor_background(int mode);
void cm_process_mouse(void);
void cm_process_keypress(void);
int cm_redraw_level_editor_background(void);
void set_windows(int mode);
int is_mouse_on_any_window(void);
int mw_get_max_layer(void);
int mw_cycle_windows(int draw_only);


not these:
void cm_process_menu_bar(int draw_only);
int cm_draw_filter_buttons(int x1, int x2, int y1, int mode, int draw_only);
void cm_draw_status_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);
void cm_draw_selection_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);



that is actually quite an impressive list of functions that could all be rolled into a class..
as far as the data is concerned, it's almost entirely just the window objects..


imagine that...

the entirety of level editor in one class, one instance of that class, one object...
it is very tempting...


there is already very few globals for level editor...

one thing I am anticpating having problems with (because I have run into it before)
I want to make mwWindowManager contain the array of mwWindows

It should be possible, but I get errors about muliple definitions whenever I try.

I think I could solve it by using pointers to objects, but I have been trying to stay away from dynamically creating things...

started making the frameworks...


make an array of 10 pointers to mwWindows

when I construct a new mwWindowManager, dynamically allocate the 10 mwWindows


this is what I have so far:


// mwWindowManager.h
class mwWindow{};
#define NUM_MW 10
class mwWindowManager
{
   public:
    mwWindowManager();  // constructor
    ~mwWindowManager(); // destructor
//    mwWindow * mwW;
    mwWindow * mwW[10];
};

// mwWindowManager.cpp
#include "pm.h"
#include "mwWindowManager.h"
mwWindowManager::mwWindowManager()  // constructor
{
   //mwW = new mwWindow[10];
   for (int i=0; i<10; i++)
      mwW[i] = new mwWindow;
}
mwWindowManager::~mwWindowManager()  // destructor
{
   //delete [] mwW;
   for (int i=0; i<10; i++)
      delete mwW[i];
}

what next?


where do I create and destroy mwWindowManager?

at the start and end of edit menu

statically allocated at the start:
mwWindowManager mWM;

it should automatically get destroyed when it goes out of scope


I'm still getting stupid multiple definition errors...

I'm going to experiment with header guards...

maybe I don't have to use dynamic after all??





Use header guards in all your header file and declare a global variable in .c file and declare extern to that global variable in a header file.

#ifndef HEADER_FILE_NAME_H    /* if not defined already */
#define HEADER_FILE_NAME_H
extern wchar_t szClassName[];
#endif


omg that was excactly what I was looking for!

now I can use statically define varaibles...


create at the start of edit menu:
mwWindowManager mwWM;

class mwWindowManager
{
   public:
   mwWindowManager();  // constructor
   ~mwWindowManager(); // destructor
   mwWindow mwW[10];
};

now what?

start copying things over?

   void cm_get_block_position_on_map(void);
   void cm_process_scrolledge(void);
   void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
   void cm_get_new_box(void);
   void cm_redraw_level_editor_background(int mode);
   void cm_process_mouse(void);
   void cm_process_keypress(void);
   int cm_redraw_level_editor_background(void);

   void set_windows(int mode);
   int is_mouse_on_any_window(void);
   int mw_get_max_layer(void);
   int mw_cycle_windows(int draw_only);

all these have been added


now what?

make my own loop()
i can even call it loop...done

started renaming functions that are part of the class...
could be easier if I comment out the old ones and find out where they are used...
did a shit load of that...
now its mostly all patched in...

did it get any simpler?

still need to clean up some stuff...

pm.h defines for all removed functions in e_window common..done

what to do with the 4 functions left in that file...bite the bullet and move all to the class?
right now window manager class is 600 lines

170 menu
80 filter
50 status
200 selection
-----
520 lines

the window varaibles are all long now, especially outisde of class like mwWM.mW[4].blah
'mwWM.mW' is used 420 times in the project

some things make better sense as part of the manager class like:
set_focus.done
level_editor_mode.done

can I reimplement the saving?

20230211
move level_editor_mode from mwWM.mW[8].level_editor_mode to mwWM.level_editor_mode
done...

save_mW..done

I am using while (mW[8].active) to control when the entire level_editor process ends

what if I change it to something that window manager owns? active..done..

OK now that I have all that done...I want to continue with the documenting of the level editor process...

first what have I changed?..fixed all

fixed enemy shapes not all showing in ge list

but ge_controls never show...why?..deleted mw.pm and all good..


maybe I could make a menu option:

auto save level editor state
reset level editor saved state

and maybe also if level editor crashes on entry to reset state..

under the view menu:

Autosave level editor state
Reset level editor state

done...but did not do the auto reset if something went wrong...too hard to tell??
how about I have a variable that gets set when level editor starts
and reset when level editor ends normally

then next time it starts if it did not exit noramlly the prviuos time, reset state..

I could manually save this in config
level_editor_exit_flag

at start:

if set to 1, reset state
set to 1 and save

at normal exit
set to 0 and save


or:

at start, delete mw.pm
only save if normal exit..
this looks a lot simpler

whenever I do a load, delete it there...done...
hard to test, eh?


what next?

can I make these part of the window manager class? yes..done


// ------------------------------------------------
// ----- level editor unsorted --------------------
// ------------------------------------------------
extern int swbl[NUM_SPRITES][2];

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

extern int gx; // mouse position relative to scaled level background
extern int gy;
extern int hx;
extern int hy;


#define NUM_OBJ 600
// list of objects to edit as a group
extern int obj_list[NUM_OBJ][3];
extern int obj_filter[5][20];


extern int swbl[NUM_SPRITES][2]; ..done..moved to mw class
extern int obj_list[NUM_OBJ][3]; ..done
extern int obj_filter[5][20];..done
extern int gx; done
extern int gy; done

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

all done...


make logo its own class...
mwLogo

I have two very close function I would like to merge:
an is for menu
an3 is for help

can I start using it yet?

I want to put these globals in the class...

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;


I have gotten rid of the old file z_logo.cpp

I forget to take adjust and test!!!..fixed


now work on the globals

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;
those are all done...


I should put these in the .cpp and .h for logo...

not the class? why not?

int show_splash_screen = 1;
int splash_screen_done = 0;
put in class and done...

I think I am all done with logo...


what about bottom message?

that is a good candidate for a class...

mwBottomMessage
mwBM

make it declare, create and destroy its own bitmaps...


   // bottom msg bitmaps
   for (int x=0; x<20; x++)
   {
      bmsg_bmp[x] = al_create_bitmap(800, 20);
      al_set_target_bitmap(bmsg_bmp[x]);
      al_clear_to_color(al_map_rgba(0,0,0,0));
      bmsg_bmp2[x] = bmsg_bmp[x];
   }


actually that does not work...
I can declare pointers in the class, but if I try to create bitmaps at the same time it dies,
probably because allegro is not initialized yet.

So I just create them when I create all the other bitmaps, and it works...

all the fuinctions have been moved to the class and erased from screen_overlay..

now I have three more variables to add to the class:

extern int bottom_msg_on;
extern int bottom_msg;
extern int bmsg_index;

done...


now how about demo mode?

mwDemoMode
mWDM


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
extern ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
extern int demo_played[100];
extern int num_demo_filenames;
extern int demo_mode_loaded;
extern int demo_mode_on;
extern int demo_mode_countdown;
extern int demo_mode_countdown_val;
extern int demo_mode_countdown_reset;
extern int demo_mode_enabled;
extern int demo_mode_last_frame;
extern int demo_mode_config_enable;
extern float demo_mode_overlay_opacity;

I think demo mode is done...

now demo mode starts immediately??


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
int demo_played[100];
int num_demo_filenames = 0;
int demo_mode_loaded = 0;
int demo_mode_enabled = 1;
int demo_mode_on = 0;
int demo_mode_countdown_val;
int demo_mode_countdown_reset = 2400;
int demo_mode_last_frame = 0;
int demo_mode_config_enable = 1;
float demo_mode_overlay_opacity = 0.1;


demo is now done...


OK the huge one:
display

mwDisplay
mwD

created the class and copied all these functions in:

   void show_bitmap_flags(int flags);
   void show_pixel_format(int df);
   void show_display_flags(int flags);
   void show_display_options(void);
   void show_display_orienation(void);
   void show_fullscreen_modes(void);
   void auto_set_display_transform_double(void);
   void set_saved_display_transform(int sdt);
   void cycle_display_transform(void);
   void set_display_transform();
   void show_disp_values(int fs, int disp, int curr, int wind, int full, char *head);
   void show_display_adapters(void);
   int init_display(void);
   void proc_display_change(void);
   void save_display_window_position(void);
   void proc_display_change_tofs(void);
   void proc_display_change_fromfs(void);


it compiles and works!!

now for all these varaibles:


extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // current (either wind in windowed mode or full in fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

extern int disp_x_full; // fullscreen  (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;

extern int SCREEN_W;
extern int SCREEN_H;
extern int WX;
extern int WY;
extern int fullscreen;
extern int display_adapter_num;
extern float WX_shift_speed;

extern int viewport_mode;
extern int viewport_show_hyst;
extern float viewport_x_div;
extern float viewport_y_div;

// used to only redraw a region of background to increase fps
extern int level_display_region_x;
extern int level_display_region_y;
extern int level_display_region_w;
extern int level_display_region_h;

extern int display_transform_double;
extern int display_transform_double_max;
extern int saved_display_transform_double;
extern int show_dtd;

make a method to replace these:
         if (mwD.fullscreen) mwD.proc_display_change_fromfs();
         else                mwD.proc_display_change_tofs();
done...

make my own set_clipping_rect...done
al_set_clipping_rectangle

more vars?

extern float scale_factor;
extern float scale_factor_current;
extern float scale_factor_inc;
extern int show_scale_factor;
extern int scale_factor_holdoff;

done...
what about set_scale_factor?..done
what about proc_scale_factor_change()?..done


any more?

I'm thinking about adding these:

// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;


I have something similar in logo

   float mdw_map_logo_x;
   float mdw_map_logo_y;
   float mdw_map_logo_scale;

   float mdw_splash_logo_x;
   float mdw_splash_logo_y;
   float mdw_splash_logo_scale;


and I have a function that sets all this up:

void set_map_var(void)
{
   // determine menu_map_size and position
   int y_size = mwD.SCREEN_H-160;
   int x_size = mwD.SCREEN_W-260;
   if (y_size < x_size) menu_map_size = y_size;
   else menu_map_size = x_size;
   if (menu_map_size < 10) menu_map_size = 10;
   menu_map_x = mwD.SCREEN_W/2-(menu_map_size/2);
   menu_map_y = 140;

   // splash screen logo position
   mwL.mdw_splash_logo_x = mwD.SCREEN_W/2;
   mwL.mdw_splash_logo_y = mwD.SCREEN_H/2;

   // splash screen logo size
   float min_d = mwD.SCREEN_H;  // find miniumum dimension
   if (mwD.SCREEN_W < mwD.SCREEN_H) min_d = mwD.SCREEN_W;
   mwL.mdw_splash_logo_scale = min_d / 500; // 400 is the exact size, make it bigger for padding

   // map screen logo position and size
   float sp = menu_map_x - BORDER_WIDTH;    // how much space do I have between the map and the screen edge?
   mwL.mdw_map_logo_scale = sp / 500; // 400 is the exact size, make it bigger for padding
   mwL.mdw_map_logo_x = BORDER_WIDTH + sp/2;
   mwL.mdw_map_logo_y = menu_map_y + mwL.mdw_map_logo_scale * 200; // align top of logo with top of map

   // this is the link from splash to map
   mwL.mdw_logo_scale_dec = (mwL.mdw_splash_logo_scale - mwL.mdw_map_logo_scale) / 320;
   mwL.mdw_logo_x_dec = (mwL.mdw_splash_logo_x - mwL.mdw_map_logo_x) / 320;
   mwL.mdw_logo_y_dec = (mwL.mdw_splash_logo_y - mwL.mdw_map_logo_y) / 320;

//   printf("slx %f sly %f\n", mdw_splash_logo_x, mdw_splash_logo_y );
//   printf("mlx %d mly %d\n", mdw_map_logo_x, mdw_map_logo_y );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec, mdw_logo_y_dec );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec*320, mdw_logo_y_dec*320 );
}

this leads me to the place where I figure out what goes in display, screen, and bitmaps

display - for all the setup
screen - for actually drawing on the screen

screen should have:
all the level draw functions
all the screen overlay things

screen should not have:
create and load bitmaps
rebuild bitmaps
load fonts

what if I renamed e_bitmap to e_bitmap_tools or something like that...done

then make a class mwBitmap mwB
this class will have all the bitmap pointer declarations
have methods to create load, rebuild bitmaps
might as well stick fonts in there too...


done and I have moved

   void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size);
   void load_fonts(void);
   void create_bitmaps(void);
   void rebuild_bitmaps(void);

and it runs...
what else?
load tiles is in file.cpp and it called after more stuff is set up...

timestamps...just get it out of the way...done
packetbuffer..just make a header for n_packet.cpp and stick it in there..done

I might leave it there..

what variables do I have?

extern ALLEGRO_FONT *font0;
extern ALLEGRO_FONT *font;
extern ALLEGRO_FONT *font2;
extern ALLEGRO_FONT *f1;
extern ALLEGRO_FONT *f2;
extern ALLEGRO_FONT *f3;

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern int sa[NUM_SPRITES][2];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;


do the fonts, but also name them better:

extern ALLEGRO_FONT *font0; // built-in thick 8x8
extern ALLEGRO_FONT *font;  // pristine, my new fav 8x8
extern ALLEGRO_FONT *font2; // pristine, in 16x16 format for bmsg
extern ALLEGRO_FONT *f1;    // achafont
extern ALLEGRO_FONT *f2;    // saucer
extern ALLEGRO_FONT *f3;    // pixel gosub

what will they be now:

mF.bltn
mF.pr8
mF.pr16
mF.sauc
mF.acha
mF.pixl

I want them to have their own class file mwFont mF
ok that's done.. now the grueling task of replacing all font references...

font0 mF.bltn  .done
font  mF.pr8
font2 mF.pr16  .done
f1    mF.acha  .done
f2    mF.sauc  .done
f3    mF.pixl  .done

font has 667 occurances!!

I am all done with fonts...

add these to mwBitmap

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



   ALLEGRO_BITMAP *tilemap;
   ALLEGRO_BITMAP *btilemap;
   ALLEGRO_BITMAP *ptilemap;
   ALLEGRO_BITMAP *dtilemap;
   ALLEGRO_BITMAP *M_tilemap;
   ALLEGRO_BITMAP *M_btilemap;
   ALLEGRO_BITMAP *M_ptilemap;
   ALLEGRO_BITMAP *M_dtilemap;

   ALLEGRO_BITMAP *tile[NUM_SPRITES];
   ALLEGRO_BITMAP *btile[NUM_SPRITES];

   ALLEGRO_BITMAP *player_tile[16][32];
   ALLEGRO_BITMAP *door_tile[2][16][8];

   ALLEGRO_BITMAP *level_background;
   ALLEGRO_BITMAP *level_buffer;


bitmaps has quite a lot done...

I could still put more like:

extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;

but I am not sure they belong...



lifts is next....

e_lift.cpp 500 lines
z_lift.cpp 500 lines
pm.h

// ------------------------------------------------
// ---------------- lifts -----------------------
// ------------------------------------------------
extern int num_lifts;
extern char lift_step_type_name[10][10];
extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};

// e_lift.h
al_fixed lift_get_distance_to_previous_move_step(int lift, int step);
void show_all_lifts(void);
void lift_step_set_size_from_previous_move_step(int lift, int step);
int lift_find_previous_move_step(int lift, int step);
void erase_lift(int lift);
void delete_lift_step(int l, int step);
void lift_setup(void);
int create_lift(void);
void move_lift_step(int lift, int step);
int get_new_lift_step(int lift, int step);
int insert_lift_step(int lift, int step);
void insert_steps_until_quit(int lift, int step);
void set_all_steps(int l, int s, int what);
void step_popup_menu(int lift, int step);
int draw_current_step_buttons(int x1, int x2, int y, int l, int s, int d);
void draw_step_button(int xa, int xb, int ty1, int ty2, int l, int s, int rc, int d);
int draw_steps(int x1, int x2, int y, int lift, int current_step, int highlight_step, int d);

// z_lift.h
int construct_lift(int l, char* lift_name);
void clear_lift(int l);
int construct_lift_step(int l, int s, int type, int x, int y, int w, int h, int val);
void clear_lift_step(int l, int s);
void set_lift_to_step(int l, int s);
int is_player_riding_lift(int l);
void draw_lift_line(int l);
void draw_lift(int l, int x1, int y1, int x2, int y2);
void draw_lifts();
void set_lift_xyinc(int d, int step);
int lift_check_prox(int l, int pd);
void move_lifts(int ignore_prox);

what is my plan here?

I still want lifts and lift_steps accessible

I think I still want the seperation of e_lifts and z_lifts

One possibility:
- put both in one file
- make one header file

that would be easy

cons:
the one file would be >1000 lines
nbd

now I only have one file: z_lift.cpp
one one header z_lift.h

now pm.h is less than 100 lines!!

523 function defs
200 lines global vars

some low hanging fruit...
sliders, should just get a h file

renamed to mwWidget, even though it wont have a class, its a generic group




here is some low hanging fruit:


// n_client.h
void client_read_packet_buffer(void);
void client_fast_packet_loop(void);
int  ClientInitNetwork(const char *serveraddress);
void ClientExitNetwork(void);
int  ClientCheckResponse(void);
int  ClientReceive(void *data);
void ClientSend(void *data, int len);
void client_flush(void);
int  client_init_join(void);
void client_exit(void);
int  client_init(void);
void client_read_game_move_from_packet(int x);
void client_send_ping(void);
void client_process_stdf_packet(double timestamp);
void client_apply_dif();
void client_block_until_initial_state_received(void);
void client_process_sdat_packet(void);
void client_process_serr_packet(void);
void client_proc_player_drop(void);
void client_control(void);
void client_local_control(int p);
void process_bandwidth_counters(int p);

// n_network.h
extern int NetworkDriver;
int NetworkInit();

// n_packet.h
extern char packetbuffer[1024];
extern int packetsize;
void set_packetpos(int pos);
int get_packetpos(void);
void Packet(const char *id);
int PacketRead(const char *id);
void PacketAddByte(char b);
char PacketGetByte(void);
void PacketAddString(char*);
void PacketReadString(char*);
void PacketPut1ByteInt(int b);
void PacketPut2ByteInt(int b);
void PacketPut3ByteInt(int b);
void PacketPut4ByteInt(int b);
int PacketGet1ByteInt(void);
int PacketGet2ByteInt(void);
int PacketGet3ByteInt(void);
int PacketGet4ByteInt(void);
void PacketPutDouble(double);
double PacketGetDouble(void);

//n_server.h
int ServerInitNetwork(void);
void ServerExitNetwork(void);
void ServerListen(void);
int ServerReceive(void *data, int *sender);
void ServerBroadcast(void *data, int len);
void ServerSendTo(void *data, int len, int who, int player);
void server_flush(void);
int  server_init(void);
void server_exit(void);
void server_send_dif(int p);
void server_create_new_state(void);
void server_rewind(void);
void server_send_sdat(void);
void server_proc_player_drop(void);
void server_proc_cdat_packet(double timestamp);
void server_proc_stak_packet(double timestamp);
void server_proc_cjon_packet(int who);
void server_control();
void server_fast_packet_loop(void);

done..

give bullets a header file..done

visual_level..done

396 function def
167 globals

I want to make game_moves array a class...maybe...






   if (players[0].level_done_mode == 5) // skippable 15s timeout
   {
      if (!ima_client)
      {
         if (have_all_players_acknowledged()) players[0].level_done_timer = 0; // skip
         for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }
      }
   }


i want to move this to have_all_players_acknowledged()...should be pretty straightforward



            for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }

GMA works...


level_header should only live in file.cpp..done..


I have intoduced a bug somehwere...

when I resize the screen, I lose screen_overlay...maybe just the fonts..they need to be reloaded also? yes. fixed..



move these declatations to logo...done

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

tile_helper.h ..done
pde.h..done


I am thinking of making color a class.. mwColor mColor
yes...

old:
mColor.pc[15]

new:
mColor.c[15];

or:
mColor.white;

it will return an actual ALLEGRO_COLOR..

I will also have all the color names in the class

maybe later I will extend it to have more fading than just the 16 preset levels

also it will have the flash colors

to start with, and replace all occurance of color...how many?...1143!...
I'll just do a straight replace of mColor.pc with mColor.pc

flash_color is not actually a color, its an index

It compiles and runs!!
now for some more features..
add color names...done..

add specific colors like:

mColor.white..etc..done...

make flash colors actual colors instead of indexes..done, but most use case still use the indexes...


pm_events .. the one used in the game for triggers and such...

make it its own class. It has a lot going on...
mwPMEvent mwPME

I think I have it all in there and working...



mouse
keys
joystick
event
timers
queue

lets call these mwInput
mouse
keys
joystick


OK now I have a huge search and repalce to do:


extern char skc[64]; // serial key check
extern int skc_index;

extern char *key_names[]; 12-done
extern bool mI.key[ALLEGRO_KEY_MAX][4];  297
extern int key_pressed_ASCII;18-done

extern int mouse_x; 107-done all blind replace
extern int mI.mouse_y; 124- done all blind
extern int mouse_z; 4-done
extern int mouse_dx; 4-done
extern int mouse_dy; 5-done
extern int mouse_dz; 12-done

extern bool mI.mouse_b[5][4]; 183 blind

clear_keys
proc_keys_held


globals < 100 !!

what esle can I add to mwInput?
function_key_check()..done

all done from control.cpp




put event queue and timers into mwEventQueue
do it...you've come too far to stop now!!

now add timers...

I have about 40 globals variables left!!!

put animation_sequence array in with bitmaps...
also rest and update...done...

what aboout sa, shape atributes?  same place? yup..done

last of the bitmaps there too...done


I'm gettting down to the last of them

I want something like a class called mwProgramState to catch a lot of things like:


add to bmsg:
extern int game_event_retrigger_holdoff[10];
extern float game_event_retrigger_holdoff_tally[10];


add to logo
// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;
done...


make this a part of menu..
extern char global_string[20][25][80];
menu.h
done..
setup menu



I think I am ready to make all of these part of a class called mwProgramState

extern int program_state;
extern int new_program_state;
extern int old_program_state;
extern int older_program_state;

extern int top_menu_sel;
extern int main_loop_exit;

extern int autosave_level_editor_state;
extern int level_editor_running;
extern int help_screens_running;
extern int visual_level_select_running;

// frame_speed, frames per second, mwPS.frame_num stuff
extern int speed_testing;
extern int frame_speed;
extern int speed_control_lock;
extern int mwPS.frame_num;

extern int show_debug_overlay;
extern int show_player_join_quit_timer;
extern int show_player_join_quit_player;
extern int show_player_join_quit_jq;

extern int eco_draw;

// temp testing variable
extern int pct_x;
extern int pct_y;
extern char msg[1024];

// some global strings
extern char level_filename[80];
extern char local_hostname[80];
extern char pm_version_string[80];
extern char al_version_string[80];



need to fix level_filename later...vl uses is to get a filename from make_filename....



there is some weird shit going on where I work with filenames...
I should examine as fix it...

the first thing I did was get rid of the global level_filename...


my base functions are:

int save_level(int level_to_save)
always returns 0

int load_level(int level_to_load, int load_only)
returns 1 on success, 0 on failure

      if (!load_only)
      {
         valid_level_loaded = 1;
         lift_setup();
         for (int x=0; x<500; x++)
            if (item[x][0]) // only if active set x y
            {
               itemf[x][0] = al_itofix(item[x][4]);
               itemf[x][1] = al_itofix(item[x][5]);
            }
         level_check();
         init_level_background(0); // draw blocks on level_background
         mwB.reset_animation_sequences();
         //set_player_start_pos(0, 0);
      }


they both take an integer level num and call make filename..

To print with padding by Zeros, we use the following format specifier with the printf() statement,

    %d : No padding.
    %01d : 1 digit padding with zeros.
    %02d : 2 digits padding with zeros.
    %03d : 4 digits padding with zeros.

replaced make_filename with:

char lf[255];
sprintf(lf, "levels/level%03d.pml", level_num);

now load and save level make their own filename
save level does not return anything...



load_level_prompt()

is called from level_editor popup menu and from regular menu..

also from command line but that never works...

what if command line is passed a level that deosn exist?
level loading error..


edit_menu is called by:

pm -e (uses play_level)
pm -e num (uses num if 0 < num < 400)
game_menu (uses start_level)

in edit menu if passed 0 it would run the prompt, but that never occurs...


I am happy with how load level prompt works

save_level_prompt..good...

le popmnu new
le regmnu new
le regmnu save_as

what is left?

why does level viewer not work?
It just gives errors for every level it cannot find...
can I make that optional? yes I can...

not sure if the level viewer copying thing is working...it is..


msg...784 matches...that's just lazy

where can I hide it? z_menu...just like global_string...



Now I have this left for global variables:


// items
int item[500][16];      // item ints
al_fixed itemf[500][4]; // item fixeds
int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];
char pmsgtext[500][500] = {0};
int item_tile[20];

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
int e_num_of_type[50];
int e_first_num[50];
char enemy_name[100][2][40] = {0};
int num_enemy;
int enemy_tile[20];




// ------------------------------------------------
// ---------------- level -------------------------
// ------------------------------------------------
int l[100][100];
int warp_level_location = 0;
int start_level;
int play_level;
int valid_level_loaded;
int last_level_loaded; // used by level editor and load file to keep track of last level loaded
int resume_allowed=0;
int number_of_starts;
int number_of_purple_coins;


for level I need to make a cpp file or a class
lets just do a cpp file for now..
z_level.cpp and z_level.h


20230212 4:36PM all globals are gone!!
well...at least from pm.h..there are still some in other files but they are only externed where needed...

now I plan to make .h files and move all function prototypes there...

I still have 250 function in 18 files...

tell me again why I would want them spread over 18 files instead of all in one place?

and why would I want 18 more files?...

I now have 100 files...58 cpp and 42 header

Purple Martians Source Code Line Counts [2023-02-12  17:27:41]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2872][  2172][  1734][   605][   167][   438][   533] - z_item.cpp
[  2705][  1951][  1367][   848][   264][   584][   490] - z_enemy.cpp
[  2087][  1755][  1347][   515][   107][   408][   225] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1599][  1448][   207][    56][   151][   220] - mwGraph.cpp
[  1745][  1343][  1124][   319][   100][   219][   302] - z_player.cpp
[  1865][  1334][  1110][   275][    51][   224][   480] - mwWidget.cpp
[  1658][  1222][  1019][   335][   132][   203][   304] - z_fnx.cpp
[  1416][  1140][  1009][   181][    50][   131][   226] - z_menu.cpp
[  1250][  1003][   901][   139][    37][   102][   210] - z_screen_overlay.cpp
[  1281][   963][   834][   188][    59][   129][   259] - e_bitmap_tools.cpp
[  1595][   905][   820][   183][    98][    85][   592] - e_glt.cpp
[  1157][   901][   731][   219][    49][   170][   207] - z_lift.cpp
[  1078][   891][   755][   195][    59][   136][   128] - e_edit_selection.cpp
[  1129][   802][   737][   125][    60][    65][   267] - z_settings.cpp
[   994][   735][   659][   108][    32][    76][   227] - e_fnx.cpp
[   851][   716][   401][   363][    48][   315][    87] - e_editor_main.cpp
[   782][   689][   606][   101][    18][    83][    75] - e_group_edit.cpp
[   874][   657][   621][    99][    63][    36][   154] - z_file.cpp
[   937][   634][   548][   166][    80][    86][   223] - z_screen.cpp
[   765][   616][   559][    92][    35][    57][   114] - n_client.cpp
[   777][   611][   562][   100][    51][    49][   115] - n_server.cpp
[   819][   587][   536][   117][    66][    51][   166] - e_visual_level.cpp
[  1140][   548][   472][   343][   267][    76][   325] - z_args.cpp
[   759][   538][   461][   160][    83][    77][   138] - z_loop.cpp
[   622][   510][   385][   150][    25][   125][    87] - e_item.cpp
[   642][   489][   416][   118][    45][    73][   108] - mwWindowManager.cpp
[   705][   477][   457][    93][    73][    20][   155] - mwLogo.cpp
[   542][   434][   387][    77][    30][    47][    78] - e_window_common.cpp
[   560][   432][   407][    28][     3][    25][   125] - mwInput.cpp
[   588][   416][   191][   258][    33][   225][   139] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   565][   372][   369][    63][    60][     3][   133] - mwDisplay.cpp
[   439][   367][   327][    48][     8][    40][    64] - e_pde.cpp
[   451][   328][   328][    31][    31][     0][    92] - pm.h
[   360][   297][   237][    71][    11][    60][    52] - e_enemy.cpp
[   341][   291][   272][    31][    12][    19][    38] - mwWindow.cpp
[   405][   289][   288][    22][    21][     1][    95] - z_config.cpp
[   308][   221][   180][    56][    15][    41][    72] - mwPMEvent.cpp
[   285][   208][   202][    26][    20][     6][    57] - z_main.cpp
[   303][   198][   173][    81][    56][    25][    49] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   250][   178][   148][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   151][   124][   113][    18][     7][    11][    20] - z_control.cpp
[   146][   117][   115][    11][     9][     2][    20] - z_sound.cpp
[   219][   115][   106][    68][    59][     9][    45] - mwDrawSequence.cpp
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   187][   100][    92][    42][    34][     8][    53] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   117][    85][    77][    13][     5][     8][    27] - mwFont.cpp
[   130][    75][    70][    16][    11][     5][    44] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   106][    65][    59][    12][     6][     6][    35] - mwEventQueue.cpp
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    64][    60][    58][     4][     2][     2][     2] - z_item.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    31][    29][     3][     1][     2][     5] - z_enemy.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
-------------------------------------------------------- - totals
[ 47082][ 34769][ 29614][  8162][  3007][  5155][  9306] - 100 files

On to something else...

what about those defines..kept the ones that worked

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-12  18:26:29]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2876][  2176][  1738][   605][   167][   438][   533] - z_item.cpp
[  2705][  1953][  1369][   848][   264][   584][   488] - z_enemy.cpp
[  2088][  1758][  1350][   515][   107][   408][   223] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1749][  1346][  1127][   319][   100][   219][   303] - z_player.cpp
[  1865][  1335][  1111][   275][    51][   224][   479] - mwWidget.cpp
[  1661][  1225][  1022][   335][   132][   203][   304] - z_fnx.cpp
[  1417][  1142][  1011][   181][    50][   131][   225] - z_menu.cpp
[  1255][  1005][   903][   139][    37][   102][   213] - z_screen_overlay.cpp
[  1287][   968][   839][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1600][   909][   824][   183][    98][    85][   593] - e_glt.cpp
[  1163][   905][   735][   219][    49][   170][   209] - z_lift.cpp
[  1082][   896][   760][   195][    59][   136][   127] - e_edit_selection.cpp
[  1136][   806][   741][   125][    60][    65][   270] - z_settings.cpp
[   998][   738][   662][   108][    32][    76][   228] - e_fnx.cpp
[   856][   721][   406][   363][    48][   315][    87] - e_editor_main.cpp
[   786][   693][   610][   101][    18][    83][    75] - e_group_edit.cpp
[   883][   660][   624][    99][    63][    36][   160] - z_file.cpp
[   941][   636][   550][   166][    80][    86][   225] - z_screen.cpp
[   771][   620][   563][    92][    35][    57][   116] - n_client.cpp
[   781][   613][   564][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1147][   554][   478][   343][   267][    76][   326] - z_args.cpp
[   765][   545][   468][   160][    83][    77][   137] - z_loop.cpp
[   622][   513][   388][   150][    25][   125][    84] - e_item.cpp
[   648][   496][   423][   118][    45][    73][   107] - mwWindowManager.cpp
[   705][   478][   458][    93][    73][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   441][   368][   328][    48][     8][    40][    65] - e_pde.cpp
[   360][   299][   239][    71][    11][    60][    50] - e_enemy.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   409][   291][   290][    22][    21][     1][    97] - z_config.cpp
[   308][   222][   181][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   252][   180][   150][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   219][   117][   108][    68][    59][     9][    43] - mwDrawSequence.cpp
[   130][   110][   110][     5][     5][     0][    15] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   190][   101][    93][    42][    34][     8][    55] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   119][    86][    78][    13][     5][     8][    28] - mwFont.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    86][    76][    74][     4][     2][     2][     8] - z_item.h
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    51][    42][    40][     4][     2][     2][     7] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    39][    37][    37][     1][     1][     0][     1] - z_fnx.h
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47189][ 34913][ 29758][  8153][  2998][  5155][  9278] - 116 files


pm.h has been stripped of all global variables and function prototypes

god help us all...


now, why do lifts need a button from bitmap_editor..


I will replace with a button...but...

the one thing I like about the old button was that they showed a highlight when the mouse was on them


I want to make a new type of button...

text and returs 1 when pressed, just like buttont, but...

this one will show a highlight when moused over
and will draw centered
and will auto size based on text length...

how about all that?..done...


Its time for a push, I shoudl be done for today...


20230212 7:18PM


20230214 4:00AM
remove menu fromn e_bitmap by making msg local to funtions is in done..4x
make DS have static RA's done

PDE could be a class to reduce a few globals
mwPDE mPDE..done...

glt no globals and no msg...done

color done...

cleanup is going well...





remove globals in bullets, can it be made a class?

mwBullets mwBullets

what about mwShots mShots

mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc

why don't I also start here with changing all fixed to floats

how about you do that first?

ebullet fixed to floats
then test with all types of enemies that shoot bullets...
I think I did it...

now make the class...


mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc



to start with just replace variables all the variables with the ones in the class

old:
ebullets[].active
ebullets[].shape

new:
e[].active
mShot.e[].shape

done...

next remove old variable defs..


next change all pbullet refs to class and use floats...

old:
pbullet[][0] - active
pbullet[][1] - player
pbullet[][2] - int x
pbullet[][3] - int y
pbullet[][4] - int xinc
pbullet[][5] - int yinc

new
mwS.p[].active
mwS.p[].player
mwS.p[].x
mwS.p[].y
mwS.p[].xinc
mwS.p[].yinc

done...
now what?
mwShots has been all renamed..only thing left would be to add some bullet functions..done...
void mwShots::fire_enemy_bulletz(int EN, int bullet_ans, al_fixed px, al_fixed py)
void mwShots::fire_enemy_bulleta(int EN, int bullet_ans, int p)
void mwShots::fire_enemy_x_bullet(int EN, int p)
replace deathmatch_pbullets and suicide bullets with shots..done and also made a part of class...
bul

all ref to bullet, bull, bul have been removed from game...

nice....


One thing..my new short class instance names may be kind of cryptic...like mwS for shots
alternatives? mwShot.e[].active
I can always search and replace later


how about changing lifts back to floats?
then items, players, enemies...

make it a class
that constains 2 arrays of structs

what about inheritance?

how many things all have x, y, xinc, yinc

players
enemies
items
lifts
e shots
p shots

how many have active, bitmap
players
enemies
items
e shots
p shots

later


back to lifts..

I also want to add active to lifts

and maybe get rid of level header...
where used?
3 times in fnx, but only for size display..
10 times in file.cpp

when saving level:
- erase level_header
fill from:
   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(1); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   lift_setup();
   level_header[5] = num_lifts;  // num of lifts

when loading level:
    num_lifts = level_header[5];

I want to use a different method of iterating lifts and lose level_header

also turn lifts into a class

also change fixed to floats

also do something about the int versions of x1, y1, x2, y2, width, height

where to start...

iterator:

old:
for (int l=0; l<num_lifts; l++) // iterate lifts

new:
for (int l=0; l<NUM_LIFTS; l++) // iterate lifts
   if (lifts[l].active)


I can have a member of the lifts class that tells me how many lifts are active
and a sort function that pretty much just removes spaces..optional, why bother?
it would break event links if there are any...


added active to lift struct..
now crashes hard when loading any level with lifts...
remove and rethink this...

should I just jump to class?
and change all the variables at that time?
mwLift mwLifts
started the class...


in order to change variables I need to make a shadow varaible for lifts (lift steps is not changing)

load old
convert to new
save


old:

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

new:

struct lift2
{
   float x1;
   float y1;
   float x2;
   float y2;
   float w;
   float h;
   float xinc;
   float yinc;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};



I still think I should do this in small steps:
first just add active..

step 1:
make shadow struct array lifts2 with added variable..done


step2
load normal
in glt copy to shadow
modify save to use new struct and new PML_SIZE
run glt..

now all levels are save in new format.

add var to lifts struct
increase PML_SIZE

load all level succesfully!!

remove mod to save...


wow that was a lot to modify save level format...
















Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112928


Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts2    :  5440
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :113088



#define PML_SIZE 384960

+160

#define PML_SIZE 385120



now fix the iterators

start with move and draw...

make a function to get the next empty lift...

like item and enemy..

I have removed all refs to num_lifts...
next:

does erase do the job of closing gaps, or do I need something else?..its good
figure out next and prev in ov..done
re implement num_lifts for display only..done
remove level header completely..not used..next time I re-do level format remove it...
what is going on with ft_? it all seems to work..it still uses ft_level_header but I dont care right now
in es copy and delete seem to be working good..
make a test level and try copy and paste and from disk...
copying 4 lifts works..
clearing lifts only erases half of them...fixed

all this is working so well...
what next??
replace fixed...

all 8 at once?  why not?

step 1
lifts2 has fixed replaced with floats

step 2
old vars
Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120


new vars (lifts2) and remove level_header
Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385040


don't reduce size of PML_SIZE until after re-saving

step 3
void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 4
in glt:

      for (int l=0; l<NUM_LIFTS; l++)
         if (lifts[l].active)
         {
            lifts2[l].x = al_fixtof(lifts[l].fx);
            lifts2[l].y = al_fixtof(lifts[l].fy);
            lifts2[l].w = al_fixtof(lifts[l].fw);
            lifts2[l].h = al_fixtof(lifts[l].fh);
            lifts2[l].xinc = al_fixtof(lifts[l].fxinc);
            lifts2[l].yinc = al_fixtof(lifts[l].fyinc);
            lifts2[l].winc = al_fixtof(lifts[l].fwinc);
            lifts2[l].hinc = al_fixtof(lifts[l].fhinc);

            lifts2[l].active = lifts[l].active;

            lifts2[l].x1 = lifts[l].x1;
            lifts2[l].y1 = lifts[l].y1;
            lifts2[l].x2 = lifts[l].x2;
            lifts2[l].y2 = lifts[l].y2;
            lifts2[l].width = lifts[l].width;
            lifts2[l].height = lifts[l].height;

            lifts2[l].flags = lifts[l].flags;
            lifts2[l].mode = lifts[l].mode;
            lifts2[l].val1 = lifts[l].val1;
            lifts2[l].val2 = lifts[l].val2;

            lifts2[l].color = lifts[l].color;
            lifts2[l].current_step = lifts[l].current_step;
            lifts2[l].num_steps = lifts[l].num_steps;
            lifts2[l].limit_counter = lifts[l].limit_counter;
            lifts2[l].limit_type = lifts[l].limit_type;

            sprintf(lifts2[l].lift_name, lifts[l].lift_name);

         }


step 5
make backup of levels...


step 6
run glt


step 7:
disable glt

you fucked up..go back to step 3

this was wrong....

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}

restored levels from backup...

set this properly:

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 6
run glt

step 7
disable glt

step 8
change load

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
//   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 9:

fix struct declaration

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int active;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};


level_header has been completely removed

now remove the integer shit in lift

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;



step 1
lifts2 has fixed replaced with floats

step 2

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080

don't reduce size of PML_SIZE until after re-saving

step 3

struct lift2
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}



step 4:
in glt do nothing, just load and save




step 5 backup levels

step 6 do glt...



wrong!

restore levels...

in glt copy from lifts to lifts2...



OK now I think I have it:

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080


level_header is completely gone...

lifts have been converted to floats


now working on item fixed to float..


change all these to not even pass x, y..get it from itemfl

         bomb_blocks( i, 1, item[i][7], fx, fy); // mark blocks that will be destroyed
         bomb_enemies(i, 1, item[i][7], fx, fy); // mark enemies that will be destroyed
         bomb_players(i, 1, item[i][7], fx, fy); // mark players in damage range



I got it all to compile!! now I have some bugs to fix...


first I want to record some performance metrics:
348 al_fixed
138 al_ftofix
383 al_itofix
207 al_fixtoi
124 al_fixtof


bugs..
player start position..fixed
jump on spring..fixed

OK its looking good...

what fixed to replace now?
player...the big one

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

   al_fixed LIFE;
   al_fixed old_LIFE;

   al_fixed draw_rot;
   al_fixed draw_scale;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;

lets do LIFE and old LIFE first
I also want to take this opportunity to rename it to health
done..


now PX, PY and rename to x, y
I should do all:

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

at the same time...

x, y, fxinc, fyinc, fright_xinc, fleft_yinc

the name change is important to find all the places it needs changing

convert all to float


I got stuck in the door move stuff...

there are ints:
   int door_xinc;
   int door_yinc;

that are used as fixed even though not declared as ints...I think...


I think I need to do the door ones at the same time..

   int door_xinc;
   int door_yinc;

   float door_fxinc;
   float door_fyinc;




ran into another issue with solidfm


they get passed fixeds and return fixed...

can I make a float wrapper?

they are used for ladder move and trakbot only...Ill need to fix them later...

well it compiles...

there is probably a lot broken...

remove these also:

   al_fixed draw_rot;
   al_fixed draw_scale;
   int door_draw_rot_num_steps;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


start with these:

   al_fixed draw_rot;
   al_fixed draw_scale;

done..

next:
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


compiles clean but there are so many things to fix...

first I want to record some performance metrics:
292 al_fixed
91  al_ftofix
287 al_itofix
138 al_fixtoi
114 al_fixtof


to fix:
rotation
rocket and door

ladder and rope

the rocket rotates like it should, but not player..


how does rotation work?

uses radians

pi/2 = 90
pi radians = 180


how is it done in items?

      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);



fuck all that...
I am going to start from scratch
if I have to store rotation as an int, how would I do that?

I figured it out and added notes in pm_docs

now implement for rocket

in proc_lit_rocket(int i)
angle is read from item[i][10] and used to calculate x and yinc inc and apply
also acceleration is processed

in proc_player_riding_rocket(int p)
player's controls are used to change angle
player gets pos and incs set from rocket

not much I could change there
steerability is simply the amount added or subtracted from the angle

I still think I should multiply by 100 to save angle as int
do it and fix whatever breaks

this is how it is drawn

    // these types need rotation
   if ((type == 11) || (type == 98) ||  // rockets
      ((type == 4) && (item[i][11] > 0))) // moving key
   {
      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);
      drawn = 1;
   }


Lets start with changing how it is draw

how do I want to do it?

should the angle be the one for draw or for trig?

I choose the trig one
this is how it is drawn now, deal with it...
      float rot = (float) item[i][10] / 1000;
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);

how was it done before?

when a rocket was created and all..

[10] is zero in PDE for rocket

fixed rocket lines...

multiplied steerability by 2
what if I just left it and increased the slider limit..
set rocket initial direction..done

what else do I need to fix?
when letting go of rocket, player warps...added to bugs...

now why do I have scale and door scale and all that?

check door stuff..

I think I fixed the player rotation stuff in door travel

door creator position bad...fixed

what about orb rotation?
there is another item that rotates...it works fine...

time for players ladders and bullshit like that...
make a wrapper...done..

first I want to record some performance metrics:
235 al_fixed
78  al_ftofix
246 al_itofix
135 al_fixtoi
109 al_fixtof

now the last big one: enemies

620 occurances of Efi



just like items, I will need to change the structure, then run glt



step 1 - backup levels

step 2 - add Ef[][16]

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
float Ef[100][16];      // enemy floats

extern int Ei[100][32];        // enemy ints
extern al_fixed Efi[100][16];  // enemy fixeds
extern float Ef[100][16];      // enemy floats

step 3 - glt
      // copy enemy fixed to to new float array
      for (int e=0; e<100; e++)
         for (int f=0; f<16; f++)
            Ef[e][f] = al_fixtof(Efi[e][f]);


step 4 - file.

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Ef);           memcpy(b+offset, Ef,           sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 5 run glt

step 6
disable glt
fix file
comment out Efi..


then fix!! 620 refs...
also in es I have this :
al_fixed ft_Efi[100][16];

change it too..
float ft_Ef[100][16];

PDEfx will also need changing later
rot for ft enemies


flapper does some weird flap sequences based on 0-100 and 0-255 and fixed sin

//   Efi[][8]  = flap offset for next loop



finally compiles clean!!!


first I want to record some performance metrics:
71 al_fixed
22 al_ftofix
66 al_itofix
28 al_fixtoi
51 al_fixtof

get_sproingy_jump_height(int num)
2 calls


convert PDE to use floats again
then remove the last calls to sliderf..done


now can I rename all the float ones from d to f...done...

key rotation..fixed..
fix the solid routines..done
fixed is no longer needed anywhere..

20230219 5:00AM

how many left?
33 al_fixed
15 al_ftofix
45 al_itofix
21 al_fixtoi
43 al_fixtof


fix enemy rotations, start with trakbot
look in enemy draw code:
float rot = Ef[e][14];
float sc =  Ef[e][12];
al_draw_scaled_rotated_bitmap(mwB.tile[tn], 10, 3, EXint+10, EYint+10, sc, sc, rot, flags);

deg fix rad
0   0   0
270 192 3p/2

trakbot is done..
check bouncers...good
vinepods, pozilla..good
flapper..no
jumpworm..good
fix flapper flap thingy..done

find a way to not use fixed trig in logo..done...
fixed trig 0-256

removed all the old solid functions

20230219 6:46 AM
0 al_fixed
0 al_ftofix
0 al_itofix
0 al_fixtoi
0 al_fixtof

they are all gone!!

cannon explosion death sequence looks different
need to fix rot inc in death sequence
done...

when letting go of rocket, player warps...fixed





lifts have strange artifacts in many levels...

clean up messed up levels


what about 'could not find move step!!' error?

lev 1 good
lev 2 2 lifts, one does not move..
lev 3 2 lifts, both move fine
lev 4 3 lifts, all move fine
when speed is too low, lifts don't move...fixed

5 no lifts
6 phantom lifts from level 4...removed
7 fixed
8
9
10
11
12
13 has 15 lifts
14
15
16
17 has 17 lifts
18 2
19 13
-36 done

80
81
82
83-99 done


100
108 37 lifts
109
155 39 lifts

I have gone through all 127 levels and removed bad lifts!

now what?


bullet targetting
seek xincs
set rot..etc
enemy stuff


I want to make a nice solution for angles
x,y is the reference, the angle will be refences to that point
      float xlen = mx-x;
      float ylen = my-y;
now get the answer in rad and shift by 90 deg
      float ra = atan2(ylen, xlen) + pi/2;;


now do the flapper targetting...
I think I got it..

all of that stuff is looking very good now

these functions in z_fnx are all looking great..
maybe later they can become a part of something like an enemy class

they are only 200 lines:

void set_enemy_rot_from_incs(int e);
void set_enemy_rot_from_player(int e, int p);
void seek_set_xyinc(int e);
int find_closest_player(int e);
int find_closest_player_flapper(int e);
int find_closest_player_trakbot(int e);
int find_closest_player_cannon(int e);
float deg_to_rad(float deg);


20230219 12:48  I should do a push..it has been a while....


test netgame

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Ef       :  6400
item     : 32000
itemf    :  8000
lifts    :  4480
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112128

it got 800 bytes smaller
800 / 40 = 20 / 4 = 5...could be 5 ints smaller in lifts

//#define STATE_SIZE 112928
#define STATE_SIZE 112128

of course it still works...I'm not just banging rocks together here....

what next?

I had started making lifts a class...

I have 1200 lines of code in z_lifts.cpp

lets move the data structures first and fix all references to them...

this is what I have now:

class mwLift
{
   public:

   mwLift(); // default constructor
   void initialize(void);

   struct lift lifts[NUM_LIFTS];
   struct lift_step lift_steps[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

};
extern mwLift mwLifts;


old:
lifts[].x
lift_steps[][].x

new:
mwLifts.l[].x
mwLifts.lift_steps[][].x

comment out the old and lets change shit...

actually it might be easier if I did all the funtions at the same time...
then I won't have to change them only to change them back later...
ok do it...

copied all header and function..compiles clean

now comment out the old and watch everything break!
compiles clean and completely removed old z_lifts files


can I make the names shorter?

mwLifts.lifts[].x
mwLifts.lift_steps[][].x

Lifts.l[] 13 to 7 (-6)
Lifts.steps[][] 18 to 11 (-7)

yes, do it

130 lifts
86 steps
41 member function refs

now I've gone and fucked it all up

lifts within the class now has changed

it does not like the single letter l...

what else can I call it?  curr, main,
cur for lifts
stp for steps..

like this:
lift.cur[]
lift.stp[][]

OK lets try to make that happen

replace
Lifts.l[
lift.cur[

replace
Lifts.steps[
lift.stp[


now that the class name is 'lift' I can't use that as a local int anymore

I should have just called it Lift dammit!!

there is a reason for complicated variable name

to simple and search and replace fails hard

Once more with feeling...
replace lift. with Lift.

done..and it compiles:

here is what the variables are called now:

   struct lift       cur[NUM_LIFTS];
   struct lift_step  stp[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

Lift.cur[]
Lift.stp[][]

so now that I have done that, what did I gain?


not sure...




z_item has ~3000 lines
e_item has 600


some items that are complex maybe should have there own source files..

I'm thinking doors, keys, rockets,

z_item.cpp
z_item_door.cpp
z_item_rocket.cpp


lets try it with keys..

just as a test to see how it could work...

got 100 lines out of z_items.cpp
and as a bonus, most stuff related to key is in the same place..


there is a bunch of stuff related to seq_color that I could find a place for..

the sorting stuff could go in e_items..

seq colors..part of bomb_blocks

I want to put bombs and rockets in their own file

z_item_bomb.cpp also rockets...500 lines

pmsg..done

also move switch to key..done


make one source file for all 4 of these closely related things:

call it trigger..

door
trigger
bd
bm

this will be the last for a while...

how nice can I make z_items.cpp look now?
now I only have around 600 lines

how big is z_enemy.cpp? 2400 lines...maybe later...




Server opened channel for `192.168.1.122:24785' and sent reply
Shutting down the server

C:\pm>pm

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-19  17:18:27]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2626][  1926][  1382][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1899][  1327][  1101][   278][    52][   226][   520] - mwWidget.cpp
[  1611][  1250][  1058][   279][    87][   192][   274] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1249][  1003][   907][   142][    46][    96][   200] - z_menu.cpp
[  1290][   971][   842][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1136][   897][   731][   206][    40][   166][   199] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1064][   881][   747][   190][    56][   134][   127] - e_edit_selection.cpp
[  1137][   807][   742][   125][    60][    65][   270] - z_settings.cpp
[   990][   734][   658][   108][    32][    76][   224] - e_fnx.cpp
[   857][   722][   407][   363][    48][   315][    87] - e_editor_main.cpp
[   926][   702][   560][   175][    33][   142][   191] - z_item_trigger.cpp
[  1191][   699][   635][   129][    65][    64][   427] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   862][   650][   618][    95][    63][    32][   149] - z_file.cpp
[   815][   642][   537][   140][    35][   105][   138] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   774][   621][   564][    92][    35][    57][   118] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1233][   585][   509][   346][   270][    76][   378] - z_args.cpp
[   766][   545][   468][   160][    83][    77][   138] - z_loop.cpp
[   650][   539][   416][   148][    25][   123][    86] - e_item.cpp
[   786][   539][   456][   155][    72][    83][   175] - z_fnx.cpp
[   649][   497][   424][   118][    45][    73][   107] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   449][   393][   316][    87][    10][    77][    46] - mwBottomMessage.cpp
[   521][   384][   299][   132][    47][    85][    90] - z_item_bomb.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   438][   367][   327][    48][     8][    40][    63] - mwPDE.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   411][   293][   291][    23][    21][     2][    97] - z_config.cpp
[   350][   288][   228][    71][    11][    60][    51] - e_enemy.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   256][   217][    67][    28][    39][    69] - mwShots.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   163][   127][    53][    17][    36][    71] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   128][    97][    81][    20][     4][    16][    27] - mwColor.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   116][    85][    77][    13][     5][     8][    26] - mwFont.cpp
[   141][    79][    72][    29][    22][     7][    40] - mwBitmap.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    55][    42][    40][     4][     2][     2][    11] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    48][    37][    35][     4][     2][     2][     9] - z_item.h
[    51][    31][    30][     3][     2][     1][    18] - mwBitmap.h
[    40][    31][    30][     2][     1][     1][     8] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    32][    24][    24][     1][     1][     0][     7] - z_fnx.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    23][    14][     8][     7][     1][     6][     8] - mwFont.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_bomb.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    16][    12][    12][     1][     1][     0][     3] - z_menu.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47880][ 35512][ 30292][  8207][  2987][  5220][  9381] - 130 files


about 600 lines more than last time I looked....



bug - sometimes rocket bomb lines do not work properly
the bomb_blocks circle is way behind...
fixed...

bug - door animation sequence sometimes disappears
door tiles don't get rebuilt...
at what point are they bad?
can I check them right after creating them...
goddamn I'm dum!!!


here is what I notice...


explosions are slightly more powerful than before
test this...
level 12 aim rocket lower center and 2 rows of blocks can be destroyed...seems the same...

rockets turn at a different rate
how to test this?
before, rotation was 0-256 fixed...x10

0    =  0 deg
640  = 90 deg
-640 = 270 deg_to_rad
1200 = 180 deg

steerability slider 1-50
item[][6]

that was added directly to angle, it wrapped forever...

what values do I have now


0    =  0 deg
1500 = 90 deg
3100 = 180 deg
4600 = 270 deg

so to convert

3142/1280 = 2.45

void proc_player_riding_rocket(int p)
{
   float rot_inc = (float)item[c][6] * 2.45;

this seems really close...

I would like to use glt and multiply all the vals by 2.5

then increase the slider range to 0-100

then manually adjust directions...
ok do it...


I really don't have that many rockets in my levels


Running Global Level Test
Level:  6 st:16
Level:  8 st:45
Level: 11 st:38
Level: 11 st:25
Level: 11 st:50
Level: 11 st:30
Level: 11 st:40
Level: 11 st:50
Level: 11 st:25
Level: 11 st:1
Level: 12 st:21
Level: 12 st:21
Level: 17 st:22
Level: 22 st:30
Level: 23 st:10
Level: 26 st:35
Level: 28 st:24
Level: 50 st:16
Level: 83 st:20
Level: 84 st:32
Level:101 st:20
Level:102 st:25
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:20
Level:155 st:1

only 28 up to here...
now can I do something about the initial directions?
or should I just adjust them all manually? yes...

rockets are done...

bottom messages do not show enemies anymore and item are not lined up...fixed
also I want some settings controls for them..

make it when left and right on levels, go to the next found level, not missing
done and it works great!!


if cancel from visual level don't reset level to 1

there are many different ways of doing this
- whenever selection is changed in vls make it change start_level
- exit with esc back to menu
- exit with enter, run level

- whenever selection is changed in vls do not change start_level
- exit with esc back to menu no change
- exit with enter, change start_level and run

which way do I like it? the first way..


here I am making a filename in a stupid way:

   char fn[20] = "levels/level000.pml";
   // look for levels that exist and put them in array
   for (int x=lll; x<ull; x++)
   {
      int h, d, rem = x;

      h = rem/100; // hundreds
      fn[12] = 48+h;
      rem -=h*100;

      d = rem/10;  // tens
      fn[13] = 48 + d;
      rem -=d*10;

      fn[14] = 48 + rem;
      if (al_filename_exists(fn)) le[num_levs++] = x; // put in array
   }

   char lf[255];
   sprintf(lf, "levels/level%03d.pml", level_num);
   //printf("saving: %s\n", lf);


right now z_level just has some variable definitions
I could make it into a class and add a bunch of methods
like what?
calc num of purple coins
take care of all the start block things
take care or erasing blocks and redrawing the level editor background when blocks change
calc num of enemies left alive??
mwLevel mLevel
.la[100][100]

done...
move tsw and merr to mwInput...done...

move more things out of file:
bitmaps
game moves
WM
then file will be done...

the only thing left in file is mw_file_select..used by bitmap_tools, edit_selection, and mwLevel..
I think I'll just put it in z_fnx for now...done

remove z_file from project...done...


void make_palette(void); -- to color
now called from display init...
moved to mwColor class and called in contructor...works good..
void window_title(void); -- to display..done
void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh);  -- to font..dpne


void get_hostname(int print); used in main and when clicking on button in settings..
maybe do inline?
print only from settings..done
inline in main


void spin_shape(int tn, int x, int y, int tsx, int tsy, int tsw, int tsh, float scale, float dim, int cycle);
move to bitmaps..

void show_var_sizes(void);
move to display with all the other console text dumps..


the pile is getting small...

should I make multi color lines its own thing?
it does not need to be a class, it only has 3 functions:

call it mw_multicolor_line...

move everything left into e_fnx...done

remove z_fnx...done



help should be made a class...
mwHelp mHelp
done..


I should be more consistant with my naming conventions

class names all start with mw then CamelCase...
they are already all like that...
but the instances of classes are all over the place
sometimes I made them shorter, but that hurts readability...just like too long does also...


menu stuff...

I should get rid of global_string

use something local and fill it everytime it is called...

I will still need to store it somewhere:

how about a class?

this time though, create instances when needed, nothing global
put all three menu type in the class..
use a common global string and have methods to assist with filling it

zmenu and tmenu done...
pmenu done..
disabling all old vars...done...

now move the text setup into item and enemy respectivbely...done

now the only thing left in z_menu is the text editing stuff....

and that fucking msg...


well its 3:40

20230220 3:40PM

push...

Purple Martians Source Code Line Counts [2023-02-20  15:45:36]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2089][  1761][  1353][   514][   106][   408][   222] - e_object_viewer.cpp
[  2550][  1685][  1468][   405][   188][   217][   677] - z_log.cpp
[  1878][  1601][  1450][   207][    56][   151][   221] - mwGraph.cpp
[  1899][  1328][  1102][   278][    52][   226][   519] - mwWidget.cpp
[  1609][  1249][  1056][   280][    87][   193][   273] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1293][   970][   841][   189][    60][   129][   263] - e_bitmap_tools.cpp
[  1399][   945][   834][   189][    78][   111][   376] - e_fnx.cpp
[  1140][   899][   733][   206][    40][   166][   201] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1063][   879][   745][   190][    56][   134][   128] - e_edit_selection.cpp
[  1139][   807][   742][   125][    60][    65][   272] - z_settings.cpp
[   862][   723][   408][   363][    48][   315][    91] - e_editor_main.cpp
[   925][   702][   560][   174][    32][   142][   191] - z_item_trigger.cpp
[  1194][   701][   637][   121][    57][    64][   436] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   815][   641][   536][   140][    35][   105][   139] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   777][   620][   563][    92][    35][    57][   122] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[  1234][   582][   506][   347][   271][    76][   381] - z_args.cpp
[   718][   580][   457][   148][    25][   123][   113] - e_item.cpp
[   810][   580][   531][   115][    66][    49][   164] - e_visual_level.cpp
[   765][   533][   456][   161][    84][    77][   148] - z_loop.cpp
[   682][   522][   449][   120][    47][    73][   113] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   683][   465][   426][   124][    85][    39][   133] - mwGameMovesArray.cpp
[   592][   459][   434][    28][     3][    25][   130] - mwInput.cpp
[   553][   443][   396][    77][    30][    47][    80] - e_window_common.cpp
[   679][   442][   439][    67][    64][     3][   173] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   492][   422][   366][    73][    17][    56][    53] - mwHelp.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   495][   380][   295][   120][    35][    85][    80] - z_item_bomb.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   438][   366][   326][    48][     8][    40][    64] - mwPDE.cpp
[   403][   332][   272][    71][    11][    60][    60] - e_enemy.cpp
[   475][   322][   297][    62][    37][    25][   116] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   348][   297][   278][    32][    13][    19][    38] - mwWindow.cpp
[   409][   290][   288][    23][    21][     2][    98] - z_config.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   255][   216][    67][    28][    39][    70] - mwShots.cpp
[   319][   232][   226][    27][    21][     6][    66] - z_main.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   197][   185][    29][    17][    12][    42] - z_menu.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   162][   126][    53][    17][    36][    72] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    12][    10][     2][    22] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   124][    92][    84][    15][     7][     8][    25] - mwFont.cpp
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   132][    76][    71][    16][    11][     5][    45] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   111][    71][    65][    12][     6][     6][    34] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    38][    36][     4][     2][     2][     9] - z_item.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    59][    32][    32][     4][     4][     0][    23] - e_fnx.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    20][    10][    10][     5][     5][     0][     5] - z_item_bomb.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     7][     4][     4][     1][     1][     0][     2] - z_menu.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 48239][ 35551][ 30333][  8226][  3008][  5218][  9680] - 132 files



lets remove msg wherever we can

I guess I could take 250 lines of edit text from menu and put it in e_fnx...
then kill menu


or....
leave only msg in menu...to see where I need to kill it...
done..I have been through every file and removed all global msg.. then kill z_menu.cpp and h...



mwItem mItem

mItem.i[16]
mItem.f[4]


I will have multiple source files for this class named as follows:

mwItem.h
mwItem.cpp

mwItemDoor.cpp
mwItemBomb.cpp
mwItemKey.cpp
mwItemMessage.cpp
mwItemTrigger.cpp


I will also put all functions from e_items.cpp in mwItem.cpp  if there are too many, later I will make more files

for now, lets just stick everything in the one file...mwItem.cpp...and get it to compile..


I now have a 4000 line file....
now for the header....
it will never change...


that all compiles clean...

I am a little scared to make my var names too short...

I would like:
mItem.i[16]
mItem.f[4]

but that would mean that in the class they would look like:

i[16]
f[4]

and could easily get confused with other single char var names:

I am just going to leave them as they are:

mItem.item[16]
mItem.itemf[4]


item[
itemf

1784 occ
186

do a global replace...just make sure to not do any within the class

item[ to mItem.item[
itemf[ to mItem.itemf[


it compiles...

I have removed:
e_items.cpp
z_items.cpp
z_items_xxx.cpp
files are removed from project...

everything is in the class and it compiles and seems to work!!

now lets try to make more .cpp files..

mwItemTrigger.cpp 880 lines
mwItemMessage.cpp 400 lines
mwItemBomb.cpp 500 lines
mwItemKey.cpp 200 lines
mwItemDoor.cpp 350 lines
mwItem.cpp 1500 lines

getting there...

700 lines of stuff that used to be in e_items...

time for a push then bed time...



Purple Martians Source Code Line Counts [2023-02-20  23:33:51]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1519][  1225][   999][   285][    59][   226][   235] - mwItem.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   817][   701][   559][   165][    23][   142][    93] - mwItemTrigger.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   489][   379][   294][   120][    35][    85][    75] - mwItemBomb.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   407][   282][   235][    73][    26][    47][    99] - mwItemMessage.cpp
[   357][   264][   187][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   315][   232][   226][    27][    21][     6][    62] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   199][   160][   124][    53][    17][    36][    22] - mwItemKey.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   133][    87][    84][    11][     8][     3][    38] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47894][ 35597][ 30380][  8163][  2946][  5217][  9351] - 124 files


now: (final)
700 mwItem.cpp
650 mwItemEditorFnz.cpp
800 mwItemTrigger.cpp
500 mwItemBomb.cpp
400 mwItemMessage.cp
200 mwItemKey.cpp
350 mwItemDoor.cpp
100 mwItem.h
-------------
3700 lines



in draw item make custom functions to draw key, start, exit, rocket message...

push..
maybe I'll get to do something at work...

nope...

num of starts is set only when items are sorted...
I should do it where i count purple coins...done..

items is done..

System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  19:00:59]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   313][   231][   225][    27][    21][     6][    61] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47891][ 35624][ 30408][  8168][  2952][  5216][  9315] - 126 files






now enemies!!

first put everything in one file...

2600 z_enemy.cpp
400  e_enemy.cpp
200 e_fnx.cpp


that's not how I did it with items


mwEnemy mEnemy

mEnemy.Ei[]
mEnemy.Ef[]


put everything in class
class file compiles

now fix all refs..
done:

compiles and runs!!!

now what?

3200 lines..
start making other files...

got to go..push time...



Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  21:16:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  2231][  1654][  1244][   590][   180][   410][   397] - mwEnemy.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1443][   985][   894][   148][    57][    91][   401] - e_fnx.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   311][   230][   224][    27][    21][     6][    60] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   223][   133][   100][    65][    32][    33][    58] - mwEnemyCloner.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    76][    57][    54][     8][     5][     3][    14] - mwEnemy.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    48][    27][    27][     1][     1][     0][    20] - e_fnx.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47986][ 35649][ 30433][  8182][  2966][  5216][  9371] - 129 files






I want to change the name of enemy move functions...


old:

enemy_cannon

new:
move_cannon

etc..

done:
move_archwagon
move_block_walker
move_arch_block_common
move_cannon
move_bouncer
move_bouncer_cannon_common
move_cloner
move_flapper
move_jumpworm
move_trakbot
move_podzilla
move_vinepod




int is_player_in_trigger_box(int x1, int y1, int x2, int y2);

is used only once by cloner

could I do it more genrically?
what else tests for this?
pod and vine
trigger
block damage


vine:
//     Ei[e][11] = trigger box x
//     Ei[e][12] = trigger box y
//     Ei[e][13] = trigger box w
//     Ei[e][14] = trigger box h
pod:
//     Ei[e][11] = trigger box x
//     Ei[e][12] = trigger box y
//     Ei[e][13] = trigger box w
//     Ei[e][14] = trigger box h
cloner:
//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2

just enemy for now..

int mwEnemy::is_player_in_enemy_trigger_box(int e)
{
   int x1 = Ei[e][11] - 10; // trigger box
   int y1 = Ei[e][12] - 10;
   int x2 = Ei[e][11] + Ei[e][13] + 10;
   int y2 = Ei[e][12] + Ei[e][14] + 10;
   for (int p=0; p<NUM_PLAYERS; p++)
      if ((players[p].active) && (!players[p].paused))
      {
         int px = players[p].x;
         int py = players[p].y;
         if ((px > x1) && (px < x2) && (py > y1) && (py < y2)) return 1;
      }
   return 0;
}

done and patched in for cloner, pod, vine...


void show_level_data(void);
void mwEnemy::show_level_data(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(al_map_rgb(0,0,0));
   int y_pos = 40;
   int x_pos = 40;
   if (mLevel.valid_level_loaded)
   {
      y_pos = show_enemy_data(x_pos, y_pos) + 8;
      y_pos = mItem.item_data(x_pos, y_pos) + 8;
      al_draw_textf(mF.pr8, mColor.pc[15], x_pos, y_pos,   0, "%d Lifts  ", Lift.get_num_lifts());
      al_draw_text(mF.pr8, mColor.pc[15], x_pos, y_pos+8,  0, "-------");
   }
   al_flip_display();
   mI.tsw(); // wait for keypress
}

is in enemy, but I want to move it..
only used by level editor menu
other places?

int mwVisualLevel::lev_show_level_data(int x_pos, int y_pos)
int mwVisualLevel::lev_show_level_data(int x_pos, int y_pos)
{
   int ey_pos = mEnemy.show_enemy_data(x_pos, y_pos);
   int iy_pos = mItem.item_data(x_pos+135, y_pos);
   ey_pos = ey_pos + 8;
   al_draw_textf(mF.pr8, mColor.pc[15], x_pos, ey_pos, 0,"%d Lifts  ", Lift.get_num_lifts());
   ey_pos += 8;
   al_draw_text(mF.pr8, mColor.pc[15], x_pos, ey_pos, 0, "-------");
   ey_pos += 8;
   if (iy_pos > ey_pos) return iy_pos;
   else return ey_pos;
}

make a generic version and put it in mwLevel.cpp..done
1 call from visual and 1 from level editor menu...

but the best part is
void show_level_data(void);
is removed from enemy class...

how about:
mwEnemyEditorFnx

this is used in lots of place...move out of enemy to e_fnx...
void rectangle_with_diagonal_lines(float x1, float y1, float x2, float y2, int spacing, int frame_color, int line_color, int clip_mode);

done..

now mwEnemy.cpp is less than 500 lines before the huge comment section at the end...



Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-22  07:41:51]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1472][   999][   908][   149][    58][    91][   415] - e_fnx.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   705][   562][   408][   176][    22][   154][   121] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItem.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   553][   444][   397][    77][    30][    47][    79] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   454][   326][   310][    28][    12][    16][   116] - mwLevel.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   311][   230][   224][    27][    21][     6][    60] - z_main.cpp
[   315][   226][   178][    71][    23][    48][    66] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   281][   176][   122][   105][    51][    54][    54] - mwEnemyVinePod.cpp
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   172][   125][    81][    61][    17][    44][    30] - mwEnemyCannon.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    86][    57][    55][    12][    10][     2][    19] - mwEnemy.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    47][    29][    28][     2][     1][     1][    17] - mwLevel.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    54][    28][    28][     1][     1][     0][    25] - e_fnx.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47973][ 35649][ 30436][  8173][  2960][  5213][  9364] - 134 files



push....

rename mwS

class is mwShots
instance should be mShot not mwS




do something about this code...
it looks weird

void mwEnemy::proc_enemy_collision_with_pshot(int e)
{
   float ex = Ef[e][0];
   float ey = Ef[e][1];

   for (int c=0; c<50; c++)
      if (mwS.p[c].active)
      {
         // shot collision box size adjusted with shot speed
         float cx = fabs(mwS.p[c].xinc/2) + 8;
         float cy = fabs(mwS.p[c].yinc/2) + 8;

         // shot collision box size adjusted with enemies collision box size
         cx += (float) Ei[e][29] - 10;
         cy += (float) Ei[e][29] - 10;

         float bx1 = mwS.p[c].x - cx;
         float bx2 = mwS.p[c].x + cx;
         float by1 = mwS.p[c].y - cy;
         float by2 = mwS.p[c].y + cy;

         // check for collision with player's shots
         if ((ex > bx1) && (ex < bx2) && (ey > by1) && (ey < by2))
         {
            //printf("hit!\n");
            int p = mwS.p[c].player;       // player number of shot
            Ei[e][31] = 1;                 // flag that this enemy got shot
            Ei[e][26] = p;                 // number of player that shot enemy
            players[p].stat_enemy_hits++;  // add to number of hits the player has
            mwS.p[c].active = 0;           // shot dies
         }
      }
}

players shot speed is always 12..

so after these lines:
float cx = fabs(mwS.p[c].xinc/2) + 8;
float cy = fabs(mwS.p[c].yinc/2) + 8;

one of cx or cy will be 8 and the other one will be 14


Ei[e][29] is almost always 10
then after these lines:
cx += (float) Ei[e][29] - 10;
cy += (float) Ei[e][29] - 10;
no change..

I want to make this test a point compare to a box.

first set up the enemy box

then test with the bullet point..

void mwEnemy::proc_enemy_collision_with_pshot(int e)
{
   float cb = (float) Ei[e][29]; // enemy collision box size
   float x1 = Ef[e][0] - cb;
   float y1 = Ef[e][1] - cb;
   float x2 = Ef[e][0] + cb;
   float y2 = Ef[e][1] + cb;

   for (int c=0; c<50; c++)
      if (mwS.p[c].active)
      {
         // shot position
         float x = mwS.p[c].x;
         float y = mwS.p[c].y;

         // adjust enemy collision box with shot speed
         float cx = fabs(mwS.p[c].xinc/2);
         float cy = fabs(mwS.p[c].yinc/2);

         if ((x > x1-cx) && (x < x2+cx) && (y > y1-cy) && (y < y2+cy))
         {
            //printf("hit!\n");
            int p = mwS.p[c].player;       // player number of shot
            Ei[e][31] = 1;                 // flag that this enemy got shot
            Ei[e][26] = p;                 // number of player that shot enemy
            players[p].stat_enemy_hits++;  // add to number of hits the player has
            mwS.p[c].active = 0;           // shot dies
         }
      }
}


this looks funny to me too...
enemy keeps track of when they last gave damage to a player for holdoff reasons? OK...

if collision happens when in holdoff, it is not cleared until holdoff is done and damage applied

only the most recent collision can cause damage...





void mwEnemy::enemy_player_hit_proc(int e)
{
   if (--Ei[e][23] < 0) // hit player retrigger
   {
      if (Ei[e][22]) // player hit!
      {
         int p = Ei[e][22]-1;
         players[p].health -= Ef[e][4];

         game_event(44, 0, 0, p, e, 0, Ef[e][4]);
         Ei[e][22] = 0;  // clear hit
         Ei[e][23] = 60; // set retrigger amount
      }
   }
   else Ei[e][22] = 0;
}






it is time to make player a class

mwPlayers mPlayer

the two arrays: player and player1

how about syn and loc

mplayer.syn[0].
mplayer.loc[0].



what is the easiest way to do this?

rename arrays later...

first just make it into a class...done and compiles

now remove old z_player.cpp and h...


now do some search and replace

players[  to mPlayer.players[  // 965 matches
players1[  to mPlayer.players1[
active_local_player to    mPlayer.active_local_player


did all the functions...

now it compiles and runs...

now I want to change:
players[]  to syn[]
players1[] to loc[]


first in mwPlayers.cpp and .h

structure name:
old player
new psyn
old player1
new ploc
that was easy, only 4 occ...done

next struct instances in class:
players[]  to syn[]
players1[]  to loc[]

then external refs

mPlayer.players[]. to  mPlayer.syn[].
mPlayer.players1[]. to  mPlayer.loc[].


compare lengths:
players[] 7
mPlayer.players[].  15
mPlayer.syn[].  11

players1[]  8
mPlayer.players1[]. 16
mPlayer.loc[]. 11



I am rethinking syn and loc...

they look good outside the class
mPlayer.syn[].
mPlayer.loc[].

but inside the class they don't make much sense...
syn[].
loc[].

fuck it, I'll live with it..if I really want I can keep the long ones in the class also..

players is all done and compiles




20230225 5:00AM
made log into a class..

I want to straighten out the naming for the pairs of graph functions...
for example:
   void run_timestamp_graph(void);
   void log_timestamp_graph(int num_lines);

log_timestamp_graph loads the data then calls run to display it...

how about:
show_timestamp_graph
calls load_time_stamp graph, or just does it internally..


lets do it for profile first..done..

void run_profile_graph(int choose);
calls
int load_profile_graph(int choose);


next ping_graph...called only from log_file_viewer..done
void run_ping_graph(int num_lines);
calls
int load_ping_graph(int num_lines);

next
void run_client_server_sync_graph(void);
void log_client_server_sync_graph(int num_lines);
done:

next
void run_bandwidth_graph(int both);
void log_bandwidth_graph(int num_lines, int both);

done for now...



I want to do netgame...
files:
n_client.cpp
n_server.cpp
n_network.cpp
n_netgame.cpp
n_packet.cpp
and h files for all..

after:

mwNetgame.cpp
mwNetgameServer.cpp
mwNetgameClient.cpp

and one h file for all

class mwNetgame
instance mNetgame

created the class..

add all these:
n_network.cpp
n_packet.cpp
n_netgame.cpp

or should I add everything?

do it...

copied all the contents to cpp and h then removed from project and moved files...

class compiles clean...and works!!

next:


what if I move game_event to sound or bottom_message

it seems out of place in screen_overlay


I have three things that have event in them:
allegro events mwEventQueue mwEQ;
game events
trigger events mwPMEvent mwPME;

I would like to make the naming more consistant..

mwAllegroEvent mAllegroEvent
mwTriggerEvent mTriggerEvent
mwGameEvent mGameEvent

right now, do I make a new class ?
mwGameEvent mGameEvent
it will be very small
yes, I think I should..done

then after I want to rename PMEvent, it is a silly name...done..
now called mwTriggerEvent mTriggerEvent

now make glt a class..why? why not? im doing it for everything else...

mwGlobalLevelTool mGlobalLevelTool


next bitmap tools
mwBitmapTools mBitmapTools
done..


mwMulticolorLine ..done...



can I make solid part of something else, or a class to itself?

class
mwSolid mSolid

done..


// z_control.h

void clear_controls(int p);
void set_controls_from_comp_move(int p, int comp_move);
void set_comp_move_from_player_key_check(int p);
void set_controls_from_player_key_check(int p);
void rungame_key_check(int p);
void proc_player_input(void);

I thinking this could be made part of player...
its only 150 lines

yes..do it...done..


what are the few things left?

e_fnx
z_screen
z_screen_overlay

main
loop
args

6 level editor files

lets look at screen and screen overlay...

800 lines
// z_screen.h

void get_new_background(int full);
void stimp(void);
void stamp(void);
void draw_hyst_rect(void);
void get_new_screen_buffer(int type, int x, int y);
void set_map_var(void);
void mark_non_default_block(int x, int y);
void init_level_background(int);
void draw_level2(ALLEGRO_BITMAP *b, int mx, int my, int ms, int blocks, int items, int enemies, int lifts, int players);
void draw_level_centered(int screen_x, int screen_y, int level_x, int level_y, float scale_factor);
void draw_level(void);
int get_contrasting_color(int color);
void frame_and_title(int show_players);
void rtextout_centre(ALLEGRO_FONT *f, ALLEGRO_BITMAP *dbmp, const char *txt1, int x, int y, int col, float scale, float op);
void draw_title(int tx, int ty, int ttw, int tth, int color);
void draw_large_text_overlay(int type, int color);
void draw_percent_barc(int cx, int y, int width, int height, int percent, int c1, int c2, int fc);
void draw_percent_bar(int cx, int y, int width, int height, int percent);
void draw_percent_bar_line(int cx, int y, int width, int height, int rise, int color, int percent);
void draw_percent_bar_range(int cx, int y, int width, int height, int color, int start, int end);


1100 lines
// z_screen_overlay.h
int dif_from_now_to_nl();
void show_player_stat_box(int tx, int y, int p);
void show_level_done(void);
void draw_screen_overlay(void);
void set_player_join_quit_display(int p, int type, int time);
void show_player_join_quit(void);
void draw_top_frame(int p);
void draw_bottom_frame(int p);
void draw_common_debug_overlay(int p, int &cx, int &cy);
void draw_server_debug_overlay(int p, int &cx, int &cy);
void draw_client_debug_overlay(int p, int &cx, int &cy);
void draw_demo_debug_overlay(int p, int &cx, int &cy);




I think I will combine them into a class:
mwScreen mScreen
then later seperate to two cpp files...
done..

move contrasting color to color....done

now I have args loop and main on the one end and e_fnx and the 6 level editor files on the other end...




what do args and main look like?

400 lines
// z_args.h
void proc_command_line_args1(int argument_count, char **argument_array);
void proc_command_line_args2(int argument_count, char **argument_array);
void copy_files_to_clients(int exe_only);
void temp_test(void);

300 lines
// z_main.h
void final_wrapup(void);
void fast_exit(int why);
void show_system_id();
void set_and_get_versions(void);
void get_desktop_resolution();
int initial_setup(void);
int main(int argument_count, char **argument_array);


what should i do with them?


how about a file called main.cpp with no header that only calls:

mwMain.cpp mMain


and in that class I will have everything from args and main..

lets try it...done...

now all I have is loop



700 lines
// z_loop.h
void draw_frame(void);
void move_frame(void);
void loop_frame(int);
int have_all_players_acknowledged(void);
void proc_level_done_mode(void);
void proc_program_state(void);
void proc_level_done_mode(void);
void main_loop(void);



has no functions
// mwProgramState.h
class mwProgramState
{
   public:

   mwProgramState(); // default constructor
   void initialize(void);


   int program_state = 0;
   int new_program_state = 0;
   int old_program_state = 0;
   int older_program_state = 0;

   int top_menu_sel = 3;
   int main_loop_exit = 0;

   // temp testing variables
   int pct_x = 0;
   int pct_y = 0;

   int autosave_level_editor_state;
   int level_editor_running;
   int help_screens_running;
   int visual_level_select_running;


   int show_debug_overlay;

   int show_player_join_quit_timer;
   int show_player_join_quit_player;
   int show_player_join_quit_jq;


   // frame_speed, frames per second, mwPS.frame_num stuff
   int speed_testing = 0;
   int frame_speed = 40;
   int frame_num;
   int speed_control_lock = 1;
   int eco_draw = 0;

   // some global strings

   char local_hostname[80];
   char pm_version_string[80];
   char al_version_string[80];
   //char msg[1024];

};
extern mwProgramState mwPS;

I somehow want to combine them...

loop has no varaibles
program state has no functions


mwLoop mLoop

should get all of the variables from program state...

yes..do it...


mwProgramState is gone..replaced by mwLoop

now add everything from z_loop to that...done...


now there is nothing but e_fnx and the 6 level editor files...



// e_fnx.h

int exit_level_editor_dialog(void);
int mw_file_select(const char * title, char * fn, const char * ext, int save);

void draw_block_non_default_flags(int tn, int x, int y);

void chop_first_x_char(char *str, int n);

int round20(int val);
int enforce_limit(int val, int ll, int ul);
int check_limit(int val, int ll, int ul);
void swap_int(int *i1, int* i2);
float mdw_rnd(float rmin, float rmax);
void set_int_3216(int &I32, int H16, int L16);
void get_int_3216(int I32, int &H16, int &L16);
void printBits(size_t const size, void const * const ptr);


float get_sproingy_jump_height(int num);
int get_sp(float jh);

void set_xyinc_rot(int e, int x2, int y2);
void set_rocket_rot(int num, int x2, int y2);



int get_block_range(const char *txt, int *x1, int *y1, int *x2, int *y2, int type);
int getxy(const char *txt, int obj_type, int sub_type, int num);
int get_trigger_item(int obj_type, int sub_type, int num);
int get_item(int obj_type, int sub_type, int num);

void crosshairs_full(int x, int y, int color, int line_width);
void titlex(const char *txt, int tc, int fc, int x1, int x2, int y);
void rectangle_with_diagonal_lines(float x1, float y1, float x2, float y2, int spacing, int frame_color, int line_color, int clip_mode);

void show_cursor(char *f, int cursor_pos, int xpos_c, int ypos, int cursor_color, int restore);
void edit_server_name(int type, int x, int y);
int edit_lift_name(int lift, int step_ty, int bts, char *fst);



thin out e_fnx....
removed:
void draw_vinepod_controls(int num, int legend_highlight);
void scale_bouncer_and_cannon_speed(int e);







// used only in sliders for button set new direction (rocket) !!! actually only in getxy
void set_rocket_rot(int num, int x2, int y2)
{
   float xlen = x2 - mItem.item[num][4];      // get the x distance between item and x2
   float ylen = y2 - mItem.item[num][5];      // get the y distance between item and y2
   float a = atan2(ylen, xlen) + ALLEGRO_PI/2;
   mItem.item[num][10] = a * 1000;
}
put this one instance inline...done



only in sliders for button set new direction (cannon and podzilla) !! actually in get xy just like above
void set_xyinc_rot(int e, int x2, int y2)
{
   float xlen = x2 - mEnemy.Ef[e][0];      // get the x distance between enemy and x2
   float ylen = y2 - mEnemy.Ef[e][1];      // get the y distance between enemy and y2
   float hy_dist = sqrt(pow(xlen, 2) + pow(ylen, 2)); // hypotenuse distance
   float speed = mEnemy.Ef[e][5];                  // speed
   float scaler = hy_dist / speed;     // get scaler
   mEnemy.Ef[e][2] = xlen / scaler;         // calc xinc
   mEnemy.Ef[e][3] = ylen / scaler;         // calc yinc
   mEnemy.Ef[e][14] = atan2(ylen, xlen) - ALLEGRO_PI / 2;
}
also used in ge to aim bouncer and cannon at start block or random
rename it:
void set_new_initial_direction(int e, int x2, int y2)
move it:done...


the list is a little thinner...


now for the huge one:

level_editor_mode is very similar to program state

It should not be that much of a stretch to make the level editor stuff fit into the loop and program state thing.


But I want to do something with all the source files...

list them first:
700  mwWindowManager
350  mwWindow

1000 edit_selection
800  editor_main
800  group edit
2000 object_viewer
600  tile helper
500  window common..


what if I amke them all part of the big window class
they alreay are, I mean just make all the functions member functions if they aren't already

mwWindow.cpp
mwWindowEditorMain
mwWindowEditSelection
mwWindowGroupEdit
mwWindowObjectViewer
mwWindowTileHelper


lets start with one that isn't too big..tile helper

// e_tile_helper.h

extern int thl[100][100]; // tile helper

void th_replace(int type);
int th_draw_buttons(int x3, int x4, int yfb, int draw_only);
int th_compare_tile(int rb, int cb, int group);
void th_find_connected(int x, int y, int group);
void th_process_mouse(void);


I don't want that array part of the windows class...i save and restore that..maybe part of wm class??
actually it makes no sense to add to win class, then all windows would get it...
I want specific storage for specific instances of windows
i could put it in wm as long as nothing else but wm uses w's

actually I save wm not w...maybe I should try it and see...40K..nbd 100x100x4

tile helper is done...mW.pm went from 18k to 58k


next add these to the main cpp file and make them part of the class..


500lines
// e_window_common.h
void cm_process_menu_bar(int draw_only);
int cm_draw_filter_buttons(int x1, int x2, int y1, int mode, int draw_only);
void cm_draw_status_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);
void cm_draw_selection_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);

350 lines
mwWindows.cpp

done:

Now I have left:
edit_selection..done
editor main
group edit..done
object viewer..done

the big ones...

mwWM.mW[1].editor main

mwWM.mW[4].edit selection
mwWM.mW[5].group edit
mwWM.mW[7].object viewer
mwWM.mW[9].tile helper

edit selection is done but has all the ft_ globals..Im amazied it works...
one left...done...woo hoo!! that was a lot of work...

actually there is one more..
e_fnx
mwMiscFnx mMiscFnx
lots of those....done!!


save and push..


Purple Martians Source Code Line Counts [2023-02-25  16:35:10]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1758][  1350][   515][   107][   408][   223] - mwWindowObjectViewer.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  2040][  1480][  1292][   349][   161][   188][   399] - mwLog.cpp
[  1767][  1366][  1162][   297][    93][   204][   308] - mwPlayers.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidget.cpp
[  1292][   970][   841][   188][    59][   129][   263] - mwBitmapTools.cpp
[  1144][   948][   856][   125][    33][    92][   163] - mwScreenOverlay.cpp
[  1291][   903][   827][   114][    38][    76][   350] - mwMiscFnx.cpp
[  1136][   898][   732][   206][    40][   166][   198] - mwLift.cpp
[  1059][   878][   744][   190][    56][   134][   125] - mwWindowEditSelection.cpp
[  1137][   805][   740][   125][    60][    65][   272] - mwSettings.cpp
[   918][   724][   658][   107][    41][    66][   153] - mwWindow.cpp
[   858][   721][   406][   363][    48][   315][    89] - mwWindowEditorMain.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1193][   702][   638][   121][    57][    64][   434] - mwGlobalLevelTool.cpp
[   776][   686][   603][   101][    18][    83][    72] - mwWindowGroupEdit.cpp
[   838][   627][   541][   153][    67][    86][   144] - mwScreen.cpp
[   769][   622][   565][    91][    34][    57][   113] - mwNetgameClient.cpp
[   824][   614][   569][    95][    50][    45][   160] - mwNetgameServer.cpp
[  1261][   582][   506][   346][   270][    76][   409] - mwMainArgs.cpp
[   768][   570][   406][   210][    46][   164][   152] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   791][   554][   477][   163][    86][    77][   151] - mwLoop.cpp
[   676][   551][   468][   107][    24][    83][   101] - mwItem.cpp
[   653][   541][   418][   148][    25][   123][    87] - mwItemEditorFnx.cpp
[   677][   519][   445][   121][    47][    74][   111] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   668][   467][   428][   124][    85][    39][   116] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   585][   438][   347][   150][    59][    91][    88] - mwSolid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   416][   192][   257][    33][   224][   139] - mwWindowTileHelper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   380][   304][    86][    10][    76][    44] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   454][   326][   310][    28][    12][    16][   116] - mwLevel.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   386][   268][   266][    23][    21][     2][    97] - mwConfig.cpp
[   359][   265][   188][   114][    37][    77][    57] - mwItemDoor.cpp
[   373][   262][   246][    37][    21][    16][    90] - mwNetgame.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   383][   231][   171][   122][    62][    60][    90] - mwEnemyVinePod.cpp
[   311][   227][   221][    27][    21][     6][    63] - mwMain.cpp
[   316][   226][   178][    71][    23][    48][    67] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwTriggerEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   294][   169][   151][    27][     9][    18][   116] - mwPlayers.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   233][   164][   111][    78][    25][    53][    44] - mwEnemyCannon.cpp
[   169][   150][   133][    20][     3][    17][    16] - mwMulticolorLine.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   209][   140][   107][    69][    36][    33][    33] - mwColor.cpp
[   146][   117][   104][    22][     9][    13][    20] - mwNetgame.h
[   219][   116][   107][    68][    59][     9][    44] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   170][   111][   107][    18][    14][     4][    45] - mwWindow.h
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   124][    97][    95][     8][     6][     2][    21] - mwSound.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItem.h
[   124][    78][    75][    10][     7][     3][    39] - mwLog.h
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    99][    73][    72][     6][     5][     1][    21] - mwLift.h
[   111][    70][    64][    12][     6][     6][    35] - mwEventQueue.cpp
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[    76][    65][    55][    13][     3][    10][     8] - mwGameEvent.cpp
[    95][    60][    58][    13][    11][     2][    24] - mwEnemy.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    95][    43][    40][     4][     1][     3][    51] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    59][    40][    40][     4][     4][     0][    15] - mwScreen.h
[    62][    39][    38][     5][     4][     1][    19] - mwLoop.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    45][    33][    32][     2][     1][     1][    11] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    39][    31][    30][     2][     1][     1][     7] - mwConfig.h
[    47][    29][    28][     2][     1][     1][    17] - mwLevel.h
[    42][    29][    29][     1][     1][     0][    12] - mwMiscFnx.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidget.h
[    43][    27][    27][     1][     1][     0][    15] - mwBottomMessage.h
[    52][    25][    25][     1][     1][     0][    26] - mwBitmapTools.h
[    33][    25][    24][     2][     1][     1][     7] - mwSettings.h
[    50][    24][    22][     4][     2][     2][    24] - mwGameMovesArray.h
[    28][    24][    24][     1][     1][     0][     3] - mwSound.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    45][    23][    23][     2][     2][     0][    20] - mwMain.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    23][    17][    17][     1][     1][     0][     5] - mwSolid.h
[    29][    16][    15][     2][     1][     1][    12] - mwTriggerEvent.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][     9][     9][     1][     1][     0][     5] - mwGlobalLevelTool.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    15][     9][     9][     1][     1][     0][     5] - mwMulticolorLine.h
[    10][     7][     7][     1][     1][     0][     2] - main.cpp
[    10][     6][     6][     1][     1][     0][     3] - mwGameEvent.h
-------------------------------------------------------- - totals
[ 46556][ 34554][ 29523][  7921][  2890][  5031][  9112] - 116 files






ok, what do I need to rename?


mwBitmap mwB;
mwB to mBitmap
done

mwBottomMessage mwBM;
mwBM to mBottomMessage
done


mwColor mColor;
mColor to mColor
done

mwDemoMode mwDM;
mwDM to mDemoMode
done

mwDisplay mwD;
mwD to mDisplay
done

mwDrawSequence mwDS;
mwDS to mDrawSequence
done

mwEventQueue mwEQ;
mwEQ to mEventQueue
done

mwFont mF;
mF to mFont
done

mwGameMovesArray mwGMA;
mwGameMovesArray to mwGameMoves done
mwGMA to mwGameMoves
done


mwGraph mwG[10];
mwG to mGraph
done


mwInput mI;
mI to mInput
done

mwLogo mwL;
mwL to mLogo
done

mwQuickGraph mwQG[10];
mwQG to mQuickGraph
done


mwRollingAverage mwRA[4];
mwRA to mRollingAverage
done

mwTally mwT[8];
mwT to mTally
done

mwTimeStamp mwTS;
mwTS to mTimeStamp
done


mwWidget is not even a class!!!


i have almost 500 occurances of widgets..search and replace would take a while

name length

mdw_slider
mdw_slideri
mdw_button
mdw_buttonp

mwWidget mW.slider

mW.slider
mWidget.slider


I alreadt have
mwWindow mW
mwWindowManager mwWM

at least mW is wholly contained in mwWM

how about mWidget

just do it...

why?...just so everything is the same...



20230226
82  slideri done
30  slider0 done
40  sliderf done
35  button
144 buttont
9   buttont_nb
7   buttonca
9   buttontt
33  buttonp
45  toggle
34  togglef
48  togglecc
8   colsel
-------------
520

widget is done...

then I should also do mwWM 744 references?? maybe later



I broke up mwLog.cpp (>2000) into:
380 mwLog.cpp
450 mwLogViewer.cpp
830 mwLogGraph.cpp

and also made a new class
220 mwCodeStat.cpp




I am having issues with callbacks in log files

C:\pm\src\mwLog.cpp|101|error: cannot convert 'mwLog::fill_filename_array' from type 'int (mwLog::)(ALLEGRO_FS_ENTRY*, void*)' to type 'int (*)(ALLEGRO_FS_ENTRY*, void*)'|
try to make the functiom static
I ended up keeping the callback function external to the class
it is defined in mLogViewer.cpp

int fill_filename_array(ALLEGRO_FS_ENTRY *fs, void * extra)
{
   if (mLog.num_filenames > 999) return 0; // only get 1000 max
   mLog.filenames[mLog.num_filenames] = al_create_fs_entry(al_get_fs_entry_name(fs));
   mLog.num_filenames++;
   return ALLEGRO_FOR_EACH_FS_ENTRY_OK;
}

has a prototype outside the class in mwLog.h
// cant be a part of the class if it gets called in a callback
int fill_filename_array(ALLEGRO_FS_ENTRY *fs, void * extra);
class mwLog
{
   private:

it uses the mLog instance of the variables internally..


this is shared with code stats... demo mode... maybe glt and visual level...

maybe I should make my own file iterator class that all of these can use...
it would still need an external callback function...


mwFileIterator mFileIterator

   ALLEGRO_FS_ENTRY *filenames[1000];
   int num_filenames;



show it being used:


int mwLog::load_profile_graph(int choose)
{
   mGraph[0].initialize();
   mGraph[0].set_series(0, "", 1, 0);
   char fname[256] = {0};
   int done = 0;
   int debug_print = 0;

   if (choose)
   {
      ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(fname, "Select Log File to View", "*.txt", 0);
      if (al_show_native_file_dialog(mDisplay.display, afc))
      {
         if (al_get_native_file_dialog_count(afc) == 1) sprintf(fname, "%s", al_get_native_file_dialog_path(afc, 0));
      }
      else { al_destroy_native_file_dialog(afc); return 0; } // user cancelled
      al_destroy_native_file_dialog(afc);
   }
   else // most recent file
   {
      sprintf(fname, "logs/");
      //printf("fname:%s\n", fname);
      // convert to 'ALLEGRO_FS_ENTRY' (to makes fully qualified path)
      ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

      // convert back to string
      sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));
      //printf("FS_fname:%s\n", fname);

      num_filenames = 0;
      // iterate levels in log folder and put in filename array
      al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);
      if (num_filenames == 0) printf("No log files found.\n");
      else
      {
         //for (int i=0; i< num_filenames; i++)
         //printf("%s\n", al_get_fs_entry_name(filenames[i]));
         time_t t = 0;
         int latest = 0;
         for (int i=0; i< num_filenames; i++)
            if (al_get_fs_entry_ctime(filenames[i]) > t)
            {
               t = al_get_fs_entry_ctime(filenames[i]);
               latest = i;
            }
         //printf("most recent file is: %s\n", al_get_fs_entry_name(filenames[latest]));
         sprintf(fname, "%s", al_get_fs_entry_name(filenames[latest]));
      }
   }


   FILE *filepntr=fopen(fname,"r");
   while(!done)
   {




void mwCodeStats::run(void)
{
   char msg[1024];
   struct code_stat cs[200] = {0};

   char fname[1024];
   sprintf(fname, "src/");
   ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

   // convert back to string
   sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));

   mLog.num_filenames = 0;

   // iterate files in folder and put in filename array
   al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);

   if (mLog.num_filenames == 0) printf("No files found.\n");
   else
   {
      for (int i=0; i<mLog.num_filenames; i++)
      {
         // printf("%s\n", al_get_fs_entry_name(filenames[i]));
         sprintf(cs[i].fname, al_get_fs_entry_name(mLog.filenames[i]));
         fill_stat_struct(cs[i]);

         // get just the name part of the path
         ALLEGRO_PATH * path = al_create_path(cs[i].fname);
         sprintf(cs[i].name, "%s", al_get_path_filename(path));
         al_destroy_path(path);
      }
   }
   // do the totals





{
   char msg[1024];
   al_show_mouse_cursor(mDisplay.display);
   char fname[1024];
   sprintf(fname, "logs/");
   //printf("fname:%s\n", fname);
   // convert to 'ALLEGRO_FS_ENTRY' (to makes fully qualified path)
   ALLEGRO_FS_ENTRY *FS_fname = al_create_fs_entry(fname);

   // convert back to string
   sprintf(fname, "%s\\", al_get_fs_entry_name(FS_fname));
   //printf("FS_fname:%s\n", fname);

   if (type == 2) // most recent file
   {
      num_filenames = 0;
      // iterate levels in log folder and put in filename array
      al_for_each_fs_entry(FS_fname, fill_filename_array, NULL);
      if (num_filenames == 0)
      {
         printf("No log files found.\n");
         type = 1; // prompt for select file
      }
      else
      {
         //for (int i=0; i< num_filenames; i++)
         //printf("%s\n", al_get_fs_entry_name(filenames[i]));
         time_t t = 0;
         int latest = 0;
         for (int i=0; i< num_filenames; i++)
            if (al_get_fs_entry_ctime(filenames[i]) > t)
            {
               t = al_get_fs_entry_ctime(filenames[i]);
               latest = i;
            }
         //printf("most recent file is: %s\n", al_get_fs_entry_name(filenames[latest]));
         sprintf(fname, "%s", al_get_fs_entry_name(filenames[latest]));
      }
   }
   if (type == 1) // select file
   {
      int user_cancelled = 0;
      ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(fname, "Select Log File to View", "*.txt", 0);
      if (al_show_native_file_dialog(mDisplay.display, afc))
      {
         if (al_get_native_file_dialog_count(afc) == 1)
         {
            const char * r = al_get_native_file_dialog_path(afc, 0);
            sprintf(fname, "%s", r);
            //printf("file selected:%s\n", fname);
         }
      }
      else
      {
         user_cancelled = 1;
         //printf("file select cancelled\n" );
      }
      al_destroy_native_file_dialog(afc);
      if (user_cancelled) return 0;
   }

   // get just the name part of the path
   ALLEGRO_PATH * path = al_create_path(fname);
   const char *tmp = al_get_path_filename(path);
   char fnam[100];
   sprintf(fnam, "%s", tmp);
   al_destroy_path(path);






for just these 3 case I will make the class, but I hope to do more with it later

mwFileIterator mFileIterator

   ALLEGRO_FS_ENTRY *filenames[1000];
   int num_filenames;

call it with dir and search string, it will fill its own internal array

also will have a method to get the most recent..

also..I am going to try to not have a global instance, only create one when needed...
dammit, there needs to be an instance for the callback...

OK I have it working for code stats...

does code stats need a global instance? probably not....
{mwCodeStats t; t.run();} works..
also make all functions static works...

try that with mwFileIterator...no luck....

moving on...

next load profile graph...

1 line!!!
sprintf(fname, "%s", al_get_fs_entry_name(mFileIterator.filenames[mFileIterator.get_most_recent("logs/")]));

better 1 line:
sprintf(fname, "%s", mFileIterator.get_most_recent_fname("logs/", fname));

next...log file viewer...done...







moving on...

demo mode.

int fill_demo_array(ALLEGRO_FS_ENTRY *fs, void * extra)
{
   if (mDemoMode.num_demo_filenames > 99) return 0; // only get 100 max
   mDemoMode.demo_FS_filenames[mDemoMode.num_demo_filenames] = al_create_fs_entry(al_get_fs_entry_name(fs));
   mDemoMode.demo_played[mDemoMode.num_demo_filenames] = 0;
   mDemoMode.num_demo_filenames++;
   return ALLEGRO_FOR_EACH_FS_ENTRY_OK;
}


   ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
   int num_demo_filenames;

looks like they are never referenced outside this class

I think I am going to leave this the way it is...
very small
only uses 100 instead of 1000
array is persistant

visual level does not use this method...

OK I think I'm done..


how does it work in linux?
looks good




what would a slider that doesnt block look like?
make one...done





new trigger emitter..timer

item 13 name timer

copy stuff from block damage, that has timers built in...
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val

t1 val
t2 val
count

if free run then count goes from 0 to t2 then resets

if wait for trigger then the same but wait for trigger before starting
can emit tiggers at t1 and t2


uses:
1 free run with on and off times by emitting 2 events at t1 and t2

2 wait for trigger then do something for t1 time, then something else at t2

what variable are going to be needed?

what shape?

I can have much better control over a timer display with all these extra variables

how about also something like cloner..then timer will only advance when triggered

so something like player has to be in box for timer to run
optionally reset if trigger goes away..


state t1 or t2

timer 1 val
timer 1 count

timer 1 trigger input mode:
0 = free run
1 = trigger to start then free run
2 = timer only runs when trigger is active
3 = timer only runs when trigger is active and resets when not
event used to trigger timer 1

timer 1 trigger output mode:
event to set when in mode (continuous)
event to set when mode completed (one time)




timer 2 val
timer 2 count

timer 2 trigger input mode:
0 = free run
1 = trigger to start then free run
2 = timer only runs when trigger is active
3 = timer only runs when trigger is active and resets when not
event used to trigger timer 2

timer 2 trigger output mode:
event to set when in mode (continuous)
event to set when mode completed (one time)

item[][0]  = 13 - Time Trigger
item[][1]  = count
item[][2]  = state
item[][3]  = flags

item[][4]  = x pos   (2000)
item[][5]  = y pos   (2000)

item[][6]  = t1 reset val
item[][7]  = t1 mode (0,1,2,3)
item[][8]  = t1 i/p event
item[][9]  = t1 o/p event

item[][10]  = t2 reset val
item[][11]  = t2 mode (0,1,2,3)
item[][12]  = t2 i/p event
item[][13]  = t2 o/p event

item[][14] = x2  for display
item[][15] = y2

now what kind of display icon TM

tile 987


now how to create one..
use PDE

I now have the shell of the new item..

create the ov


I will assume the item will always be in state 1 or 2
#define PM_ITEM_TIMER_STATE_CURR     0b00000000000100000
#define PM_ITEM_TIMER_STATE_PREV     0b00000000000100000


1 - find out what state we are in now
2 - compare with prev state and set appropriate events


wow, that was easy to implement..90% of all the functionality is there

I did not do any optimization of variables..
I still have left
3 flags
14 display
15 display

if I squeezed I could:
put state as a flag
put t1 and t2 mode as using 2 bits each in flags
this would get me 3 more variables to play with

I dont need it...

I want to make the draw mode use 14 and 15 and draw a rectangle there

it would be so nice to use 6789 for a rect just like all the others...

ok make me some free ones...

6 and 10 could be put into one...


new:

item[][0]  = 13 - Time Trigger
item[][1]  =
item[][2]  =
item[][3]  = flags

item[][4]  = x pos
item[][5]  = y pos

item[][6]  = x1
item[][7]  = y1
item[][8]  = w
item[][9]  = h

item[][10] = t1 reset val
item[][11] = t2 reset val
item[][12] = t1 i/p event
item[][13] = t1 o/p event
item[][14] = t2 i/p event
item[][15] = t2 o/p event

start by putting state into flags
make a function that does all that:

state:1
t1mode:2
t2mode:2
count:16

done...

now I have:
2 ints free even after using 4 for the display rectangle

item[][0]  = 13 - Time Trigger
item[][1]  =
item[][2]  =
item[][3]  = flags

item[][4]  = x pos
item[][5]  = y pos

item[][6]  = x1
item[][7]  = y1
item[][8]  = w
item[][9]  = h

item[][10] = t1 reset val
item[][11] = t2 reset val
item[][12] = t1 i/p event
item[][13] = t1 o/p event
item[][14] = t2 i/p event
item[][15] = t2 o/p event

void mwItem::set_timer_flags(int &pack, int state, int t1_mode, int t2_mode, int cnt)
{
   pack = state -1;
   int H16 = cnt<<16; // shift to upper 16 bits
   H16 &= 0b11111111111111110000000000000000; // clear other bits
   pack += H16;
   int t1m = t1_mode << 14; // shift to bits 14 and 15
   t1m &= 0b00000000000000001100000000000000; // clear other bits
   pack += t1m;
   int t2m = t2_mode << 12; // shift to bits 12 and 13
   t2m &= 0b00000000000000000011000000000000; // clear other bits
   pack += t2m;
}


void mwItem::get_timer_flags(int pack, int &state, int &t1_mode, int &t2_mode, int &cnt)
{
   cnt = pack>>16;
   t1_mode = pack>>14;
   t1_mode           &= 0b00000000000000000000000000000011;  // clear other bits
   t2_mode = pack>>12;
   t2_mode           &= 0b00000000000000000000000000000011;  // clear other bits
   state = 1 + (pack &  0b00000000000000000000000000000001); // clear other bits
}



next:

hook up the buttons that let you easily pick trigger input sources..

the same for outputs

test block manip

add some draw modes for the timing indicator


its been a long day..time for a push

Purple Martians Source Code Line Counts [2023-02-26  22:38:24]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2146][  1799][  1385][   522][   108][   414][   239] - mwWindowObjectViewer.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1980][  1388][  1150][   300][    62][   238][   530] - mwWidget.cpp
[  1745][  1359][  1155][   297][    93][   204][   293] - mwPlayers.cpp
[  1425][   971][   892][   122][    43][    79][   411] - mwMiscFnx.cpp
[  1144][   948][   856][   125][    33][    92][   163] - mwScreenOverlay.cpp
[  1247][   944][   815][   190][    61][   129][   242] - mwBitmapTools.cpp
[  1138][   897][   731][   206][    40][   166][   201] - mwLift.cpp
[  1053][   878][   698][   212][    32][   180][   143] - mwItemTrigger.cpp
[  1059][   878][   744][   190][    56][   134][   125] - mwWindowEditSelection.cpp
[  1120][   799][   734][   125][    60][    65][   261] - mwSettings.cpp
[   923][   725][   658][   108][    41][    67][   157] - mwWindow.cpp
[   858][   721][   406][   363][    48][   315][    89] - mwWindowEditorMain.cpp
[  1193][   702][   638][   121][    57][    64][   434] - mwGlobalLevelTool.cpp
[   776][   686][   603][   101][    18][    83][    72] - mwWindowGroupEdit.cpp
[   838][   627][   541][   153][    67][    86][   144] - mwScreen.cpp
[   769][   622][   565][    91][    34][    57][   113] - mwNetgameClient.cpp
[   824][   614][   569][    95][    50][    45][   160] - mwNetgameServer.cpp
[   813][   593][   493][   167][    67][   100][   153] - mwLogGraph.cpp
[  1261][   582][   506][   346][   270][    76][   409] - mwMainArgs.cpp
[   767][   570][   406][   210][    46][   164][   151] - mwEnemy.cpp
[   786][   557][   509][   110][    62][    48][   167] - mwVisualLevel.cpp
[   698][   555][   430][   151][    26][   125][   117] - mwItemEditorFnx.cpp
[   679][   554][   471][   107][    24][    83][   101] - mwItem.cpp
[   790][   554][   477][   163][    86][    77][   150] - mwLoop.cpp
[   677][   519][   445][   121][    47][    74][   111] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   554][   459][   434][    28][     3][    25][    92] - mwInput.cpp
[   635][   443][   410][   118][    85][    33][   107] - mwGameMoves.cpp
[   639][   441][   438][    67][    64][     3][   134] - mwDisplay.cpp
[   585][   438][   347][   150][    59][    91][    88] - mwSolid.cpp
[   492][   422][   366][    73][    17][    56][    53] - mwHelp.cpp
[   588][   416][   192][   257][    33][   224][   139] - mwWindowTileHelper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   435][   383][   307][    84][     8][    76][    44] - mwBottomMessage.cpp
[   438][   366][   326][    48][     8][    40][    64] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   395][   328][   268][    71][    11][    60][    56] - mwEnemyEditorFnx.cpp
[   443][   325][   263][    94][    32][    62][    86] - mwLogViewer.cpp
[   479][   316][   268][    77][    29][    48][   134] - mwItemMessage.cpp
[   404][   315][   291][    34][    10][    24][    79] - mwMenu.cpp
[   408][   305][   290][    27][    12][    15][    91] - mwLevel.cpp
[   390][   302][   298][     8][     4][     4][    84] - mwLog.cpp
[   373][   268][   267][    22][    21][     1][    84] - mwConfig.cpp
[   359][   265][   188][   114][    37][    77][    57] - mwItemDoor.cpp
[   371][   262][   246][    36][    20][    16][    89] - mwNetgame.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   383][   231][   171][   122][    62][    60][    90] - mwEnemyVinePod.cpp
[   308][   227][   221][    27][    21][     6][    60] - mwMain.cpp
[   316][   226][   178][    71][    23][    48][    67] - mwEnemyArchwagon.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwTriggerEvent.cpp
[   296][   212][   187][    62][    37][    25][    47] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   290][   182][   134][    88][    40][    48][    68] - mwEnemyCloner.cpp
[   246][   181][   180][     5][     4][     1][    61] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   274][   167][   150][    26][     9][    17][    98] - mwPlayers.h
[   235][   166][   133][    69][    36][    33][    33] - mwEnemyFnx.cpp
[   233][   164][   111][    78][    25][    53][    44] - mwEnemyCannon.cpp
[   169][   150][   133][    20][     3][    17][    16] - mwMulticolorLine.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   209][   145][   124][    60][    39][    21][    25] - mwCodeStats.cpp
[   146][   117][   104][    22][     9][    13][    20] - mwNetgame.h
[   219][   116][   107][    68][    59][     9][    44] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   158][   111][   107][    18][    14][     4][    33] - mwWindow.h
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   134][   104][    88][    33][    17][    16][    13] - mwColor.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][   100][    97][    11][     8][     3][    29] - mwItem.h
[   124][    97][    95][     8][     6][     2][    21] - mwSound.cpp
[   133][    94][    93][    17][    16][     1][    23] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   118][    76][    73][    12][     9][     3][    33] - mwLog.h
[   105][    75][    70][    17][    12][     5][    18] - mwDemoMode.cpp
[    92][    73][    72][     6][     5][     1][    14] - mwLift.h
[    85][    73][    73][     1][     1][     0][    11] - mwTimeStamp.cpp
[    87][    67][    64][     5][     2][     3][    18] - mwDisplay.h
[    75][    65][    55][    13][     3][    10][     7] - mwGameEvent.cpp
[    81][    63][    57][    12][     6][     6][    12] - mwEventQueue.cpp
[    93][    60][    58][    13][    11][     2][    22] - mwEnemy.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    66][    50][    49][     7][     6][     1][    10] - mwFileIterator.cpp
[    91][    43][    40][     4][     1][     3][    47] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    59][    40][    40][     4][     4][     0][    15] - mwScreen.h
[    62][    39][    38][     5][     4][     1][    19] - mwLoop.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    75][    36][    36][     1][     1][     0][    38] - mwWidget.h
[    58][    35][    34][     3][     2][     1][    21] - mwBitmap.h
[    38][    32][    31][     2][     1][     1][     5] - mwColor.h
[    41][    32][    31][     2][     1][     1][     8] - mwVisualLevel.h
[    38][    31][    30][     2][     1][     1][     6] - mwConfig.h
[    47][    31][    31][     1][     1][     0][    15] - mwMiscFnx.h
[    43][    27][    27][     1][     1][     0][    15] - mwBottomMessage.h
[    40][    27][    27][     1][     1][     0][    12] - mwLevel.h
[    31][    25][    25][     1][     1][     0][     5] - mwBitmapTools.h
[    36][    24][    22][     3][     1][     2][    11] - mwGameMoves.h
[    30][    24][    24][     1][     1][     0][     5] - mwSettings.h
[    28][    24][    24][     1][     1][     0][     3] - mwSound.h
[    45][    23][    23][     2][     2][     0][    20] - mwMain.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    36][    23][    23][     1][     1][     0][    12] - mwTimeStamp.h
[    28][    22][    22][     1][     1][     0][     5] - mwCodeStats.h
[    33][    22][    21][     2][     1][     1][    10] - mwDrawSequence.h
[    33][    20][    15][     6][     1][     5][    12] - mwEventQueue.h
[    26][    19][    19][     1][     1][     0][     6] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    23][    17][    17][     1][     1][     0][     5] - mwSolid.h
[    29][    16][    15][     2][     1][     1][    12] - mwTriggerEvent.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    23][    15][    15][     1][     1][     0][     7] - mwPDE.h
[    21][    12][    11][     2][     1][     1][     8] - mwFileIterator.h
[    20][    11][    11][     1][     1][     0][     8] - mwMenu.h
[    15][     9][     9][     1][     1][     0][     5] - mwGlobalLevelTool.h
[    15][     9][     9][     1][     1][     0][     5] - mwHelp.h
[    15][     9][     9][     1][     1][     0][     5] - mwMulticolorLine.h
[    10][     6][     6][     1][     1][     0][     3] - mwGameEvent.h
[     8][     5][     5][     1][     1][     0][     2] - main.cpp
-------------------------------------------------------- - totals
[ 46533][ 34775][ 29712][  7931][  2868][  5063][  8890] - 122 files








20230227
fix percent bar to draw exactly where you would expect it to..done

hook up the buttons that let you easily pick trigger input sources..
seems to work



the same for outputs
add some draw modes for the timing indicator

make sure timer always starts in mode 1, with cnt = t1_count..done

add to creator choose display rect..done

make header for each timer in ov

separate display stuff in ov..done



what happens when timer is set to zero?

should this be an option for both, for only 2, for neither?



some of my confusion is coming from the fact that timer is both event sender and reeiver

show timer sender links also..



when choosing event source and picking timer...it would be nice to know what timer is being used as a source...

change some functions like:

int get_trigger_item(int obj_type, int sub_type, int num);
right now it only returns item num or -1 if bad

change return val to be zero if bad or cancelled
add extra params

int get_trigger_item(int obj_type, int sub_type, int num, int &ti_type, &int ti_sub_type, &int ti_num );

then it can be used for lifts and others in the future, and subtype can also be used for timer 1 or 2..


now do the same for:

int is_mouse_on_trigger_item(ti_obj_type, ti_num);

i think i've got it...

do some tests...


block damage needs some tweaking

I want a mode that is on only when triggered
needs to be constantly triggered or it turns off

and the same only reversed:

off only when triggered
needs to be constantly triggered or it turns on


then I want a mode that toggles with trigger
I have that already

then I want a mode that turns on with one trigger and turns off with another..
this would be tricky to implement, I would need 2 input triggers...
can I do it with the new constant mode I am thinking of implementing?
probably

maybe I could make the timer outputs constant or only when switching

what are they now?, only once when changing...

options:
- add 2 more more output events or
- add a flag to each output event so it could be one or the other

what should I do next?


I want to add something to bm, a way of marking block that it will effect, like a flag..
so that it can turn on and off blocks without having to use toggle

add trigger sender to lift
works!!

fix new step menu length..done
fix list of steps..done
remove the button that searches for inputs..done
add to list so it can be found as a sender

I need to get my terminology consistant
it will help a lot in my code..


i use trigger, event, transmitter, receiver, sender...

preferred:
event sender
event receiver

to specify an object I will need three variables:
obj_type
obj_num
obj_ext

       obj_type obj_num obj_ext
item      2       num    n/a
orb       2       num    n/a
trigger   2       num    n/a
timer     2       num    timer number
enemy     3       num    n/a
lift      4       step   lift

when choosing lift step 6 as trigger sender, switch lift to that step for display..done..

this is coming along nicely


void mwTriggerEvent::find_and_show_event_links(int type, int i, int num2)

change to
void mwTriggerEvent::find_and_show_event_links(int obj_type, int obj_num, int obj_ext)

bug---can't see any prox line in level editor for prox lift step
it shows up fine in game
in level editor the function:
void set_lift_to_step(int l, int s)
{
   // new behaviour
   // if passed step is a move step, set that
   // if not, then set to previous move step
does not actually set lift's current step to steps that are not move steps

what if I changed that to only set lifts main pos to prev lift step, not actual step...fixed....


20230304 10:00AM

still working on lifts and trigger events...
I think lifts are done...

what should I do next?

add cloner to receivers

I think I can use Ei[][21] for trigger input..

I should also add a mode for that..

will I blindly just clone when trigger is received?

modes:
force clone when trigger received, probably use a toggle on

clone when trigger received, then use a cool done timer
run timer while triggered then when timer is full clone..

I think all of these case could be handled by the combination of timer and trigger items..


trigger direct will do instant

timer direct can do timed

I think I sould add the event option and see if I can replace all other uses...

make the option to have a timer run the cloner animation.

for now make a new mode and the option to set an event receiver..done
now I can control cloner with just event..

see if I can replace uses...

level 5
cloner 2
mode immed delay 90 with trigger box...
make trigger item of same size with player input...done
make the trigger item trigger a timer with t1 set to run whenever player is in trigger area

this works...

needs trigger item -> timer item -> cloner


level 6
cloner for rocket...
immed delay 20

trigger->timer->cloner

this time I want immediate with a cool off...

t1 time:1  run after trigger send event 2
t2 time:20 free run


I think those are the two most common use cases

check with glt...


the only types used are 0 and 2
0 timer runs
2 imdediate on trigger then timer runs

0 will be easy to replace with a straight timer.
2 can be replaced with a combo of trigger and timer..

I can also do a straight trigger input..

what I need to do is make a way that the timer can affect the cloner display

cloner display:
hidden or not
static shape
linked to timer (timer item num, timer 1 or 2)

I will have more space once I get rid of the 4 ints used for cloner trigger

all these can go:

//      Ei[e][5] = player in box
//      Ei[e][6] = create wait
//      Ei[e][7] = create wait counter
//      Ei[e][8] = trigger mode (0 = wait, 1=reset, 2=immed)
//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2


how will I go about changing all this?

Level:  1 - cloner:3 trigger type:0
Level:  5 - cloner:1 trigger type:0
Level:  5 - cloner:2 trigger type:3
Level:  5 - cloner:3 trigger type:0
Level:  6 - cloner:0 trigger type:3
Level:  7 - cloner:0 trigger type:0
Level:  8 - cloner:0 trigger type:2
Level:  8 - cloner:1 trigger type:0
Level:  8 - cloner:2 trigger type:0
Level:  8 - cloner:3 trigger type:0
Level:  8 - cloner:4 trigger type:2
Level:  9 - cloner:0 trigger type:2
Level:  9 - cloner:1 trigger type:2
Level:  9 - cloner:2 trigger type:0
Level:  9 - cloner:3 trigger type:2
Level:  9 - cloner:4 trigger type:2
Level: 10 - cloner:0 trigger type:0
Level: 10 - cloner:1 trigger type:0
Level: 10 - cloner:2 trigger type:0
Level: 10 - cloner:3 trigger type:2
Level: 11 - cloner:0 trigger type:2
Level: 11 - cloner:1 trigger type:2
Level: 11 - cloner:2 trigger type:2
Level: 11 - cloner:3 trigger type:2
Level: 11 - cloner:4 trigger type:2
Level: 11 - cloner:5 trigger type:2
Level: 11 - cloner:6 trigger type:0
Level: 11 - cloner:7 trigger type:2
Level: 11 - cloner:8 trigger type:2
Level: 11 - cloner:9 trigger type:0
Level: 11 - cloner:10 trigger type:0
Level: 11 - cloner:11 trigger type:0
Level: 11 - cloner:12 trigger type:0
Level: 12 - cloner:0 trigger type:0
Level: 12 - cloner:1 trigger type:2
Level: 12 - cloner:2 trigger type:2
Level: 12 - cloner:3 trigger type:0
Level: 12 - cloner:4 trigger type:0
Level: 12 - cloner:5 trigger type:0
Level: 13 - cloner:0 trigger type:0
Level: 13 - cloner:1 trigger type:0
Level: 13 - cloner:2 trigger type:0
Level: 13 - cloner:3 trigger type:2
Level: 15 - cloner:0 trigger type:0
Level: 16 - cloner:20 trigger type:2
Level: 16 - cloner:21 trigger type:2
Level: 16 - cloner:22 trigger type:0
Level: 16 - cloner:23 trigger type:2
Level: 16 - cloner:24 trigger type:0
Level: 16 - cloner:25 trigger type:0
Level: 16 - cloner:26 trigger type:0
Level: 17 - cloner:21 trigger type:2
Level: 17 - cloner:22 trigger type:0
Level: 17 - cloner:23 trigger type:0
Level: 17 - cloner:24 trigger type:0
Level: 17 - cloner:25 trigger type:0
Level: 17 - cloner:26 trigger type:0
Level: 17 - cloner:27 trigger type:0
Level: 18 - cloner:0 trigger type:0
Level: 18 - cloner:1 trigger type:0
Level: 19 - cloner:0 trigger type:2
Level: 19 - cloner:1 trigger type:0
Level: 19 - cloner:2 trigger type:0
Level: 20 - cloner:9 trigger type:0
Level: 20 - cloner:10 trigger type:0
Level: 20 - cloner:11 trigger type:0
Level: 21 - cloner:1 trigger type:0
Level: 21 - cloner:2 trigger type:0
Level: 21 - cloner:3 trigger type:0
Level: 21 - cloner:4 trigger type:0
Level: 21 - cloner:5 trigger type:0
Level: 21 - cloner:6 trigger type:0
Level: 21 - cloner:7 trigger type:0
Level: 22 - cloner:8 trigger type:2
Level: 22 - cloner:9 trigger type:0
Level: 22 - cloner:10 trigger type:0
Level: 22 - cloner:11 trigger type:0
Level: 23 - cloner:0 trigger type:0
Level: 23 - cloner:1 trigger type:0
Level: 23 - cloner:2 trigger type:2
Level: 23 - cloner:3 trigger type:2
Level: 23 - cloner:4 trigger type:0
Level: 26 - cloner:0 trigger type:2
Level: 28 - cloner:0 trigger type:2
Level: 29 - cloner:17 trigger type:0
Level: 29 - cloner:18 trigger type:0
Level: 29 - cloner:19 trigger type:0
Level: 29 - cloner:20 trigger type:0
Level: 30 - cloner:0 trigger type:0
Level: 30 - cloner:1 trigger type:0
Level: 30 - cloner:2 trigger type:0
Level: 31 - cloner:4 trigger type:2
Level: 31 - cloner:5 trigger type:0
Level: 32 - cloner:2 trigger type:0
Level: 32 - cloner:3 trigger type:0
Level: 32 - cloner:4 trigger type:0
Level: 32 - cloner:5 trigger type:0
Level: 32 - cloner:6 trigger type:0
Level: 33 - cloner:0 trigger type:0
Level: 33 - cloner:1 trigger type:0
Level: 33 - cloner:2 trigger type:0
Level: 33 - cloner:3 trigger type:0
Level: 35 - cloner:0 trigger type:2
Level: 35 - cloner:1 trigger type:2
Level: 35 - cloner:2 trigger type:2
Level: 35 - cloner:3 trigger type:0
Level: 35 - cloner:4 trigger type:0
Level: 35 - cloner:5 trigger type:2
Level: 36 - cloner:0 trigger type:2
Level: 36 - cloner:1 trigger type:0
Level: 49 - cloner:0 trigger type:0
Level: 50 - cloner:0 trigger type:2
Level: 51 - cloner:0 trigger type:3
Level: 83 - cloner:0 trigger type:0
Level: 83 - cloner:1 trigger type:0
Level: 83 - cloner:2 trigger type:0
Level: 83 - cloner:3 trigger type:0
Level: 83 - cloner:4 trigger type:0
Level: 84 - cloner:0 trigger type:0
Level: 84 - cloner:1 trigger type:0
Level: 84 - cloner:2 trigger type:2
Level: 86 - cloner:0 trigger type:0
Level: 88 - cloner:0 trigger type:0
Level: 88 - cloner:1 trigger type:0
Level: 88 - cloner:2 trigger type:0
Level: 88 - cloner:3 trigger type:0
Level: 88 - cloner:4 trigger type:0
Level: 89 - cloner:0 trigger type:0
Level: 93 - cloner:0 trigger type:0
Level: 93 - cloner:1 trigger type:0
Level: 93 - cloner:2 trigger type:0
Level: 93 - cloner:3 trigger type:2
Level: 93 - cloner:4 trigger type:0
Level: 93 - cloner:5 trigger type:0
Level: 95 - cloner:2 trigger type:0
Level: 95 - cloner:3 trigger type:0
Level: 97 - cloner:0 trigger type:0
Level: 97 - cloner:1 trigger type:0
Level: 97 - cloner:2 trigger type:0
Level: 97 - cloner:3 trigger type:0
Level: 98 - cloner:0 trigger type:0
Level:101 - cloner:1 trigger type:0
Level:101 - cloner:2 trigger type:0
Level:101 - cloner:3 trigger type:2
Level:102 - cloner:0 trigger type:0
Level:105 - cloner:0 trigger type:2
Level:105 - cloner:1 trigger type:2
Level:105 - cloner:2 trigger type:2
Level:106 - cloner:5 trigger type:0
Level:106 - cloner:6 trigger type:0
Level:106 - cloner:7 trigger type:0
Level:106 - cloner:8 trigger type:0
Level:106 - cloner:9 trigger type:2
Level:106 - cloner:10 trigger type:2
Level:106 - cloner:11 trigger type:2
Level:107 - cloner:0 trigger type:0
Level:113 - cloner:0 trigger type:0
Level:117 - cloner:6 trigger type:0
Level:153 - cloner:5 trigger type:2
Level:155 - cloner:4 trigger type:0
Level:155 - cloner:5 trigger type:0
Level:155 - cloner:6 trigger type:0
Level:155 - cloner:7 trigger type:0
Level:155 - cloner:8 trigger type:0
Level:155 - cloner:9 trigger type:2
Level:160 - cloner:0 trigger type:2
Level:160 - cloner:1 trigger type:2
Level:303 - cloner:0 trigger type:0
Level:303 - cloner:1 trigger type:2
Level:303 - cloner:2 trigger type:0
Level:303 - cloner:3 trigger type:0
Level:303 - cloner:4 trigger type:0
Level:303 - cloner:5 trigger type:0
Level:303 - cloner:6 trigger type:0
Level:313 - cloner:0 trigger type:2
Level:320 - cloner:0 trigger type:2
Level:320 - cloner:1 trigger type:2
Level:320 - cloner:2 trigger type:2
Level:321 - cloner:3 trigger type:0
Level:321 - cloner:4 trigger type:2
Level:322 - cloner:0 trigger type:2
Level:322 - cloner:1 trigger type:2
Level:322 - cloner:2 trigger type:2
Level:322 - cloner:3 trigger type:2
Level:322 - cloner:4 trigger type:2
Level:322 - cloner:5 trigger type:2
Level:324 - cloner:0 trigger type:2
Level:332 - cloner:98 trigger type:2
Level:333 - cloner:0 trigger type:2
Level:360 - cloner:4 trigger type:2
Level:360 - cloner:5 trigger type:0
Level:360 - cloner:6 trigger type:0
Level:360 - cloner:7 trigger type:0
Level:360 - cloner:8 trigger type:0
Level:360 - cloner:9 trigger type:0
Level:361 - cloner:0 trigger type:0
Level:361 - cloner:1 trigger type:2
Level:363 - cloner:0 trigger type:0
Level:364 - cloner:0 trigger type:1
Level:365 - cloner:16 trigger type:2
Level:365 - cloner:17 trigger type:0
Level:365 - cloner:18 trigger type:0
Level:368 - cloner:0 trigger type:0
Level:368 - cloner:1 trigger type:0
Level:369 - cloner:0 trigger type:2
Level:369 - cloner:1 trigger type:2
Level:370 - cloner:0 trigger type:0
Level:370 - cloner:1 trigger type:2
Level:371 - cloner:1 trigger type:2
Level:371 - cloner:2 trigger type:0
Level:371 - cloner:3 trigger type:2
Level:371 - cloner:4 trigger type:2
Level:372 - cloner:0 trigger type:0
Level:373 - cloner:26 trigger type:0
Level:373 - cloner:27 trigger type:0
Level:373 - cloner:28 trigger type:0
Level:373 - cloner:29 trigger type:0
Level:373 - cloner:30 trigger type:0
Level:373 - cloner:31 trigger type:0
Level:373 - cloner:32 trigger type:0
Level:373 - cloner:33 trigger type:0
Level:373 - cloner:34 trigger type:0
Level:373 - cloner:35 trigger type:0
Level:373 - cloner:36 trigger type:0
Level:373 - cloner:37 trigger type:0
Level:373 - cloner:38 trigger type:0
Level:373 - cloner:39 trigger type:0
Level:374 - cloner:4 trigger type:2
Level:374 - cloner:5 trigger type:2
Level:374 - cloner:6 trigger type:0
Level:374 - cloner:7 trigger type:0
Level:375 - cloner:2 trigger type:0


I think that 0 and 2 both run down the timer...


I want to automate this change somewhat

in glt for each cloner found:

create a trigger item with the same area as the cloners trigger area
create a timer item with the t1 the same time as the cloners time

put the newly created items immed above or below cloner

//      Ei[e][11] = trigger box x1
//      Ei[e][12] = trigger box y1
//      Ei[e][13] = trigger box x2
//      Ei[e][14] = trigger box y2

then gut cloner and re arrange variables


I know this is more complicated to make a cloner, but it is also much more extendable..

almost every cloner should have a timer driving it..

the timer can be a free run, or only run if player in trigger box.

what would it look like if the timer even that triggered that cloner was at the end of t2?


free run:
t1 0 free run
t2 100 free run and send event

free run when triggered:
t1 0 free run
t2 100 free run when triggered and send event

immed when triggered then run timer while still triggered:
t1 1 free run after triggered and send event
t2 100 free run

I think I am ready to pull the trigger on all the levels...

backup first...done
convert..done


move variables around
old:
Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)
Ei[][5]  mode
Ei[][6]  create wait
Ei[][7]  create wait counter
Ei[][8]  trigger mode (0=wait, 1=reset, 2=immed)
Ei[][9]  time to live for created objects
Ei[][10] max num of created objects
Ei[][11] trigger box x1
Ei[][12] trigger box y1
Ei[][13] trigger box x2
Ei[][14] trigger box y2
Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height
Ei[][21] event

new:
Ei[][4]  draw boxes (0 = none) (1 = trigger) (2 = source/dest) (3 = both)

Ei[][5]  draw mode
Ei[][6]  draw linked timer item num
Ei[][7]  draw linked timer num
Ei[][8]  event

Ei[][9]  time to live for created objects
Ei[][10] max num of created objects

Ei[][15] copy box x
Ei[][16] copy box y
Ei[][17] dest box x
Ei[][18] dest box y
Ei[][19] copy box width
Ei[][20] copy box height




add button to cloner to choose event and add stuff to make that work...
mostly done..now I need lines in ov overaly...done...



A very common mode (old 0)
timer runs while triggered then clones

could be implemented with either t1 or t2

t1 0 free run (skips immed)
t2 100 free run when triggered and send event

or

t1 100 free run when triggered and send event
t2 0   free run (skips immed)

make a function that returns a float based on the percent of the active timer
done..

add to cloner
Ei[][6]  draw linked timer item num
this could change..
make a function to find float timer ration based on event num
search item type 13 for event num match


I actually think cloner is done..mostly
creator...should I prompt for timer? and trigger..

timer display options.. at least have a way to not display anything..done


if timer value == 0 the timer is off






Another very common mode (old 2)
when triggered clone immediately then holdoff
if continually triggered will clone every period
if retriggered, nothing will happen until holdoff is done

if continually triggered, acts just like first use case

the difference here is when first triggered it clones right away

could be implemented with either t1 or t2

t1 1 free run when triggered and send event
t2 100 free run (just for holdoff delay)

or
t1 100 free run (just for holdoff delay)
t2 1 free run when triggered and send event



what if I made the immediate ones trigger with trigger only?
then it would be simpler..I would lose the auto retrigger stuff though
I can control how many are made with cloner..

going through levels and changing..
up to 10


make trigger boxes easier to see on overlay...

some triggers are less than 0 and greater than 2000
probably auto created...fix with glt...
4 key
9 trigger
14 switch
16 bm
17 bd

Running Global Level Test
l:1 it:9 x<0
l:1 it:9 y<0
l:5 it:9 x<0
l:5 it:9 w<2000
l:13 it:9 x<0
l:13 it:9 y<0
l:13 it:9 w<2000
l:13 it:9 h<2000
l:13 it:9 x<0
l:13 it:9 y<0
l:13 it:9 w<2000
l:13 it:9 h<2000
l:23 it:9 x<0
l:23 it:9 y<0
l:23 it:9 w<2000
l:23 it:9 h<2000
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0

fixed..







I have redidi all the cloner in levels up to 100 so far..

here are my notes:

I can just about always use timer 1 only...

if the old cloner had a trigger box the size of the entire level, the new one doesn't need one
use timer only in this case


if the old cloner waited for player to trigger to get an item, most of the time can do this with just trigger and cloned item limit

to use a cloner to make sure there is always 1 item in an area:
cloner -> timer -> trigger???





thoughts for the creator:

first lose the prompt for trigger...

then make some templates

cloner -> timer
free running timer in t1 that triggers cloner

cloner -> trigger
toggle trigger

cloner -> timer -> trigger
when you want a timed clone only when something triggers





ov set to zero sometimes buggy
start a level in level editor with no enemies...



ov_check_if_valid(type); is called from ov_get_size(void)

lets call it one sooner...

void mwWindow::draw(int draw_only)
{
   if (index == 7) // object viewer
   {
      ov_check_if_valid(type);
      ov_get_size();
      ov_title(x1, x2, y1, y2, legend_line);
      ov_draw_buttons(x1, y1, x2, y2, d);
   }

lets not pass type to it, make it calculate that itself

I think it is fixed...much simpler now:

void mwWindow::ov_check_if_valid(void)
{
   // check if the current object is valid
   int obt = mwWM.mW[7].obt;
   int num = mwWM.mW[7].num;
   if (obt==0)                               mwWM.set_windows(1);
   if ((obt==2) && (!mItem.item[num][0]))    mwWM.set_windows(1);
   if ((obt==3) && (!mEnemy.Ei[num][0]))     mwWM.set_windows(1);
   if ((obt==4) && (!mLift.cur[num].active)) mwWM.set_windows(1);
}




now I have done up to level 200
there are still some old type cloners in the 300's but I don't care, they are all junk levels anyway..




now what was I doing with timer's and such?

block damage has built in timers and quite a bit of display
the numbers and progress bars are not as configurable as the the ones in timer..

I could make some new modes...
on always unless a continous off event is present
off always unless a continous on event is present
these events could be sent with timers

that would take care of the three timed modes

existing modes:
always on
toggle
timed on
timed off
timed on and off



the simplest would be
toggle
on unless trigger
off unless triggered

the second two could be attached to a timer or to a constant trigger

trigger -> damage
timer -> damage
trigger -> timer -> damage


bottom line, timer will not be needed in damage, i will use item timer...
then what about display?

also for block manip i want a way to set blocks based on some flag
some way that is invisible in the game

made it so that I can view and edit block flags for blocks stored in block manip

now I need a flag to use for block manip
i am not using secret, how about that?

#define PM_BTILE_ROPE_MOVE         0b00010000000000000000000000000000
#define PM_BTILE_SECRET            0b00100000000000000000000000000000

do I need to rename it? or just use it

make a new mode in block manip

set all secret to block 1
set all secret to block 2
toggle secret from block 1 to block 2
(how does this differ from normal toggle)

actually all these modes could be the same, I could just have a flag to only apply them to blocks marked secret
and when applying them, do not change the secret flag..

item[][13] = secret flag only


looking at this now:
set all to block 1
set all secret to block 1
set all block 2 to block 1
toggle block 1 to block 2

makes more sense

set all block 2 to block 1 does not need to have secret flag added flag added
if that is what I want then add the flag to block2

the same with toggle 2 and 1..we already are looking for a specfic block..

hell I could even do away with mode 1...just set use mode 2 and make the replacement block have special flags

I think this was all I needed...get rid of 13 and tests..
good...

I think that block manip does everything I want it to..

what about bd?

I wanted to be able to control it with an external timer
do I want to get rid of the internal timer? and the internal display stuff?

bd modes:
0 - Always ON
1 - Toggle
2 - ON Until Triggered
3 - OFF Until Triggered
4 - Timed ON And OFF

item[][0]  = 17 - Block Damage
item[][1]  = event trigger number
item[][2]  = damage draw type
item[][3]  = flags
#define PM_ITEM_DAMAGE_PLAYER   0b00000000000000001
#define PM_ITEM_DAMAGE_ENEMY    0b00000000000000010
#define PM_ITEM_DAMAGE_ITEM     0b00000000000000100
#define PM_ITEM_DAMAGE_PSHOT    0b00000000000001000
#define PM_ITEM_DAMAGE_ESHOT    0b00000000000010000
#define PM_ITEM_DAMAGE_CURR     0b00000000000100000
#define PM_ITEM_DAMAGE_LIFT_ON  0b00000000001000000
#define PM_ITEM_DAMAGE_LIFT_XC  0b00000000010000000
#define PM_ITEM_DAMAGE_LIFT_XF  0b00000000100000000
#define PM_ITEM_DAMAGE_LIFT_XL  0b00000001000000000
#define PM_ITEM_DAMAGE_LIFT_YC  0b00000010000000000
#define PM_ITEM_DAMAGE_LIFT_YF  0b00000100000000000
#define PM_ITEM_DAMAGE_LIFT_YL  0b00001000000000000

item[][4]  = x pos   (2000)
item[][5]  = y pos   (2000)
item[][6]  = field x (2000)
item[][7]  = field y (2000)
item[][8]  = field w (2000)
item[][9]  = field h (2000)
item[][10] = lift number
item[][11] = mode
item[][12] = t1 val
item[][13] = count
item[][14] = t2 val
item[][15] = damage


how many bd do I have out there?

what do I want to do first?

should I add a option to timer to always set trigger when in a timer mode?
I would then use this to control whether or not damage field is on...

my other options are:

- use damage toggle mode and timer to do what I want
(this is the simplest solution, but I worry I can't trust it to be in a specific state)

- add two event inputs to damage, on and off..
(this seems the safest but would require the most changing)


I think I will try option 2:
use damage toggle mode and timers...

see if I can replace all occurances of using the internal timers
mode 2, 3, 4..

what about display??

level 7
on until triggered, off time 60..


I have run into a snag of the first one:
what I want is for the field to be always on, then off when triggered..
the problem is that I want to not count down the off time while still triggered..

while the timer is counting down, reset if triggered..

add a mode to timer:
reset if triggered..

that should do it..

I dont have enough bits for mode fix...

then I will need to convert all the old timers...

ARGH!!

make a list to start with


glt -> timers -> t1 and t2 mode...


l:  5 y:  8  t1_mode:2 t2_mode:0
l:  5 y:  9  t1_mode:2 t2_mode:0
l:  5 y: 10  t1_mode:2 t2_mode:0
l:  6 y:  0  t1_mode:0 t2_mode:1
l:  7 y: 41  t1_mode:1 t2_mode:2
l:  7 y: 42  t1_mode:1 t2_mode:3
l:  8 y: 22  t1_mode:1 t2_mode:0
l:  8 y: 23  t1_mode:2 t2_mode:0
l:  8 y: 24  t1_mode:2 t2_mode:0
l:  8 y: 25  t1_mode:2 t2_mode:0
l:  8 y: 26  t1_mode:1 t2_mode:0
l:  9 y:  3  t1_mode:1 t2_mode:0
l:  9 y:  4  t1_mode:1 t2_mode:0
l:  9 y:  5  t1_mode:2 t2_mode:0
l:  9 y:  6  t1_mode:1 t2_mode:0
l:  9 y:  7  t1_mode:1 t2_mode:0
l: 10 y:  7  t1_mode:2 t2_mode:0
l: 10 y:  8  t1_mode:2 t2_mode:0
l: 10 y:  9  t1_mode:2 t2_mode:0
l: 11 y: 22  t1_mode:2 t2_mode:0
l: 11 y: 23  t1_mode:1 t2_mode:0
l: 11 y: 24  t1_mode:2 t2_mode:0
l: 11 y: 25  t1_mode:2 t2_mode:0
l: 11 y: 26  t1_mode:2 t2_mode:0
l: 12 y: 23  t1_mode:2 t2_mode:0
l: 12 y: 24  t1_mode:2 t2_mode:0
l: 12 y: 25  t1_mode:2 t2_mode:0
l: 12 y: 26  t1_mode:2 t2_mode:0
l: 13 y: 14  t1_mode:0 t2_mode:0
l: 13 y: 15  t1_mode:0 t2_mode:0
l: 13 y: 16  t1_mode:0 t2_mode:0
l: 13 y: 17  t1_mode:2 t2_mode:0
l: 15 y:  8  t1_mode:0 t2_mode:0
l: 16 y: 15  t1_mode:2 t2_mode:0
l: 16 y: 16  t1_mode:2 t2_mode:0
l: 16 y: 17  t1_mode:0 t2_mode:0
l: 16 y: 18  t1_mode:0 t2_mode:0
l: 17 y: 29  t1_mode:0 t2_mode:0
l: 17 y: 30  t1_mode:2 t2_mode:0
l: 17 y: 31  t1_mode:0 t2_mode:0
l: 17 y: 32  t1_mode:2 t2_mode:0
l: 17 y: 33  t1_mode:0 t2_mode:0
l: 17 y: 34  t1_mode:2 t2_mode:0
l: 18 y:  7  t1_mode:0 t2_mode:0
l: 18 y:  8  t1_mode:2 t2_mode:0
l: 19 y:  5  t1_mode:2 t2_mode:0
l: 19 y:  6  t1_mode:2 t2_mode:0
l: 20 y: 33  t1_mode:2 t2_mode:0
l: 20 y: 34  t1_mode:2 t2_mode:0
l: 20 y: 35  t1_mode:2 t2_mode:0
l: 21 y: 17  t1_mode:2 t2_mode:0
l: 21 y: 18  t1_mode:2 t2_mode:0
l: 21 y: 19  t1_mode:2 t2_mode:0
l: 21 y: 20  t1_mode:2 t2_mode:0
l: 21 y: 21  t1_mode:2 t2_mode:0
l: 21 y: 22  t1_mode:2 t2_mode:0
l: 21 y: 23  t1_mode:2 t2_mode:0
l: 22 y:  9  t1_mode:0 t2_mode:0
l: 22 y: 10  t1_mode:2 t2_mode:0
l: 22 y: 11  t1_mode:0 t2_mode:0
l: 23 y:  8  t1_mode:0 t2_mode:0
l: 23 y:  9  t1_mode:2 t2_mode:0
l: 23 y: 10  t1_mode:2 t2_mode:0
l: 29 y:  8  t1_mode:2 t2_mode:0
l: 29 y:  9  t1_mode:2 t2_mode:0
l: 29 y: 10  t1_mode:2 t2_mode:0
l: 29 y: 11  t1_mode:2 t2_mode:0
l: 30 y:  6  t1_mode:2 t2_mode:0
l: 30 y:  7  t1_mode:2 t2_mode:0
l: 30 y:  8  t1_mode:2 t2_mode:0
l: 31 y: 15  t1_mode:0 t2_mode:0
l: 32 y: 12  t1_mode:2 t2_mode:0
l: 32 y: 13  t1_mode:0 t2_mode:0
l: 32 y: 14  t1_mode:2 t2_mode:0
l: 32 y: 15  t1_mode:2 t2_mode:0
l: 32 y: 16  t1_mode:2 t2_mode:0
l: 33 y:  7  t1_mode:0 t2_mode:0
l: 33 y:  8  t1_mode:0 t2_mode:0
l: 33 y:  9  t1_mode:0 t2_mode:0
l: 33 y: 10  t1_mode:0 t2_mode:0
l: 35 y: 33  t1_mode:2 t2_mode:0
l: 35 y: 34  t1_mode:2 t2_mode:0
l: 36 y: 26  t1_mode:0 t2_mode:0
l: 49 y:  6  t1_mode:3 t2_mode:1
l: 49 y:  7  t1_mode:0 t2_mode:0
l: 49 y:  8  t1_mode:1 t2_mode:2
l: 49 y:  9  t1_mode:1 t2_mode:0
l: 49 y: 10  t1_mode:2 t2_mode:0
l: 51 y:  3  t1_mode:0 t2_mode:0
l: 51 y:  4  t1_mode:0 t2_mode:0
l: 51 y:  5  t1_mode:0 t2_mode:0
l: 51 y:  6  t1_mode:0 t2_mode:0
l: 84 y:  4  t1_mode:2 t2_mode:0
l: 84 y:  5  t1_mode:2 t2_mode:0
l: 84 y:  6  t1_mode:2 t2_mode:0
l: 86 y: 13  t1_mode:2 t2_mode:0
l: 88 y: 29  t1_mode:2 t2_mode:0
l: 88 y: 30  t1_mode:2 t2_mode:0
l: 88 y: 31  t1_mode:2 t2_mode:0
l: 88 y: 32  t1_mode:2 t2_mode:0
l: 88 y: 33  t1_mode:2 t2_mode:0
l: 89 y: 10  t1_mode:2 t2_mode:0
l: 93 y:  1  t1_mode:2 t2_mode:0
l: 93 y:  2  t1_mode:2 t2_mode:0
l: 93 y:  3  t1_mode:2 t2_mode:0
l: 95 y:  2  t1_mode:2 t2_mode:0
l: 95 y:  3  t1_mode:2 t2_mode:0
l: 97 y:  0  t1_mode:0 t2_mode:0
l: 97 y:  1  t1_mode:0 t2_mode:0
l: 97 y:  2  t1_mode:0 t2_mode:0
l: 97 y:  3  t1_mode:0 t2_mode:0
l: 98 y:  3  t1_mode:2 t2_mode:0
l:101 y:  3  t1_mode:2 t2_mode:0
l:101 y:  4  t1_mode:2 t2_mode:0
l:102 y:  0  t1_mode:2 t2_mode:0
l:106 y:  6  t1_mode:2 t2_mode:0
l:106 y:  7  t1_mode:2 t2_mode:0
l:106 y:  8  t1_mode:2 t2_mode:0
l:106 y:  9  t1_mode:2 t2_mode:0
l:107 y:  3  t1_mode:2 t2_mode:0
l:113 y:  2  t1_mode:2 t2_mode:0
l:117 y:  1  t1_mode:2 t2_mode:0
l:155 y:  3  t1_mode:2 t2_mode:0
l:155 y:  4  t1_mode:2 t2_mode:0
l:155 y:  5  t1_mode:2 t2_mode:0
l:155 y:  6  t1_mode:2 t2_mode:0
l:155 y:  7  t1_mode:2 t2_mode:0
l:160 y:  5  t1_mode:1 t2_mode:0
l:160 y:  6  t1_mode:1 t2_mode:0
l:320 y:  7  t1_mode:0 t2_mode:0
l:320 y:  8  t1_mode:0 t2_mode:0
l:320 y:  9  t1_mode:0 t2_mode:0
l:321 y:  4  t1_mode:0 t2_mode:0
l:321 y:  5  t1_mode:0 t2_mode:0
l:322 y:  4  t1_mode:0 t2_mode:0
l:322 y:  5  t1_mode:0 t2_mode:0
l:322 y:  6  t1_mode:0 t2_mode:0
l:322 y:  7  t1_mode:0 t2_mode:0
l:322 y:  8  t1_mode:0 t2_mode:0
l:322 y:  9  t1_mode:0 t2_mode:0
l:324 y:  0  t1_mode:0 t2_mode:0
l:332 y:  0  t1_mode:0 t2_mode:0
l:333 y:  0  t1_mode:0 t2_mode:0
l:360 y:  7  t1_mode:0 t2_mode:0
l:360 y:  8  t1_mode:0 t2_mode:0
l:360 y:  9  t1_mode:0 t2_mode:0
l:360 y: 10  t1_mode:0 t2_mode:0
l:360 y: 11  t1_mode:0 t2_mode:0
l:360 y: 12  t1_mode:0 t2_mode:0
l:361 y:  7  t1_mode:0 t2_mode:0
l:361 y:  8  t1_mode:0 t2_mode:0
l:363 y:  5  t1_mode:0 t2_mode:0
l:364 y: 48  t1_mode:0 t2_mode:0
l:365 y: 30  t1_mode:0 t2_mode:0
l:365 y: 31  t1_mode:0 t2_mode:0
l:365 y: 32  t1_mode:0 t2_mode:0
l:368 y:  0  t1_mode:0 t2_mode:0
l:368 y:  1  t1_mode:0 t2_mode:0
l:369 y:  5  t1_mode:0 t2_mode:0
l:369 y:  6  t1_mode:0 t2_mode:0
l:370 y:  7  t1_mode:0 t2_mode:0
l:370 y:  8  t1_mode:0 t2_mode:0
l:371 y:  3  t1_mode:0 t2_mode:0
l:371 y:  4  t1_mode:0 t2_mode:0
l:371 y:  5  t1_mode:0 t2_mode:0
l:371 y:  6  t1_mode:0 t2_mode:0
l:372 y:  0  t1_mode:0 t2_mode:0
l:374 y: 18  t1_mode:0 t2_mode:0
l:374 y: 19  t1_mode:0 t2_mode:0
l:374 y: 20  t1_mode:0 t2_mode:0
l:374 y: 21  t1_mode:0 t2_mode:0
l:375 y:  7  t1_mode:0 t2_mode:0





new set function:


st
l:  5 y:  8  t1_mode:2 t2_mode:0
l:  5 y:  9  t1_mode:2 t2_mode:0
l:  5 y: 10  t1_mode:2 t2_mode:0
l:  6 y:  0  t1_mode:0 t2_mode:1
l:  7 y: 41  t1_mode:1 t2_mode:2
l:  7 y: 42  t1_mode:1 t2_mode:3
l:  8 y: 22  t1_mode:1 t2_mode:0
l:  8 y: 23  t1_mode:2 t2_mode:0
l:  8 y: 24  t1_mode:2 t2_mode:0
l:  8 y: 25  t1_mode:2 t2_mode:0
l:  8 y: 26  t1_mode:1 t2_mode:0
l:  9 y:  3  t1_mode:1 t2_mode:0
l:  9 y:  4  t1_mode:1 t2_mode:0
l:  9 y:  5  t1_mode:2 t2_mode:0
l:  9 y:  6  t1_mode:1 t2_mode:0
l:  9 y:  7  t1_mode:1 t2_mode:0
l: 10 y:  7  t1_mode:2 t2_mode:0
l: 10 y:  8  t1_mode:2 t2_mode:0
l: 10 y:  9  t1_mode:2 t2_mode:0
l: 11 y: 22  t1_mode:2 t2_mode:0
l: 11 y: 23  t1_mode:1 t2_mode:0
l: 11 y: 24  t1_mode:2 t2_mode:0
l: 11 y: 25  t1_mode:2 t2_mode:0
l: 11 y: 26  t1_mode:2 t2_mode:0
l: 12 y: 23  t1_mode:2 t2_mode:0
l: 12 y: 24  t1_mode:2 t2_mode:0
l: 12 y: 25  t1_mode:2 t2_mode:0
l: 12 y: 26  t1_mode:2 t2_mode:0
l: 13 y: 14  t1_mode:0 t2_mode:0
l: 13 y: 15  t1_mode:0 t2_mode:0
l: 13 y: 16  t1_mode:0 t2_mode:0
l: 13 y: 17  t1_mode:2 t2_mode:0
l: 15 y:  8  t1_mode:0 t2_mode:0
l: 16 y: 15  t1_mode:2 t2_mode:0
l: 16 y: 16  t1_mode:2 t2_mode:0
l: 16 y: 17  t1_mode:0 t2_mode:0
l: 16 y: 18  t1_mode:0 t2_mode:0
l: 17 y: 29  t1_mode:0 t2_mode:0
l: 17 y: 30  t1_mode:2 t2_mode:0
l: 17 y: 31  t1_mode:0 t2_mode:0
l: 17 y: 32  t1_mode:2 t2_mode:0
l: 17 y: 33  t1_mode:0 t2_mode:0
l: 17 y: 34  t1_mode:2 t2_mode:0
l: 18 y:  7  t1_mode:0 t2_mode:0
l: 18 y:  8  t1_mode:2 t2_mode:0
l: 19 y:  5  t1_mode:2 t2_mode:0
l: 19 y:  6  t1_mode:2 t2_mode:0
l: 20 y: 33  t1_mode:2 t2_mode:0
l: 20 y: 34  t1_mode:2 t2_mode:0
l: 20 y: 35  t1_mode:2 t2_mode:0
l: 21 y: 17  t1_mode:2 t2_mode:0
l: 21 y: 18  t1_mode:2 t2_mode:0
l: 21 y: 19  t1_mode:2 t2_mode:0
l: 21 y: 20  t1_mode:2 t2_mode:0
l: 21 y: 21  t1_mode:2 t2_mode:0
l: 21 y: 22  t1_mode:2 t2_mode:0
l: 21 y: 23  t1_mode:2 t2_mode:0
l: 22 y:  9  t1_mode:0 t2_mode:0
l: 22 y: 10  t1_mode:2 t2_mode:0
l: 22 y: 11  t1_mode:0 t2_mode:0
l: 23 y:  8  t1_mode:0 t2_mode:0
l: 23 y:  9  t1_mode:2 t2_mode:0
l: 23 y: 10  t1_mode:2 t2_mode:0
l: 29 y:  8  t1_mode:2 t2_mode:0
l: 29 y:  9  t1_mode:2 t2_mode:0
l: 29 y: 10  t1_mode:2 t2_mode:0
l: 29 y: 11  t1_mode:2 t2_mode:0
l: 30 y:  6  t1_mode:2 t2_mode:0
l: 30 y:  7  t1_mode:2 t2_mode:0
l: 30 y:  8  t1_mode:2 t2_mode:0
l: 31 y: 15  t1_mode:0 t2_mode:0
l: 32 y: 12  t1_mode:2 t2_mode:0
l: 32 y: 13  t1_mode:0 t2_mode:0
l: 32 y: 14  t1_mode:2 t2_mode:0
l: 32 y: 15  t1_mode:2 t2_mode:0
l: 32 y: 16  t1_mode:2 t2_mode:0
l: 33 y:  7  t1_mode:0 t2_mode:0
l: 33 y:  8  t1_mode:0 t2_mode:0
l: 33 y:  9  t1_mode:0 t2_mode:0
l: 33 y: 10  t1_mode:0 t2_mode:0
l: 35 y: 33  t1_mode:2 t2_mode:0
l: 35 y: 34  t1_mode:2 t2_mode:0
l: 36 y: 26  t1_mode:0 t2_mode:0
l: 49 y:  6  t1_mode:3 t2_mode:1
l: 49 y:  7  t1_mode:0 t2_mode:0
l: 49 y:  8  t1_mode:1 t2_mode:2
l: 49 y:  9  t1_mode:1 t2_mode:0
l: 49 y: 10  t1_mode:2 t2_mode:0
l: 51 y:  3  t1_mode:0 t2_mode:0
l: 51 y:  4  t1_mode:0 t2_mode:0
l: 51 y:  5  t1_mode:0 t2_mode:0
l: 51 y:  6  t1_mode:0 t2_mode:0
l: 84 y:  4  t1_mode:2 t2_mode:0
l: 84 y:  5  t1_mode:2 t2_mode:0
l: 84 y:  6  t1_mode:2 t2_mode:0
l: 86 y: 13  t1_mode:2 t2_mode:0
l: 88 y: 29  t1_mode:2 t2_mode:0
l: 88 y: 30  t1_mode:2 t2_mode:0
l: 88 y: 31  t1_mode:2 t2_mode:0
l: 88 y: 32  t1_mode:2 t2_mode:0
l: 88 y: 33  t1_mode:2 t2_mode:0
l: 89 y: 10  t1_mode:2 t2_mode:0
l: 93 y:  1  t1_mode:2 t2_mode:0
l: 93 y:  2  t1_mode:2 t2_mode:0
l: 93 y:  3  t1_mode:2 t2_mode:0
l: 95 y:  2  t1_mode:2 t2_mode:0
l: 95 y:  3  t1_mode:2 t2_mode:0
l: 97 y:  0  t1_mode:0 t2_mode:0
l: 97 y:  1  t1_mode:0 t2_mode:0
l: 97 y:  2  t1_mode:0 t2_mode:0
l: 97 y:  3  t1_mode:0 t2_mode:0
l: 98 y:  3  t1_mode:2 t2_mode:0
l:101 y:  3  t1_mode:2 t2_mode:0
l:101 y:  4  t1_mode:2 t2_mode:0
l:102 y:  0  t1_mode:2 t2_mode:0
l:106 y:  6  t1_mode:2 t2_mode:0
l:106 y:  7  t1_mode:2 t2_mode:0
l:106 y:  8  t1_mode:2 t2_mode:0
l:106 y:  9  t1_mode:2 t2_mode:0
l:107 y:  3  t1_mode:2 t2_mode:0
l:113 y:  2  t1_mode:2 t2_mode:0
l:117 y:  1  t1_mode:2 t2_mode:0
l:155 y:  3  t1_mode:2 t2_mode:0
l:155 y:  4  t1_mode:2 t2_mode:0
l:155 y:  5  t1_mode:2 t2_mode:0
l:155 y:  6  t1_mode:2 t2_mode:0
l:155 y:  7  t1_mode:2 t2_mode:0
l:160 y:  5  t1_mode:1 t2_mode:0
l:160 y:  6  t1_mode:1 t2_mode:0
l:320 y:  7  t1_mode:0 t2_mode:0
l:320 y:  8  t1_mode:0 t2_mode:0
l:320 y:  9  t1_mode:0 t2_mode:0
l:321 y:  4  t1_mode:0 t2_mode:0
l:321 y:  5  t1_mode:0 t2_mode:0
l:322 y:  4  t1_mode:0 t2_mode:0
l:322 y:  5  t1_mode:0 t2_mode:0
l:322 y:  6  t1_mode:0 t2_mode:0
l:322 y:  7  t1_mode:0 t2_mode:0
l:322 y:  8  t1_mode:0 t2_mode:0
l:322 y:  9  t1_mode:0 t2_mode:0
l:324 y:  0  t1_mode:0 t2_mode:0
l:332 y:  0  t1_mode:0 t2_mode:0
l:333 y:  0  t1_mode:0 t2_mode:0
l:360 y:  7  t1_mode:0 t2_mode:0
l:360 y:  8  t1_mode:0 t2_mode:0
l:360 y:  9  t1_mode:0 t2_mode:0
l:360 y: 10  t1_mode:0 t2_mode:0
l:360 y: 11  t1_mode:0 t2_mode:0
l:360 y: 12  t1_mode:0 t2_mode:0
l:361 y:  7  t1_mode:0 t2_mode:0
l:361 y:  8  t1_mode:0 t2_mode:0
l:363 y:  5  t1_mode:0 t2_mode:0
l:364 y: 48  t1_mode:0 t2_mode:0
l:365 y: 30  t1_mode:0 t2_mode:0
l:365 y: 31  t1_mode:0 t2_mode:0
l:365 y: 32  t1_mode:0 t2_mode:0
l:368 y:  0  t1_mode:0 t2_mode:0
l:368 y:  1  t1_mode:0 t2_mode:0
l:369 y:  5  t1_mode:0 t2_mode:0
l:369 y:  6  t1_mode:0 t2_mode:0
l:370 y:  7  t1_mode:0 t2_mode:0
l:370 y:  8  t1_mode:0 t2_mode:0
l:371 y:  3  t1_mode:0 t2_mode:0
l:371 y:  4  t1_mode:0 t2_mode:0
l:371 y:  5  t1_mode:0 t2_mode:0
l:371 y:  6  t1_mode:0 t2_mode:0
l:372 y:  0  t1_mode:0 t2_mode:0
l:374 y: 18  t1_mode:0 t2_mode:0
l:374 y: 19  t1_mode:0 t2_mode:0
l:374 y: 20  t1_mode:0 t2_mode:0
l:374 y: 21  t1_mode:0 t2_mode:0
l:375 y:  7  t1_mode:0 t2_mode:0
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0


I think they are all converted..moving on...

now I can make block damage in level 7 do what I want it to do


Running Global Level Test
l:1 y:0  mode:0
l:7 y:0  mode:1
l:7 y:1  mode:0
l:7 y:2  mode:0
l:7 y:3  mode:0
l:7 y:4  mode:0
l:7 y:5  mode:0
l:7 y:6  mode:0
l:9 y:0  mode:3
l:9 y:1  mode:3
l:11 y:0  mode:0
l:11 y:1  mode:3
l:11 y:2  mode:3
l:12 y:0  mode:0
l:12 y:1  mode:0
l:12 y:2  mode:0
l:12 y:3  mode:0
l:12 y:4  mode:0
l:13 y:0  mode:0
l:13 y:1  mode:3
l:15 y:0  mode:0
l:15 y:1  mode:0
l:15 y:2  mode:0
l:15 y:3  mode:0
l:15 y:4  mode:0
l:15 y:5  mode:0
l:15 y:6  mode:0
l:16 y:0  mode:3
l:16 y:1  mode:0
l:16 y:2  mode:3
l:16 y:3  mode:3
l:18 y:0  mode:0
done up to here:

l:20 y:1  mode:3
l:20 y:2  mode:0
l:20 y:3  mode:0
l:20 y:4  mode:3
l:20 y:5  mode:3
l:20 y:6  mode:0
l:20 y:7  mode:0
l:20 y:8  mode:0
l:20 y:9  mode:0
l:20 y:10  mode:3
l:20 y:11  mode:3
l:20 y:12  mode:0
l:20 y:13  mode:0
l:20 y:14  mode:0
l:21 y:0  mode:0
l:22 y:0  mode:0
l:22 y:1  mode:0
l:22 y:2  mode:0
l:22 y:3  mode:0
l:22 y:4  mode:0
l:22 y:5  mode:0
l:24 y:0  mode:3
l:26 y:0  mode:0
l:26 y:1  mode:0
l:28 y:0  mode:0
l:28 y:1  mode:0
l:31 y:0  mode:3
l:32 y:0  mode:3
l:32 y:1  mode:3
l:34 y:0  mode:0
l:34 y:1  mode:0
l:34 y:2  mode:0
l:34 y:3  mode:0
l:35 y:0  mode:3
l:35 y:1  mode:3
l:35 y:2  mode:3
l:35 y:3  mode:3
l:35 y:4  mode:0
l:35 y:5  mode:0
l:36 y:0  mode:3
l:36 y:1  mode:3
l:49 y:0  mode:3
l:49 y:1  mode:1
l:81 y:0  mode:0
l:82 y:0  mode:0



what if I made a new mode for bd...one time on..

when triggered, do the damage, don't toggle anything

then I would not have to use dual timer and toggle for simple one time damage blasts...

also how about on unless triggered..I know I already have that, but how about one without a timer

try the one time first..

mode 5 damage when triggered
this could replace almost everything (except always on)

new proposed modes:
0 always on
1 toggle
2 on till triggered
3 off till triggered

then just make timer capable of constant output

1 - make timer capable of constant event output
normal mode: send event when timer complete
constant: send trigger continoulsy when timer active
added to flags and ov


now do something with it..

change bd mode 2 and 3

these are now the only modes

0 always on
1 toggle
2 on till triggered
3 off till triggered



Running Global Level Test
l:1 y:0  mode:0
l:7 y:0  mode:2 still needed timer
l:7 y:1  mode:0
l:7 y:2  mode:0
l:7 y:3  mode:0
l:7 y:4  mode:0
l:7 y:5  mode:0
l:7 y:6  mode:0
l:9 y:0  mode:1 now mode 3 still no timer
l:9 y:1  mode:1 now mode 3 still no timer
l:11 y:0  mode:0
l:11 y:1  mode:1
l:11 y:2  mode:1
l:12 y:0  mode:0
l:12 y:1  mode:0
l:12 y:2  mode:0
l:12 y:3  mode:0
l:12 y:4  mode:0
l:13 y:0  mode:0
l:13 y:1  mode:1
l:15 y:0  mode:0
l:15 y:1  mode:0
l:15 y:2  mode:0
l:15 y:3  mode:0
l:15 y:4  mode:0
l:15 y:5  mode:0
l:15 y:6  mode:0
l:16 y:0  mode:1
l:16 y:1  mode:0
l:16 y:2  mode:1
l:16 y:3  mode:1
l:18 y:0  mode:0
l:20 y:0  mode:0
l:20 y:1  mode:1
l:20 y:2  mode:0
l:20 y:3  mode:0
l:20 y:4  mode:1
l:20 y:5  mode:1
l:20 y:6  mode:0
l:20 y:7  mode:0
l:20 y:8  mode:0
l:20 y:9  mode:0
l:20 y:10  mode:1
l:20 y:11  mode:1
l:20 y:12  mode:0
l:20 y:13  mode:0
l:20 y:14  mode:0

done
l:21 y:0  mode:0
l:22 y:0  mode:0
l:22 y:1  mode:0
l:22 y:2  mode:0
l:22 y:3  mode:0
l:22 y:4  mode:0
l:22 y:5  mode:0
l:24 y:0  mode:1

l:26 y:0  mode:0
l:26 y:1  mode:0
l:28 y:0  mode:0
l:28 y:1  mode:0


l:31 y:0  mode:3

l:32 y:0  mode:3
l:32 y:1  mode:3

l:34 y:0  mode:0
l:34 y:1  mode:0
l:34 y:2  mode:0
l:34 y:3  mode:0



l:35 y:0  mode:3
l:35 y:1  mode:3
l:35 y:2  mode:3
l:35 y:3  mode:3
l:35 y:4  mode:0
l:35 y:5  mode:0


mode 2 and 3 do not need any changes..




l:36 y:0  mode:3
l:36 y:1  mode:3



l:49 y:0  mode:3
l:49 y:1  mode:1

l:81 y:0  mode:0
l:82 y:0  mode:0
l:82 y:1  mode:0
l:82 y:2  mode:0
l:82 y:3  mode:0

l:83 y:0  mode:3
l:83 y:1  mode:0
l:83 y:2  mode:0
l:83 y:3  mode:0
l:83 y:4  mode:0
l:83 y:5  mode:3
l:83 y:6  mode:3

l:86 y:0  mode:3
l:86 y:1  mode:3
l:86 y:2  mode:2

all done up to level 88 bd example

fixed ov also..

now do something about draw mode..

red rect and spikey floor are good

do they work without timer?
yes, removed a bunch of stuff...


If I want to show progress use the timer...



l:95 y:0  mode:3
l:98 y:0  mode:0
l:98 y:1  mode:0
l:108 y:0  mode:0
l:110 y:0  mode:0
l:153 y:0  mode:0
l:155 y:0  mode:3
l:157 y:0  mode:0
l:157 y:1  mode:0
l:157 y:2  mode:0
l:157 y:3  mode:0
l:157 y:4  mode:0
l:157 y:5  mode:0
l:157 y:6  mode:0
l:157 y:7  mode:0
l:157 y:8  mode:0
l:157 y:9  mode:0
l:157 y:10  mode:0
l:157 y:11  mode:0
l:157 y:12  mode:0
l:157 y:13  mode:0
l:157 y:14  mode:0
l:157 y:15  mode:0
l:157 y:16  mode:0
l:157 y:17  mode:0
l:157 y:18  mode:0
l:157 y:19  mode:0
l:157 y:20  mode:0
l:157 y:21  mode:0
l:157 y:22  mode:0
l:157 y:23  mode:0
l:157 y:24  mode:0
l:157 y:25  mode:0
l:157 y:26  mode:0
l:157 y:27  mode:0
l:157 y:28  mode:0
l:157 y:29  mode:0
l:157 y:30  mode:0
l:157 y:31  mode:0
l:157 y:32  mode:0
l:157 y:33  mode:0
l:157 y:34  mode:0
l:157 y:35  mode:0
l:157 y:36  mode:0
l:157 y:37  mode:0
l:157 y:38  mode:0
l:157 y:39  mode:0
l:157 y:40  mode:0
l:157 y:41  mode:0
l:157 y:42  mode:0
l:157 y:43  mode:0
l:157 y:44  mode:0
l:157 y:45  mode:0
l:157 y:46  mode:0
l:157 y:47  mode:0
l:157 y:48  mode:0
l:157 y:49  mode:0
l:160 y:0  mode:3
l:160 y:1  mode:0
l:160 y:2  mode:3
l:313 y:0  mode:0
l:322 y:0  mode:2
l:322 y:1  mode:2
l:374 y:0  mode:8
l:374 y:1  mode:0
l:374 y:2  mode:0
l:374 y:3  mode:3
l:374 y:4  mode:3
l:375 y:0  mode:2
l:375 y:1  mode:0
l:375 y:2  mode:0
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0



all have been gone through....


moving some things from to do to done...

make level editor zoom mode that fits entire level vertically on screen..done

make block manip show flags for its blocks..done

in visual level select, make hotkey 'L' to start level editor on selected level
does not do as intended when L is a control...use END instead...done


ov set to zero sometimes buggy...i think i fixed it...




bug when adjusting trigger field in ov can't get last x pos..fixed

bug when drawing trigger field in overlay draws twice at wrong size
when ever drawing trigger shape in ov or draw item, etc...fixed by adding custom to draw_trigger

bug -- in level editor can't see trigger box edges on left or top if zero..fixed

bug - block damage does not destroy items..fixed

bug - when cloner is hidden, it shows till run for the first time..fixed
fixed this in draw cloner

bug - when cloner is invincible do not target with explosions..done

bug - player not hurt by damage field...fixed




another trigger emitter, based soley on time
cloner to take a trigger input
damage field to use this new trigger item
block manip also..

trigger emitters:
orb
trigger
-timer
-lift

trigger receivers:
block damage
block manip
lift
-cloner



20230312

mostly done with new event stuff, no new major features planned, just bugs as they pop up

fixed lift prox not showing in level editor again..


make spikes have some intermediate steps...

2 intermediate
0 - off 808
1 - 1/3
2 = 2/3
3 = on 807


0/3 - 1/3 804
1/3 - 2/3 805
2/3 - 3/3 806
3/3       807

find out what item is triggering
similar to how cloner does it..done and it looks good..
I only have one use of this in all levels!




I have a pretty big idea:


Make some more items that control things about the level.

Zones
big rectangular areas of the level that can be hidden or shown
maybe dependant on whether the player is in the zone or not

Field that lights bombs and rockets...

Springs that activate just by proximity...also have abritrary direction..like pinball bumpers




Wrap lines
horizontal or vertical line that instantly transport objects..

make a new item type
type 20 wrap

rectangle with four points..


for example lets just do a horizontal one.

for this we need 2 horizontal lines of the same length
x1, x2 and width

y1 and y2

do we need to specify which is the input and which is the output?

maybe it would be easier to do a rectangle and assume that nothing exists outside it.
all object exist inside and wrap when hitting an edge

optional x and y

optional for different types of objects??


make new item 20 with rectangle..

where do I start?
draw a shape or pick one...
544 for now

made simple PDE item.
make ov

now lets try some functionality

looking good!!

bullets go on forever..
make an option to not include them, or kill them at boundaries
did not even try to make lifts work, they use absolute positions



x and y only?  If I don't want them going off in one axis, either manually kill them or make a wall



make an button for what is affected:

Players
items
enemies
pbul
ebul

item[][3]  = flags
#define PM_ITEM_WRAP_PLAYER   0b000000000000000001
#define PM_ITEM_WRAP_ENEMY    0b000000000000000010
#define PM_ITEM_WRAP_ITEM     0b000000000000000100
#define PM_ITEM_WRAP_PSHOT    0b000000000000001000
#define PM_ITEM_WRAP_ESHOT    0b000000000000010000
#define PM_ITEM_WRAP_XMN      0b000000000000100000
#define PM_ITEM_WRAP_XPL      0b000000000001000000
#define PM_ITEM_WRAP_YMN      0b000000000010000000
#define PM_ITEM_WRAP_YPL      0b000000000100000000



some times things escape from the warp, not sure why and how I can prevent it...

I could have a mode where everything is forced to be within the rectangle, and if not jump it to there...
this would ony work with one wrap


how about check if object is within rectangle


it always seems to move to the other side fine, but once there not so good.
could I move to the other side and add inc??

how about not using any offset +10 -10? only do that when drawing..nah


I want to make this pixel perfect, I'm not sure what is going wrong...


how about check if object is within rectangle, then only check if it leaves...

I think this has to do with returning back to the same line we came from

get some data...


y1:310
y2:430

y 310 - good
move up .5
not caught in proc changed to 309.5

I finally fixed it, by adding xi, yi to h and w at the end of the line

if ((item[i][3] & PM_ITEM_WRAP_YPL) && (yi > 0) && (x >= x1) && (x <= x2) && (y <= y2) && (y+yi > y2)) y -= (h-yi); // moving down
if ((item[i][3] & PM_ITEM_WRAP_YMN) && (yi < 0) && (x >= x1) && (x <= x2) && (y >= y1) && (y+yi < y1)) y += (h+yi); // moving up
if ((item[i][3] & PM_ITEM_WRAP_XPL) && (xi > 0) && (y >= y1) && (y <= y2) && (x <= x2) && (x+xi > x2)) x -= (w-xi); // moving right
if ((item[i][3] & PM_ITEM_WRAP_XMN) && (xi < 0) && (y >= y1) && (y <= y2) && (x >= x1) && (x+xi < x1)) x += (w+xi); // moving left

I think I want to add something to bullets to kill them if they travel too far, or pass through too many wraps...

ladder does not work with wrap, probably due to no yinc..fixed


Now I would like to make something very similar but not aligned with a rectangle..
they could even be at right angles to each other...
It sounds like I am making portals!!

input line x or y
input direction + or -

output line x or y
ouptut direction + or -

one way or 2 way


rename old one wrap rect
new one wrap line


what am I going to do for variables:

i/p
x,y length

o/p
x,y

#define PM_ITEM_WRAP_PLAYER   0b000000000000000001
#define PM_ITEM_WRAP_ENEMY    0b000000000000000010
#define PM_ITEM_WRAP_ITEM     0b000000000000000100
#define PM_ITEM_WRAP_PSHOT    0b000000000000001000
#define PM_ITEM_WRAP_ESHOT    0b000000000000010000
#define PM_ITEM_WRAP_IPXY     0b000000000000100000
#define PM_ITEM_WRAP_IPPM     0b000000000001000000
#define PM_ITEM_WRAP_OPXY     0b000000000010000000
#define PM_ITEM_WRAP_OPPM     0b000000000100000000

I am going to skip this idea for now..


Lets see if I can flesh out the zones idea.


If there are no zones, act like normal.

Zones can have types or modes..

type 0 means do not draw

type 1 means draw always

type 2 means draw only when player is in zone

do I need this? multiplayer will be confusing

what about vertical launch pads




20230401 I have been busy on another project for a while

coming back, it looks like I am in the middle of WRAP, and still cant get it to work as good as I want

then I have some other things to clean up..

20230416

my other project is done for now...

having this break from pm hopefully has reset my obsession...
now that I am back I want to halt all new features and just complete and release the thing...

specifically:
roll back warp
remove warp line and warp rect
remove all instances in levels and remove from PDE...

removed this from bugs as it has been fixed:

prox in lifts is not right, uses prev step speed..fixed
drawing arrows has tracers..it makes no sense to me
it is an artifact from the shape beside it.
tile 488 is a right facing bullet
tile 487 is archwagon
they are both with the boundaries in gimp
none of these flags are used ALLEGRO_MIN_LINEAR ALLEGRO_MAG_LINEAR ALLEGRO_MIPMAP
it only happens at certain bullet speeds:
9.0 no
9.1 yes
9.2 no
9.3 yes
9.4 no
9.5 yes
I don't see it happpening for any other shape
the draw routine for e shots is very straight forward
al_draw_bitmap(mBitmap.tile[t], e[b].x, e[b].y, 0);
I will try to fix it with a hack, but it is very worrying to me
it should not do this..
use tile 328 and 329 instead on 488 and 489..fixed...





20230417

what is hotkey for settings? CTRL SHFT O

make eco_draw an option in settings ..done
remove F2 hot key to toggle eco_draw..done
only show eco draw in bottom frame when on..done






----------------------------------
add bottom message settings page
----------------------------------

in this page I want to show demo bmsg and have live changes



- what variables?

- save variables in cfg



add a bunch of settings for bottom message:
how many lines: 8 (max 20)
float io = 1.0; // initial opacity
float fo = 0.1; // final opacity
float ivs = 0.5; // initial v size
float fvs = 0.1; // final v size
float ihs = 0.5; // initial h size
float fhs = 0.1; // final h size

which game events cause messages

player tile, text or both
enemy  tile, text or both
item   tile, text or both

how close the player has to be to reduce messages



change event 2 to not need a specific item.

old:
mGameEvent.add(2, 0, 0, p, i, 0, 0);
if (ev == 2) // key
{
   custom_drawn = 1;
   bmsg_length += draw_text(" got a ", 15, bmsg_length);

   int c1 =0;  // color
   int tn = 0; // tile_numer
   int k = mItem.item[z2][1] - 1039;
   char tmsg[20] = {0};


new:
mGameEvent.add(2, 0, 0, p, mItem.item[i][1], 0, 0);
if (ev == 2) // key
{
   custom_drawn = 1;
   bmsg_length += draw_text(" got a ", 15, bmsg_length);

   int c1 =0;  // color
   int tn = 0; // tile_numer
   int k = z2 - 1039;
   char tmsg[20] = {0};


it has never come up before, but I do not have colors set for any player except 0
i only set those when needed in netgame
choose unued color?? only looks at active players
I don't think it could hurt to set those colors, will only be used by bmsg settings...
do it in initial setup..done


change:
mPlayer.loc[4].block_damage_item_number

to:
mPlayer.loc[4].block_damage_type

mGameEvent.add(59, 0, 0, p, i, 0, 0); // only do damage noise when taking health..??
does not set in player struct...
fixed all this to senf type item[i][2] in z2 and damage item[i][15] in z4
59 sets mPlayer.loc[4].block_damage_type
58 prints it..


72 health bonus
I want it to show the tile for flowers also...done...


now I am at the point that I want to start adjusting variables..

I might need to make them externally accessible and save them in config

how many lines: 8 (max 20)
float io = 1.0; // initial opacity
float fo = 0.1; // final opacity
float ivs = 0.5; // initial v size
float fvs = 0.1; // final v size
float ihs = 0.5; // initial h size
float fhs = 0.1; // final h size

this works great so far..

increase the max number of lines..done
make live adjustments..done

save in config
make button for defaults



void get_door_tile(int i, int &col, int &type)
{
   col = mItem.item[i][6];

   if (mItem.item[i][13] == 1083) type = 0;
   if (mItem.item[i][13] == 448) type = 1;
   if (mItem.item[i][13] == 0) type = -1;

}

pass these with event...





--------------

20230419

clean up the bitmap drawing routines in bmsg

they should all call one with passed bmp and offset

20230420
items are all on the new plan except I want to do nicer for bonus

928 - banana
929 - apple
930 - white flower
931 - pink flower
932 - blue cherries
933 - carrot
934 - red flower
935 - rainbow

960 - yellow
961 - red
962 - white
963 - pink
964 - blue
965 - orange
966 - green
967 - lt blue

now all of the items are done.

cleaned up the draw bmp and text routines..now there are only two...

next is the health drawing....

commit...its been a long time...

health drawing is done..

now toggles for each type..
this will be a lot...

use event numbers?


remember when I had msgs that showed up on screen where the stuff happened?
20030619 no
20061025 no
20091210 no
20100314 yes



20230422

player text long/short ...done
change buttonp to return 1 if pressed...currently void...done

make toggles for types
how many and where will I show them all?


23 unique


2  key
3  exit
5  door
30 switch
24 bomb
26 rocket

50 player hit a mine

59 raw damage
58 player lost health from block damage

71 player got a purple coin
72 player got a health bonus



43 player got shot by enemy
44 player got hit by enemy
40 player got shot by another player
52 exploded another player

60 player killed enemy with a shot
62 player killed enemy with explosion



54 player got squished
56 player got stuck


80 player joined
81 player quit
90 player died


int filter_event[100];



what about widget toggle? can I make it return 1 if pressed?
right now it returns value

it looks like the return value is never used for togglec...
test by making it void...compiles fine..

now change it to return 1 if pressed...done
maybe do the other toggles later...


combine both bombs into one
24 and 25 done...

combine 40 and 41...also 52 and 53

40 player got shot by another player
41 player shot themself
52 exploded another player
53 player exploded themself


add these to damage
54 player got squished
56 player got stuck


mGameEvent.add(54, x, y, p, 0, 0, 0); 5 calls
mGameEvent.add(56, x, y, p, 0, 0, 0); 1 call


if ((mLoop.frame_num) && (mLoop.frame_num == loc[p].block_damage_holdoff)) mGameEvent.add(58, 0, 0, p, 0, 0, 0);



does stuck and squished trigger every frame? looks like it..

I do custom holdoff for mine and block damage, but not for squished and stuck...
change to handle all the same....

also locked exit can trigger every frame



make stuck (56) send 59 instead, but make z2 type something else...


         if (type == 2) draw_text(" was hurt by spikey floor ", 15, xpos);
         else           draw_text(" was hurt by block damage ", 15, xpos);



mGameEvent.add(59, 0, 0, p, item[i][2], 0, item[i][15]); // only do damage noise when taking health..??

what specific types are used? 2 and ??

      if (var == 0) sprintf(msg, "Draw Type:none         ");
      if (var == 1) sprintf(msg, "Draw Type:Red Rectangle");
      if (var == 2) sprintf(msg, "Draw Type:Spikey Floor ");


if (ha > 0) // lose health
{
   int damage_type = 1; // default
   if (item[i][2] == 2) damage_type = 2;
   mGameEvent.add(59, 0, 0, p, damage_type, 0, item[i][15]); // only do damage noise when taking health..??




now can I add mine to that?

make it type 5
is damage the same scale? an int divided by 100?

mGameEvent.add(59, 0, 0, p, 5, 0, item[i][15]);


this is damage item
float ha = (float)item[i][15]/100; // health adjust

this is mine
mPlayer.syn[p].health -= (float)mItem.item[i][8] / 10;

change mine to use same scale


look in glt for all mines and get range...

looks like 5 10 12 20.....

multiply all by 10....done

adjust slider in ov..done
make default in PDE 50 from 5..done..

fix collision

void mwItem::proc_mine_collision(int p, int i)
{
   mPlayer.syn[p].health -= (float)mItem.item[i][8] / 100;
//   mGameEvent.add(50, 0, 0, p, i, 0, mItem.item[i][8]);
   mGameEvent.add(59, 0, 0, p, 5, 0, mItem.item[i][8]);
}

patch into bmsg..

      if (ev == 58) // player took damage (lost health from block damage, mine, stuck...
      {
         custom_drawn = 1;
         draw_text(" was hurt by ", 15, xpos);
         int damage = (int) mPlayer.loc[z1].block_damage_tally;
         int type = mPlayer.loc[z1].block_damage_type;
         if (type == 1) draw_text(" block damage ", 15, xpos);
         if (type == 2) draw_text(" spikey floor ", 15, xpos);
         if (type == 5) draw_item(mBitmap.tile[456], "mine", 15, xpos, 0, 0);
         draw_health(z1, -damage, xpos);
      }


remove mine holdoff stuff...done
remove 50 from config..done
rename three var in lo player sruct to remove 'block_'...done
when player health sends 58 send type as z2...done...

add stuck...make it type 7

void mwPlayers::proc_player_stuck_in_blocks(int p)
{
//      mGameEvent.add(56, x, y, p, 0, 0, 0);
      mGameEvent.add(59, x, y, p, 7, 0, 100);
   }
}

works
add squished ..make it type 9,,done

pass damage as z4 when player health sends 58


now i only have 18 unique types

      asci(BMSG, mBottomMessage.filter_event[2])
      asci(BMSG, mBottomMessage.filter_event[3])
      asci(BMSG, mBottomMessage.filter_event[5])
      asci(BMSG, mBottomMessage.filter_event[30])
      asci(BMSG, mBottomMessage.filter_event[24])
      asci(BMSG, mBottomMessage.filter_event[26])

      asci(BMSG, mBottomMessage.filter_event[71])
      asci(BMSG, mBottomMessage.filter_event[72])

      asci(BMSG, mBottomMessage.filter_event[40])
      asci(BMSG, mBottomMessage.filter_event[43])
      asci(BMSG, mBottomMessage.filter_event[44])

      asci(BMSG, mBottomMessage.filter_event[60])
      asci(BMSG, mBottomMessage.filter_event[62])
      asci(BMSG, mBottomMessage.filter_event[52])

      asci(BMSG, mBottomMessage.filter_event[80])
      asci(BMSG, mBottomMessage.filter_event[81])
      asci(BMSG, mBottomMessage.filter_event[90])


      asci(BMSG, mBottomMessage.filter_event[58])


2  key
3  exit
5  door
30 switch
24 bomb
26 rocket

71 player got a purple coin
72 player got a health bonus



40 player got shot by another player
43 player got shot by enemy
44 player got hit by enemy

60 player killed enemy with a shot
62 player killed enemy with explosion
52 exploded another player

80 player joined
81 player quit
90 player died

59 raw damage
58 player lost health from block damage

do some renaming

I want a master list of all my events...
some play sounds, some trigger bmsg


rearrange done..now fix bugs...

fuse hiss gone...fixed
for some reason proc_sound was not being called once per frame...

add all message controls then test...

test player hurt player in single player mode...
will need to do multiplayer for that


test enemy hit player..good
test enemy shot player..good

player shot enemy..good
player exploded enemy..good

player enemy collision..good

damage tally, mine, block damage, stuck, squished..good..
make default setting button



20230425
I think I finally have the settings page for bottom message done..
everything is lined up nice and looks good..

I still need to test the muliplayer messages...

what else do I need to finish?


wrap rect 20
wrap line 21
remove wrap PDE..done
remove wrap from levels..done
remove wrap from ov..commented out

change name of global level thingy..done

move test levels from 50 to higher...done...

go through levels and fix additions..

edit text for pmsg shows red ^ for most text...why?
in draw pop msg, when I draw the cursor, I count on char 30 being a blank space that does not count as a space
how can I fix this?
changed to char 96..its a good blank char in font pr8

visual level select to wrap when moving left and right and up and down...done

spelling mistakes premanment..fixed

edit text in trigger demo level..done

make mouse b2 exit settings..done
make mouse able to click on game menu..done
make mouse able to click on visual level select..done



make advanced section of settings
- how to toggle?
- what pages are advanced?


basic

   sprintf(st[0].title,  "Basics");
   sprintf(st[1].title,  "Controls");
   sprintf(st[2].title,  "Netgame");



advanced:
   sprintf(st[3].title,  "Double");
   sprintf(st[4].title,  "Demo");
   sprintf(st[5].title,  "Advanced");
   sprintf(st[7].title,  "Viewport");
   sprintf(st[10].title, "Overlay");
   sprintf(st[11].title, "Message");


debug:
   sprintf(st[6].title,  "Info");
   sprintf(st[8].title,  "Profiling");
   sprintf(st[9].title,  "Logging");

make a way to re-arrange without having to renumber

add to st struct what actual page each one is

another way would be to allow blanks in the list and just not draw them

then they could still keep their numbers

I would just turn on and off ones I don't want to show

yes, this sounds a lot simpler


make the 3 basic pages
Basics
Controls
Netgame

on basic pages

show advanced settings
show debug settings

these will show extra pages and also show more options on single pages

move stdf freq and udp/tcp to advanced on netgame..done

make a button to reset all config values to default (erase config file and reload)

do it on basic page for now, but later maybe have an advanced tab that has
this reset button and the advanced and debug toggles
also make it erase the level editor config mW.pm ..done
make server name look better:
frame it on its own line
edit text...done


make advanced tab part of basic stuff...
also demo

done...
add reset config and advanced and debug toggles..done

move spline test and eco draw somewhere else

add help buttons to settings..done

make message part of default
swap with double


make it so that I can configure system keys like F12, etc...


where can I move eco draw? speed controls, spline test?
I need more tabs in settings...
but another row would mess with height...

do it any way...

make another row, then see how things line up...done
moved crap to misc


newly created podzillas don't work...
also copied ones
why?
existing ones work...
there was a stupid al_fix_div with floats

copied podzilla have wrong size...
why?
fixed bug when savind sel, saved floats as ints...

make mouse wheel scroll in help..done

20230430 6:00 AM
Mom's bday


look at the level done stuff for netgame

single player music plays after level done
right now stop_sound is called in:
   if (mLoop.program_state == 12)
   {
      mSound.stop_sound();

but this is too late

move that call to

void mwLoop::proc_level_done_mode(void)
{
   if (mPlayer.syn[0].level_done_mode == 9) // pause players and set up exit xyincs
   {
      mSound.stop_sound();
that sounds kind of abrupt
can I gradually fade out?
   if (mPlayer.syn[0].level_done_mode == 8) // players seek exit
   {
//      float fade = (float) mPlayer.syn[0].level_done_timer / 60; // 1 to 0 in 60 frames
//      float fade = 0.5 + (float) mPlayer.syn[0].level_done_timer / 120; // 1 to .5 in 60 frames
      float fade = 0.3 + (float) mPlayer.syn[0].level_done_timer / 85; // 1 to .3 in 60 frames
      if (mSound.sound_on) al_set_mixer_gain(mSound.st_mixer, ((float)mSound.st_scaler / 9) * fade);

when players seek exit and it takes 60 frames fade from 1.0 to 0.3
restore mixer levels in start sound..
done...

stimp and warp level done stuff....
level done shows briefly when using warp
I can reduce the time, but what if it breaks things in network level done?
I'm getting a stimp in single player

tested multiplayer LAN 3P 150-153 has warp at end.. all good

temp made stimp and stamp 140frame from 40 for testing

is stamp only used when going back to menu?
right now level done does not stamp, but stimps


stamp is called only once, when changing program state to 1


stimp is called:

single player new game
level done
resume game
run demo


just looking at this, I would think I could remove the level done stimp...
or in level done do both stamp and stimp...
this sounds much more complex...
I think I've got it fixed by removing stimp in level done...
what if I added something the the level done..no

in screen overlay don't show large LEVEL DONE for level done modes < 4
that fixes the bried large LEVEL DONE in warp mode..

I think this is all fixed

fix stimp and stamp times, now 60..done

fix bmsg always on..fixed


look at command line switches in help..done

controls in help...
add help button to control page in settings
done
remove serial key..done
config file..done
title stretched??..fixed..
naviagation..done..




I want to make the system function keys configureable...


first make a list


[F1] fake key

<l14>         [F5] - Zoom Out (decrease scale factor)
<l14>         [F6] - Zoom In (increase scale factor)
<l14>    [F5]+[F6] - Reset Zoom (set scale factor to 1.0)

<l09>         [F7] - Speed Decrease (by 1 frame per second)
<l57>  [SHIFT][F7] - Speed Decrease (by 20 frames per second)
<l89>[CONTROL][F7] - Speed Decrease (by 100 frames per second)

<l09>    [F7]+[F8] - Reset Speed (set frames per second to 40)

<l09>         [F8] - Speed Increase (by 1 frame per second)
<l57>  [SHIFT][F8] - Speed Increase (by 20 frames per second)
<l89>[CONTROL][F8] - Speed Increase (by 100 frames per second)




<l15>        [F10] - Toggle the debug overlay

<l05>[PRINTSCREEN] - Saves a screen shot in the screenshot folder

<l13>        [F12] - Toggle Full Screen Mode


variables for config
I need a good name:
I have game controls, what do I call the others?
other controls

OTHER_CONTROLS_FULLSCREEN

other_control_fullscreen_toggle


function_key_fullscreen
function_key_text_double
function_key_debug_overlay
function_key_fakekey
function_key_printscreen
function_key_zoom_in
function_key_zoom_out

check for all these in function check
if any are set to 0 they are considered disabled


save them in config

edit them in settings...

F12 fullscreen
F11 double
F10 debug overlay

it works, but now I have to make it look good in settings...better

make a way to disable a control...
if press esc then set to zero
done


add names for missing things...
like ~

detect duplicate keys
done

set to defaults..done

center the top thing..done

make size dynamic..done
can adjust num lines and higher ones will not be shown

add more keys
speed
force_save
force_init_background

this is all done..

now I kind of want to make this more accessible

show tab with advanced

show last three with debug...
done

rename to "Function Keys"
show always

rename to "Controls 2"
title "Function Keys"

done...

make a new tab for speed control

add some framing to netgame tab..looks great now...

how about advanced toggle in title?..done

am I done with settings?

what else could I possibly add?

optional resolution in window title
- I can already show it with debug overlay

optional text in bottom frame

main menu level editor shortcut key

level editor ov lock key

change settings page for double...configrable key and default..done

max level num to show in visual level select..done



20230502 done with settings...

moving on...


alt levels...the ones not good enough for the main sequence
move the best ones to 50 and up
move others to > 200
done

when changing max_num_levels, force reload of vls..done


level 7 archwag can get pressed down through floor by lift
making level impossible to complete...
added damage field to block, that should fix it..







how do I make the spikes show progress?

instant mode is when bd is set to toggle
timer has t1 and t2 and both are set to one time output

bd on until triggered
timer mode continuous


there are 2 frames at the end of timer when ratio is very low but timer has not switched yet...
this makes the spike drawing not work nicely

how to fix?

fixed...


spikes only show progress when in modes:
2 on until triggered
3 off until triggered

spikes only show progress when:
curr damage is off and
a timer is counting down to turn them on..


I want to change pristine font to use better looking straight single and double quotes
did for p8 only...looks good...


add timer page to help..done


when sorting items, sort starts by start index...done
will make setting them up so much easier



block damage demo level
display stuff - bd no long has its own display stuff
fix modes - bd no longer has any timer modes
done..

when moving timer with es, display area should move also..done






SHIFT move timer in ov to move display box also

make swicth box move also like key
list of items that all should do that:
4 key
9 trigger
10 msg
13 timer
14 switch
16 manip
17 damage

// does the item type have a secondary position at 6,7?
int mwItem::item_secondary67(int type)
{
   if (type == 4)  return 1; // key
   if (type == 9)  return 1; // trigger
   if (type == 10) return 1; // message
   if (type == 13) return 1; // timer display
   if (type == 14) return 1; // switch
   if (type == 16) return 1; // block manip
   if (type == 17) return 1; // block damage
   return 0;
}

//if ((mItem.item[b][0] == 4) || (mItem.item[b][0] == 9) || (mItem.item[b][0] == 10) || (mItem.item[b][0] == 13) || (mItem.item[b][0] == 16) || (mItem.item[b][0] == 17)) // key, trigger, msg, timer, manip, damage
if (mItem.item_secondary67(mItem.item[b][0]))


is pop msg an exception? yes...

6 and 7 are used for timers shit...


it would be much better if they did not...




verify this:
[10] - pop-up msg
mItem.item[][6]  timer counter
mItem.item[][7]  timer value
mItem.item[][8]  text color
mItem.item[][9]  frame color
mItem.item[][10] msg x pos (100)
mItem.item[][11] msg y pos (100)

this from draw code does not agree:

   mMiscFnx.get_int_3216(mItem.item[i][10], x1, y1);       // get x and y
   mMiscFnx.get_int_3216(mItem.item[i][11], w, h);         // get width and height
   mMiscFnx.get_int_3216(mItem.item[i][13], tc, fc);       // get text and frame colors

the problem is that pmsg uses 6,7,8,9 for its own trigger box

how hard would it be to make it use the event system?

fix the variable description first

mItem.item[][6]  trigger x
mItem.item[][7]  trigger y
mItem.item[][8]  trigger w
mItem.item[][9]  trigger h
mItem.item[][10] msg x and y (packed)
mItem.item[][11] msg w and h (packed)
mItem.item[][12] timer count and val  (packed)
mItem.item[][13] text and frame color (packed)


now where to start?

end result:

mItem.item[][6]  msg x
mItem.item[][7]  msg y
mItem.item[][8]  msg w
mItem.item[][9]  msg h
mItem.item[][10] event trigger
mItem.item[][11]
mItem.item[][12]
mItem.item[][13] text and frame color (packed)


use glt to find how many pmsg use trigger box..


for levels < 100
296 show always
119 use trigger box


for each one that uses a trigger box
- make a trigger item with same area
- make timer item with same time
- link them all together with pmsg


how do I get from here to there?

start with the glt...

make trigger item


wait a tick here...

msg can use trigger box or basic shape....
count that...

lev < 100
415 total
296 show always
71  trigger box
48 no trigger box

revise the plans

mode draw always
do not need trigger or timer

mode draw with trigger
only need trigger event number

mode draw with scroll
need internal timer

I think I will keep the internal timer...I can always set it to zero

It will make some things easier and I can alway override if needed...


basically:
always on
turn on with scroll
turn on with event
delay to turn off (0 to disable)

this way I do not ever need to attach a timer to it

the only ones I will need to modify will be the ones that actually have a trigger box defined
and in those cases, just create a trigger item...


new:
mItem.item[][1] event trigger
mItem.item[][6]  msg x
mItem.item[][7]  msg y
mItem.item[][8]  msg w
mItem.item[][9]  msg h
mItem.item[][10]
mItem.item[][11]
mItem.item[][12] timer count and val  (packed)
mItem.item[][13] text and frame color (packed)


in order to change things I need a temp variable

does every message have the same int in 1? yes 1036
415 < 100
596 < 400

permanently make 1 into event trigger
hard code 1036...

done...

now I can use 1 as trigger event, just like bd and bm

next step...

set up a mode in timer to allow reading of trigger event....

add buttons to ov..done

add code to proc psmg..done

now when event is not zero if set it starts the msg timer...

next would be to create triggers in glt...

back up levels first...


it works as a proof on concept

before I replace 71 trigger things lets think this through...
- none of them should be visible

set all 596 messages to have 1 = 0..done

after setting, change flag


I think I am ready to do it...

make a running list of levels and messages that have been changed


Running Global Level Test
level:  6 y:  2
level:  6 y:  3
good


level:  7 y: 45
level:  7 y: 46
level:  7 y: 47
level:  7 y: 49
good


level:  9 y:  8
level:  9 y:  9
level:  9 y: 10
level:  9 y: 11
level:  9 y: 12


level: 10 y: 10
level: 11 y: 36
level: 11 y: 37
level: 12 y: 30
level: 13 y: 22
level: 13 y: 23
level: 13 y: 24
level: 18 y: 10
level: 20 y: 36
level: 20 y: 37
level: 20 y: 38
level: 20 y: 39
level: 20 y: 40
level: 20 y: 41
level: 20 y: 42
level: 20 y: 43
level: 20 y: 44
level: 20 y: 45
level: 26 y: 15
level: 26 y: 16
level: 26 y: 18
level: 28 y:  9
level: 28 y: 10
level: 29 y: 13
level: 32 y: 18
level: 34 y:  9
level: 36 y: 27
level: 36 y: 28
level: 39 y:  4
level: 44 y:  3
level: 47 y:  3
level: 47 y:  4
level: 55 y:  5
level: 80 y: 10
level: 80 y: 11
level: 80 y: 12
level: 80 y: 13
level: 82 y: 22
level: 82 y: 23
level: 82 y: 33
level: 82 y: 38
level: 83 y: 20
level: 83 y: 21
level: 83 y: 22
level: 83 y: 23
level: 83 y: 27
level: 84 y:  9
level: 84 y: 10
level: 84 y: 11
level: 85 y: 15
level: 85 y: 16
level: 85 y: 17
level: 85 y: 24
level: 85 y: 25
level: 85 y: 26
level: 91 y:  4
level: 91 y:  6
level: 91 y:  7
level: 91 y: 10
level: 97 y: 11
Total count0:0
Total count1:0
Total count2:0
Total count3:0
min:9990 max:0

without checking them all I am going to assume everything is good...

what is next?

there should be no need for the flag trigger rect... or the fucntions to draw or adjust it....

removed buttons from ov
now that 6, 7, 8, 9 are not needed for trigger anymore, move the message xywh to there

done

now fixed almost all stuff like that...

what else did you want to rearrange in popmsg?

fixed the checks for moving secondaries in edit selection
in save and fcopy

and in ov map move

make the docs for msg correct...done

also pacth secondary move into ov shift move item...done

A few finishing touches to ov message viewer


If show always, grey out a lot of stuff...
- dont show scroll
- dont show event stuff
- dont shopw timer

right under show always show the timer


show scroll implies that the scroll will trigger the message
if scroll is hidden, do not let it trigger message...
done

if (show always) do not show scroll..done


can I do custom height for item ov??


cursor in edit pmsg text is not very visible
make it blink faster and made custom char 127 that has double underline

done

no sound when taking damage
fixed


20230506 push

is there any reason I could not also set timer display to values not snapped to 20?
do it!!!   done...it was easy
what else could be high res adjust?
trigger
damage

what should never be high res?...things that deal with blocks...
key
switch
block damage

hi-res:
trigger
message
timer display
block damage

made a function in items for these
made it so that you can still snap to blocks when adjusting by holding shift

make a way to align messages with each other...
actually it could be any item that has a secondary 67 position
I was thinking of using group edit
select some items and edit them as a group
this works perfectly with all hires secondary items
x,y,w,h,xc,y2
test it out...
add clear obj list to right click..done...


find a way to add timer to first level...done...


Timer is not in filter list..fixed



it is only used in es when pasting a selection from ft_xxx to regular

Events in the copied section will probably collide with existing event links
this would take some time and effort to sort out after a paste so I want to do it automatically

hi level algorithm

before paste, iterate objects in ft_xx

look for any event recievers or senders

add to link translation table
include

ft_index
original event
new event
index of variable

at each insert, check to see if there is already a link entry from the old to the new event
if yes, use that
if not make a new mapping

then when adding objects check that index of each obj for an entry in the clt table

if there is one, substitute the new event number

the only thing I need to do is extend this table to work with enemies (cloner) and lifts also

add obt_type to table

new table

obt_type
obt_sub_type (for lifts, step num)
obt_num

old_ev
new_ev
var_num

obt (2 = item, 3 = enemy, 4=lift)
num (object_index)
ext (var type, or lift step num)
old_ev
new_ev


item: mItem.item[num][ext]
obt = 2
num = item index
ext = var_num

enemy: mEnemy.Ei[num][ext]
obt = 3
num = enemy index
ext = var_num

lift: mLift.stp[num][ext].val
obt = 4
num = lift index
ext = step index



this was the original that only did items

   // this section is to make any copied pm_event links have new unique pm_events and still linked properly
   int clt[500][4] = { 0 };
   int clt_last = 0; // index

   for (b=0; b<500; b++)       // iterate items in selection
   {
      if ((ft_item[b][0] == 10) || (ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // message, bm or bd
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 1, ft_item[b][1], clt, clt_last);
      }
      if (ft_item[b][0] == 9) // trigger
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
      }
      if (ft_item[b][0] == 13) // timer
      {
         clt_last += mTriggerEvent.add_item_link_translation(b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 14, ft_item[b][14], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(b, 15, ft_item[b][15], clt, clt_last);
      }
   }


   // items
   for (b=0; b<500; b++)
      if ((ft_item[b][0]) && (mwWM.obj_filter[2][ft_item[b][0]]))
      {
         //int copied = 0;
         for (c=0; c<500; c++) // search for empty place to copy to
         {
            if (mItem.item[c][0] == 0) // found empty
            {
               //copied = 1000+c;
               int lim = 0;
               // copy all 16 variables
               for (y=0; y<16; y++)
                     mItem.item[c][y] = ft_item[b][y];

               // apply offsets
               mItem.item[c][4] += x3;
               mItem.item[c][5] += y3;

               if (erase_out_of_bounds_main)
               {
                  if (mMiscFnx.check_limit(mItem.item[c][4], 0, 1980)) lim = 1;
                  if (mMiscFnx.check_limit(mItem.item[c][5], 0, 1980)) lim = 1;
               }
               else // adjust if out of bounds
               {
                  mItem.item[c][4] = mMiscFnx.enforce_limit(mItem.item[c][4], 0, 1980);
                  mItem.item[c][5] = mMiscFnx.enforce_limit(mItem.item[c][5], 0, 1980);
               }


               // does this copy item have an entry in the clt table?
               for (int i=0; i<clt_last; i++)
                  if (clt[i][0] == b) // found index of source item table
                  {
                     int var_index = clt[i][1]; // var #
                     int ev2 = clt[i][3];       // new ev

                     mItem.item[c][var_index] = ev2;
                  }



new:


int clt[100][5] = { 0 };
int clt_last = 0; // index

do this before lifts, enemies and items paste

clt[0] = obt
clt[1] = num
clt[2] = ext
clt[3] = src_ev
clt[4] = dst_ev







   // this section is to make any copied pm_event links have new unique pm_events and still linked properly
   int clt[100][5] = { 0 };
   int clt_last = 0; // index

//   clt[0] = obt (2=item, 3=enem, 4=lift)
//   clt[1] = num
//   clt[2] = ext (2,3 int var num  4=lift step index
//   clt[3] = src_ev
//   clt[4] = dst_ev

   for (b=0; b<500; b++) // iterate items in ft
   {
      if (ft_item[b][0] == 6) // orb
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 10, ft_item[b][10], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
      }
      if (ft_item[b][0] == 9) // trigger
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 11, ft_item[b][11], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 14, ft_item[b][14], clt, clt_last);
      }
      if (ft_item[b][0] == 13) // timer
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 12, ft_item[b][12], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 13, ft_item[b][13], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 14, ft_item[b][14], clt, clt_last);
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 15, ft_item[b][15], clt, clt_last);
      }
      if ((ft_item[b][0] == 10) || (ft_item[b][0] == 16) || (ft_item[b][0] == 17)) // message, bm or bd
      {
         clt_last += mTriggerEvent.add_item_link_translation(2, b, 1, ft_item[b][1], clt, clt_last);
      }
   }
   for (b=0; b<100; b++) // iterate enemies in ft
      if (ft_Ei[b][0] == 9) // cloner
         clt_last += mTriggerEvent.add_item_link_translation(3, b, 8, ft_Ei[b][8], clt, clt_last);


   for (b=0; b<ft_level_header[5]; b++) // iterate lifts in ft
      for (y=0; y<ft_lift[b][3]; y++) // iterate lift steps in ft
      {
         int step_type = ft_ls[b][y][5] % 31);
         int step_val = ft_ls[b][y][4];
         if ((step_type == 5) || (step_type == 6)) clt_last += mTriggerEvent.add_item_link_translation(4, b, y, step_val, clt, clt_last);
      }



20230508

timer demo level complete

look at when putting items from draw item...done

add a reload help key for editting help..done
lower ? and X for status window...done
add help ? to edit selection..done
add help ? for ge, th and ov..done
make ge controls always show..done


20230510

add jumpworm stuff to ge..done

same as arch

Ei
2 initial dir
10 turn before hole
11 jump before hole
12 jump before wall
7  jump under width
6  jump wait
done these 6

Ef
3 y speed same
6 x speed jump is same as arch x speed

new:
Ei
4 x speed ground (1/)
8 jump wall boost


there are some missing controls already
10 turn before hole
11 jump before hole
12 jump before wall
7  jump under width
6  jump wait
added all these


Is there an easier way to map what controls apply to what objects?
3 dimensional array?
control, obt, type
bool cot[40][2][20] = {0};
done


what if I gave the ge list a better title
Group Edit Object List

do I still want to show how many objects are listed?
what if I have some huge number and it scrolls off the bottom of the screen?
who cares? why would knowing how many objects there are make any difference?
I could make if hidden when it has nothing in the list...??
I tried it and don't like, it, need the right click menu

make all ge controls collapsed by default?..no
make + and - buttons to collapse/expand all...done
make + and - buttons for each control...done
make tinted backgrounds for controls...done and looks great

now ge is finally done...


th help is finally done...

cursor for th should be block, not just plain mouse
Main Action: Add Mark / Remove Marks
Tile Filter: Single Tile / All Matching Tiles / All Connected Matching Tiles
Match Type: Specific Tile Only / All Tiles in Tileset



podzilla and vinepod are very similar

I wonder if I could make vinepod do everything that podzilla does?


If I put cp1 and cp2 at 1/3 and 2/3 position in between initial and extended
that works...


as for speed:
podzilla speed is pixels/frame
vinepod speed is num of frames to get to extended


to convert podzilla speed to vinepod
get podzilla hypot distance
divide by podzilla speed
get time, that can be plugged into vinepod
v=d/t
d=vt
t=d/v

can i make a vinepod have a simple option? ignore cp?


how about the first step is to make them have the same speed

I have this function called re-calc pod that could possibly go away too


pod will just store main and extended pos and time
when time is running


vinepod actually stores extended pos in 9,10

can podzilla do the same?

podzilla could move 5-9 to 15-19 and be just like vinepod

I am really thinking about just doing it....
convert all podzilla to vinepod
then after that I can make some simple if I want

do both do the timer count thing the same?


is speed stored anywhwere in podzilla?

vinepod
//     Ei[e][15] = mode
//     Ei[e][16] = sequence counter
//     Ei[e][17] = sequence limit
//     Ei[e][18] = wait count
//     Ei[e][19] = wait limit
set 17 and 19 direct

podzilla
//     Ei[e][5] = mode
//     Ei[e][6] = sequence counter
//     Ei[e][7] = sequence limit
//     Ei[e][8] = wait count
//     Ei[e][9] = wait limit
set 9 direct
set speed Ef[e][9] direct then calculate Ei[e][7]..time


convert podzillas to use 15-19 instead of 5-9
then add main and extended pos to
Ei[e][3]  = x initial position
Ei[e][4]  = y initial position
Ei[e][9]  = x extended position
Ei[e][10] = y extended position


backup levels
use glt to copy all 5 6 7 8 9 to 15-19
for type 7
done
change podzilla move..done
still working

put main and extended pos in place
main copy from 0, 1
ext run function
done...
backup levels again..done

now what?

change method of running timer....

when leaving mode 0, do the calcs there for xinc, yinc
but first, do I already have the proper time in 17? I should...

this all seems to work...


now what?

am I ready to convert them all to vinepods?
not yet...

what then??

add to vinepod to make it simple...
then test...done

looks great

so to convert to vinepods:
change from 7 to 13
change to simple
change to not show

backup levels again..done

looks like its working great..

I now have no podzilla left at all....


I am thinking of re-arranging the numbers:

   strcpy (enemy_name[0][0],  "empty");
   strcpy (enemy_name[1][0],  "undef");
   strcpy (enemy_name[2][0],  "undef");
   strcpy (enemy_name[3][0],  "ArchWagon");
   strcpy (enemy_name[4][0],  "Bouncer");
   strcpy (enemy_name[5][0],  "JumpWorm");
   strcpy (enemy_name[6][0],  "Cannon");
   strcpy (enemy_name[7][0],  "PodZilla");
   strcpy (enemy_name[8][0],  "TrakBot");
   strcpy (enemy_name[9][0],  "Cloner");
   strcpy (enemy_name[10][0], "undef");
   strcpy (enemy_name[11][0], "Block Walker");
   strcpy (enemy_name[12][0], "Flapper");
   strcpy (enemy_name[13][0], "VinePod");


   strcpy (enemy_name[0][0],  "empty");
c  strcpy (enemy_name[1][0],  "Bouncer");
c  strcpy (enemy_name[2][0],  "Cannon");
   strcpy (enemy_name[3][0],  "ArchWagon");
c  strcpy (enemy_name[4][0],  "BlokWalk");
   strcpy (enemy_name[5][0],  "JumpWorm");
   strcpy (enemy_name[6][0],  "Flapper");
c  strcpy (enemy_name[7][0],  "VinePod");
   strcpy (enemy_name[8][0],  "TrakBot");
   strcpy (enemy_name[9][0],  "Cloner");

do it!

it is a huge change....


used glt to make all 13-7

4-1 and 6-2..done

11-4 and 12-6


now go through the files one at a time and fix:

mwEnemy.cpp..done
mwEnemyArchwagon.cpp..done
mwEnemyCannon.cpp..done
mwEnemyCloner.cpp..done
mwEnemyEditorFnx.cpp..done
mwEnemyFlapper.cpp..done
mwEnemyFnx.cpp..done
mwEnemyJumpworm.cpp..done
mwEnemyTrakbot.cpp..done
mwEnemyVinePod.cpp..done


mwWindowObjectViewer.cpp...done
mwWindow.cpp..done
creator
delete 04 vinepd 216
leave 05 podzilla 204 but rename to vinepod
make simple by default
set cp with thirds
done..

make ov overlays show cp only in !simple done

make ov hide stuff in simple

rearrange things in ov to make it look better

try the doubling of cp's...must be relative to initial?

add trigger input and output to vinepod
where will I find variables for that?
I supposed I could move some of the counters to floats
it would be easiest to move just counters

18 and 19 to 8 and 9

done...

now I should have 18, 19 and 21 free


18 input trigger
19 output trigger

add some flags to help with this bullshit
int trigger box enabled or not
output bullet or not

I think I have everything modified that I need to in: mwTriggerEvent.cpp

vp can be triggered by event now!
make a flag to disable int trigger box..done

vp can now send event!
the only option is at the same time as bullet is fired
I think that shoue be enough

make a flag to disable bullet firing..done


I want to make a common function that gets put the points into an array:

3 places:

move:
      // put variables in spline array
      float pnts[8];
      for (int i=0; i<8; i++) pnts[i] = Ei[e][i+3];

      // fill array of points from the spline
      int np = Ei[e][17]+1; // number of points
      float dest[np*2];
      al_calculate_spline(dest, 8, pnts, 0, np);


draw:

         // put variables in spline array
         float pnts[8];
         for (int i=0; i<8; i++) pnts[i] = Ei[e][i+3]+10;
//      // experimental scaling of control points
//         float d = 1;
//         pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//         pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//         pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//         pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;

         // draw spline path outline
         if (Ei[e][20] & PM_ENEMY_VINEPOD_SHOW_PATH) al_draw_spline(pnts, c2, 0);

         // if anything other than mode 0
         if (Ei[e][15])
         {
            // fill array of points from the spline
            int np = Ei[e][17]+1; // number of points
            float dest[np*2];
            al_calculate_spline(dest, 8, pnts, 0, np);

draw controls

      // put variables in spline array
      float pnts[8];
      for (int i=0; i<8; i++) pnts[i] = mEnemy.Ei[num][i+3]+10;

//      // experimental scaling of control points
//      float d = 1;
//      pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//      pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//      pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//      pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;

      al_draw_spline(pnts, mColor.pc[10], 0);

      // fill array of points from the spline
      float dest[200];
      al_calculate_spline(dest, 8, pnts, 0, 100);



I don't need to keep pnts anywhere

I just need to declare float dest[??]

then pass that to my fucntion..

int np = Ei[e][17]+1; // number of points
float dest[np*2];

vinepod_fill_points_array(int e, int np, float &dest[])
{
   // put variables in spline array
   float pnts[8];
   for (int i=0; i<8; i++) pnts[i] = mEnemy.Ei[num][i+3]+10;


//      // experimental scaling of control points
//      float d = 1;
//      pnts[2] = pnts[0] + (pnts[2] - pnts[0]) * d;
//      pnts[3] = pnts[1] + (pnts[3] - pnts[1]) * d;
//      pnts[4] = pnts[0] + (pnts[4] - pnts[0]) * d;
//      pnts[5] = pnts[1] + (pnts[5] - pnts[1]) * d;


   al_calculate_spline(dest, 8, pnts, 0, np);

}

do I want to add 10 when I create??

yes..

this works, its not much simpler, but at least it is all in one place

now implement control point multiplier

use a float...
Ef[][6] = 1

in glt make all vinepods:
#define PM_ENEMY_VINEPOD_USE_TRIGGER 0b00000000000100000
#define PM_ENEMY_VINEPOD_FIRE_SHOT   0b00000000001000000
Ef[][6] = 1

make creator also use these defaults

done...

now check how existing vinepods work...they seem to work fine

now finish the help screen for vinepod

trigger string...

help()


make a test example of:

vinepod triggering another vinepod in a chain

vinepod triggering a group of vinepods in a star

vinepod getting out of the way of a shot aimed at it

test invincible with non spline

looks good


I want some helpers to draw symmetrical splines

rotate spline 90 deg

init is the anchor
all other positions are relative


what about bullet speed for vinepod?
should be ef[][7]

fixed a bug....







use glt and find out how many:

lev  4 15 pod
lev 11 20 pod
lev 18 32 pod
lev 20 9  vinepod
lev 23 4  pod
lev 30 5  pod
lev 31 13 pod
lev 35 7  pod
lev 36 12 pod
lev 39 16 pod
lev 40 6  pod
lev 43 2  pod
lev 51 4  pod
lev 52 3  pod
lev 55 4 pod
lev 56 10 pod
lev 94 6 vinepod 7 podzilla
------
163 pod
17 vine

what is stopping me from combining podzilla into vinepod?
worries about performance?


if I made cp1 and cp2 able to be adjusted 0-2000 instead of 0-100
done for cp1, cp2 and ext, why not init?


made a way of muliplying the cp to deal with off level cps


see if I can make flag toggles work in group edit
what are edit options? all on all off random
done...


Redo vinepod demo level..done



make an expandable folder for the vinepod manip buttons:done




I have been having some problems with using the mouse scroll wheel to adjust sliders
in that loop with a mouse button pressed, where does the event loop get processed?
get slider pos
I spent some some time, but cannot understand why it does not work anymore
added a work around, hold mouse scroll button, then instead of scrolling, use arrows to move 1 val at a time
mouse scroll wheel still works good with help and graph...


make spline test not reset values..done
make spline adjust have simple directions, arrow keys mostly
make a spline reset button
all done

I want to do something so that the level editor remembers its last position
what variables are involved?, are they shared with game?
the problem seems to be that the mouse x and y are zero until the mouse is moved
fixed that..made it so that calling mInput.initialize() sets mouse x and y to actual values instead of zero


20230520

In the name of consistancy...
change class instance name from mwWM to mWM..done
shot shots..done
player players..done
widgets widget..done
item items..done





can I make precise move in ov with mouse and arrows
I have done that for enemies
normal = 20 move
CTRL = 1 move
SHIFT = also secondaries
mouse_b3 plus arrows single = pixel any dir
made a helper function to move enemies
works great, only when moving by 20's it no longer snaps to 20's

im thinking of how to implement that


make vinepod move positions snap to 20 or not
right now, SHIFT move init moves all
move init uses 20
move all others uses 1
I think I have it all sorted now:
normal move for all enemies is snap to 20
and also vps extra 3
when CTRL is held, move is 1 pixel
when SHIFT is held move secondaries also



How things are objects are moved by the mouse in object viewer:
---------------------------------------------------------------

Main enemy position:

Default:  Move by 20
CTRL:     Move by 1

Default: main pos only
SHIFT:   secondaries also

If default move of main pos, it will snap to 20's
(but will not snap secondaries, they are still relative to main pos)
I think this is how I wnat to keep it.
If I want to snap secondaries I can just click on them

I am thinking I might want a global snap to control for ov

what would that look like?
where would I store it?
in mW[7].snap

set it to 20 in constructor..
change it in top border...done

now use it...


I am not sure I am getting how this should work..
click on enemy
get mouse_offset
apply to pos
do rounding
see if it actually moved
if yes apply move to secondaries



I think I have this working good for moving main enemy pos:
- snap mouse pos
- get offset from enemy pos
- apply offset to main pos and optionally to secondaries

I think I have this working for all enemy secondaries also
now items..
looks like they are done also

how about lifts??
show step x, y, w, h for lift steps, just like for msg or cp
its coming along..looks like thet are all done..

now make b3 arrow work for all...done
works for:
main enemy
item secondary (only hires)

now make the snap slider thing look better



Can I make block manip copy a rectangular section of blocks
how many variables do I have left?
I could use 13 and 14
new mode:
copy rect area
done...


PDE needs to have enemy numbers fixed..done


adjust crew speed in ge like arch..done

adjust manip src with ov..done

something is fucky with doors
shapes change to 2nd type weirdly and crashes when changing

cannot reproduce on test level
erase door and try again

make mouse not disappear in level editor, ever...done

orb does not show lines to events it is linked to..fixed

modify block walker to make it an arbitrary block it turns into
35586216 - default H Block
done

I want to make the final rocket blastoff scene that I have always wanted to
where do I start?
make a special NPC to show locked up buddies
use enemy data struct, but make new type
this will look like a player but move like arch and jump over gaps
when triggered they will walk to rocket and find their places
how do I make them find nice places and not crowd each other?
new enemy type
what var for color?


now where do I put the custom cutscene?
how do I hook it in?

how about a new program state?

state 30 - cutscene
can get to this state from state 11



step 1 - zoom in on the level until the rocket is as wide as the screen
at this time show the message 'Preparing for take off!'

step 2 - erase everything else on the level

step 3


or
show message prepaing for takeoff

zoom until entire rocket is on screen

show the rocket moving upwards relative to the rest of the level
or the rest of the level moving down with the rocket stationary

when it is gone, switch to another view

just the rocket moving through space, getting smaller

then show level done

to make a bitmap of the rocket...13 x 94 or 260 x 1880

first, determine the zoom size that would have all of the level visible vertically

OK done state 31, zoom to fulscreen height..

state 32:
make large bitmap of rocket


state 33:
show level
erase where rocket is
draw new rocket

state 34:
destroy bitmap
level done




I am dithering between keeping background or rocket...

at the end I still want to use the rocket on the level for level done


how about:
bring all other players to the rocket
make a bitmap of the entire level
erase the rocket from the bitmap
actually erase everything on the level
draw the background bitmap as a layer, shifting downwards to make it look like the rocket is taking off


next..

after rocket has left level, zoom back in on cockpit..done

now make other players in multiplayer gather in rocket.

do this while first zooming in...


make a special place for them on a platform just below the cockpit

find out who is the captain...

the only way to do this is to detect in orb..
then set the player that triggered...done..ugly but done

x13 y6

make the time of the first seek and zoom
zoom and time both have to complete
if time completes first, stop doing xincs
set time to 100

make the second zoom smaller

then after that zoom back to original...done

test this muliplayer


20230522 12:12
push and relocate to garage

It does not work...

program state is not synced across...

its like it does not get triggered at all on clients


why is this so hard?

level done and bullshit like that are so hard for me...

they shouldn't be...

just get it working good on server then send to client...


I think my server rewind could be the cuplrit...I can't even get it to work in a server only netgame....

what did I do to fix it with level done?


I suppose I could make this procedure part of the level done code...not sure what I will gain...



first of all, fix the html docs for the existing level done procedure....
just update them mostly...done


then make some new modes, copying from the states I aleady have


ps 30

ldm 30 - start







   //---------------------------------------
   // 30 - end cutscene new 30
   //---------------------------------------
   if (program_state == 30)
   {
      cutscene_original_zoom = mDisplay.scale_factor_current;
      mDisplay.set_scale_factor((float)(mDisplay.SCREEN_H - BORDER_WIDTH*2)/2000, 0);


      // bring other netgame players home

      // each one has its own place

      int xh = 120;
      int yh = 260;
      for (int p=0; p< NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active)
         {
            float dx = xh - mPlayer.syn[p].x;
            float dy = yh - mPlayer.syn[p].y;

            mPlayer.syn[p].xinc = dx / 100;
            mPlayer.syn[p].yinc = dy / 100;

           // set left right direction
           if (mPlayer.syn[p].xinc > 0) mPlayer.syn[p].left_right = 1;
           if (mPlayer.syn[p].xinc < 0) mPlayer.syn[p].left_right = 0;

           xh += 20;

         }

      cutscene_timer = 100;
      mTriggerEvent.event[99] = 0; // clear trigger event
      program_state++;    // next state
   }


   31 - 29



   if (program_state == 32) 28
   {
      // create bitmap of the background
      cutscene_background = al_create_bitmap(2000, 2000);
      al_set_target_bitmap(cutscene_background);
      al_clear_to_color(al_map_rgba(0,0,0,0));
      al_draw_bitmap(mBitmap.level_buffer, 0, 0, 0);

      // erase the rocket area
      al_draw_filled_rectangle(20, 0, 380, 1980, mColor.Black);
      al_convert_mask_to_alpha(cutscene_background, mColor.Black);


      // actually erase everything else from level
      for (int i=0; i<100; i++) if (mEnemy.Ei[i][0] != 19) mEnemy.Ei[i][0] = 0; // enemies (except crew)
      for (int i=0; i<500; i++) mItem.item[i][0] = 0; // items
      mShot.clear_shots();

      // blocks
      for (int x=16; x<100; x++)
         for (int y=0; y<100; y++)
            mLevel.l[x][y] = 0;
      for (int x=0; x<3; x++)
         for (int y=0; y<100; y++)
            mLevel.l[x][y] = 0;
      for (int x=0; x<100; x++) mLevel.l[x][0] = 0; // top line
      for (int x=0; x<100; x++) mLevel.l[x][99] = 0; // bottom line
      mScreen.init_level_background(0);

      cutscene_timer = 200;
      cutscene_accel = 1.0;
      cutscene_bg_x =  0.0;
      program_state++;
   }


   if (program_state == 34)
   {
      mDisplay.set_scale_factor((float)(mDisplay.SCREEN_H - BORDER_WIDTH*2)/320, 0);
      program_state++;
   }

   if (program_state == 36)
   {
      al_destroy_bitmap(cutscene_background);

      mPlayer.syn[0].level_done_mode = 6;
      mPlayer.syn[0].level_done_timer = 0;
      mPlayer.syn[0].level_done_x = mPlayer.syn[0].x;
      mPlayer.syn[0].level_done_y = mPlayer.syn[0].y;
      mPlayer.syn[0].level_done_next_level = 1;

      mDisplay.set_scale_factor(cutscene_original_zoom, 0);

      program_state = 11;
   }




         if (program_state == 31) // cutscene zoom adjust
         {
            mDisplay.proc_scale_factor_change();

            if (--cutscene_timer < 0) cutscene_timer = 0;

            if (cutscene_timer)
               for (int p=0; p< NUM_PLAYERS; p++)
                  if (mPlayer.syn[p].active)
                  {
                     mPlayer.syn[p].x += mPlayer.syn[p].xinc;
                     mPlayer.syn[p].y += mPlayer.syn[p].yinc;
                  }

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();

            draw_frame();
            al_flip_display();
            if ((abs(mDisplay.scale_factor_current - mDisplay.scale_factor) < .001) && (cutscene_timer == 0)) program_state++;
         }

         if (program_state == 33) // cutscene rocket move
         {

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();


            mScreen.get_new_background(1);

            cutscene_bg_x += cutscene_accel;
            cutscene_accel += 0.1;
            al_draw_bitmap(cutscene_background, 0, cutscene_bg_x, 0);

            mEnemy.draw_enemies();
            mPlayer.draw_players();

            mScreen.get_new_screen_buffer(0, 0, 0);
            mScreen.draw_screen_overlay();
            al_flip_display();

            if (--cutscene_timer < 1) program_state++;


         }

         if (program_state == 35) // cutscene zoom adjust
         {

            mLoop.frame_num++;
            if (mNetgame.ima_server) mNetgame.server_control();
            if (mNetgame.ima_client) mNetgame.client_control();
            mNetgame.server_create_new_state();

            mDisplay.proc_scale_factor_change();
            draw_frame();
            al_flip_display();
            if (abs(mDisplay.scale_factor_current - mDisplay.scale_factor) < .001) program_state++;
         }

      }

converted from program_state level_done_mode and it works in netgame...
some bugs to iron out
make a way for scale factor change to take an exact number of frames to get to the target
done..

made it so that the captain player stays on top...

sometimes I get a double free error and everything crashes
when
after the rocket travel...
it happens when a client completes the game
it happens on all machines

put in some debug printfs now I can't reproduce it



had a different crash
server did 45 but not 6
that is set custom scale factor

made it crash finally...all three machines..double free error on ubuntu
between 4 and 5

       printf("test4\n");
       if (cutscene_background) al_destroy_bitmap(cutscene_background);
       printf("test5\n");

al_destroy_bitmap
void al_destroy_bitmap(ALLEGRO_BITMAP *bitmap)

Destroys the given bitmap, freeing all resources used by it. This function does nothing if the bitmap argument is NULL.

As a convenience, if the calling thread is currently targeting the bitmap then the bitmap will be untargeted first. The new target bitmap is unspecified. (since: 5.0.10, 5.1.6)

Otherwise, it is an error to destroy a bitmap while it (or a sub-bitmap) is the target bitmap of any thread.

changed it so that I dont actually destroy it when I am done
I do this when creating it now:
if (!cutscene_background) cutscene_background = al_create_bitmap(2000, 2000);
seems to be working

need to set players x and yinc to zero in mode 30..done

still sometimes getting stuck in endless loop in custom scale routine...
made some adjustments to that...

I think that the rocket scene is done!!

just fixed the scale changing functions and they are looking very good...


20230523 6:00AM push



the door bug is back
item 12
I moved a door

mItem.item[][6]  color
mItem.item[][7]  move type (0=auto, 1=force instant, 2=force move)
mItem.item[][8]  type (0=exit only, 1=linked dest)
mItem.item[][9]  linked destination item
mItem.item[][10] key held flag
mItem.item[][11] door entry type (0=immed, 1=up, 2=down)
mItem.item[][12] draw lines always, never, only when touched
mItem.item[][13] base animation shape


why do I have base animation shape at 13 and also at 1


448 = static
1083 = in
1084 = out


look at what we have with glt.

item[][1]

I also have 972 and -1
972 is the first shape in the animation sequence

this is all so overly complex

I really want to make it simpler

do everything in draw_door

ditched the old ans bullshit, now use frame nums direct, only works when frame_num incrementing
what if I use timer count? done

now I would like to do away with either 1 or 13


lets kill 1 and see what happens

should not be used...

I only have 3 values for 13:
0
448
1083

My plan is to move these to 1 and change the values

0 same
1 448 old static
2 1083 new ans

I think I have it all done...
lets hope the door bug does not return


I think the bug was color!!

if the color is too big the animation seq will be off
what could make the color too big?


bad!
      // snap these item secondaries to 20
      if ((mouse_on_obj) && (obt == 2) && (!mItem.item_secondary67_hires(mItem.item[num][0])))
      {
         mMiscFnx.mw_round(mItem.item[num][6], 20);
         mMiscFnx.mw_round(mItem.item[num][7], 20);
      }

good?
      if ((mouse_on_obj) && (obt == 2) && (mItem.item_secondary67(mItem.item[num][0])) && (!mItem.item_secondary67_hires(mItem.item[num][0]))) )


I think doors are done...




lift step type 5 wait for trigger
calls bn 520
that calls:
if (mTriggerEvent.get_trigger_item(4, num, type, ti_obj_type, ti_num, ti_sub_type))

then calls:

mItem.set_trigger_event(ti_num, 0, 0, ev, 0); // toggle ON trigger
but i think this is a one off that should use the more generic method
this is the only time this function is called


this is what should be called for both:

void mwTriggerEvent::find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)


bn = 520
num = l
type = s
obt = 4

mWidget.button( xa, ya, xb, bts,  520,l,s,4, 0,c1,15,0,  1,0,1,d); ya+=bts; // lift step wait trigger get event





this is the button in lift:

if (mWidget.buttont(xa, ya, xb, bts, 0,0,0,0,   0,c1,15,0,  1,0,1,d, "Set Trigger")) mTriggerEvent.find_event_sender_for_obj(4, l, s, 0);

am I sending the right args?

void mwTriggerEvent::find_event_sender_for_obj(int obj_type, int obj_num, int obj_ext, int obj_ext2)

this is wrong:
mLift.stp[ti_num][ti_obj_ext].val = ev; // set event number in receiver
should be:
mLift.stp[obj_num][obj_ext].val = ev; // set event number in receiver

I think I've got it...


remove button 520..done
remove:done
//void mwItem::set_trigger_event(int i, int ev0, int ev1, int ev2, int ev3)
//{
//   if (item[i][0] == 6) // orb
//   {
//      item[i][10] = ev0;
//      item[i][11] = ev1;
//      item[i][12] = ev2;
//      item[i][13] = ev3;
//   }
//   if (item[i][0] == 9) // trigger
//   {
//      item[i][11] = ev0;
//      item[i][12] = ev1;
//      item[i][13] = ev2;
//      item[i][14] = ev3;
//   }
//   if (item[i][0] == 13) // timer
//   {
//      item[i][13] = ev0;
//      item[i][15] = ev1;
//   }
//}


cleaned up and made more trigger event stuff look good





20230524

Make new level entry item
type 18 - gate
touching it shows simple data
up enters
down more data

what do I do when entering?
same as warp?

yes...

what next?

show something when touching...

do I want a permanently loaded icon for each level?
each level up to 100
what size?

how about dynamically loaded

what is my persitant data storage going to look like?

achievements struct

char name[200]
char desc[2000]
int level
float complete


level meta struct
int level num
int level name
int par time
int unlocked

int completed
int best time
int fewest deaths
int fewest enemies left alive


add level meta

define struct

done


do the dynamic level showing
make temp

without a bunch of duplicated code:
save player x,y
load level and make bitmap
reload original level

try that..

where will I store the bitmap?

2000x2000 in level

I think all this will not play nicely with netgame

preload icons...

100x100

i need a way to tell if any player is touching the gate

what order do these get called in?
proc
draw
touch


added int marked_gate to player struct and removed one spare int

clear it here just like door
void mwPlayer::proc_player_collisions(int p)
{
   float px = syn[p].x;
   float py = syn[p].y;

   // items
   loc[p].potential_bomb_damage = 0;
   syn[p].marked_door = -1; // so player can touch only one door
   syn[p].marked_gate = -1; // so player can touch only one gate


added set to -1 in init player..

seems to be working good now...

20230525

need to return to overworld map when level done
what about menu? return to overworld?

I need to figure out how these states link together...

overworld

play level

finish level

overworld

how about we are always in overworld


when in menu mode if resume is allowed, also return to overworld is allowed too


I think I am going to have to redo the entire menu thing..

menu-overworld-level

menu can be on top of overworld or specific level


I think I have the whole overworld to level and back thing ok in my mind

but where does the main menu apply to all this

when running a level (not overworld)
esc will pause the level and bring up a menu
one of the options will be to quit the current level and go back to the overworld


I want to have both methods coexisting, at least for the start


what I can do to start for now is have all exits take you back to the overworld

then in the overworld you will be at the gate for the level you just completed

added  int gate_level; to mwLevel
set it when entering gate...
in player set start pos if level 1 look for matching gate...

I am thinking of replacing all warps with gates...only ever used on level 1 anyway


I want to save the level icons bitmaps to disk
why?
to speed up the process of loading them
how long does it take now?

m36   sz:200 lev:100 0.8s
e6430 sz:200 lev:100 2.7s

what is the max size of bitmap I can create

how much do I need?
200x200x100 = 4,000,000
2000x2000 = 4,000,000
not that much apparantly

I am only looking at levels 1-99
right now I am using approx 80 levels of 1-99
should I go to 200?

make a bitmap sz*10, sz*10
add icons in a 10x10 grid and dont care about missing ones

new times:
m36   sz:200 lev:100 0.044s
e6430 sz:200 lev:100 0.114s

make level icon size and last level configurable
no..stick with 200 and 100


what is next?

enforce locked..done
show either: locked, unlocked, or completed


do something at level completed

mark level completed
record best times, etc..

where to detect this:
in exit collision

where to put code for this:
mLevel




OK I am at a crossroads here:
I want to save data everytime a level is completed

how am I going to do this?

a file everytime?
a row in a data structure?


int level
double start_timestamp
int completed;
int timer;
int number_players
int enemies_killed
int enemies_left_alive_at_exit
int player_respawns
int purple_coins_collected


in my new plan is there any need for new game, vs next level?

I will always be in the overworld, level 1, or in another level...

when the game starts, level 1 starts and player is put at current level

esc brings up the menu and pauses the game

without breaking too much implement the level_play_data stuff

when do I enter the first stuff?

I could just do it when a level is completed for now...


make 2 functions:

one when level is started and one when level is complete
add variables to level class to track things happening while level is running

when do I run the start function?

I could do it when level is loaded...done

now patch in code to updated variables as game runs...


   level_data_purple_coins_collected = 0;
   level_data_player_respawns = 0;
   level_data_enemies_killed = 0;


   if (bonus_type == 3) // purple coin!!!
   {
      item[i][0] = 0;
      mPlayer.syn[p].stat_purple_coins++;
      mLevel.level_data_purple_coins_collected++;
      mGameEvent.add(27, 0, 0, p, 0, 0, 0);
   }

      mGameEvent.add(8, 0, 0, p, 0, 0, 0);  // player death
      syn[p].stat_respawns++;
      mLevel.level_data_player_respawns++;

   mGameEvent.add(42, 0, 0, Ei[e][26], e, type, hbm);
   mLevel.level_data_enemies_killed++;


these three were easy to patch in
I think I will have to do something to account for rewind...
otherwise these will be counted on rewind also...
add this test...
if (!mLoop.ff_state)
OK done...

make some test levels

show time with a decimal..done
purple coins as a fraction of max..done

wow, i think the frame work is coming along nicely

do more with play data.. i do nothing yet...

count number of times level has been completed
average time
total time

now should I make it look nicer?

level name
par time
number of purple coins

frame level?

locked, completed indicators?

more info, cycle pages by pressing down?

I think I want the level icon to be displayed below the gate
title, frame, icon

the max char fot title that can fit in the frame with icon size 200 is 24 char


auto set number of purple coins requires each level to be loaded
do it when creating icons

1 - clear data
2 - create icons (and set tot_purple)
3 - save
done:


could I show more icons?

one for completed
one for time
one for all purple coins

401 dude
197 pc
445 time

I want to do min enemy also

how to find that?

for each level, iterate all exits and find least
100 means 0 so do 100-num and find least

done..now what?

pressing down to cycle pages

make a holdoff...done

make more pages

what else can I show?

do something about the locked, complete stuff

draw gates bigger, double size?

overlay small text

I could make the map just one of the screens
yes, that looks great!


number of info screens will change based on whether the level has been completed or not
0 will always be map
in ready mode

add page to locked to tell what has to be done to unlock

add page to run demo mode

make sure demo mode does not save any achivements


I need a function that starts demo mode when only passed integer level num

it wil need to look in savegame/demo and all files there need to be named:
levxxx.gm

like lev002.gm

there are so many transitions between states
it will take a while to sort them out

if I enter demo mode from a gate
I want to go back to the same gate when done...


I am trying to trace where it goes when level done in demo mode

demo mode is just mode 14 then mode 11

level_done mode is the only way out

at the end, ldm forces mode 12 load new level

I missed something...

how does it get back to settings if called from there

mode 12 set new state 2

      if (mPlayer.syn[mPlayer.active_local_player].control_method == 1) // run demo mode saved game file
      {
         mLoop.new_program_state = 2;
         al_rest(1);
         return; // to exit immediately
      }


it doesnt! it continues demo mode

do I need a mode to reset all this?

mode xx
reload overworld level


when getting player start for level 1, force it to be play level
maybe I should have another variable to keep track of the current level in the overworld
did that and it seems to work good

now I need to make it so that demo's don't actually get achievements..done

what next?

this is huge:

make it so that I am in the overworld by default and the menu is called from there

make a new menu..don't kill the old one

I want some nice transitions from overworld to level and back

I will always have a level loaded, tbis will stay the same
menu will pause level and do menu stuff
this sounds so simple

the menu will be different

new game and start level won't make sense


start server
start client
settings
run demo
help
quit

when playing non overworld level
quit to overworld

when in netgame, bringing up the menu will end netgame (same as before)
I could make it so that the menu does not pause the game
then give the client a smaller list of things they can do..

change controls, color, bmsg, viewport

I would like to have a secondary way to store a level in memory
I could really use it for some cool transitions between overworld and levels
I could have a small running level in the overworld
I could use it to dynamically show levels when I touch the gates


just like messages, draw the overworld level icon last


make a new menu

make a global option old_menu



I want to have a program state that lets me know when I am in overworld
state 11 and level 1


classic mode
choose any level all are unlocked
automatically load next level on completion

story mode
start levels from overworld only
levels are locked by default
automatically go to overworld on level complete


add classic_mode to main

save in config
add settings page
also add reset all data there
also add unlock all levels there
done


now make the menu different if !classic mode

in story_mode make start level 1
where? initial setup.
also there setup the level and make it ready to resume


this is actually working pretty good!
overworld and regular menus do the state thing nicely
remove the text at the top of the level map for overworld
done

add more things to story menu's
made demo work

remove all warps...

they are only for hub world anyway


can I automate it?

in hub, move down 40 y+=40;

old warp level item[i][8] 12

new gate item[i][6] 18

new shape?

now get rid of all others

they all have level 1 as the dest?


change them all to exit

do they need to be stationary?
all warps are staionary
3 = 0;


same when exit..

old 12

new 3
new 8 = enemies left, set to 100
3 1022 1 0

I think it is all done...
now more warps...
should i just kill all the rest?
why not? just erase...
they are all gone
now remove in code
done


next?

make sure gate info is on top of everything
how?
I don't want to mess with draw order

I could do it in draw player

don't I already store something there?
marked gate...
moved draw gate info to its own function
now called from draw_player
works good...



next?

now in story mode, when starting game you are in the menu and overworld is loaded in the background
this is how it should be

make settings shortcut for story also
make seeting line up under main title
done


next..

what else can I add to menu 3?
settings??

what is the purpose of menu 3?
to avoid immediately going to overworld when esc is pressed...
A way of pausing...

the only thing different is the option to quit to overworld
what if I wanted to save the level before quitting to overworld?

I think I should have more options there
not demo
not netgame
add settings and help..done

test in netgame

It works amazingly well!
Either player can start a level with gate
Neither can exit to menu or the netgame ends, but that is how it was before also..

level 100, my final level causes a crash
should I make max levels 100?
moved to level 64
still seems to work

also should I only show gate info for active local player?...soft no...

in classic mode, when I exit, go to the next level
done

bug when playing a level then switching to story mode, you get stuck on that level..fixed

OK lets do some more levels

9...
something is missing in the levels that

the first game move entry is missing...

0 0 0 lev

add cheat demo..done


WTF is going on!

I have a bug in ladder climbing

when the player gets stuck climbing and breaks free he warps a lot...

wrong:
syn[p].y = tx; // set x to passed by pos
syn[p].y -= m; // move in y

fixed
syn[p].x = tx; // set x to passed by pos
syn[p].y -= m; // move in y


9 bomb intro same (has ack 8)
10 dead zone demo does not exit nicely (has ack at end)

the level done stuff runs at the end
but times out when it gets to 10s

11 good and evil works, but times out at 13s (has ack)
12 bucket of bad works, times out right away





what happens when you interrupt a demo called from gate?
you can resume, but control is still with file


this control path is confusing and i would like to make it more clear


demo mode is an int that is set when automatically running random levels

it is not set when only running one demo



when a level ends that is played from file, what happens?

how do we detect that the file level has ended
in rungame key check if a cancel key is pressed
in rungame keycheck if 4 sec past last game move
or the level done thing can proceed..

I want a state dedicated to cleaning up after demo mode
move rungame keycheck to demo and rename..done


make a function to clean up after demo mode is done



test all possible changes

make a small collection of simple levels to test with..


run single demo level from gate
-------------------------------
start from state 11

if (mGameMoves.load_gm(msg))
{
   mLoop.new_program_state = 14;
   //old_program state = 3

in mGameMoves.load_gm(msg)

mLevel.play_level = arr[0][3]; // set play level
mDemoMode.demo_mode_last_frame = arr[entry_pos-1][0];






demo mode called from menu story mode
runs and loops good, cancel with key not good



demo mode called from menu classic mode



I want to look at what gets save at the end of a gm file
and if it makes any difference if you let the timer run out or not
I get an acknowledge if I press a key

which levels do that

maybe I could add a game move just to mark when the exit was touched


I am not sure how setting new_program_state 1 works

this is done when leaving ??

this checks to see where it came from
from settings, from demo, from command line

i need to figure this out better


20230601 what am I doing?

am I done with demo mode

do the docs

looking at transitions
make a generic from any to any


start level variables

what about the variables:
start level
play level
overworld level
demo_restore_level
last_level_loaded


where are they all used? and can it be made simpler?

-------------------
mLevel.start_level
-------------------
saved in config

in classic mode:
it is the level shown on the menu
it is the level used when new_game is run

-------------------
mLevel.play_level
-------------------
in classic and story, it is the level currently being played

in mode 12 next level, it is set to the next level to load and play

demo mode uses if for the currently playing demo level
load_gm set it from gm files loaded

----------------------
mLevel.overworld_level
----------------------
saved in config
- set when active local player touches a gate
- used to set player position when starting overworld level

------------------------
mLevel.last_level_loaded
------------------------
used to keep track of the last level loaded (or saved)

-----------------------
mDemoMode.restore_level
-----------------------
used to save original level when running demo so original level can be restored after demo is done


20230601 7:00 AM

I think that demo mode is done...put all demo files back and push

next is to work on transitions

and making overworld look better

should I rename stimp and stamp?

what do I want them to do?


zoom in from an icon to the level playing
and the reverse

void transition_from_map_to_game(int ix, int iy, int iw, int ih);



void transition_from_game_to_map(int ix, int iy, int iw, int ih);






in level editor mode

void mwScreen::get_new_screen_buffer(int type)
is always called with type 3

this means that WX and WY are set by level editor...



change variable names to these in mDisplay

   int level_display_region_x;
   int level_display_region_y;
   int level_display_region_w;
   int level_display_region_h;

   int screen_display_x;
   int screen_display_y;
   int screen_display_w;
   int screen_display_h;


remove old uses of these:
   int level_display_region_x;
   int level_display_region_y;
   int level_display_region_w;
   int level_display_region_h;

they are actually the same...

   mDisplay.level_display_region_x = mDisplay.level_display_region_x;
   mDisplay.level_display_region_y = mDisplay.level_display_region_y;
   mDisplay.level_display_region_w = SW;
   mDisplay.level_display_region_h = SH;


   maybe what I want to do is remove WX, WY

done..

now I have these variables in mDisplay:

mDisplay.level_display_region_x;
mDisplay.level_display_region_y;
mDisplay.level_display_region_w;
mDisplay.level_display_region_h;

mDisplay.screen_display_x;
mDisplay.screen_display_y;
mDisplay.screen_display_w;
mDisplay.screen_display_h;

they are a bit long...

I have a function:
mDisplay.set_screen_display_variables(void);

that sets:
mDisplay.level_display_region_w;
mDisplay.level_display_region_h;

mDisplay.screen_display_x;
mDisplay.screen_display_y;
mDisplay.screen_display_w;
mDisplay.screen_display_h;

and another function:
mDisplay.set_level_display_reqion_xy();
that sets:
mDisplay.level_display_region_x;
mDisplay.level_display_region_y;

replace other calls to this in stimp and stamp:
done:


void mwScreen::set_map_var(void)
{
   // determine menu_map_size and position
   int y_size = mDisplay.SCREEN_H-160;
   int x_size = mDisplay.SCREEN_W-260;
   if (y_size < x_size) mLogo.menu_map_size = y_size;
   else mLogo.menu_map_size = x_size;
   if (mLogo.menu_map_size < 10) mLogo.menu_map_size = 10;
   mLogo.menu_map_x = mDisplay.SCREEN_W/2-(mLogo.menu_map_size/2);
   mLogo.menu_map_y = 140;



I think I have stimp and stamp working and cleaned up nicely...

now where are they all patched in?

stimp
new game
resume
31 demo start


stamp
back to menu
level done demo
level done default

stamp is called when starting demo mode, and it looks bad
that is beacause starting demo mode calls next level to get the first demo level

how to fix..

starting demo mode or starting level play needs to tak into account where it came from

all these transitions need to do that..


so far I have:
menu to game (stimp)
game to menu (stamp)

level done should do something different
not level done, next level...

it is not going back to the menu..
right now I do stamp and stimp

I want it to do a zoom out to nothing in the center then back with the new level

new functions:

void transition_from_menu_to_game();
void transition_from_game_to_menu();
void transition_from_nothing_to_game();
void transition_from_game_to_nothing();

where used:

void transition_from_menu_to_game();
- 10 new game
- 13 resume game

void transition_from_game_to_menu();
- back to menu

void transition_from_menu_to_game();
- 10 new game
- 13 resume game

void transition_from_game_to_nothing();
- 12 next level demo and normal (before new level is loaded)



when cancelling demo, it zooms back in on last loaded level, but that is sometimes off screen??
in mode 32 I am reloaded old level but did not set player positions

how should I handle this?
demo mode cancel and back to menu
game to nothing
restore level
nothing to menu (does not exist)

I already have 4 transition functions, and I am planning on more...
could I make them more generic?

what are my states?
0 - nothing
1 - game
2 - map
3 - gate icon

void transition_cutscene(int initial, int final)
{

}
done...

now I have:

void mwScreen::transition_cutscene(int i, int f, int num_steps, float delay)
where used:

if (program_state == 1) mScreen.transition_cutscene(1, 2, 60, 0.02); // game to menu
- back to menu

mScreen.transition_cutscene(2, 1, 60, 0.02); // menu to game
- 10 new game
- 13 resume game

mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
- 12 common before load


mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game
- 12 normal end after load
- 31 demo setup after load




now make a transition from gate icon to game

mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

it has to be in next level...

I will be in the overworld level
classic mode = 0;

at next level do nothing at start, but after load do

mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

where is the starting player position on the screen
need the x and y
should I save them when exiting?


I have it figured out:

when using gate to start level...

// gate item locatiom
int x = itemf[i][0];
int y = itemf[i][1];

// offset from gate item to level icon
x += (10 - 100);
y += (12 + 35);

// convert to actual screen pos
mScreen.gate_transition_x = (x - mDisplay.level_display_region_x) * mDisplay.scale_factor_current + mDisplay.screen_display_x;
mScreen.gate_transition_y = (y - mDisplay.level_display_region_y) * mDisplay.scale_factor_current + mDisplay.screen_display_y;


when setting up the transition cutscene after new level is loaded
if (i == 3) // gate
{
   fmsi = 200.0 / 2000.0; // level icon size = 200;
   fmxi = gate_transition_x + px * fmsi;
   fmyi = gate_transition_y + py * fmsi;

do i really need the menu when the level is paused?
that is how it is in classic mode...

but in story mode, I can't go back to the overworld without actually leaving the level

how about the menu in ov-lev is just paused, no other changes

disable it for now...optionally to come back


when leaving level in story mode, go right back to overworld instantly

where does this hook in?



I have so much working good now...

I think I will open a new file and document it



20230604

bug - demo mode in story mode different than in classic
look in next level

this was faulty:

if (mMain.classic_mode)          mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
else if (mLevel.play_level != 1) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate

demo mode in story would run gate..

this does not work either:
if ((!mMain.classic_mode) && (mLevel.play_level != 1)) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate
else                                                   mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing

finally this does what I want:
if ((!mMain.classic_mode) && (mLevel.play_level == 1) && (!mDemoMode.demo_mode_on)) mScreen.transition_cutscene(1, 3, 90, 0.01); // game to gate
else                                                                                mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing




I really do have a complicated way of going through program states


I think I would like to do something about old_program_state, older_program_state, etc...

what about an array?

program_state[8]

0 is the new_program_state
1 is the current_program_state
2 is older program state
3 is older....


this covers what I already have, but could do more...

throughout the codebase, just set 0

in void mwLoop::proc_program_state(void)

if 0 != 1

do code for change

slide all down in array

leave it with 0 == 1


int state[8] = {0};

replace all new_program_state with program_state[0]

I have it all the variables changed, now to make it work...

coming along nicely

start demo from command line..fixed
quit demo started from command line..fixed

start level from command line and exit to cmd...done

start level editor from command line and exit to cmd...just works

classic mode tests
-------------------------
start game cutscene good
game to menu cutscene...fixed

demo mode from menu
start...good
next level...good
quit....good
in 32 game to nothing
in 1 nothing to menu
that affected command line demo..fixed

demo mode from settings
seems to work, both random and single

overworld in classic mode
starting level
zooms out of overworld then into new level
quitting level zooms out to menu
this looks OK
overworld was never meany for classic but will still work



story mode tests
----------------
settings demo mode seems to work well
demo mode from menu..looks good

demo mode from overworld..needs work

start level from overworld
calls next level


what happens in next level?

it is complicated
pre load transitions
post load transitions

what should happen?

pre load nothing
post load gate to game
show state array in next level


overworld gate to level..good

level back to overworld

pressing esc or menu key...
instead of adding game move, in single player just sets mLoop.state[0] = 1;

then instead of actually going back to the menu, hijack it to go to the overworld

trap it with a test..done

not sure what else I might have broken with all these changes...


test story demo
make starting transition work..done

ending transition...

11 to 32 does 1 to 0
32 to 10 does 2 to 1
10 to 11 none

fixed 11 to 32
now disable 32 to 10

actually send to 12 instead

















starting the tests over:
args


classic mode
------------

start new
back to menu
demo from menu
demo and single from settings
all good...

overworld level in classic
start new game to overworld
back to menu
resume


start game from gate good

demo start from gate


demo return goes through too many transitions


31 that starts demo mode

called from:

setup

random

gate


I have restore_mode...

kind of like called from


gate demo call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 2;
mDemoMode.restore_level = lev;

gate cheat call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 2;
mDemoMode.restore_level = lev;

args call:
mLoop.state[0] = 31;
mDemoMode.restore_mode = 0;

settings call:
mLoop.state[0] = 30;
mDemoMode.restore_mode = 3;
mDemoMode.restore_level = mLevel.last_level_loaded;

mLoop.state[0] = 31;
mDemoMode.restore_mode = 3;
mDemoMode.restore_level = mLevel.last_level_loaded;


where else do I set 31?

state[0] = 31

demo random:
mLoop.state[0] = 31;

state[0] = 30
if  (top_menu_sel == 9)  { state[0] = 30; mDemoMode.restore_mode = 1; mDemoMode.restore_level = mLevel.start_level;   return; } // demo mode
so what can I use it for?


31 demo mode start is good

demo mode start from gate exit not good


something is wrong with coming back to overworld
do I keep the old icon position?
do I need to get a new one?

to reproduce:

start level from gate
move to scroll
back to overworld

I think I need to use the existing exact position when icon is source, but when it is desination I need to recalc
I will have to store item num...

that did not work


It always seems to go to the right place
but when it comes back, no

where is it coming back from?

next level, pre load transition 1 to 3

I think I will need to save the wx and wy also

that seems to have fixed it...

mScreen.gate_transition_wx = mDisplay.level_display_region_x;
mScreen.gate_transition_wy = mDisplay.level_display_region_y;


in next level

before load

         else if (mMain.classic_mode)
         {
            mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
         }
         else
         {
            mScreen.transition_cutscene(1, 3, 90, 0.01); // game to icon
            game_to_icon = 1;
         }
      }

after load

      if (game_to_icon)
      {
         mDisplay.level_display_region_x = mScreen.gate_transition_wx;
         mDisplay.level_display_region_y = mScreen.gate_transition_wy;
      }
does not work if I change scale, save and restore that also

done...


now back to testing:

story gate demo end, double transistion
only when level done
good when exiting with keypress


finish:
starts 12
12 does preload transition
sent to 32
32 does transition
sent to 12
OMG!! why?

abort:
starts on 32

I could hook into 12 and send to 32 when done...

seems so overly complicated


is there any way to simplify all of this?

manage the complexity

demo mode from menu ends with overworld



------------------------------

greatly improved console logging to follow states

now lets test again

---------------------------------
arg demo with key cancel..good
----------------------------------
---------  Stage change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:0]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31  0  0  0  0  0  --------  [  56]
[State 32 - Quit and Cleanup Demo Dode]  [drm:0]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 11 31  0  0  0  0  --------  [  56]
[State 1 - Game Menu]

---------------------------------
arg demo with level done..good
---------------------------------
---------  Stage change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:0]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  0  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  0  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  0  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:0]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 12 11 31  0  0  0  --------  [ 427]
[State 1 - Game Menu]

---------------------------------
command line int level esc quit..good
---------------------------------
---------  Stage change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  0  0  0  0  0  --------  [  48]
[State 1 - Game Menu]

---------------------------------
command line int level level done...good
---------------------------------
---------  Stage change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  0  0  0  0  0  --------  [ 233]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 10  0  0  0  0
command line exit
---------  Stage change from 12 to  0  --------   0 12 11 10  0  0  0  0  --------  [ 233]






--------------------------
Classic mode tests
--------------------------

start level from menu and quit with esc to menu

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  1  0  0  0  0  --------  [ 140]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 10  1  0  0  0  --------  [ 140]




start level from menu and quit with esc to menu then resume

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 10  1  0  0  0  0  --------  [ 213]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to 13  --------  13  1 11 10  1  0  0  0  --------  [ 213]
transition from menu to game
---------  Stage change from 13 to 11  --------  11 13  1 11 10  1  0  0  --------  [ 213]
---------  Stage change from 11 to  1  --------   1 11 13  1 11 10  1  0  --------  [ 572]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 13  1 11 10  1  --------  [ 572]


start level from menu, then level done, then esc to menu

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 290]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 10  1  0  0  0
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 153]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 11 10  1  0  --------  [ 153]



demo mode from menu

---------  Stage change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:1]
---------  Stage change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:70]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:31
---------  Stage change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:31]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 30  1  0  0  --------  [  91]
[State 12 - Next Level]   [play lev:31]  [next lev:0]
12 12 11 31 12 30  1  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:17
---------  Stage change from 12 to 31  --------  31 12 11 31 12 30  1  0  --------  [  91]
[State 31 - Setup Demo Level]  [lev:17]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 30  1  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 11 31 12 30  --------  [  55]
[State 12 - Next Level]   [play lev:17]  [next lev:0]
12 12 11 31 12 11 31 12
pre-load transition
transition from game to nothing
pass:1 - playing demo level:82
---------  Stage change from 12 to 31  --------  31 12 11 31 12 11 31 12  --------  [  55]
[State 31 - Setup Demo Level]  [lev:82]  [drm:1]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 11 31  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 12 11 31 12 11  --------  [  46]
[State 32 - Quit and Cleanup Demo Dode]  [drm:1]
transition from game to nothing
---------  Stage change from 32 to  1  --------   1 32 11 31 12 11 31 12  --------  [  46]
[State 1 - Game Menu]
transition from nothing to menu
---------  Stage change from  1 to  0  --------   0  1 32 11 31 12 11 31  --------  [  46]




demo mode from settings

when key cancel it zooms to nothing then reloads level, then back to settings
good



---------  Stage change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:3]
---------  Stage change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:70]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:92
---------  Stage change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:92]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31 12 30  1  0  0  --------  [  70]
[State 12 - Next Level]   [play lev:92]  [next lev:0]
12 12 11 31 12 30  1  0
pre-load transition
transition from game to nothing
pass:1 - playing demo level:34
---------  Stage change from 12 to 31  --------  31 12 11 31 12 30  1  0  --------  [  70]
[State 31 - Setup Demo Level]  [lev:34]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31 12 11 31 12 30  1  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 12 11 31 12 30  --------  [  52]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 11 31 12 11 31 12  --------  [  52]
---------  Stage change from  3 to  1  --------   1  3 32 11 31 12 11 31  --------  [  52]
[State 1 - Game Menu]
---------  Stage change from  1 to  0  --------   0  1  3 32 11 31 12 11  --------  [  52]




demo level from settings with key cancel...good

---------  Stage change from  1 to 31  --------  31  1  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  1  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  1  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  1  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 12 11 31  1  0  0  --------  [ 427]
---------  Stage change from  3 to  1  --------   1  3 32 12 11 31  1  0  --------  [ 427]
[State 1 - Game Menu]
---------  Stage change from  1 to  0  --------   0  1  3 32 12 11 31  1  --------  [ 427]



demo level from settings with level done..good

---------  Stage change from  1 to 31  --------  31  1  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:3]
transition from nothing to game
---------  Stage change from 31 to 11  --------  11 31  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 31  1  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:15]
12 12 11 31  1  0  0  0
---------  Stage change from 12 to 32  --------  32 12 11 31  1  0  0  0  --------  [ 427]
[State 32 - Quit and Cleanup Demo Dode]  [drm:3]
transition from game to nothing
---------  Stage change from 32 to  3  --------   3 32 12 11 31  1  0  0  --------  [ 427]
---------  Stage change from  3 to  1  --------   1  3 32 12 11 31  1  0  --------  [ 427]
[State 1 - Game Menu]


overworld in classic mode

start level from gate, then esc pause and resume ...good
---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 272]
[State 12 - Next Level]   [play lev:1]  [next lev:7]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 220]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to 13  --------  13  1 11 12 11 10  1  0  --------  [ 220]
transition from menu to game
---------  Stage change from 13 to 11  --------  11 13  1 11 12 11 10  1  --------  [ 220]
---------  Stage change from 11 to  1  --------   1 11 13  1 11 12 11 10  --------  [ 242]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 13  1 11 12 11  --------  [ 242]



start level from gate, then level done..all good

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [  45]
[State 12 - Next Level]   [play lev:1]  [next lev:70]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  Stage change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 12 11 10  1  0  0  --------  [ 268]
[State 12 - Next Level]   [play lev:70]  [next lev:71]
12 12 11 12 11 10  1  0
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 12 11 10  1  0  --------  [   0]
---------  Stage change from 11 to 12  --------  12 11 12 11 12 11 10  1  --------  [ 327]
[State 12 - Next Level]   [play lev:71]  [next lev:80]
12 12 11 12 11 12 11 10
pre-load transition
transition from game to nothing
post-load transition
transition from nothing to game
---------  Stage change from 12 to 11  --------  11 12 11 12 11 12 11 10  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 11 12 11 12 11  --------  [  22]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 11 12 11 12  --------  [  22]


demo from gate, then quit with esc

does not line up when returning to overworld from level

---------  Stage change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  Stage change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  Stage change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [ 123]
[State 31 - Setup Demo Level]  [lev:71]  [drm:2]
transition from gate to game
---------  Stage change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  Stage change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  89]
[State 32 - Quit and Cleanup Demo Dode]  [drm:2]
transition from game to gate
---------  Stage change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  89]
[State 12 - Next Level]   [play lev:71]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
post-load transition
---------  Stage change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  Stage change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [ 208]
[State 1 - Game Menu]
transition from game to menu
---------  Stage change from  1 to  0  --------   0  1 11 12 32 11 31 11  --------  [ 208]


I thinks this is all part of the same problem I had when returning to gate in single player

I need to find a way to do both

in next level, after the level is loaded, the wx and wx corrwections are made then things line up

i need a way of detecting that we just zoomed in on a gate


bug - change to story mode sometimes freezes game
classic
change start level to > 1
change to story..freezes
fixed by forcing start_level to 1 when setting story mode


I have been doing a lot os tests and all is looking good.


Next to do:

clean up 12 next level

make all debug print statements optional in program state
make sure all is working well..



rename get new screen buffer as it does not use a buffer, it is the display
draw_level_region_to_display get_new_screen_buffer
done...


there is a lot in common with

10 new game
12 next level
31 setup demo mode

see what you can make common

after load level


list them here:





   //---------------------------------------
   // 10 - single player new game
   //---------------------------------------
   if (state[1] == 10)
   {
      printf("[State 10 - New Game]  [lev:%d]\n", mLevel.play_level);


      // load level
      mLevel.set_start_level();





      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 1);            // full reset
         mPlayer.set_player_start_pos(p, 0);   // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;

      mGameMoves.initialize();

      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start

      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      mScreen.transition_cutscene(2, 1, 60, 0.02); // menu to game

      frame_num = 0;
      show_player_join_quit_timer = 0;

      mSound.start_music(0); // rewind and start theme

      mTimeStamp.init_timestamps();

      state[0] = 11;

      // set up mwQuickGraph here
      mQuickGraph[0].initialize(1);
      mQuickGraph[1].initialize(2);


   }



   //---------------------------------------
   // 31 - setup and play demo level
   //---------------------------------------
   if (state[1] == 31)
   {
      int drm = mDemoMode.restore_mode;
      printf("[State 31 - Setup Demo Level]  [lev:%d]  [drm:%d]\n", mLevel.play_level, drm);

      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = 1;
         return;
      }


      // reset players
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 1);           // full reset (start modes 1, 2, 3, 9)
         mPlayer.set_player_start_pos(p, 0);  // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;
      mPlayer.syn[0].control_method = 1; // rungame demo mode



      frame_num = 0;
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      show_player_join_quit_timer = 0;
      mSound.start_music(0); // rewind and start theme

      if (drm == 0) mScreen.transition_cutscene(0, 1, 90, 0.01); // args (nothing to game)
      if (drm == 1) mScreen.transition_cutscene(0, 1, 90, 0.01); // demo mode random (nothing to game)
      if (drm == 2) mScreen.transition_cutscene(3, 1, 120, 0.02); // gate (gate to game)
      if (drm == 3) mScreen.transition_cutscene(0, 1, 90, 0.01); // settings (nothing to game)

      mTimeStamp.init_timestamps();
      state[0] = 11;
   }



   //---------------------------------------
   // 12 - level done (more accurately load next level)
   //---------------------------------------
   if (state[1] == 12)
   {
      printf("[State 12 - Next Level]   [play lev:%d]  [next lev:%d]\n", mLevel.play_level, mPlayer.syn[0].level_done_next_level);

      for (int i=0; i<8; i++) printf("%2d ", state[i]);
      printf("\n");

      // if demo level just ended to get here, immediately send to 32
      if ((state[3] == 31) && (!mDemoMode.demo_mode_on)) // demo level just completed
      {
         state[0] = 32; // demo mode cleanup and exit
         return; // to exit immediately
      }

      if ((state[3] == 10) && (state[4] == 0)) // normal play level started from command line
      {
         printf("command line exit\n");
         state[0] = 0; // exit to dos
         return; // to exit immediately
      }

      mSound.stop_sound();

      mPlayer.syn[0].level_done_mode = 0;

      if (mLog.LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", mPlayer.syn[0].level_done_next_level); mLog.add_log_entry_header(10, 0, msg, 3); }



      // -------------------------------
      // pre load transition
      // -------------------------------

      printf("pre-load transition\n");

      int gate_to_game = 0;
      int game_to_gate = 0;


      // if going to overworld from anything except menu, set game to gate
      if ((mPlayer.syn[0].level_done_next_level == 1) && (state[2] != 1))
      {
         game_to_gate = 1;
         printf("1game to gate set\n");
      }



      // did we just come from 32?
      if (state[2] == 32) // demo mode just ended
      {

      }
      else
      {
         // if going from overworld to any other level, assume gate is used...no transition until after load
         if ((mLevel.play_level == 1) && (mPlayer.syn[0].level_done_next_level != 1)) gate_to_game = 1;

         else if (mMain.classic_mode)
         {
            mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
         }
         else
         {
            mScreen.transition_cutscene(1, 3, 90, 0.01); // game to icon
            game_to_gate = 1;
            printf("2game to gate set\n");
         }
      }







      // if we get here in demo mode, either initially or after level done
      // call mDemoMode.load_random_demo() to load game moves for next demo level
      // this needs to be after the cutscene transitions
      if (mDemoMode.demo_mode_on)
      {
         mDemoMode.load_random_demo();
         return; // to exit immediately
      }







      if ((mLog.LOG_NET) && (mNetgame.ima_client)) mLog.log_ending_stats(mPlayer.active_local_player);
      if ((mLog.LOG_NET) && (mNetgame.ima_server)) mLog.log_ending_stats_server();

      if (mNetgame.ima_server) mNetgame.server_flush();
      if (mNetgame.ima_client) mNetgame.client_flush();

      mGameMoves.blind_save_game_moves(1);

      if (mLog.autosave_log_on_level_done) mLog.save_log_file();

      mLevel.play_level = mPlayer.syn[0].level_done_next_level;


//      if ((mNetgame.ima_client) || (mNetgame.ima_server))
//         for (int p=0; p<NUM_PLAYERS; p++)
//         {
//            // free all the used clients, so they can be re-assigned on the next level
//            // if (mPlayer.syn[p].control_method == 9) mPlayer.syn[p].control_method = 0;
//            // set all clients inactive on server and client, to force them to re-chase and lock on the new level
//            // if ((mPlayer.syn[p].control_method == 2) || (mPlayer.syn[p].control_method == 4)) mPlayer.syn[p].active = 0;
//         }



      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = 1;
         return;
      }



      // reset players
      for (int p=0; p<NUM_PLAYERS; p++)
      {
         mPlayer.init_player(p, 2);            // next level reset
         mPlayer.set_player_start_pos(p, 0);   // get starting position for all players, active or not
      }
      mPlayer.syn[0].active = 1;



      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start



      frame_num = 0;
      mNetgame.reset_states();
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      if (mNetgame.ima_server) // set server initial state (for both 2-new game and 5-level done when server)
      {
         mPlayer.syn[0].control_method = 3;

         mNetgame.game_vars_to_state(mNetgame.srv_client_state[0][1]);
         mNetgame.srv_client_state_frame_num[0][1] = frame_num;

         if (mLog.LOG_NET_stdf)
         {
            //   printf("saved server state[1]:%d\n\n", frame_num);
            sprintf(msg, "stdf saved server state[1]:%d\n", frame_num);
            mLog.add_log_entry2(27, 0, msg);
         }
      }

      // save colors in game moves array
      for (int p=0; p<NUM_PLAYERS; p++)
         if (mPlayer.syn[p].active) mGameMoves.add_game_move(0, 1, p, mPlayer.syn[p].color); // [01] player_state and color

      if (mLog.LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", mLevel.play_level);
         mLog.add_log_entry_header(10, 0, msg, 3);
      }

      // reset the viewport so the cutscene lines up
      if (game_to_gate)
      {
         mDisplay.level_display_region_x = mScreen.gate_transition_wx;
         mDisplay.level_display_region_y = mScreen.gate_transition_wy;
         mDisplay.set_scale_factor(mScreen.gate_transition_scale, 1);
      }

      printf("post-load transition\n");

      if (gate_to_game) mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game

      // not just come from 32 and classic and not gate to game

      else if ((state[2] != 32) && (mMain.classic_mode)) mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game


//            // did we just come from 32?
//      if (state[2] == 32) // demo mode just ended
//      {
//
//      }
//      else
//      {
//         if (gate_to_game) mScreen.transition_cutscene(3, 1, 90, 0.01); // gate to game
//         else
//         {
//            if (mMain.classic_mode) mScreen.transition_cutscene(0, 1, 90, 0.01); // nothing to game
//         }
//
//      }

      show_player_join_quit_timer = 0;
      mSound.start_music(0); // rewind and start theme
      mTimeStamp.init_timestamps();
      state[0] = 11;
   }



10

      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start

      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mInput.initialize();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;






12
      mGameMoves.initialize();
      mGameMoves.add_game_move(0, 0, 0, mLevel.play_level);       // [00] game_start
      mNetgame.reset_states();


      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mShot.clear_shots();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;



31

      mInput.initialize();
      mBottomMessage.initialize();
      mTriggerEvent.initialize();
      mShot.clear_shots();
      frame_num = 0;
      show_player_join_quit_timer = 0;
      mTimeStamp.init_timestamps();
      mSound.start_music(0); // rewind and start theme
      state[0] = 11;

that looks a little more simplified

still need to straighten out next level transitions....
they are very ugly....


20230605 12:15 AM push







bug - story gate demo end transition does not line up
story gate level start transitions work good
actually they both work, but not the first time..fixed




bug - story menu demo mode ends with overworld instead of menu

---------  State change from  1 to 30  --------  30  1  0  0  0  0  0  0  --------  [   0]
[State 30 - Start Demo Mode]  [drm:1]
---------  State change from 30 to 12  --------  12 30  1  0  0  0  0  0  --------  [   0]
[State 12 - Next Level]   [play lev:1]  [next lev:0]
12 12 30  1  0  0  0  0
pre-load transition
pass:1 - playing demo level:86
---------  State change from 12 to 31  --------  31 12 30  1  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:86]  [drm:1]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12 30  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 12 30  1  0  0  --------  [  60]
[State 32 - Quit and Cleanup Demo Dode]  [drm:1]
transition from game to nothing
---------  State change from 32 to  1  --------   1 32 11 31 12 30  1  0  --------  [  60]
[State 1 - Game Menu]
[State 12 - Next Level]   [play lev:86]  [next lev:1]
12 12 32 11 31 12 30  1
pre-load transition
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 12 30  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 12 30  --------  [ 110]
[State 1 - Game Menu]
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12 32 11 31 12  --------  [ 110]



when going to game menu I need a way to know where I came from


in 32 what my drm is 1


I think I need more drm

current:
0 called from args
1 random
2 gate
3 setting

new

10 called from args single
21 menu random
31 settings single
32 settings random
42 gate single





also demo_mode
current
0 off
1 on

new
0 off
1 single
2 random

implement this

do all the drm

both args:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 10;
mLoop.state[0] = 31;

both menu calls:
mDemoMode.mode = 2;
mDemoMode.restore_mode = 21;
mDemoMode.restore_level = mLevel.start_level;
state[0] = 12;

settings single:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 31;
mDemoMode.restore_level = mLevel.last_level_loaded;
mLoop.state[0] = 31;

settings random:
mDemoMode.mode = 2;
mDemoMode.restore_mode = 32;
mDemoMode.restore_level = mLevel.last_level_loaded;
mLoop.state[0] = 12;

gate single:
mDemoMode.mode = 1;
mDemoMode.restore_mode = 42;
mDemoMode.restore_level = lev;
mLoop.state[0] = 31;


those are all done...

now look at all mode refs
removed this line:

do I even need mode 30, all it does is go directly to 12

   //---------------------------------------
   // 30 - start demo mode
   //---------------------------------------
   if (state[1] == 30)
   {
      if (debug_print_state_names) printf("[State 30 - Start Demo Mode]  [drm:%d]\n", mDemoMode.restore_mode);
      //mDemoMode.mode = 1;
      state[0] = 12;
   }

removed it and modified all calls to 30 to now go to 12


looked at all mode refs


now look at all drm refs






// maybe it would be better to list all the places we could jump to from here
// no change - menu
// settings
// overworld
// exit immed

// then list conditions for each

/*

in state 11 there are 2 ways out:
esc
level done
are there any other ways?


could I setup variables to register what happens then?

before starting 11 set:
quit_action
done_action

quit_action
0 quit program
1 menu
2 overworld
3 settings


done_action
0 quit program
1 menu
2 overworld
3 settings
4 next inc level
5 next rand level


I could be on to something here.....

where would I store these variables
mLoop.quit_action
mLoop.done_action


where are all the places I would set these?

command line

2 x
mLoop.state[0] = 31;
mLoop.quit_action = 0;
mLoop.done_action = 0;

1 x
mLoop.state[0] = 10;
mLoop.quit_action = 0;
mLoop.done_action = 0;


classic menu

if (top_menu_sel == 3) // start new game
{
   state[0] = 10;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 4; // next inc level
   top_menu_sel = 4;
   return;
}

if (top_menu_sel == 9) // demo mode
{
   mDemoMode.mode = 2;
   mDemoMode.restore_mode = 21;
   mDemoMode.restore_level = mLevel.start_level;
   state[0] = 12;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 5; // next rand level
   return;
}


story menu

if (top_menu_sel == 2) // start new game
{
   state[0] = 10;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 2; // overworld
   return;
}

if (top_menu_sel == 6) // demo mode
{
   mDemoMode.mode = 2;
   mDemoMode.restore_mode = 21;
   mDemoMode.restore_level = mLevel.start_level;
   state[0] = 12;
   mLoop.quit_action = 1; // menu
   mLoop.done_action = 5; // next rand level
   return;
}


do some testing....

some stuff is working great

ov to game and back




20230607

---------------------
command line demo
---------------------
quit works perfectly
done works perfectly

---------  State change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:10]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31  0  0  0  0  0  --------  [  48]
[State 32 - Quit and Cleanup Demo Mode]  [drm:10]  [m:1]
transition from game to nothing
---------  State change from 32 to  0  --------   0 32 11 31  0  0  0  0  --------  [  48]


---------  State change from  0 to 31  --------  31  0  0  0  0  0  0  0  --------  [   0]
[State 31 - Setup Demo Level]  [lev:14]  [drm:10]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 31  0  0  0  0  0  --------  [ 427]
[State 12 - Next Level]   [play lev:14]  [next lev:1]
12 12 11 31  0  0  0  0
command line exit
transition from game to nothing
---------  State change from 12 to  0  --------   0 12 11 31  0  0  0  0  --------  [ 427]



----------------------
command line lev start
----------------------
first transition good
quit works perfectly
done works perfectly


---------  State change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from nothing to game
---------  State change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 10  0  0  0  0  0  --------  [  45]
[State 1 - Game Menu] - done_action:0
transition from game to nothing

---------  State change from  0 to 10  --------  10  0  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:70]
transition from nothing to game
---------  State change from 10 to 11  --------  11 10  0  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 10  0  0  0  0  0  --------  [ 242]
[State 12 - Next Level]   [play lev:70]  [next lev:1]
12 12 11 10  0  0  0  0
command line exit
transition from game to nothing
---------  State change from 12 to  0  --------   0 12 11 10  0  0  0  0  --------  [ 242]




----------------------
story mode start new game
start level with gate
quit to overworld
quit to menu
quit program
----------------------
works good

---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 146]
[State 12 - Next Level]   [play lev:1]  [next lev:5]
12 12 11 10  1  0  0  0
pre-load transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [  83]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [  83]
[State 12 - Next Level]   [play lev:5]  [next lev:1]
12 12  1 11 12 11 10  1
pre-load transition
transition from game to gate
2game to gate set
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 11 10  --------  [  40]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 11  --------  [  40]



----------------------
story mode start new game
start level with gate
next level to overworld
----------------------
works good

----------------------
story mode demo from menu
----------------------
works good



quitting demo mode to menu
first 32 goes from nothing to menu
then 1 goes from game to menu

stop 1 from doing that...
set quit_action to 99 in 32


bug, after demo mode starting single player in story starts last loaded level then freezes...
fixed by forcing
if (!mMain.classic_mode) mLevel.start_level = mLevel.play_level = 1;
in 10 new game




----------------------
story mode demo from gate
----------------------
end transition not right

goes back to gate twice?


System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [  94]
[State 31 - Setup Demo Level]  [lev:3]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  68]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  68]
[State 12 - Next Level]   [play lev:3]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [  42]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 32 11 31 11  --------  [  42]
[State 12 - Next Level]   [play lev:1]  [next lev:1]
12 12  1 11 12 32 11 31
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 32 11 31  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 32 11  --------  [  39]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 32  --------  [  39]

C:\pm>

added extra text to next level preload transition:

      if ((!gate_to_game) && (!classic_next_level) && (!mMain.classic_mode) && (!mDemoMode.mode) && (state[2] != 32))



when going back:
it goes back to overworld twice


System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [  45]
[State 31 - Setup Demo Level]  [lev:4]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  30]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  30]
[State 12 - Next Level]   [play lev:4]  [next lev:1]
12 12 32 11 31 11 10  1
pre-load transition
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [  42]
[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 32 11 31 11  --------  [  42]
[State 12 - Next Level]   [play lev:1]  [next lev:1]
12 12  1 11 12 32 11 31
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 32 11 31  --------  [   0]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 32 11  --------  [  45]
[State 1 - Game Menu] - done_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 32  --------  [  45]

C:\pm>


32 dr2 42

42 means return to overworld

set a done action there

done_action 2 = overworld

then in 12...

it starts overworld...good so far


---------------

- I am in overworld
- start demo level

         mDemoMode.mode = 1;
         mDemoMode.restore_mode = 42;
         mDemoMode.restore_level = lev;
         mLoop.state[0] = 31;
         mLoop.quit_action = 2;
         mLoop.done_action = 2;
31
quit demo level
32
transition from game to gate
12
no transitions
load level 1 (overworld)
11 start level 1

11 quit to 1

[State 1 - Game Menu] - done_action:2
instead of menu, go to overworld


in the first 12 change quit_action to 1


      if (quit_action == 2) // overworld
      {
         quit_action = 1;
         if (debug_print_more) printf("change quit_action from 2 to 1\n");
      }


this is working, but is getting very complex...

I am not making much use of done_action...

next bug...after gate demo..play the level..then exit freezes...

it is because level is not being set back to overworld

the last bit of code to fix the last bug broke this...


I have again run out of time...

what to fix next?


moved it to here and now both cases work...

      if (rm == 42) // started from gate, send to overworld with next level and level 1
      {
         mScreen.transition_cutscene(1, 3, 120, 0.02); // game to gate
         mPlayer.syn[0].level_done_next_level = 1;
         state[0] = 12;

         quit_action = 1;
         if (debug_print_more) printf("changed quit_action to 1\n");
      }

it looks like most things in story mode work


story mode setting exit exits program...fixed



demo mode from settings works

demo single from settings esc quit stuck in 32 drm31 m0

change drm from 31 to 32 in setting start single demo...

now seems to work...


so does all stuff in settings work?
story mode demo setting all seems to work

what about starting single, server, and client games from settings??

lets look at single
what do we want it to do?
come back to settings after level done or exit



---------  State change from  1 to  3  --------   3  1  0  0  0  0  0  0  --------  [   0]
---------  State change from  3 to 10  --------  10  3  1  0  0  0  0  0  --------  [   0]
[State 10 - New Game]  [lev:1]
---------  State change from 10 to 11  --------  11 10  3  1  0  0  0  0  --------  [   0]
---------  State change from 11 to  1  --------   1 11 10  3  1  0  0  0  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1 11 10  3  1  0  0  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1 11 10  3  1  0  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1 11 10  3  1  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1  3  1 11 10  3  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1 11 10  --------  [  91]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1 11  --------  [  91]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [  91]



lets look at classic mode

first fix the classic mode menu


start new game good
resume good
quitting from resume quits program..fixed

demo mode menu start
next level
exit with keypress
exit with level done
all good



settings demo mode
12 pre load transition




bug - in all mouse button click on widgets things
click on button
dont move move
cant click again on button unless mouse if moved

for example:

settings
press play demo level button
quit with esc
can't press again unless mouse is moved slightly

I still get the events mouse down and up


what is happening is the mouse x and y are getting changed
it all works fine in text_double 1 but not anything else..


in mInput.initialize

I get the initial mouse positions, but don't scale them...fixed

   ALLEGRO_MOUSE_STATE state;
   al_get_mouse_state(&state);
   mouse_x = state.x / mDisplay.display_transform_double;
   mouse_y = state.y / mDisplay.display_transform_double;
   mouse_z = state.z / mDisplay.display_transform_double;



settings demo single
no transition

show dif from demo rnd start to demo single start

demo single start:
31 - 11 - 32

demo rnd start
12 - 31 - 11 - 12 - 11 - 32


for demo rnd I am doing the transition in 12

for single it never passes through 12

they both pass through 31...

but after the load...so that doesnt help

or does it?
I am trying to do the post load transition


back to settings demo single preload transition...


I could hook into it in 31...

do I even care?

rand does a zoom from nothing, I want to do the same

it was already there for demo_mode ==2, I just hijacked it to do 1 also

hope this doesn't affect single demo called from gate....

test..it does...
add a test so it doesn't

actually simplified that a lot, now only 2 choices:

      if (mDemoMode.restore_mode == 42) mScreen.transition_cutscene(3, 1, 120, 0.02); // gate (gate to game)
      else                              mScreen.transition_cutscene(0, 1, 90, 0.01);  // all other (nothing to game)


back to testing...

demo mode from settings:
good in both classic and story

args still work?
yes for demo
yes for single level

story mode:
good:

classic mode:
good



advanced:
overworld in classic mode
starting level from gate works
when quitting level goes back to overworld
when completing level, goes to next level, not overworld
when exiting from that level goes back to overworld

classic mode with any level other than overworld
start level and exit to menu with resume
finish level take you to next level
nothing changes start level, except manually changing it

demo from overworld has extra transitions at end


---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 31  --------  31 11 10  1  0  0  0  0  --------  [ 269]  --------   [qa:2] [da:2]
[State 31 - Setup Demo Level]  [lev:70]  [drm:42]
transition from gate to game
---------  State change from 31 to 11  --------  11 31 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to 32  --------  32 11 31 11 10  1  0  0  --------  [  36]  --------   [qa:2] [da:2]
[State 32 - Quit and Cleanup Demo Mode]  [drm:42]  [m:1]
transition from game to gate
changed quit_action to 1

---------  State change from 32 to 12  --------  12 32 11 31 11 10  1  0  --------  [  36]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:70]  [next lev:1] [qa:1] [da:2]
12 12 32 11 31 11 10  1
pre-load transition
game to nothing for classic next level
transition from game to nothing
post-load transition
---------  State change from 12 to 11  --------  11 12 32 11 31 11 10  1  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to  1  --------   1 11 12 32 11 31 11 10  --------  [ 390]  --------   [qa:1] [da:2]
[State 1 - Game Menu] - quit_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12 32 11 31 11  --------  [ 390]  --------   [qa:0] [da



added another exception

// -----------------------------------------------------------------------------------------------------
// classic mode and not gate_to_game and not in demo mode
// zoom to nothing before loading next level
// make an exception to not do this if returning to 1 (like when demo ends)
// (mPlayer.syn[0].level_done_next_level != 1))

// -----------------------------------------------------------------------------------------------------
      int classic_next_level = 0;
      if ((!gate_to_game) && (mMain.classic_mode) && (!mDemoMode.mode) && (mPlayer.syn[0].level_done_next_level != 1))
      {
         if (debug_print_more) printf("game to nothing for classic next level\n");
         classic_next_level = 1;
         mScreen.transition_cutscene(1, 0, 90, 0.01); // game to nothing
      }

now it looks good

what else is there to test?


game start from settings?
cannot exit after...


---------  State change from  1 to  3  --------   3  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:0]
---------  State change from  3 to 10  --------  10  3  1  0  0  0  0  0  --------  [   0]  --------   [qa:3] [da:3]
[State 10 - New Game]  [lev:70]  [qa:3] [da:3]
---------  State change from 10 to 11  --------  11 10  3  1  0  0  0  0  --------  [   0]  --------   [qa:3] [da:3]
---------  State change from 11 to  1  --------   1 11 10  3  1  0  0  0  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1 11 10  3  1  0  0  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1 11 10  3  1  0  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1 11 10  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1 11 10  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1 11 10  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1 11  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3
instead of menu, go to settings
---------  State change from  1 to  3  --------   3  1  3  1  3  1  3  1  --------  [ 102]  --------   [qa:3] [da:3]
---------  State change from  3 to  1  --------   1  3  1  3  1  3  1  3  --------  [ 102]  --------   [qa:3] [da:3]
[State 1 - Game Menu] - quit_action:3


added test to settings for esc pressed on entry to wait for release

single player start from setting works
in classic mode, uses start level, same with story only start level is always 1 in story mode...


I think I have all the transitions working...


netgame has not been tested...
for netgame, we never leave a running game...always in mode 11 or 12...

I want to make the timing something I can change in settings



bug - in menu mouse, when mouse is on menu, keys do not work
even if mouse times out...

added this and now works like it should

if ((mInput.mouse_x > mix1) && (mInput.mouse_x < mix2) && (mInput.mouse_y > miy1) && (mInput.mouse_y < miy2) && (!al_get_timer_count(mEventQueue.mou_timer)))



I have a bad transition return to level 1 in classic mode

classic mode
when on lev 1 can start levels just like in story mode
when exiting go back to level 1

when completing go to next level

but do not change start level unless changed on menu


Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 205]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:3] [qa:2] [da:2]
12 12 11 10  1  0  0  0
pre-load transition
set gate_to_game for post transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [ 198]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [ 198]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:3]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
pre-load transition
post-load transition
not state[2]=32 and classic
transition from nothing to game
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]



this is what it should be (story mode)


1  3  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:0]
[State 1 - Game Menu] - quit_action:1
---------  State change from  1 to 10  --------  10  1  3  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:2]
[State 10 - New Game]  [lev:1]  [qa:1] [da:2]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  3  1  0  0  0  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to 12  --------  12 11 10  1  3  1  0  0  --------  [  84]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:3] [qa:2] [da:2]
12 12 11 10  1  3  1  0
pre-load transition
set gate_to_game for post transition
post-load transition
transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  3  1  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  3  1  --------  [  39]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  3  --------  [  39]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:3]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
pre-load transition
game to gate for next level to overworld
transition from game to gate
post-load transition
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]












fix the next level cases:

how many cases are there?

- classic mode gate demo end
- story mode gate demo end

these should be the same

pre: game to gate
post: none

also story mode level done that returns to overworld
also classic mode level done that returns to overworld

all these cases come from a level to overworld


what other cases are not like this?

demo random next level
classic next inc level

these should both be:
pre: game to nothing
post: nothing to game



I think I have simplified that a lot...now test:

start new game in classic mode, force play level to be start level..done


demo mode from menu...


---------  State change from  1 to 12  --------  12  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 12 - Next Level]  [play lev:71]  [next lev:0] [qa:1] [da:5]
12 12  1  0  0  0  0  0
Level to level (no overworld)

pre-load transition:game to nothing
post-load transition:nothing to game

transition from game to nothing
---------  State change from 12 to 31  --------  31 12  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
[State 31 - Setup Demo Level]  [lev:70]  [drm:21]
transition from nothing to game
---------  State change from 31 to 11  --------  11 31 12  1  0  0  0  0  --------  [   0]  --------   [qa:1] [da:5]
---------  State change from 11 to 32  --------  32 11 31 12  1  0  0  0  --------  [  43]  --------   [qa:1] [da:5]
[State 32 - Quit and Cleanup Demo Mode]  [drm:21]  [m:2]
transition from game to nothing
transition from nothing to menu
---------  State change from 32 to  1  --------   1 32 11 31 12  1  0  0  --------  [  43]  --------   [qa:99] [da:5]
[State 1 - Game Menu] - quit_action:99
---------  State change from  1 to  0  --------   0  1

found a new case for 12...menu to demo
menu to nothing then nothing to game

test more...

make a common place for transition speed and length...

it needs to be saved in config...

done...now change all call to transtion...done




test thoroughly....

args..

bug? if in story mode, starting lev from command line starts overworld...
I think I will just leave it like this


args story mode demo good

classic mode start lev from commnad line sets start level...



bug classic mode start level from gate
return transition wrong


---------  State change from  1 to 10  --------  10  1  0  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
[State 10 - New Game]  [lev:1]  [qa:1] [da:1]
transition from menu to game
---------  State change from 10 to 11  --------  11 10  1  0  0  0  0  0  --------  [   0]  --------   [qa:1] [da:1]
---------  State change from 11 to 12  --------  12 11 10  1  0  0  0  0  --------  [ 101]  --------   [qa:2] [da:2]
[State 12 - Next Level]  [play lev:1]  [next lev:2] [qa:2] [da:2]
12 12 11 10  1  0  0  0
Next level from overworld

pre-load transition:none
post-load transition:gate to game

transition from gate to game
---------  State change from 12 to 11  --------  11 12 11 10  1  0  0  0  --------  [   0]  --------   [qa:2] [da:2]
---------  State change from 11 to  1  --------   1 11 12 11 10  1  0  0  --------  [  44]  --------   [qa:2] [da:2]
[State 1 - Game Menu] - quit_action:2
instead of menu, go to overworld
---------  State change from  1 to 12  --------  12  1 11 12 11 10  1  0  --------  [  44]  --------   [qa:1] [da:2]
[State 12 - Next Level]  [play lev:2]  [next lev:1] [qa:1] [da:2]
12 12  1 11 12 11 10  1
Next level to overworld
Demo mode started from menu

pre-load transition:menu to nothing
post-load transition:none

transition from menu to nothing
---------  State change from 12 to 11  --------  11 12  1 11 12 11 10  1  --------  [   0]  --------   [qa:1] [da:2]
---------  State change from 11 to  1  --------   1 11 12  1 11 12 11 10  --------  [  61]  --------   [qa:1] [da:2]
[State 1 - Game Menu] - quit_action:1
transition from game to menu
---------  State change from  1 to  0  --------   0  1 11 12  1 11 12 11  --------  [  61]  --------   [qa:0] [da:2]



the problem is, 2 things matched in 12:
Next level to overworld
Demo mode started from menu

only the first should have matched

quiting back to over world from level passes through menu (1) so it thinks its demo mode started from menu

added test and fixed

// -----------------------------------------------------------------------------------------------------
// previous state == 1, called here from menu
// the only time this happens is when starting demo mode from menu
// -----------------------------------------------------------------------------------------------------
      if ((state[2] == 1) && (mDemoMode.mode == 2))

just a quick check but I think all classic and story is working




20230610

make it so that I can continue on from a demo
press a key and now I am playing
erase all game moves after current, change control method..


it works!

use it to fix lev 12
cut in about 390s
get last coin

done demos for up to level 35




when ! is in lift name it shows up as = and !, nowhere else...

font is pr8

I use that everywhere
there is actually something wrong with that font

rebuilt it with //   mFont.convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
and now it is good

bug - level editor, then play game instantly, then exit...program quits..fixed

make the time in the upper frame do m:ss when > 60s..done



can I make all my gates show the number, name, and small icon






I am thinking about removing the enemies left achievemnet and the level done icon

then I would only have the purple coin and time achivements

I can show if completed some other way..



if a level becomes complete by cheating, unlock it..done


make a group of the first 8 levels on a platform...


unlock all training levels by default


make some more level icons
I want a way to load and draw a level with interrupting the level in progress

duplicate the data structures?

make the draw routine use either?

what do I really need?

blocks
items
enemies
lifts
i can fake players if I need to..

this will also make ft easier...maybe

because they are a class, could I just add another instance
or another array to the exiting instance

start with level



or I could store the full 2000x2000 for each level to make scaled drawing nicer....
this would not work, as I only draw to the level background not screen

just make some different sized icons


advanced enemy info levels:
90-95
center levels...done
titles..done
purple coins..done



bug - spelling error in selection buttons..fixed

bug - crash when move top row in overworld
find out what is causing it
it is in draw_items
fixed for door, now do custon in es_draw_item

bug - edit text for msg can not see cursor
it is because I manually edited 127 in the font bitmap
fixed..open in gimp and draw a line at the bottom of 127...


bug - archwagon arrows do no damage
dammnit I will have to redo lots of demo's!!!
fixed

remove free man from PDE..done

bug - 2 way door creator has one door invisible..fixed

bug - lone door creator causes crash..fixed


15 smash demo is broken falls through lift
level 15 'could not find move step'
fixed

index = 0;

demo mode does not do pass 2
fixed a bug I introduced when trying to nor choose overworld level as demo
confused index with level, renamed to avoid future confusion


101
972
1

11-1
12-1




               mItem.item[c][0] = 1;    // type 1
               mItem.item[c][1] = 2;    // draw type
               mItem.item[c][3] = 0;    // stationary
               mItem.item[c][6] = 13;   // default color = lt blue
               mItem.item[c][8] = 1;    // type: linked exit
               mItem.item[c][11] = 0;   // enter immed
               mItem.item[c][12] = 1;   // always draw line

               if (mMiscFnx.getxy("Destination Door", 2, 1, d) == 1)
               {
                  mItem.item[c][9] = d;  // linked exit

                  mItem.item[d][0] = 1;  // type 1
                  mItem.item[d][1] = 2;  // draw type
                  mItem.item[d][3] = 0;  // stationary
                  mItem.item[d][6] = 13; // default color = lt blue
                  mItem.item[d][8] = 0;  // type: exit only


PDE uses 1 to show tile...
could use creator for this too...


do it...

210
211

209 single door item

bug level editor someimes draws status and selection windows on level buffer instead of screen
I think when drawing blocks in that mode it calls init_level_background and this changes the target bitmap
I explicitly set it back to the backbuffer after and it seems fixed


add the rest of the levels

I have all levels done except 64

it needs some work..

make the rocket npc platforms match npc color


can I make npc crew smaller and call them children?

I can but the scaling looks bad..
I wish I could draw them directly on the screen

I have it working!!

make scale adjust Ef[][8]

I have the npc scale looking great

now I can call them children!!

nice!!

level 64 is done and I have demo for it..
what happens after final cutscene?
level done called??

all good...


now what?

test with multiplayer

set up locked zones and groups


20230614 push























































































































































































































































































































































































































