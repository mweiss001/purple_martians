20221228

New running log of changes to the project...

The old one was over 40,000 lines and 1M char...


do a line count:

24525 code only
8006 empty
4979 comment
4557 code and comment
----------------
42067 total


where do I use proc_controllers?
108 matches

not in client anymore since I removed the blocking...

client does not exit when connection fails...fixed first part...

now what about waiting for initial state from server?

break it on the server and test how client responds

did it not used to say waiting for server in a few places?


I have made a nice way to quit while waiting for initial state....

I should make all the ways to exit from client go to a state that cleans up....i think I did...

client still will not rejoin until program is restarted....fixed...it was a strange issue with packetpos needing to be reset to 0


later make sure that server cleans up at exit like client, and try to restart....

also make sure that TCP still works...



Now I think I am finally ready to try some fast ping packets


OK I have the packet passing...what should I do about it?


when server receives pong do some timing

ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   1.2 ms
ping time:   1.6 ms
ping time:   1.6 ms
ping time:   0.5 ms
ping time:   1.3 ms
ping time:   0.9 ms
ping time:   1.1 ms
ping time:   1.5 ms
ping time:   1.0 ms
ping time:   1.5 ms
ping time:   0.7 ms
ping time:   0.6 ms
ping time:   0.6 ms

this is round trip UDP on LAN

switching to WAN


96.45.15.187


I am going to send the ts with the packet and add client ts also...
how do I add a double to a packet?

I could turn it into a char array like I do with state...


im guessing sizeof double is 8...

double test = 1.23;

memcpy(packetbuffer+pos, test,  8);





   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;




before I do this in a packet, lets just try to do it in a regular way....



void PacketPutDouble(double *d)
{
   memcpy(packetbuffer+packetsize, d, 8);
	packetsize+=8;
}

double PacketGetDouble(void)
{
   double d[2];
   memcpy(d, packetbuffer+packetpos, 8);
	packetpos+=8;
	return *d;
}



use this:
char packetbuffer[1024];

make a function to stick something in it and another fucntion to get it out....




char packetbuffer1[1024] = {0};
int packetsize1 = 0;
int packetpos1 = 0;

void PacketPutDouble1(double d)
{
   double dd[2] = {0};
   dd[0] = d;
   memcpy(packetbuffer1 + packetsize1, dd, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d[2] = {0};
   memcpy(d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d[0];
}

void temp_test(void)
{
   double t0 = 0.000123;
   printf("1 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);

   PacketPutDouble1(t0);
   printf("2 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);


   double t1 = PacketGetDouble1();
   printf("3 - ps:%d pp:%d sot:%d t1:%f\n", packetsize1, packetpos1, sizeof(t1), t1);


this shit works!!!


the problem I was having is that memcopy does not like to be passed plain variables, it wants pointers...
so I made an array of the variable tyope I wanted and only use the first element...

found this:


double in=2.132;
char arr[12] = {};
memcpy(arr,&in,sizeof(in));

char arr2[12] = ...;
double out;
memcpy(&out,arr2,sizeof(out));

void PacketPutDouble1(double d)
{
   memcpy(packetbuffer1 + packetsize1, &d, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d = 0;
   memcpy(&d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d;
}

that works too!

now put it in the packets....done...

now try


C:\pm>pm -s

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Local address of channel:24785
Network initialized - channel mode (UDP)
Server successfully initialized

Server received initial 1234 packet from '192.168.1.116:24785'
Server opened channel for `192.168.1.116:24785' and sent reply
ping time:   0.7 ms
ping time:   0.7 ms
ping time:   0.4 ms
ping time:   1.3 ms
ping time:   0.3 ms
ping time:   1.1 ms
ping time:   1.0 ms
ping time:   1.2 ms
ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.4 ms
ping time:   1.1 ms
ping time:   0.4 ms
ping time:   0.6 ms
ping time:   0.5 ms
Shutting down the server


now try internet:


Server received initial 1234 packet from '70.75.228.155:24785'
Server opened channel for `70.75.228.155:24785' and sent reply
ping time:  30.6 ms
ping time:  25.7 ms
ping time:  21.7 ms
ping time:  26.7 ms
ping time:  20.7 ms
ping time:  31.1 ms
ping time:  26.3 ms
ping time:  27.9 ms
ping time:  24.1 ms
ping time:  27.8 ms
ping time:  25.9 ms
ping time:  35.6 ms
Shutting down the server


OK I've got something

now try TCP

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Network initialized - connection mode (TCP)
Server successfully initialized

Connection received from 70.75.228.155:63272
ping time:  34.1 ms
ping time:  48.3 ms
ping time:  24.3 ms
ping time:  23.1 ms
ping time:  23.7 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  27.4 ms
ping time:  32.7 ms
ping time:  25.6 ms
ping time:  30.6 ms
ping time:  28.6 ms
ping time:  31.7 ms
ping time:  70.3 ms
Shutting down the server

not that much of a difference...

Now how can I use this to monitor and adjust timing..

Now that I can receive stdf any time, I want to know exactly when I am receiving them

this will be a client thing

when client gets an stdf, compare to the latest frame start

it was about 23ms after frame start...

soon, timestamp fills up.. I should make one global timestamp called frame_start....
I am amazed at how stable the timer is, fps adjust very rarely has anything to do...

now lets try fine tuning the sync...


I can get it down to 5-10 instead of 22 with fine tuning, but it does not make the game more playable on WAN
LAN still looks great

the problem on WAN is the corrections make it look really jumpy
try s1 = 2...



it work so good on LAN, whay not WAN, why so many jumpy corrections??

I need to look into the timing closer

maybe running just in time to get difs as needed is not the right approach

If I got difs for a frame that I has already rendered...
I could replay with the local controls for that frame that has already occured...
this would mean I am running ahead of the the server
controls that I am currently pressing are not as old on the server


If I got difs for a frame that I had not rendered yet...
i would hold off till then and apply it
this would mean I am running behind the server
controls that I am currently pressing are even older on the server



I will need to experiment with both

20221219 11:22PM ..push



I have some thoughts...

I want to know where in the client frame are the stdf's rx'd and where are they used..


Make a graphical overlay for the game

sliding bar to show sync and stuff

controls also...

timestamp bar in screen overlay
what am I going to show?

where will i get the data for that

should I clear old timestamps every second?

yes and I should do somthing in there about doing some nice averages and min max

later...


now I want to have some timestamps that do not get saved, only for current frame...
I have one for frame start, but I also want one for stdf rx..


what if I log these so that I can make a nice graph and look at them?? maybe later...


what I am seeing is the stdf being rx'd right after draw in the frame


where in the frame does the client use stdf?

at the very start...

- input
- move
- draw


what if I measured the timestamp difference between stdf packet being received and it being used by the client?

that is the critical timing anyway, is it not?



I want to solve the client sync thing....
I want to be able to control where in the frame the stdf is rx'd
this is proving to be harder than I thought

OK I think I figured out how to do that...

now I want to see if I can have some on screen controls

they will need to be non-blocking


run them from debug screen overlay

first can I show mouse??..yes

button works but blocks on mouse press....
made a non_blocking version


         static int pres = 0;
         if (mdw_buttont_nb(100, yyy, 200, 16,  0,0,0,0,  0,14,15, 0,  1,0,1,0, "Inc"))
         {
            if (pres == 0) printf ("incd\n");
            pres = 1;
         }
         else pres = 0;




now make a global to control the client dsync....done


when adjusting chase too close the connection is lost
the client gets difs too late to apply and does nothing??

cleaning up the logging...

removed call to apply dif from rx packet thing
now only called in the loop every frame and when waiting for intial state

logs look much better now...

I can tell the we are receiving stdf's too late..

they fail all the time when trying to apply, but that is normal.

what I should do is check when they are completed if there is any chance they can be used....
if they are late then I should raise some errors...already done....but addedd to log...
in client debug screen if server_sync = -1

and stays there for 100 frames server will drop

should client reply at all, all it has is stak...and we are not acknowledging anything...

we ack when we get a bad base, should we ack when we get a bad dest??...yes...done...



now sync can go to -1 and client stays connected

I should have something on the client to tell when te last applied dif is.

I am thinking about the nice little graph that shows dsync...
It could also display last diff applied....

added to player1

   int client_last_diff_applied;


That works...


now I want to make a nice little display for the client.

graph
buttons
chase_offset
last_dif
draw in red if last_dif > 2


for the actual value, lets take if from

added to player1 struct...
   double dsync;


OMG that looks great...

now what??

that is about the only thing that I can adjust and monitor on the client....
it sends cdats when they occurs
it processes stdfs just before it has to apply them...

this client dsync is such an important number that I wonder if I should sync it back to the server.
I could add it to stak....

on the client


move all of these to player1

double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;
double client_chase_offset = 0.010;

done...

I actually did not need these and removed them...
double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;

still wondering about adding dsync to stak so server has it....

It was as easy as adding one line on the client:

   PacketPutDouble(players1[p].dsync);

   and one on the client...

   players1[p].dsync            = PacketGetDouble();

add display it in server debug...done...


now what?

do some things for server...like?

buttons to change s1 and s2

graph to show when clients cdats arrive in relation to current frame...

s1 and s2 are already part of the player1 struct...

done...


I want to know at what position in the frame do cdats arrive at, and how many frames behind....

crudely looking in the logs -2 and rarely -3 for a WAN game....
-1 for a LAN game....this might be unavoidable...

if the round trip ping is around 30 then one way would be 15...

I want to know exactly what it is and see if adjusting the client offset can do anything about it....


so how to measure?


server fast packet loop already marks cdats with timestamp when they arrive

so go to where they are processed...




I still don't like how the frame_number are processed!!
I really want to fix it but I am scared of what it will break....

---------------
- current:
---------------
timer_triggers_event

input
move
draw
inc frame

wait until triggered again...


---------------
what I want:
---------------
timer_triggers_event

inc frame
input
move
draw

wait until triggered again...

this would mean that for the entirety of the frame, the frame number is the same

not
change frame number
wait
do stuff

the wait would be at the end....


goddamn it!! I don't care what I have to fix...I'm going to make it so that is how it is...

one consequence is there will never be a frame 0...I know somethings depend on that....

or rather any setup that is done before the first loop will be done on frame 1....


it is done, these are the first lines

mwPS.frame_num++;
update_animation();

lets see what still works...

single player seems good....level done too

server and client seem to work...omg...

This will have more of an effect on some timer things I am doing....




[1457]cdat 1455  gc:-2 0.016008
[1458]cdat 1456  gc:-2 0.012546
[1459]cdat 1457  gc:-2 0.008733
[1460]cdat 1458  gc:-2 0.013411
[1461]cdat 1459  gc:-2 0.015866
[1462]cdat 1460  gc:-2 0.016015
[1463]cdat 1461  gc:-2 0.008641
[1464]cdat 1462  gc:-2 0.012660
[1465]cdat 1463  gc:-2 0.016165
[1466]cdat 1464  gc:-2 0.016065
[1467]cdat 1465  gc:-2 0.008550
[1468]cdat 1466  gc:-2 0.016006
[1469]cdat 1467  gc:-2 0.013687
[1470]cdat 1468  gc:-2 0.010922
[1471]cdat 1469  gc:-2 0.011143
[1472]cdat 1470  gc:-2 0.015377
[1473]cdat 1471  gc:-2 0.011053
[1474]cdat 1472  gc:-2 0.013461
[1476]cdat 1473  gc:-3 0.023695
[1477]cdat 1474  gc:-3 0.023571
[1477]cdat 1475  gc:-2 0.015960
[1478]cdat 1476  gc:-2 0.016023
[1479]cdat 1477  gc:-2 0.008565
[1480]cdat 1478  gc:-2 0.015372
[1481]cdat 1479  gc:-2 0.011239
[1482]cdat 1480  gc:-2 0.015975
[1483]cdat 1481  gc:-2 0.016240
[1484]cdat 1482  gc:-2 0.013693
[1485]cdat 1483  gc:-2 0.013712
[1486]cdat 1484  gc:-2 0.016219
[1487]cdat 1485  gc:-2 0.006484
[1488]cdat 1486  gc:-2 0.010268
[1489]cdat 1487  gc:-2 0.016290
[1490]cdat 1488  gc:-2 0.016250
[1491]cdat 1489  gc:-2 0.005989
[1492]cdat 1490  gc:-2 0.016332
[1493]cdat 1491  gc:-2 0.016286
[1494]cdat 1492  gc:-2 0.011335
[1496]cdat 1493  gc:-3 0.015332
[1496]late cdat dropped p:1 c:1493  state:1494  tally:5
[1496]cdat 1494  gc:-2 0.015881
[1497]cdat 1495  gc:-2 0.011157
[1498]cdat 1496  gc:-2 0.016283
[1500]cdat 1497  gc:-3 0.018602
[1500]cdat 1498  gc:-2 0.016122
[1501]cdat 1499  gc:-2 0.016274
[1502]cdat 1500  gc:-2 0.016290
[1504]cdat 1501  gc:-3 0.022777
[1504]cdat 1502  gc:-2 0.015344
[1505]cdat 1503  gc:-2 0.016394
[1506]cdat 1504  gc:-2 0.013682
[1507]cdat 1505  gc:-2 0.005452
[1508]cdat 1506  gc:-2 0.016448
[1509]cdat 1507  gc:-2 0.008965
[1510]cdat 1508  gc:-2 0.013958
[1511]cdat 1509  gc:-2 0.012853
[1512]cdat 1510  gc:-2 0.012440
[1513]cdat 1511  gc:-2 0.010386
[1514]cdat 1512  gc:-2 0.015350
[1515]cdat 1513  gc:-2 0.002899
[1516]cdat 1514  gc:-2 0.015026
[1517]cdat 1515  gc:-2 0.010401
[1518]cdat 1516  gc:-2 0.012886
[1519]cdat 1517  gc:-2 0.012882
[1520]cdat 1518  gc:-2 0.015386
[1521]cdat 1519  gc:-2 0.012910
[1522]cdat 1520  gc:-2 0.015355
[1523]cdat 1521  gc:-2 0.007923
[1524]cdat 1522  gc:-2 0.012935
[1525]cdat 1523  gc:-2 0.012978
[1526]cdat 1524  gc:-2 0.015520
[1527]cdat 1525  gc:-2 0.012827
[1528]cdat 1526  gc:-2 0.015430
[1529]cdat 1527  gc:-2 0.015545
[1530]cdat 1528  gc:-2 0.012892
[1531]cdat 1529  gc:-2 0.012998
[1532]cdat 1530  gc:-2 0.014326
[1533]cdat 1531  gc:-2 0.012941
[1534]cdat 1532  gc:-2 0.015566
[1535]cdat 1533  gc:-2 0.008016
[1537]cdat 1535  gc:-2 0.015592
[1538]cdat 1536  gc:-2 0.015593
[1539]cdat 1537  gc:-2 0.000435
[1540]cdat 1538  gc:-2 0.015559
[1541]cdat 1539  gc:-2 0.015597
[1542]cdat 1540  gc:-2 0.015425
[1543]cdat 1541  gc:-2 0.008001
[1544]cdat 1542  gc:-2 0.014422
[1545]cdat 1543  gc:-2 0.008050
[1546]cdat 1544  gc:-2 0.015639
[1547]cdat 1545  gc:-2 0.015657
[1548]cdat 1546  gc:-2 0.010277
[1549]cdat 1547  gc:-2 0.015553
[1550]cdat 1548  gc:-2 0.013098
[1551]cdat 1549  gc:-2 0.008058
[1552]cdat 1550  gc:-2 0.015317
[1553]cdat 1551  gc:-2 0.016250
[1554]cdat 1552  gc:-2 0.016115
[1555]cdat 1553  gc:-2 0.006201
[1556]cdat 1554  gc:-2 0.016057
[1557]cdat 1555  gc:-2 0.013614
[1558]cdat 1556  gc:-2 0.011243
[1559]cdat 1557  gc:-2 0.013781
[1560]cdat 1558  gc:-2 0.015270
[1561]cdat 1559  gc:-2 0.016355
[1562]cdat 1560  gc:-2 0.016313
[1563]cdat 1561  gc:-2 0.005983
[1564]cdat 1562  gc:-2 0.016292
[1565]cdat 1563  gc:-2 0.016259
[1566]cdat 1564  gc:-2 0.016243
[1568]cdat 1565  gc:-3 0.021811
[1568]late cdat dropped p:1 c:1565  state:1566  tally:6
[1568]cdat 1566  gc:-2 0.010779
[1569]cdat 1567  gc:-2 0.013561
[1570]cdat 1568  gc:-2 0.013822
[1571]cdat 1569  gc:-2 0.013807
[1572]cdat 1570  gc:-2 0.016112
[1573]cdat 1571  gc:-2 0.013626
[1574]cdat 1572  gc:-2 0.011389
[1575]cdat 1573  gc:-2 0.008685
[1576]cdat 1574  gc:-2 0.014161
[1577]cdat 1575  gc:-2 0.013923
[1578]cdat 1576  gc:-2 0.013768
[1579]cdat 1577  gc:-2 0.011336
[1580]cdat 1578  gc:-2 0.013763
[1581]cdat 1579  gc:-2 0.013759
[1582]cdat 1580  gc:-2 0.016342
[1583]cdat 1581  gc:-2 0.013814
[1584]cdat 1582  gc:-2 0.009788
[1585]cdat 1583  gc:-2 0.015957
[1586]cdat 1584  gc:-2 0.015287
[1587]cdat 1585  gc:-2 0.012783
[1588]cdat 1586  gc:-2 0.012283
[1589]cdat 1587  gc:-2 0.014804
[1590]cdat 1588  gc:-2 0.009828
[1591]cdat 1589  gc:-2 0.012939
[1592]cdat 1590  gc:-2 0.014961
[1593]cdat 1591  gc:-2 0.014743
[1594]cdat 1592  gc:-2 0.015493
[1595]cdat 1593  gc:-2 0.015486
[1596]cdat 1594  gc:-2 0.015339
[1597]cdat 1595  gc:-2 0.015183
[1598]cdat 1596  gc:-2 0.012898
[1599]cdat 1597  gc:-2 0.012872
[1600]cdat 1598  gc:-2 0.015144
[1601]cdat 1599  gc:-2 0.015399
[1602]cdat 1600  gc:-2 0.015535
[1603]cdat 1601  gc:-2 0.015149
[1604]cdat 1602  gc:-2 0.015224
[1605]cdat 1603  gc:-2 0.015317
[1606]cdat 1604  gc:-2 0.015380
[1607]cdat 1605  gc:-2 0.015513
[1608]cdat 1606  gc:-2 0.015421
[1609]cdat 1607  gc:-2 0.013009
[1610]cdat 1608  gc:-2 0.015586
[1611]cdat 1609  gc:-2 0.013025
[1612]cdat 1610  gc:-2 0.009968
[1613]cdat 1611  gc:-2 0.012802
[1614]cdat 1612  gc:-2 0.015206
[1615]cdat 1613  gc:-2 0.013571
[1616]cdat 1614  gc:-2 0.010078
[1617]cdat 1615  gc:-2 0.013467
[1618]cdat 1616  gc:-2 0.011040
[1619]cdat 1617  gc:-2 0.008677
[1620]cdat 1618  gc:-2 0.013720
[1621]cdat 1619  gc:-2 0.008645
[1622]cdat 1620  gc:-2 0.016253
[1623]cdat 1621  gc:-2 0.013690
[1624]cdat 1622  gc:-2 0.010371
[1625]cdat 1623  gc:-2 0.016220
[1626]cdat 1624  gc:-2 0.016234
[1627]cdat 1625  gc:-2 0.013284
[1628]cdat 1626  gc:-2 0.016230
[1629]cdat 1627  gc:-2 0.016302
[1630]cdat 1628  gc:-2 0.013344
[1631]cdat 1629  gc:-2 0.013923
[1632]cdat 1630  gc:-2 0.014303
[1633]cdat 1631  gc:-2 0.011076
[1634]cdat 1632  gc:-2 0.016218
[1636]cdat 1634  gc:-2 0.016113
[1637]cdat 1635  gc:-2 0.016295
[1638]cdat 1636  gc:-2 0.011313
[1639]cdat 1637  gc:-2 0.011073
[1640]cdat 1638  gc:-2 0.009382
[1641]cdat 1639  gc:-2 0.015344
[1642]cdat 1640  gc:-2 0.013728
[1643]cdat 1641  gc:-2 0.011338
[1644]cdat 1642  gc:-2 0.012676
[1645]cdat 1643  gc:-2 0.016255
[1646]cdat 1644  gc:-2 0.016330
[1647]cdat 1645  gc:-2 0.011304
[1648]cdat 1646  gc:-2 0.012836
[1649]cdat 1647  gc:-2 0.016026
[1650]cdat 1648  gc:-2 0.013793
[1651]cdat 1649  gc:-2 0.011195
[1652]cdat 1650  gc:-2 0.015942
[1653]cdat 1651  gc:-2 0.013636
[1654]cdat 1652  gc:-2 0.013275
[1655]cdat 1653  gc:-2 0.013769
[1656]cdat 1654  gc:-2 0.015110
[1657]cdat 1655  gc:-2 0.010577
[1658]cdat 1656  gc:-2 0.016374
[1659]cdat 1657  gc:-2 0.011284
[1660]cdat 1658  gc:-2 0.010566
[1661]cdat 1659  gc:-2 0.015398
[1662]cdat 1660  gc:-2 0.015214
[1663]cdat 1661  gc:-2 0.012801
[1664]cdat 1662  gc:-2 0.007925
[1665]cdat 1663  gc:-2 0.014823
[1666]cdat 1664  gc:-2 0.012664
[1667]cdat 1665  gc:-2 0.012927
[1668]cdat 1666  gc:-2 0.007893
[1669]cdat 1667  gc:-2 0.013443
[1670]cdat 1668  gc:-2 0.015582
[1671]cdat 1669  gc:-2 0.000908
[1672]cdat 1670  gc:-2 0.009900
[1673]cdat 1671  gc:-2 0.013594
[1674]cdat 1672  gc:-2 0.015531
[1675]cdat 1673  gc:-2 0.010952
[1676]cdat 1674  gc:-2 0.013435
[1677]cdat 1675  gc:-2 0.013549
[1678]cdat 1676  gc:-2 0.008466
[1680]cdat 1677  gc:-3 0.019645
[1680]cdat 1678  gc:-2 0.002917
[1681]cdat 1679  gc:-2 0.008503
[1682]cdat 1680  gc:-2 0.016072
[1683]cdat 1681  gc:-2 0.011123
[1684]cdat 1682  gc:-2 0.003675
[1685]cdat 1683  gc:-2 0.013604
[1686]cdat 1684  gc:-2 0.015596
[1687]cdat 1685  gc:-2 0.016052
[1688]cdat 1686  gc:-2 0.015212
[1689]cdat 1687  gc:-2 0.016168
[1690]cdat 1688  gc:-2 0.011074
[1691]cdat 1689  gc:-2 0.013681
[1692]cdat 1690  gc:-2 0.013463
[1693]cdat 1691  gc:-2 0.011137
[1694]cdat 1692  gc:-2 0.011156
[1695]cdat 1693  gc:-2 0.000906
[1696]cdat 1694  gc:-2 0.009721
[1697]cdat 1695  gc:-2 0.016065
[1698]cdat 1696  gc:-2 0.010847
[1699]cdat 1697  gc:-2 0.008499
[1700]cdat 1698  gc:-2 0.015868
[1701]cdat 1699  gc:-2 0.013527
[1702]cdat 1700  gc:-2 0.012817
[1703]cdat 1701  gc:-2 0.013946
[1704]cdat 1702  gc:-2 0.015312
[1705]cdat 1703  gc:-2 0.016129
[1706]cdat 1704  gc:-2 0.016215
[1707]cdat 1705  gc:-2 0.001235
[1708]cdat 1706  gc:-2 0.016209
[1709]cdat 1707  gc:-2 0.016298
[1710]cdat 1708  gc:-2 0.016262
[1711]cdat 1709  gc:-2 0.006192
[1712]cdat 1710  gc:-2 0.015423
[1713]cdat 1711  gc:-2 0.015889
[1714]cdat 1712  gc:-2 0.013694
[1715]cdat 1713  gc:-2 0.013802
[1716]cdat 1714  gc:-2 0.013334
[1717]cdat 1715  gc:-2 0.011154
[1718]cdat 1716  gc:-2 0.016351
[1719]cdat 1717  gc:-2 0.016319
[1720]cdat 1718  gc:-2 0.002903
[1721]cdat 1719  gc:-2 0.015321
[1722]cdat 1720  gc:-2 0.013337
[1723]cdat 1721  gc:-2 0.013783
[1724]cdat 1722  gc:-2 0.016235
[1725]cdat 1723  gc:-2 0.016357
[1726]cdat 1724  gc:-2 0.015293
[1727]cdat 1725  gc:-2 0.016391
[1728]cdat 1726  gc:-2 0.012899
[1729]cdat 1727  gc:-2 0.011115
[1730]cdat 1728  gc:-2 0.015705
[1731]cdat 1729  gc:-2 0.013571
[1732]cdat 1730  gc:-2 0.013652
[1733]cdat 1731  gc:-2 0.013832
[1734]cdat 1732  gc:-2 0.015658
[1735]cdat 1733  gc:-2 0.013765
[1736]cdat 1734  gc:-2 0.010355
[1737]cdat 1735  gc:-2 0.015423
[1738]cdat 1736  gc:-2 0.012726
[1739]cdat 1737  gc:-2 0.005048
[1740]cdat 1738  gc:-2 0.015540
[1741]cdat 1739  gc:-2 0.010319
[1742]cdat 1740  gc:-2 0.007640
[1743]cdat 1741  gc:-2 0.002646
[1744]cdat 1742  gc:-2 0.010272
[1745]cdat 1743  gc:-2 0.020515
[1746]cdat 1744  gc:-2 0.015403
[1747]cdat 1745  gc:-2 0.012900
[1748]cdat 1746  gc:-2 0.007992
[1749]cdat 1747  gc:-2 0.015303
[1750]cdat 1748  gc:-2 0.010310
[1751]cdat 1749  gc:-2 0.007921
[1752]cdat 1750  gc:-2 0.012557
[1753]cdat 1751  gc:-2 0.015826
[1754]cdat 1752  gc:-2 0.016052
[1755]cdat 1753  gc:-2 0.011077
[1756]cdat 1754  gc:-2 0.013468
[1757]cdat 1755  gc:-2 0.016045
[1758]cdat 1756  gc:-2 0.016096
[1759]cdat 1757  gc:-2 0.011004
[1760]cdat 1758  gc:-2 0.015371
[1761]cdat 1759  gc:-2 0.011178
Shutting down the server
savegame/game_exit_20221230-183937-lev150.txt - saved
logs/20221230-183937-[150][m36].txt saved

C:\pm>







so how to combine those two numbers


and do they even still make sense?


Now, if I get one I can assume by the time it gets added it will be the next frame...
or this frame because by the time it is processed the frame has incremented

so when I get one that says -2 on frame 1730 for example...
that mean the cdat is for 1728, 2 frame ago...


now that the start of frame timer can be trusted, I should use that to go back and find out exactly when the packet arrived in relation to the frame start.

then I can make a composite number of how late it is...

WAN

[244]cdat 242  gc:-2 0.016242 -33.757700ms
[245]cdat 243  gc:-2 0.013527 -36.472500ms
[246]cdat 244  gc:-2 0.001073 -48.926800ms
[247]cdat 245  gc:-2 0.013675 -36.325100ms
[248]cdat 246  gc:-2 0.008515 -41.484700ms
[249]cdat 247  gc:-2 0.013653 -36.346700ms
[250]cdat 248  gc:-2 0.003773 -46.226500ms
[251]cdat 249  gc:-2 0.013406 -36.593600ms
[252]cdat 250  gc:-2 0.013678 -36.322400ms
[253]cdat 251  gc:-2 0.013635 -36.364900ms
[255]cdat 252  gc:-3 0.018778 -56.222400ms
[256]cdat 253  gc:-3 0.013594 -61.405500ms
[256]cdat 254  gc:-2 0.013532 -36.468100ms
[257]cdat 255  gc:-2 0.013844 -36.155600ms
[258]cdat 256  gc:-2 0.008631 -41.369000ms
[259]cdat 257  gc:-2 0.011310 -38.690000ms
[260]cdat 258  gc:-2 0.013817 -36.183400ms
[261]cdat 259  gc:-2 0.012976 -37.023800ms
[262]cdat 260  gc:-2 0.006389 -43.610600ms
[263]cdat 261  gc:-2 0.011331 -38.669100ms
[264]cdat 262  gc:-2 0.013452 -36.548300ms
[265]cdat 263  gc:-2 0.003223 -46.777400ms
[266]cdat 264  gc:-2 0.008756 -41.244300ms
[267]cdat 265  gc:-2 0.011006 -38.994200ms
[268]cdat 266  gc:-2 0.016051 -33.949000ms
[269]cdat 267  gc:-2 0.013857 -36.143100ms
[270]cdat 268  gc:-2 0.008706 -41.294100ms
[271]cdat 269  gc:-2 0.011205 -38.794700ms
[272]cdat 270  gc:-2 0.013796 -36.204100ms
[278]cdat 276  gc:-2 0.006955 -43.044900ms



LAN 10ms

[352]cdat 351  gc:-1 0.012526 -12.474100ms
[353]cdat 352  gc:-1 0.011416 -13.583900ms
[354]cdat 353  gc:-1 0.012495 -12.505200ms
[355]cdat 354  gc:-1 0.012518 -12.481800ms
[356]cdat 355  gc:-1 0.011462 -13.538200ms
[357]cdat 356  gc:-1 0.013423 -11.577100ms
[358]cdat 357  gc:-1 0.013426 -11.573700ms
[359]cdat 358  gc:-1 0.012400 -12.599700ms
[360]cdat 359  gc:-1 0.012547 -12.453300ms
[361]cdat 360  gc:-1 0.013429 -11.570900ms
[362]cdat 361  gc:-1 0.012374 -12.626400ms
[363]cdat 362  gc:-1 0.013445 -11.554800ms
[364]cdat 363  gc:-1 0.013457 -11.543500ms
[365]cdat 364  gc:-1 0.012394 -12.606000ms
[366]cdat 365  gc:-1 0.012999 -12.001300ms
[367]cdat 366  gc:-1 0.012964 -12.036300ms
[368]cdat 367  gc:-1 0.011328 -13.672500ms

LAN 2ms

[573]cdat 572  gc:-1 0.021599 -3.400600ms
[574]cdat 573  gc:-1 0.021587 -3.412900ms
[575]cdat 574  gc:-1 0.020520 -4.480400ms
[576]cdat 575  gc:-1 0.020883 -4.117200ms
[577]cdat 576  gc:-1 0.021548 -3.452300ms
[578]cdat 577  gc:-1 0.020530 -4.470000ms
[579]cdat 578  gc:-1 0.021555 -3.445200ms
[580]cdat 579  gc:-1 0.021530 -3.469900ms
[581]cdat 580  gc:-1 0.020455 -4.545000ms
[582]cdat 581  gc:-1 0.021507 -3.493000ms
[583]cdat 582  gc:-1 0.021511 -3.489000ms
[584]cdat 583  gc:-1 0.019713 -5.286600ms
[585]cdat 584  gc:-1 0.021510 -3.490400ms
[586]cdat 585  gc:-1 0.021510 -3.489900ms
[587]cdat 586  gc:-1 0.020450 -4.550300ms
[588]cdat 587  gc:-1 0.021512 -3.488100ms



I want to have server stats on cdat_rx time
tally for 1s and do average and max min
same for late cdats

OK I have done that...big surprise...nothing seems to effect when cdats are received on server, except for client dsync....


the only thing I can do to get cdats to the server faster, would be to let the client move ahead of the server in time....
but then the client would always get difs that were too late to apply....

what if I let the client rewind?
and apply the local moves from the last frame?

that would mean I would have to keep the clients local moves...it would only be one move per frame max...

this is just crazy enough to maybe work.....

client stores all its game moves in it's own local array....
when client get a dif that is in the past:
apply then play back to current...



right now I have the server in the lead, the client lags behind just enough so I can get the current state from the server and apply it.
If I let the client pass the server, the server will be able to get cdats with less delay, but who knows what else might happen??

I think it's worth a try....

1 - make client put stuff in its own local game_moves array

2 - remove the part in rx stdf where we ignore late difs

3 - modify apply dif to allow late ones

this is a tricky bit of code here....

   // check to see if frame_nums match and its time to apply dif or if initial state when mwPS.frame_num == 0
   if ((mwPS.frame_num != client_state_dif_dst) && (mwPS.frame_num != 0))
   {


first of all if the match then do it
second of all if mwPS.frame_num == 0 do it
third of all...
if newer than last applied dif....

what is the varaible for the last applied dif mwPS.frame_num? 'client_state_base_frame_num'

so check if the dest of the dif_dest on deck is newer than that

if (client_state_dif_dst > client_state_base_frame_num) // we have dif with a newer dest than previous

omg I am ready to try it....

well it looks like I can run a game succesfully with negative sync... lets try it on WAN


client has all been put back together nicely...
still to do on client
look into chase multiplier...seems to work good but I have not examined it
automatically set chase amount, but based on what?
should it be a sliding scale, or a fixed number?

on server I have issues if I try to lower s1
raising it is OK but when I lower it, server becomes unresponsive and will not accept new connections

show more about the clients on the server...but what and why??

profile using timestamps certain functions...

move
draw
rewind
send stdf
receive packets

move packetbuffer code and functions to packet file


testing...making the client -40 seemed to make the game a lot smoother....


calculate and show ping on client and server...


server tx ping from 'loop' with current time

client rx ping and tx pong with passed time and current time

server rx pong
calc rt
return passed ts in pang

client rx pang
calc rt


ok now where to store it...

player1
   double ping;

put it on the bottom for client

in server it will be part of debug array



flush client and server on level done


when does client show red...removed

how about auto setting clients offset to ping....

but I would need to get an average ping
I only read it every 2s

how about reading it one per second and keep a 10s rolling average....

at the start of when a client joins
use default of zero to start...
get 8 pings in 2s for avg then use that to adjust
then do the rolling replace one every 2 sec

is this overkill...maybe...

but just blindly plugging one ping into offset is bad also

should have some limits....
+20 absolute max, why would you even want to go positive?
-50 to -80 somehwere around there for the min need to test...




try experimenting with different s1 and s2
3 1 - default

I'm getting late cdats and stuff from 4230's but not scat or e6430
the sync on them is jumping around a lot...
I could probably benefit from some code profiling....


20221231 9:26 AM

make the client initiate ping, as it is the one that needs it.
where?
how about from a timer?
too complex, just do it like the server does...
done...

now make way for client to do more right after join...

how about make the cyclic buffer of ping to average first....

then make a method to add new pings

then make a way that the average is calultaed

then make a way that when the buffer is not full, its pings mopre often...

struct ping_buffer

int num_filled;
int new_index;
double ping[8];
double avg;

initially:
num_filled = 0;
index = 0;
all are 0;

as added:
num_filled++
index++

num_filled can be greater than index

when doing avg

loop and add from 0 to num filled, or max if full

then divide and set avg...


do I need to do it in a struct? probably not the besy way...

double ping_array[8];
double ping_avg;
int    ping_num_filled;
int    ping_index;

make a new file ping_buffer.cpp

clear in client init..done

now make a function to add...done...

now where am I going to save this?

player1

ping_avg

ok that's done...now make it run faster until filled...

done...

now maybe toss out the highest and lowest for average....

experiment with different values of s1 and s2

right now I have been using 3 and 1

re do the client sync graph for the server, especially since I now use dsync

what did I use before?

stak packet on server prints this log line:

sprintf(tmsg1, "rx stak sync:[%d] chase:[%d] ack_fn:%d cli_fn:%d", players1[p].server_sync, players1[p].client_chase_fps, ack_frame_num, client_frame_num );

[30][1][318]rx stak sync:[1] chase:[39] ack_fn:316 cli_fn:317 set new base

I want to add dsync and remove unneeded things...why do I have 2 fn that are always the same??

change client_chase_fps to double from int....

its main use is to get back to the server to be displayed

OK I have parsed it from the log lines in graph...

but the problem is that the data for the graph is an integer array....

for now, multiply by 10...

redo sync to display in ms

I can come back to this later....
when I get this done I can examine chase better.....

OK, Ive been thinking...
I want to make the tag parsing thing a separate function...done
replaced 8-10 calls

Also this sync graph would probably be better on the client.

The server only has data when it receives stak....

what can I do to make the graph look better??

it is not frames anymore, but ms...

better....

can I auto range based on the data shown?...yes...

my stak log line can bee too long

[30][3][500]rx stak syn:[4] dsy:[12405.5] chs:[70.0] afn:496 cfn:496 failed to set base! cl:499

[30][4][6180]rx stak syn:[-2] dsy:[-113.3] chs:[31.7] afn:6177 cfn:6182 failed to set base! cl:6179
[30][3][6182]rx stak syn:[-2] dsy:[-104.8] chs:[33.0] afn:6179 cfn:6184 failed to set base! cl:6181
[30][4][6182]rx stak syn:[-2] dsy:[-104.6] chs:[32.6] afn:6177 cfn:6184 failed to set base! cl:6181
[30][2][6183]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6185 failed to set base! cl:6181
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183


failed to set base! cl:6183
change to
fail base set:6183

saved 9 char

more:
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183

[30][2][6184]rx stak s[-2] d[-100.0] c[33.0] af:6179 cf:6186 fail set base:6183

saved 20 char



can I make some buttons in graphs?  at the top of the legend scale lock or autorange..
auto/manual
manual +/-



I really want to make the graphs simpler...

wouldn't it be nice to have a common function for all of them?

they all seem to have common x axis...frames, seconds, minutes, etc.....


what is the data needed to describe a graph?

screen coordinates x1, y1, x2, y2, w, h
these are in the standard computer screen format: x1,y1 is upper left corner

graph x axis
start and end data values

graph y axis
start and end data values

can get range from these.

an array of data used to plot points on the graph

data[][0] = x
data[][1] = y

can I make this an object?

why?

so it encaspulates it's own data and methods

I will call it to draw itself
optionally draw legends and gridlines
process mouse input on the graph

class mw_graph

make a new file and lets do this....


I don't get why I am having such a hard time mapping one range to another....
am i doing the wrong things??
I don't need to map the data range to the axis range!
I need to map the axis range to the screen range!!!!

   double xm = screen_w / x_axis_rng;
   double ym = screen_h / y_axis_rng;

   for (int i=0; i<data_points; i++)
   {
      float x = screen_x1 + (data[i][0]-x_axis_min) * xm;
      float y = screen_y2 - (data[i][1]-y_axis_min) * ym;
      al_draw_rectangle(x, y, x+1, y+1, mC.pc[10], 1);
   }


now what??

should I put some mouse_controls in?
yes...

ist show mouse...

2nd show mouse position and convert to values...

this will mean I have to call this in a loop and process event queue....

done...
now I want an autoscale button
one for x and y and one for each also...

done...


what now?

can you do a nice title...

set a minimum x axis range....

butttons for nice axis management:
auto/manual
of just auto button
+ and - to adjust scale
for each min and mix??

not sure if this will be that usefull

implement mouse_drag...
x only or x and y?
can you set a scale conevrsion varaible for x axis and y axis
do it on the fly..it was easy...
mouse drag works beautifully




            // graph position under mouse (mx1) needs to stay the same

            // change range?? then find min and max to ensure same pos??


            // what if i calulated scaler, then changed that, then worked backwards from there
//            double x_scaler =  x_axis_rng / screen_w;
//            x_scaler *= 1.1;
//            x_axis_rng = x_scaler * screen_w; // convert range back

            // now how do I adjust min so that current pos is the same

            // old distance from current pos to min * scaler  ????

//
//            // old distance from curent position to min
//            double old_offset = mx1 - x_axis_min;
//
//            printf("old_offset:%f\n", old_offset);
//
//
//            // get original scale
//            double x_scaler =  x_axis_rng / screen_w;
//
//            printf("orignal_scale:%f\n", x_scaler);
//
//
//
//            // change scale
//            x_scaler *= 1.1;
//
//
//            printf("new_scale:%f\n", x_scaler);
//
//
//            printf("old range:%f\n", x_axis_rng);
//
//            // convert range
//            x_axis_rng = x_scaler * screen_w;
//
//            printf("new range:%f\n", x_axis_rng);
//
//
//
//            printf("old offset:%f\n", old_offset);
//
//            // scale to new
//            double new_offset = old_offset * 1.1;
//
//
//            printf("new offset:%f\n", new_offset);
//
//
//
//            printf("old min:%f\n", x_axis_min);
//
//            // set min from original position and new offset
//            x_axis_min = mx1 - new_offset;
//
//
//            printf("new min:%f\n", x_axis_min);
//
//            // set max1
//            x_axis_max = x_axis_min + x_axis_rng;
//
//
//


            double old_offset = mx1 - x_axis_min;     // old distance from curent position to min
            double new_offset = old_offset * 1.1;     // scale to new
            x_axis_min = mx1 - new_offset;            // set min from original position and new offset
            x_axis_rng *= 1.1;                        // convert range
            x_axis_max = x_axis_min + x_axis_rng;     // set new max


holy shit that is beautiful!!

mouse drag (x axis)
mouse wheel zoom (x axis)
mouse drag zoom in (x and y axis)

do something about mouse drag when off screen, clamp to edges done...

try y drag move...awesome...

try y zoom wheel...wicked...

now if I added lock buttons on the x and y axis to prevent this

will it lock both scroll and zoom??

for x axis

zoom lock..


I want scroll bars...

do an x one first


I think I am readt to start thinking about some limits....

limit the axis ranges....

make all changes to the axis ranges go through a common function so limit will only need to be tested once
done...
it works, but seems a little weird when drag turns into resize...
drag normally moves both start and end
if one does not move, it turns into a resize...
the alternative would be to do nothing, no drag move allowed if it would change range

I can live with it for now...


now make some ways to drag the scroll bar...

make scrollbar variables part of class...done

int x_axis_scrollbar_x1;
int x_axis_scrollbar_x2;
int x_axis_scrollbar_w;

int x_axis_scrollbar_bar_x1;
int x_axis_scrollbar_bar_x2;

int x_axis_scrollbar_y1;
int x_axis_scrollbar_y2;

moved draw into its own function


figure out the offset...data does not start till 40...done...


now I have 5 ways to adjust the scroll bar with the mouse and its looking pretty good...

sometimes I can adjust past data max and stuff breaks...
a_axis min can be more the max...this should not happen...

there is some chicken and egg things going on with enforce limits...

testing for min max
testing for wrong order

I need to test both min and max to see if they are in range

I also want to add another test...minimum range...

I should find the smallest difference between x values and make the minum range 10 of those...

for now, lets just set a static value and test..

if both max and min are stuck near the top separate them by minimum range...

this all looks good...

now I want to do some y ranging


   bool x_axis_lock_scroll;
   bool x_axis_lock_zoom;

   bool y_axis_lock_scroll;
   bool y_axis_lock_zoom;
   bool y_axis_lock_auto_zoom;



y_axis_lock_zoom
done for drag rect and mouse wheel
not done for drag scroll...still changes zoom...fixed

y_axis_lock_scroll

y_axis scrollbars

y axis is reversed, which poses some issues
how am I going to deal with that? at what point do I flip the axis...
x1 is smaller than x2 when drawing on the screen
but when the mouse moves they are oppposite...
make the data reveser
y2 is min, y1 is max...
im thinking of doing it all upside down...
y1 is lower

I just made the scrollbar y1 and y2 reversed....

I have implemented all scrollbar functionality to y scroll bar...
make the highlight look better, align better, color, size, different mouse_pointer....done...



now back to the locking...

enforce zoom lock on y scroll bar..done...


what does it mean if scroll is locked and zoom is not? does that even make sense??
it could mean that the x_min is locked, but not x_max and scroll


can change   min max rng
no lock       1   1   1
zl            1   1   0
sl            0   1   1
zl + sl       0   0   0


what about autoscale y depending on what is on screen

what if I made zoom_lock have 3 values

0 off
1 lock
2 auto

rignt click on axis or scrollbar for options..

mouseover text ...

mouse crosshairs

jump to nearest data position and show data for that...

I want a way to store the units for each axis...
call a fucntion to set msg

right click on stuff to popup menu....done


20230103 back to work...

what are the main things left to do on graph?

units, axis labels, gridlines

nice bounding boxes for all the graph elements
(optional) title and (optional)space for it (probably above but not married to it)

y axis labels (could be on left or right side)
y axis scrollabr (left or right)

x axis labels (could be on top or bottom)
x axis scrollabr (could be up or down)

all of these things are optional

reset range should turn auto off....

need to stack things on the axis...

gridlines and labels
axis label
scrollbar
these should all dynamically size...
then when that is all done, I will have the size of the entire graph area
maybe I can rename that to graph_x y etc... and the other to plot...

graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

these are the main ones that are set outside the class....
then after the width of all the things in the axes are calculated...
then what is left over will be for the plot

call resize at the beginning....

these will never be changed internally:
graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

find out the width needed for axes...

set:
plot_x1
plot_y1
plot_x2
plot_y2
plot_w
plot_h





make a function to auto set positions... for each axis...

void x_axis_draw(void) // does gridlines, labels, axis title and scroll bars

int x_axis_get_size(void) // returns the size needed by x_axis


start with gridlines and labels...
make them all optional




I now have:

void x_axis_draw(void);
void x_axis_get_size(void);
void x_axis_draw_legend(void);
void x_axis_draw_gridlines_and_labels(void);
int  x_axis_draw_scrollbar(void);
void x_axis_proc_scrollbar(void);


called from main draw:

void mwGraph::x_axis_draw(void)
{
   x_axis_draw_gridlines_and_labels();
   x_axis_draw_legend();
   x_axis_draw_scrollbar();
}


I also have:

void mwGraph::process_input(void)
{
   x_axis_proc_scrollbar();

which also calls:

void mwGraph::x_axis_proc_scrollbar(void)
{
   int sb = x_axis_draw_scrollbar();


how are draw and proc called?
like this externally:
mG[0].draw();
mG[0].process_input();

I will probabaly change that later, do I really need to separarte them?

for now I have other things to do:

get the variables for each x_axis element done


int x_axis_label_draw_on;
int x_axis_label_tick_size;
int x_axis_label_text_size;
int x_axis_label_draw_size;



1st get axis sizes
2nd set plot size and pos
3rd set axis pos

do I need a spearate value for actual size, vs stored size
so I can restore if turned on and off...

I think the x axis is looking really good...now work on the y axis

I am very happy with how these look

next I want to have the option of small text on legends
done and now I have a much nicer method for drawing those...


next, I want to always put labels on origins...

done, but sometimes overwrite other axis labels..



make a function to display axis values...

why can't I put mouse on point on the edge of plot?? fixed
also fixed when point text box is draw off screen...

implment units for axis...

x_axis_value_type..

0 = none
1 = time in frames...

this will have a large impact...

depending on the current displayed range,
the units for an axis will change..

the max value displayed could be used to set the units in some cases...n other cases the range...

like for time (frames)
could be frames, sec, minutes...
depending on what range is shown

this will change:
x axis legend
gridlines and labels
point text box...

I need a main title for the legend:
Time
then I need another for units

I could make a type...

type 0 - do nothing
type 1 - customized for frames

made a type..


if 1, where do I check it??

depending on the range I need to set units, divider and legend

where does that naturally happen?
draw
set size and pos
input

none of these actually

how about enforce axis limits?


and what am I going to be setting?

if type 1
use range to set
legend text
divider
units text

add divider...


----------------------

make labels also able to have font
start with x..done
and also reduce space between labels and legend..done

now do y...done...


it gets kind of messy at the origin when I draw labels there that conflict with the auto ones...and the x and y sometimes confict too...

remove x, keep y.. actually fixed origin still conficts with auto...remove (comment out) both for now...








I am happy with this


should I try it on some real data??

what would happen if I tried more data? like a real bandwidth graph...


what if I made the array larger, to include more players


or I could put them all in the main array but tag them with different series...

or I could make an entirely new graph and overlay the data...

all these things I am thinking of would have a common x axis...

should I try to put everything in one array and tag it by series?
or should I have multiple arrays?

with any method, I need to make sure the data is in order



how about a three dimensional array

point[series][x][y]


I want an int for series and doubles for the other two..

looks like a structure

max needed would be 16 if I do 8tx and 8rx



each instance of my class will get this:


struct data_seri
{
   double data[10000][2];
   int num_data;
   int active;
   int color;
   char name[1024];
};
data_seri series[20] = {0};

use like this:
series[0].data[i][0]

wow! that was surpisingly easy to get 8 tx rate lines...

next I need a series legend and the ability to toggle series on and off while the graph is running...

I want to be able to have many other things shown as well...


when setting unlocked, make sure to set autrange off also...

I want to make a nice gui setup for changing things....

like a page of toggles and checkmarks...

maybe some sliders and buttons too..

show legend like:

series number - series name - show the color and line style - click to toggle

bug--scrollbar does not like negative data

removed clear screen from calling loop, handle it internally

I am calling axis_get_size_and_arrange_pos() externally every loop, do I need to?..yes
so call it internally then...
from draw, or proc input?  proc input...

now I only call 3 things externally and one is only in case the user resized the screen...

mG[0].set_graph_pos(0,0, SCREEN_W, SCREEN_H/2-10);
mG[0].draw();
mG[0].process_input();

now back to showing legend for multiple series.......



figure out how to draw dashed line...

https://www.allegro.cc/forums/thread/615463
https://www.allegro.cc/forums/thread/615415



It looks like I can only do al_draw_soft_line on a bitmap, drawing directly to the backbuffer has weird results

so lets try to figure out hpw to do that...


make a bitmap the same size as graph

now make all my draw stuff draw on that, but all coordinates will need to be adjust to 0,0 for graph_x and y

there were surprisingly few references to those..mostly in adjust x amd y axis...

now that I am drawing onto a bitmap instead of the backbuffer, the drawing looks a lot blockier...yay! :(
text looks fine, but the high level primitives (lines) suck...

the gridlines are terriblly blocky and missing in places...

what a goddamn hassle to try to draw dashed lines

there is no godamn reason for it...



how hard would it be to revert now?
and either:
- only draw the plot lines on its own bitmap, or
- figure out how to use soft lines with backbuffer

reverted...

try to figure out how to use soft lines with backbuffer

- does soft line return x and y that make sense?? yes...


if I store all the x and y in an array then draw them outside the function that seems to work...go fig...





now how im I going to implement this?

ideally I would like to call something very similar to draw_line

al_draw_line(100, 110, 200, 110, mC.pc[15], 1);
mw_draw_line(100, 110, 200, 110, col1, col2);


here it is:

int mw_p[10000][2] = {0};
int mw_i = 0;

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t state, int x, int y)
{
   if (mw_i < 10000)
   {
      mw_p[mw_i][0] = x;
      mw_p[mw_i][1] = y;
      mw_i++;
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, int c1, int c2)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   mw_i = 0;
   al_draw_soft_line(&v1, &v2, (uintptr_t)NULL , mw_FirstFunction , mw_StepFunction , mw_DrawFunction);

   int cycle = 0;
   for (int i=0; i<mw_i; i++)
   {
      int x = mw_p[i][0];
      int y = mw_p[i][1];

      int c = c1;
      if ((cycle % 8) < 4) c = c2;
      cycle++;

//      al_draw_filled_circle(x, y, 1, mC.pc[c]);
      al_draw_filled_rectangle(x-0.5, y-0.5, x+0.5, y+0.5, mC.pc[c]);

//   printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
      //al_put_pixel(p[i][0], p[i][1], mC.pc[p[i][2]]);
   }
}


I am thinking about doing it slightly different...

make my array contain only line segements of the same color

then use the regular al_draw_line to draw those segments...

then I would have less draw calls, and I could use the thickness of lines


values to send to draw:
cycle total
cycle 0 col (default color)

// cycle & total < val color = c1
cycle 1 val
cycle 1 col

8, 15, 4, 10

then when drawing, draw 1 to 0, 2 to 1...etc...

I have it all implemented except for the thinning of call to al_draw_line
it would make it more complicated and im not sure it is needed...

not that complicated

now I need to ensure the last point is not skipped...


int mw_p[10000][3] = {0};
struct mw_state
{
   int num_points;
   int cycle_total;
   int cycle_tally;
   int default_color;
   int c1_val;
   int c1_col;
   int c2_val;
   int c2_col;
};

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t ms1, int x, int y)
{
   struct mw_state* ms = (struct mw_state*) ms1;
   if (ms->num_points < 10000)
   {
      // get color from cycle
      int col = ms->default_color;
      int mod = ms->cycle_tally++ % ms->cycle_total;
      if (mod < ms->c1_val) col = ms->c1_col;
      if (mod < ms->c2_val) col = ms->c2_col;

      // always set these, in case we get to the end and the point is skipped beacuse of duplicate colors
      mw_p[ms->num_points][0] = x;
      mw_p[ms->num_points][1] = y;

      // should i add this point?
      if ((ms->num_points == 0) || (col != mw_p[ms->num_points-1][2])) // if first point, or color different from previous
      {
         mw_p[ms->num_points][2] = col;
         ms->num_points++;
      }
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, float thickness, int cycle_total, int default_color, int c1_val, int c1_col, int c2_val, int c2_col)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   struct mw_state ms;
   ms.num_points = 0;
   ms.cycle_total = cycle_total;
   ms.default_color = default_color;
   ms.c1_val = c1_val;
   ms.c1_col = c1_col;
   ms.c2_val = c2_val;
   ms.c2_col = c2_col;

   al_draw_soft_line(&v1, &v2, (uintptr_t)&ms, mw_FirstFunction, mw_StepFunction, mw_DrawFunction);

   // ensure last point was not skipped, due to duplicate color
   mw_p[ms.num_points][2] = mw_p[ms.num_points-1][2];
   ms.num_points++;


   for (int i=1; i<ms.num_points; i++)
   {
      int x1 = mw_p[i-1][0];
      int y1 = mw_p[i-1][1];
      int x2 = mw_p[i][0];
      int y2 = mw_p[i][1];
      int c =  mw_p[i][2];
      al_draw_line(x1, y1, x2, y2, mC.pc[c], thickness);
      //printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
   }
}

that was the final iteration...now try it in action!!

see how long it takes...
it is literally 1000 times slower....

plot time: 0.000210   lines drawn:152
plot time: 0.227604   lines drawn:156

I commented out the drawing part...
its not the drawing part, its the call to soft line...

this is useless, but at least now I know it

I just wasted 6 hours on this...

can I make my own code that will do it better?


pass it 2 vertexes
and a span like this:

   int c0_len;
   int c1_col;
   int c1_len;
   int c1_col;

it will create an array of points

point 0 = vertex 1
next point

what math will you use?

total x span
total y span
total length

length of span / color_span = divider

divide xspan and yspan by divider to get incs

do incs and add vertex points...

this is my first hacked together implementaion and it works...
before I go any further, speed test it....


void mw_draw_line2(int x1, int y1, int x2, int y2, float thickness)
{
   int color_span = 10;

   double line_xspan = x2-x1;
   double line_yspan = y2-y1;
   double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

   double div = line_span / color_span; // number of spans

   double xinc = line_xspan / div;
   double yinc = line_yspan / div;

   int xa = x1;
   int ya = y1;

   int xb = xa+xinc;
   int yb = ya+yinc;


   int c = 15;

   while (xa < x2)
   {
      al_draw_line(xa, ya, xb, yb, mC.pc[c], thickness);
      if (c == 15) c = 10;
      else if (c == 10) c = 15;
      xa+=xinc;
      ya+=yinc;
      xb+=xinc;
      yb+=yinc;
   }
}


plot time: 0.000283   lines drawn:156


I'm back baby! as proof of concept it works and is just as fast as the al_draw_line...

now clean it up....

what if I kept the remainder of the color shift for the next line, that would make the graph look awesome...

I could keep a static int 'distance travelled' and use mod for the cycling repeats

3 colors, just like last one

this will mean a major rewrite of how I do the getting of lines..

it is so simple now because the span is always the same

8 red
3 blue
4 yellow


get inc from main period (14)
get inc from main to 2   (3)
get inc from 2 to 3      (4)

distance_travelled

start with the args...
 int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col))

I have a beautiful three color version working, but no carry over for color shift

plot time: 0.000990   lines drawn:156
plot time: 0.000983   lines drawn:156
plot time: 0.000986   lines drawn:156

now it takes almost 1ms...should I be worried?

it depends on how small the color line segments are


now how will i make this work in the plot? how will I keep track of color?

negative values for color?

2 values for color?

if second one is 0 just draw normally






if (series[s].color2 == 0) al_draw_line(ox, oy, x, y, mC.pc[series[s].color1], 1.0);
else                       mw_draw_line(ox, oy, x, y, 1.0, 8, series[s].color1, 10, series[s].color2, 0, 0);

wait how??



I think I do want to implement the color shift across lines...when lines are too short, sometimes they dont show at all...


when I zoom in and get more color segments it really slows down...

do all lines draw every time? yes

try thinning....

did the test for x_axis min...works but i want to draw a line to the first offscreen data points

mak a function to get that....

get lowest x and highet x index on screen...
for each series
cycle the dat

that is done...

can I make a way to adjust the color shift span based on size?
I also could make the color shift carry over...

add clicking on series legend....
put series legend in y axis lineup...??
what order? can I assume...

now I want to try the color shift carry over


remainder as a fraction of position in the total color cycle...

maybe there is an easier way...


startxy endxy

get a unit for 1 pixel diagonally converted to x and y

then I can pick any spot on the line and do x,y

then start drawing the line sequence before the actual line

seg1
get ab_positin
static double line_color_offset = 0;
find un


I have finally done it, after much, much work....



20230108 sunday morning

I have the multi-colored line thing working,
the complicated part was the bit where I keep the color sequence going over multiple calls.
this was important so that a graphline made of short segments has a consistant color pattern
and doesn;t just restart the pattern for every line.

to do today...



pop up menu to adjust stuff on series legend, like line size.
config screen that stays overlaid while you change things and see immediate results

move position of mouse over box...done
make only one call to process input and draw
maybe don't redraw every frame, only when changed

when is draw called on its own??
a few times when adjusting things...

when is proc_input called...only externally
added draw to proc_input...seems to work
I still call draw() every frame...

pop up menus...made one for series and cleaned up a bit...

series_legend...

need to make it to fit with all...
series_legend_type
0 autofill
1 8 player array

why does not having at least 1 series initialized cause crash?
range is set to zero and enforce range loops forever
fixed it with an error message if no data
I just need to make sure to set up at least one series when loading data...

or call mG[0].set_series_legend_type(0);
and auto detect...done...

make it so that any arbitrary series can be turned on and off..done...

now do I even need a special mode for type 1...yes...

now on to the big one:
figure out why with short color sequences, especially at the end I have gaps before the first line

what I have discovered is that the color wrap does not work if the end occurs in the first sequence


actually it never works at all...
the next lines always start somwhere in segment 0


where do I use store and use lco?
store it outside the call, the call uses and modifies it

fixing lco made things better...

does not like when c = 0;

when b = 0, it triggers a call to regular line draw..no its when b_col = 0;


trouble shoot c = 0;



in all my checks I am comparing the x and y values separately,
would it not be easier to somehow check the vector...
that is how it is specified...
10 vector units of one color, 5 of another

line is 100 vector pixels

0-9 are one color

10-14 are another

then convert those to x and y at the very last step...

this sounds a lot easier....


I have xa ya xb yb....
I want za and zb, each is just the number of pixels we are on the current line

start:

za = 0; // or previous color shift index
zb = za + c0_val;
do line checks

if (zb < 0)           // off line completely
if (za > line_length) // off line completely

else
if (za<0) adjust za to zero
if (zb>line_length) adjust to line length.

that did not take very long...

test...

c = 0
a = 0
b = 0

all work fine... but the total cannot be zero....
patched into the graph...

now lets make bandwidth graph do its thing

that took like 10 minutes...wow...


now lets do the other one...

client sync actually has 3 graphs...
active
sync
chase

not only that, it has 8 players * 3 graphs

this should be fun...
do three different graphs

0 active
1 sync
2 chase

OK that all works, but now I need to customize the graphs
default values are nice, but I want more control...

like on the active graph, I want to set and lock the y ranges...


now I want to slave the x ranges to a different graph


x_axis_slave

100 slave to 0
101 slave to 1...etc..

where to check...proc x scroll bar...done

now I also need to make sure plot_x1 lines up for all slaved plots...
still need to make these work together


make a copy of original bad method in note then erase it//done

try a version with only 2 colors to see if its faster...less segements by 1/3 but not faster...













/*
original bad mnethod, actually the second....

// returns 1 if end adjust...
int check_and_draw(double x1, double y1, double x2, double y2, double xa, double ya, double xb, double yb, double line_xinc, double line_yinc, int col, float thickness, int &segments_drawn, int &lco)
{
   char t[1024] = {0};
   sprintf(t, "\n");


   int skip = 0;
   int start_adj = 0;
   int end_adj = 0;

   // these checks mean that the segment is entirely not on the line
   if (((line_xinc > 0) && (xb < x1)) || ((line_xinc < 0) && (xb > x1))) skip = 1; // xb before line start
   if (((line_xinc > 0) && (xa > x2)) || ((line_xinc < 0) && (xa < x2))) skip = 2; // xa after line end
   if (((line_yinc > 0) && (yb < y1)) || ((line_yinc < 0) && (yb > y1))) skip = 1; // yb before line start
   if (((line_yinc > 0) && (ya > y2)) || ((line_yinc < 0) && (ya < y2))) skip = 2; // ya after line end

   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (((line_xinc > 0) && (xa < x1)) || ((line_xinc < 0) && (xa > x1))) start_adj = 1; // xa is before line start
      if (((line_yinc > 0) && (ya < y1)) || ((line_yinc < 0) && (ya > y1))) start_adj = 1; // ya is before line start

      if (((line_xinc > 0) && (xb > x2)) || ((line_xinc < 0) && (xb < x2))) end_adj = 1; // xb is after line end
      if (((line_yinc > 0) && (yb > y2)) || ((line_yinc < 0) && (yb < y2))) end_adj = 1; // yb is after line end

      if (start_adj)
      {
         sprintf(t, "start_adj\n");
         xa = x1;
         ya = y1;
      }
      if (end_adj)
      {
         int xlo = abs(x2-xb);
         int ylo = abs(y2-yb);

         if (xlo>ylo) lco = xlo;
         else         lco = ylo;

         sprintf(t, "end_adj - lco:%d\n", lco);
         xb = x2;
         yb = y2;
      }


      printf("%s   drawn at xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f\n", t, xa, ya, xb, yb);


      al_draw_line(xa, ya, xb, yb, mC.pc[col], thickness);
      segments_drawn++;



   }

  // if (skip == 2) end_adj = 1;

   return end_adj;
}



int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
  // printf("mw_dl x1:%f y1:%f x2:%f y2:%f\n", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion

   int segments_drawn = 0;

   if (c1_col == 0) al_draw_line(x1, y1, x2, y2, mC.pc[c0_col], thickness);
   else
   {
      int color_span = c0_val + c1_val + c2_val;
      printf("\nlco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span

      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_span != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         // one unit of these are one unit of vector move
         double line_xinc = line_xspan / line_span;
         double line_yinc = line_yspan / line_span;

         int section = 0;

         while (!done)
         {
            printf("\nSection:%d\n", section);


            // draw first segment
            double xa = x1 + ((section * color_span) - line_color_offset) * line_xinc; // start position for drawing
            double ya = y1 + ((section * color_span) - line_color_offset) * line_yinc;
            double xb = xa + c0_val * line_xinc;
            double yb = ya + c0_val * line_yinc;

            printf("1st segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
            if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = color_span - c1_val - c0_val - lco;
            }
            if (!done)
            {
               // draw second segment
               xa = x1 + ((section * color_span) - line_color_offset + c0_val) * line_xinc; // start position for drawing
               ya = y1 + ((section * color_span) - line_color_offset + c0_val) * line_yinc; // start position for drawing
               xb = xa + (c1_val) * line_xinc;
               yb = ya + (c1_val) * line_yinc;
               printf("2nd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
               if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c1_col, thickness, segments_drawn, lco))
               {
                  done = 1;
                  line_color_offset = color_span - c1_val - lco;
               }
               if (!done)
               {
                  // draw third segment
                  xa = x1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_xinc; // start position for drawing
                  ya = y1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_yinc; // start position for drawing
                  xb = xa + (c2_val) * line_xinc;
                  yb = ya + (c2_val) * line_yinc;
                  printf("3rd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
                  if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c2_col, thickness, segments_drawn, lco))
                  {
                     done = 1;
                     line_color_offset = color_span - lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}
*/

good method....




int check_and_draw(double x1, double y1, double line_length, double line_xinc, double line_yinc, double za, double zb, int col, float thickness, int &segments_drawn, int &lco)
{
   int debug_print = 0;
   char t[1024] = {0};
   sprintf(t, "\n");
   int skip = 0;
   int end_adj = 0;
   // these checks mean that the segment is entirely not on the line
   if (za > line_length) skip = 1; // za after line end
   if (zb < 0)           skip = 1; // zb before line start
   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (za < 0) // za is before line start
      {
         if (debug_print) sprintf(t, "start_adj\n");
         za = 0;
      }
      if (zb > line_length) // zb is after line end
      {
         lco = line_length - zb;
         if (debug_print) sprintf(t, "end_adj - lco:%d\n", lco);
         zb = line_length;
         end_adj = 1;
      }
      double xa = x1 + za * line_xinc; // convert to screen coordinates
      double ya = y1 + za * line_yinc;
      double xb = x1 + zb * line_xinc;
      double yb = y1 + zb * line_yinc;
      if (debug_print) printf("%s   drawn at za:%3.0f zb:%3.0f\n", t, za, zb);
      al_draw_line(xa, ya, xb, yb, mC.pc[col], thickness);
      segments_drawn++;
   }
   return end_adj;
}

int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
   int debug_print = 0;

   if (debug_print) printf("\nmw_dl x1:%3.1f y1:%3.1f x2:%3.1f y2:%3.1f ", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion
   int segments_drawn = 0;

   int color_span = c0_val + c1_val + c2_val;
   if ((color_span < 1) || ((c1_col == 0) && (c2_col == 0))) al_draw_line(x1, y1, x2, y2, mC.pc[c0_col], thickness);
   else
   {
      if (debug_print) printf("lco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span
      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_length = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_length != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         double line_xinc = line_xspan / line_length; // one unit of these are one unit of vector move
         double line_yinc = line_yspan / line_length;
         int section = 0;
         while (!done)
         {
            if (debug_print) printf("Section:%d\n", section);
            double section_z_start = ((section-1) * color_span) - line_color_offset;

            double za = section_z_start;   // start position for drawing 1st segment
            double zb = za + c0_val;
            if (debug_print) printf("1st segment za:%3.0f zb:%3.0f ", za, zb);
            if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = lco - c2_val - c1_val;
            }
            if (!done)
            {
               za = section_z_start + c0_val;   // start position for drawing 2nd segment
               zb = za + c1_val;
               if (debug_print) printf("2nd segment za:%3.0f zb:%3.0f ", za, zb);
               if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c1_col, thickness, segments_drawn, lco))
               {
                   done = 1;
                   line_color_offset = lco - c2_val;
               }
               if (!done)
               {
                  za = section_z_start + c0_val + c1_val;   // start position for drawing 3rd segment
                  zb = za + c2_val;
                  if (debug_print) printf("3rd segment za:%3.0f zb:%3.0f ", za, zb);
                  if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c2_col, thickness, segments_drawn, lco))
                  {
                      done = 1;
                      line_color_offset = lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}




add pop up menu to plot area or series legend to thin number of segments or change to solid color.
changing from a segmented line to solid only make a small change

show hide segments drawn and time taken..




amke y xais arrange customizable...

if axis slaved, make it so the plot_x1 follows master
gridlines and label are always anchored to plot

on slaves, don't show x axis legends



remove y scrollbar for active...

put dsync on bottom and make it the master

active on top

make a y axis label type for active

slave series legend...just copy x_axis_slave

thin out player active....done

make it so that you can still see series legend on slave and change things, but only master can change active...

make it so that number of points on series legend is optional....done
also plot time optional

hide and show series legend from main plot popup menu...done

main plot pop up menu..done


fix the double drawing nonsense on the scroll bars....

remove from draw because proc calls draw...
double shit is gone, but now I have no mouse cursors

they are fixed but the mouse over is done....

make nice colors match...done


make units from pointer data and stuff work nicely wit ha few new types



I have a bigger issue...

I cant quite figure out in what order to do all the things....

I have moved everything in the draw function....

but that is bad because sometimes I call that recursively when moving stuff...


I need to separate the draw from the input....

also what about the checking of variables??


lets start with the most obvious

draw_plot() and
process_mouse_on_plot() (which also draws on plot)

obviously the plot area has to be drawn first, then the stuff on top, or it will never be seen

I should merge these two....
and have a draw only option for when I have call to it recursively

void proc_plot_area(int draw_only)
{
   draw

   if ()!draw_only)

   proc mouse on graph

}


do the same with scrollbars

have one entry point and an option to draw only...

then have draw itself have an option to draw only

void mwGraph::y_axis_proc_scrollbar(void)
{
      int sb = y_axis_draw_scrollbar(0);

now I have one entry point:
mG[].proc_graph(void)

all it does is call:
draw_graph(int draw_only)

and that calls:

x_axis_get_size_and_arrange_pos();
y_axis_get_size_and_arrange_pos();
enforce_axis_limits();

al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mC.pc[title_frame_color+224]); // erase plot background
al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mC.pc[title_frame_color], 2); // frame plot

x_axis_draw();
y_axis_draw();


x_axis_proc_scrollbar(draw_only);
y_axis_proc_scrollbar(draw_only);

proc_plot_area(draw_only);

draw_title(0);
draw_series_legend();

this seems to work pretty good

can I refine it? yes I can...

void mwGraph::draw_graph(int draw_only)
{
   al_show_mouse_cursor(display);
   if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2))
      al_set_system_mouse_cursor(display, ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT);

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


it looks really good now....

make nice title and colors for bandwidth..done
make bandwidth have option for 2 graph (tx and rx)..done
make a way to slave y axis range also...done...

make units for all types look good...

y axis
tx = 1
rx = 2
dsync = 3
FPS = 4

done....


add reset all to plot menu

add resize slider in between graphs...done...added to bandwidth...

make is so when x_axis_slave, can't even slide x axis a little bit...done

make it so if y legend does not fit on screen, auto set to smaller font...


make a way to not draw x_axis labels and reclaim space....

I think I might need to properly separate gridline and labels
right now I kind of lump them together

I still want to draw them together, but the variable used to control whether tey are draw or not are overly complicated


this is what I have now:
int  x_axis_label_draw_on;
int  x_axis_label_font;
int  x_axis_label_draw_size;
int  x_axis_label_tick_size;
int  x_axis_label_text_size;
int  x_axis_label_text_draw;
int  x_axis_label_color;

change to:
int x_axis_grid_draw_on
int x_axis_grid_color
int x_axis_grid_labels_draw_on
int x_axis_grid_labels_font
int x_axis_grid_labels_color
int x_axis_grid_labels_draw_size
int x_axis_grid_labels_tick_size
int x_axis_grid_labels_text_size


this is done and it works way better

add one more...
int x_axis_grid_draw_to_top_of_other_graph...why bother...

removed the lock, unlock, auto button...

now clean up the y axis the same way...

old
int y_axis_label_draw_on;
int y_axis_label_font;
int y_axis_grid_label_draw_size;
int y_axis_label_tick_size;
int y_axis_label_text_size;
int y_axis_label_text_draw;
int y_axis_label_color;

new
int y_axis_grid_draw_on
int y_axis_grid_color
int y_axis_grid_label_draw_on
int y_axis_grid_label_font
int y_axis_grid_label_color
int y_axis_grid_label_draw_size
int y_axis_grid_label_tick_size
int y_axis_grid_label_text_size

fixed some weirdness in void mwGraph::y_axis_get_size_and_arrange_pos(void)
now it's much simpler

add reset to main menu...done...



add x_axis_top_graph_gridline...done...

now it matter in what order thing are drawn in
the graph that draws the gridlines, needs to be last or the other plots will overwrite them
also when thet are draw, they draw on top of everything else....
not sure if this was a good idea...removed....


how about the mouse position on any graph is sent to the others so they can show that x position on their graph too...

how will I go about linking them?

make a series number that they can share
if the mouse is diplaying a point, send that to all others in the same series

all others look for shared values when they don't have mouse...

each graph could have a

if graph does not have the mouse, they are listening
if graph does have the mouse, they sending


all I need to link is x_cursor_pos...

any of the linked ones can set all other linked ones...


code:
if mouse on plot, set x_cursor_pos on all others..
if mouse not on plot read x_cursor pos...

this could work...

vars

int linked_group_id;
double x_axis_cursor_pos;

ok fine, try it




x_axis_cursor_pos = -99999;

if mouse is on graph, but not on plot set all local and remote to dont show value

if mouse is not on graph at all, read and use value from local

if mouse is on plot, set local and send to all linked

have a common place to draw....



i need a function that you pass it only an x position
and you get:

0 = no data at that x point
1 = scaled y position at that point
2 = closest point (less tham threshold)

this is getting complicated....

i could have mutiple y matches for x at the destination

keep it simple...

do only the line....done

         else // show mouse position
         {
            col = 15;
            x = mI.mouse_x;
            y = mI.mouse_y;
            draw_point_data(x, y, mx1, my1, col, f3, -1);
         }
         if (linked_group_id)
         {
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = x;
         }


      } // end of mouse on plot area
      else // mouse not on plot area
      {
         if ((mI.mouse_x > graph_x1) && (mI.mouse_x < graph_x2) && (mI.mouse_y > graph_y1) && (mI.mouse_y < graph_y2)) // not on plot, but on graph
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = 99999; // set all linked cursors to not valid

         if (x_axis_cursor_pos > -99998)
            al_draw_line(x_axis_cursor_pos, plot_y1, x_axis_cursor_pos, plot_y2, mC.pc[15], 0); // draw if valid
      }



that is done...now add it to bandwidth graph...done....



test graph on weak clients...it seems really slow  can take up to 800ms to plot
in that case I could automatically reduce the x range....


is there anything else in the logs I could graph?




make a client sync graph from the clients point of view:
fps chase
dsysnc
ping
what log line am I basing this on?

the server only has data when the client sends stak but the client should have much more data than that...


it looks like the client only adjust timer when rxing stdf....

I thought it would happen more often...but what does it have to sync with?

I suppose we could use ping...

I want to do a ping vs dsync from the client's pov


there are three things on the client...

ping
sync target
acually sync

I think a graph of those might be insightful

where does it happen and what are the vars again??


in client_fast_packet_loop:
players1[active_local_player].ping = t2 - t0;
ping_array_add(players1[active_local_player].ping);
I should add a log entry for this...

then what?

void client_timer_adjust(void)
{
   int p = active_local_player;
   double dsync = players1[p].dsync - players1[p].client_chase_offset; // adjust for target offset
   double fps_adj = dsync * 100; // make the change bigger

   float fps_chase = frame_speed + fps_adj;
   if (fps_chase < 10) fps_chase = 10; // never let this go negative
   if (fps_chase > 70) fps_chase = 70;
   al_set_timer_speed(fps_timer, ( 1 / fps_chase));
   players1[p].client_chase_fps = fps_chase;
}




where is offset calculated...

in ping array add....

places for log inputs:
- stdf rx (dysnc, fps_chase) this is already done...
- add ping... (ping_curr, ping avg, offset)


add one in timer adjust....


36 tmaj // timer adjust
37 cpng // client ping


sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", dsync, players1[p].client_chase_offset, fps_chase);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(36, p, msg);

sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping, players1[p].ping_avg);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(37, p, msg);


OK I have some log lines, now lets make a graph....




I need a way to get value for y axis....


just throw a values and it will know how to print it...

i think I started one of those already....
char* mwGraph::y_axis_get_val_text(double val, int units)


dsync is huge at the start....how about we don't actually use it to set fps until after initial state is received and chase starts....




clean up the number formating stuff+...

int y_axis_type
set for different types

y_axis_type
y_axis_legend
y_axis_units
y_axis_divider

The name you give to legend, should not ever automatically change
however the units may depending on type...

at init:
set name, units name, divider,

now I only have types 1 and 2 that change units
they do that in enforce_axis_limits(5)


all the rest should be handled in:
char* mwGraph::y_axis_get_val_text(double val, int units)

this should not change units, just print formating

type 3 for all ms
type 4 for FPS

check where thet are all set...done...



now what else can I monitor??

on the server, late cdat dropped


d 3-1 30s 1c

e 3-1 at 15s 3-1 ic




why? on my latest test graph, do the 2 graphs not line up vertically?

im guessing something to do with enforce limits.....
can i disable it for x axis on slaves...
made it so that plot can start before data....
this broke scrollbars, now ends are past...
2 ways to fix...
adjust only scrollbar ends to b not past data max...
adjust data max be larger
add new variable data display max and min
set clip...

try set_clip...

also disable slaving of series legend tied to x axis slaving...done


make it so that you can see status of things in menu...
make the main menu do everything
like locking x and y axis and show status of locking...
Y axis: free move / locked / auto range
unlock/lock Y axis
set y ais auto range..

done and it looks way better...

can you also lock x axis?
autoscroll does not make sense for x axis, but lock would be nice so I could zoom and move y without moving x...

I don't think I need menus for scroll bars any more, comment out for now....

added this....

   // min, max, and range for min and max displayable range (used for limits on axis, instead of using data)
   double x_disp_min;
   double x_disp_max;
   double x_disp_rng;
   double y_disp_min;
   double y_disp_max;
   double y_disp_rng;


cleaned up the scroll bar code a lot...





am I drawing scroll bars twice?


proc_plot_area calls

x and y axis_draw
then draws plot

x and y axis_draw call grid and labels, legend and scroll bars
this seems like too much...

where are they arranged?

down the fucking rabbit hole!!

proc_graph -> draw_graph ->

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


this all works but seems overly complicated

gridlines and labels have always had to be drawn before plot...
well...I don't want to separate gridlines and labels...
but they need to be done after old plot is erased and before data is plotted...
make it a part of draw plot??

this is the way it is now:
void mwGraph::proc_plot_area(int draw_only)
{
   al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mC.pc[title_frame_color+224]); // erase plot background
   al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, mC.pc[title_frame_color], 2);         // frame plot

   x_axis_draw();
   y_axis_draw();

   draw_plot_area();

I want to replace
   x_axis_draw();
   y_axis_draw();


with just the labels and gridlines

leaving legend and scroll bars for somehwere else...done...much better now...

bool mouse_on_graph;
bool mouse_on_scrollbar;

done...awesome!!

make x axis use get text...done


still have issues with labels, now the first one less than 0 does not show.....



I'm sure its my rounding function

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 =  nr + (in - tmp);
   if (nr2 < 0) nr2 -= nr; // hack because negatives were rounding too high
   printf("in:%f  nr:%f  nr2:%f\n", in, nr, nr2);
   return nr2;
}

what is it supposed to do?

round 'in' up to the nearest 'nr'

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 = (in - tmp) + nr;
   if (tmp < 0) nr2 -= nr; // hack because negatives were rounding too high
   //printf("in:% 5.1f  out:% 5.1f  tmp:% 3.1f\n", in, nr2, tmp);
   return nr2;
}
this is the fix....nice...
auto reduce legend font if too tall, also clip so it won't exceed graph..done for y and x
make x legend do name and units like y....done

make split bar invisible until mouse over...
remove top padding for graph....


20220110 1:11PM

graph is done....


put chase and ping into main log thing

make sure the other graphs still work nice

separate the load part of each graph
fail gracefully if no data found..


how to check for no data...


I could use
void mwGraph::calc_data_range(void)
yes...but need to set series first...done...

now do the same for bandwidth graph...


erased all the old graph stuff from z_logs.cpp...1500+ lines gone
now the entire z_logs.cpp is around 1500 lines...

made it very easy to load graphs....

from log file viewer:
log_bandwidth_graph(int num_lines, int both);
log_client_server_sync_graph(int num_lines);
log_ping_graph(int num_lines);

from anywhere else:
log_bandwidth_graph(load_log_lines_array_from_static_file("logs/a.txt"), 0);
log_client_server_sync_graph(load_log_lines_array_from_static_file("logs/a.txt"));
log_ping_graph(load_log_lines_array_from_static_file("logs/e.txt"));

I use this function in 4 places:
int load_log_lines_array_from_static_file(const char* f));
it loads:
extern char log_lines[NUM_LOG_LINES][100]; // for log file viewer
extern int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer

this makes things much simpler...



now clean up the other 2 graphs:

bandwidth
make nice splitter
why no x gridlines on upper
done...

client sync...looks good...

now the only thing left is the three way splitter...done

bug... when x axis is locked, disable x scroll bar...done....

we are way further along now.....

can I call the graph thing done? yes...

now what?

log:
when the server gets late cdats?
the current s1 and s2 values on the server...
when clients base is reset

how about some code profiling...

draw_time
move time
decompress time

I am going to make the busiest level I can imagine...

how do I get the default menu back on level editor after I come back...done...

bug on graph.. y axis scroll bars draw off their range. it was a bug I inadvertantly introduced when making type 3 for active...fixed...



what do I have for my timer thing...

I have 10,000 of these

struct timestamp
{
   int frame0;
   int frame1;
   int frame2;
   int type;
   double t0;
   double t1;
   double t2;
};


how was i supposed to use them?

void add_timestamp(int type, int f1, int f2, double t1, double t2)
{
   if (timestamps_index < 9998)
   {
      timestamps[timestamps_index].frame0 = mwPS.frame_num;
      timestamps[timestamps_index].frame1 = f1;
      timestamps[timestamps_index].frame2 = f2;
      timestamps[timestamps_index].type   = type;
      timestamps[timestamps_index].t0     = al_get_time();
      timestamps[timestamps_index].t1     = t1;
      timestamps[timestamps_index].t2     = t2;

      timestamps_index++;
   }
}

            add_timestamp(1, 0,0,0,0);
            timestamp_frame_start = al_get_time();

            proc_timer_adjust();

            proc_scale_factor_change();

            if (ima_server) server_control();
            if (ima_client) client_control();

            proc_player_input();
            proc_game_moves_array();

            if (players[0].level_done_mode) proc_level_done_mode();
            else
            {
               //add_timestamp(5, 0,0,0,0);
               move_frame(0);
               //add_timestamp(6, 0,0,0,0);
            }

            if (players1[0].server_send_dif) server_send_stdf();



//            if (get_delta(mwPS.frame_num,   3, mwPS.frame_num,   4, res)) printf("time in draw: %5.1f us\n", res*1000000);
//            if (get_delta(mwPS.frame_num,   1, mwPS.frame_num,   2, res)) printf("time in move: %5.1f us\n", res*1000000);
//
//            if (get_delta(mwPS.frame_num-2, 1, mwPS.frame_num-1, 1, res)) printf("total fram time: %5.1f us\n", res*1000000);




now that I have the mwPS.frame_num inc at the very start of every frame it should make timing easier.


I don't know why I have multiple frame numbers in the structure

most of the time I just use the current frame number and the current timestamp


so lets do it...

take some times and plot them...

I want to have a log entry every frame

how many timestamps per frame?

lets say 10, that would give me 1000 frames or 250s or just over 4 min...

that's a good start

time for a new log entry...44

holy shit that was fast!
I got some profile timestamps, made a new log entry and made a dual graph to view them both: draw time and move time
It only took about 1H to do all that, because of all the framework I have in place...nice...

I can't wait to profile more things....

but I am going to do a push, then get a hot drink...

20230110 10:15PM


do a timer for server send stdf
one for each client...or all together?

they will all be on the same frame, but with different player numbers

I can probably do this one in line, without the timer struct...

use tag 45...

more data...like was the base reset? how many packets...

[45][1][169]tmst [1.368000] [0] [835] [1]
[45][1][172]tmst [1.355800] [0] [792] [1]
[45][1][175]tmst [1.369900] [0] [800] [1]
[45][1][178]tmst [1.347400] [0] [704] [1]
[45][1][181]tmst [1.367600] [0] [804] [1]
[45][1][184]tmst [1.369800] [0] [799] [1]

I could plot all these on the same graph if /1000 for 3...do it...

20230111 7:41AM


I want to make a different, easier way to get these profiling timestamps into a graph..


Maybe I could tag each one like td:[] tm:[] stdf:[]

then I will need a tag reader than can get the text before...

I can have multiple log file lines that all have the code 45 tmst

they can all go on the same graph beacuse they all have the same units

I have the very basic framwork in place....


I want to make a new gui element.
I will act exactly like button toggle but will look different
[] - name


I have the logging options page looking really good...
what other pages?

sound, color, splash screen

controllers

netgame options

make multiple tabbed pages...

this should be fun

in the end it will be so much easier to add new options, so many more that I have not even thought about....

make it look good...


I think I have all the functionality for controls except for set indivual

now I need to make it look good..


make the list of keys more centered but still left justified
add a button to the left of each key, 'new' which prompts to set that one control

I want my own function to redraw all keys....done...

what is the maxiumun text length of key_names[]? 11 PRINTSCREEN
make it so that this displays nicely....
press new control is 17....

page for controllers is setup and looks great!!

next, nextgame??
all the controls are in place and working...now make it look good...


display server name and give a text description

Server Name: ....

Clients must have the server name or IP address set here.


OK...config page for netgame is done...


This is looking very nice...how are you going to patch it into the game_menu?
I think I should have an overall larger background and title:

Like 'Configuration'

make it a fixed width of 400,400


do I need a large size for the frame, tabs, and title??

Yes, obviosly....

OK what am I going to name them?

Do I have an actual minimun size for the useable pages?

can I go up from there??

sure why not?

add tab height and title height

that should do it...


I don't know where am going to patch it into the menu...
it seems like it is already pretty busy...

put it on the options menu for now and have a hotkey to bring it up any time from any menu....ok...
CTRL SHIFT O


i like it....

when it gets full I will need to have a second row of tabs...


I have changed my mind...


I want to start with the full outer size and then shrink it as I move in...

what are my varaible going to be called?


this is all I have for now:



   int cfp_x1 = 200;
   int cfp_y1 = 200;
   int cfp_x2 = 600;
   int cfp_y2 = 600;
   int cfp_txc = cfp_x1 + (cfp_x2 - cfp_x1) / 2;



I think I will keep these vars...

entire thing:
cf_x1
cf_w
cf_x2
cf_y1
cf_y2
cf_h

then I will figure out the borders, tab height, title height, and then finally set:

cfp_x1
cfp_w
cfp_x2
cfp_y1
cfp_y2
cfp_h

for the display area of the pages


goddamn this looksg good...


what else can I add?

sound
color
splash screen


today:
finish basic page..done
make advanced page
add help buttons to pages...
think about re-arranging menus to make simpler

do I have enough tabs??..yes


what wil go on advanced?
speed
disable timed demo mode...
show hysteris box...

what is left on the options menu that I don't have in config pages?

   strcpy (global_string[8][3], "Netgame Options");
   strcpy (global_string[8][4], "<-Change Color->");
   strcpy (global_string[8][5], "Controller Setup");
   strcpy (global_string[8][6], "Speed:40fps");
   strcpy (global_string[8][7], "Sound:Off");
   strcpy (global_string[8][8], "Sound Effects Volume:9");
   strcpy (global_string[8][9], "Sound Track Volume:9");
   strcpy (global_string[8][10], "Logging Options");
   strcpy (global_string[8][11], "Splash Screen:ON");
   strcpy (global_string[8][12], "Save Demo");
   strcpy (global_string[8][13], "Run Demo");
   strcpy (global_string[8][14], "Configuration Pages");
   strcpy (global_string[8][15], "end");

speed
save demo
run demo

I could have a tab just for demo...
run
save
disable timed demo
options for auto save

yes, do this...then options menu can go away totally and be replaced with config pages on main menu....

Maybe it could be renamed to 'Settings'...that seems more generic and apt and standard...done

here is the thing...

running demo from these pages is not as simple as just calling a function...

we are in menu, then in config, how to get back to where the game runs??

we have to:
- set next program mode
- quit config
- quit zmenu


I guess this all depends on where config_pages is called from...

lets make sure it is always called from zmenu...
then we can figure out how to handle return...
called from:
args
zmenu CTRL O
game_menu options 14

for now just do CTRL O

if I can make config pages return something...

maybe the zmenu was not better choice..another layer deep...

make the CTRL O call option 14 then deal with it there for now in game menu

maybe I am doing this wrong...maybe config pages ahould be another program_state

something that I can return to, like command line and zmenu

that seem a little less hacky...

from menu, leave menu and do configpages..from there do run games...

   if (program_state == 3) config_pages();  // this blocks


ok it gets there, but how does it get back??

replace OPTIONS MENU with SETTING and then it will come back there...


coming back from playing demo does not come back to config, it come back to menu...why??


it seems like a lot of things set old_program_state...too many


like for instance it is set when rungame_key_check exits...it is set to 1...why?  how does it know what called it?

where are the places it should be set?


0 when delared
then if called from command line it will know where to go

1 when starting game_menu

2 when starting demo mode

3 when starting config...

those are the only places it should be set....

it is used when leaving a running game to determine where to go back to....




This is what actually is in place:

int old_program_state = 1;

when game_menu() starts
old_program_state = 1;



when demo_mode loads a level and plays it
new_program_state = 14;
old_program_state = 2;

if demo mode fails to load level
new_program_state = 1;
old_program_state = 1;


when config starts rungame
new_program_state = 14;
old_program_state = 3;

when config ends with ESC
new_program_state = 1;
old_program_state = 1;

rungame_key_check
new_program_state = 1;
does not set old....


OK this is looking a little better...


start game, start config, rungame from file...

exit with any key..goes back to config...good

exit with ESC key..skips past config to menu...fix this
added this in rungame_key_check to eat ESC
while (mI.key[ALLEGRO_KEY_ESCAPE][0]) proc_controllers();

now it does stimp and goes back to config....
from there you can run another file...

this all works great...

but when you leave config for menu, stimp is called again...
happens every time config to menu....fixed
if (program_state != 3) stamp();


that was the last thing from options menu...time to retire it....

and at the same time...call it settings...
settings_pages


top_men_sel == 7 // settings

CTRL SHIFT O from zmenu as a shortcut

commented out all option menu stuff in game menu

returns to setting selection when leaving config..

wow! all of this works so good...

I will miss wacthing the title screen change immediatley when changing player color....


should I alway have that background behind settings_pages?yes
the only other possible thing would be a partially played demo level....
do it...
call frame and title and make sure settings is centered also....done...

you know what would be amazing?
If I could center the title 'Settings' on the menu item 'Settings'
how do I know where that is?
set_map_vars()
done....
now can I show the menu text only....done

now hide the mouse when leaving settings..done

rename...done...

now make that goddamn demo_mode time able to be disabled



what variables?


demo_mode_countdown_val;
demo_mode_countdown_reset;

demo_mode_enabled

int demo_mode_enabled = 1; when declared

then set to zero:
if resume allowed
if any menu key is moved
if demo mode times out and starts


i suppose I could read this value from config file

default it to 1 and if player turns it off in config...

the problem is...any time config file is read, it gets turned back on...

make a separate config file varibale and only use it to set the global one once at startup..

this is getting confusing!!

demo_mode_config_enable

extern int demo_mode_config_enable;
now use it in initial_setup() to set  demo_mode_enabled
this is all done!!!

next, demo mode....
when trying to exit, it quits the current level and immediately plays next....

in rungame_key_check:

      new_program_state = 1;
      if (old_program_state == 2) old_program_state = 1; // don't send back to demo mode if cancelled

this seems to have fixed it....



now, does it work from settings....yes, but it comes back to menu, not settings...big deal....
when demo mode starts it sets old_program_state to 2..in this way we do not know what started demo mode
it could be menu or settings

do I want yet another variable to track this?
some humor 'older_program_state'

used only when starting demo mode
3 from settings
1 from menu

then when demo mode is cancelled from rungame_key_check it can set the appropriate place to return to...

new_program_state = 1;
if (old_program_state == 2) old_program_state = older_program_state; // don't send back to demo mode

done and it works perfectly....

now to make demo tab look nicer.. looking pretty good!!!


now how many things call zmenu? only one: top
old ones:
options
logging
netgame
controller



put speed on advanced tab...done

also by default make the speed locked, disabling function key
also speed is never saved to config file

add DEMO MODE overlay transparency option to demo tab...and config file...done

add other hysteris mode stuff somewhere


now that I have everything from option menu on the settings page....

I have so many more things I want to put there....

but first...

lets see what it would take to get more tabs....

and a second row....

maybe an optional second row...

erased options menu...now game menu is <70 lines

going through code and removing unneeded references to global_string....


why don;t I make a struct for each tab...then make an array of structs
done and its looking good...



I want to see how hard it is to draw a filled polygon with allegro primitives....

float v[4][2] = {0};

v[0][0] = 100;
v[0][1] = 100;

v[1][0] = 100;
v[1][1] = 200;

v[2][0] = 200;
v[2][1] = 200;

v[3][0] = 200;
v[3][1] = 100;

al_draw_filled_polygon(*v, 4, mC.pc[14]);

this is all it takes....

now use that to draw tabs....done...

that looks so much better...


now what?

rename the logging netplay things and add more....


now I have game_menu down to 25 lines!!!

// z_game_menu.cpp
#include "pm.h"
void game_menu(void)
{
   old_program_state = 1;
   if (!splash_screen_done) { splash_screen(); splash_screen_done = 1; }
   if (!resume_allowed) load_level(start_level, 0);
   if (top_menu_sel < 3) top_menu_sel = 3;
   while (top_menu_sel != 1)
   {
      top_menu_sel = zmenu(7, top_menu_sel, 10);
      if  (top_menu_sel == 1)  { program_state = 0;                                           return; } // exit
      if  (top_menu_sel == 2)  { visual_level_select(); top_menu_sel = 3;                             } // visual level select
      if ((top_menu_sel == 4) && (resume_allowed)) { new_program_state = 13;                  return; } // resume game
      if  (top_menu_sel == 3)  { new_program_state = 10;  top_menu_sel = 4;                   return; } // start new game
      if  (top_menu_sel == 5)  { new_program_state = 20;                                      return; } // host network game
      if  (top_menu_sel == 6)  { new_program_state = 24;                                      return; } // join network game
      if  (top_menu_sel == 7)  { new_program_state = 3;                                       return; } // settings
      if  (top_menu_sel == 8)  { play_level = edit_menu(start_level); new_program_state = 10; return; } // level editor
      if  (top_menu_sel == 9)  { new_program_state = 2;  older_program_state = 1;             return; } // demo mode
      if  (top_menu_sel == 10)                                                                help(""); // help
      if (top_menu_sel == 102) if (++start_level > 399) start_level = 399; // start level inc
      if (top_menu_sel == 202) if (--start_level < 1) start_level = 1;     // start level dec
      if (top_menu_sel > 100) { set_start_level(start_level); load_level(start_level, 0); top_menu_sel = 2; }
   }
}



these are the config names:
LOGGING_NETPLAY);
LOGGING_NETPLAY_JOIN);
LOGGING_NETPLAY_PLAYER_ARRAY);
LOGGING_NETPLAY_bandwidth);
LOGGING_NETPLAY_cdat);
LOGGING_NETPLAY_game_move);
LOGGING_NETPLAY_sdat);
LOGGING_NETPLAY_sdak);
LOGGING_NETPLAY_stdf);
LOGGING_NETPLAY_stdf_all_packets);
LOGGING_NETPLAY_stdf_when_to_apply);
LOGGING_NETPLAY_show_dif1);
LOGGING_NETPLAY_show_dif2);


extern int L_LOGGING_NETPLAY;
extern int L_LOGGING_NETPLAY_JOIN;
extern int L_LOGGING_NETPLAY_PLAYER_ARRAY;
extern int L_LOGGING_NETPLAY_bandwidth;
extern int L_LOGGING_NETPLAY_cdat;
extern int L_LOGGING_NETPLAY_game_move;
extern int L_LOGGING_NETPLAY_sdat;
extern int L_LOGGING_NETPLAY_sdak;
extern int L_LOGGING_NETPLAY_stdf;
extern int L_LOGGING_NETPLAY_stdf_all_packets;
extern int L_LOGGING_NETPLAY_stdf_when_to_apply;
extern int L_LOGGING_NETPLAY_show_dif1;
extern int L_LOGGING_NETPLAY_show_dif2;


I want to make this simpler:

variables:
LOG_NET_xxx

config
CLOG_NET

and make them all lower case after the _

replace:

L_LOGGING_NETPLAY_
LOG_NET_

do it: 75 replaced  still compiles


now replace
LOGGING_NETPLAY
CLOG

wait why??
they can have the exact same name, i do it all the time in config..same variable name and config name
OK

replace
LOGGING_NETPLAY
LOG_NET

OK done.. now do lower case for JOIN and PLAYER_ARRAY

ok that's all done too:

demo mode is not on by default...fixed...


keep a list in to do of other things to add to settings....


many of them will require:
- making a global variable
- saving it in config
- making a way to change it in settings

how about 'send stat to console'

made a lot of those....




what do I call the hyst thing?
lakitu
viewport

lets go with viewport

do a global for viewport_type

0 = force to be in the center of the screen all the time, except when near edges of course...
1 = regular hysteresis
2 = slowly changing hysteresis

added these globals:

int viewport_mode = 1;
int viewport_show_hyst = 0;
int viewport_x_div = 8;
int viewport_y_div = 12;


20230213 6:24AM Friday the 13th
I have taken the entire week off work so far, I probably will take today also...
I have gotten a lot done...
what are some of my next plans?

make links to graphs??? from settings..and log_file_viewer..done




settings - add more stuff
program state - clean up and make simpler
see if I can make level done part of program state...




add timers and LOG_TMR tags for the packets related...

how many do I want?

move
draw
stdf send (server only)
dif unpack (client only)
rewind time (client or server)

LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd
first of all, make these global variables, then save in config, then add toggle in setting...all done
now just patch them into the code where log entries are entered...





make options on logs to never save log files....
I am so annoyed when shit gets saved and I dont want it to....


i am thinking of 2 different types of timestamps


one would be used to profile sections of code...

like move, draw, stdf etc....


each will have a tag like

tmst move:[]


then my tagging system will find them all and apply the label to the series.....

I will have as many or as few as I want, and when I run the graph it will automatically show the ones present

the other type of timestamp would show things in relation to frame start...I can think about that later....

I am excited to do this one....

use these to start:
LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd

I want to make global double t0 just to make the code look cleaner


now make a graph....

looking good....

make a us y axis type....already done, but store data as ms...al_get_time * 1000 print wih %0.4f


looking good...

now make this graph so it can be called with its own file select....


then put it on a button in settings....

this looks awesome....

how about saving log when coming back to menu or config, instead of having to quit game..

options:

save log on program exit
save log on game quit
save log on level done
save log manually only
save log now

do it...




I redid all of the config with macro's..
it took a while but it is so much shorter and easier
to do a config value, i need 1 set and one get, before I need 3 for get and 2 for set
I should really test each one to make sure they are working....
erase config file and see!!
looks good...
color does not stick...fixed...


in program_mode 12 - level done

added: if (autosave_log_on_level_done) save_log_file();

this was here:
blind_save_game_moves(1) - level done

this checks to see if autosave is on and labels the save file accordingly...
I guess this is OK

what else calls blind save??


blind_save_game_moves(2) - game_exit
at the end of main...we should change this to when leaving running game...that seems much more useful...

blind_save_game_moves(3) - bad exit

fast_exit and

void function_key_check(void)
{
   if (mI.key[ALLEGRO_KEY_F4][3])
   {
      blind_save_game_moves(3);
      save_log_file();



-----------

log files for now...

put checks for program exit in fast exit and end of main....done...

look for occurances of save_log_file...good

now just find an entry point for leaving a running game...


resume_allowed...no...

when leaving program_mode 11 to 1 or 3

done...




I think all cases ahould be covered now...

occ of blind_save_game_moves();

blind_save_game_moves(3); F4         only if game_exit set
blind_save_game_moves(3); fast exit  only if game_exit set
blind_save_game_moves(2); game quit  only if game_exit set
blind_save_game_moves(1); level done only if level done set

occ of save_log_file()
F4           only if program exit set
fast exit    only if program exit set
end of main  only if program exit set
game quit    only if game_exit set
level done   only if level done set

looking good....





lets try some log tmr and view on graph...nice....

tmst back:[0.0060] lifts:[0.0207] items:[0.5058] enem:[0.0101] ebul:[0.0001] pbul:[0.0001] play:[0.0035] buff:[0.0111] ovrl:[0.1171] flip:[0.1415]
tmst back:[0.0053] lifts:[0.0197] items:[0.5073] enem:[0.0097] ebul:[0.0001] pbul:[0.0002] play:[0.0033] buff:[0.0112] ovrl:[0.1181] flip:[0.1382]
tmst back:[0.0060] lifts:[0.0206] items:[0.5062] enem:[0.0096] ebul:[0.0002] pbul:[0.0001] play:[0.0034] buff:[0.0108] ovrl:[0.1169] flip:[0.1311]

its 150 char

lets log it...



20230114 8:44 AM

working on timestamp logging today....at least for now...

have move and draw done
total and all individual..

now work on graph and pop up values...
show series and accurate units

units done
series name done


I have this stupid bug that is annoying me....

I have text drawing routines I have made that can take either 'font' pristine or 'f3' pixel gosub

I have been making good use of:
al_get_text_dimensions(f3, text, &bx, &by, &bw, &bh);

I have no problems with the width but the bh and by sometimes do strange things...

mostly by

I want to do some experiment with these fonts to see if I can make a solution

I just want my text to line up consistantly

what is the character range?

pristine 32-127
pixel_gosub 32-127


what is the max and min for bx, by, bw, bh


the built in font has all 0 0 8 8...nice

how did stuff not break when I changed to pristine??
why does it still draw with 8 8 like the old one....




int al_get_font_line_height(const ALLEGRO_FONT *f)

font and font0 are 8
f3 is 9??? WTF

looking into it: almost everything I care about in f3 is 5 high
exceptions:
Q - 6
{} () | $ are 7

also all the ones that are bh5 are also by4...this would cover 99% of what I do with them....


so to make some code common.....

do not use al_get_text_dimensions for height...
you can us it for width, that seems to be fine

have my own custom get text_height thing...
for font or font0, always return 0 8
for f3 always return -4 5

void mw_get_text_height(ALLEGRO_FONT *f, int by, int bw)
{
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

this is just craxy enough to work!

what can I do to test it?

make an example that shows the problem...


function that you send a char, font, color, x, y and it prints that in a nice bounding box with 1 pixel border.
then test that funtion with various fonts and text strings....

I think I got it!

2 steps:
- use my function to get text dimensions
- use bx and by when drawing text
this seems to work for all cases

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

void draw_text_in_box(const char* txt, ALLEGRO_FONT *f, int x, int y, int color, int type)
{
   int bx, by, bw, bh;

   if (type == 0) // the regular method
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mC.pc[color], 1);
      al_draw_textf(f, mC.pc[color], x+2, y+2, 0, txt);
   }
   if (type == 1) // use bx, by to offset text
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mC.pc[color], 1);
      al_draw_textf(f, mC.pc[color], x+2-bx, y+2-by, 0, txt);
   }

   if (type == 2) // use my method to force by offset and bh size
   {
      mw_get_text_dimensions(f, txt, bx, by, bw, bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, mC.pc[color], 1);
      al_draw_textf(f, mC.pc[color], x+2-bx, y+2-by, 0, txt);
   }
}


void temp_test(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(mC.pc[0]);

   ALLEGRO_FONT *f = font;

   for (int j=0; j<3; j++)
      for (int i=0; i<3; i++)
      {
         if (i == 0) f = font;
         if (i == 1) f = font0;
         if (i == 2) f = f3;

         draw_text_in_box("Hellg", f, 100, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("Hello", f, 150, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("emmem", f, 200, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("e{3}",  f, 250, 100 + i*20 + j*100, 10, j);
      }
}


lets try it out...

where to put my function...in z_fnx...

fixed draw point...perfect...

now lets go through graph, and fix all.....

basically just search for al_get_text_dimensions

make series legend text x + 1
what if I load that font with no kerning???


it is loaded with no kerning...

force bx for that font?? yes...and bw...remember, this font is suppose to be 8x8

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
    // first get from the allegro method
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);

   // then override for my nefarious purposes!
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; bx = 0; bw = 8*strlen(txt); }
   if (f == font0) { by = 0; bh = 8; }
}


done all the mw_get_text_dimensions in mwGraph....

I should add some code to see if labels are touching each other because they are too close...
try x axis first....i have it working....
labels can only be powers of 10....that is fine...
what would the whole thing look like if I used this to set major instaed of bewyeen 2 and 20...gave up...

oh this is done...

now what the hell was I doing before?

just added move profiling...


better auto colors in graph...
make a function to set colors...just skip 0....done....

now fix the goddam 2 line drawing bug....done...

take a break and come back for more....


now I want to go inside the move enemy and break down individual types..same with draw....


Hysterisis window following player
lots of options there

can I make the hyst div number make more sense?

its a fraction of screen size...

2 is max

how about 1/num * 2 that was 1 will be widest

20 min 1/20 * 2 == .1

save as float from 0.01 to 1

when using it do 1/num and divide by 2....

i use it to divide SCREEN_W and H so now I can just muliply instead...done...

this settings page works, but could use some polish






make a header of mwGraph and move header there


what have you done?

made z_mwGraph.h

put the class declaration there
and at the end of the class declaration:
extern mwGraph mG[10];



// z_mwGraph.cpp
#include "pm.h"
#include "z_mwGraph.h"
mwGraph mG[10];


then the only other source file that needed access was z_log.cpp and all I had to do was add
// zlog.cpp
#include "pm.h"
#include "z_mwGraph.h"


wow, that was easy...

z_mwGraph.h 250 lines
z_mwGraph.cpp 1850 lines

viewport page on settings completely done....

zoom is not saved...well it is, but when getting loaded it always loads 1...
I should make sure of that then remove it from config file...not yet, just disabled and forced to 1.0 instant on load

Disable speed settings including function keys
Speed testing abilites.

is speed save to config file? no and I don't think it should be
I do want a variable to unlock speed changes though...

int speed_control_lock = 1;


done...


I have all the stuff in place for display trandform double, just need to make it look nice...


20230114 9:45PM...push



I don't think I can profile the individual enemies and items as easy....

so what else can I do...





20230115 11:11

so this morning I chose to do something completely different...
something meta....

source code stats!!!

Purple Martians Source Code Line Counts [2023-01-15  11:11:11]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[  2378][  1597][  1387][   385][   175][   210][   606] - z_log.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
--------------------------------------------------------
[ 46138][ 33787][ 28655][  8526][  3394][  5132][  8957] - Total





Purple Martians Source Code Line Counts [2023-01-15  11:27:00]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2435][  1623][  1411][   388][   176][   212][   636] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
--------------------------------------------------------
[ 46195][ 33813][ 28679][  8529][  3395][  5134][  8987] - Total


sorted by code size



why the fuck do I still have z_map.cpp??


// zmap.cpp

#include "pm.h"

void set_map_position()
{

//  1   9   2
//      |
// -----+-----
//      |
//  4   |   3

   int alp = active_local_player;

   int px1 = players1[alp].sbx1;
   int py1 = players1[alp].sby1;
   int px2 = players1[alp].sbx2;
   int py2 = players1[alp].sby2;

//   printf("gmo:%d mx:%d my:%d px1:%d py1:%d px2:%d py2:%d\n",game_map_on, map_x, map_y, px1, py1, px2, py2);
   switch (game_map_on)
   {
      case 0:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
      break;
      case 1:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         // check to see if player is covered by the map
         if ((px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 2;
      break;
      case 2:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (py1 < map_y + map_size))  game_map_on = 1;
      break;
      case 3:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px2 > map_x)
          && (py2 > map_y))  game_map_on = 4;
      break;
      case 4:
         map_x = BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px1 < map_x + map_size)
          && (py2 > map_y))  game_map_on = 3;
      break;
      case 9:
         map_x = SCREEN_W/2 - map_size/2;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 4;
      break;
   }
}

void next_map_mode()
{
   int old_game_map_on = game_map_on;
   switch (game_map_on)
   {
      case 0: game_map_on = 1; break;
      case 1: game_map_on = 2; break;
      case 2: game_map_on = 3; break;
      case 3: game_map_on = 4; break;
      case 4: game_map_on = 9; break;
      case 9: game_map_on = 0; break;
   }
   set_map_position();
   if (old_game_map_on == game_map_on) game_map_on = 0;
}

void next_map_size()
{
   int smin = 0;
   if (SCREEN_H < SCREEN_W) smin = SCREEN_H;
   else smin = SCREEN_W;

   if (new_size == smin /4) new_size = smin/3; // 1/3
   else if (new_size == smin /3) new_size = smin/2; // 1/2
   else if (new_size == smin /2) new_size = smin/4; // 1/4
   else  new_size = smin /3; // if for some reason none of these match
}

void draw_map()
{
   if (game_map_on)
   {
      // process the size change gradually
      if (map_size < new_size)
      {
         map_size+=30;
         if (map_size > new_size) map_size = new_size;
      }
      if (map_size > new_size)
      {
         map_size-=60;
         if (map_size < new_size) map_size = new_size;
      }
      set_map_position();
      al_draw_scaled_bitmap(level_buffer, 0,0, 2000, 2000, map_x, map_y, map_size, map_size, 0);
   }
}

kill it!!!

a few more tweaks then I am done....

Purple Martians Source Code Line Counts [2023-01-15  11:41:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2404][  1620][  1405][   391][   176][   215][   608] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
-------------------------------------------------------- - totals
[ 46055][ 33720][ 28587][  8519][  3386][  5133][  8949] - 44 files

done!!!!...

just for comparison, what does code blocks say?

47 files
45856 - total
26651 - code only
 4834 - code and comment
 8899 - blank
 5472 - comment

manually add
26651 - code only
 4834 - code and comment
-------
31485

what files does it get that I don't




got to move on.....






make sure all logging entries throughtout the code have appropriate if statements
list them...


extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_game_move;
extern int LOG_NET_sdat;
extern int LOG_NET_sdak;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_show_dif1;
extern int LOG_NET_show_dif2;

--------------------------------------------------------
LOG_NET [10]
--------------------------------------------------------

8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()


6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()


1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()




   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }


   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }


   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }



1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL

server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked



--------------------------------------------------------
LOG_NET_player_array [26]
--------------------------------------------------------
1 x server_control() [26]

--------------------------------------------------------
LOG_NET_bandwidth [23][24]
--------------------------------------------------------
1 x process_bandwidth_counters() [23][24]

--------------------------------------------------------
LOG_NET_cdat [35]
--------------------------------------------------------
1 x server_proc_cdat_packet() [35]
1 x proc_player_input() // when client sends cdat [35]

--------------------------------------------------------
LOG_NET_game_move
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdat
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdak
--------------------------------------------------------
not used


--------------------------------------------------------
LOG_NET_stdf
--------------------------------------------------------
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]
1 x client_process_stdf_packet() dif decompressed [27]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]
1 x server_proc_stak_packet() [30]

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   //---------------------------------------
   // server new game
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }



--------------------------------------------------------
LOG_NET_stdf_all_packets
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received [28]
1 x server_send_stdf() // when sending an individual stdf packets to a client [28]


1 x client_timer_adjust() [36]
   sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", players1[p].dsync*1000, players1[p].client_chase_offset*1000, fps_chase);
   if (LOG_NET_stdf_all_packets) add_log_entry2(36, p, msg);

1 x ping_array_add() [37]
   sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping*1000, players1[p].ping_avg*1000);
   if (LOG_NET_stdf_all_packets) add_log_entry2(37, p, msg);

--------------------------------------------------------
LOG_NET_stdf_when_to_apply
--------------------------------------------------------
1 x client_apply_diff() [29]
   sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);



--------------------------------------------------------
LOG_NET_show_dif1
--------------------------------------------------------
all in fnx

--------------------------------------------------------
LOG_NET_show_dif2
--------------------------------------------------------
all in fnx

void show_state_dif(char *a, char *b) 430 lines..has not been used in a while....

maybe its time for all that to go away.....gone...now remove the LOG_NET...done...


what about the ping... what is it used for??
is it only for ping_graph?

Make this list also show the log entry type number....
also removed game_move, sdat, sdak...











---------------------------------------------------------------------------------
-------------   The official list of how logging works: -------------------------
---------------------------------------------------------------------------------
extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_client_ping;
extern int LOG_NET_client_timer_adj;
extern int LOG_NET_server_rx_stak;

--------------------------------------------------------
LOG_NET [10] [both]
--------------------------------------------------------
8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()

6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()

1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()

   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11] [both]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL
server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked

--------------------------------------------------------
LOG_NET_player_array [26] [server]
--------------------------------------------------------
1 x server_control()

--------------------------------------------------------
LOG_NET_bandwidth [23][24] [both]
--------------------------------------------------------
1 x process_bandwidth_counters()

--------------------------------------------------------
LOG_NET_cdat [35] [both]
--------------------------------------------------------
1 x server_proc_cdat_packet()
1 x proc_player_input()

--------------------------------------------------------
LOG_NET_stdf [27][29] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() dif received and decompressed [27]
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]

   //---------------------------------------
   // 12 - level done [27]
   //---------------------------------------
   //---------------------------------------
   // server new game [27]
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = mwPS.frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", mwPS.frame_num);
      add_log_entry2(27, 0, msg);
   }

--------------------------------------------------------
LOG_NET_stdf_all_packets [28] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received
1 x server_send_stdf() // when sending an individual stdf packets to a client

--------------------------------------------------------
LOG_NET_stdf_when_to_apply [29] [client]
--------------------------------------------------------
1 x client_apply_diff()

--------------------------------------------------------
LOG_NET_client_timer_adj [36] [client]
--------------------------------------------------------
1 x client_timer_adjust()

--------------------------------------------------------
LOG_NET_client_ping [37] [client]
--------------------------------------------------------
1 x ping_array_add()

--------------------------------------------------------
LOG_NET_server_rx_stak [30] [server]
--------------------------------------------------------
1 x server_proc_stak_packet() [30]


the only area that I still am not sure about is 27 and 29 for stdf...
a lot of these things all fall under the stdf blanket...
but it would be nice to have the option of not filling the log with unneeded stuff...

what is the point of logging that dif was received if I don't say if it was successfully appllied?



here is what I would like to see in great detail:

1 - server decides to make new dif (this is when the base it uses comes due)

2 - server rewinds to previous saved state

3 - server plays back a set number of frames (and applies all late input)

4 - server saves a new state

5 - server plays a set number of states to get back to where it was originally

6 - server set a flag to send stdf

7 - goes back into the game loop and continues the current frame (processes input, moves frame, draws frame, then sends stdf to clients)

why the delay here? why can't I send it sooner?
I am already delayed by having to rewind and make a new state....
Nothing in the state I am sending will change by playing this current loop....

The way I am doing it now is waiting for the worst possible time to do that.

I have waited for the timer to fire, then I send based on the old state
I don't even get fresh input...

What I think I should do is: (server only)

play the frame to the end (draw also?) ...no... everything but draw
get all the input
process all the client packets
move the frame...

then...before draw...do the server thing if needed....

rewind, make new state, apply lost stuff (you realize this means you will replay the frame you just played...???)

then send the stdf, then draw...


I just had a thought...what if all I do is send the stdf before I draw?

would that have the same effect??

also if I could process all client input before I make the dif that should be good also....



one at a time....
on the server, when do I process cdats.....
right at the top of the frame...I cannot make that any sooner...

second...
I already send the stdf before draw...

you were saying.....

what about when the client sends pings....literally at the end of the game_loop right before the free time....

could I be rewinding and replaying in the background?...idk

i think it is time for some tests....

ping graph needs 36 and 37 tmaj and ping




show in debug overlay, how much time it took to process the last frame
basically how much free time....
as a percentage...

50% means it took 20ms...

done...


do some more testing....











I would like a scrolling real time graph to show on debug overlay...
oh really, and would you like some gold and silver with that?


come on it will be fun and will look so cool....

make it a class kind of like ping buffer...

all you need to do it pass it values once a frame

then call it to draw itself


it will only keep a certain ammount of history then throw stuff away.


use it to show, ping, dysnc, cpu, draw, move...


1 pixel per frame....


similar to mWgraph

it doesn't even have to have any history...it can just slide over the bitmap and draw a new pixel...

what am I going to call it?

class qGraph

what about the series size, this should be a lot samller than mwGraph...after all it is quick graph...

4 series max
1000 data points max

implicit x axis is frames and should be an int

1000 / 40 = 25 sec

yaxis will be a double

how about

double data[1000][4]

the index is the x axis

or this...

   struct data_series
   {
      double data[1000];
      int active;
      int color1;
      int color2;
      char name[256];
   };
   data_series series[4] = {0};

this expects new data every frame

when it gets data the old data is pushed down one.

draw is called independantly


y axis will be scaled manually or auto
for now lets start with manual...


I will call draw from srceen overlay..done
I will add data at the end of game loop
where am I going to set this up..new game...done


I don't think I want store x and y in the class...just pass x and y with draw...

the object must know its size though

should we put some data in?

it is working!!

in single player what else can I show but cpu??

client can do ping, dysnc, cpu

I think they should be on separate graphs...

make one just for cpu

auto range from 100 to 50 to 25

OK, challenge accepted


make type variable and type 1 == cpu

make y_axis_min, y_axis_max, y_axis_rng

its just fucking beautiful!!
I love it so much!!

cant wait to make it work on client with dsync and ping....

I could still do it on m36...just make something else the server....

OK lets do this...done....


the cpu makes use of the timestamp buffer, which fills up pretty soon...
change it to just use standard timstamps in the main loop....


then try again...

it 11:30 at night....just a little longer....

fixed cpu...now lets get this to as many clients as I can...

11:57 push



20230117 6:0AM

thing are going slower no that I am back to work....

add more options to pm -t
-t   type 1 exe only
-tl  type 2 exe and levels
-tr  type 3 delete everything first and do release
-ta  type 4 abslutely everything

cleaned up this part of the code...works nicely now...

lets do a full release to all...done


not much time...

what graph can I run on client to see what is using all cpu??

profile

level 29 single player on m36

draw from 500 to 800us

move 95% 30us BUT! spikes to 2000 and once to 4000!!!

I need to know what...

did the move_all profiling and found spikes on player (2ms) and enemy (2-4ms)






implement the per enemy and per item timers...

can I use the timer buffer??

I might have 100 thing to time...

put each enemy in a bin...

      timestamps[i].frame0 = 0;
      timestamps[i].frame1 = 0;
      timestamps[i].frame2 = 0;
      timestamps[i].type   = 0;
      timestamps[i].t0     = 0;
      timestamps[i].t1     = 0;
      timestamps[i].t2     = 0;


I think I will precalc each time...


then add a timestamp like
frame0 - current frame
frame1 - enemy number
frame2 - enemy type
t0 - delta time

then at the end, calculate, enter log entry and erase them all...

LOG_TMR_enem added...

I need to know how many enemies cause the number...



It looks like I have a problem with enemy deathcount...
walk through what happens....


enemy killed by player bullet...

void enemy_bouncer(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return; // to stop rest of execution
   }

in enemy killed:
Ei[e][0] = 99; // set type to death loop


in enemy_move:
case 99: enemy_deathcount(e); break;


void enemy_deathcount(int e)
{
   int EXint = al_fixtoi(Efi[e][0]);
   int EYint = al_fixtoi(Efi[e][1]);
   Efi[e][14] += Efi[e][13]; // rot inc
   Efi[e][12] = al_fixmul(Efi[e][11], Efi[e][12]); // scale inc

   Efi[e][0] += Efi[e][2]; // xinc
   Efi[e][1] += Efi[e][3]; // yinc

   Ei[e][1] = zz[0][ Ei[e][3] ]; // draw current ans shape
   // dec and check countdown timer
   if (--Ei[e][30] < 0) // create bonus
   {
      Ei[e][0] = 0; // kill enemy
      for (int c=0; c<500; c++)
         if (item[c][0] == 0) // find empty
         {
            for (int y=0; y<16; y++) item[c][y] = 0; // clear item
            item[c][0] = 2;           // type - bonus
            item[c][1] = Ei[e][24];  // flower shape
            item[c][2] = 1; // draw mode normal
            item[c][3] = -1; // carryable
            item[c][4] = EXint;
            item[c][5] = EYint;
            item[c][6] = 1; // bonus type 1 - health
            item[c][7] = Ei[e][25];  //  life
            item[c][8] = 0;

            item[c][14] = 800; // time to live

            itemf[c][0] = al_itofix(item[c][4]);
            itemf[c][1] = al_itofix(item[c][5]);
            itemf[c][2] = al_itofix(0);
            itemf[c][3] = al_itofix(0);
            break; // end loop
         }
   }
}

looks like its only the first frame of 99...

tmst arch:[0.3217] cann:[0.3111] trak:[0.6000] clon:[0.1750] flap:[0.4810]
tmst arch:[0.3043] cann:[0.3444] trak:[0.7000] clon:[0.1500] flap:[0.4333]
tmst arch:[0.3522] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6050] dth1:[1600.6000]
tmst arch:[0.2957] cann:[0.3333] trak:[0.7000] clon:[0.2000] flap:[0.5050] dth1:[0.1000]
tmst arch:[0.3000] cann:[0.3111] trak:[0.6000] clon:[0.1500] flap:[0.4800] dth1:[0.1000]
tmst arch:[0.4174] cann:[0.5000] trak:[0.8000] clon:[0.3250] flap:[0.5750] dth1:[0.3000]
tmst arch:[0.3565] cann:[0.3556] trak:[0.7000] clon:[0.1750] flap:[0.5400] dth1:[0.1000]
tmst arch:[0.3261] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3087] cann:[0.3444] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.2000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.8000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.6000] clon:[0.2000] flap:[0.4750] dth1:[0.1000]
tmst arch:[0.3609] cann:[0.3667] trak:[0.7000] clon:[0.2000] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3222] trak:[0.8000] clon:[0.1250] flap:[0.5300] dth1:[0.1000]
tmst arch:[0.3783] cann:[0.4333] trak:[0.9000] clon:[0.3750] flap:[0.6400] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.3778] trak:[0.6000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3667] trak:[0.7000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.4222] trak:[0.7000] clon:[0.2000] flap:[0.5000] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3889] trak:[0.8000] clon:[0.1750] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3667] trak:[0.7000] clon:[0.1750] flap:[0.5000] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3889] trak:[0.7000] clon:[0.2250] flap:[0.5500] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst arch:[0.3913] cann:[0.4556] trak:[0.8000] clon:[0.2750] flap:[0.6200] dth1:[0.2000]
tmst arch:[0.3304] cann:[0.3444] trak:[0.6000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst mpty:[0.2000] arch:[0.3000] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6500]
tmst arch:[0.3217] cann:[0.3556] trak:[0.6000] clon:[0.1750] flap:[0.5000]
tmst arch:[0.3304] cann:[0.3667] trak:[0.8000] clon:[0.1750] flap:[0.6050]

I think it might be one of these....

//      if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);


3 should not exist...field


         case 60: case 62: case 64: // enemy killed
            al_play_sample(snd[8], 0.5, 0, 1.2, ALLEGRO_PLAYMODE_ONCE, NULL);
         break;



its definitely in bmsg...not the sound part though...

is it every call to create new bmsg??.. i think it is...disable this bullshit and see what happens...

much better... now lets try a busy level...

copy all to clients

now I found that drawing the screen overlay takes almost 25ms on 4230 ClientSend
on e6430 it only takes 2.5ms


there are definitely some things to look at....

can I make screen overlay take less?
how much do graphs take?


bottom msg
why does it take so much when creating a new one?
displaying them all does not take so much...



gtg its linzies 18th!!

20230118 6:45AM



run profile graph with screen overlay on/off

could it be that the temp_bitmap created is a memory bitmap??

won't know till I profile...







made profiling page in settings
button to open most recent graph
button to run game from that page
done


some duplicate labels are messing up profile graphs...

all draw have d- prefix
all move have m- prefix
all move enemy now have m- prefix


all profile to add new bmsg




making sounds have its own header...


moved all externs and function prototypes to  .h

// ------------------------------------------------
// ---------------- sound -------------------------
// ------------------------------------------------
extern ALLEGRO_VOICE *voice;
extern ALLEGRO_MIXER *mn_mixer;
extern ALLEGRO_MIXER *se_mixer;
extern ALLEGRO_MIXER *st_mixer;
extern ALLEGRO_SAMPLE *snd[20];
extern ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
extern ALLEGRO_AUDIO_STREAM *pm_theme_stream;
extern int fuse_loop_playing;
extern int sample_delay[8];
extern int st_scaler;
extern int se_scaler;
extern int lit_item;
extern int sound_on;

// z_sound.h
void start_music(int resume);
void stop_sound(void);
void proc_sound(void);
void load_sound(void);
void set_se_scaler(void);
void set_st_scaler(void);
void sound_toggle(void);



moved all declarations to sound.cpp

ALLEGRO_VOICE *voice = NULL;
ALLEGRO_MIXER *mn_mixer = NULL;
ALLEGRO_MIXER *se_mixer = NULL;
ALLEGRO_MIXER *st_mixer = NULL;
ALLEGRO_SAMPLE *snd[20];
ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
ALLEGRO_AUDIO_STREAM *pm_theme_stream;
int fuse_loop_playing;
int sample_delay[8];
int se_scaler=5;
int st_scaler=5;
int lit_item;
int sound_on = 1;


then every file that needs access includes z_sound.h

that seems to work good.....

did the same with z_log...




I am profiling bmsg...

add 1.4-2.2ms
draw 7us


now lets try to change somethings...

see what type of bitmap is created...


there is a global variable:
ALLEGRO_BITMAP *bmsg_temp;

every time new_bmsg is called:
bmsg_temp = al_create_bitmap(800, 20); // create a temp bitmap to build a single line
al_destroy_bitmap(bmsg_temp); // destroy the temp bitmap

why do I bother?? it is always the same size...
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE

I will try to create it in create bitmap

still 1.6 to 1.9ms

next....

maybe its my dtextout...does nothing except double text size, but it uses a temp bitmap...

comment out and speed test..still 1.1 to 1.3...


how about instead of all these temp bitmaps, I just draw on the final...pass a pointer to it to al the subfunctions


al_set_target_bitmap(bmsg_bmp[bmsg_index]);
al_clear_to_color(al_map_rgb(0, 0, 0));

//al_draw_bitmap(bmsg_temp, (400 - (bmsg_length/2)), 0, 0); same as 0

al_convert_mask_to_alpha(bmsg_bmp[bmsg_index], al_map_rgb(0, 0, 0)) ;
al_set_target_backbuffer(display);


so just pass (bmsg_bmp[bmsg_index]);

I don't think that was what was slowing it down

I think it was:
- the dtextout using a temp bitmap to doubel text size
- the call to set alpha..

i fixed the text thing by creating another font that is size 16..
have not figured out the alpha yet...

i think I need to bring bacj the temp bitmap, if for no other reason than:
I need to make it centered, but can't do that until I am finished drawing...
like I said, I dont think that was the bottleneck...

changed from
al_clear_to_color(al_map_rgb(0, 0, 0));
to
al_clear_to_color(al_map_rgba(0, 0, 0, 0));

now it works better...


first add spikes to 700us then around 100-150us...10x better...

not sure why first one is different

print bmsg when adding and compare to profile graph...


why when I draw a tile it takes ~6us but when I draw text, it takes ~100us

it makes no sense to me...



when I use the built in 8x8 font I get the first spike to 50us then around 10-15us

maybe the problem all along has been the truetype font

can I convert it to a bitmap type font?


I sure as fuck am going to try...

first of all print the pristine char set...



I only care about 32-127


now that I have done that, they seem to draw very fast....
no big spike on start, max for everything in add bmsg is 34us..draw text is typically 10us
I am very happy with that...I'll need to put it all back together

put the code here in the comments for future reference...




//   convert pristine ttf font to bitmap font so I can draw it faster 16x16 version



   ALLEGRO_BITMAP *b = al_create_bitmap(290, 110);
   al_set_target_bitmap(b);

   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);

   al_clear_to_color(bg1);

   int y = 2;
   for (int b=32; b<128; b+=16)
   {
      int x = 2;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*18, y, x+a*18+16, y+16, bg2);
         al_draw_textf(font2, t, x+a*18, y, 0, "%c", a+b);
      }
      y+=18;
   }

   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);

   al_save_bitmap("bitmaps/Pristine_16.bmp", b);


   al_flip_display();
   tsw();



//   convert pristine ttf font to bitmap font so I can draw it faster 8x8 version
//
//   ALLEGRO_BITMAP *b = al_create_bitmap(162, 62);
//   al_set_target_bitmap(b);
//
//   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
//   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
//   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);
//
//   al_clear_to_color(bg1);
//
//   int y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//   al_set_target_backbuffer(display);
//   al_draw_bitmap(b, 0, 0, 0);
//
//   al_save_bitmap("bitmaps/new_p_8.bmp", b);
//
//
//   al_flip_display();
//   tsw();
//
//
//   ALLEGRO_BITMAP* tmp234 = al_load_bitmap("bitmaps/new_p_8.bmp");
//   if (!tmp234) mI.m_err((char*)"Can't load bitmaps//new_p_8.bmp");
//   else
//   {
//      al_destroy_font(font);
//      int ranges[] = {32, 127};
//      font = al_grab_font_from_bitmap(tmp234, 1, ranges);
//      if(!font) mI.m_err("Failed to load font from bitmaps/Pristine.ttf");
//      al_destroy_bitmap(tmp234);
//   }
//
//
//   al_set_target_backbuffer(display);
//   al_clear_to_color(bg2);
//   al_flip_display();
//
//   y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//
//
//
//   al_flip_display();
//   tsw();
//
//




OK that should be done for now....

I have other things to profile...like screen overlay...lets see if that got any better now that I have fonts fixed....





20230120 2:00AM
profile screen overlay..


make a way to disable bmg in settings...done
hostname is not getting saved...done




on m36 as client
cpu 120us
sync 230us
cbuttons 43us


none of that seems excessive....


I want to know what happens when player paused due to death...

scrn overlay takes a huge hit in jq...
why don't I get jq when clients join quit?? i do...

what can I do to make jq faster??

5ms then 1.5, 1.5, 1.5 then 5ms
spikes once to 6.7 at start and end..

its that fucking convert mask to alpha!!
265us spike then 35 then 164 spike near end...

why is it sooo slow? why do I need it?

same thing as bmsg....

old:
al_clear_to_color(al_map_rgb(0,0,0));
al_draw_text(font0, mC.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);
al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

new:
al_clear_to_color(al_map_rgba(0,0,0,0));
al_draw_text(font0, mC.pc[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);

now it is transparent and really fast...



find all occurances of: al_convert_mask_to_alpha and see if they are needed...

25 matches...

ignore one that are not in a fast loop..
6 in bitmap.cpp
4 in file when loading from file..
7 in logo
mw_text for 'created by' fixed...
title..fixed

2 x void draw_large_text_overlay(int type, int color)..fixed
3 x void idw(int txt, int x, int y, float x_scale, float y_scale)

some when loading my new fonts...can I do that before I save?
does not seem to save in bmp format, i still need to call

al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)) in bmp after loading and before loading font from it...

here is my new routine:

void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size)
{
   // converts ttf fonts to bitmap font to draw faster and have consistant size
   sprintf(msg, "bitmaps/%s", ttf_filename);
   ALLEGRO_FONT *cf = al_load_ttf_font(msg, char_size, ALLEGRO_TTF_NO_KERNING | ALLEGRO_TTF_MONOCHROME | ALLEGRO_TTF_NO_AUTOHINT);
   if(!cf)
   {
      sprintf(msg, "Failed to load font from bitmaps/%s", ttf_filename);
      m_err("Failed to load font from bitmaps/Pristine.ttf");
   }
   else printf("loaded font %s\n", msg);

   int bw = 1;                 // border width
   int step0 = char_size+bw;   // step size between char
   int step1 = char_size;      // char size
   int bmp_w = (16 * step0) + bw;
   int bmp_h = (6  * step0) + bw;

   ALLEGRO_BITMAP *b = al_create_bitmap(bmp_w, bmp_h);
   al_set_target_bitmap(b);

   al_clear_to_color(al_map_rgb(255, 0, 0));  // set entire bitmap to red, this will be the background color separating the glyphs

   int y = bw;
   for (int b=32; b<128; b+=16)
   {
      int x = bw;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*step0, y, x+a*step0+step1, y+step1, al_map_rgb(0, 0, 0)); // clear glyph background
         al_draw_textf(cf, al_map_rgb(255, 255, 255), x+a*step0, y, 0, "%c", a+b);
      }
      y+=step0;
   }
   al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)); // does not actually save in bmp format :(
   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);
   sprintf(msg, "bitmaps/%s", bmp_filename);
   al_save_bitmap(msg, b);
   al_destroy_font(cf);
}

convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_16.bmp", 16);

and here is how I load them...

   ALLEGRO_BITMAP* tmp = al_load_bitmap("bitmaps/Pristine_8.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_8.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font);
      int ranges[] = {32, 127};
      font = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font) m_err("Failed to load font from bitmaps/Pristine_8.bmp");
      al_destroy_bitmap(tmp);
   }

   tmp = al_load_bitmap("bitmaps/Pristine_16.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_16.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font2);
      int ranges[] = {32, 127};
      font2 = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font2) m_err("Failed to load font from bitmaps/Pristine_16.bmp");
      al_destroy_bitmap(tmp);
   }


back to looking for al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;

should be all good...

I have a couple of functions that are not used anymore:

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col);
void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col);

ill list them here then delete them...



/*

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // can show mirror image text when scales are negative
   // used only mdw logo animation
//   int sw = strlen(txt1) * 8;      // string length in pixels
//   int sh = 8;                     // string height in pixels


   int bbx1, bby1, bbw1, bbh1;
   al_get_text_dimensions(f1, txt1, &bbx1, &bby1, &bbw1, &bbh1);

//   printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);

   // scale the scale...
   x_scale *=  24 / (float) al_get_font_line_height(f1);
   y_scale *=  24 / (float) al_get_font_line_height(f1);

   int sw = bbw1;
   int sh = bbh1;



   ALLEGRO_BITMAP *temps = NULL;
   temps = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temps);
   al_clear_to_color(al_map_rgb(0,0,0));


//   al_draw_text(font,mC.pc[col], 0, 0, 0, txt1 );

   al_draw_text(f1, mC.pc[col], 0-bbx1, 0-bby1, 0, txt1);


   al_convert_mask_to_alpha(temps, al_map_rgb(0, 0, 0)) ;


   int flags = 0;
   if (x_scale < 0) flags |= ALLEGRO_FLIP_HORIZONTAL;
   if (y_scale < 0) flags |= ALLEGRO_FLIP_VERTICAL;

   // offset x pos if scale is negative
   if (x_scale < 0) x -= abs( (int) ((float)sw * x_scale) );

   // offset y pos if scale is negative
   if (y_scale < 0) y -= abs( (int) ((float)sh * y_scale) );

   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temps, 0, 0, x, y, fabs(x_scale), fabs(y_scale), 0, flags);
   al_destroy_bitmap(temps);
}

void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // used only by bottom message and level done
   int sw = strlen(txt1) * 8;      // string length in pixels
   int sh = 8;                     // string height in pixels

   ALLEGRO_BITMAP *temp = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));

   int dw = (int) ((float)sw * x_scale);
   int dh = (int) ((float)sh * y_scale);

   al_draw_text(font, mC.pc[col], 0, 0, 0, txt1);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

   al_set_target_backbuffer(display);
   al_draw_scaled_bitmap(temp, 0, 0, sw, sh, x-dw/2, y, dw, dh, 0);

   al_destroy_bitmap(temp);
}
*/


20230120 7:00AM

well I think I have that sorted out...


now back to things that were slowing down on profile...


I was in client with the three things in screen overlay...


240us sync_ping
130us CPU
100   client grid
90    debug common
44    cbuttons
it all adds up to about 700us


when running as client everything added up (cpu) takes about 1ms, draw and move

if i turn off the debug overlay everything is around 400us





clients still around 90-100%

ran the profile graph on a client and 22ms spent in draw and 17 was screen overlay


what to do about that?

make it adjustable somehow. I want to see cpu

sync 7ms
cpu 4ms
c_grid 2.3
dbug_com 1.5

the width of the qGraph determines how many points are drawn...
right now I am using 200 for width which gives me 5s

should I make this adjustable?

set ranges based on how large the screen is?

I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...


20230221 5:00AM
pm -? show commandline options...done




show_debug_overlay to have more options:

0-off
1-minimal
2-medium
3-all

mimimal
cpu only

medium
cpu and sync (client only)

all


make list of things that can be shown:
- cpu
- client sync and ping
- client grid
- server grid

common list of text
more list of text...






I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...

the way I have it now is is only measures send to one client...
and it only add a log entry when it actually sends...
what I want to do is move it to here:

from loop:
if (players1[0].server_send_dif) server_send_stdf();

and add a log entry every frame...
that way I will get the total time, and zero's when nothing happens

between this and rewind, I should have all the main server stuff profiled...done


log cpu (total time spent processing each frame)

calc where?

right now screen_overlay does it...is this what I want??
this is not actually at the end of the frame is it?
no...it is at the end of loop where it is added to qG

            if (proc_frame_skip()) draw_frame();

            double pt = al_get_time() - timestamp_frame_start;
            double cpu = (pt/0.025)*100;
            qG[0].add_data(0, cpu);

literally the last thing...
this is where I should add the log entry also...
LOG_TMR_cpu

done...


ready for some more tests??
looking good...

bug..why does it fail at level done when trying to load next level and getting level 0?

it looks like next_level is only set when player touches exit or warp...
I think some clients are missing this...

fix when I get back....

got to go to a first aid class on a saturday...oh well..8H OT..

push..





20230121 4:30PM
moved all settings related stuff to z_settings.cpp and z_settings.h

e_mWindow.h done
z_player.h done


now I am down to 1300 lines in pm.h...little by little, I am chipping away at it....


added to player array:

   int level_done_next_level;

find occ of next_level and replace with players[0].level_done_next_level....done

that should fix that....


I think I am back to the testing part of things....
send out to all


the dsync on clients has a bit of a strange pattern

on e6430 one peak at +60-500us then a few at -2.3ms

on 4230 4 around +1ms then 1 at -15ms

why is this happening?

what does it all mean?

what happens on a pattern of 5 frames?

I think its the timer adjust...the patterns match...

can I make it less aggressive....



I am dealing with very small values here...

I have usually kept fps at 40 and set timer with 1/40

I could just as easily set timer with 0.025

1 / 40.00 = 0.0250000
1 / 40.10 = 0.024937
            0.000063 or 63us

1 / 40.00 = 0.0250000
1 / 40.01 = 0.0249937
            0.0000063 or 6.3us

my adjustments seem really small


maybe I need to print all the numbers used in my calc

make a new log entry for now...temp...









I want to make a PID loop...


I have an output I can measure: dsync
I have a setpoint I am trying to achieve: offset
I have a variable I can use to control the process: fps


first of all I want to graph these...
then I will try to plug in a new PID algorithm


make a new graph just for this....
client only

in the interests of it all fitting on the same graph I will use fps_adjust as my control

and I will make fps adjust the value added or subtracted to 0.025....

all my values will be in ms to 3 deciaml places...

make a new log entry...done...


now I can easily plot...

   float mv = players1[p].dsync;                 // measured value
   float sp = players1[p].client_chase_offset;   // set point
   float err = sp - mv;                          // error = set point - measured value



my control loop currently is just P, err*100 = P

to get the integral I will need a running total...

simply add and subtract the error....

why do I have doubts this will work?

beacuse when it ramps up the I will grow really fast...

2 ways to solve this...
- set limits on i
- gradually decay i


first of all I need a global variable to keep a running total...

done...



what if the problem is that the things I am trying to sync are inherently unstable....

what if I took an average of dsync and used that...


how often do I get dsync?

with every dif so 2-3 frame...


what if I just took a running average, like ping?


I can still show the instantaneous ones, but use the average to set chase speed

this needs to be fast for initial chase though...


try it....



make ping_buffer have a header file and be self contained...then add dsync...

add dsync_avg to player1 array..done


add call when calc



I think I have stumbled upon something amazing...all this bullshit happens when we need 2 packets...

each packet causes its own timer adjust, and one is definitely later than the other...duh...


how can I make it not do that?

have a variable last stdf_packet frame and check it...
already had var...check it now and only do one timer adj per frame based on first stdf rx'd..done

still getting some wild oscilliations


lets also try starting offset at 0 instead of +10ms


set ia to zero.
how long does it take for mv to climb to zero line?
then with overshoot how long to cross back down?

pa = 100
mv  = 748-727 = 21
mv  = 793-727 = 66

mva = 762-727 = 35
mva = 805-727 = 78


pa = 60

mv  = 428-384 = 44
mv  = 456-384 = 72

mva = 442-384 = 58
mva = 471-384 = 87



make client offset update faster at start of chase..
it seems to take a while to actually change off zero...
352-259 = 93 frames

i cant run ping graph...i broks it..fixed
691-622 = 69

still does not seem to send first ping till mwPS.frame_num>0 (initial state rx?)


this is getting complicated...is is worth it to send pings while still in setup?
while still in setup stdf packets are being processed and timer is being adjusted...
might as well be based on a real setpoint based on a real ping...
while in setup the loop happens very fast and mwPS.frame_num is not incremented...

need another way to trigger sending pings...


how about in loop, after the main 11 is done, send client ping if flag is set.

then I can set this flag in 11 like normal, and also in setup based on a timer...

if (players1[active_local_player].client_ping_flag)
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

make a new timer png_timer..done...

now the event timer is the only thing that sets the flag...
it works, but still no pings for the first bit...

why the fuck not??

log...
all on frame 0:
got reply
send and rx join
start level..

then on frame 152
152 game state updated
162 tmaj
165
166
172
...
240
243
244 ping!!!

this is a long delay...

also client does not show when they became active??
not in log anyway

so back to the issue at hand:

after client gets initial state, it starts the main loop and and chases, while inactive
there is a long pause here before the first ping is received...

why?


show on console the frames when ping is sent..

191026 initial state
191028 ping
191047 ping
191067 ping
191087 ping
191107 ping
191128 ping

in logs
191108 1st ping received 24ms
191129 2nd ping received 28ms


I am sending them, but it appears that the first 4 are lost??

what a subtle bug!!!
on server, when rxing ping and replying, it looks up who from player_num and fails if player is not active yet!!

int get_player_num_from_who(int who)
{
   for(int p=0; p<NUM_PLAYERS; p++)
//      if ((players[p].active) && (players1[p].who == who)) return p;
      if (players1[p].who == who) return p;
   return -1;
}

still the same

console:
652 initial state
671 ping
691 ping
711 ping
731 ping
752 ping

log
732 1st ping
753 2nd ping

still missing first 4 pings...


more console logging:

049 init state
069 send ping
089 send ping
109 send ping
129 send ping
130 rx pong
150 tx ping
151 rx pong

as far as I can tell server is not sending reply...

add console logging on server and look into who...


I think I forgot to send most recent compile to server...it works now...


ping graph dumps a bunch of shit to console...fixed

make it so that once init state is rx, do a one time send ping by setting flag...

OK I think I have that one thing figured out....

clean up and move on...

this is how I handle client ping sends:

made a timer:
png_timer = al_create_timer(.5);   // 2 fps

made a variable in player1 array:
players1[].client_ping_flag

when timer event fires:
if (ev.timer.source == png_timer) players1[active_local_player].client_ping_flag = 1;

in the main loop just after every thing else:
if ((players1[active_local_player].client_ping_flag) && (ima_client))
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

in client setup, when initial state is received:
players1[active_local_player].client_ping_flag = 1;

the only thing I might like to add later is a method of slowing the ping timer...
maybe I don't need to...2 packets per second is hardly anything

now I want to make the ping and sync graph easier to use..

first of all...
make a button on logging to load most recent file in log file viewer..done
then remove profile button from that page...done
then put both pages adjacent...done

now, how do I make ping sync graph better?

I can do most stuff with generic profile graph
tmaj and ping

the only nice thing about the specific one is that it has ping also...

make it all use profile...

ping uses 37
old tmaj uses 36

tmr uses 44

do both for now:

LOG_NET_client_timer_adj 36
LOG_NET_client_ping 37

new:
LOG_TMR_client_timer_adj
LOG_TMR_client_ping

now both graphs can co-exist....


after all this messing around, I have not come to any real conclusions

client sync is still pretty much what it used to be...


now can I finally look at what changing s1 and s2 do?


server_rewind is called and it determines if it is time to make a new state and send dif...

if the current mwPS.frame_num matches the mwPS.frame_num of the last saved base+s1+s2....

then it is time....

- rewind to the last saved base
- play forward s1 frames
- save new state
- play forward s2 frames




random demo game is very not random...
always starts with trigger...
add this: srand((unsigned) time(&t)); // done
checkbox to test opacity on demo...done
when starting stuff from demo save config first so it comes back to the same page..done



next on my simulation
keep client and server frame numbers different
when server is in rewind do not move client fn...

when server makes new state, jump to clients side and receive and rewind it...



what happens if I set s2 to 0??

LAN seem to work with no issues...
WAN i get a few late cdats and some noticeable corrections

tried s2 == 1
WAN was about the same...






I never use the 4 states in this array:
// server's copy of last stdf state
extern char srv_stdf_state[4][STATE_SIZE];
extern int srv_stdf_state_frame_num[4];

I only ever use [1]


I should remove it and make it a flat array....

do I use all 8 of these?

extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

they are server only, so is 0 unused?

I would have to say I think it is

so for server only iI can use 0

I am currently using:
srv_stdf_state[1]
srv_stdf_state_frame_num[1]

I propose to use:
srv_client_state[0][1]
srv_client_state_frame_num[0][1]

I am 99% sure I can do this...so do it...but doc all that you do....

7 occ of
pm..done
main...done
fnx memset..done

loop: 2 places....
old:
game_vars_to_state(srv_stdf_state[1]);
srv_stdf_state_frame_num[1] = mwPS.frame_num;

new:
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;

server 1:
//mwPS.frame_num = srv_stdf_state_frame_num[1]; // set rewind frame num
//state_to_game_vars(srv_stdf_state[1]);   // apply rewind state
mwPS.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
state_to_game_vars(srv_client_state[0][1]);   // apply rewind state

server 2:
//game_vars_to_state(srv_stdf_state[1]);
//srv_stdf_state_frame_num[1] = mwPS.frame_num;
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = mwPS.frame_num;


4 more in server:
if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
sprintf(msg, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
if (cdat_frame_num < srv_client_state_frame_num[0][1])
printf("[%d]late cdat dropped p:%d c:%d  state:%d  tally:%d\n", mwPS.frame_num, p, cdat_frame_num, srv_client_state_frame_num[0][1], players1[p].late_cdats);



it still seems to work...remove all traces...

I would like to put all netgame stuff in its own file...

n_netgame.cpp
n_netgame.h

do it...done...



20230124 6:15AM

I have some thoughts about what I would like to monitor:
I want to be able to see how much the clients need to rewind
in LAN test they are exact or 1






I think I have an idea about what s2 is for..
its so that the difs sent are not the most current







remove from player1 struct??
there is no field anymore...

//   float field_damage_tally;
//   int field_damage_holdoff;
//   int field_damage_enemy_number;




but is it used for other stuff?  like mine or block damage?
idk
yes, used for block damage, but not mine...


game_event(59
called only when block_damage is taking health from player

game_event(57
not called at all

game_event(50
mine collison

convert the bit in health to work with block_damage
OK I fixed all that, but that was not what I planned to do...


I wanted to add client_rewind to player1...done and added to client debug grid...done
LAN always 0 or 1..even when increasing s1 and s2...
WAN always 1 or 2..even when increasing s1 and s2... (ping ~27)



20230125 2:20AM


add some sort of manual sync control to client

Like I can set to manual, or the value for auto..

I want to experiment with changing offset and seeing how my clients rewinds come out..


what variables?, should I put it in settings? yes, and also live control..

players1[p].client_chase_offset

currently set in add ping:

players1[p].client_chase_offset = - players1[p].ping_avg;

also in debug overlay


double client_chase_offset;
double client_chase_offset_auto_offset;
int client_chase_offset_mode; // 0 = manual, 1 = auto

add button /auto/manual done
make button adjust ping offset in that mode..done...

now make a way to view client rewind in real time..I can see it in debug grid just fine...


in LAN mode, if I increase a few ms, I no longer jump from 0 to 1, I stay steady on 1

in WAN mode with a ping of 20-30, if I add or subtract a few I can force mostly 1 or 2 for rewind

what have I learned from this?

idk...


I am trying to figure out the effect of changing client sync offset

what effect does it have on when server receives cdat?  I guess I actually have to press keys to see that!

when client is doing rewind of 2 server say game move sync is 0


s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

I think I am on to something here...

try this with different s1 and s2 values

s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

s1:3 s2:2
crwd sgms
2    0
1    -1
0    -2

s1:4 s2:2
crwd sgms
2    0
1    -1
0    -2

that did not seem to change anything...
how is sgms calculated?

void server_proc_cdat_packet(double timestamp)
{
   players1[p].server_game_move_sync = cdat_frame_num - mwPS.frame_num;


what does this tell me?

at what point of sgms are cdats considered late and not applied?
when they are earlier than last saved server state...

lets try to make that happen...

when client moves ahead of server with a positive offset
and sgms gets to -3 then I get late cdat errors...

changing s1 did not seem to affect this...


on client, when I adjust dsync too high it ramps...see if I con find out why...


It looks like my raw calclution of dsync...when it goes over 25, it subtracts 25....

   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   players1[p].client_sync = dst - mwPS.frame_num;               // crude integer sync based on frame numbers

   if (players1[p].client_last_stdf_rx_frame_num != mwPS.frame_num)       // this is the first stdf received for this frame
   {
      players1[p].client_last_stdf_rx_frame_num = mwPS.frame_num;         // client keeps track of last stdf rx'd and quits if too long
      players1[p].dsync = al_get_time() - timestamp;                 // time between when the packet was received into the packet buffer and now
      players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot
      dsync_array_add();
      client_timer_adjust();
   }


the problem is that csync goes to 1 for only one frame

the problem is much deeper than that....
the client has no way of dealing with a future dif...
it just applies it, and that has the effect of the client jumping forward in time

yes abandon this line of questioning, I don't really care about this case...or do I?

what would happen if I did not apply till the next frame??

I think I have that fixed, and it seems to work...


I need to change to docs...

now why did i do that again?


to see what happens to sgms and crwd...ok let see...


crwd now goes to -1 and -2, never got less than zero before...
sgms now to -3 and -4....

when sgms goes to -3 (in s1:3 s2:1) late cdats happen constantly

lets try changing s2....

when s2 goes to 2 late cdats stop...
then increasing client offset till sgms = 4
late cdats again...

I think I found out something...

s2 affects late cdats...

lets do a grid compare again..

WAN with 20-30ms ping


s1:3 s2:0
offs crwd sgms late cdats
-40  2    0
-15  1    -1  rare
+10  0    -2  constant
+80       -6  game done

s1:3 s2:1
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same
          -6    game done


s1:3 s2:2
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same game done


s1:3 s2:3
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    none
+54  0/-2 -4    rare
+80  0/-3 -5    constant
+86       -6    game done


s1:3 s2:4
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5    rare game done


OK now what if I try changing s1:

leave s2 at 1

s1:1 s2:1
offs crwd sgms late cdats base resets
-40  2    0
-15  1    -1
+10  0    -2   rare
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5



with s1 set at 1, I get constant base resets 7K dif size 7 packets 290kBs or 2.3Mbps
lets just throw this one out...its sending dif every frame...

OK so lets start with the minimum s1 of 2
now around 30kBs or 0.24Mpbs

s1:2 s2:1
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   occ/rare   occ/rare
+35  0/-1 -3   constant   const
+54  0/-2 -4   lost server


s1:2 s2:2
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   rare       const
+50  0/-2 -4   const      const
+55  lost server

s1:2 s2:3
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   0          const
+50  0/-2 -4   rare       const
+55  lost server


redo 3
around 21kBps or 0.17Mbps


s1:3 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    const      0
+40  0/-2 -3    const      occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    rare       0
+40  0/-2 -3/-4 most       occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 0          0
+25  0/-1 -3    0          0
+40  0/-2 -3/-4 0          occ
+45  0/-2 -4    0          const
+68       -5    const      const
+80 lost server

now do 4
15kBps or 0.12Mbps


s1:4 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+20  0    -2/-3 occ        0
+30  0/-1 -3    const      0
+50  0/-2 -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+40       -3/-4 rare       0
+50       -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+50       -4    0          0
+65       -4/-5 rare       occ
+70       -5    const      const
+95       -6
+110 lost server



OK... there is alot of data:

its 7:30 so I don't have time to analyze

very briefly

s1
min:2
best 3-4


s2
min:0
best 1-3

3 2 will probalby be best...

experiment with auto sync at 1/2 round trip ping....



20230126 3:00AM

So see if you can do so sort of summary...

s1
controls the frequency or sending difs
1 sends them every frame, should not use, every dif will be full size
2 sends every other frame, occasional base resets are common
3 base reset are very rare


s2
how much the client can lag server without late cdats..
1-3 works probably use 2..


there are probably other things that these affect, that I have not been able to measure yet
I assume that the longer I take to rewind and resnd, the more jarring the corrections will be..

I need some way of measuring that...


how long from sending a cdat, does the client need to wait before it gets a dif with that cdat...
that sounds so simple, how will I measure it

client rx dif for frame 98-100, current client frame = 102...

client rewinds to 100 and ff 2..

so that worst case is a move made on frame 98 does not get back to client until 102...

something like that, lets look at some real data from a log...

3871 tx cdat
3873 dif applied 3867-3871

just that one line:
3873 dif applied 3867-3871

tells me that at worst case 3873-3867 = 6 frames before making a move and getting the official dif from server

this was in mode 4 3..

try in mode 2 3











side track:

why does server rack up a shitload of base resets, waiting for client to join?

make finer tuning of stdf shit in log

I would like to be able to filter out all unsuccessful dif applied
there are a lot of them

maybe a different tag for succesfull vs unsuccesful

27 and 29


extern int LOG_NET_dif_applied;
extern int LOG_NET_dif_not_applied;

replace
extern int LOG_NET_stdf_when_to_apply;

done...the logging is much more better...



mode 2 3 gets 4...this is better yes?

should I calculate and show on client?


where? when dif applied
saved where?

new var
int client_move_lag;

done...now experimeting with that..
I would assume that lower is better..

I have found that when s1 = 2
I need to adjust offset so dsync is about -12 (half frame) or I get base resets...

should I show somewhere on client the base resets?

I already have players1[p].client_base_resets++; on the server
re use it for clients...done..now in debug grid



so, is that what I should do for offset?  aim for - 1/2 frame??

ping  offset
0-12   -12
12-37  -37


changing the offset changes move_lag also...


I have one setup that should work good but the corrections are quite jarring:
s1:2 s2:2
move_lag:2
dsync +12
sgms -2
no late cdat
no base reset

this one has much less jarring corrections:
s1:2 s2:2
move_lag:3
dsync -12
sgms -1
jno late cdat
no base reset

also good is
s1:3 s2:1
move_lag:5
dsync -35
sgms 0
jno late cdat
no base reset

many settings work
also good
s1:2 s2:1

maybe the move_lag is not all important...
it can be longer, as long as the prediction and the actual are not too far off...

I might just be as good as I can get...

set offset so that dsync is about 12-14 ms independant of ping

figure out how to test on worse networks...

why does reducing s1 cause bad problems on server?
kicks client and wont let new one connect

when the new one tries to connect:
server log shows stak reply that client fails base set, has base from previous game


am I not resetting something on server?
when that happens on server, server resets its copy of client base state to zero..
am I not resetting that on client?


reset_states()
client_state_dif_src = -1; // -1 will never match a mwPS.frame_num
client_state_dif_dst = -1;

this will mark if we have not received a state yet, or the state is a bad decompress



server keeps old last acked state for client

need to reset that on server when client quits or is dropped....done

changed this:
void client_apply_diff(void)
{
   int p = active_local_player;

   // check if valid dif
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1))
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
//      if (mwPS.frame_num == 0)
//      {
//         printf("initial state - dif_src:%d dif_dts:%d  cbsfn:%d \n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
//      }
//      if ((client_state_dif_dst > client_state_base_frame_num) || (mwPS.frame_num == 0)) // stored dif with a new dest, or initial state (frame 0)



      if ((client_state_dif_dst > client_state_base_frame_num)) // stored dif has a newer dest
      {

OK with that cleaned up..back to why reducing s1 is bad...does not seem to be bad any more, maybe test more...


when client does level done and starts new level...
it is not waiting for initial state...that is the way it should be
it is still getting stdfs from last level...? at least it is smart enough not to try tp apply them

on the server, do I need to reset client states at level done??

in level done reset_states is called....

clientlog:
------------------
1    client rx dif from 22122 to 22124
     client says wrong client base and replies with 0 for client base
4    client rx dif from 0-22126
4-10 client doesnt apply...too early
11   client rx dif from 0-3

then we are back on track..


server log:
------------------
22122 tx 22120-22122
22123 rx stak  22122
22124 tx 22122-22124
22125 rx stak  0
22125 server drop player sync>100
22126 tx 0-22126
22127 NEXT LEVEL
3     tx 0-3
4     rx stak 3

then we are back on track..

OK what can I do about this?
nothing right now...its time for work...

20230126 7:37AM
20230127 4:24 AM

why do I want to do something about it? it works
I don't like how the server tries to drop the client


I don't like how the client is still getting difs from the previous level.
It is just a natural consequence of the client being ahead of the server..

What if on the client, I check to see if dif_src is much larger than current frame number?
Won't this also catch initial state? Maybe not...is not initial state dif_src == 0?

if (client_state_dif_src - mwPS.frame_num > 100)


I have rewritten the client_apply_dif() again..


this time I have front loaded all the tests and added one for  if (client_state_dif_src - mwPS.frame_num > 100)
it only seems to catch when level done and client is ahead of server...


void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - mwPS.frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d mwPS.frame_num:%d\n", client_state_dif_src, mwPS.frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // stored dif has a newer dest
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }

            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);

               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = mwPS.frame_num - client_state_dif_dst; // dst compared to current mwPS.frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", mwPS.frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (mwPS.frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (mwPS.frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));


                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, mC.pc[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

                  // for initial state only
                  if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);

                  players1[p].client_last_dif_applied = mwPS.frame_num;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = mwPS.frame_num - client_state_dif_src;

                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}

this is a log of how it works


[31][1][2272]dif [2267 to 2269] not applied - not newer than current [2269]
[27][1][2273]rx dif complete [2269 to 2271] sync[-2] dsync[-35.9ms] - decompressed
[30][1][2273]dif [2269 to 2271] applied - rewind [2] frames
[31][1][2274]dif [2269 to 2271] not applied - not newer than current [2271]
[27][1][2275]rx dif complete [2271 to 2273] sync[-2] dsync[-36.7ms] - decompressed
[30][1][2275]dif [2271 to 2273] applied - rewind [2] frames
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                              NEXT LEVEL:151                              |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 151 STARTED                             |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[31][1][1]dif is not valid - src:-1 dst:-1
[27][1][2]rx dif complete [2273 to 2275] sync[2273] dsync[56839.2ms] - decompressed
[31][1][2]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:2
[31][1][3]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:3
[31][1][4]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:4
[31][1][5]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:5
[31][1][6]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:6
[31][1][7]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:7
[31][1][8]dif_src is > 100 frames in the future - src:2273 mwPS.frame_num:8
[27][1][9]rx dif complete [0 to 3] sync[-6] dsync[-136.1ms] - decompressed
[31][1][9]Resetting client base state to zero
[30][1][9]dif [0 to 3] applied - rewind [6] frames
[31][1][10]dif [0 to 3] not applied - not newer than current [3]
[31][1][11]dif [0 to 3] not applied - not newer than current [3]
[27][1][12]rx dif complete [3 to 5] sync[-7] dsync[-168.9ms] - decompressed
[30][1][12]dif [3 to 5] applied - rewind [7] frames
[31][1][13]dif [3 to 5] not applied - not newer than current [5]
[31][1][14]dif [3 to 5] not applied - not newer than current [5]
[31][1][15]dif [3 to 5] not applied - not newer than current [5]
[27][1][16]rx dif complete [5 to 7] sync[-9] dsync[-210.9ms] - decompressed
[30][1][16]dif [5 to 7] applied - rewind [9] frames
[31][1][17]dif [5 to 7] not applied - not newer than current [7]
[31][1][18]dif [5 to 7] not applied - not newer than current [7]
[27][1][19]rx dif complete [7 to 9] sync[-10] dsync[-243.8ms] - decompressed
[30][1][19]dif [7 to 9] applied - rewind [10] frames
[31][1][20]dif [7 to 9] not applied - not newer than current [9]
[31][1][21]dif [7 to 9] not applied - not newer than current [9]
[31][1][22]dif [7 to 9] not applied - not newer than current [9]
[27][1][23]rx dif complete [9 to 11] sync[-12] dsync[-285.9ms] - decompressed



windows wants to do an update so I am going to do a push first


then go through code and make sure dif is not spelled diff
and that state and dif refer to the proper things...


'state' refers the the entire game state, typically put into a char array of size STATE_SIZE
'dif' is when 2 states are subtracted, resulting in the diference between the 2

difs are then compressed, optionally broken into packet sized pieces and sent from server to clients

when a client has all the pieces of a dif, and the state on which it is based,
it applies the dif to its base state, recreating the server state..

                  // update mwPS.frame_num and client base mwPS.frame_num
                  mwPS.frame_num = client_state_base_frame_num = client_state_dif_dst;

removed this... i don't think it ever applies... in the previous line mwPS.frame_num will be set to something non-zero

                  // for initial state only
            //      if (mwPS.frame_num == 0) set_frame_nums(client_state_dif_dst);




re did the netgame docs for client_apply_dif()

time for work:

20230127 7:25AM


what do I want to do next?

make the auto offset run at - 1/2 frame

figure out how to test with bad network...


document:
void client_fast_packet_loop(void)
void server_fast_packet_loop(void)

extern struct packet_buffer packet_buffers[200];
struct packet_buffer
{
   int active;
   int type;
   double timestamp;
   int who;
   int packetsize;
   char data[1024];
};



files I want to have for netgame

netgame_client_state

netgame_client_sync

netgame_client_control_change

netgame_fast_packet_loop

netgame_state (describes state and dif)







fixed a bug in STATE_SIZE
old:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

new:
Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928

the totals are the same, but the individual value for itemf was wrong..


I have netgame_state_and_dif complete...

next finish netgame_client_state..done...
now make a few links from one to the other....
did reset to zero -> state copmpression methods...
stak...done
state..done

next do:

netgame_client_control_change...done

netgame_client_sync



I just found something I didn't realize

      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


I though that the client used the server's local frame number when calculating sync
it doesn't...

what it uses is the dst frame number, which, depending on s2 is NOT the server's local frame number

what does this all mean?

is my sync not what I thought it is?

the client is syncing to the dst frame of the state....


why do I even need s2 is my question??

could I not handle that by just moving clients sync offset??




try this by making s2 = 0 and running some tests...


if s2 == 0 then dst == server local frame num...




LAN (ping 0.1-0.2)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  5        3    2    0          0
-45  4        2    1    0          0 - playable
-20  3        1    0    0          0 - very playable
+5   2        0    -1   0          0 - very playable
+30  2        0/-1 -2   const      0



4.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-70  6        3    2    0          0
-45  5        2    1    0          0 - playable
-20  4        1    0    0          0 - very playable
+5   3        0    -1   0          0 - very playable
+30  3        0/-1 -2   const      0






WAN (ping 22-27)
5.5kBs
s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  5        3    1    0          0
-38  4        2    0    0          0 - playable
-13  3        1    -1   very rare  0 - playable (better)
+12  2        0    -2   const      some


WAN (ping 22-27)
5.5kBs
s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets
-63  6        3    1    0          0
-38  5        2    0    0          0
-13  4        1    -1   very rare  0
+12  2        0    -2   const      0


conclusions:


I think I could do without s2: not sure why I had it in the first place....



am I ready to test degraded network?



yes!!



tried clumsy 0.3rc4-win64a on win7 e6430
failed to open device 577


linux...


tc and netem


Linux  tc & netem

The most low-level and feature-rich at the same time is Linux Network Emulator (netem). If you are using one of the most common Linux distributions(Fedora, OpenSuse, Gentoo, Debian, Mandriva, Ubuntu) you already have it enabled in the kernel. It comes along with another built-in utility Traffic Control(tc). There is no UI, just CLI, the way most of Linux users like it.

Obviously the sky is the limit in terms of functionality with this tool. I would provide some examples, just to give you a hint:

tc qdisc add dev eth0 root netem delay 100ms

What happens here:

    tc qdisc  what Traffic control is doing under the hood is configuring the kernel packet scheduler.
    add  operation of appending new rule, after the test you probably would want to execute `del` operation.
    dev eth0  the device on which the rule would be applied.
    root  apply it on the egress (outbound traffic) qdisc
    netem  use the network emulator
    delay  network metric to be modified
    100ms  value to be set on this metric

So overall this adds a delay of 100ms to outbound traffic.

This is how can you set it up to simulate 5 percent of packet loss, 2 percent of packet corruption and 1% of duplication:

tc qdisc add dev eth0 root netem loss 5%tc qdisc change dev eth0 root netem corrupt 2%tc qdisc change dev eth0 root netem duplicate 1%

Not enough? Here comes more:

tc qdisc change dev eth0 root netem delay 10ms reorder 25%

With this rule, 25 percent of packets will get sent immediately, others will be delayed by 20ms.

And so on, I think you have got the idea. In the end if you want to delete these traffic shaping rules, just execute:

tc qdisc del dev eth0 root

Check out the manual to get more information.

It is installed on scat Ubuntu 20.04.5 LTS

the line I need to use is:

sudo tc qdisc add dev eno1 root netem delay 100ms

first of all test with 40



set up 40ms delay on outgoing traffic:
--------------------------------------
sudo tc qdisc add dev eno1 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev eno1 root


How can I use netem on incoming traffic?

You need to use the Intermediate Functional Block pseudo-device IFB . This network device allows attaching queuing discplines to incoming packets.

 # modprobe ifb
 # ip link set dev ifb0 up
 # tc qdisc add dev eth0 ingress
 # tc filter add dev eth0 parent ffff: \
   protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
 # tc qdisc add dev ifb0 root netem delay 750ms



set up 40ms delay on incoming traffic:
--------------------------------------
sudo modprobe ifb
sudo ip link set dev ifb0 up
sudo tc qdisc add dev eno1 ingress
sudo tc filter add dev eno1 parent ffff: protocol ip u32 match u32 0 0 flowid 1:1 action mirred egress redirect dev ifb0
sudo tc qdisc add dev ifb0 root netem delay 40ms

cancel:
--------------------------------------
sudo tc qdisc del dev ifb0 root

















can I do some sort of max correction measurement on the client?
like actually measure the difference between the local and the server
lets use players x pos.. beacuse y might be on the ground...


how to do this??


good, now what to do with it?

get the max and avg

no, just the max, but reset every 2-3 sec

   float xcor_max;
   int xcor_reset_frame;


this works...


the max correction I can get is when I am manuall running back and forth, fakekey has much less corrections

the max possible would be if I was running in one direction and changed the same frame I got a correction...i think...

test manually for now by running back and forth

I think the max is achieved by running in one direction than changing
that way I get multiples of 4, the max x speed of the player




LAN (40ms) 20in 20out

s1:3 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  6        3    0    0          0           12
-35  5        2    -1   0          0           8
-20  4        1    -1   0          0           4
+5   3        0    -2   yes        0

s1:2 s2:0
offs move_lag crwd sgms late_cdats base_resets xcor_max
-55  nan      3    0    0          const       12
-45  4        2    0    0          0           8
-20  3        1    -1   0          0           4
+5   2        0    -2   yes        0



LAN (60ms) 30in 30out

s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  6/7      2/3  -1    0          0           12
-45  6        2    -1    0          0           8 - playable
-36  6        2    -1/-2 yes        0           4 late cdats  start

s1:3 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-50  5/6      2/3  -1    0          occ         12 base resets stop
-45  5        2    -1    0          0           8 - playable
-36  5        2    -1/-2 yes        yes         4 late cdats and base resets start

s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
at no time do base resets stop...
late cdats start at -35



LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable



LAN (100ms) 50in 50out
s1:5 late cdats start at -76
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-80  9        4    -1    0          0           16 - playable

now I want to test with random shittienes...

lets do 30 20 on both in and out

from 10-50 delay

its still playable at -80 on s1:5


I can't wait to test dropped packets and corrupt packets

duplicates should not be a problem, but corrupt? I have nothing to stop bad shit from happening...

reset cor_max on level start...with player stuff...done...

don't reset offset mode and offset...

how am I going to set this up?

- use ping average

first of all, how should I set s1:?

actually even before that, does s2 really not do anything useful?

go back to an exmaple




LAN (80ms) 40in 40out

s1:2 const base resets
s1:3 const base resets
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

s1:5 no base resets til +43 late cdats start at -55
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-60  8        3    -1    0          0           12 - playable


try this with different s2 values...


sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms




LAN (80ms) 40in 40out

then
s1:4 no base resets from 33-48, but nowhere in that range can I get no late cdats

now:
s1:4 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
base resets stop at -73 and start again at -1

base resets start at -81



I am so confused...


I should make a training sequence to get this info automatically

It should cycle through the values for offset and see where base resets and late cdats happens...



how can I do this?

start server on s1:3

redo all these test manually and this time:

measure when br and lc start and stop...




sudo tc qdisc change dev eno1 root netem delay 0ms
sudo tc qdisc change dev ifb0 root netem delay 0ms


LAN (0ms)
s1:2 s2:0
offs move_lag crwd sgms  late_cdats base_resets xcor_max
-25  3/4      1/2   0    0          0
-15  3        1     0    0          0           4
0    2/3      0/1   -1   0          0           4
25   2        -1/0  -2   yes        0

late cdats start >+25 stop: n/a
base reset start lose sever before than happens


ping / 25

>100 = 4
>75  = 3
>50  = 2
>25  = 1

s1 = 2+(ping/25)

2 for LAN

3-5 for internet

first of all, find settings to get no base resets
s1 and offset

I guess even before that, go back to why lowering s1 can drop client and prevent reconnecting
I though I had it fixed but it still happens...

on client in the join procedure it look s like it never gets initial state


on server the first drop was for last stak rx > 100 (fix spelling!!!)


maybe on the server the rewind thing gets broken...

   int s1 = players1[0].s1;
   int s2 = players1[0].s2;
   int s3 = s1+s2;

   // is it time to make a new dif and send to clients?
   if (mwPS.frame_num == srv_client_state_frame_num[0][1] + s3)
   {


   if (mwPS.frame_num >= srv_client_state_frame_num[0][1] + s3)

I think that fixed that...lets see if I can lower s2 to 0 also...
looks good....


now how can I do a training session?

makes sense for newly joining clients, but not server

run training session on client....



ramps through the offset values by fives
starts at 0 and decreases until -100

stays on each for 1s

how many late_cdats
how many base_reset

---------------


I still want to know if changing s2 does anything

sudo tc qdisc change dev eno1 root netem delay 40ms
sudo tc qdisc change dev ifb0 root netem delay 40ms


LAN (80ms) 40in 40out
s1:4 s2:0
base resets
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
start at -100 and increase
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


here is some great evidence...changing s2 from 0 to 1 definitely affected late cdats
but...did it really???
it just put a 25ms offset on dsync!!!



test some more...

why are base resets so cyclic?










LAN (100ms) 50in 50out
s1:5 s2:0
base resets never
late cdats start at -76

LAN (100ms) 50in 50out
s1:4 s2:0
base resets always
late cdats start at -76

LAN (90ms) 45in 45out
s1:5 s2:0
base resets never
late cdats start at -66

LAN (90ms) 45in 45out
s1:4 s2:0
base resets (16 on)
-90 to -76
-66 to -50
late cdats start at -66


LAN (80ms) 40in 40out
s1:5 s2:0
base resets never from -100 to +40
late cdats start at -56

LAN (80ms) 40in 40out
s1:4 s2:1
base resets (7 on)
-81 to -74
-56 to -49
-31 to -24
-6 to +1
late cdats start at -31


LAN (70ms) 35in 35out
s1:4 s2:0
base resets: never from -100 to 0
late cdats start at -46

LAN (70ms) 35in 35out
s1:3 s2:0
base resets: (20 on)
-95 to -75
-70 to -50
-55 to -25
-20 to 0
late cdats start at -46


LAN (60ms) 30in 30out
s1:4 s2:0
base resets: never
late cdats start at -36

LAN (60ms) 30in 30out
s1:3 s2:0
base resets: (9 on)
-86 to -75
-61 to -49
-36 to -25
-11 to 0
late cdats start at -36



LAN (50ms) 25in 25out
s1:4 s2:0
base resets: never
late cdats start at -26

LAN (50ms) 25in 25out
s1:3 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at -26


LAN (40ms) 20in 20out
s1:3 s2:0
base resets: never
late cdats start at -16

LAN (40ms) 20in 20out
s1:2 s2:0
base resets: (16 on)
91-75
66-50
41-25
16-0
late cdats start at -16


LAN (30ms) 15in 15out
s1:3 s2:0
base resets: never
late cdats start at -6

LAN (30ms) 15in 15out
s1:2 s2:0
base resets: (6 on)
-81 to -75
-56 to -50
-31 to -25
-6 to 0
late cdats start at -6


LAN (20ms) 10in 10out
s1:2 s2:0
base resets: never
late cdats start at +4

LAN (20ms) 10in 10out
s1:1 s2:0
base resets: (21 on)
-96 to -75
-71 to -50
-46 to -25
-21 to 0
late cdats start at +4


LAN (10ms) 5in 5out
s1:2 s2:0
base resets: never
late cdats start at +14

LAN (10ms) 5in 5out
s1:1 s2:0
base resets: (11 on)
-86 to -75
-61 to -50
-36 to -25
-11 to 0
late cdats start at +14

LAN (0ms) 0in 0out
s1:2 s2:0
base resets: never
late cdats start at +24

LAN (0ms) 0in 0out
s1:1 s2:0
base resets: (2 on)
-76 to -75
-51 to -50
-26 to -25
-1 to 0
late cdats start at +24


what is the correlation of those two variables?

ping 100 needs s1:5 offset < -76  (4 + 25)
ping 90  needs s1:5 offset < -66  (4 + 16)
ping 80  needs s1:5 offset < -56  (4 + 7)
ping 70  needs s1:4 offset < -46  (3 + 20)
ping 60  needs s1:4 offset < -36  (3 + 9)
ping 50  needs s1:4 offset < -26  (3 + 2)
ping 40  needs s1:3 offset < -16  (2 + 16)
ping 30  needs s1:3 offset < -6   (2 + 6)
ping 20  needs s1:2 offset < +4   (1 + 21)
ping 10  needs s1:2 offset < +14  (1 + 11)
ping  0  needs s1:2 offset < +24  (1 + 2)

so, given an input, ping, formula for s1

                    ping/20
 0 < ping < 20 = 2    0
20 < ping < 40 = 3    1
40 < ping < 60 = 4    2
60 < ping < 80 = 5    3

s1 = 2 + (ping/20)

will never be less than 2



formula for offset

ping  offset
0  -> 10
10 -> 0
20 -> -10
30 -> -20

offset = (10-ping)

I can easily do this on the client
offset = (10-ping)


on the server though...

take the average client ping?
worst client ping?

set s1 from that?


but I don't want to change it too often

is once per second too often??

first of all, do the client auto stuff...done


now where to do the calc on the server



first of all, what the hell?


server sets:

            double t0 = PacketGetDouble();
            double t1 = al_get_time();
            players1[p].ping = t1 - t0;

when rxing both ping and pang...that cant be right....

cli tx ping
srv rx ping then tx pong
cli rx pong then tx pang
srv rx pang

it should be only when server rx's pang..it makes no sense to do it after rxing ping...


client does a nice average for its local ping..that doesn't help me..

server need to keep track of maximum and reset somehow...

make a var in player struct....

20230129 5:49 AM

I made a lot of progress yesterday...

I am pretty sure that s2 is not needed, all it does is adjust where in the cycle the dif is sent,
so all it really does give an offset to dsycn on the client...

I did a lot of tests, made some new measurements, and made some automatic adjustments..

I should add some of this info to the docs...


what am I going to do with client offset?

10-ping...
did I not alreay have -ping
yes I did...

so if I make the offset +10 by default that should so it. It will stay there unless changed..
that takes are of that...

now for for the other one...

everytime server gets a pang packet, it calculates the ping for that client
at the same time, it checks that ping value only against max client ping and sets if higher

if (players1[p].ping > players1[0].server_max_client_ping) players1[0].server_max_client_ping = players1[p].ping;

then in the once per second timer area, if server...
use that max client ping to set s1, then reset max client ping

if (ima_server)
{
   int cmp = players1[0].server_max_client_ping*1000;
   players1[0].server_max_client_ping = 0;
   if (cmp > 100) cmp = 100;
   players1[0].s1 = 2 + cmp/20; // use client max ping to set s1

this looks like it is finished, as long as it keeps working as good as it has...


so now what?


what are sc cs and rt in server debug grid?
are they used?
how are they calculated


void server_proc_stak_packet(void)
{
   int p                        = PacketGet1ByteInt();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;

   int sfn1 = ack_frame_num;
   int cfn = client_frame_num;
   int sfn2 = mwPS.frame_num;

   players1[p].sc_sync = sfn1 - cfn; // packet stdf from s to c  sfn1-cfn
   players1[p].cs_sync = cfn - sfn2; // packet stak from c to s  cfn-sfn
   players1[p].rt_sync = sfn2 - sfn1; // round trip to server back to server through client via stdf and stak


all three of them are only used to show in server debug grid, and I don't recall them ever being useful...

lets kill them...done...

make a new switch -tl to copy src dir only to linux...


done...

now just run pm -tu, then recompile on ubuntu..

now I can complie and run on linux with F9...not sure why I could not run on linux before, except command line...
still can't just click on the executable in linux though...


anyway, now that I have that done lets check out the new server debug grid


what is lcls...late cdats last second...makes sense...
lets hide if for now...


when server displays dsync for clients, where does it come from?
client sends it to server with stak packet

what is gmav on server for each client...
// client game move sync avg last sec
the amount of time between server getting cdat and when it should be applied...???

pretty much follows offset on client....
when client offset is 10ms, gmav is -10...etc...i think ill keep it for now....but hide it



what is server_sync used for?

server keeps track of it for each client when stak packet received

void server_proc_stak_packet(void)
{
   int p                        = PacketGet1ByteInt();
   int ack_frame_num            = PacketGet4ByteInt();
   int client_frame_num         = PacketGet4ByteInt();
   players1[p].frames_skipped   = PacketGet4ByteInt();
   players1[p].client_chase_fps = PacketGetDouble();
   players1[p].dsync            = PacketGetDouble();

   players1[p].server_sync = mwPS.frame_num - client_frame_num;
   server_lock_client(p);



server uses it to lock clients when first joining

void server_lock_client(int p)
{
   if ((!players[p].active) && (players[p].control_method == 2)) // inactive client chasing for lock
   {
      if ((players1[p].server_sync > -2) && (players1[p].server_sync < 5)) players1[p].sync_stabilization_holdoff++;
      else players1[p].sync_stabilization_holdoff = 0;
   }
   if (players1[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
   {
      add_game_move(mwPS.frame_num + 4, 1, p, players[p].color);
      players1[p].sync_stabilization_holdoff = 0;

      sprintf(msg,"Player:%d has locked and will become active in 4 frames!", p);
      if (LOG_NET_join) add_log_entry_header(11, 0, msg, 0);
   }
}


server uses it to drop clients if it goes over 100

         if ((players[p].active) && (players1[p].server_sync > 100))
         {
            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)

            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
         }


I now have dsync, which does pretty much the same thing, only higher resolution..
it is calculated on the client and passed to server with stak packet....

just for the sake of making things simpler, could I replace server_sync with the dsync that I get from clients?

why do I need both?


right now, server does not get anything for server_sync until it gets stak packet from client, this should not change anything...


lets run a log and look at the stak packets rx'e by server...especially when joining and level done...



first try to replace in the locking part....

what ranges should I use?

max +30  +0.03
min -150 -0.15
try that...


it seems to work but I should try it on some shitty networks....

where does it show waiting for sync?
it show it on the client (duh!) and uses the varaible client_sync...

on the client,

calculated in rx_stdf:
players1[p].client_sync = dst - mwPS.frame_num;                        // crude integer sync based on frame numbers

then used to calculate higher resolution dsync:
players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot

then after that it is used only to display...
log entries,
client debug grid
"Please wait for server sync" overlay

I think I want make it only used for a few lines in rx stdf
then after that, just use dsync...
client_sync is gone....

back to server sync...

test with 40 30 on both

it joined...


try 80 on both (160)

it still joined...
I think the target was 150 (160-10) so try 90 90 (180)

now it fails...

lets try setting the limit to 0.2 or (200)

that works, it finally joined with a ping of 200

reduced stabilization time to 10 frames...

OK moving on to removing server_sync....

do I even need to drop players with a huge sync??
how about I take a page from the join stuff and make it so that it has to be over the value for a specified number of frames?
or just don't do it...lets try not doing it....

//         if ((players[p].active) && (players1[p].server_sync > 100))
//         {
//            //printf("[%4d] server_sync:[%4d] drop p:%d \n", mwPS.frame_num, players1[p].server_sync, p);
//            add_game_move(mwPS.frame_num + 4, 2, p, 70); // make client inactive (reason sync > 100)
//
//            sprintf(msg,"Server dropped player:%d (server sync > 100)", p);
//            if (LOG_NET) add_log_entry_header(10, p, msg, 1);
//         }
server_sync is completely gone....


that all seems to work...


bug...can't quit on client while waiting for sync

after getting initial state it goes to mode 11, the normal running mode...
but the client is not active yet, until the server says it is....
all I want is a way out of this mode...

added this to control....

      else if (players[p].control_method == 4) // not active and control method 4 is a client waiting for server to make it active
      {
         if (mI.key[ALLEGRO_KEY_ESCAPE][1]) new_program_state = 25; // give them an escape option
      }

there do not seem to be any other escape routes in client setup...

if the network setup fails, it will just timeout...

what about when waiting for a join invitation?
it normally never fails, but lets make it fail then make a way out...done
nothing is shown, except on the console, but that's ok

can I add one to the network setup?
especially the part where it waits for a response...done

now fix what you broke....done...


moving right along... now what?

remove s2....

should I rename s1?

im doing documnenataion and would like to call it something else..

i used to call it stdf freq

how about dif_freq?
i like that
server_state_frequency would be more accurate
it does rewinds and makes states even when it has no clients...


ok

server_state_frequency it is....

find all s1 and replace...

also kill s2..

...........


more testing, with corrupted and missing packets

more documentation... did a lot of doc......



I don't think I need to send the client ping when the client joins...it should be fine just doing it with just the 2 Hz png_timer
the timer is constantly running, and therefore the flag is set..
only gets cleared if it actually send a ping...

ima_client gets set when sjon is rx'd

while waiting for initial state we are not in mode 11 yet

as soon as innitial stae is rx'd flag is set and we are in mode 11

but!!.. ping is not sent in game loop, it is sent just past it on the outside..

so ping will be sent with 2 Hz timer as soon as ima_client is set when sjon is rx'd
the extra one when initial state is rx'd is still not needed...

OK I'm convinced...kill it...


I don't think I want to save players1[0].server_state_freq in config file anymore...
after all, i dysnalically set it...
just make sure it has a sane value...

at the same time, also lose zlib compression...I have never once changed it...done...

what about TCP/UDP? leave it for now, but its very experimental

Actually I would have liked to experiment with zlib_cmp...
I should make i changeable as the game is running...but no need to set it in config though...

-------------------------


next...


while gointg through the code, i realize...

why do I have two states for every client?

I only keep one previous state...

the other one is only used as a temp storage when making difs...

make sure this is the case, then remove it..

15 occurances:
2 define and declare
4 for clear

that leaves 9
4 time server only [0]
all cases where I use it for the server:
I use [0][1]


I know why!!

I don't actually overwrite the old state until I get an ack for the new one....

OK, just leave it....

experiment with zlib_cmp...I would really like to see it in real time...
i still like 7 the best








can I make a general rolling average algorithm...

then just make instances of it?

what would that look like?
a class


OK, I think I have the class done, now how to patch it in...

lets do cpu...

I need to choose which one I'm going to use and initialize it somewhere....you don't even have to initialize!

make cpu graph show inst and avg...but make text use avg...

looking good...

I add data in loop..
I draw in graph screen overlay

I am spending far too much time on this...
be done with CPU...
in the very middle: CPU: just liek it used to be, then min and max on each side...
CPU is done!!


now redo ping with new RollingAverage

0 = CPU
1 = PING
2 = DSYNC
right in ping array was where the avg was used...move it...done

I think ping is done
next dsync..done...

now remove ping_buffer and all traces of it...done...

nice...now I have a nice rolling average I can use when I want...

I should send dsync _avg to server instead of raw...done

remove the adjustments to s1..just comment out..done
but then I would like to be able to view state_freq...put it in debug grid....done






can I let client know when late cdats happen, so I might adjust offset to prevent it??
the only way would be to add it to stdf packet and that is pretty much full...
I think I use 1022/1024 bytes already


      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mwPS.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mwPS.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, players1[p].who, p);
      start_byte+=1000;


4 stdf
4
4
1
1
4
4
1000
--
1022

do I need 4 bytes for start_byte and packet data size?


what is tha max the could be

well packet_data_size would be 1000 max

what is the data range of a 2byte int?

2^16 = 63356
or +/- 32768

what is the max data size we are prepared to handle? do I have a limit somewhere?

I'm putting it in a buffer the size of a state so that is not a limit...

I don't see anything on the server that would limit it...
it just breaks it into 1000byte pieces...

ok, i only use 1 byte for num_packets so I have a limit of 256 there....

on the client, I have client_state_buffer_pieces[i]

int  client_state_buffer_pieces[16];   // to mark packet pieces as received

so there is my only limit so far and it would be trivial to increase...

start_byte could be 16,000 if I used 16 packets...
still easily fit into 2 bytes...

should I do it?

reduce to 2 bytes...

then I would have 6 extra...
what do I want to send?  how about late_cdats_last_sec...
what is the max that could be?
40 fps could be 40 late cdats...hell I could just use 1 byte for that...
lets just do that...done

OK now client has late_cdats_last_sec...what is he going to do about it?

when not zero, show a warning on the screen in red...

can I make rtextout_centre take an arbitrary font?

11 occurances...
9 uses...2 i just used...
converted...also that fixed edit server name having the wrong font...

I think I will just put this error message on the bottom frame...I like it there better....done...






make the mouse disappear if not moved and and appear if moved
I could put this in the event processing loop...

make a 5s timer...
if the event timer fires (times out), hide the mouse...
if the mouse is moved, show the mouse and reset timer
this worked on my first try...

   mou_timer = al_create_timer(5);    // 5s
   // register timer event source
   al_register_event_source(event_queue, al_get_timer_event_source(mou_timer));
   // start timers
   al_start_timer(mou_timer);

   if (ev.type == ALLEGRO_EVENT_MOUSE_AXES)
   {
      al_set_timer_count(mou_timer, 0);
      al_show_mouse_cursor(display);
   }
   if (ev.timer.source == mou_timer) al_hide_mouse_cursor(display);

done......

it is 5:44PM on Jan 30, 2023

I took today opff work due to being sick with a headache...

got a lot done...

next up on the things to do, test more with shitty networks...





there is some stuff that should be cleaned up in program states...

when client exits, it has its own special state 25 where it cleans up, then goes to state 1.

server does not have this...just goes to 1...

in 1:
         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();

            if (autosave_log_on_game_exit) save_log_file();
            if (autosave_game_on_game_exit) blind_save_game_moves(2);

            stop_sound();
            if (program_state != 3) stamp();

            program_state = old_program_state; // go back to the state that called 0,1,2 or 3
         }
      }
      new_program_state = 0;

in 25:

   //---------------------------------------
   // 25 - client exit
   //---------------------------------------
   if (program_state == 25) // client exit
   {
      client_exit();
      new_program_state = 1;
   }

in the interests of making them both them same...

should I make them both like client, or both like server??



both like client...

add a new state then..

19 is server_exit

now find places where the server would exit...


I think I still want to keep:

         if (new_program_state == 1) // game menu or fast exit
         {
            if (ima_server) server_exit();
            if (ima_client) client_exit();


and use 19 and 25 for errors in setup...

not sure what I gained here...at least its more consistant looking


now back to doc...where was I? server_setup...??





I have an urge to figure out more exactly what is going on with the timing loop in netgame...


I can picture the server making and sending the state on a specific frame

I will draw a rectangle with time on the y axis like normal

then I will draw a rectangle below it show the clients frame and the offset is determined ny the ping and offset...

I need pictures, diagrams..



go back to your data...

when you increase offset evetually you get late cdat on the server, right?? yes...



that would mean that increasing offset, makes the clients less ahead of the server..

dsync > 0   client gets difs for future frames
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client gets difs for past frames

as the dsync decreases the client has to rewind, meaning that it got a past dif, meaning that the client is further ahead of the server...

dsync > 0   client is further behind
dysnc = 0   client gets difs exactly when needed for current frame_and_title
dsync < 0   client is further ahead

so... when offset increases, the client is further behind, until late cdats happen







could I actually do these graphs in real time, based on the real data??

server would should a rectangle the size of stdf freq frames...
server would show when it got stak replies and cdats...



I would need persistant data over the course of a state

sending a new state would reset the variable...

start_frame_num
start_frame_ms
num_frames
num_ms

sdak_rx_ms - how many milliseconds to get the reply from the client
cdat_rx_ms - cdat offset from frame start...


do I already do this with sgms? server game move sync?
measure how far off the cdats are from when they are needed?

I do...

on the sever, I maeasure that and it it always the neagtive of dysnc on the server

for ping 0..clients dsync 10 gmav -10

so I already have this...

what am I trying to figure out here?

Do i just want some nice pictures to help me understand?


from the server's point of view:

see the entire state to state block.
see when sdaks come back..
see when client input arrives..
see how far the client is running ahead/behind

from the client's point of view..
show timing relation to server, (dsync)

I don't think I am getting anything new here...

this is all information I already have...

I think the most important thing is to set state_freq first.
make that as fast as possible, without getting base resets
right now I am just setting that based on ping...

would it be any better if I set it based on how long it takes to get stak replies?
they are pretty much the same thing as pings...??

then after that set the client offset...

I really can't see any improvements to be made...

I think I might be getting a little lost here...

I think I need to officially stop messing with the netgame stuff...
I am afraid that there might be a few improvements I could do that if I don't do it now I never will...

the only improvement I could possibly think of, is when in the loop are dif's made and sent...

I went down that rabbit hole once, it was very complicated and I never came to any resolution...

at most, I could save part of a frame in time...maybe...

here is the old description:

In the game loop, 'server_send_stdf()' is called after 'move()' but before 'draw()'

It is important that it is in this place in the game loop.

It cannot be called before move...why not??

Was it because in the old way, frame numbers changing was a big issue?

Now the frame numbers are the same in both places.

the state needs to be made at a very specific place in the loop, you can't just move it before or after the input has been applied and moves made

I don't think it really matters at all now, but I would like to test it.....later

now that I think about it, why do I make a state before input is applied for a frame?

I don't know, but it smells wrong...

rewind 3
play 3
make state
do input
move
send dif
draw

back to top



what do you think it should look like, and why?

rewind and get all missed input
do input for this frame
move

make and send state

draw


what if I did the rewind for input independant of the make and send state?

and only do it if there is actually something to rewind for...

I could do it every frame. if I remember, it was not expensive in cpu time..

but why? what are you trying to achieve?

premature optimization when you don't even think there is a problem?

the problem I thought I saw was the server replaying and making states early in the frame.
then still applying local input and doing the move after...

I thought this would result in the state being made and sent to the clients just before it changed as opposed to just after it changed...
that still seems true..


but the way I have things set up, after loading a state, both client and server still expect to play that frame out...

what if I changed it to:

server saves states after all input and moves are done for mwPS.frame_num
then when loading them the first thing that shoud be done is to increment the frame number and start at the top of the loop.

basically I would be changing the states behaviuor from:
frame:100 starting state
to:
frame:100 ending state



OK this is the final time we go over this:


frame++ (100)

server control
 - check for client input and put in game moves array (could get client input for 100 here)
 - time to make state? rewind and replay then make new state for 100 (before any processing of 100)

local input for 100
game moves array input

move 100

send stdf for 100 (pre move)

draw 100


the first thing I notice is that there is no reason to wait until after move to send the state
nothing about the state will change...

the second thing...
the rewind, replay, and make state are at the start of the frame after the previous frame pause...


a thought....

----------------

top of frame

frame++

if it is time to make a new state:

at the start of the frame:
- check for more client input
- do the rewind

do local and game move input...

move the frame

make the state and send it with the frame number for the next frame

draw the frame

----------


all that would be required to make this change is:
- move the part where the state gets made to the send part
- date the frame to the future...

a state would still refer to a frame that has not been processed yet...
the starting state of a frame...

the benefit would be that I am not waiting till the next frame to send a state from the previous...


I think I have convinced myself to do this:

I was very easy to implement...


the first thing I noticed is that late cdats happen at the normal +10 offset...

changing to -10 fixed that..

that would make sense as my timing has shifted by the entire wait period...


should I redo all my time testing? yes


put back the manual adjust of state_freq...



I am loving this new way....

on the server I monitor cdsync and gmav
they can both run in low single didgits


I was working on some tools to help me understand in finer detail what is happening with
the different offsets and state_frequency settings...

I still kind of want to understand this better.


I was wondering if I could remove the ping stuff...
the only reason is to simplify things...

I was thinking of using the stdf-stak exchange..
then the server could calculate ping and send it to clients..

but...
client only replies when applying the dif..

nevermind...it is fine the way that it is..




Could I show a nice rectangular graphical representaition on the server...
Show the width of the state_freq
show when cdats mostly come in
show the client sync
show when sdak was recieved...

does this even make any sense?

the data I would need to keep..

once per state save

start frame
end frame
when was stak rx'd (in finer resolution than 1 frame)
client offset
all the client cdat sync times..

I could just start with frame and stak rx...

make stak rx time and use fine detail


I made stak_dsync and am testing..


something weird..

on LAN (ping < 1)
state_freq = 1

no matter how I adjust client offset, I never get base resets...
saem with 20ms

lets try 30..finally I get some..

stak_dsync is not what I think it should be

I want it to be a positive number in ms
of how far after the frame start i receive stak...
it will probably be very similar to raw ping

I don't seem to be getting anywhere with this


OK lets do something easier, maybe...make a class for last_sec...

what uses it?

lots...
late_cdats_last_sec
game_move_dsync_avg_last_sec
frames_skipped_last_sec
timer_adjust_last_sec

bandwidth counters..
also do frame as well as last sec..

what does each one have in common?
they need a tally, a running total

optional:
number of entries
average
min
max

OK do it...
first what are you going to call it?

mwPerSecond


while implementing, I realized, it doesn't have to be per second
it could be any arbitrary period..
whenever calc is called

also I realized I want to fix the naming of my classes

I want them all to begin with mw then use CamelCase

what do I have so far?

e_mWindow
z_mwGraph
z_qGraph
z_mwRollingAverage
z_mwPerSecond


this is what I want:

mwWindow
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

I want the file name for the cpp and h to be the same as the class name...

start with an easy one: qGrapgh

remove files from project
rename
add files to project

done:
mwGraph mwG[]
mwQuickGraph mwQG[]
mwRollingAverage mwRA[]
mwTally mwT[]

window is huge...do it later...


i think tally is ready to implement...

lets try late_cdats_last_sec...

it looks like there are 3 varaibles used in player struct..

   int late_cdats;
   int late_cdats_last_sec;
   int late_cdats_last_sec_tally;

I will keep:
   int late_cdats;
   int late_cdats_last_sec;


this is where I add:

      players1[p].late_cdats++;
      //players1[p].late_cdats_last_sec_tally++;
      mwT[0].add_data(1);

this is where I initialize:

      players1[p].late_cdats = 0;
      mwT[0].initialize();

this is where I tally:
                     players1[p].late_cdats_last_sec = mwT[0].get_tally();
                     //players1[p].late_cdats_last_sec = players1[p].late_cdats_last_sec_tally;
                     //players1[p].late_cdats_last_sec_tally = 0;



OK this one works...

now these:

mwT[1]

   int frames_skipped;
   int frames_skipped_last_sec;
   int frames_skipped_last_sec_tally;

mwT[2]
   int timer_adjust;
   int timer_adjust_last_sec;
   int timer_adjust_last_sec_tally;



            players1[active_local_player].frames_skipped_last_sec = mwT[1].get_tally();
//            players1[active_local_player].frames_skipped_last_sec = players1[active_local_player].frames_skipped_last_sec_tally;
//            players1[active_local_player].frames_skipped_last_sec_tally = 0;

            players1[active_local_player].timer_adjust_last_sec = mwT[2].get_tally();
//            players1[active_local_player].timer_adjust_last_sec = players1[active_local_player].timer_adjust_last_sec_tally;
//            players1[active_local_player].timer_adjust_last_sec_tally = 0;



      players1[p].frames_skipped = 0;
      players1[p].frames_skipped_last_sec = 0;
      mwT[1].initialize();

      players1[p].timer_adjust = 0;
      players1[p].timer_adjust_last_sec = 0;
      mwT[2].initialize();


those two are done...this is going well...
can't wait to do more...



now for a more difficlut one

mwT[3].initialize();


game_move_dsync_avg_last_sec

   double game_move_dsync; // current value
   double game_move_dsync_max; // never used
   double game_move_dsync_avg_last_sec;
   double game_move_dsync_avg_last_sec_tally;
   double game_move_dsync_avg_last_sec_count;


                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
                     {
                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
                        players1[p].game_move_dsync_avg_last_sec_count = 0;
                     }

   // calculate game_move_dsync
   players1[p].game_move_dsync = ( (double) players1[p].server_game_move_sync * 0.025) + timestamp_frame_start - timestamp;
   mwT[3].add_data(players1[p].game_move_dsync);
//   players1[p].game_move_dsync_avg_last_sec_tally += players1[p].game_move_dsync;
//   players1[p].game_move_dsync_avg_last_sec_count +=1;



                     players1[p].game_move_dsync_avg_last_sec = mwT[3].get_avg();
//                     if (players1[p].game_move_dsync_avg_last_sec_count > 0)
//                     {
//                        players1[p].game_move_dsync_avg_last_sec = players1[p].game_move_dsync_avg_last_sec_tally / players1[p].game_move_dsync_avg_last_sec_count;
//                        players1[p].game_move_dsync_avg_last_sec_tally = 0;
//                        players1[p].game_move_dsync_avg_last_sec_count = 0;
//                     }



server max client ping...
mwT[4].initialize();

               if (players1[0].server_state_freq_mode == 1) // 0 = manual, 1 = auto
               {
                  int mcp = players1[0].server_max_client_ping*1000;
                  players1[0].server_max_client_ping = 0;
                  if (mcp > 100) mcp = 100;
                  //players1[0].server_state_freq = 2 + mcp/20; // use max_client_ping to set server_state_freq
                  players1[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq
               }


OK I think I have all those done:

should I test them??

what about bandwidth?
leave for now...



I am thinking about reanmeing functions in server send state...


now:
void server_create_new_state(void) // rewids and sets flag

void server_send_stdf(void) // craetes new state

void server_send_stdf(int p) // send stdf to a specific client


new:

server_rewind...done
server_create_new_state..done
server_send_dif..done



I want to do some tests...

with lots of clients..


I was a little concerned when running a game with 40ms lag
I saw what looked like quite huge corrections.
On one client to another.
Viewing a client with fake key on another client looked very jumpy...




OK I have some serious bugs here


some clients simply cannot connect:
they either fail at sync with a high number till they time out
or they never get the initial state...

why? what is going on??


it looks like they have a very high cpu..

it looks like draw it taking >20ms

but then clients cannot connect after that

and on server

state_freq is an enormous number....

log when it is set...

or just print...

fixed a bug the tally max code used by max client_ping
now if no enries, the max returned is zero, not min double!

deploy to server and test...better


Now running profile on client
draw
8 ms lift
7 ms screen overlay
2 ms item

this is on level 13 which has 15 lifts...not even close to a max...

also it seems to take a long time to chase...



on client, the time inbetween init state and first timer adjust

1-3 frame

level 150
m36   3f -6
      2f +3

4230l 1f +39
      1f +25



level 13
m36   2f +5
      2f +12


4230l 1f +177
      3f +175

I can't see what might be causing this in the logs or profile


could it be redraw tiles in client_apply_dif?
profile it...does not look like the culprit

are you sure about this?

the time in between the initial state received and the first timer adjust...

look at timer_adjust...it never fires....

I just had a client that never connected. could not catch up...
It looks like when it is trying to go faster, it has even less time process the frame...
but more importantly, I don't think that skip drawing frame ever triggers!


old:
int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

   if ((mwPS.frame_num+0) < al_get_timer_count(fps_timer)) // skip drawing frame


it appears that in single player and client that fn is one less than timer

do I care?

i use the raw timer event to flag that it is time to process a frame...


should I keep them in sync? should timer always match the current frame?


the only thing I use the actual timer value for is deciding if I skip drawing

void set_frame_nums(int fn)
{
   // reset mwPS.frame_num and fps_timer count
	mwPS.frame_num = fn;
   al_set_timer_count(fps_timer, fn);
   reset_animation_sequence_frame_nums(fn);
}


at the start of loop i check to see if the counter is too far ahead

void proc_timer_adjust(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num+1)
   {
      players1[active_local_player].timer_adjust++;
      mwT[2].add_data(1); // add to tally
      al_set_timer_count(fps_timer, mwPS.frame_num+1);
      printf("Adjusted timer - fn:%d timer:%d\n", mwPS.frame_num, (int) al_get_timer_count(fps_timer));
   }
}


then later in the loop if check it again to see if I skip drawing:

int proc_frame_skip(void)
{
   if ((mwPS.frame_num+1) < al_get_timer_count(fps_timer)) // skip drawing frame
   {
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //players1[active_local_player].frames_skipped_last_sec_tally++;
      printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}


these conflict and are unccesarily complicated...

do it once..



int proc_frame_skip(void)
{
   if (al_get_timer_count(fps_timer) > mwPS.frame_num) // skip drawing frame
   {
      al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
      return 0;
   }
   return 1;
}

this has the effect of forcing timer to always have the value of frame number

the timer will fire and event an increment the timer

the loop will increment mwPS.frame_num

if, while processing the loop, the timer increments again, the loop will not be drawn

if, when starting the loop the timer is ahead of frame, frame will still be processed, but draw will be skipped.

when the test to draw is performed, if timer is ahead, it will be set to current......is this part necessary?
wont that speed up the game enough to catch up?

I want to try this without the reset timer...

the one thing I am not checking for is if the timer is behind mwPS.frame_num
we don't want to stop or slow the game to catch up to the timer (i think?)
so we should move the timer ahead to the actual mwPS.frame_num...
not sure if this ever happens though...

first:
comment out timer adjust (it never fired anyway)...
change
int proc_frame_skip(void)
{
   int draw_frame = 1;
   if (al_get_timer_count(fps_timer) > mwPS.frame_num)
   {
      draw_frame = 0;
      players1[active_local_player].frames_skipped++;
      mwT[1].add_data(1); // add to tally
      //printf("Skipped drawing frame:%d\n", mwPS.frame_num);
   }
   al_set_timer_count(fps_timer, mwPS.frame_num); // set timer to current frame
   return draw_frame;
}

mwPS.frame_num is the reference.
set the timer from this, not the other way around

why do I get to a place where clients cannot join server?
the only thing I can do is reset the server
clients stall at waiting for initial state...

client log shows that they cannot apply dif from over 100 frames in the future..
if (client_state_dif_src - mwPS.frame_num > 100)
fixed...
if ((client_state_dif_src - mwPS.frame_num > 100) && (mwPS.frame_num != 0))


now I want to make a much more minimal overlay
just show cpu and fsls in border...
done

still at 70% cpu on level 13
state_freq and zlib_cmp make no difference...

its still draw lift at 8ms

can I improve on that?
removed draw lift lines and got about 4ms

removed the drawing of 10 shrinking rounded filled rectangles
less than 1ms

I know it looks nice, but is there a less expensive way of drawing it?

same with lift lines...is every frame neccesary?

maybe I could measure if lifts draw time > 5ms then go to a simpler draw method...

draw lift lines every other frame...

etc...

go back to the original method of drawing lift lines
only when drawing background..

when do I do this:

switches, bombs, keys, block manip, client_apply_dif

I don't know if I can go back to this...
I just checked and I don't think lift lines ever change...

why is this such a change, did I not notice it before?

maybe I could make a global reduce cpu thingy..

don't I already have that with drawing less??


I think I broke stuff!

client does not play nice on cleint anymore  :(

I like it on m36 0ms...
and on e6430...

but on 4230j it does not seem to skip frames gracefully...


to test this....


make a function that adds delay in the draw stuff.
like pct_y

seems to work ok in single player...
but the terminology is a liitle off

FPS set..good
FPS actual..not really..
FPS skipped..just skipped drawing is all, not actually skipped...

have a look at this...

on the 1 Hz timer:
actual_fps = mwPS.frame_num - last_fps_frame_num;
last_fps_frame_num = mwPS.frame_num;

why? what good is this?

just use:
frames_skipped_drawing_total
frames_skipped_drawing_last_sec
done...

maybe actual fps had some use in speed testing?
it just records the number of times the game loop has been processed in the last 1s

something funny is going on...why does it record less when a frame skip happens?

when I change the timer count, do I also reset when the tick happens?

i think I should not be correcting the timer


when timer > frame then skip

but if i don't do any corections it will be the same next frame....


how about this:

at the start of the game loop:
fn++
timer event has fired and incremented timer_fn

before anything else...
if we are already behind at this point:
correct timer to match frame
flag this frame as not to be drawn

if we are on the same frame:
process as normal

then test to see if we are behind after processing...
if so, skip drawing, but do not correct timer..

so there will be two types:

one at frame start
one after processing

give this a try...

no luck...


I have made a big mess here...
this should not be complicated....



can I do a timestamp when the event fires then compare it with when the frame starts..

print timestamp on 1Hz timer...see if that is actually 1Hz
it is not...maybe its my stupid way of calling al_rest...

I should do something else to pause...

same with 40hz



am I all fucked up here?

timers do not seem to be firing when I think they should

I could be that I am doing things that pause them more than the period of the timer....


for example, if draw takes more that 25ms how do I handle that?

my network code needs the rest of the stuff to run at 40hz


even if I draw every other frame, when I do draw, the draw time being over 25ms will mess up my nice timing...


could I figure out a way to split the draw between 2 frames?


I think I should just put all this back together and abandon the idea of skipping draw frames for now....
It just does not work nicely

if I go over 80% cpu, I should enable econ_draw...



how much can I remove?

do I even care at all what the timer count is?

all I need is the timer event firing...

I'm gonna say no and remove it...



fix animation sequence...you know what I mean..

this has been this this way for over 25 years

I don't want to embed frame numbers in it anymore..

how does it work now?

   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count

what I need to do is:

make 2 the tally count and inc evey frame
if 2 > 3 then next shape and 2 = 0;

old:
void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = mwPS.frame_num of last seq change
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

  // printf("update_animation :%d\n", mwPS.frame_num);


   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
         if ((mwPS.frame_num - zz[2][y]) > zz[3][y])
         {
            zz[2][y] = mwPS.frame_num;                     // set counter
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
}

new:

void update_animation(void)
{
   // 0 = current shape
   // 1 = current shape index
   // 2 = count tally
   // 3 = seq change delay count
   // 4 = num of shapes in seq (15 shapes max)
   // 5 = shape 0
   // 19 = shape 14

   // printf("update_animation :%d\n", mwPS.frame_num);

   for (int y=0; y<NUM_ANS; y++)
      if (zz[4][y] != 0)
      {
         if ((++zz[2][y]) > zz[3][y])
         {
            zz[2][y] = 0;                             // reset tally
            zz[1][y]++;                               // next bitmap
            if (zz[1][y] > zz[4][y]) zz[1][y] = 0;    // is bitmap past end?
            zz[0][y] = zz[ 5 + zz[1][y] ] [y];        // put shape in 0
         }
      }
}

yay that has been there for far too long!

next I want to get rid of set_frame_nums();

at least in the game for now...done

now is there anything that reads timer?

yes, some stuff in level editor...I want to get rid of it too...

these no longer exist:
al_get_timer_count
al_set_timer_count
set_frame_nums()
proc_frame_skip()

so much simpler...

now I have removed all safeguards against cpu > 100%

bad things will happen!!

what do you want to do?

put draw in economy mode...

draw half the things one frame and half the next...but where do I draw the line?


   get_new_background(1);
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   get_new_screen_buffer(0, 0, 0);
   draw_screen_overlay();
   al_flip_display();




everything has to:

   get_new_background(1);
   get_new_screen_buffer(0, 0, 0);
   al_flip_display();


optional
   draw_lifts();
   draw_items();
   draw_enemies();
   draw_ebullets();
   draw_pbullets();
   draw_players();
   draw_screen_overlay();


int draw_seq[20]

0 = always
1 = odd frames
2 = even frames



I am tempted to make a acreen overlay that shows these times:

then go through the list from max to min and put one in each column...



I want to max this a class

mwDrawSequence

mwDS

only one instance

has an array for times, min, max, avg and draw sequence

everytime something is actually drawn the time is measured


it look horrible!!

lets rethink this:


odd:
   sprintf(name_long[0], "get_new_background");

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");

even

   optional...

   sprintf(name_long[7], "get_new_screen_buffer");

   optional...

   sprintf(name_long[9], "al_flip_display");


There is a lot of flickering no matter what I do.

I could make screen_overlay use its own bitmap.....

it is one of the biggest culprits

and in screen overlay, QuickGraph uses a lot

measure it..

or just disable it...


I think I am just going to leave stuff the way it is.

sure the screen overlay take lots of cpu, but you can just turn it off...

lets test...




I would like to make things optional in the debug screens

make a grid in settings:

number of debug levels across the top

things that can be shown is a list to the left

then a grid of check boxes.

different one for client and server:



server:

CPU graph
screen info
debug grid
bandwidth
draw timers
adjustment buttons


put text cpu in bottom display for all...far right...done


                    mode 0 mode 1 mode 2 mode 3
debug grid
cpu graph
sync graph
display info
bandwidth stats
draw timers
adjustment buttons
fps
player pos


overlay_grid[10][4]

overlay_grid[0][0]  debug grid on for mode 0
overlay_grid[0][1]  debug grid on for mode 1
overlay_grid[0][2]  debug grid on for mode 2
overlay_grid[0][3]  debug grid on for mode 3

overlay_grid[1][3]  cpu graph on for mode 0
...
...


can set the number of modes from 2 to 4




I think I have most of the client server stuff done...

there is also file play and demo mode to straighten out

push for now...



I want to straighten out the functions in screen overlay





























void show_player_stat_box(int tx, int y, int p)
void show_level_done(void)
void draw_screen_overlay(void)
void set_player_joint_quit_display(int p, int type, int time)
void show_player_join_quit(void)
void sdg_show_column(int col, int &x, int y)
void sdg_show(int x, int y) // server debug grid
void cdg_show(int x, int y) // client debug grid

void draw_top_frame(int p)

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)

void draw_top_display(void)



The very top is

void draw_screen_overlay(void)

it calls:

   show_level_done();
   draw_top_display();
   draw_bmsg();
   show_player_join_quit();


I want it to also call:

draw_top_frame
draw_bottom_frame

void draw_common_debug_overlay(int p, int &cx, int &cy)
void draw_server_debug_overlay(int p, int &cx, int &cy)
void draw_client_debug_overlay(int p, int &cx, int &cy)


and remove top_display...



I want to combine draw_top display text stuff and debug display stuff...

can I call it
draw_on_screen_overlay

it will have sections for server, client, file, common
it will call debug overlays
misc text overlays
waiiting to join
demo mode overlay...

just rename top_display to draw_on_screen_overlay




that was a lot of rearranging...hopefully it's better now:

void draw_screen_overlay(void)
{
   int p = active_local_player;
   int cx = BORDER_WIDTH;
   int cy = BORDER_WIDTH+72;

   al_set_target_backbuffer(display);

   if (LOG_TMR_scrn_overlay) t0 = al_get_time();

   show_level_done();

   draw_bmsg();

   show_player_join_quit();

   draw_top_frame(p);
   draw_bottom_frame(p);

   draw_common_debug_overlay(p, cx, cy);

   if (ima_server)                     draw_server_debug_overlay(p, cx, cy);
   if (ima_client)                     draw_client_debug_overlay(p, cx, cy);
   if (players[0].control_method == 1) draw_demo_debug_overlay(p, cx, cy);

   if (LOG_TMR_scrn_overlay) add_log_TMR(al_get_time() - t0, "scrn_overlay_all", 0);
}

do some testing and make sure demo mode is working
display stuff draws on border...fixed...
demo mode misc...good..

single player..good

fix pos and backgrounf for draw profile timers..done..
test client...
fix bandwidth...done
why is packets per sec rx so high?? fixed

what about the space after the debug grid?
if not used can be move everything else up?

I guess it all depends on what order I draw things in..

first:
debug grid
specific misc

last:
display
timers
bandwidth


common does in this order:
display
profile
cpu

client does in this order:
debug grid
sync graph
snyc adjust
misc
bandwidth

server does in this order:
debug grid
adjust
misc
bandwidth

demo does in this order:
misc


so if I just switch common to after specific, then make debug grid part of the cy stuff....


OK this is all looking good

If everything is on, this is the order it shows in:
debug grid
misc
bandwidth
display
profile

I just have server left to do:
make debug grid like client..done...

server adjust widget... where should i put it?

on the right like client?

just above cpu...done..


the only thing I still want to test is where late cdats are drawn in flashing on bottom frame...

I need to manually adjust offset till I get late..done and it lokks great..

in demo mode stuff overwrites the player array...fixed...

now in settings:
make a default button
reduce the number of debug states

the samllest screen size that the entire settings thing fits on is 400x400..


I am finally done with all this debug overlay stuff...it looks pretty good too.

Now to clean up that mess I made with the drawing....

In loop it is fine, just one call to mwDW

The class takes care of
drawing
profiling and averaging
printing screen overlay of results
plus all the optional stuff that didn't work out as planned

It all looks good...logging annd overlay work...the rest has been disabled...


An important question I need to ask?  Do you feel lucky, punk?

I have disabled all frame skipping.  I expect bad things to happen if cpu hits 100%.

What actually happens? Should I try to do something about it?

My rationale was mostly this:

99% of the time, the reason we will not be able to draw is that the draw function takes too long.
It is exceeding rare that the other part of the code is the limiting factor.

I still want to do soemthing about it though...

But what?

I have made it possible to disable with fine control all the bad things in screen overlay.

What about drawing every other frame, just doing the frame skip like we used to?
I can have a mode where I draw thing as simple as possible..

I would like to automatically play all the demo levels and record info about what timing profiles they have...
not every frame, but lets say the average of the last 10s

then I could try out some new economical draw routines

One that comes to mind right away is lifts.

I could draw lifts using much less resource than I do now.


I should just make a global int eco_draw...

be able to toggle it on and off and see what I can do...

I have made a global;
extern int eco_draw;
saved in config
toggle with F2
display on bottom frame...

yay!

now lets test it in draw lifts..


level 155 with 39 lifts with 37 steps each
1400 circles

4.7 ms 3 circles
2.4 ms 1 circle
1.3 ms 0 circles

stick in on 0 for now and test rects..

0.19 1      filled rect
0.20 1      filled rounded rect
0.51 10 not-filled rounded rects and 1 filled not-rounded

that is quite an impressive change..

total:
4.96 original
0.99 eco

5 times faster...


lets try this shit on a 4230
level 13
8.5 ms original
1.5 ms eco_draw

level 155
125 ms original
26 ms eco_draw

nice... now what else can I try to eco?

I think pmsg are a resource hog....

lets make a test level...copy 1...

level 154 has 105 messages
1.99 ms original
1.62 ms force all frame sizes over 1 to be 1

when the text is commented out
0.58 orig
0.19 eco

1.44 for text alone


what can I do?

I could draw them only once...
make a bitmap, draw the frame and text, then just draw the bitmap in the future...

maybe I could pre_calc line_height, so I don't have to do it every time


removing just the call to al_draw_multiline_text:
0.65 orig
0.28 eco_draw

1.34 just for al_draw_multiline_text:

I don't think that I can optimize this any further...
unless I predraw on bitmaps...

test on 4230...
level 154 with draw disabled
15 ms orig
5 ms eco_draw

draw enabled:
29 ms orig
19 ms eco_draw

it takes 14ms to draw text alone...


what are some other candidates?

things that draw rectangles, especially rect with diag lines
make a level with block damages and 10x10 rects...

level 157
50 block damage with 10x10 rect with diag...
1.15  ms orig
thats not too bad....
33 ms on 4230


what about vinepods?
they draw the entire vine every frame
level 158
10 vinepods
0.01 stationary
1.46 when fully extended

4230:
0.2 ms stationary
41  ms when fully extended

what about explosions??

figure out how to tell how much cpu time an explosion takes
- time drawing the circles
- time erasing blocks

so far the only thing I have been able to eco draw is
lifts
lift_lines
message frames



I am thinking that I should just say fuck it to the old 4230...I don't care if the game will run on it.

I still need to do something though when cpu hits 100%

what specs are the 4230's

64 bit win7 sp1
core2 T5500 @ 1.66GHz
2G RAM
Intel Mobile 945 Express
256M video memory







testing...


e6403 server on eidnet
ping 25-30


client 1 - m36
getting late cdats, no matter what offset I use

client 2 - scat
getting late cdats on server, but server never show any for late cdats last sec..
and client does not show any because lcls is what is being sent back and server thinks it is zero...


on server cdsy is about -35 for both clients, this seems normal
gmav of 4-8 for m36 and follows offset changes
but gmav is always zero for scat?

am i missing some things here, only done for first client?

the game is jumpy as ecxpected, late cdats and all...

but why?


I am using a tally for late_cdats last sec, and guess what?...I need one for each player

make them then...
extern mwTally mwT_late_cdat_last_sec[8];

extern mwTally mwT_game_move_dsync_avg_last_sec[8];



I think the late cdats can be explained by gmav


when offset is 10+ping sometimes it varies and you get late cdats
increasing to 20 gave more of a buffer and no more late...
well they were very rare....

look into this more...

I'm thinking that with state_freq 2 there is a pretty small window that client input can arrive in...

I want to make some logs and investigate...

make a function that returns a complimetary contrasting color.

use when you want to draw on the frame...

test it with version...looks good, now used whenever I draw on the frame.. I like it better that the yellow I was using before..







I want to get rid of the old proc_controllers();

136 matches..

I think most of the time, I am waiting for input, or a key to be released ...

in those case, a straight replacement with mwEQ.proc_event_queue would work...

other times, the menu_timer_block thing is being used...


down to 135...


I going to do a global replace for things like... while () proc_controllers()

proc_controllers()
mwEQ.proc_event_queue()
proc_event_queue_menu()


this is a replacement for when I want a timer

      while (!program_update) mwEQ.proc_event_queue();
      program_update = 0;

but then I'll never get the 3's to fire.. use 0 instead



in visual_level I also want the controls to be checked

add these two lines to peq...
no, I don't think I will...
   // only do key check for active local player


   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);

   if I want to do that I'll just make a wrapper
   that does both...

   for menu and visual level select...


    while (!menu_update) mwEQ.proc_event_queue();
    menu_update = 0;




e_bitmap.cpp done and checked
e_fnx.cpp done and checked
e_lift.cpp done
e_pde.cpp done
e_sliders.cpp done
e_visual_level.cpp
mwGraph.cpp
z_args.cpp done
z_log.cpp done
z_log.cpp done  // can't cancel splash screen??


edit_pmsg_text looks a little funny


0   - proc_controllers()
147 - mwEQ.proc_event_queue()
17  - proc_event_queue_menu()

officially gone!!!
void proc_controllers(void)
{
   int menu_timer_block=1;
   mI.key[ALLEGRO_KEY_PRINTSCREEN][0] = 0; // hack to make PRINTSCREEN key work properly
   key_pressed_ASCII = 0;

   while (menu_timer_block)
   {
      while (!al_is_event_queue_empty(event_queue))
      {
         ALLEGRO_EVENT ev;
         if (al_get_next_event(event_queue, &ev))
         {
            if ((ev.type == ALLEGRO_EVENT_TIMER) && (ev.timer.source == mnu_timer)) menu_timer_block = 0;
            else proc_events(ev);
         }
      }
   }

   proc_keys_held();
   function_key_check();

   // only do key check for active local player
   clear_controls(active_local_player);
   set_controls_from_player_key_check(active_local_player);
}


key_pressed_ASCII does not work as 'press any key' beacuse it only has a value for the frame it was pressed on..

I can't use it to cancel splash screen anymore until i added a hack

when the event happens, I now also trigger the menu_update and it works!!

   if (ev.type == ALLEGRO_EVENT_KEY_CHAR)
   {
      key_pressed_ASCII = ev.keyboard.unichar;
      serial_key_check(key_pressed_ASCII);
      menu_update = 1;
      //printf("key_pressed_ASCII:%d\n", key_pressed_ASCII);
   }

go the fuck to bed!!


20230205 11:46 PM


20230207 4:52 AM

still can't escape from level editor

145 - mwEQ.proc_event_queue()

what are my key array things?
0 = pressed
1 = pressed last frame
2 - just pressed this frame
3 - just released this frame


do I need to document the program flow for level editor?

I would be nice...
and I can rename mWindow also...

done..now mwWindow
decided not to change all >500 referneces to mW[] that can stay



so what is the process of level editor?

it is started by calling:
edit_menu(start_level)

edit_menu sets some stuff up, then does this loop

   while (mW[8].active)
   {
      cm_redraw_level_editor_background();
      if (!mw_cycle_windows(0)) cm_process_mouse();
      cm_process_keypress();
   }


cm_redraw_level_editor_background();
- mwEQ.proc_event_queue
- does the delay (currently by calling mwEQ.proc_event_queue and waiting on program_update)
- gets new background
- draws lifts, enemies, items
- draws overlay specific to mode
- gets new screen buffer


if (!mw_cycle_windows(0)) cm_process_mouse();
- processes and draws all active windows for this mode
- if the mouse is not on any window, process mouse for background



cm_process_keypress();
custom handler for em and ovw
but mostly all ESC tries to quit the entire level editor

I have simplified this now...
- still have a custom handler for em and ovw
- in any other mode ESC quits
that seems to work good now

removed up and down from ovw

em_keypress custom...all it did was check for hotkeys for lists...removed...

so now it is even simpler:
cm_process_keypress();
- runs custom handler for ovm
- checks for ESC in all modes for quit
- runs the exit dialog for last chance to abort or save before quit


I think that is all I have time for today...

add this to level_editor_process.txt and push...





I think there is something in zz animation sequence used by enemy killed that I need to fix...done

I want a new name for zoom full screen

how about selection edit?

main edit
selection edit
group edit
object viewer
tile helper


I like it...

how to rename:

file:

old e_editor_zfs
new e_edit_selection


the prefices I have...

em
ge
ovw
use es where I used to use zfs

I think it is all done...

rename group_edit_windows to just group_edit
that was easy, I think it was mostly just the filename...

now object_viewer_windows to just object_viewer

done...

now I have:
e_editor_main.cpp
e_edit_selection.cpp
e_group_edit.cpp
e_object_viewer.cpp

and the prefixes:
em_
es_
ge_
ov_



changed the behaviour of cm_redraw_level_editor_background..

old:
mwEQ.proc_event_queue and block, waiting for program_update
draw

new:
mwEQ.proc_event_queue
if program_update, draw
no blocking...

seems to work good


I want to make the file mwWindow only have functions from that specific class

any common files put in a seperate file e_mw_common.cpp


what calls draw?
.draw(
only one thing:
- cycle windows


how about from within the class? none!

nice! so there is only one single point of entry...

well cycle windows probbaly has many, it draws them all...

calls to cycle_windows(int draw_only)
- 1 call in editor_main (main loop)           (draw_only = 0)
- 2 calls when moving or resizing windows     (draw_only = 1)
- 1 call when blocked in tmenu                (draw_only = 1)
- 1 call when re-arranging ge list items      (draw_only = 1)
- 1 call running lifts                        (draw_only = 1)
- sliders has 2 calls when moving slider bars (draw_only = 1)

OK, this is all coming together....







I was thinking about making a mwWindowManager class to handle all of the windows as a group...

I am not sure what I would gain from that...

what functions would be a part of it:

void cm_get_block_position_on_map();
void cm_process_scrolledge(void);
void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
void cm_get_new_box(void);
void cm_redraw_level_editor_background(int mode);
void cm_process_mouse(void);
void cm_process_keypress(void);
int cm_redraw_level_editor_background(void);
void set_windows(int mode);
int is_mouse_on_any_window(void);
int mw_get_max_layer(void);
int mw_cycle_windows(int draw_only);


not these:
void cm_process_menu_bar(int draw_only);
int cm_draw_filter_buttons(int x1, int x2, int y1, int mode, int draw_only);
void cm_draw_status_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);
void cm_draw_selection_window(int x1, int x2, int y1, int y2, int draw_only, int have_focus);



that is actually quite an impressive list of functions that could all be rolled into a class..
as far as the data is concerned, it's almost entirely just the window objects..


imagine that...

the entirety of level editor in one class, one instance of that class, one object...
it is very tempting...


there is already very few globals for level editor...

one thing I am anticpating having problems with (because I have run into it before)
I want to make mwWindowManager contain the array of mwWindows

It should be possible, but I get errors about muliple definitions whenever I try.

I think I could solve it by using pointers to objects, but I have been trying to stay away from dynamically creating things...

started making the frameworks...


make an array of 10 pointers to mwWindows

when I construct a new mwWindowManager, dynamically allocate the 10 mwWindows


this is what I have so far:


// mwWindowManager.h
class mwWindow{};
#define NUM_MW 10
class mwWindowManager
{
   public:
    mwWindowManager();  // constructor
    ~mwWindowManager(); // destructor
//    mwWindow * mwW;
    mwWindow * mwW[10];
};

// mwWindowManager.cpp
#include "pm.h"
#include "mwWindowManager.h"
mwWindowManager::mwWindowManager()  // constructor
{
   //mwW = new mwWindow[10];
   for (int i=0; i<10; i++)
      mwW[i] = new mwWindow;
}
mwWindowManager::~mwWindowManager()  // destructor
{
   //delete [] mwW;
   for (int i=0; i<10; i++)
      delete mwW[i];
}

what next?


where do I create and destroy mwWindowManager?

at the start and end of edit menu

statically allocated at the start:
mwWindowManager mwWM;

it should automatically get destroyed when it goes out of scope


I'm still getting stupid multiple definition errors...

I'm going to experiment with header guards...

maybe I don't have to use dynamic after all??





Use header guards in all your header file and declare a global variable in .c file and declare extern to that global variable in a header file.

#ifndef HEADER_FILE_NAME_H    /* if not defined already */
#define HEADER_FILE_NAME_H
extern wchar_t szClassName[];
#endif


omg that was excactly what I was looking for!

now I can use statically define varaibles...


create at the start of edit menu:
mwWindowManager mwWM;

class mwWindowManager
{
   public:
   mwWindowManager();  // constructor
   ~mwWindowManager(); // destructor
   mwWindow mwW[10];
};

now what?

start copying things over?

   void cm_get_block_position_on_map(void);
   void cm_process_scrolledge(void);
   void cm_show_level_buffer_block_rect(int x1, int y1, int x2, int y2, int color, const char * text);
   void cm_get_new_box(void);
   void cm_redraw_level_editor_background(int mode);
   void cm_process_mouse(void);
   void cm_process_keypress(void);
   int cm_redraw_level_editor_background(void);

   void set_windows(int mode);
   int is_mouse_on_any_window(void);
   int mw_get_max_layer(void);
   int mw_cycle_windows(int draw_only);

all these have been added


now what?

make my own loop()
i can even call it loop...done

started renaming functions that are part of the class...
could be easier if I comment out the old ones and find out where they are used...
did a shit load of that...
now its mostly all patched in...

did it get any simpler?

still need to clean up some stuff...

pm.h defines for all removed functions in e_window common..done

what to do with the 4 functions left in that file...bite the bullet and move all to the class?
right now window manager class is 600 lines

170 menu
80 filter
50 status
200 selection
-----
520 lines

the window varaibles are all long now, especially outisde of class like mwWM.mW[4].blah
'mwWM.mW' is used 420 times in the project

some things make better sense as part of the manager class like:
set_focus.done
level_editor_mode.done

can I reimplement the saving?

20230211
move level_editor_mode from mwWM.mW[8].level_editor_mode to mwWM.level_editor_mode
done...

save_mW..done

I am using while (mW[8].active) to control when the entire level_editor process ends

what if I change it to something that window manager owns? active..done..

OK now that I have all that done...I want to continue with the documenting of the level editor process...

first what have I changed?..fixed all

fixed enemy shapes not all showing in ge list

but ge_controls never show...why?..deleted mw.pm and all good..


maybe I could make a menu option:

auto save level editor state
reset level editor saved state

and maybe also if level editor crashes on entry to reset state..

under the view menu:

Autosave level editor state
Reset level editor state

done...but did not do the auto reset if something went wrong...too hard to tell??
how about I have a variable that gets set when level editor starts
and reset when level editor ends normally

then next time it starts if it did not exit noramlly the prviuos time, reset state..

I could manually save this in config
level_editor_exit_flag

at start:

if set to 1, reset state
set to 1 and save

at normal exit
set to 0 and save


or:

at start, delete mw.pm
only save if normal exit..
this looks a lot simpler

whenever I do a load, delete it there...done...
hard to test, eh?


what next?

can I make these part of the window manager class? yes..done


// ------------------------------------------------
// ----- level editor unsorted --------------------
// ------------------------------------------------
extern int swbl[NUM_SPRITES][2];

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

extern int gx; // mouse position relative to scaled level background
extern int gy;
extern int hx;
extern int hy;


#define NUM_OBJ 600
// list of objects to edit as a group
extern int obj_list[NUM_OBJ][3];
extern int obj_filter[5][20];


extern int swbl[NUM_SPRITES][2]; ..done..moved to mw class
extern int obj_list[NUM_OBJ][3]; ..done
extern int obj_filter[5][20];..done
extern int gx; done
extern int gy; done

extern int bx1;  // selection window
extern int by1;
extern int bx2;
extern int by2;

all done...


make logo its own class...
mwLogo

I have two very close function I would like to merge:
an is for menu
an3 is for help

can I start using it yet?

I want to put these globals in the class...

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;


I have gotten rid of the old file z_logo.cpp

I forget to take adjust and test!!!..fixed


now work on the globals

extern int mdw_an_seq;   // mdw animation sequence number
extern float points[9][8];  // for mdw logo

extern int mdw_map_logo_x;
extern int mdw_map_logo_y;
extern int mdw_map_logo_th;
extern float mdw_map_logo_scale;

extern float mdw_splash_logo_x;
extern float mdw_splash_logo_y;
extern int mdw_splash_logo_th;
extern float mdw_splash_logo_scale;

extern float mdw_logo_scale_dec;
extern float mdw_logo_x_dec;
extern float mdw_logo_y_dec;
those are all done...


I should put these in the .cpp and .h for logo...

not the class? why not?

int show_splash_screen = 1;
int splash_screen_done = 0;
put in class and done...

I think I am all done with logo...


what about bottom message?

that is a good candidate for a class...

mwBottomMessage
mwBM

make it declare, create and destroy its own bitmaps...


   // bottom msg bitmaps
   for (int x=0; x<20; x++)
   {
      bmsg_bmp[x] = al_create_bitmap(800, 20);
      al_set_target_bitmap(bmsg_bmp[x]);
      al_clear_to_color(al_map_rgba(0,0,0,0));
      bmsg_bmp2[x] = bmsg_bmp[x];
   }


actually that does not work...
I can declare pointers in the class, but if I try to create bitmaps at the same time it dies,
probably because allegro is not initialized yet.

So I just create them when I create all the other bitmaps, and it works...

all the fuinctions have been moved to the class and erased from screen_overlay..

now I have three more variables to add to the class:

extern int bottom_msg_on;
extern int bottom_msg;
extern int bmsg_index;

done...


now how about demo mode?

mwDemoMode
mWDM


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
extern ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
extern int demo_played[100];
extern int num_demo_filenames;
extern int demo_mode_loaded;
extern int demo_mode_on;
extern int demo_mode_countdown;
extern int demo_mode_countdown_val;
extern int demo_mode_countdown_reset;
extern int demo_mode_enabled;
extern int demo_mode_last_frame;
extern int demo_mode_config_enable;
extern float demo_mode_overlay_opacity;

I think demo mode is done...

now demo mode starts immediately??


// ------------------------------------------------
// ----------------- demo mode --------------------
// ------------------------------------------------
ALLEGRO_FS_ENTRY *demo_FS_filenames[100];
int demo_played[100];
int num_demo_filenames = 0;
int demo_mode_loaded = 0;
int demo_mode_enabled = 1;
int demo_mode_on = 0;
int demo_mode_countdown_val;
int demo_mode_countdown_reset = 2400;
int demo_mode_last_frame = 0;
int demo_mode_config_enable = 1;
float demo_mode_overlay_opacity = 0.1;


demo is now done...


OK the huge one:
display

mwDisplay
mwD

created the class and copied all these functions in:

   void show_bitmap_flags(int flags);
   void show_pixel_format(int df);
   void show_display_flags(int flags);
   void show_display_options(void);
   void show_display_orienation(void);
   void show_fullscreen_modes(void);
   void auto_set_display_transform_double(void);
   void set_saved_display_transform(int sdt);
   void cycle_display_transform(void);
   void set_display_transform();
   void show_disp_values(int fs, int disp, int curr, int wind, int full, char *head);
   void show_display_adapters(void);
   int init_display(void);
   void proc_display_change(void);
   void save_display_window_position(void);
   void proc_display_change_tofs(void);
   void proc_display_change_fromfs(void);


it compiles and works!!

now for all these varaibles:


extern int desktop_width;
extern int desktop_height;

extern int disp_x_curr; // current (either wind in windowed mode or full in fullscreen mode)
extern int disp_y_curr;
extern int disp_w_curr;
extern int disp_h_curr;

extern int disp_x_wind; // windowed
extern int disp_y_wind;
extern int disp_w_wind;
extern int disp_h_wind;

extern int disp_x_full; // fullscreen  (set to 0, 0, desktop_width, desktop_height and never change)
extern int disp_y_full;
extern int disp_w_full;
extern int disp_h_full;

extern int SCREEN_W;
extern int SCREEN_H;
extern int WX;
extern int WY;
extern int fullscreen;
extern int display_adapter_num;
extern float WX_shift_speed;

extern int viewport_mode;
extern int viewport_show_hyst;
extern float viewport_x_div;
extern float viewport_y_div;

// used to only redraw a region of background to increase fps
extern int level_display_region_x;
extern int level_display_region_y;
extern int level_display_region_w;
extern int level_display_region_h;

extern int display_transform_double;
extern int display_transform_double_max;
extern int saved_display_transform_double;
extern int show_dtd;

make a method to replace these:
         if (mwD.fullscreen) mwD.proc_display_change_fromfs();
         else                mwD.proc_display_change_tofs();
done...

make my own set_clipping_rect...done
al_set_clipping_rectangle

more vars?

extern float scale_factor;
extern float scale_factor_current;
extern float scale_factor_inc;
extern int show_scale_factor;
extern int scale_factor_holdoff;

done...
what about set_scale_factor?..done
what about proc_scale_factor_change()?..done


any more?

I'm thinking about adding these:

// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;


I have something similar in logo

   float mdw_map_logo_x;
   float mdw_map_logo_y;
   float mdw_map_logo_scale;

   float mdw_splash_logo_x;
   float mdw_splash_logo_y;
   float mdw_splash_logo_scale;


and I have a function that sets all this up:

void set_map_var(void)
{
   // determine menu_map_size and position
   int y_size = mwD.SCREEN_H-160;
   int x_size = mwD.SCREEN_W-260;
   if (y_size < x_size) menu_map_size = y_size;
   else menu_map_size = x_size;
   if (menu_map_size < 10) menu_map_size = 10;
   menu_map_x = mwD.SCREEN_W/2-(menu_map_size/2);
   menu_map_y = 140;

   // splash screen logo position
   mwL.mdw_splash_logo_x = mwD.SCREEN_W/2;
   mwL.mdw_splash_logo_y = mwD.SCREEN_H/2;

   // splash screen logo size
   float min_d = mwD.SCREEN_H;  // find miniumum dimension
   if (mwD.SCREEN_W < mwD.SCREEN_H) min_d = mwD.SCREEN_W;
   mwL.mdw_splash_logo_scale = min_d / 500; // 400 is the exact size, make it bigger for padding

   // map screen logo position and size
   float sp = menu_map_x - BORDER_WIDTH;    // how much space do I have between the map and the screen edge?
   mwL.mdw_map_logo_scale = sp / 500; // 400 is the exact size, make it bigger for padding
   mwL.mdw_map_logo_x = BORDER_WIDTH + sp/2;
   mwL.mdw_map_logo_y = menu_map_y + mwL.mdw_map_logo_scale * 200; // align top of logo with top of map

   // this is the link from splash to map
   mwL.mdw_logo_scale_dec = (mwL.mdw_splash_logo_scale - mwL.mdw_map_logo_scale) / 320;
   mwL.mdw_logo_x_dec = (mwL.mdw_splash_logo_x - mwL.mdw_map_logo_x) / 320;
   mwL.mdw_logo_y_dec = (mwL.mdw_splash_logo_y - mwL.mdw_map_logo_y) / 320;

//   printf("slx %f sly %f\n", mdw_splash_logo_x, mdw_splash_logo_y );
//   printf("mlx %d mly %d\n", mdw_map_logo_x, mdw_map_logo_y );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec, mdw_logo_y_dec );
//   printf("xdec %f ydec %f\n", mdw_logo_x_dec*320, mdw_logo_y_dec*320 );
}

this leads me to the place where I figure out what goes in display, screen, and bitmaps

display - for all the setup
screen - for actually drawing on the screen

screen should have:
all the level draw functions
all the screen overlay things

screen should not have:
create and load bitmaps
rebuild bitmaps
load fonts

what if I renamed e_bitmap to e_bitmap_tools or something like that...done

then make a class mwBitmap mwB
this class will have all the bitmap pointer declarations
have methods to create load, rebuild bitmaps
might as well stick fonts in there too...


done and I have moved

   void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size);
   void load_fonts(void);
   void create_bitmaps(void);
   void rebuild_bitmaps(void);

and it runs...
what else?
load tiles is in file.cpp and it called after more stuff is set up...

timestamps...just get it out of the way...done
packetbuffer..just make a header for n_packet.cpp and stick it in there..done

I might leave it there..

what variables do I have?

extern ALLEGRO_FONT *font0;
extern ALLEGRO_FONT *font;
extern ALLEGRO_FONT *font2;
extern ALLEGRO_FONT *f1;
extern ALLEGRO_FONT *f2;
extern ALLEGRO_FONT *f3;

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern int sa[NUM_SPRITES][2];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;


do the fonts, but also name them better:

extern ALLEGRO_FONT *font0; // built-in thick 8x8
extern ALLEGRO_FONT *font;  // pristine, my new fav 8x8
extern ALLEGRO_FONT *font2; // pristine, in 16x16 format for bmsg
extern ALLEGRO_FONT *f1;    // achafont
extern ALLEGRO_FONT *f2;    // saucer
extern ALLEGRO_FONT *f3;    // pixel gosub

what will they be now:

mF.bltn
mF.pr8
mF.pr16
mF.sauc
mF.acha
mF.pixl

I want them to have their own class file mwFont mF
ok that's done.. now the grueling task of replacing all font references...

font0 mF.bltn  .done
font  mF.pr8
font2 mF.pr16  .done
f1    mF.acha  .done
f2    mF.sauc  .done
f3    mF.pixl  .done

font has 667 occurances!!

I am all done with fonts...

add these to mwBitmap

extern ALLEGRO_BITMAP *tilemap;
extern ALLEGRO_BITMAP *btilemap;
extern ALLEGRO_BITMAP *ptilemap;
extern ALLEGRO_BITMAP *dtilemap;
extern ALLEGRO_BITMAP *M_tilemap;
extern ALLEGRO_BITMAP *M_btilemap;
extern ALLEGRO_BITMAP *M_ptilemap;
extern ALLEGRO_BITMAP *M_dtilemap;

extern ALLEGRO_BITMAP *tile[NUM_SPRITES];
extern ALLEGRO_BITMAP *btile[NUM_SPRITES];

extern ALLEGRO_BITMAP *player_tile[16][32];
extern ALLEGRO_BITMAP *door_tile[2][16][8];

extern ALLEGRO_BITMAP *level_background;
extern ALLEGRO_BITMAP *level_buffer;



   ALLEGRO_BITMAP *tilemap;
   ALLEGRO_BITMAP *btilemap;
   ALLEGRO_BITMAP *ptilemap;
   ALLEGRO_BITMAP *dtilemap;
   ALLEGRO_BITMAP *M_tilemap;
   ALLEGRO_BITMAP *M_btilemap;
   ALLEGRO_BITMAP *M_ptilemap;
   ALLEGRO_BITMAP *M_dtilemap;

   ALLEGRO_BITMAP *tile[NUM_SPRITES];
   ALLEGRO_BITMAP *btile[NUM_SPRITES];

   ALLEGRO_BITMAP *player_tile[16][32];
   ALLEGRO_BITMAP *door_tile[2][16][8];

   ALLEGRO_BITMAP *level_background;
   ALLEGRO_BITMAP *level_buffer;


bitmaps has quite a lot done...

I could still put more like:

extern ALLEGRO_BITMAP *ft_bmp;  //  file temp paste bmp

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

extern ALLEGRO_BITMAP *text_title;
extern int text_title_bitmaps_create;
extern int text_title_draw_color;

extern ALLEGRO_BITMAP *large_text_overlay_bitmap;
extern int large_text_overlay_state;

but I am not sure they belong...



lifts is next....

e_lift.cpp 500 lines
z_lift.cpp 500 lines
pm.h

// ------------------------------------------------
// ---------------- lifts -----------------------
// ------------------------------------------------
extern int num_lifts;
extern char lift_step_type_name[10][10];
extern struct lift lifts[NUM_LIFTS];
extern struct lift_step lift_steps[NUM_LIFTS][40];

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;

   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};
struct lift_step
{
   int type;
   int x;
   int y;
   int w;
   int h;
   int val;
};

// e_lift.h
al_fixed lift_get_distance_to_previous_move_step(int lift, int step);
void show_all_lifts(void);
void lift_step_set_size_from_previous_move_step(int lift, int step);
int lift_find_previous_move_step(int lift, int step);
void erase_lift(int lift);
void delete_lift_step(int l, int step);
void lift_setup(void);
int create_lift(void);
void move_lift_step(int lift, int step);
int get_new_lift_step(int lift, int step);
int insert_lift_step(int lift, int step);
void insert_steps_until_quit(int lift, int step);
void set_all_steps(int l, int s, int what);
void step_popup_menu(int lift, int step);
int draw_current_step_buttons(int x1, int x2, int y, int l, int s, int d);
void draw_step_button(int xa, int xb, int ty1, int ty2, int l, int s, int rc, int d);
int draw_steps(int x1, int x2, int y, int lift, int current_step, int highlight_step, int d);

// z_lift.h
int construct_lift(int l, char* lift_name);
void clear_lift(int l);
int construct_lift_step(int l, int s, int type, int x, int y, int w, int h, int val);
void clear_lift_step(int l, int s);
void set_lift_to_step(int l, int s);
int is_player_riding_lift(int l);
void draw_lift_line(int l);
void draw_lift(int l, int x1, int y1, int x2, int y2);
void draw_lifts();
void set_lift_xyinc(int d, int step);
int lift_check_prox(int l, int pd);
void move_lifts(int ignore_prox);

what is my plan here?

I still want lifts and lift_steps accessible

I think I still want the seperation of e_lifts and z_lifts

One possibility:
- put both in one file
- make one header file

that would be easy

cons:
the one file would be >1000 lines
nbd

now I only have one file: z_lift.cpp
one one header z_lift.h

now pm.h is less than 100 lines!!

523 function defs
200 lines global vars

some low hanging fruit...
sliders, should just get a h file

renamed to mwWidgets, even though it wont have a class, its a generic group




here is some low hanging fruit:


// n_client.h
void client_read_packet_buffer(void);
void client_fast_packet_loop(void);
int  ClientInitNetwork(const char *serveraddress);
void ClientExitNetwork(void);
int  ClientCheckResponse(void);
int  ClientReceive(void *data);
void ClientSend(void *data, int len);
void client_flush(void);
int  client_init_join(void);
void client_exit(void);
int  client_init(void);
void client_read_game_move_from_packet(int x);
void client_send_ping(void);
void client_process_stdf_packet(double timestamp);
void client_apply_dif();
void client_block_until_initial_state_received(void);
void client_process_sdat_packet(void);
void client_process_serr_packet(void);
void client_proc_player_drop(void);
void client_control(void);
void client_local_control(int p);
void process_bandwidth_counters(int p);

// n_network.h
extern int NetworkDriver;
int NetworkInit();

// n_packet.h
extern char packetbuffer[1024];
extern int packetsize;
void set_packetpos(int pos);
int get_packetpos(void);
void Packet(const char *id);
int PacketRead(const char *id);
void PacketAddByte(char b);
char PacketGetByte(void);
void PacketAddString(char*);
void PacketReadString(char*);
void PacketPut1ByteInt(int b);
void PacketPut2ByteInt(int b);
void PacketPut3ByteInt(int b);
void PacketPut4ByteInt(int b);
int PacketGet1ByteInt(void);
int PacketGet2ByteInt(void);
int PacketGet3ByteInt(void);
int PacketGet4ByteInt(void);
void PacketPutDouble(double);
double PacketGetDouble(void);

//n_server.h
int ServerInitNetwork(void);
void ServerExitNetwork(void);
void ServerListen(void);
int ServerReceive(void *data, int *sender);
void ServerBroadcast(void *data, int len);
void ServerSendTo(void *data, int len, int who, int player);
void server_flush(void);
int  server_init(void);
void server_exit(void);
void server_send_dif(int p);
void server_create_new_state(void);
void server_rewind(void);
void server_send_sdat(void);
void server_proc_player_drop(void);
void server_proc_cdat_packet(double timestamp);
void server_proc_stak_packet(double timestamp);
void server_proc_cjon_packet(int who);
void server_control();
void server_fast_packet_loop(void);

done..

give bullets a header file..done

visual_level..done

396 function def
167 globals

I want to make game_moves array a class...maybe...






   if (players[0].level_done_mode == 5) // skippable 15s timeout
   {
      if (!ima_client)
      {
         if (have_all_players_acknowledged()) players[0].level_done_timer = 0; // skip
         for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }
      }
   }


i want to move this to have_all_players_acknowledged()...should be pretty straightforward



            for (int p=0; p<NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (mwGMA.has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }

GMA works...


level_header should only live in file.cpp..done..


I have intoduced a bug somehwere...

when I resize the screen, I lose screen_overlay...maybe just the fonts..they need to be reloaded also? yes. fixed..



move these declatations to logo...done

extern ALLEGRO_BITMAP *logo_ichael;
extern ALLEGRO_BITMAP *logo_avid;
extern ALLEGRO_BITMAP *logo_eiss;
extern int logo_text_bitmaps_create;

tile_helper.h ..done
pde.h..done


I am thinking of making color a class.. mwColor mC
yes...

old:
mC.pc[15]

new:
mC.c[15];

or:
mC.white;

it will return an actual ALLEGRO_COLOR..

I will also have all the color names in the class

maybe later I will extend it to have more fading than just the 16 preset levels

also it will have the flash colors

to start with, and replace all occurance of color...how many?...1143!...
I'll just do a straight replace of mC.pc with mC.pc

flash_color is not actually a color, its an index

It compiles and runs!!
now for some more features..
add color names...done..

add specific colors like:

mC.white..etc..done...

make flash colors actual colors instead of indexes..done, but most use case still use the indexes...


pm_events .. the one used in the game for triggers and such...

make it its own class. It has a lot going on...
mwPMEvent mwPME

I think I have it all in there and working...



mouse
keys
joystick
event
timers
queue

lets call these mwInput
mouse
keys
joystick


OK now I have a huge search and repalce to do:


extern char skc[64]; // serial key check
extern int skc_index;

extern char *key_names[]; 12-done
extern bool mI.key[ALLEGRO_KEY_MAX][4];  297
extern int key_pressed_ASCII;18-done

extern int mouse_x; 107-done all blind replace
extern int mI.mouse_y; 124- done all blind
extern int mouse_z; 4-done
extern int mouse_dx; 4-done
extern int mouse_dy; 5-done
extern int mouse_dz; 12-done

extern bool mI.mouse_b[5][4]; 183 blind

clear_keys
proc_keys_held


globals < 100 !!

what esle can I add to mwInput?
function_key_check()..done

all done from control.cpp




put event queue and timers into mwEventQueue
do it...you've come too far to stop now!!

now add timers...

I have about 40 globals variables left!!!

put animation_sequence array in with bitmaps...
also rest and update...done...

what aboout sa, shape atributes?  same place? yup..done

last of the bitmaps there too...done


I'm gettting down to the last of them

I want something like a class called mwProgramState to catch a lot of things like:


add to bmsg:
extern int game_event_retrigger_holdoff[10];
extern float game_event_retrigger_holdoff_tally[10];


add to logo
// position and size of map on menu screen
extern int menu_map_size;
extern int menu_map_x;
extern int menu_map_y;
done...


make this a part of menu..
extern char global_string[20][25][80];
menu.h
done..
setup menu



I think I am ready to make all of these part of a class called mwProgramState

extern int program_state;
extern int new_program_state;
extern int old_program_state;
extern int older_program_state;

extern int top_menu_sel;
extern int main_loop_exit;

extern int autosave_level_editor_state;
extern int level_editor_running;
extern int help_screens_running;
extern int visual_level_select_running;

// frame_speed, frames per second, mwPS.frame_num stuff
extern int speed_testing;
extern int frame_speed;
extern int speed_control_lock;
extern int mwPS.frame_num;

extern int show_debug_overlay;
extern int show_player_join_quit_timer;
extern int show_player_join_quit_player;
extern int show_player_join_quit_jq;

extern int eco_draw;

// temp testing variable
extern int pct_x;
extern int pct_y;
extern char msg[1024];

// some global strings
extern char level_filename[80];
extern char local_hostname[80];
extern char pm_version_string[80];
extern char al_version_string[80];



need to fix level_filename later...vl uses is to get a filename from make_filename....



there is some weird shit going on where I work with filenames...
I should examine as fix it...

the first thing I did was get rid of the global level_filename...


my base functions are:

int save_level(int level_to_save)
always returns 0

int load_level(int level_to_load, int load_only)
returns 1 on success, 0 on failure

      if (!load_only)
      {
         valid_level_loaded = 1;
         lift_setup();
         for (int x=0; x<500; x++)
            if (item[x][0]) // only if active set x y
            {
               itemf[x][0] = al_itofix(item[x][4]);
               itemf[x][1] = al_itofix(item[x][5]);
            }
         level_check();
         init_level_background(0); // draw blocks on level_background
         mwB.reset_animation_sequences();
         //set_player_start_pos(0, 0);
      }


they both take an integer level num and call make filename..

To print with padding by Zeros, we use the following format specifier with the printf() statement,

    %d : No padding.
    %01d : 1 digit padding with zeros.
    %02d : 2 digits padding with zeros.
    %03d : 4 digits padding with zeros.

replaced make_filename with:

char lf[255];
sprintf(lf, "levels/level%03d.pml", level_num);

now load and save level make their own filename
save level does not return anything...



load_level_prompt()

is called from level_editor popup menu and from regular menu..

also from command line but that never works...

what if command line is passed a level that deosn exist?
level loading error..


edit_menu is called by:

pm -e (uses play_level)
pm -e num (uses num if 0 < num < 400)
game_menu (uses start_level)

in edit menu if passed 0 it would run the prompt, but that never occurs...


I am happy with how load level prompt works

save_level_prompt..good...

le popmnu new
le regmnu new
le regmnu save_as

what is left?

why does level viewer not work?
It just gives errors for every level it cannot find...
can I make that optional? yes I can...

not sure if the level viewer copying thing is working...it is..


msg...784 matches...that's just lazy

where can I hide it? z_menu...just like global_string...



Now I have this left for global variables:


// items
int item[500][16];      // item ints
al_fixed itemf[500][4]; // item fixeds
int item_num_of_type[30];
int item_first_num[30];
char item_name[30][40];
char pmsgtext[500][500] = {0};
int item_tile[20];

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
int e_num_of_type[50];
int e_first_num[50];
char enemy_name[100][2][40] = {0};
int num_enemy;
int enemy_tile[20];




// ------------------------------------------------
// ---------------- level -------------------------
// ------------------------------------------------
int l[100][100];
int warp_level_location = 0;
int start_level;
int play_level;
int valid_level_loaded;
int last_level_loaded; // used by level editor and load file to keep track of last level loaded
int resume_allowed=0;
int number_of_starts;
int number_of_purple_coins;


for level I need to make a cpp file or a class
lets just do a cpp file for now..
z_level.cpp and z_level.h


20230212 4:36PM all globals are gone!!
well...at least from pm.h..there are still some in other files but they are only externed where needed...

now I plan to make .h files and move all function prototypes there...

I still have 250 function in 18 files...

tell me again why I would want them spread over 18 files instead of all in one place?

and why would I want 18 more files?...

I now have 100 files...58 cpp and 42 header

Purple Martians Source Code Line Counts [2023-02-12  17:27:41]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2872][  2172][  1734][   605][   167][   438][   533] - z_item.cpp
[  2705][  1951][  1367][   848][   264][   584][   490] - z_enemy.cpp
[  2087][  1755][  1347][   515][   107][   408][   225] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1599][  1448][   207][    56][   151][   220] - mwGraph.cpp
[  1745][  1343][  1124][   319][   100][   219][   302] - z_player.cpp
[  1865][  1334][  1110][   275][    51][   224][   480] - mwWidgets.cpp
[  1658][  1222][  1019][   335][   132][   203][   304] - z_fnx.cpp
[  1416][  1140][  1009][   181][    50][   131][   226] - z_menu.cpp
[  1250][  1003][   901][   139][    37][   102][   210] - z_screen_overlay.cpp
[  1281][   963][   834][   188][    59][   129][   259] - e_bitmap_tools.cpp
[  1595][   905][   820][   183][    98][    85][   592] - e_glt.cpp
[  1157][   901][   731][   219][    49][   170][   207] - z_lift.cpp
[  1078][   891][   755][   195][    59][   136][   128] - e_edit_selection.cpp
[  1129][   802][   737][   125][    60][    65][   267] - z_settings.cpp
[   994][   735][   659][   108][    32][    76][   227] - e_fnx.cpp
[   851][   716][   401][   363][    48][   315][    87] - e_editor_main.cpp
[   782][   689][   606][   101][    18][    83][    75] - e_group_edit.cpp
[   874][   657][   621][    99][    63][    36][   154] - z_file.cpp
[   937][   634][   548][   166][    80][    86][   223] - z_screen.cpp
[   765][   616][   559][    92][    35][    57][   114] - n_client.cpp
[   777][   611][   562][   100][    51][    49][   115] - n_server.cpp
[   819][   587][   536][   117][    66][    51][   166] - e_visual_level.cpp
[  1140][   548][   472][   343][   267][    76][   325] - z_args.cpp
[   759][   538][   461][   160][    83][    77][   138] - z_loop.cpp
[   622][   510][   385][   150][    25][   125][    87] - e_item.cpp
[   642][   489][   416][   118][    45][    73][   108] - mwWindowManager.cpp
[   705][   477][   457][    93][    73][    20][   155] - mwLogo.cpp
[   542][   434][   387][    77][    30][    47][    78] - e_window_common.cpp
[   560][   432][   407][    28][     3][    25][   125] - mwInput.cpp
[   588][   416][   191][   258][    33][   225][   139] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   565][   372][   369][    63][    60][     3][   133] - mwDisplay.cpp
[   439][   367][   327][    48][     8][    40][    64] - e_pde.cpp
[   451][   328][   328][    31][    31][     0][    92] - pm.h
[   360][   297][   237][    71][    11][    60][    52] - e_enemy.cpp
[   341][   291][   272][    31][    12][    19][    38] - mwWindow.cpp
[   405][   289][   288][    22][    21][     1][    95] - z_config.cpp
[   308][   221][   180][    56][    15][    41][    72] - mwPMEvent.cpp
[   285][   208][   202][    26][    20][     6][    57] - z_main.cpp
[   303][   198][   173][    81][    56][    25][    49] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   250][   178][   148][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   151][   124][   113][    18][     7][    11][    20] - z_control.cpp
[   146][   117][   115][    11][     9][     2][    20] - z_sound.cpp
[   219][   115][   106][    68][    59][     9][    45] - mwDrawSequence.cpp
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   187][   100][    92][    42][    34][     8][    53] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   117][    85][    77][    13][     5][     8][    27] - mwFont.cpp
[   130][    75][    70][    16][    11][     5][    44] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   106][    65][    59][    12][     6][     6][    35] - mwEventQueue.cpp
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    64][    60][    58][     4][     2][     2][     2] - z_item.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    31][    29][     3][     1][     2][     5] - z_enemy.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidgets.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
-------------------------------------------------------- - totals
[ 47082][ 34769][ 29614][  8162][  3007][  5155][  9306] - 100 files

On to something else...

what about those defines..kept the ones that worked

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-12  18:26:29]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2876][  2176][  1738][   605][   167][   438][   533] - z_item.cpp
[  2705][  1953][  1369][   848][   264][   584][   488] - z_enemy.cpp
[  2088][  1758][  1350][   515][   107][   408][   223] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1749][  1346][  1127][   319][   100][   219][   303] - z_player.cpp
[  1865][  1335][  1111][   275][    51][   224][   479] - mwWidgets.cpp
[  1661][  1225][  1022][   335][   132][   203][   304] - z_fnx.cpp
[  1417][  1142][  1011][   181][    50][   131][   225] - z_menu.cpp
[  1255][  1005][   903][   139][    37][   102][   213] - z_screen_overlay.cpp
[  1287][   968][   839][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1600][   909][   824][   183][    98][    85][   593] - e_glt.cpp
[  1163][   905][   735][   219][    49][   170][   209] - z_lift.cpp
[  1082][   896][   760][   195][    59][   136][   127] - e_edit_selection.cpp
[  1136][   806][   741][   125][    60][    65][   270] - z_settings.cpp
[   998][   738][   662][   108][    32][    76][   228] - e_fnx.cpp
[   856][   721][   406][   363][    48][   315][    87] - e_editor_main.cpp
[   786][   693][   610][   101][    18][    83][    75] - e_group_edit.cpp
[   883][   660][   624][    99][    63][    36][   160] - z_file.cpp
[   941][   636][   550][   166][    80][    86][   225] - z_screen.cpp
[   771][   620][   563][    92][    35][    57][   116] - n_client.cpp
[   781][   613][   564][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1147][   554][   478][   343][   267][    76][   326] - z_args.cpp
[   765][   545][   468][   160][    83][    77][   137] - z_loop.cpp
[   622][   513][   388][   150][    25][   125][    84] - e_item.cpp
[   648][   496][   423][   118][    45][    73][   107] - mwWindowManager.cpp
[   705][   478][   458][    93][    73][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   527][   387][   309][    98][    20][    78][   120] - mwBottomMessage.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   441][   368][   328][    48][     8][    40][    65] - e_pde.cpp
[   360][   299][   239][    71][    11][    60][    50] - e_enemy.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   409][   291][   290][    22][    21][     1][    97] - z_config.cpp
[   308][   222][   181][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   252][   180][   150][    46][    16][    30][    56] - z_bullets.cpp
[   216][   156][   138][    27][     9][    18][    51] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   219][   117][   108][    68][    59][     9][    43] - mwDrawSequence.cpp
[   130][   110][   110][     5][     5][     0][    15] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   190][   101][    93][    42][    34][     8][    55] - mwBitmap.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   124][    89][    75][    24][    10][    14][    25] - n_netgame.cpp
[   119][    86][    78][    13][     5][     8][    28] - mwFont.cpp
[   154][    85][    68][    45][    28][    17][    41] - mwColor.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    86][    76][    74][     4][     2][     2][     8] - z_item.h
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    81][    69][    69][     4][     4][     0][     8] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    51][    42][    40][     4][     2][     2][     7] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    53][    38][    32][     7][     1][     6][    14] - mwRollingAverage.cpp
[    39][    37][    37][     1][     1][     0][     1] - z_fnx.h
[    42][    31][    30][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    52][    30][    29][     3][     2][     1][    20] - mwBitmap.h
[    36][    30][    30][     1][     1][     0][     5] - mwWidgets.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    24][     2][     1][     1][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    36][    24][    16][    14][     6][     8][     6] - n_netgame.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    27][    21][    21][     2][     2][     0][     4] - z_bullets.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    38][    19][    18][     2][     1][     1][    18] - mwDrawSequence.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    24][    16][    15][     2][     1][     1][     7] - mwRollingAverage.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    29][    13][     7][     7][     1][     6][    15] - mwFont.h
[    17][    13][    13][     1][     1][     0][     3] - z_menu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    11][     9][     9][     1][     1][     0][     1] - e_pde.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47189][ 34913][ 29758][  8153][  2998][  5155][  9278] - 116 files


pm.h has been stripped of all global variables and function prototypes

god help us all...


now, why do lifts need a button from bitmap_editor..


I will replace with a button...but...

the one thing I like about the old button was that they showed a highlight when the mouse was on them


I want to make a new type of button...

text and returs 1 when pressed, just like buttont, but...

this one will show a highlight when moused over
and will draw centered
and will auto size based on text length...

how about all that?..done...


Its time for a push, I shoudl be done for today...


20230212 7:18PM


20230214 4:00AM
remove menu fromn e_bitmap by making msg local to funtions is in done..4x
make DS have static RA's done

PDE could be a class to reduce a few globals
mwPDE mPDE..done...

glt no globals and no msg...done

color done...

cleanup is going well...





remove globals in bullets, can it be made a class?

mwBullets mwBullets

what about mwShots mShots

mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc

why don't I also start here with changing all fixed to floats

how about you do that first?

ebullet fixed to floats
then test with all types of enemies that shoot bullets...
I think I did it...

now make the class...


mShots.e[].active
mShots.e[].shape
mShots.e[].fx
mShots.e[].fy
mShots.e[].fxinc
mShots.e[].fyinc

mShots.p[].active
mShots.p[].player
mShots.p[].x
mShots.p[].y
mShots.p[].xinc
mShots.p[].yinc



to start with just replace variables all the variables with the ones in the class

old:
ebullets[].active
ebullets[].shape

new:
mwS.e[].active
mwS.e[].shape

done...

next remove old variable defs..


next change all pbullet refs to class and use floats...

old:
pbullet[][0] - active
pbullet[][1] - player
pbullet[][2] - int x
pbullet[][3] - int y
pbullet[][4] - int xinc
pbullet[][5] - int yinc

new
mwS.p[].active
mwS.p[].player
mwS.p[].x
mwS.p[].y
mwS.p[].xinc
mwS.p[].yinc

done...
now what?
mwShots has been all renamed..only thing left would be to add some bullet functions..done...
void mwShots::fire_enemy_bulletz(int EN, int bullet_ans, al_fixed px, al_fixed py)
void mwShots::fire_enemy_bulleta(int EN, int bullet_ans, int p)
void mwShots::fire_enemy_x_bullet(int EN, int p)
replace deathmatch_pbullets and suicide bullets with shots..done and also made a part of class...
bul

all ref to bullet, bull, bul have been removed from game...

nice....


One thing..my new short class instance names may be kind of cryptic...like mwS for shots
alternatives? mwShot.e[].active
I can always search and replace later


how about changing lifts back to floats?
then items, players, enemies...

make it a class
that constains 2 arrays of structs

what about inheritance?

how many things all have x, y, xinc, yinc

players
enemies
items
lifts
e shots
p shots

how many have active, bitmap
players
enemies
items
e shots
p shots

later


back to lifts..

I also want to add active to lifts

and maybe get rid of level header...
where used?
3 times in fnx, but only for size display..
10 times in file.cpp

when saving level:
- erase level_header
fill from:
   level_header[0] = 5; // .pml level version
   level_header[3] = sort_item(1); // num_of_items
   sort_enemy();
   level_header[4] = num_enemy;  // num_of_enemies
   lift_setup();
   level_header[5] = num_lifts;  // num of lifts

when loading level:
    num_lifts = level_header[5];

I want to use a different method of iterating lifts and lose level_header

also turn lifts into a class

also change fixed to floats

also do something about the int versions of x1, y1, x2, y2, width, height

where to start...

iterator:

old:
for (int l=0; l<num_lifts; l++) // iterate lifts

new:
for (int l=0; l<NUM_LIFTS; l++) // iterate lifts
   if (lifts[l].active)


I can have a member of the lifts class that tells me how many lifts are active
and a sort function that pretty much just removes spaces..optional, why bother?
it would break event links if there are any...


added active to lift struct..
now crashes hard when loading any level with lifts...
remove and rethink this...

should I just jump to class?
and change all the variables at that time?
mwLift mwLifts
started the class...


in order to change variables I need to make a shadow varaible for lifts (lift steps is not changing)

load old
convert to new
save


old:

struct lift
{
   al_fixed fx;
   al_fixed fy;
   al_fixed fxinc;
   al_fixed fyinc;
   al_fixed fw;
   al_fixed fh;
   al_fixed fwinc;
   al_fixed fhinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

new:

struct lift2
{
   float x1;
   float y1;
   float x2;
   float y2;
   float w;
   float h;
   float xinc;
   float yinc;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};



I still think I should do this in small steps:
first just add active..

step 1:
make shadow struct array lifts2 with added variable..done


step2
load normal
in glt copy to shadow
modify save to use new struct and new PML_SIZE
run glt..

now all levels are save in new format.

add var to lifts struct
increase PML_SIZE

load all level succesfully!!

remove mod to save...


wow that was a lot to modify save level format...
















Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts    :  5280
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112928


Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    :  8000
lifts2    :  5440
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :113088



#define PML_SIZE 384960

+160

#define PML_SIZE 385120



now fix the iterators

start with move and draw...

make a function to get the next empty lift...

like item and enemy..

I have removed all refs to num_lifts...
next:

does erase do the job of closing gaps, or do I need something else?..its good
figure out next and prev in ov..done
re implement num_lifts for display only..done
remove level header completely..not used..next time I re-do level format remove it...
what is going on with ft_? it all seems to work..it still uses ft_level_header but I dont care right now
in es copy and delete seem to be working good..
make a test level and try copy and paste and from disk...
copying 4 lifts works..
clearing lifts only erases half of them...fixed

all this is working so well...
what next??
replace fixed...

all 8 at once?  why not?

step 1
lifts2 has fixed replaced with floats

step 2
old vars
Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385120


new vars (lifts2) and remove level_header
Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  5440
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :385040


don't reduce size of PML_SIZE until after re-saving

step 3
void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 4
in glt:

      for (int l=0; l<NUM_LIFTS; l++)
         if (lifts[l].active)
         {
            lifts2[l].x = al_fixtof(lifts[l].fx);
            lifts2[l].y = al_fixtof(lifts[l].fy);
            lifts2[l].w = al_fixtof(lifts[l].fw);
            lifts2[l].h = al_fixtof(lifts[l].fh);
            lifts2[l].xinc = al_fixtof(lifts[l].fxinc);
            lifts2[l].yinc = al_fixtof(lifts[l].fyinc);
            lifts2[l].winc = al_fixtof(lifts[l].fwinc);
            lifts2[l].hinc = al_fixtof(lifts[l].fhinc);

            lifts2[l].active = lifts[l].active;

            lifts2[l].x1 = lifts[l].x1;
            lifts2[l].y1 = lifts[l].y1;
            lifts2[l].x2 = lifts[l].x2;
            lifts2[l].y2 = lifts[l].y2;
            lifts2[l].width = lifts[l].width;
            lifts2[l].height = lifts[l].height;

            lifts2[l].flags = lifts[l].flags;
            lifts2[l].mode = lifts[l].mode;
            lifts2[l].val1 = lifts[l].val1;
            lifts2[l].val2 = lifts[l].val2;

            lifts2[l].color = lifts[l].color;
            lifts2[l].current_step = lifts[l].current_step;
            lifts2[l].num_steps = lifts[l].num_steps;
            lifts2[l].limit_counter = lifts[l].limit_counter;
            lifts2[l].limit_type = lifts[l].limit_type;

            sprintf(lifts2[l].lift_name, lifts[l].lift_name);

         }


step 5
make backup of levels...


step 6
run glt


step 7:
disable glt

you fucked up..go back to step 3

this was wrong....

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}

restored levels from backup...

set this properly:

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 6
run glt

step 7
disable glt

step 8
change load

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
//   sz = sizeof(level_header); memcpy(level_header, b+offset, sz); offset += sz;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
//   offset += sz; sz = sizeof(level_header); memcpy(b+offset, level_header, sz);
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 9:

fix struct declaration

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;

   int active;

   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};


level_header has been completely removed

now remove the integer shit in lift

   int x1;
   int y1;
   int x2;
   int y2;
   int width;
   int height;



step 1
lifts2 has fixed replaced with floats

step 2

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts2       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080

don't reduce size of PML_SIZE until after re-saving

step 3

struct lift2
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Efi);          memcpy(b+offset, Efi,          sz);
   offset += sz; sz = sizeof(lifts2);        memcpy(b+offset, lifts2,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}



step 4:
in glt do nothing, just load and save




step 5 backup levels

step 6 do glt...



wrong!

restore levels...

in glt copy from lifts to lifts2...



OK now I think I have it:

struct lift
{
   float x;
   float y;
   float xinc;
   float yinc;

   float w;
   float h;
   float winc;
   float hinc;

   int active;
   int flags;
   int mode;
   int val1;
   int val2;
   int color;
   int current_step;
   int num_steps;
   int limit_counter;
   int limit_type;
   char lift_name[40];
};

Variables used to save levels in pml format

l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  4480
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384080


level_header is completely gone...

lifts have been converted to floats


now working on item fixed to float..


change all these to not even pass x, y..get it from itemfl

         bomb_blocks( i, 1, item[i][7], fx, fy); // mark blocks that will be destroyed
         bomb_enemies(i, 1, item[i][7], fx, fy); // mark enemies that will be destroyed
         bomb_players(i, 1, item[i][7], fx, fy); // mark players in damage range



I got it all to compile!! now I have some bugs to fix...


first I want to record some performance metrics:
348 al_fixed
138 al_ftofix
383 al_itofix
207 al_fixtoi
124 al_fixtof


bugs..
player start position..fixed
jump on spring..fixed

OK its looking good...

what fixed to replace now?
player...the big one

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

   al_fixed LIFE;
   al_fixed old_LIFE;

   al_fixed draw_rot;
   al_fixed draw_scale;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;

lets do LIFE and old LIFE first
I also want to take this opportunity to rename it to health
done..


now PX, PY and rename to x, y
I should do all:

   al_fixed PX, PY;       // players position
   al_fixed xinc, yinc;   // players momentum
   al_fixed right_xinc, left_xinc;

at the same time...

x, y, fxinc, fyinc, fright_xinc, fleft_yinc

the name change is important to find all the places it needs changing

convert all to float


I got stuck in the door move stuff...

there are ints:
   int door_xinc;
   int door_yinc;

that are used as fixed even though not declared as ints...I think...


I think I need to do the door ones at the same time..

   int door_xinc;
   int door_yinc;

   float door_fxinc;
   float door_fyinc;




ran into another issue with solidfm


they get passed fixeds and return fixed...

can I make a float wrapper?

they are used for ladder move and trakbot only...Ill need to fix them later...

well it compiles...

there is probably a lot broken...

remove these also:

   al_fixed draw_rot;
   al_fixed draw_scale;
   int door_draw_rot_num_steps;
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


start with these:

   al_fixed draw_rot;
   al_fixed draw_scale;

done..

next:
   al_fixed door_draw_rot;
   al_fixed door_draw_rot_inc;


compiles clean but there are so many things to fix...

first I want to record some performance metrics:
292 al_fixed
91  al_ftofix
287 al_itofix
138 al_fixtoi
114 al_fixtof


to fix:
rotation
rocket and door

ladder and rope

the rocket rotates like it should, but not player..


how does rotation work?

uses radians

pi/2 = 90
pi radians = 180


how is it done in items?

      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);



fuck all that...
I am going to start from scratch
if I have to store rotation as an int, how would I do that?

I figured it out and added notes in pm_docs

now implement for rocket

in proc_lit_rocket(int i)
angle is read from item[i][10] and used to calculate x and yinc inc and apply
also acceleration is processed

in proc_player_riding_rocket(int p)
player's controls are used to change angle
player gets pos and incs set from rocket

not much I could change there
steerability is simply the amount added or subtracted from the angle

I still think I should multiply by 100 to save angle as int
do it and fix whatever breaks

this is how it is drawn

    // these types need rotation
   if ((type == 11) || (type == 98) ||  // rockets
      ((type == 4) && (item[i][11] > 0))) // moving key
   {
      float rot = al_fixtof(al_fixmul(al_itofix(item[i][10]/10), al_fixtorad_r));
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);
      drawn = 1;
   }


Lets start with changing how it is draw

how do I want to do it?

should the angle be the one for draw or for trig?

I choose the trig one
this is how it is drawn now, deal with it...
      float rot = (float) item[i][10] / 1000;
      al_draw_rotated_bitmap(mwB.tile[shape], 10, 10, x+10, y+10, rot, 0);

how was it done before?

when a rocket was created and all..

[10] is zero in PDE for rocket

fixed rocket lines...

multiplied steerability by 2
what if I just left it and increased the slider limit..
set rocket initial direction..done

what else do I need to fix?
when letting go of rocket, player warps...added to bugs...

now why do I have scale and door scale and all that?

check door stuff..

I think I fixed the player rotation stuff in door travel

door creator position bad...fixed

what about orb rotation?
there is another item that rotates...it works fine...

time for players ladders and bullshit like that...
make a wrapper...done..

first I want to record some performance metrics:
235 al_fixed
78  al_ftofix
246 al_itofix
135 al_fixtoi
109 al_fixtof

now the last big one: enemies

620 occurances of Efi



just like items, I will need to change the structure, then run glt



step 1 - backup levels

step 2 - add Ef[][16]

// enemies
int Ei[100][32];        // enemy ints
al_fixed Efi[100][16];  // enemy fixeds
float Ef[100][16];      // enemy floats

extern int Ei[100][32];        // enemy ints
extern al_fixed Efi[100][16];  // enemy fixeds
extern float Ef[100][16];      // enemy floats

step 3 - glt
      // copy enemy fixed to to new float array
      for (int e=0; e<100; e++)
         for (int f=0; f<16; f++)
            Ef[e][f] = al_fixtof(Efi[e][f]);


step 4 - file.

void pml_to_var(char * b) // for load level
{
   int sz = 0, offset = 0;
   sz = sizeof(l);            memcpy(l,            b+offset, sz); offset += sz;
   sz = sizeof(item);         memcpy(item,         b+offset, sz); offset += sz;
   sz = sizeof(Ei);           memcpy(Ei,           b+offset, sz); offset += sz;
   sz = sizeof(Efi);          memcpy(Efi,          b+offset, sz); offset += sz;
   sz = sizeof(lifts);        memcpy(lifts,        b+offset, sz); offset += sz;
   sz = sizeof(lift_steps);   memcpy(lift_steps,   b+offset, sz); offset += sz;
   sz = sizeof(pmsgtext);     memcpy(pmsgtext,     b+offset, sz); offset += sz;
}

void var_to_pml(char * b) // for save level
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(l);            memcpy(b+offset, l,            sz);
   offset += sz; sz = sizeof(item);         memcpy(b+offset, item,         sz);
   offset += sz; sz = sizeof(Ei);           memcpy(b+offset, Ei,           sz);
   offset += sz; sz = sizeof(Ef);           memcpy(b+offset, Ef,           sz);
   offset += sz; sz = sizeof(lifts);        memcpy(b+offset, lifts,        sz);
   offset += sz; sz = sizeof(lift_steps);   memcpy(b+offset, lift_steps,   sz);
   offset += sz; sz = sizeof(pmsgtext);     memcpy(b+offset, pmsgtext,     sz);
}


step 5 run glt

step 6
disable glt
fix file
comment out Efi..


then fix!! 620 refs...
also in es I have this :
al_fixed ft_Efi[100][16];

change it too..
float ft_Ef[100][16];

PDEfx will also need changing later
rot for ft enemies


flapper does some weird flap sequences based on 0-100 and 0-255 and fixed sin

//   Efi[][8]  = flap offset for next loop



finally compiles clean!!!


first I want to record some performance metrics:
71 al_fixed
22 al_ftofix
66 al_itofix
28 al_fixtoi
51 al_fixtof

get_sproingy_jump_height(int num)
2 calls


convert PDE to use floats again
then remove the last calls to sliderf..done


now can I rename all the float ones from d to f...done...

key rotation..fixed..
fix the solid routines..done
fixed is no longer needed anywhere..

20230219 5:00AM

how many left?
33 al_fixed
15 al_ftofix
45 al_itofix
21 al_fixtoi
43 al_fixtof


fix enemy rotations, start with trakbot
look in enemy draw code:
float rot = Ef[e][14];
float sc =  Ef[e][12];
al_draw_scaled_rotated_bitmap(mwB.tile[tn], 10, 3, EXint+10, EYint+10, sc, sc, rot, flags);

deg fix rad
0   0   0
270 192 3p/2

trakbot is done..
check bouncers...good
vinepods, pozilla..good
flapper..no
jumpworm..good
fix flapper flap thingy..done

find a way to not use fixed trig in logo..done...
fixed trig 0-256

removed all the old solid functions

20230219 6:46 AM
0 al_fixed
0 al_ftofix
0 al_itofix
0 al_fixtoi
0 al_fixtof

they are all gone!!

cannon explosion death sequence looks different
need to fix rot inc in death sequence
done...

when letting go of rocket, player warps...fixed





lifts have strange artifacts in many levels...

clean up messed up levels


what about 'could not find move step!!' error?

lev 1 good
lev 2 2 lifts, one does not move..
lev 3 2 lifts, both move fine
lev 4 3 lifts, all move fine
when speed is too low, lifts don't move...fixed

5 no lifts
6 phantom lifts from level 4...removed
7 fixed
8
9
10
11
12
13 has 15 lifts
14
15
16
17 has 17 lifts
18 2
19 13
-36 done

80
81
82
83-99 done


100
108 37 lifts
109
155 39 lifts

I have gone through all 127 levels and removed bad lifts!

now what?


bullet targetting
seek xincs
set rot..etc
enemy stuff


I want to make a nice solution for angles
x,y is the reference, the angle will be refences to that point
      float xlen = mx-x;
      float ylen = my-y;
now get the answer in rad and shift by 90 deg
      float ra = atan2(ylen, xlen) + pi/2;;


now do the flapper targetting...
I think I got it..

all of that stuff is looking very good now

these functions in z_fnx are all looking great..
maybe later they can become a part of something like an enemy class

they are only 200 lines:

void set_enemy_rot_from_incs(int e);
void set_enemy_rot_from_player(int e, int p);
void seek_set_xyinc(int e);
int find_closest_player(int e);
int find_closest_player_flapper(int e);
int find_closest_player_trakbot(int e);
int find_closest_player_cannon(int e);
float deg_to_rad(float deg);


20230219 12:48  I should do a push..it has been a while....


test netgame

Variables used for netgame state exchange

players  :  2048
Ei       : 12800
Ef       :  6400
item     : 32000
itemf    :  8000
lifts    :  4480
l        : 40000
mwS.p    :  1200
mwS.e    :  1200
pm_event :  4000
---------:------
total    :112128

it got 800 bytes smaller
800 / 40 = 20 / 4 = 5...could be 5 ints smaller in lifts

//#define STATE_SIZE 112928
#define STATE_SIZE 112128

of course it still works...I'm not just banging rocks together here....

what next?

I had started making lifts a class...

I have 1200 lines of code in z_lifts.cpp

lets move the data structures first and fix all references to them...

this is what I have now:

class mwLift
{
   public:

   mwLift(); // default constructor
   void initialize(void);

   struct lift lifts[NUM_LIFTS];
   struct lift_step lift_steps[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

};
extern mwLift mwLifts;


old:
lifts[].x
lift_steps[][].x

new:
mwLifts.l[].x
mwLifts.lift_steps[][].x

comment out the old and lets change shit...

actually it might be easier if I did all the funtions at the same time...
then I won't have to change them only to change them back later...
ok do it...

copied all header and function..compiles clean

now comment out the old and watch everything break!
compiles clean and completely removed old z_lifts files


can I make the names shorter?

mwLifts.lifts[].x
mwLifts.lift_steps[][].x

Lifts.l[] 13 to 7 (-6)
Lifts.steps[][] 18 to 11 (-7)

yes, do it

130 lifts
86 steps
41 member function refs

now I've gone and fucked it all up

lifts within the class now has changed

it does not like the single letter l...

what else can I call it?  curr, main,
cur for lifts
stp for steps..

like this:
lift.cur[]
lift.stp[][]

OK lets try to make that happen

replace
Lifts.l[
lift.cur[

replace
Lifts.steps[
lift.stp[


now that the class name is 'lift' I can't use that as a local int anymore

I should have just called it Lift dammit!!

there is a reason for complicated variable name

to simple and search and replace fails hard

Once more with feeling...
replace lift. with Lift.

done..and it compiles:

here is what the variables are called now:

   struct lift       cur[NUM_LIFTS];
   struct lift_step  stp[NUM_LIFTS][40];
   char lift_step_type_name[10][10];

Lift.cur[]
Lift.stp[][]

so now that I have done that, what did I gain?


not sure...




z_item has ~3000 lines
e_item has 600


some items that are complex maybe should have there own source files..

I'm thinking doors, keys, rockets,

z_item.cpp
z_item_door.cpp
z_item_rocket.cpp


lets try it with keys..

just as a test to see how it could work...

got 100 lines out of z_items.cpp
and as a bonus, most stuff related to key is in the same place..


there is a bunch of stuff related to seq_color that I could find a place for..

the sorting stuff could go in e_items..

seq colors..part of bomb_blocks

I want to put bombs and rockets in their own file

z_item_bomb.cpp also rockets...500 lines

pmsg..done

also move switch to key..done


make one source file for all 4 of these closely related things:

call it trigger..

door
trigger
bd
bm

this will be the last for a while...

how nice can I make z_items.cpp look now?
now I only have around 600 lines

how big is z_enemy.cpp? 2400 lines...maybe later...




Server opened channel for `192.168.1.122:24785' and sent reply
Shutting down the server

C:\pm>pm

Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-19  17:18:27]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2626][  1926][  1382][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2544][  1683][  1466][   405][   188][   217][   673] - z_log.cpp
[  1875][  1600][  1449][   207][    56][   151][   219] - mwGraph.cpp
[  1899][  1327][  1101][   278][    52][   226][   520] - mwWidgets.cpp
[  1611][  1250][  1058][   279][    87][   192][   274] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1249][  1003][   907][   142][    46][    96][   200] - z_menu.cpp
[  1290][   971][   842][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1136][   897][   731][   206][    40][   166][   199] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1064][   881][   747][   190][    56][   134][   127] - e_edit_selection.cpp
[  1137][   807][   742][   125][    60][    65][   270] - z_settings.cpp
[   990][   734][   658][   108][    32][    76][   224] - e_fnx.cpp
[   857][   722][   407][   363][    48][   315][    87] - e_editor_main.cpp
[   926][   702][   560][   175][    33][   142][   191] - z_item_trigger.cpp
[  1191][   699][   635][   129][    65][    64][   427] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   862][   650][   618][    95][    63][    32][   149] - z_file.cpp
[   815][   642][   537][   140][    35][   105][   138] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   774][   621][   564][    92][    35][    57][   118] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[   823][   590][   539][   117][    66][    51][   167] - e_visual_level.cpp
[  1233][   585][   509][   346][   270][    76][   378] - z_args.cpp
[   766][   545][   468][   160][    83][    77][   138] - z_loop.cpp
[   650][   539][   416][   148][    25][   123][    86] - e_item.cpp
[   786][   539][   456][   155][    72][    83][   175] - z_fnx.cpp
[   649][   497][   424][   118][    45][    73][   107] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   549][   442][   395][    77][    30][    47][    77] - e_window_common.cpp
[   565][   437][   412][    28][     3][    25][   125] - mwInput.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   449][   393][   316][    87][    10][    77][    46] - mwBottomMessage.cpp
[   521][   384][   299][   132][    47][    85][    90] - z_item_bomb.cpp
[   572][   375][   372][    63][    60][     3][   137] - mwDisplay.cpp
[   438][   367][   327][    48][     8][    40][    63] - mwPDE.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   411][   293][   291][    23][    21][     2][    97] - z_config.cpp
[   350][   288][   228][    71][    11][    60][    51] - e_enemy.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   256][   217][    67][    28][    39][    69] - mwShots.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   293][   214][   208][    26][    20][     6][    59] - z_main.cpp
[   307][   201][   176][    81][    56][    25][    50] - mwGameMovesArray.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   163][   127][    53][    17][    36][    71] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    11][     9][     2][    23] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   128][    97][    81][    20][     4][    16][    27] - mwColor.cpp
[   131][    92][    91][    17][    16][     1][    23] - mwInput.h
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   116][    85][    77][    13][     5][     8][    26] - mwFont.cpp
[   141][    79][    72][    29][    22][     7][    40] - mwBitmap.cpp
[   130][    76][    71][    16][    11][     5][    43] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[   106][    67][    61][    12][     6][     6][    33] - mwEventQueue.cpp
[    91][    65][    62][     5][     2][     3][    24] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    55][    42][    40][     4][     2][     2][    11] - z_enemy.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    86][    40][    38][     3][     1][     2][    45] - mwWindowManager.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    48][    37][    35][     4][     2][     2][     9] - z_item.h
[    51][    31][    30][     3][     2][     1][    18] - mwBitmap.h
[    40][    31][    30][     2][     1][     1][     8] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidgets.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    32][    24][    24][     1][     1][     0][     7] - z_fnx.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    22][    21][    21][     1][     1][     0][     0] - e_fnx.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    35][    20][    14][     7][     1][     6][    14] - mwEventQueue.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    35][    19][    17][     3][     1][     2][    15] - mwGameMovesArray.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    20][    18][    18][     1][     1][     0][     1] - z_file.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    23][    14][     8][     7][     1][     6][     8] - mwFont.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_bomb.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    16][    12][    12][     1][     1][     0][     3] - z_menu.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    18][    10][     9][     2][     1][     1][     7] - z_level.cpp
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    14][     9][     9][     1][     1][     0][     4] - z_level.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47880][ 35512][ 30292][  8207][  2987][  5220][  9381] - 130 files


about 600 lines more than last time I looked....



bug - sometimes rocket bomb lines do not work properly
the bomb_blocks circle is way behind...
fixed...

bug - door animation sequence sometimes disappears
door tiles don't get rebuilt...
at what point are they bad?
can I check them right after creating them...
goddamn I'm dum!!!


here is what I notice...


explosions are slightly more powerful than before
test this...
level 12 aim rocket lower center and 2 rows of blocks can be destroyed...seems the same...

rockets turn at a different rate
how to test this?
before, rotation was 0-256 fixed...x10

0    =  0 deg
640  = 90 deg
-640 = 270 deg_to_rad
1200 = 180 deg

steerability slider 1-50
item[][6]

that was added directly to angle, it wrapped forever...

what values do I have now


0    =  0 deg
1500 = 90 deg
3100 = 180 deg
4600 = 270 deg

so to convert

3142/1280 = 2.45

void proc_player_riding_rocket(int p)
{
   float rot_inc = (float)item[c][6] * 2.45;

this seems really close...

I would like to use glt and multiply all the vals by 2.5

then increase the slider range to 0-100

then manually adjust directions...
ok do it...


I really don't have that many rockets in my levels


Running Global Level Test
Level:  6 st:16
Level:  8 st:45
Level: 11 st:38
Level: 11 st:25
Level: 11 st:50
Level: 11 st:30
Level: 11 st:40
Level: 11 st:50
Level: 11 st:25
Level: 11 st:1
Level: 12 st:21
Level: 12 st:21
Level: 17 st:22
Level: 22 st:30
Level: 23 st:10
Level: 26 st:35
Level: 28 st:24
Level: 50 st:16
Level: 83 st:20
Level: 84 st:32
Level:101 st:20
Level:102 st:25
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:8
Level:105 st:20
Level:155 st:1

only 28 up to here...
now can I do something about the initial directions?
or should I just adjust them all manually? yes...

rockets are done...

bottom messages do not show enemies anymore and item are not lined up...fixed
also I want some settings controls for them..

make it when left and right on levels, go to the next found level, not missing
done and it works great!!


if cancel from visual level don't reset level to 1

there are many different ways of doing this
- whenever selection is changed in vls make it change start_level
- exit with esc back to menu
- exit with enter, run level

- whenever selection is changed in vls do not change start_level
- exit with esc back to menu no change
- exit with enter, change start_level and run

which way do I like it? the first way..


here I am making a filename in a stupid way:

   char fn[20] = "levels/level000.pml";
   // look for levels that exist and put them in array
   for (int x=lll; x<ull; x++)
   {
      int h, d, rem = x;

      h = rem/100; // hundreds
      fn[12] = 48+h;
      rem -=h*100;

      d = rem/10;  // tens
      fn[13] = 48 + d;
      rem -=d*10;

      fn[14] = 48 + rem;
      if (al_filename_exists(fn)) le[num_levs++] = x; // put in array
   }

   char lf[255];
   sprintf(lf, "levels/level%03d.pml", level_num);
   //printf("saving: %s\n", lf);


right now z_level just has some variable definitions
I could make it into a class and add a bunch of methods
like what?
calc num of purple coins
take care of all the start block things
take care or erasing blocks and redrawing the level editor background when blocks change
calc num of enemies left alive??
mwLevel mLevel
.la[100][100]

done...
move tsw and merr to mwInput...done...

move more things out of file:
bitmaps
game moves
WM
then file will be done...

the only thing left in file is mw_file_select..used by bitmap_tools, edit_selection, and mwLevel..
I think I'll just put it in z_fnx for now...done

remove z_file from project...done...


void make_palette(void); -- to color
now called from display init...
moved to mwColor class and called in contructor...works good..
void window_title(void); -- to display..done
void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh);  -- to font..dpne


void get_hostname(int print); used in main and when clicking on button in settings..
maybe do inline?
print only from settings..done
inline in main


void spin_shape(int tn, int x, int y, int tsx, int tsy, int tsw, int tsh, float scale, float dim, int cycle);
move to bitmaps..

void show_var_sizes(void);
move to display with all the other console text dumps..


the pile is getting small...

should I make multi color lines its own thing?
it does not need to be a class, it only has 3 functions:

call it mw_multicolor_line...

move everything left into e_fnx...done

remove z_fnx...done



help should be made a class...
mwHelp mHelp
done..


I should be more consistant with my naming conventions

class names all start with mw then CamelCase...
they are already all like that...
but the instances of classes are all over the place
sometimes I made them shorter, but that hurts readability...just like too long does also...


menu stuff...

I should get rid of global_string

use something local and fill it everytime it is called...

I will still need to store it somewhere:

how about a class?

this time though, create instances when needed, nothing global
put all three menu type in the class..
use a common global string and have methods to assist with filling it

zmenu and tmenu done...
pmenu done..
disabling all old vars...done...

now move the text setup into item and enemy respectivbely...done

now the only thing left in z_menu is the text editing stuff....

and that fucking msg...


well its 3:40

20230220 3:40PM

push...

Purple Martians Source Code Line Counts [2023-02-20  15:45:36]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2089][  1761][  1353][   514][   106][   408][   222] - e_object_viewer.cpp
[  2550][  1685][  1468][   405][   188][   217][   677] - z_log.cpp
[  1878][  1601][  1450][   207][    56][   151][   221] - mwGraph.cpp
[  1899][  1328][  1102][   278][    52][   226][   519] - mwWidgets.cpp
[  1609][  1249][  1056][   280][    87][   193][   273] - z_player.cpp
[  1253][  1005][   903][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1293][   970][   841][   189][    60][   129][   263] - e_bitmap_tools.cpp
[  1399][   945][   834][   189][    78][   111][   376] - e_fnx.cpp
[  1140][   899][   733][   206][    40][   166][   201] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1063][   879][   745][   190][    56][   134][   128] - e_edit_selection.cpp
[  1139][   807][   742][   125][    60][    65][   272] - z_settings.cpp
[   862][   723][   408][   363][    48][   315][    91] - e_editor_main.cpp
[   925][   702][   560][   174][    32][   142][   191] - z_item_trigger.cpp
[  1194][   701][   637][   121][    57][    64][   436] - e_glt.cpp
[   779][   687][   604][   101][    18][    83][    74] - e_group_edit.cpp
[   815][   641][   536][   140][    35][   105][   139] - z_item.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   777][   620][   563][    92][    35][    57][   122] - n_client.cpp
[   782][   614][   565][   100][    51][    49][   117] - n_server.cpp
[  1234][   582][   506][   347][   271][    76][   381] - z_args.cpp
[   718][   580][   457][   148][    25][   123][   113] - e_item.cpp
[   810][   580][   531][   115][    66][    49][   164] - e_visual_level.cpp
[   765][   533][   456][   161][    84][    77][   148] - z_loop.cpp
[   682][   522][   449][   120][    47][    73][   113] - mwWindowManager.cpp
[   703][   477][   457][    92][    72][    20][   154] - mwLogo.cpp
[   683][   465][   426][   124][    85][    39][   133] - mwGameMovesArray.cpp
[   592][   459][   434][    28][     3][    25][   130] - mwInput.cpp
[   553][   443][   396][    77][    30][    47][    80] - e_window_common.cpp
[   679][   442][   439][    67][    64][     3][   173] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   492][   422][   366][    73][    17][    56][    53] - mwHelp.cpp
[   592][   418][   193][   258][    33][   225][   141] - e_tile_helper.cpp
[   495][   380][   295][   120][    35][    85][    80] - z_item_bomb.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   438][   366][   326][    48][     8][    40][    64] - mwPDE.cpp
[   403][   332][   272][    71][    11][    60][    60] - e_enemy.cpp
[   475][   322][   297][    62][    37][    25][   116] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   348][   297][   278][    32][    13][    19][    38] - mwWindow.cpp
[   409][   290][   288][    23][    21][     2][    98] - z_config.cpp
[   455][   282][   235][    85][    38][    47][   135] - z_item_pmsg.cpp
[   390][   265][   188][   130][    53][    77][    72] - z_item_door.cpp
[   353][   255][   216][    67][    28][    39][    70] - mwShots.cpp
[   319][   232][   226][    27][    21][     6][    66] - z_main.cpp
[   311][   225][   184][    56][    15][    41][    71] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   197][   185][    29][    17][    12][    42] - z_menu.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   251][   162][   126][    53][    17][    36][    72] - z_item_key.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   151][   119][   117][    12][    10][     2][    22] - z_sound.cpp
[   220][   116][   107][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   111][   111][     5][     5][     0][    16] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   124][    92][    84][    15][     7][     8][    25] - mwFont.cpp
[   121][    86][    72][    24][    10][    14][    25] - n_netgame.cpp
[   132][    76][    71][    16][    11][     5][    45] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   111][    71][    65][    12][     6][     6][    34] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    38][    36][     4][     2][     2][     9] - z_item.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    59][    32][    32][     4][     4][     0][    23] - e_fnx.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidgets.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    21][    19][    19][     1][     1][     0][     1] - e_visual_level.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    20][    14][    14][     1][     1][     0][     5] - z_item_trigger.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    20][    10][    10][     5][     5][     0][     5] - z_item_bomb.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[     9][     8][     8][     1][     1][     0][     0] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    11][     6][     6][     1][     1][     0][     4] - z_item_key.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[    11][     4][     4][     1][     1][     0][     6] - z_item_door.h
[    21][     4][     4][     1][     1][     0][    16] - z_item_pmsg.h
[     7][     4][     4][     1][     1][     0][     2] - z_menu.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 48239][ 35551][ 30333][  8226][  3008][  5218][  9680] - 132 files



lets remove msg wherever we can

I guess I could take 250 lines of edit text from menu and put it in e_fnx...
then kill menu


or....
leave only msg in menu...to see where I need to kill it...
done..I have been through every file and removed all global msg.. then kill z_menu.cpp and h...



mwItems mItem

mItem.i[16]
mItem.f[4]


I will have multiple source files for this class named as follows:

mwItems.h
mwItems.cpp

mwItemDoor.cpp
mwItemBomb.cpp
mwItemKey.cpp
mwItemMessage.cpp
mwItemTrigger.cpp


I will also put all functions from e_items.cpp in mwItems.cpp  if there are too many, later I will make more files

for now, lets just stick everything in the one file...mwItems.cpp...and get it to compile..


I now have a 4000 line file....
now for the header....
it will never change...


that all compiles clean...

I am a little scared to make my var names too short...

I would like:
mItem.i[16]
mItem.f[4]

but that would mean that in the class they would look like:

i[16]
f[4]

and could easily get confused with other single char var names:

I am just going to leave them as they are:

mItem.item[16]
mItem.itemf[4]


item[
itemf

1784 occ
186

do a global replace...just make sure to not do any within the class

item[ to mItem.item[
itemf[ to mItem.itemf[


it compiles...

I have removed:
e_items.cpp
z_items.cpp
z_items_xxx.cpp
files are removed from project...

everything is in the class and it compiles and seems to work!!

now lets try to make more .cpp files..

mwItemTrigger.cpp 880 lines
mwItemMessage.cpp 400 lines
mwItemBomb.cpp 500 lines
mwItemKey.cpp 200 lines
mwItemDoor.cpp 350 lines
mwItems.cpp 1500 lines

getting there...

700 lines of stuff that used to be in e_items...

time for a push then bed time...



Purple Martians Source Code Line Counts [2023-02-20  23:33:51]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidgets.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1519][  1225][   999][   285][    59][   226][   235] - mwItems.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   817][   701][   559][   165][    23][   142][    93] - mwItemTrigger.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   489][   379][   294][   120][    35][    85][    75] - mwItemBomb.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   434][   303][   287][    28][    12][    16][   119] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   407][   282][   235][    73][    26][    47][    99] - mwItemMessage.cpp
[   357][   264][   187][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   315][   232][   226][    27][    21][     6][    62] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   199][   160][   124][    53][    17][    36][    22] - mwItemKey.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   133][    87][    84][    11][     8][     3][    38] - mwItems.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidgets.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47894][ 35597][ 30380][  8163][  2946][  5217][  9351] - 124 files


now: (final)
700 mwItems.cpp
650 mwItemEditorFnz.cpp
800 mwItemTrigger.cpp
500 mwItemBomb.cpp
400 mwItemMessage.cp
200 mwItemKey.cpp
350 mwItemDoor.cpp
100 mwItems.h
-------------
3700 lines



in draw item make custom functions to draw key, start, exit, rocket message...

push..
maybe I'll get to do something at work...

nope...

num of starts is set only when items are sorted...
I should do it where i count purple coins...done..

items is done..

System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  19:00:59]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2627][  1927][  1383][   787][   243][   544][   457] - z_enemy.cpp
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidgets.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1625][  1134][  1011][   217][    94][   123][   397] - e_fnx.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItems.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   402][   332][   272][    71][    11][    60][    59] - e_enemy.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   313][   231][   225][    27][    21][     6][    61] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItems.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    56][    43][    41][     4][     2][     2][    11] - z_enemy.h
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    66][    35][    35][     4][     4][     0][    27] - e_fnx.h
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidgets.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47891][ 35624][ 30408][  8168][  2952][  5216][  9315] - 126 files






now enemies!!

first put everything in one file...

2600 z_enemy.cpp
400  e_enemy.cpp
200 e_fnx.cpp


that's not how I did it with items


mwEnemy mEnemy

mEnemy.Ei[]
mEnemy.Ef[]


put everything in class
class file compiles

now fix all refs..
done:

compiles and runs!!!

now what?

3200 lines..
start making other files...

got to go..push time...



Purple Martians Version 7.24.2
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160


Purple Martians Source Code Line Counts [2023-02-21  21:16:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2088][  1760][  1352][   514][   106][   408][   222] - e_object_viewer.cpp
[  2559][  1695][  1478][   405][   188][   217][   676] - z_log.cpp
[  2231][  1654][  1244][   590][   180][   410][   397] - mwEnemy.cpp
[  1883][  1606][  1455][   207][    56][   151][   221] - mwGraph.cpp
[  1900][  1326][  1100][   278][    52][   226][   522] - mwWidgets.cpp
[  1607][  1248][  1055][   280][    87][   193][   272] - z_player.cpp
[  1258][  1010][   908][   137][    35][   102][   213] - z_screen_overlay.cpp
[  1443][   985][   894][   148][    57][    91][   401] - e_fnx.cpp
[  1289][   970][   841][   188][    59][   129][   260] - e_bitmap_tools.cpp
[  1137][   899][   733][   206][    40][   166][   198] - mwLift.cpp
[  1119][   888][   722][   207][    41][   166][   190] - z_lift.cpp
[  1062][   879][   745][   190][    56][   134][   127] - e_edit_selection.cpp
[  1119][   808][   743][   125][    60][    65][   251] - z_settings.cpp
[   859][   723][   408][   363][    48][   315][    88] - e_editor_main.cpp
[   821][   705][   563][   165][    23][   142][    93] - mwItemTrigger.cpp
[  1192][   701][   637][   121][    57][    64][   434] - e_glt.cpp
[   780][   687][   604][   101][    18][    83][    75] - e_group_edit.cpp
[   931][   635][   549][   166][    80][    86][   216] - z_screen.cpp
[   781][   629][   572][    92][    35][    57][   117] - n_client.cpp
[   794][   625][   576][   101][    52][    49][   117] - n_server.cpp
[  1233][   582][   506][   346][   270][    76][   381] - z_args.cpp
[   799][   569][   521][   110][    62][    48][   168] - mwVisualLevel.cpp
[   676][   552][   469][   107][    24][    83][   100] - mwItems.cpp
[   649][   540][   417][   148][    25][   123][    84] - mwItemEditorFnx.cpp
[   761][   534][   457][   161][    84][    77][   143] - z_loop.cpp
[   681][   521][   448][   120][    47][    73][   113] - mwWindowManager.cpp
[   704][   477][   457][    92][    72][    20][   155] - mwLogo.cpp
[   671][   467][   428][   125][    86][    39][   118] - mwGameMovesArray.cpp
[   591][   459][   434][    28][     3][    25][   129] - mwInput.cpp
[   552][   444][   397][    77][    30][    47][    78] - e_window_common.cpp
[   675][   443][   440][    67][    64][     3][   168] - mwDisplay.cpp
[   583][   436][   345][   150][    59][    91][    88] - z_solid.cpp
[   493][   422][   366][    73][    17][    56][    54] - mwHelp.cpp
[   588][   418][   193][   258][    33][   225][   137] - e_tile_helper.cpp
[   522][   394][   306][   128][    40][    88][    88] - mwItemBombRocket.cpp
[   434][   379][   303][    86][    10][    76][    45] - mwBottomMessage.cpp
[   439][   366][   326][    48][     8][    40][    65] - mwPDE.cpp
[   398][   332][   213][   154][    35][   119][    31] - mwEnemyTrakbot.cpp
[   447][   322][   297][    49][    24][    25][   101] - mwMenu.cpp
[   442][   307][   291][    28][    12][    16][   123] - mwLevel.cpp
[   347][   297][   278][    31][    12][    19][    38] - mwWindow.cpp
[   424][   294][   246][    76][    28][    48][   102] - mwItemMessage.cpp
[   410][   291][   289][    23][    21][     2][    98] - z_config.cpp
[   358][   265][   188][   114][    37][    77][    56] - mwItemDoor.cpp
[   352][   255][   216][    67][    28][    39][    69] - mwShots.cpp
[   311][   230][   224][    27][    21][     6][    60] - z_main.cpp
[   310][   225][   184][    56][    15][    41][    70] - mwPMEvent.cpp
[   339][   212][   187][    68][    43][    25][    84] - mwBitmap.cpp
[   266][   206][   162][    58][    14][    44][    46] - mwEnemyJumpworm.cpp
[   256][   181][   180][     5][     4][     1][    71] - mwGraph.h
[   204][   167][   129][    54][    16][    38][    21] - mwItemKeySwitch.cpp
[   217][   156][   138][    27][     9][    18][    52] - z_player.h
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   166][   148][   131][    20][     3][    17][    15] - mw_multicolor_line.cpp
[   184][   141][   139][     8][     6][     2][    37] - n_packet.cpp
[   188][   133][   100][    56][    23][    33][    32] - mwColor.cpp
[   223][   133][   100][    65][    32][    33][    58] - mwEnemyCloner.cpp
[   154][   126][   115][    18][     7][    11][    21] - z_control.cpp
[   149][   119][   117][    11][     9][     2][    21] - z_sound.cpp
[   221][   117][   108][    68][    59][     9][    45] - mwDrawSequence.cpp
[   138][   113][   100][    23][    10][    13][    15] - mwItemStartExitWarp.cpp
[   132][   110][   110][     5][     5][     0][    17] - pm.h
[   151][   108][    99][    16][     7][     9][    36] - mwQuickGraph.cpp
[   188][   103][    74][    73][    44][    29][    41] - mwEnemyFlapper.cpp
[   137][    94][    93][    17][    16][     1][    27] - mwInput.h
[   123][    92][    84][    15][     7][     8][    24] - mwFont.cpp
[   120][    92][    89][    11][     8][     3][    20] - mwItems.h
[   117][    86][    72][    24][    10][    14][    21] - n_netgame.cpp
[   129][    76][    71][    16][    11][     5][    42] - mwDemoMode.cpp
[    87][    74][    74][     1][     1][     0][    12] - mwTimeStamp.cpp
[    94][    73][    72][     6][     5][     1][    16] - mwLift.h
[   112][    71][    65][    12][     6][     6][    35] - mwEventQueue.cpp
[    81][    68][    68][     4][     4][     0][     9] - z_lift.h
[    96][    67][    64][     5][     2][     3][    27] - mwDisplay.h
[   114][    61][    58][    12][     9][     3][    44] - z_log.h
[    76][    57][    54][     8][     5][     3][    14] - mwEnemy.h
[    77][    56][    52][    14][    10][     4][    11] - mwWindow.h
[    72][    51][    51][     5][     5][     0][    16] - mwTally.cpp
[    92][    42][    40][     3][     1][     2][    49] - mwWindowManager.h
[    69][    40][    37][     5][     2][     3][    27] - mwLogo.h
[    54][    39][    39][     1][     1][     0][    14] - mwShots.h
[    49][    37][    31][     7][     1][     6][    11] - mwRollingAverage.cpp
[    61][    35][    34][     3][     2][     1][    24] - mwBitmap.h
[    42][    33][    32][     2][     1][     1][     8] - mwVisualLevel.h
[    43][    32][    31][     2][     1][     1][    10] - mwColor.h
[    53][    31][    30][     6][     5][     1][    17] - mwProgramState.h
[    35][    31][    31][     1][     1][     0][     3] - n_packet.h
[    37][    29][    29][     1][     1][     0][     7] - mwWidgets.h
[    43][    28][    27][     2][     1][     1][    14] - mwLevel.h
[    48][    27][    27][     1][     1][     0][    20] - e_fnx.h
[    41][    27][    27][     3][     3][     0][    11] - mwProgramState.cpp
[    40][    25][    25][     1][     1][     0][    14] - mwBottomMessage.h
[    48][    25][    25][    10][    10][     0][    13] - n_network.cpp
[    51][    24][    22][     4][     2][     2][    25] - mwGameMovesArray.h
[    36][    24][    24][     1][     1][     0][    11] - mwTimeStamp.h
[    35][    23][    22][     2][     1][     1][    11] - mwQuickGraph.h
[    24][    22][    22][     1][     1][     0][     1] - n_client.h
[    44][    21][    20][     2][     1][     1][    22] - mwDrawSequence.h
[    35][    21][    15][     7][     1][     6][    13] - mwEventQueue.h
[    32][    21][    13][    14][     6][     8][     5] - n_netgame.h
[    23][    20][    20][     1][     1][     0][     2] - e_bitmap_tools.h
[    22][    20][    20][     1][     1][     0][     1] - z_screen.h
[    27][    19][    19][     1][     1][     0][     7] - mwDemoMode.h
[    30][    19][    18][     2][     1][     1][    10] - mwTally.h
[    21][    19][    19][     1][     1][     0][     1] - n_server.h
[    21][    18][    17][     2][     1][     1][     2] - mwRollingAverage.h
[    29][    16][    15][     2][     1][     1][    12] - mwPMEvent.h
[    23][    16][    16][     2][     2][     0][     5] - z_sound.h
[    27][    15][     9][     7][     1][     6][    11] - mwFont.h
[    24][    15][    15][     1][     1][     0][     8] - mwPDE.h
[    17][    14][    14][     1][     1][     0][     2] - e_edit_selection.h
[    15][    13][    13][     1][     1][     0][     1] - e_group_edit.h
[    24][    13][    12][     2][     1][     1][    10] - mwMenu.h
[    15][    13][    13][     1][     1][     0][     1] - z_screen_overlay.h
[    14][    11][    11][     1][     1][     0][     2] - e_object_viewer.h
[    12][    10][    10][     1][     1][     0][     1] - z_solid.h
[    16][     9][     9][     1][     1][     0][     6] - mwHelp.h
[    11][     8][     8][     1][     1][     0][     2] - e_editor_main.h
[    11][     8][     8][     1][     1][     0][     2] - z_loop.h
[    10][     7][     7][     1][     1][     0][     2] - z_control.h
[    10][     7][     7][     1][     1][     0][     2] - z_main.h
[    12][     6][     5][     2][     1][     1][     5] - e_tile_helper.h
[    17][     5][     5][     5][     5][     0][     7] - z_settings.h
[     7][     4][     4][     1][     1][     0][     2] - e_window_common.h
[     6][     4][     4][     1][     1][     0][     1] - z_args.h
[     4][     3][     3][     1][     1][     0][     0] - e_glt.h
[     6][     2][     2][     1][     1][     0][     3] - mw_multicolor_line.h
[     3][     2][     2][     1][     1][     0][     0] - n_network.h
[     4][     2][     2][     1][     1][     0][     1] - z_config.h
-------------------------------------------------------- - totals
[ 47986][ 35649][ 30433][  8182][  2966][  5216][  9371] - 129 files















































































































































































































































































































































































































