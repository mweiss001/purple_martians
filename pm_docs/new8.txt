20221228

New running log of changes to the project...

The old one was over 40,000 lines and 1M char...


do a line count:

24525 code only
8006 empty
4979 comment
4557 code and comment
----------------
42067 total


where do I use proc_controllers?
108 matches

not in client anymore since I removed the blocking...

client does not exit when connection fails...fixed first part...

now what about waiting for initial state from server?

break it on the server and test how client responds

did it not used to say waiting for server in a few places?


I have made a nice way to quit while waiting for initial state....

I should make all the ways to exit from client go to a state that cleans up....i think I did...

client still will not rejoin until program is restarted....fixed...it was a strange issue with packetpos needing to be reset to 0


later make sure that server cleans up at exit like client, and try to restart....

also make sure that TCP still works...



Now I think I am finally ready to try some fast ping packets


OK I have the packet passing...what should I do about it?


when server receives pong do some timing

ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   1.2 ms
ping time:   1.6 ms
ping time:   1.6 ms
ping time:   0.5 ms
ping time:   1.3 ms
ping time:   0.9 ms
ping time:   1.1 ms
ping time:   1.5 ms
ping time:   1.0 ms
ping time:   1.5 ms
ping time:   0.7 ms
ping time:   0.6 ms
ping time:   0.6 ms

this is round trip UDP on LAN

switching to WAN


96.45.15.187


I am going to send the ts with the packet and add client ts also...
how do I add a double to a packet?

I could turn it into a char array like I do with state...


im guessing sizeof double is 8...

double test = 1.23;

memcpy(packetbuffer+pos, test,  8);





   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;




before I do this in a packet, lets just try to do it in a regular way....



void PacketPutDouble(double *d)
{
   memcpy(packetbuffer+packetsize, d, 8);
	packetsize+=8;
}

double PacketGetDouble(void)
{
   double d[2];
   memcpy(d, packetbuffer+packetpos, 8);
	packetpos+=8;
	return *d;
}



use this:
char packetbuffer[1024];

make a function to stick something in it and another fucntion to get it out....




char packetbuffer1[1024] = {0};
int packetsize1 = 0;
int packetpos1 = 0;

void PacketPutDouble1(double d)
{
   double dd[2] = {0};
   dd[0] = d;
   memcpy(packetbuffer1 + packetsize1, dd, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d[2] = {0};
   memcpy(d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d[0];
}

void temp_test(void)
{
   double t0 = 0.000123;
   printf("1 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);

   PacketPutDouble1(t0);
   printf("2 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);


   double t1 = PacketGetDouble1();
   printf("3 - ps:%d pp:%d sot:%d t1:%f\n", packetsize1, packetpos1, sizeof(t1), t1);


this shit works!!!


the problem I was having is that memcopy does not like to be passed plain variables, it wants pointers...
so I made an array of the variable tyope I wanted and only use the first element...

found this:


double in=2.132;
char arr[12] = {};
memcpy(arr,&in,sizeof(in));

char arr2[12] = ...;
double out;
memcpy(&out,arr2,sizeof(out));

void PacketPutDouble1(double d)
{
   memcpy(packetbuffer1 + packetsize1, &d, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d = 0;
   memcpy(&d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d;
}

that works too!

now put it in the packets....done...

now try


C:\pm>pm -s

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Local address of channel:24785
Network initialized - channel mode (UDP)
Server successfully initialized

Server received initial 1234 packet from '192.168.1.116:24785'
Server opened channel for `192.168.1.116:24785' and sent reply
ping time:   0.7 ms
ping time:   0.7 ms
ping time:   0.4 ms
ping time:   1.3 ms
ping time:   0.3 ms
ping time:   1.1 ms
ping time:   1.0 ms
ping time:   1.2 ms
ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.4 ms
ping time:   1.1 ms
ping time:   0.4 ms
ping time:   0.6 ms
ping time:   0.5 ms
Shutting down the server


now try internet:


Server received initial 1234 packet from '70.75.228.155:24785'
Server opened channel for `70.75.228.155:24785' and sent reply
ping time:  30.6 ms
ping time:  25.7 ms
ping time:  21.7 ms
ping time:  26.7 ms
ping time:  20.7 ms
ping time:  31.1 ms
ping time:  26.3 ms
ping time:  27.9 ms
ping time:  24.1 ms
ping time:  27.8 ms
ping time:  25.9 ms
ping time:  35.6 ms
Shutting down the server


OK I've got something

now try TCP

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Network initialized - connection mode (TCP)
Server successfully initialized

Connection received from 70.75.228.155:63272
ping time:  34.1 ms
ping time:  48.3 ms
ping time:  24.3 ms
ping time:  23.1 ms
ping time:  23.7 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  27.4 ms
ping time:  32.7 ms
ping time:  25.6 ms
ping time:  30.6 ms
ping time:  28.6 ms
ping time:  31.7 ms
ping time:  70.3 ms
Shutting down the server

not that much of a difference...

Now how can I use this to monitor and adjust timing..

Now that I can receive stdf any time, I want to know exactly when I am receiving them

this will be a client thing

when client gets an stdf, compare to the latest frame start

it was about 23ms after frame start...

soon, timestamp fills up.. I should make one global timestamp called frame_start....
I am amazed at how stable the timer is, fps adjust very rarely has anything to do...

now lets try fine tuning the sync...


I can get it down to 5-10 instead of 22 with fine tuning, but it does not make the game more playable on WAN
LAN still looks great

the problem on WAN is the corrections make it look really jumpy
try s1 = 2...



it work so good on LAN, whay not WAN, why so many jumpy corrections??

I need to look into the timing closer

maybe running just in time to get difs as needed is not the right approach

If I got difs for a frame that I has already rendered...
I could replay with the local controls for that frame that has already occured...
this would mean I am running ahead of the the server
controls that I am currently pressing are not as old on the server


If I got difs for a frame that I had not rendered yet...
i would hold off till then and apply it
this would mean I am running behind the server
controls that I am currently pressing are even older on the server



I will need to experiment with both

20221219 11:22PM ..push



I have some thoughts...

I want to know where in the client frame are the stdf's rx'd and where are they used..


Make a graphical overlay for the game

sliding bar to show sync and stuff

controls also...

timestamp bar in screen overlay
what am I going to show?

where will i get the data for that

should I clear old timestamps every second?

yes and I should do somthing in there about doing some nice averages and min max

later...


now I want to have some timestamps that do not get saved, only for current frame...
I have one for frame start, but I also want one for stdf rx..


what if I log these so that I can make a nice graph and look at them?? maybe later...


what I am seeing is the stdf being rx'd right after draw in the frame


where in the frame does the client use stdf?

at the very start...

- input
- move
- draw


what if I measured the timestamp difference between stdf packet being received and it being used by the client?

that is the critical timing anyway, is it not?



I want to solve the client sync thing....
I want to be able to control where in the frame the stdf is rx'd
this is proving to be harder than I thought

OK I think I figured out how to do that...

now I want to see if I can have some on screen controls

they will need to be non-blocking


run them from debug screen overlay

first can I show mouse??..yes

button works but blocks on mouse press....
made a non_blocking version


         static int pres = 0;
         if (mdw_buttont_nb(100, yyy, 200, 16,  0,0,0,0,  0,14,15, 0,  1,0,1,0, "Inc"))
         {
            if (pres == 0) printf ("incd\n");
            pres = 1;
         }
         else pres = 0;




now make a global to control the client dsync....done


when adjusting chase too close the connection is lost
the client gets difs too late to apply and does nothing??

cleaning up the logging...

removed call to apply dif from rx packet thing
now only called in the loop every frame and when waiting for intial state

logs look much better now...

I can tell the we are receiving stdf's too late..

they fail all the time when trying to apply, but that is normal.

what I should do is check when they are completed if there is any chance they can be used....
if they are late then I should raise some errors...already done....but addedd to log...
in client debug screen if server_sync = -1

and stays there for 100 frames server will drop

should client reply at all, all it has is stak...and we are not acknowledging anything...

we ack when we get a bad base, should we ack when we get a bad dest??...yes...done...



now sync can go to -1 and client stays connected

I should have something on the client to tell when te last applied dif is.

I am thinking about the nice little graph that shows dsync...
It could also display last diff applied....

added to player1

   int client_last_diff_applied;


That works...


now I want to make a nice little display for the client.

graph
buttons
chase_offset
last_dif
draw in red if last_dif > 2


for the actual value, lets take if from

added to player1 struct...
   double dsync;


OMG that looks great...

now what??

that is about the only thing that I can adjust and monitor on the client....
it sends cdats when they occurs
it processes stdfs just before it has to apply them...

this client dsync is such an important number that I wonder if I should sync it back to the server.
I could add it to stak....

on the client


move all of these to player1

double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;
double client_chase_offset = 0.010;

done...

I actually did not need these and removed them...
double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;

still wondering about adding dsync to stak so server has it....

It was as easy as adding one line on the client:

   PacketPutDouble(players1[p].dsync);

   and one on the client...

   players1[p].dsync            = PacketGetDouble();

add display it in server debug...done...


now what?

do some things for server...like?

buttons to change s1 and s2

graph to show when clients cdats arrive in relation to current frame...

s1 and s2 are already part of the player1 struct...

done...


I want to know at what position in the frame do cdats arrive at, and how many frames behind....

crudely looking in the logs -2 and rarely -3 for a WAN game....
-1 for a LAN game....this might be unavoidable...

if the round trip ping is around 30 then one way would be 15...

I want to know exactly what it is and see if adjusting the client offset can do anything about it....


so how to measure?


server fast packet loop already marks cdats with timestamp when they arrive

so go to where they are processed...




I still don't like how the frame_number are processed!!
I really want to fix it but I am scared of what it will break....

---------------
- current:
---------------
timer_triggers_event

input
move
draw
inc frame

wait until triggered again...


---------------
what I want:
---------------
timer_triggers_event

inc frame
input
move
draw

wait until triggered again...

this would mean that for the entirety of the frame, the frame number is the same

not
change frame number
wait
do stuff

the wait would be at the end....


goddamn it!! I don't care what I have to fix...I'm going to make it so that is how it is...

one consequence is there will never be a frame 0...I know somethings depend on that....

or rather any setup that is done before the first loop will be done on frame 1....


it is done, these are the first lines

frame_num++;
update_animation();

lets see what still works...

single player seems good....level done too

server and client seem to work...omg...

This will have more of an effect on some timer things I am doing....




[1457]cdat 1455  gc:-2 0.016008
[1458]cdat 1456  gc:-2 0.012546
[1459]cdat 1457  gc:-2 0.008733
[1460]cdat 1458  gc:-2 0.013411
[1461]cdat 1459  gc:-2 0.015866
[1462]cdat 1460  gc:-2 0.016015
[1463]cdat 1461  gc:-2 0.008641
[1464]cdat 1462  gc:-2 0.012660
[1465]cdat 1463  gc:-2 0.016165
[1466]cdat 1464  gc:-2 0.016065
[1467]cdat 1465  gc:-2 0.008550
[1468]cdat 1466  gc:-2 0.016006
[1469]cdat 1467  gc:-2 0.013687
[1470]cdat 1468  gc:-2 0.010922
[1471]cdat 1469  gc:-2 0.011143
[1472]cdat 1470  gc:-2 0.015377
[1473]cdat 1471  gc:-2 0.011053
[1474]cdat 1472  gc:-2 0.013461
[1476]cdat 1473  gc:-3 0.023695
[1477]cdat 1474  gc:-3 0.023571
[1477]cdat 1475  gc:-2 0.015960
[1478]cdat 1476  gc:-2 0.016023
[1479]cdat 1477  gc:-2 0.008565
[1480]cdat 1478  gc:-2 0.015372
[1481]cdat 1479  gc:-2 0.011239
[1482]cdat 1480  gc:-2 0.015975
[1483]cdat 1481  gc:-2 0.016240
[1484]cdat 1482  gc:-2 0.013693
[1485]cdat 1483  gc:-2 0.013712
[1486]cdat 1484  gc:-2 0.016219
[1487]cdat 1485  gc:-2 0.006484
[1488]cdat 1486  gc:-2 0.010268
[1489]cdat 1487  gc:-2 0.016290
[1490]cdat 1488  gc:-2 0.016250
[1491]cdat 1489  gc:-2 0.005989
[1492]cdat 1490  gc:-2 0.016332
[1493]cdat 1491  gc:-2 0.016286
[1494]cdat 1492  gc:-2 0.011335
[1496]cdat 1493  gc:-3 0.015332
[1496]late cdat dropped p:1 c:1493  state:1494  tally:5
[1496]cdat 1494  gc:-2 0.015881
[1497]cdat 1495  gc:-2 0.011157
[1498]cdat 1496  gc:-2 0.016283
[1500]cdat 1497  gc:-3 0.018602
[1500]cdat 1498  gc:-2 0.016122
[1501]cdat 1499  gc:-2 0.016274
[1502]cdat 1500  gc:-2 0.016290
[1504]cdat 1501  gc:-3 0.022777
[1504]cdat 1502  gc:-2 0.015344
[1505]cdat 1503  gc:-2 0.016394
[1506]cdat 1504  gc:-2 0.013682
[1507]cdat 1505  gc:-2 0.005452
[1508]cdat 1506  gc:-2 0.016448
[1509]cdat 1507  gc:-2 0.008965
[1510]cdat 1508  gc:-2 0.013958
[1511]cdat 1509  gc:-2 0.012853
[1512]cdat 1510  gc:-2 0.012440
[1513]cdat 1511  gc:-2 0.010386
[1514]cdat 1512  gc:-2 0.015350
[1515]cdat 1513  gc:-2 0.002899
[1516]cdat 1514  gc:-2 0.015026
[1517]cdat 1515  gc:-2 0.010401
[1518]cdat 1516  gc:-2 0.012886
[1519]cdat 1517  gc:-2 0.012882
[1520]cdat 1518  gc:-2 0.015386
[1521]cdat 1519  gc:-2 0.012910
[1522]cdat 1520  gc:-2 0.015355
[1523]cdat 1521  gc:-2 0.007923
[1524]cdat 1522  gc:-2 0.012935
[1525]cdat 1523  gc:-2 0.012978
[1526]cdat 1524  gc:-2 0.015520
[1527]cdat 1525  gc:-2 0.012827
[1528]cdat 1526  gc:-2 0.015430
[1529]cdat 1527  gc:-2 0.015545
[1530]cdat 1528  gc:-2 0.012892
[1531]cdat 1529  gc:-2 0.012998
[1532]cdat 1530  gc:-2 0.014326
[1533]cdat 1531  gc:-2 0.012941
[1534]cdat 1532  gc:-2 0.015566
[1535]cdat 1533  gc:-2 0.008016
[1537]cdat 1535  gc:-2 0.015592
[1538]cdat 1536  gc:-2 0.015593
[1539]cdat 1537  gc:-2 0.000435
[1540]cdat 1538  gc:-2 0.015559
[1541]cdat 1539  gc:-2 0.015597
[1542]cdat 1540  gc:-2 0.015425
[1543]cdat 1541  gc:-2 0.008001
[1544]cdat 1542  gc:-2 0.014422
[1545]cdat 1543  gc:-2 0.008050
[1546]cdat 1544  gc:-2 0.015639
[1547]cdat 1545  gc:-2 0.015657
[1548]cdat 1546  gc:-2 0.010277
[1549]cdat 1547  gc:-2 0.015553
[1550]cdat 1548  gc:-2 0.013098
[1551]cdat 1549  gc:-2 0.008058
[1552]cdat 1550  gc:-2 0.015317
[1553]cdat 1551  gc:-2 0.016250
[1554]cdat 1552  gc:-2 0.016115
[1555]cdat 1553  gc:-2 0.006201
[1556]cdat 1554  gc:-2 0.016057
[1557]cdat 1555  gc:-2 0.013614
[1558]cdat 1556  gc:-2 0.011243
[1559]cdat 1557  gc:-2 0.013781
[1560]cdat 1558  gc:-2 0.015270
[1561]cdat 1559  gc:-2 0.016355
[1562]cdat 1560  gc:-2 0.016313
[1563]cdat 1561  gc:-2 0.005983
[1564]cdat 1562  gc:-2 0.016292
[1565]cdat 1563  gc:-2 0.016259
[1566]cdat 1564  gc:-2 0.016243
[1568]cdat 1565  gc:-3 0.021811
[1568]late cdat dropped p:1 c:1565  state:1566  tally:6
[1568]cdat 1566  gc:-2 0.010779
[1569]cdat 1567  gc:-2 0.013561
[1570]cdat 1568  gc:-2 0.013822
[1571]cdat 1569  gc:-2 0.013807
[1572]cdat 1570  gc:-2 0.016112
[1573]cdat 1571  gc:-2 0.013626
[1574]cdat 1572  gc:-2 0.011389
[1575]cdat 1573  gc:-2 0.008685
[1576]cdat 1574  gc:-2 0.014161
[1577]cdat 1575  gc:-2 0.013923
[1578]cdat 1576  gc:-2 0.013768
[1579]cdat 1577  gc:-2 0.011336
[1580]cdat 1578  gc:-2 0.013763
[1581]cdat 1579  gc:-2 0.013759
[1582]cdat 1580  gc:-2 0.016342
[1583]cdat 1581  gc:-2 0.013814
[1584]cdat 1582  gc:-2 0.009788
[1585]cdat 1583  gc:-2 0.015957
[1586]cdat 1584  gc:-2 0.015287
[1587]cdat 1585  gc:-2 0.012783
[1588]cdat 1586  gc:-2 0.012283
[1589]cdat 1587  gc:-2 0.014804
[1590]cdat 1588  gc:-2 0.009828
[1591]cdat 1589  gc:-2 0.012939
[1592]cdat 1590  gc:-2 0.014961
[1593]cdat 1591  gc:-2 0.014743
[1594]cdat 1592  gc:-2 0.015493
[1595]cdat 1593  gc:-2 0.015486
[1596]cdat 1594  gc:-2 0.015339
[1597]cdat 1595  gc:-2 0.015183
[1598]cdat 1596  gc:-2 0.012898
[1599]cdat 1597  gc:-2 0.012872
[1600]cdat 1598  gc:-2 0.015144
[1601]cdat 1599  gc:-2 0.015399
[1602]cdat 1600  gc:-2 0.015535
[1603]cdat 1601  gc:-2 0.015149
[1604]cdat 1602  gc:-2 0.015224
[1605]cdat 1603  gc:-2 0.015317
[1606]cdat 1604  gc:-2 0.015380
[1607]cdat 1605  gc:-2 0.015513
[1608]cdat 1606  gc:-2 0.015421
[1609]cdat 1607  gc:-2 0.013009
[1610]cdat 1608  gc:-2 0.015586
[1611]cdat 1609  gc:-2 0.013025
[1612]cdat 1610  gc:-2 0.009968
[1613]cdat 1611  gc:-2 0.012802
[1614]cdat 1612  gc:-2 0.015206
[1615]cdat 1613  gc:-2 0.013571
[1616]cdat 1614  gc:-2 0.010078
[1617]cdat 1615  gc:-2 0.013467
[1618]cdat 1616  gc:-2 0.011040
[1619]cdat 1617  gc:-2 0.008677
[1620]cdat 1618  gc:-2 0.013720
[1621]cdat 1619  gc:-2 0.008645
[1622]cdat 1620  gc:-2 0.016253
[1623]cdat 1621  gc:-2 0.013690
[1624]cdat 1622  gc:-2 0.010371
[1625]cdat 1623  gc:-2 0.016220
[1626]cdat 1624  gc:-2 0.016234
[1627]cdat 1625  gc:-2 0.013284
[1628]cdat 1626  gc:-2 0.016230
[1629]cdat 1627  gc:-2 0.016302
[1630]cdat 1628  gc:-2 0.013344
[1631]cdat 1629  gc:-2 0.013923
[1632]cdat 1630  gc:-2 0.014303
[1633]cdat 1631  gc:-2 0.011076
[1634]cdat 1632  gc:-2 0.016218
[1636]cdat 1634  gc:-2 0.016113
[1637]cdat 1635  gc:-2 0.016295
[1638]cdat 1636  gc:-2 0.011313
[1639]cdat 1637  gc:-2 0.011073
[1640]cdat 1638  gc:-2 0.009382
[1641]cdat 1639  gc:-2 0.015344
[1642]cdat 1640  gc:-2 0.013728
[1643]cdat 1641  gc:-2 0.011338
[1644]cdat 1642  gc:-2 0.012676
[1645]cdat 1643  gc:-2 0.016255
[1646]cdat 1644  gc:-2 0.016330
[1647]cdat 1645  gc:-2 0.011304
[1648]cdat 1646  gc:-2 0.012836
[1649]cdat 1647  gc:-2 0.016026
[1650]cdat 1648  gc:-2 0.013793
[1651]cdat 1649  gc:-2 0.011195
[1652]cdat 1650  gc:-2 0.015942
[1653]cdat 1651  gc:-2 0.013636
[1654]cdat 1652  gc:-2 0.013275
[1655]cdat 1653  gc:-2 0.013769
[1656]cdat 1654  gc:-2 0.015110
[1657]cdat 1655  gc:-2 0.010577
[1658]cdat 1656  gc:-2 0.016374
[1659]cdat 1657  gc:-2 0.011284
[1660]cdat 1658  gc:-2 0.010566
[1661]cdat 1659  gc:-2 0.015398
[1662]cdat 1660  gc:-2 0.015214
[1663]cdat 1661  gc:-2 0.012801
[1664]cdat 1662  gc:-2 0.007925
[1665]cdat 1663  gc:-2 0.014823
[1666]cdat 1664  gc:-2 0.012664
[1667]cdat 1665  gc:-2 0.012927
[1668]cdat 1666  gc:-2 0.007893
[1669]cdat 1667  gc:-2 0.013443
[1670]cdat 1668  gc:-2 0.015582
[1671]cdat 1669  gc:-2 0.000908
[1672]cdat 1670  gc:-2 0.009900
[1673]cdat 1671  gc:-2 0.013594
[1674]cdat 1672  gc:-2 0.015531
[1675]cdat 1673  gc:-2 0.010952
[1676]cdat 1674  gc:-2 0.013435
[1677]cdat 1675  gc:-2 0.013549
[1678]cdat 1676  gc:-2 0.008466
[1680]cdat 1677  gc:-3 0.019645
[1680]cdat 1678  gc:-2 0.002917
[1681]cdat 1679  gc:-2 0.008503
[1682]cdat 1680  gc:-2 0.016072
[1683]cdat 1681  gc:-2 0.011123
[1684]cdat 1682  gc:-2 0.003675
[1685]cdat 1683  gc:-2 0.013604
[1686]cdat 1684  gc:-2 0.015596
[1687]cdat 1685  gc:-2 0.016052
[1688]cdat 1686  gc:-2 0.015212
[1689]cdat 1687  gc:-2 0.016168
[1690]cdat 1688  gc:-2 0.011074
[1691]cdat 1689  gc:-2 0.013681
[1692]cdat 1690  gc:-2 0.013463
[1693]cdat 1691  gc:-2 0.011137
[1694]cdat 1692  gc:-2 0.011156
[1695]cdat 1693  gc:-2 0.000906
[1696]cdat 1694  gc:-2 0.009721
[1697]cdat 1695  gc:-2 0.016065
[1698]cdat 1696  gc:-2 0.010847
[1699]cdat 1697  gc:-2 0.008499
[1700]cdat 1698  gc:-2 0.015868
[1701]cdat 1699  gc:-2 0.013527
[1702]cdat 1700  gc:-2 0.012817
[1703]cdat 1701  gc:-2 0.013946
[1704]cdat 1702  gc:-2 0.015312
[1705]cdat 1703  gc:-2 0.016129
[1706]cdat 1704  gc:-2 0.016215
[1707]cdat 1705  gc:-2 0.001235
[1708]cdat 1706  gc:-2 0.016209
[1709]cdat 1707  gc:-2 0.016298
[1710]cdat 1708  gc:-2 0.016262
[1711]cdat 1709  gc:-2 0.006192
[1712]cdat 1710  gc:-2 0.015423
[1713]cdat 1711  gc:-2 0.015889
[1714]cdat 1712  gc:-2 0.013694
[1715]cdat 1713  gc:-2 0.013802
[1716]cdat 1714  gc:-2 0.013334
[1717]cdat 1715  gc:-2 0.011154
[1718]cdat 1716  gc:-2 0.016351
[1719]cdat 1717  gc:-2 0.016319
[1720]cdat 1718  gc:-2 0.002903
[1721]cdat 1719  gc:-2 0.015321
[1722]cdat 1720  gc:-2 0.013337
[1723]cdat 1721  gc:-2 0.013783
[1724]cdat 1722  gc:-2 0.016235
[1725]cdat 1723  gc:-2 0.016357
[1726]cdat 1724  gc:-2 0.015293
[1727]cdat 1725  gc:-2 0.016391
[1728]cdat 1726  gc:-2 0.012899
[1729]cdat 1727  gc:-2 0.011115
[1730]cdat 1728  gc:-2 0.015705
[1731]cdat 1729  gc:-2 0.013571
[1732]cdat 1730  gc:-2 0.013652
[1733]cdat 1731  gc:-2 0.013832
[1734]cdat 1732  gc:-2 0.015658
[1735]cdat 1733  gc:-2 0.013765
[1736]cdat 1734  gc:-2 0.010355
[1737]cdat 1735  gc:-2 0.015423
[1738]cdat 1736  gc:-2 0.012726
[1739]cdat 1737  gc:-2 0.005048
[1740]cdat 1738  gc:-2 0.015540
[1741]cdat 1739  gc:-2 0.010319
[1742]cdat 1740  gc:-2 0.007640
[1743]cdat 1741  gc:-2 0.002646
[1744]cdat 1742  gc:-2 0.010272
[1745]cdat 1743  gc:-2 0.020515
[1746]cdat 1744  gc:-2 0.015403
[1747]cdat 1745  gc:-2 0.012900
[1748]cdat 1746  gc:-2 0.007992
[1749]cdat 1747  gc:-2 0.015303
[1750]cdat 1748  gc:-2 0.010310
[1751]cdat 1749  gc:-2 0.007921
[1752]cdat 1750  gc:-2 0.012557
[1753]cdat 1751  gc:-2 0.015826
[1754]cdat 1752  gc:-2 0.016052
[1755]cdat 1753  gc:-2 0.011077
[1756]cdat 1754  gc:-2 0.013468
[1757]cdat 1755  gc:-2 0.016045
[1758]cdat 1756  gc:-2 0.016096
[1759]cdat 1757  gc:-2 0.011004
[1760]cdat 1758  gc:-2 0.015371
[1761]cdat 1759  gc:-2 0.011178
Shutting down the server
savegame/game_exit_20221230-183937-lev150.txt - saved
logs/20221230-183937-[150][m36].txt saved

C:\pm>







so how to combine those two numbers


and do they even still make sense?


Now, if I get one I can assume by the time it gets added it will be the next frame...
or this frame because by the time it is processed the frame has incremented

so when I get one that says -2 on frame 1730 for example...
that mean the cdat is for 1728, 2 frame ago...


now that the start of frame timer can be trusted, I should use that to go back and find out exactly when the packet arrived in relation to the frame start.

then I can make a composite number of how late it is...

WAN

[244]cdat 242  gc:-2 0.016242 -33.757700ms
[245]cdat 243  gc:-2 0.013527 -36.472500ms
[246]cdat 244  gc:-2 0.001073 -48.926800ms
[247]cdat 245  gc:-2 0.013675 -36.325100ms
[248]cdat 246  gc:-2 0.008515 -41.484700ms
[249]cdat 247  gc:-2 0.013653 -36.346700ms
[250]cdat 248  gc:-2 0.003773 -46.226500ms
[251]cdat 249  gc:-2 0.013406 -36.593600ms
[252]cdat 250  gc:-2 0.013678 -36.322400ms
[253]cdat 251  gc:-2 0.013635 -36.364900ms
[255]cdat 252  gc:-3 0.018778 -56.222400ms
[256]cdat 253  gc:-3 0.013594 -61.405500ms
[256]cdat 254  gc:-2 0.013532 -36.468100ms
[257]cdat 255  gc:-2 0.013844 -36.155600ms
[258]cdat 256  gc:-2 0.008631 -41.369000ms
[259]cdat 257  gc:-2 0.011310 -38.690000ms
[260]cdat 258  gc:-2 0.013817 -36.183400ms
[261]cdat 259  gc:-2 0.012976 -37.023800ms
[262]cdat 260  gc:-2 0.006389 -43.610600ms
[263]cdat 261  gc:-2 0.011331 -38.669100ms
[264]cdat 262  gc:-2 0.013452 -36.548300ms
[265]cdat 263  gc:-2 0.003223 -46.777400ms
[266]cdat 264  gc:-2 0.008756 -41.244300ms
[267]cdat 265  gc:-2 0.011006 -38.994200ms
[268]cdat 266  gc:-2 0.016051 -33.949000ms
[269]cdat 267  gc:-2 0.013857 -36.143100ms
[270]cdat 268  gc:-2 0.008706 -41.294100ms
[271]cdat 269  gc:-2 0.011205 -38.794700ms
[272]cdat 270  gc:-2 0.013796 -36.204100ms
[278]cdat 276  gc:-2 0.006955 -43.044900ms



LAN 10ms

[352]cdat 351  gc:-1 0.012526 -12.474100ms
[353]cdat 352  gc:-1 0.011416 -13.583900ms
[354]cdat 353  gc:-1 0.012495 -12.505200ms
[355]cdat 354  gc:-1 0.012518 -12.481800ms
[356]cdat 355  gc:-1 0.011462 -13.538200ms
[357]cdat 356  gc:-1 0.013423 -11.577100ms
[358]cdat 357  gc:-1 0.013426 -11.573700ms
[359]cdat 358  gc:-1 0.012400 -12.599700ms
[360]cdat 359  gc:-1 0.012547 -12.453300ms
[361]cdat 360  gc:-1 0.013429 -11.570900ms
[362]cdat 361  gc:-1 0.012374 -12.626400ms
[363]cdat 362  gc:-1 0.013445 -11.554800ms
[364]cdat 363  gc:-1 0.013457 -11.543500ms
[365]cdat 364  gc:-1 0.012394 -12.606000ms
[366]cdat 365  gc:-1 0.012999 -12.001300ms
[367]cdat 366  gc:-1 0.012964 -12.036300ms
[368]cdat 367  gc:-1 0.011328 -13.672500ms

LAN 2ms

[573]cdat 572  gc:-1 0.021599 -3.400600ms
[574]cdat 573  gc:-1 0.021587 -3.412900ms
[575]cdat 574  gc:-1 0.020520 -4.480400ms
[576]cdat 575  gc:-1 0.020883 -4.117200ms
[577]cdat 576  gc:-1 0.021548 -3.452300ms
[578]cdat 577  gc:-1 0.020530 -4.470000ms
[579]cdat 578  gc:-1 0.021555 -3.445200ms
[580]cdat 579  gc:-1 0.021530 -3.469900ms
[581]cdat 580  gc:-1 0.020455 -4.545000ms
[582]cdat 581  gc:-1 0.021507 -3.493000ms
[583]cdat 582  gc:-1 0.021511 -3.489000ms
[584]cdat 583  gc:-1 0.019713 -5.286600ms
[585]cdat 584  gc:-1 0.021510 -3.490400ms
[586]cdat 585  gc:-1 0.021510 -3.489900ms
[587]cdat 586  gc:-1 0.020450 -4.550300ms
[588]cdat 587  gc:-1 0.021512 -3.488100ms



I want to have server stats on cdat_rx time
tally for 1s and do average and max min
same for late cdats

OK I have done that...big surprise...nothing seems to effect when cdats are received on server, except for client dsync....


the only thing I can do to get cdats to the server faster, would be to let the client move ahead of the server in time....
but then the client would always get difs that were too late to apply....

what if I let the client rewind?
and apply the local moves from the last frame?

that would mean I would have to keep the clients local moves...it would only be one move per frame max...

this is just crazy enough to maybe work.....

client stores all its game moves in it's own local array....
when client get a dif that is in the past:
apply then play back to current...



right now I have the server in the lead, the client lags behind just enough so I can get the current state from the server and apply it.
If I let the client pass the server, the server will be able to get cdats with less delay, but who knows what else might happen??

I think it's worth a try....

1 - make client put stuff in its own local game_moves array

2 - remove the part in rx stdf where we ignore late difs

3 - modify apply dif to allow late ones

this is a tricky bit of code here....

   // check to see if frame_nums match and its time to apply dif or if initial state when frame_num == 0
   if ((frame_num != client_state_dif_dst) && (frame_num != 0))
   {


first of all if the match then do it
second of all if frame_num == 0 do it
third of all...
if newer than last applied dif....

what is the varaible for the last applied dif frame_num? 'client_state_base_frame_num'

so check if the dest of the dif_dest on deck is newer than that

if (client_state_dif_dst > client_state_base_frame_num) // we have dif with a newer dest than previous

omg I am ready to try it....

well it looks like I can run a game succesfully with negative sync... lets try it on WAN


client has all been put back together nicely...
still to do on client
look into chase multiplier...seems to work good but I have not examined it
automatically set chase amount, but based on what?
should it be a sliding scale, or a fixed number?

on server I have issues if I try to lower s1
raising it is OK but when I lower it, server becomes unresponsive and will not accept new connections

show more about the clients on the server...but what and why??

profile using timestamps certain functions...

move
draw
rewind
send stdf
receive packets

move packetbuffer code and functions to packet file


testing...making the client -40 seemed to make the game a lot smoother....


calculate and show ping on client and server...


server tx ping from 'loop' with current time

client rx ping and tx pong with passed time and current time

server rx pong
calc rt
return passed ts in pang

client rx pang
calc rt


ok now where to store it...

player1
   double ping;

put it on the bottom for client

in server it will be part of debug array



flush client and server on level done


when does client show red...removed

how about auto setting clients offset to ping....

but I would need to get an average ping
I only read it every 2s

how about reading it one per second and keep a 10s rolling average....

at the start of when a client joins
use default of zero to start...
get 8 pings in 2s for avg then use that to adjust
then do the rolling replace one every 2 sec

is this overkill...maybe...

but just blindly plugging one ping into offset is bad also

should have some limits....
+20 absolute max, why would you even want to go positive?
-50 to -80 somehwere around there for the min need to test...




try experimenting with different s1 and s2
3 1 - default

I'm getting late cdats and stuff from 4230's but not scat or e6430
the sync on them is jumping around a lot...
I could probably benefit from some code profiling....


20221231 9:26 AM

make the client initiate ping, as it is the one that needs it.
where?
how about from a timer?
too complex, just do it like the server does...
done...

now make way for client to do more right after join...

how about make the cyclic buffer of ping to average first....

then make a method to add new pings

then make a way that the average is calultaed

then make a way that when the buffer is not full, its pings mopre often...

struct ping_buffer

int num_filled;
int new_index;
double ping[8];
double avg;

initially:
num_filled = 0;
index = 0;
all are 0;

as added:
num_filled++
index++

num_filled can be greater than index

when doing avg

loop and add from 0 to num filled, or max if full

then divide and set avg...


do I need to do it in a struct? probably not the besy way...

double ping_array[8];
double ping_avg;
int    ping_num_filled;
int    ping_index;

make a new file ping_buffer.cpp

clear in client init..done

now make a function to add...done...

now where am I going to save this?

player1

ping_avg

ok that's done...now make it run faster until filled...

done...

now maybe toss out the highest and lowest for average....

experiment with different values of s1 and s2

right now I have been using 3 and 1

re do the client sync graph for the server, especially since I now use dsync

what did I use before?

stak packet on server prints this log line:

sprintf(tmsg1, "rx stak sync:[%d] chase:[%d] ack_fn:%d cli_fn:%d", players1[p].server_sync, players1[p].client_chase_fps, ack_frame_num, client_frame_num );

[30][1][318]rx stak sync:[1] chase:[39] ack_fn:316 cli_fn:317 set new base

I want to add dsync and remove unneeded things...why do I have 2 fn that are always the same??

change client_chase_fps to double from int....

its main use is to get back to the server to be displayed

OK I have parsed it from the log lines in graph...

but the problem is that the data for the graph is an integer array....

for now, multiply by 10...

redo sync to display in ms

I can come back to this later....
when I get this done I can examine chase better.....

OK, Ive been thinking...
I want to make the tag parsing thing a separate function...done
replaced 8-10 calls

Also this sync graph would probably be better on the client.

The server only has data when it receives stak....

what can I do to make the graph look better??

it is not frames anymore, but ms...

better....

can I auto range based on the data shown?...yes...

my stak log line can bee too long

[30][3][500]rx stak syn:[4] dsy:[12405.5] chs:[70.0] afn:496 cfn:496 failed to set base! cl:499

[30][4][6180]rx stak syn:[-2] dsy:[-113.3] chs:[31.7] afn:6177 cfn:6182 failed to set base! cl:6179
[30][3][6182]rx stak syn:[-2] dsy:[-104.8] chs:[33.0] afn:6179 cfn:6184 failed to set base! cl:6181
[30][4][6182]rx stak syn:[-2] dsy:[-104.6] chs:[32.6] afn:6177 cfn:6184 failed to set base! cl:6181
[30][2][6183]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6185 failed to set base! cl:6181
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183


failed to set base! cl:6183
change to
fail base set:6183

saved 9 char

more:
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183

[30][2][6184]rx stak s[-2] d[-100.0] c[33.0] af:6179 cf:6186 fail set base:6183

saved 20 char



can I make some buttons in graphs?  at the top of the legend scale lock or autorange..
auto/manual
manual +/-



I really want to make the graphs simpler...

wouldn't it be nice to have a common function for all of them?

they all seem to have common x axis...frames, seconds, minutes, etc.....


what is the data needed to describe a graph?

screen coordinates x1, y1, x2, y2, w, h
these are in the standard computer screen format: x1,y1 is upper left corner

graph x axis
start and end data values

graph y axis
start and end data values

can get range from these.

an array of data used to plot points on the graph

data[][0] = x
data[][1] = y

can I make this an object?

why?

so it encaspulates it's own data and methods

I will call it to draw itself
optionally draw legends and gridlines
process mouse input on the graph

class mw_graph

make a new file and lets do this....


I don't get why I am having such a hard time mapping one range to another....
am i doing the wrong things??
I don't need to map the data range to the axis range!
I need to map the axis range to the screen range!!!!

   double xm = screen_w / x_axis_rng;
   double ym = screen_h / y_axis_rng;

   for (int i=0; i<data_points; i++)
   {
      float x = screen_x1 + (data[i][0]-x_axis_min) * xm;
      float y = screen_y2 - (data[i][1]-y_axis_min) * ym;
      al_draw_rectangle(x, y, x+1, y+1, palette_color[10], 1);
   }


now what??

should I put some mouse_controls in?
yes...

ist show mouse...

2nd show mouse position and convert to values...

this will mean I have to call this in a loop and process event queue....

done...
now I want an autoscale button
one for x and y and one for each also...

done...


what now?

can you do a nice title...

set a minimum x axis range....

butttons for nice axis management:
auto/manual
of just auto button
+ and - to adjust scale
for each min and mix??

not sure if this will be that usefull

implement mouse_drag...
x only or x and y?
can you set a scale conevrsion varaible for x axis and y axis
do it on the fly..it was easy...
mouse drag works beautifully




            // graph position under mouse (mx1) needs to stay the same

            // change range?? then find min and max to ensure same pos??


            // what if i calulated scaler, then changed that, then worked backwards from there
//            double x_scaler =  x_axis_rng / screen_w;
//            x_scaler *= 1.1;
//            x_axis_rng = x_scaler * screen_w; // convert range back

            // now how do I adjust min so that current pos is the same

            // old distance from current pos to min * scaler  ????

//
//            // old distance from curent position to min
//            double old_offset = mx1 - x_axis_min;
//
//            printf("old_offset:%f\n", old_offset);
//
//
//            // get original scale
//            double x_scaler =  x_axis_rng / screen_w;
//
//            printf("orignal_scale:%f\n", x_scaler);
//
//
//
//            // change scale
//            x_scaler *= 1.1;
//
//
//            printf("new_scale:%f\n", x_scaler);
//
//
//            printf("old range:%f\n", x_axis_rng);
//
//            // convert range
//            x_axis_rng = x_scaler * screen_w;
//
//            printf("new range:%f\n", x_axis_rng);
//
//
//
//            printf("old offset:%f\n", old_offset);
//
//            // scale to new
//            double new_offset = old_offset * 1.1;
//
//
//            printf("new offset:%f\n", new_offset);
//
//
//
//            printf("old min:%f\n", x_axis_min);
//
//            // set min from original position and new offset
//            x_axis_min = mx1 - new_offset;
//
//
//            printf("new min:%f\n", x_axis_min);
//
//            // set max1
//            x_axis_max = x_axis_min + x_axis_rng;
//
//
//


            double old_offset = mx1 - x_axis_min;     // old distance from curent position to min
            double new_offset = old_offset * 1.1;     // scale to new
            x_axis_min = mx1 - new_offset;            // set min from original position and new offset
            x_axis_rng *= 1.1;                        // convert range
            x_axis_max = x_axis_min + x_axis_rng;     // set new max


holy shit that is beautiful!!

mouse drag (x axis)
mouse wheel zoom (x axis)
mouse drag zoom in (x and y axis)

do something about mouse drag when off screen, clamp to edges done...

try y drag move...awesome...

try y zoom wheel...wicked...

now if I added lock buttons on the x and y axis to prevent this

will it lock both scroll and zoom??

for x axis

zoom lock..


I want scroll bars...

do an x one first


I think I am readt to start thinking about some limits....

limit the axis ranges....

make all changes to the axis ranges go through a common function so limit will only need to be tested once
done...
it works, but seems a little weird when drag turns into resize...
drag normally moves both start and end
if one does not move, it turns into a resize...
the alternative would be to do nothing, no drag move allowed if it would change range

I can live with it for now...


now make some ways to drag the scroll bar...

make scrollbar variables part of class...done

int x_axis_scrollbar_x1;
int x_axis_scrollbar_x2;
int x_axis_scrollbar_w;

int x_axis_scrollbar_bar_x1;
int x_axis_scrollbar_bar_x2;

int x_axis_scrollbar_y1;
int x_axis_scrollbar_y2;

moved draw into its own function


figure out the offset...data does not start till 40...done...


now I have 5 ways to adjust the scroll bar with the mouse and its looking pretty good...

sometimes I can adjust past data max and stuff breaks...
a_axis min can be more the max...this should not happen...

there is some chicken and egg things going on with enforce limits...

testing for min max
testing for wrong order

I need to test both min and max to see if they are in range

I also want to add another test...minimum range...

I should find the smallest difference between x values and make the minum range 10 of those...

for now, lets just set a static value and test..

if both max and min are stuck near the top separate them by minimum range...

this all looks good...

now I want to do some y ranging


   bool x_axis_lock_scroll;
   bool x_axis_lock_zoom;

   bool y_axis_lock_scroll;
   bool y_axis_lock_zoom;
   bool y_axis_lock_auto_zoom;



y_axis_lock_zoom
done for drag rect and mouse wheel
not done for drag scroll...still changes zoom...fixed

y_axis_lock_scroll

y_axis scrollbars

y axis is reversed, which poses some issues
how am I going to deal with that? at what point do I flip the axis...
x1 is smaller than x2 when drawing on the screen
but when the mouse moves they are oppposite...
make the data reveser
y2 is min, y1 is max...
im thinking of doing it all upside down...
y1 is lower

I just made the scrollbar y1 and y2 reversed....

I have implemented all scrollbar functionality to y scroll bar...
make the highlight look better, align better, color, size, different mouse_pointer....done...



now back to the locking...

enforce zoom lock on y scroll bar..done...


what does it mean if scroll is locked and zoom is not? does that even make sense??
it could mean that the x_min is locked, but not x_max and scroll


can change   min max rng
no lock       1   1   1
zl            1   1   0
sl            0   1   1
zl + sl       0   0   0


what about autoscale y depending on what is on screen

what if I made zoom_lock have 3 values

0 off
1 lock
2 auto

rignt click on axis or scrollbar for options..

mouseover text ...

mouse crosshairs

jump to nearest data position and show data for that...

I want a way to store the units for each axis...
call a fucntion to set msg

right click on stuff to popup menu....done


20230103 back to work...

what are the main things left to do on graph?

units, axis labels, gridlines

nice bounding boxes for all the graph elements
(optional) title and (optional)space for it (probably above but not married to it)

y axis labels (could be on left or right side)
y axis scrollabr (left or right)

x axis labels (could be on top or bottom)
x axis scrollabr (could be up or down)

all of these things are optional

reset range should turn auto off....

need to stack things on the axis...

gridlines and labels
axis label
scrollbar
these should all dynamically size...
then when that is all done, I will have the size of the entire graph area
maybe I can rename that to graph_x y etc... and the other to plot...

graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

these are the main ones that are set outside the class....
then after the width of all the things in the axes are calculated...
then what is left over will be for the plot

call resize at the beginning....

these will never be changed internally:
graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

find out the width needed for axes...

set:
plot_x1
plot_y1
plot_x2
plot_y2
plot_w
plot_h





make a function to auto set positions... for each axis...

void x_axis_draw(void) // does gridlines, labels, axis title and scroll bars

int x_axis_get_size(void) // returns the size needed by x_axis


start with gridlines and labels...
make them all optional




I now have:

void x_axis_draw(void);
void x_axis_get_size(void);
void x_axis_draw_legend(void);
void x_axis_draw_gridlines_and_labels(void);
int  x_axis_draw_scrollbar(void);
void x_axis_proc_scrollbar(void);


called from main draw:

void mwGraph::x_axis_draw(void)
{
   x_axis_draw_gridlines_and_labels();
   x_axis_draw_legend();
   x_axis_draw_scrollbar();
}


I also have:

void mwGraph::process_input(void)
{
   x_axis_proc_scrollbar();

which also calls:

void mwGraph::x_axis_proc_scrollbar(void)
{
   int sb = x_axis_draw_scrollbar();


how are draw and proc called?
like this externally:
mG[0].draw();
mG[0].process_input();

I will probabaly change that later, do I really need to separarte them?

for now I have other things to do:

get the variables for each x_axis element done


int x_axis_label_draw_on;
int x_axis_label_tick_size;
int x_axis_label_text_size;
int x_axis_label_draw_size;



1st get axis sizes
2nd set plot size and pos
3rd set axis pos

do I need a spearate value for actual size, vs stored size
so I can restore if turned on and off...

I think the x axis is looking really good...now work on the y axis

I am very happy with how these look

next I want to have the option of small text on legends
done and now I have a much nicer method for drawing those...


next, I want to always put labels on origins...

done, but sometimes overwrite other axis labels..



make a function to display axis values...

why can't I put mouse on point on the edge of plot?? fixed
also fixed when point text box is draw off screen...

implment units for axis...

x_axis_value_type..

0 = none
1 = time in frames...

this will have a large impact...

depending on the current displayed range,
the units for an axis will change..

the max value displayed could be used to set the units in some cases...n other cases the range...

like for time (frames)
could be frames, sec, minutes...
depending on what range is shown

this will change:
x axis legend
gridlines and labels
point text box...

I need a main title for the legend:
Time
then I need another for units

I could make a type...

type 0 - do nothing
type 1 - customized for frames

made a type..


if 1, where do I check it??

depending on the range I need to set units, divider and legend

where does that naturally happen?
draw
set size and pos
input

none of these actually

how about enforce axis limits?


and what am I going to be setting?

if type 1
use range to set
legend text
divider
units text

add divider...


----------------------

make labels also able to have font
start with x..done
and also reduce space between labels and legend..done

now do y...done...


it gets kind of messy at the origin when I draw labels there that conflict with the auto ones...and the x and y sometimes confict too...

remove x, keep y.. actually fixed origin still conficts with auto...remove (comment out) both for now...








I am happy with this


should I try it on some real data??

what would happen if I tried more data? like a real bandwidth graph...


what if I made the array larger, to include more players


or I could put them all in the main array but tag them with different series...

or I could make an entirely new graph and overlay the data...

all these things I am thinking of would have a common x axis...

should I try to put everything in one array and tag it by series?
or should I have multiple arrays?

with any method, I need to make sure the data is in order



how about a three dimensional array

point[series][x][y]


I want an int for series and doubles for the other two..

looks like a structure

max needed would be 16 if I do 8tx and 8rx



each instance of my class will get this:


struct data_seri
{
   double data[10000][2];
   int num_data;
   int active;
   int color;
   char name[1024];
};
data_seri series[20] = {0};

use like this:
series[0].data[i][0]

wow! that was surpisingly easy to get 8 tx rate lines...

next I need a series legend and the ability to toggle series on and off while the graph is running...

I want to be able to have many other things shown as well...


when setting unlocked, make sure to set autrange off also...

I want to make a nice gui setup for changing things....

like a page of toggles and checkmarks...

maybe some sliders and buttons too..

show legend like:

series number - series name - show the color and line style - click to toggle

bug--scrollbar does not like negative data

removed clear screen from calling loop, handle it internally

I am calling axis_get_size_and_arrange_pos() externally every loop, do I need to?..yes
so call it internally then...
from draw, or proc input?  proc input...

now I only call 3 things externally and one is only in case the user resized the screen...

mG[0].set_graph_pos(0,0, SCREEN_W, SCREEN_H/2-10);
mG[0].draw();
mG[0].process_input();

now back to showing legend for multiple series.......



figure out how to draw dashed line...

https://www.allegro.cc/forums/thread/615463
https://www.allegro.cc/forums/thread/615415



It looks like I can only do al_draw_soft_line on a bitmap, drawing directly to the backbuffer has weird results

so lets try to figure out hpw to do that...


make a bitmap the same size as graph

now make all my draw stuff draw on that, but all coordinates will need to be adjust to 0,0 for graph_x and y

there were surprisingly few references to those..mostly in adjust x amd y axis...

now that I am drawing onto a bitmap instead of the backbuffer, the drawing looks a lot blockier...yay! :(
text looks fine, but the high level primitives (lines) suck...

the gridlines are terriblly blocky and missing in places...

what a goddamn hassle to try to draw dashed lines

there is no godamn reason for it...



how hard would it be to revert now?
and either:
- only draw the plot lines on its own bitmap, or
- figure out how to use soft lines with backbuffer

reverted...

try to figure out how to use soft lines with backbuffer

- does soft line return x and y that make sense?? yes...


if I store all the x and y in an array then draw them outside the function that seems to work...go fig...





now how im I going to implement this?

ideally I would like to call something very similar to draw_line

al_draw_line(100, 110, 200, 110, palette_color[15], 1);
mw_draw_line(100, 110, 200, 110, col1, col2);


here it is:

int mw_p[10000][2] = {0};
int mw_i = 0;

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t state, int x, int y)
{
   if (mw_i < 10000)
   {
      mw_p[mw_i][0] = x;
      mw_p[mw_i][1] = y;
      mw_i++;
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, int c1, int c2)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   mw_i = 0;
   al_draw_soft_line(&v1, &v2, (uintptr_t)NULL , mw_FirstFunction , mw_StepFunction , mw_DrawFunction);

   int cycle = 0;
   for (int i=0; i<mw_i; i++)
   {
      int x = mw_p[i][0];
      int y = mw_p[i][1];

      int c = c1;
      if ((cycle % 8) < 4) c = c2;
      cycle++;

//      al_draw_filled_circle(x, y, 1, palette_color[c]);
      al_draw_filled_rectangle(x-0.5, y-0.5, x+0.5, y+0.5, palette_color[c]);

//   printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
      //al_put_pixel(p[i][0], p[i][1], palette_color[p[i][2]]);
   }
}


I am thinking about doing it slightly different...

make my array contain only line segements of the same color

then use the regular al_draw_line to draw those segments...

then I would have less draw calls, and I could use the thickness of lines


values to send to draw:
cycle total
cycle 0 col (default color)

// cycle & total < val color = c1
cycle 1 val
cycle 1 col

8, 15, 4, 10

then when drawing, draw 1 to 0, 2 to 1...etc...

I have it all implemented except for the thinning of call to al_draw_line
it would make it more complicated and im not sure it is needed...

not that complicated

now I need to ensure the last point is not skipped...


int mw_p[10000][3] = {0};
struct mw_state
{
   int num_points;
   int cycle_total;
   int cycle_tally;
   int default_color;
   int c1_val;
   int c1_col;
   int c2_val;
   int c2_col;
};

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t ms1, int x, int y)
{
   struct mw_state* ms = (struct mw_state*) ms1;
   if (ms->num_points < 10000)
   {
      // get color from cycle
      int col = ms->default_color;
      int mod = ms->cycle_tally++ % ms->cycle_total;
      if (mod < ms->c1_val) col = ms->c1_col;
      if (mod < ms->c2_val) col = ms->c2_col;

      // always set these, in case we get to the end and the point is skipped beacuse of duplicate colors
      mw_p[ms->num_points][0] = x;
      mw_p[ms->num_points][1] = y;

      // should i add this point?
      if ((ms->num_points == 0) || (col != mw_p[ms->num_points-1][2])) // if first point, or color different from previous
      {
         mw_p[ms->num_points][2] = col;
         ms->num_points++;
      }
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, float thickness, int cycle_total, int default_color, int c1_val, int c1_col, int c2_val, int c2_col)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   struct mw_state ms;
   ms.num_points = 0;
   ms.cycle_total = cycle_total;
   ms.default_color = default_color;
   ms.c1_val = c1_val;
   ms.c1_col = c1_col;
   ms.c2_val = c2_val;
   ms.c2_col = c2_col;

   al_draw_soft_line(&v1, &v2, (uintptr_t)&ms, mw_FirstFunction, mw_StepFunction, mw_DrawFunction);

   // ensure last point was not skipped, due to duplicate color
   mw_p[ms.num_points][2] = mw_p[ms.num_points-1][2];
   ms.num_points++;


   for (int i=1; i<ms.num_points; i++)
   {
      int x1 = mw_p[i-1][0];
      int y1 = mw_p[i-1][1];
      int x2 = mw_p[i][0];
      int y2 = mw_p[i][1];
      int c =  mw_p[i][2];
      al_draw_line(x1, y1, x2, y2, palette_color[c], thickness);
      //printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
   }
}

that was the final iteration...now try it in action!!

see how long it takes...
it is literally 1000 times slower....

plot time: 0.000210   lines drawn:152
plot time: 0.227604   lines drawn:156

I commented out the drawing part...
its not the drawing part, its the call to soft line...

this is useless, but at least now I know it

I just wasted 6 hours on this...

can I make my own code that will do it better?


pass it 2 vertexes
and a span like this:

   int c0_len;
   int c1_col;
   int c1_len;
   int c1_col;

it will create an array of points

point 0 = vertex 1
next point

what math will you use?

total x span
total y span
total length

length of span / color_span = divider

divide xspan and yspan by divider to get incs

do incs and add vertex points...

this is my first hacked together implementaion and it works...
before I go any further, speed test it....


void mw_draw_line2(int x1, int y1, int x2, int y2, float thickness)
{
   int color_span = 10;

   double line_xspan = x2-x1;
   double line_yspan = y2-y1;
   double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

   double div = line_span / color_span; // number of spans

   double xinc = line_xspan / div;
   double yinc = line_yspan / div;

   int xa = x1;
   int ya = y1;

   int xb = xa+xinc;
   int yb = ya+yinc;


   int c = 15;

   while (xa < x2)
   {
      al_draw_line(xa, ya, xb, yb, palette_color[c], thickness);
      if (c == 15) c = 10;
      else if (c == 10) c = 15;
      xa+=xinc;
      ya+=yinc;
      xb+=xinc;
      yb+=yinc;
   }
}


plot time: 0.000283   lines drawn:156


I'm back baby! as proof of concept it works and is just as fast as the al_draw_line...

now clean it up....

what if I kept the remainder of the color shift for the next line, that would make the graph look awesome...

I could keep a static int 'distance travelled' and use mod for the cycling repeats

3 colors, just like last one

this will mean a major rewrite of how I do the getting of lines..

it is so simple now because the span is always the same

8 red
3 blue
4 yellow


get inc from main period (14)
get inc from main to 2   (3)
get inc from 2 to 3      (4)

distance_travelled

start with the args...
 int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col))

I have a beautiful three color version working, but no carry over for color shift

plot time: 0.000990   lines drawn:156
plot time: 0.000983   lines drawn:156
plot time: 0.000986   lines drawn:156

now it takes almost 1ms...should I be worried?

it depends on how small the color line segments are


now how will i make this work in the plot? how will I keep track of color?

negative values for color?

2 values for color?

if second one is 0 just draw normally






if (series[s].color2 == 0) al_draw_line(ox, oy, x, y, palette_color[series[s].color1], 1.0);
else                       mw_draw_line(ox, oy, x, y, 1.0, 8, series[s].color1, 10, series[s].color2, 0, 0);

wait how??



I think I do want to implement the color shift across lines...when lines are too short, sometimes they dont show at all...


when I zoom in and get more color segments it really slows down...

do all lines draw every time? yes

try thinning....

did the test for x_axis min...works but i want to draw a line to the first offscreen data points

mak a function to get that....

get lowest x and highet x index on screen...
for each series
cycle the dat

that is done...

can I make a way to adjust the color shift span based on size?
I also could make the color shift carry over...

add clicking on series legend....
put series legend in y axis lineup...??
what order? can I assume...

now I want to try the color shift carry over


remainder as a fraction of position in the total color cycle...

maybe there is an easier way...


startxy endxy

get a unit for 1 pixel diagonally converted to x and y

then I can pick any spot on the line and do x,y

then start drawing the line sequence before the actual line

seg1
get ab_positin
static double line_color_offset = 0;
find un


I have finally done it, after much, much work....



20230108 sunday morning

I have the multi-colored line thing working,
the complicated part was the bit where I keep the color sequence going over multiple calls.
this was important so that a graphline made of short segments has a consistant color pattern
and doesn;t just restart the pattern for every line.

to do today...



pop up menu to adjust stuff on series legend, like line size.
config screen that stays overlaid while you change things and see immediate results

move position of mouse over box...done
make only one call to process input and draw
maybe don't redraw every frame, only when changed

when is draw called on its own??
a few times when adjusting things...

when is proc_input called...only externally
added draw to proc_input...seems to work
I still call draw() every frame...

pop up menus...made one for series and cleaned up a bit...

series_legend...

need to make it to fit with all...
series_legend_type
0 autofill
1 8 player array

why does not having at least 1 series initialized cause crash?
range is set to zero and enforce range loops forever
fixed it with an error message if no data
I just need to make sure to set up at least one series when loading data...

or call mG[0].set_series_legend_type(0);
and auto detect...done...

make it so that any arbitrary series can be turned on and off..done...

now do I even need a special mode for type 1...yes...

now on to the big one:
figure out why with short color sequences, especially at the end I have gaps before the first line

what I have discovered is that the color wrap does not work if the end occurs in the first sequence


actually it never works at all...
the next lines always start somwhere in segment 0


where do I use store and use lco?
store it outside the call, the call uses and modifies it

fixing lco made things better...

does not like when c = 0;

when b = 0, it triggers a call to regular line draw..no its when b_col = 0;


trouble shoot c = 0;



in all my checks I am comparing the x and y values separately,
would it not be easier to somehow check the vector...
that is how it is specified...
10 vector units of one color, 5 of another

line is 100 vector pixels

0-9 are one color

10-14 are another

then convert those to x and y at the very last step...

this sounds a lot easier....


I have xa ya xb yb....
I want za and zb, each is just the number of pixels we are on the current line

start:

za = 0; // or previous color shift index
zb = za + c0_val;
do line checks

if (zb < 0)           // off line completely
if (za > line_length) // off line completely

else
if (za<0) adjust za to zero
if (zb>line_length) adjust to line length.

that did not take very long...

test...

c = 0
a = 0
b = 0

all work fine... but the total cannot be zero....
patched into the graph...

now lets make bandwidth graph do its thing

that took like 10 minutes...wow...


now lets do the other one...

client sync actually has 3 graphs...
active
sync
chase

not only that, it has 8 players * 3 graphs

this should be fun...
do three different graphs

0 active
1 sync
2 chase

OK that all works, but now I need to customize the graphs
default values are nice, but I want more control...

like on the active graph, I want to set and lock the y ranges...


now I want to slave the x ranges to a different graph


x_axis_slave

100 slave to 0
101 slave to 1...etc..

where to check...proc x scroll bar...done

now I also need to make sure plot_x1 lines up for all slaved plots...
still need to make these work together


make a copy of original bad method in note then erase it//done

try a version with only 2 colors to see if its faster...less segements by 1/3 but not faster...













/*
original bad mnethod, actually the second....

// returns 1 if end adjust...
int check_and_draw(double x1, double y1, double x2, double y2, double xa, double ya, double xb, double yb, double line_xinc, double line_yinc, int col, float thickness, int &segments_drawn, int &lco)
{
   char t[1024] = {0};
   sprintf(t, "\n");


   int skip = 0;
   int start_adj = 0;
   int end_adj = 0;

   // these checks mean that the segment is entirely not on the line
   if (((line_xinc > 0) && (xb < x1)) || ((line_xinc < 0) && (xb > x1))) skip = 1; // xb before line start
   if (((line_xinc > 0) && (xa > x2)) || ((line_xinc < 0) && (xa < x2))) skip = 2; // xa after line end
   if (((line_yinc > 0) && (yb < y1)) || ((line_yinc < 0) && (yb > y1))) skip = 1; // yb before line start
   if (((line_yinc > 0) && (ya > y2)) || ((line_yinc < 0) && (ya < y2))) skip = 2; // ya after line end

   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (((line_xinc > 0) && (xa < x1)) || ((line_xinc < 0) && (xa > x1))) start_adj = 1; // xa is before line start
      if (((line_yinc > 0) && (ya < y1)) || ((line_yinc < 0) && (ya > y1))) start_adj = 1; // ya is before line start

      if (((line_xinc > 0) && (xb > x2)) || ((line_xinc < 0) && (xb < x2))) end_adj = 1; // xb is after line end
      if (((line_yinc > 0) && (yb > y2)) || ((line_yinc < 0) && (yb < y2))) end_adj = 1; // yb is after line end

      if (start_adj)
      {
         sprintf(t, "start_adj\n");
         xa = x1;
         ya = y1;
      }
      if (end_adj)
      {
         int xlo = abs(x2-xb);
         int ylo = abs(y2-yb);

         if (xlo>ylo) lco = xlo;
         else         lco = ylo;

         sprintf(t, "end_adj - lco:%d\n", lco);
         xb = x2;
         yb = y2;
      }


      printf("%s   drawn at xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f\n", t, xa, ya, xb, yb);


      al_draw_line(xa, ya, xb, yb, palette_color[col], thickness);
      segments_drawn++;



   }

  // if (skip == 2) end_adj = 1;

   return end_adj;
}



int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
  // printf("mw_dl x1:%f y1:%f x2:%f y2:%f\n", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion

   int segments_drawn = 0;

   if (c1_col == 0) al_draw_line(x1, y1, x2, y2, palette_color[c0_col], thickness);
   else
   {
      int color_span = c0_val + c1_val + c2_val;
      printf("\nlco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span

      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_span != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         // one unit of these are one unit of vector move
         double line_xinc = line_xspan / line_span;
         double line_yinc = line_yspan / line_span;

         int section = 0;

         while (!done)
         {
            printf("\nSection:%d\n", section);


            // draw first segment
            double xa = x1 + ((section * color_span) - line_color_offset) * line_xinc; // start position for drawing
            double ya = y1 + ((section * color_span) - line_color_offset) * line_yinc;
            double xb = xa + c0_val * line_xinc;
            double yb = ya + c0_val * line_yinc;

            printf("1st segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
            if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = color_span - c1_val - c0_val - lco;
            }
            if (!done)
            {
               // draw second segment
               xa = x1 + ((section * color_span) - line_color_offset + c0_val) * line_xinc; // start position for drawing
               ya = y1 + ((section * color_span) - line_color_offset + c0_val) * line_yinc; // start position for drawing
               xb = xa + (c1_val) * line_xinc;
               yb = ya + (c1_val) * line_yinc;
               printf("2nd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
               if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c1_col, thickness, segments_drawn, lco))
               {
                  done = 1;
                  line_color_offset = color_span - c1_val - lco;
               }
               if (!done)
               {
                  // draw third segment
                  xa = x1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_xinc; // start position for drawing
                  ya = y1 + ((section * color_span) - line_color_offset + c0_val + c1_val) * line_yinc; // start position for drawing
                  xb = xa + (c2_val) * line_xinc;
                  yb = ya + (c2_val) * line_yinc;
                  printf("3rd segment xa:%3.0f ya:%3.0f xb:%3.0f yb:%3.0f ", xa, ya, xb, yb);
                  if (check_and_draw(x1, y1, x2, y2, xa, ya, xb, yb, line_xinc, line_yinc, c2_col, thickness, segments_drawn, lco))
                  {
                     done = 1;
                     line_color_offset = color_span - lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}
*/

good method....




int check_and_draw(double x1, double y1, double line_length, double line_xinc, double line_yinc, double za, double zb, int col, float thickness, int &segments_drawn, int &lco)
{
   int debug_print = 0;
   char t[1024] = {0};
   sprintf(t, "\n");
   int skip = 0;
   int end_adj = 0;
   // these checks mean that the segment is entirely not on the line
   if (za > line_length) skip = 1; // za after line end
   if (zb < 0)           skip = 1; // zb before line start
   if (skip) sprintf(t, "skip\n");
   else  // at least one point is on the line
   {
      if (za < 0) // za is before line start
      {
         if (debug_print) sprintf(t, "start_adj\n");
         za = 0;
      }
      if (zb > line_length) // zb is after line end
      {
         lco = line_length - zb;
         if (debug_print) sprintf(t, "end_adj - lco:%d\n", lco);
         zb = line_length;
         end_adj = 1;
      }
      double xa = x1 + za * line_xinc; // convert to screen coordinates
      double ya = y1 + za * line_yinc;
      double xb = x1 + zb * line_xinc;
      double yb = y1 + zb * line_yinc;
      if (debug_print) printf("%s   drawn at za:%3.0f zb:%3.0f\n", t, za, zb);
      al_draw_line(xa, ya, xb, yb, palette_color[col], thickness);
      segments_drawn++;
   }
   return end_adj;
}

int mw_draw_line(double x1, double y1, double x2, double y2, float thickness, int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col, int &line_color_offset)
{
   int debug_print = 0;

   if (debug_print) printf("\nmw_dl x1:%3.1f y1:%3.1f x2:%3.1f y2:%3.1f ", x1, y1, x2, y2);

   int done = 0;
   int lco = 0; // local lco to pass to sub fucntion
   int segments_drawn = 0;

   int color_span = c0_val + c1_val + c2_val;
   if ((color_span < 1) || ((c1_col == 0) && (c2_col == 0))) al_draw_line(x1, y1, x2, y2, palette_color[c0_col], thickness);
   else
   {
      if (debug_print) printf("lco:%d color_span:%d\n", line_color_offset, color_span); // line_color_offset is in pixels, from 0 to color_span
      double line_xspan = x2-x1;
      double line_yspan = y2-y1;
      double line_length = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

      if (line_length != 0)
      {
         //printf("lxs:%f lys:%f  ls:%f\n", line_xspan, line_yspan, line_span);

         double line_xinc = line_xspan / line_length; // one unit of these are one unit of vector move
         double line_yinc = line_yspan / line_length;
         int section = 0;
         while (!done)
         {
            if (debug_print) printf("Section:%d\n", section);
            double section_z_start = ((section-1) * color_span) - line_color_offset;

            double za = section_z_start;   // start position for drawing 1st segment
            double zb = za + c0_val;
            if (debug_print) printf("1st segment za:%3.0f zb:%3.0f ", za, zb);
            if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c0_col, thickness, segments_drawn, lco))
            {
                done = 1;
                line_color_offset = lco - c2_val - c1_val;
            }
            if (!done)
            {
               za = section_z_start + c0_val;   // start position for drawing 2nd segment
               zb = za + c1_val;
               if (debug_print) printf("2nd segment za:%3.0f zb:%3.0f ", za, zb);
               if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c1_col, thickness, segments_drawn, lco))
               {
                   done = 1;
                   line_color_offset = lco - c2_val;
               }
               if (!done)
               {
                  za = section_z_start + c0_val + c1_val;   // start position for drawing 3rd segment
                  zb = za + c2_val;
                  if (debug_print) printf("3rd segment za:%3.0f zb:%3.0f ", za, zb);
                  if (check_and_draw(x1, y1, line_length, line_xinc, line_yinc, za, zb, c2_col, thickness, segments_drawn, lco))
                  {
                      done = 1;
                      line_color_offset = lco;
                  }
               }
            }
            section++;
         }
      }
   }
   return segments_drawn;
}




add pop up menu to plot area or series legend to thin number of segments or change to solid color.
changing from a segmented line to solid only make a small change

show hide segments drawn and time taken..




amke y xais arrange customizable...

if axis slaved, make it so the plot_x1 follows master
gridlines and label are always anchored to plot

on slaves, don't show x axis legends



remove y scrollbar for active...

put dsync on bottom and make it the master

active on top

make a y axis label type for active

slave series legend...just copy x_axis_slave

thin out player active....done

make it so that you can still see series legend on slave and change things, but only master can change active...

make it so that number of points on series legend is optional....done
also plot time optional

hide and show series legend from main plot popup menu...done

main plot pop up menu..done


fix the double drawing nonsense on the scroll bars....

remove from draw because proc calls draw...
double shit is gone, but now I have no mouse cursors

they are fixed but the mouse over is done....

make nice colors match...done


make units from pointer data and stuff work nicely wit ha few new types



I have a bigger issue...

I cant quite figure out in what order to do all the things....

I have moved everything in the draw function....

but that is bad because sometimes I call that recursively when moving stuff...


I need to separate the draw from the input....

also what about the checking of variables??


lets start with the most obvious

draw_plot() and
process_mouse_on_plot() (which also draws on plot)

obviously the plot area has to be drawn first, then the stuff on top, or it will never be seen

I should merge these two....
and have a draw only option for when I have call to it recursively

void proc_plot_area(int draw_only)
{
   draw

   if ()!draw_only)

   proc mouse on graph

}


do the same with scrollbars

have one entry point and an option to draw only...

then have draw itself have an option to draw only

void mwGraph::y_axis_proc_scrollbar(void)
{
      int sb = y_axis_draw_scrollbar(0);

now I have one entry point:
mG[].proc_graph(void)

all it does is call:
draw_graph(int draw_only)

and that calls:

x_axis_get_size_and_arrange_pos();
y_axis_get_size_and_arrange_pos();
enforce_axis_limits();

al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, palette_color[title_frame_color+224]); // erase plot background
al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, palette_color[title_frame_color], 2); // frame plot

x_axis_draw();
y_axis_draw();


x_axis_proc_scrollbar(draw_only);
y_axis_proc_scrollbar(draw_only);

proc_plot_area(draw_only);

draw_title(0);
draw_series_legend();

this seems to work pretty good

can I refine it? yes I can...

void mwGraph::draw_graph(int draw_only)
{
   al_show_mouse_cursor(display);
   if ((mouse_x > graph_x1) && (mouse_x < graph_x2) && (mouse_y > graph_y1) && (mouse_y < graph_y2))
      al_set_system_mouse_cursor(display, ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT);

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


it looks really good now....

make nice title and colors for bandwidth..done
make bandwidth have option for 2 graph (tx and rx)..done
make a way to slave y axis range also...done...

make units for all types look good...

y axis
tx = 1
rx = 2
dsync = 3
FPS = 4

done....


add reset all to plot menu

add resize slider in between graphs...done...added to bandwidth...

make is so when x_axis_slave, can't even slide x axis a little bit...done

make it so if y legend does not fit on screen, auto set to smaller font...


make a way to not draw x_axis labels and reclaim space....

I think I might need to properly separate gridline and labels
right now I kind of lump them together

I still want to draw them together, but the variable used to control whether tey are draw or not are overly complicated


this is what I have now:
int  x_axis_label_draw_on;
int  x_axis_label_font;
int  x_axis_label_draw_size;
int  x_axis_label_tick_size;
int  x_axis_label_text_size;
int  x_axis_label_text_draw;
int  x_axis_label_color;

change to:
int x_axis_grid_draw_on
int x_axis_grid_color
int x_axis_grid_labels_draw_on
int x_axis_grid_labels_font
int x_axis_grid_labels_color
int x_axis_grid_labels_draw_size
int x_axis_grid_labels_tick_size
int x_axis_grid_labels_text_size


this is done and it works way better

add one more...
int x_axis_grid_draw_to_top_of_other_graph...why bother...

removed the lock, unlock, auto button...

now clean up the y axis the same way...

old
int y_axis_label_draw_on;
int y_axis_label_font;
int y_axis_grid_label_draw_size;
int y_axis_label_tick_size;
int y_axis_label_text_size;
int y_axis_label_text_draw;
int y_axis_label_color;

new
int y_axis_grid_draw_on
int y_axis_grid_color
int y_axis_grid_label_draw_on
int y_axis_grid_label_font
int y_axis_grid_label_color
int y_axis_grid_label_draw_size
int y_axis_grid_label_tick_size
int y_axis_grid_label_text_size

fixed some weirdness in void mwGraph::y_axis_get_size_and_arrange_pos(void)
now it's much simpler

add reset to main menu...done...



add x_axis_top_graph_gridline...done...

now it matter in what order thing are drawn in
the graph that draws the gridlines, needs to be last or the other plots will overwrite them
also when thet are draw, they draw on top of everything else....
not sure if this was a good idea...removed....


how about the mouse position on any graph is sent to the others so they can show that x position on their graph too...

how will I go about linking them?

make a series number that they can share
if the mouse is diplaying a point, send that to all others in the same series

all others look for shared values when they don't have mouse...

each graph could have a

if graph does not have the mouse, they are listening
if graph does have the mouse, they sending


all I need to link is x_cursor_pos...

any of the linked ones can set all other linked ones...


code:
if mouse on plot, set x_cursor_pos on all others..
if mouse not on plot read x_cursor pos...

this could work...

vars

int linked_group_id;
double x_axis_cursor_pos;

ok fine, try it




x_axis_cursor_pos = -99999;

if mouse is on graph, but not on plot set all local and remote to dont show value

if mouse is not on graph at all, read and use value from local

if mouse is on plot, set local and send to all linked

have a common place to draw....



i need a function that you pass it only an x position
and you get:

0 = no data at that x point
1 = scaled y position at that point
2 = closest point (less tham threshold)

this is getting complicated....

i could have mutiple y matches for x at the destination

keep it simple...

do only the line....done

         else // show mouse position
         {
            col = 15;
            x = mouse_x;
            y = mouse_y;
            draw_point_data(x, y, mx1, my1, col, f3, -1);
         }
         if (linked_group_id)
         {
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = x;
         }


      } // end of mouse on plot area
      else // mouse not on plot area
      {
         if ((mouse_x > graph_x1) && (mouse_x < graph_x2) && (mouse_y > graph_y1) && (mouse_y < graph_y2)) // not on plot, but on graph
            for (int g=0; g<10; g++)
               if (mG[g].linked_group_id == linked_group_id) mG[g].x_axis_cursor_pos = 99999; // set all linked cursors to not valid

         if (x_axis_cursor_pos > -99998)
            al_draw_line(x_axis_cursor_pos, plot_y1, x_axis_cursor_pos, plot_y2, palette_color[15], 0); // draw if valid
      }



that is done...now add it to bandwidth graph...done....



test graph on weak clients...it seems really slow  can take up to 800ms to plot
in that case I could automatically reduce the x range....


is there anything else in the logs I could graph?




make a client sync graph from the clients point of view:
fps chase
dsysnc
ping
what log line am I basing this on?

the server only has data when the client sends stak but the client should have much more data than that...


it looks like the client only adjust timer when rxing stdf....

I thought it would happen more often...but what does it have to sync with?

I suppose we could use ping...

I want to do a ping vs dsync from the client's pov


there are three things on the client...

ping
sync target
acually sync

I think a graph of those might be insightful

where does it happen and what are the vars again??


in client_fast_packet_loop:
players1[active_local_player].ping = t2 - t0;
ping_array_add(players1[active_local_player].ping);
I should add a log entry for this...

then what?

void client_timer_adjust(void)
{
   int p = active_local_player;
   double dsync = players1[p].dsync - players1[p].client_chase_offset; // adjust for target offset
   double fps_adj = dsync * 100; // make the change bigger

   float fps_chase = frame_speed + fps_adj;
   if (fps_chase < 10) fps_chase = 10; // never let this go negative
   if (fps_chase > 70) fps_chase = 70;
   al_set_timer_speed(fps_timer, ( 1 / fps_chase));
   players1[p].client_chase_fps = fps_chase;
}




where is offset calculated...

in ping array add....

places for log inputs:
- stdf rx (dysnc, fps_chase) this is already done...
- add ping... (ping_curr, ping avg, offset)


add one in timer adjust....


36 tmaj // timer adjust
37 cpng // client ping


sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", dsync, players1[p].client_chase_offset, fps_chase);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(36, p, msg);

sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping, players1[p].ping_avg);
if (L_LOGGING_NETPLAY_stdf_all_packets) add_log_entry2(37, p, msg);


OK I have some log lines, now lets make a graph....




I need a way to get value for y axis....


just throw a values and it will know how to print it...

i think I started one of those already....
char* mwGraph::y_axis_get_val_text(double val, int units)


dsync is huge at the start....how about we don't actually use it to set fps until after initial state is received and chase starts....




clean up the number formating stuff+...

int y_axis_type
set for different types

y_axis_type
y_axis_legend
y_axis_units
y_axis_divider

The name you give to legend, should not ever automatically change
however the units may depending on type...

at init:
set name, units name, divider,

now I only have types 1 and 2 that change units
they do that in enforce_axis_limits(5)


all the rest should be handled in:
char* mwGraph::y_axis_get_val_text(double val, int units)

this should not change units, just print formating

type 3 for all ms
type 4 for FPS

check where thet are all set...done...



now what else can I monitor??

on the server, late cdat dropped


d 3-1 30s 1c

e 3-1 at 15s 3-1 ic




why? on my latest test graph, do the 2 graphs not line up vertically?

im guessing something to do with enforce limits.....
can i disable it for x axis on slaves...
made it so that plot can start before data....
this broke scrollbars, now ends are past...
2 ways to fix...
adjust only scrollbar ends to b not past data max...
adjust data max be larger
add new variable data display max and min
set clip...

try set_clip...

also disable slaving of series legend tied to x axis slaving...done


make it so that you can see status of things in menu...
make the main menu do everything
like locking x and y axis and show status of locking...
Y axis: free move / locked / auto range
unlock/lock Y axis
set y ais auto range..

done and it looks way better...

can you also lock x axis?
autoscroll does not make sense for x axis, but lock would be nice so I could zoom and move y without moving x...

I don't think I need menus for scroll bars any more, comment out for now....

added this....

   // min, max, and range for min and max displayable range (used for limits on axis, instead of using data)
   double x_disp_min;
   double x_disp_max;
   double x_disp_rng;
   double y_disp_min;
   double y_disp_max;
   double y_disp_rng;


cleaned up the scroll bar code a lot...





am I drawing scroll bars twice?


proc_plot_area calls

x and y axis_draw
then draws plot

x and y axis_draw call grid and labels, legend and scroll bars
this seems like too much...

where are they arranged?

down the fucking rabbit hole!!

proc_graph -> draw_graph ->

   x_axis_get_size_and_arrange_pos();
   y_axis_get_size_and_arrange_pos();
   enforce_axis_limits();

   proc_plot_area(draw_only);

   draw_title(0);
   draw_series_legend();

   x_axis_proc_scrollbar(draw_only);
   y_axis_proc_scrollbar(draw_only);


this all works but seems overly complicated

gridlines and labels have always had to be drawn before plot...
well...I don't want to separate gridlines and labels...
but they need to be done after old plot is erased and before data is plotted...
make it a part of draw plot??

this is the way it is now:
void mwGraph::proc_plot_area(int draw_only)
{
   al_draw_filled_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, palette_color[title_frame_color+224]); // erase plot background
   al_draw_rectangle(plot_x1, plot_y1, plot_x2, plot_y2, palette_color[title_frame_color], 2);         // frame plot

   x_axis_draw();
   y_axis_draw();

   draw_plot_area();

I want to replace
   x_axis_draw();
   y_axis_draw();


with just the labels and gridlines

leaving legend and scroll bars for somehwere else...done...much better now...

bool mouse_on_graph;
bool mouse_on_scrollbar;

done...awesome!!

make x axis use get text...done


still have issues with labels, now the first one less than 0 does not show.....



I'm sure its my rounding function

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 =  nr + (in - tmp);
   if (nr2 < 0) nr2 -= nr; // hack because negatives were rounding too high
   printf("in:%f  nr:%f  nr2:%f\n", in, nr, nr2);
   return nr2;
}

what is it supposed to do?

round 'in' up to the nearest 'nr'

double round_to_nearest(double in, double nr)
{
   double tmp = fmod(in, nr);
   double nr2 = (in - tmp) + nr;
   if (tmp < 0) nr2 -= nr; // hack because negatives were rounding too high
   //printf("in:% 5.1f  out:% 5.1f  tmp:% 3.1f\n", in, nr2, tmp);
   return nr2;
}
this is the fix....nice...
auto reduce legend font if too tall, also clip so it won't exceed graph..done for y and x
make x legend do name and units like y....done

make split bar invisible until mouse over...
remove top padding for graph....


20220110 1:11PM

graph is done....


put chase and ping into main log thing

make sure the other graphs still work nice

separate the load part of each graph
fail gracefully if no data found..


how to check for no data...


I could use
void mwGraph::calc_data_range(void)
yes...but need to set series first...done...

now do the same for bandwidth graph...


erased all the old graph stuff from z_logs.cpp...1500+ lines gone
now the entire z_logs.cpp is around 1500 lines...

made it very easy to load graphs....

from log file viewer:
log_bandwidth_graph(int num_lines, int both);
log_client_server_sync_graph(int num_lines);
log_ping_graph(int num_lines);

from anywhere else:
log_bandwidth_graph(load_log_lines_array_from_static_file("logs/a.txt"), 0);
log_client_server_sync_graph(load_log_lines_array_from_static_file("logs/a.txt"));
log_ping_graph(load_log_lines_array_from_static_file("logs/e.txt"));

I use this function in 4 places:
int load_log_lines_array_from_static_file(const char* f));
it loads:
extern char log_lines[NUM_LOG_LINES][100]; // for log file viewer
extern int log_lines_int[NUM_LOG_LINES][3]; // for log file viewer

this makes things much simpler...



now clean up the other 2 graphs:

bandwidth
make nice splitter
why no x gridlines on upper
done...

client sync...looks good...

now the only thing left is the three way splitter...done

bug... when x axis is locked, disable x scroll bar...done....

we are way further along now.....

can I call the graph thing done? yes...

now what?

log:
when the server gets late cdats?
the current s1 and s2 values on the server...
when clients base is reset

how about some code profiling...

draw_time
move time
decompress time

I am going to make the busiest level I can imagine...

how do I get the default menu back on level editor after I come back...done...

bug on graph.. y axis scroll bars draw off their range. it was a bug I inadvertantly introduced when making type 3 for active...fixed...



what do I have for my timer thing...

I have 10,000 of these

struct timestamp
{
   int frame0;
   int frame1;
   int frame2;
   int type;
   double t0;
   double t1;
   double t2;
};


how was i supposed to use them?

void add_timestamp(int type, int f1, int f2, double t1, double t2)
{
   if (timestamps_index < 9998)
   {
      timestamps[timestamps_index].frame0 = frame_num;
      timestamps[timestamps_index].frame1 = f1;
      timestamps[timestamps_index].frame2 = f2;
      timestamps[timestamps_index].type   = type;
      timestamps[timestamps_index].t0     = al_get_time();
      timestamps[timestamps_index].t1     = t1;
      timestamps[timestamps_index].t2     = t2;

      timestamps_index++;
   }
}

            add_timestamp(1, 0,0,0,0);
            timestamp_frame_start = al_get_time();

            proc_timer_adjust();

            proc_scale_factor_change();

            if (ima_server) server_control();
            if (ima_client) client_control();

            proc_player_input();
            proc_game_moves_array();

            if (players[0].level_done_mode) proc_level_done_mode();
            else
            {
               //add_timestamp(5, 0,0,0,0);
               move_frame(0);
               //add_timestamp(6, 0,0,0,0);
            }

            if (players1[0].server_send_dif) server_send_stdf();



//            if (get_delta(frame_num,   3, frame_num,   4, res)) printf("time in draw: %5.1f us\n", res*1000000);
//            if (get_delta(frame_num,   1, frame_num,   2, res)) printf("time in move: %5.1f us\n", res*1000000);
//
//            if (get_delta(frame_num-2, 1, frame_num-1, 1, res)) printf("total fram time: %5.1f us\n", res*1000000);




now that I have the frame_num inc at the very start of every frame it should make timing easier.


I don't know why I have multiple frame numbers in the structure

most of the time I just use the current frame number and the current timestamp


so lets do it...

take some times and plot them...

I want to have a log entry every frame

how many timestamps per frame?

lets say 10, that would give me 1000 frames or 250s or just over 4 min...

that's a good start

time for a new log entry...44

holy shit that was fast!
I got some profile timestamps, made a new log entry and made a dual graph to view them both: draw time and move time
It only took about 1H to do all that, because of all the framework I have in place...nice...

I can't wait to profile more things....

but I am going to do a push, then get a hot drink...

20230110 10:15PM


do a timer for server send stdf
one for each client...or all together?

they will all be on the same frame, but with different player numbers

I can probably do this one in line, without the timer struct...

use tag 45...

more data...like was the base reset? how many packets...

[45][1][169]tmst [1.368000] [0] [835] [1]
[45][1][172]tmst [1.355800] [0] [792] [1]
[45][1][175]tmst [1.369900] [0] [800] [1]
[45][1][178]tmst [1.347400] [0] [704] [1]
[45][1][181]tmst [1.367600] [0] [804] [1]
[45][1][184]tmst [1.369800] [0] [799] [1]

I could plot all these on the same graph if /1000 for 3...do it...

20230111 7:41AM


I want to make a different, easier way to get these profiling timestamps into a graph..


Maybe I could tag each one like td:[] tm:[] stdf:[]

then I will need a tag reader than can get the text before...

I can have multiple log file lines that all have the code 45 tmst

they can all go on the same graph beacuse they all have the same units

I have the very basic framwork in place....


I want to make a new gui element.
I will act exactly like button toggle but will look different
[] - name


I have the logging options page looking really good...
what other pages?

sound, color, splash screen

controllers

netgame options

make multiple tabbed pages...

this should be fun

in the end it will be so much easier to add new options, so many more that I have not even thought about....

make it look good...


I think I have all the functionality for controls except for set indivual

now I need to make it look good..


make the list of keys more centered but still left justified
add a button to the left of each key, 'new' which prompts to set that one control

I want my own function to redraw all keys....done...

what is the maxiumun text length of key_names[]? 11 PRINTSCREEN
make it so that this displays nicely....
press new control is 17....

page for controllers is setup and looks great!!

next, nextgame??
all the controls are in place and working...now make it look good...


display server name and give a text description

Server Name: ....

Clients must have the server name or IP address set here.


OK...config page for netgame is done...


This is looking very nice...how are you going to patch it into the game_menu?
I think I should have an overall larger background and title:

Like 'Configuration'

make it a fixed width of 400,400


do I need a large size for the frame, tabs, and title??

Yes, obviosly....

OK what am I going to name them?

Do I have an actual minimun size for the useable pages?

can I go up from there??

sure why not?

add tab height and title height

that should do it...


I don't know where am going to patch it into the menu...
it seems like it is already pretty busy...

put it on the options menu for now and have a hotkey to bring it up any time from any menu....ok...
CTRL SHIFT O


i like it....

when it gets full I will need to have a second row of tabs...


I have changed my mind...


I want to start with the full outer size and then shrink it as I move in...

what are my varaible going to be called?


this is all I have for now:



   int cfp_x1 = 200;
   int cfp_y1 = 200;
   int cfp_x2 = 600;
   int cfp_y2 = 600;
   int cfp_txc = cfp_x1 + (cfp_x2 - cfp_x1) / 2;



I think I will keep these vars...

entire thing:
cf_x1
cf_w
cf_x2
cf_y1
cf_y2
cf_h

then I will figure out the borders, tab height, title height, and then finally set:

cfp_x1
cfp_w
cfp_x2
cfp_y1
cfp_y2
cfp_h

for the display area of the pages


goddamn this looksg good...


what else can I add?

sound
color
splash screen


today:
finish basic page..done
make advanced page
add help buttons to pages...
think about re-arranging menus to make simpler

do I have enough tabs??..yes


what wil go on advanced?
speed
disable timed demo mode...
show hysteris box...

what is left on the options menu that I don't have in config pages?

   strcpy (global_string[8][3], "Netgame Options");
   strcpy (global_string[8][4], "<-Change Color->");
   strcpy (global_string[8][5], "Controller Setup");
   strcpy (global_string[8][6], "Speed:40fps");
   strcpy (global_string[8][7], "Sound:Off");
   strcpy (global_string[8][8], "Sound Effects Volume:9");
   strcpy (global_string[8][9], "Sound Track Volume:9");
   strcpy (global_string[8][10], "Logging Options");
   strcpy (global_string[8][11], "Splash Screen:ON");
   strcpy (global_string[8][12], "Save Demo");
   strcpy (global_string[8][13], "Run Demo");
   strcpy (global_string[8][14], "Configuration Pages");
   strcpy (global_string[8][15], "end");

speed
save demo
run demo

I could have a tab just for demo...
run
save
disable timed demo
options for auto save

yes, do this...then options menu can go away totally and be replaced with config pages on main menu....

Maybe it could be renamed to 'Settings'...that seems more generic and apt and standard...done

here is the thing...

running demo from these pages is not as simple as just calling a function...

we are in menu, then in config, how to get back to where the game runs??

we have to:
- set next program mode
- quit config
- quit zmenu


I guess this all depends on where config_pages is called from...

lets make sure it is always called from zmenu...
then we can figure out how to handle return...
called from:
args
zmenu CTRL O
game_menu options 14

for now just do CTRL O

if I can make config pages return something...

maybe the zmenu was not better choice..another layer deep...

make the CTRL O call option 14 then deal with it there for now in game menu

maybe I am doing this wrong...maybe config pages ahould be another program_state

something that I can return to, like command line and zmenu

that seem a little less hacky...

from menu, leave menu and do configpages..from there do run games...

   if (program_state == 3) config_pages();  // this blocks


ok it gets there, but how does it get back??

replace OPTIONS MENU with SETTING and then it will come back there...


coming back from playing demo does not come back to config, it come back to menu...why??


it seems like a lot of things set old_program_state...too many


like for instance it is set when rungame_key_check exits...it is set to 1...why?  how does it know what called it?

where are the places it should be set?


0 when delared
then if called from command line it will know where to go

1 when starting game_menu

2 when starting demo mode

3 when starting config...

those are the only places it should be set....

it is used when leaving a running game to determine where to go back to....




This is what actually is in place:

int old_program_state = 1;

when game_menu() starts
old_program_state = 1;



when demo_mode loads a level and plays it
new_program_state = 14;
old_program_state = 2;

if demo mode fails to load level
new_program_state = 1;
old_program_state = 1;


when config starts rungame
new_program_state = 14;
old_program_state = 3;

when config ends with ESC
new_program_state = 1;
old_program_state = 1;

rungame_key_check
new_program_state = 1;
does not set old....


OK this is looking a little better...


start game, start config, rungame from file...

exit with any key..goes back to config...good

exit with ESC key..skips past config to menu...fix this
added this in rungame_key_check to eat ESC
while (key[ALLEGRO_KEY_ESCAPE][0]) proc_controllers();

now it does stimp and goes back to config....
from there you can run another file...

this all works great...

but when you leave config for menu, stimp is called again...
happens every time config to menu....fixed
if (program_state != 3) stamp();


that was the last thing from options menu...time to retire it....

and at the same time...call it settings...
settings_pages


top_men_sel == 7 // settings

CTRL SHIFT O from zmenu as a shortcut

commented out all option menu stuff in game menu

returns to setting selection when leaving config..

wow! all of this works so good...

I will miss wacthing the title screen change immediatley when changing player color....


should I alway have that background behind settings_pages?yes
the only other possible thing would be a partially played demo level....
do it...
call frame and title and make sure settings is centered also....done...

you know what would be amazing?
If I could center the title 'Settings' on the menu item 'Settings'
how do I know where that is?
set_map_vars()
done....
now can I show the menu text only....done

now hide the mouse when leaving settings..done

rename...done...

now make that goddamn demo_mode time able to be disabled



what variables?


demo_mode_countdown_val;
demo_mode_countdown_reset;

demo_mode_enabled

int demo_mode_enabled = 1; when declared

then set to zero:
if resume allowed
if any menu key is moved
if demo mode times out and starts


i suppose I could read this value from config file

default it to 1 and if player turns it off in config...

the problem is...any time config file is read, it gets turned back on...

make a separate config file varibale and only use it to set the global one once at startup..

this is getting confusing!!

demo_mode_config_enable

extern int demo_mode_config_enable;
now use it in initial_setup() to set  demo_mode_enabled
this is all done!!!

next, demo mode....
when trying to exit, it quits the current level and immediately plays next....

in rungame_key_check:

      new_program_state = 1;
      if (old_program_state == 2) old_program_state = 1; // don't send back to demo mode if cancelled

this seems to have fixed it....



now, does it work from settings....yes, but it comes back to menu, not settings...big deal....
when demo mode starts it sets old_program_state to 2..in this way we do not know what started demo mode
it could be menu or settings

do I want yet another variable to track this?
some humor 'older_program_state'

used only when starting demo mode
3 from settings
1 from menu

then when demo mode is cancelled from rungame_key_check it can set the appropriate place to return to...

new_program_state = 1;
if (old_program_state == 2) old_program_state = older_program_state; // don't send back to demo mode

done and it works perfectly....

now to make demo tab look nicer.. looking pretty good!!!


now how many things call zmenu? only one: top
old ones:
options
logging
netgame
controller



put speed on advanced tab...done

also by default make the speed locked, disabling function key
also speed is never saved to config file

add DEMO MODE overlay transparency option to demo tab...and config file...done

add other hysteris mode stuff somewhere


now that I have everything from option menu on the settings page....

I have so many more things I want to put there....

but first...

lets see what it would take to get more tabs....

and a second row....

maybe an optional second row...

erased options menu...now game menu is <70 lines

going through code and removing unneeded references to global_string....


why don;t I make a struct for each tab...then make an array of structs
done and its looking good...



I want to see how hard it is to draw a filled polygon with allegro primitives....

float v[4][2] = {0};

v[0][0] = 100;
v[0][1] = 100;

v[1][0] = 100;
v[1][1] = 200;

v[2][0] = 200;
v[2][1] = 200;

v[3][0] = 200;
v[3][1] = 100;

al_draw_filled_polygon(*v, 4, palette_color[14]);

this is all it takes....

now use that to draw tabs....done...

that looks so much better...


now what?

rename the logging netplay things and add more....


now I have game_menu down to 25 lines!!!

// z_game_menu.cpp
#include "pm.h"
void game_menu(void)
{
   old_program_state = 1;
   if (!splash_screen_done) { splash_screen(); splash_screen_done = 1; }
   if (!resume_allowed) load_level(start_level, 0);
   if (top_menu_sel < 3) top_menu_sel = 3;
   while (top_menu_sel != 1)
   {
      top_menu_sel = zmenu(7, top_menu_sel, 10);
      if  (top_menu_sel == 1)  { program_state = 0;                                           return; } // exit
      if  (top_menu_sel == 2)  { visual_level_select(); top_menu_sel = 3;                             } // visual level select
      if ((top_menu_sel == 4) && (resume_allowed)) { new_program_state = 13;                  return; } // resume game
      if  (top_menu_sel == 3)  { new_program_state = 10;  top_menu_sel = 4;                   return; } // start new game
      if  (top_menu_sel == 5)  { new_program_state = 20;                                      return; } // host network game
      if  (top_menu_sel == 6)  { new_program_state = 24;                                      return; } // join network game
      if  (top_menu_sel == 7)  { new_program_state = 3;                                       return; } // settings
      if  (top_menu_sel == 8)  { play_level = edit_menu(start_level); new_program_state = 10; return; } // level editor
      if  (top_menu_sel == 9)  { new_program_state = 2;  older_program_state = 1;             return; } // demo mode
      if  (top_menu_sel == 10)                                                                help(""); // help
      if (top_menu_sel == 102) if (++start_level > 399) start_level = 399; // start level inc
      if (top_menu_sel == 202) if (--start_level < 1) start_level = 1;     // start level dec
      if (top_menu_sel > 100) { set_start_level(start_level); load_level(start_level, 0); top_menu_sel = 2; }
   }
}



these are the config names:
LOGGING_NETPLAY);
LOGGING_NETPLAY_JOIN);
LOGGING_NETPLAY_PLAYER_ARRAY);
LOGGING_NETPLAY_bandwidth);
LOGGING_NETPLAY_cdat);
LOGGING_NETPLAY_game_move);
LOGGING_NETPLAY_sdat);
LOGGING_NETPLAY_sdak);
LOGGING_NETPLAY_stdf);
LOGGING_NETPLAY_stdf_all_packets);
LOGGING_NETPLAY_stdf_when_to_apply);
LOGGING_NETPLAY_show_dif1);
LOGGING_NETPLAY_show_dif2);


extern int L_LOGGING_NETPLAY;
extern int L_LOGGING_NETPLAY_JOIN;
extern int L_LOGGING_NETPLAY_PLAYER_ARRAY;
extern int L_LOGGING_NETPLAY_bandwidth;
extern int L_LOGGING_NETPLAY_cdat;
extern int L_LOGGING_NETPLAY_game_move;
extern int L_LOGGING_NETPLAY_sdat;
extern int L_LOGGING_NETPLAY_sdak;
extern int L_LOGGING_NETPLAY_stdf;
extern int L_LOGGING_NETPLAY_stdf_all_packets;
extern int L_LOGGING_NETPLAY_stdf_when_to_apply;
extern int L_LOGGING_NETPLAY_show_dif1;
extern int L_LOGGING_NETPLAY_show_dif2;


I want to make this simpler:

variables:
LOG_NET_xxx

config
CLOG_NET

and make them all lower case after the _

replace:

L_LOGGING_NETPLAY_
LOG_NET_

do it: 75 replaced  still compiles


now replace
LOGGING_NETPLAY
CLOG

wait why??
they can have the exact same name, i do it all the time in config..same variable name and config name
OK

replace
LOGGING_NETPLAY
LOG_NET

OK done.. now do lower case for JOIN and PLAYER_ARRAY

ok that's all done too:

demo mode is not on by default...fixed...


keep a list in to do of other things to add to settings....


many of them will require:
- making a global variable
- saving it in config
- making a way to change it in settings

how about 'send stat to console'

made a lot of those....




what do I call the hyst thing?
lakitu
viewport

lets go with viewport

do a global for viewport_type

0 = force to be in the center of the screen all the time, except when near edges of course...
1 = regular hysteresis
2 = slowly changing hysteresis

added these globals:

int viewport_mode = 1;
int viewport_show_hyst = 0;
int viewport_x_div = 8;
int viewport_y_div = 12;


20230213 6:24AM Friday the 13th
I have taken the entire week off work so far, I probably will take today also...
I have gotten a lot done...
what are some of my next plans?

make links to graphs??? from settings..and log_file_viewer..done




settings - add more stuff
program state - clean up and make simpler
see if I can make level done part of program state...




add timers and LOG_TMR tags for the packets related...

how many do I want?

move
draw
stdf send (server only)
dif unpack (client only)
rewind time (client or server)

LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd
first of all, make these global variables, then save in config, then add toggle in setting...all done
now just patch them into the code where log entries are entered...





make options on logs to never save log files....
I am so annoyed when shit gets saved and I dont want it to....


i am thinking of 2 different types of timestamps


one would be used to profile sections of code...

like move, draw, stdf etc....


each will have a tag like

tmst move:[]


then my tagging system will find them all and apply the label to the series.....

I will have as many or as few as I want, and when I run the graph it will automatically show the ones present

the other type of timestamp would show things in relation to frame start...I can think about that later....

I am excited to do this one....

use these to start:
LOG_TMR_move
LOG_TMR_draw
LOG_TMR_sdif
LOG_TMR_cdif
LOG_TMR_rwnd

I want to make global double t0 just to make the code look cleaner


now make a graph....

looking good....

make a us y axis type....already done, but store data as ms...al_get_time * 1000 print wih %0.4f


looking good...

now make this graph so it can be called with its own file select....


then put it on a button in settings....

this looks awesome....

how about saving log when coming back to menu or config, instead of having to quit game..

options:

save log on program exit
save log on game quit
save log on level done
save log manually only
save log now

do it...




I redid all of the config with macro's..
it took a while but it is so much shorter and easier
to do a config value, i need 1 set and one get, before I need 3 for get and 2 for set
I should really test each one to make sure they are working....
erase config file and see!!
looks good...
color does not stick...fixed...


in program_mode 12 - level done

added: if (autosave_log_on_level_done) save_log_file();

this was here:
blind_save_game_moves(1) - level done

this checks to see if autosave is on and labels the save file accordingly...
I guess this is OK

what else calls blind save??


blind_save_game_moves(2) - game_exit
at the end of main...we should change this to when leaving running game...that seems much more useful...

blind_save_game_moves(3) - bad exit

fast_exit and

void function_key_check(void)
{
   if (key[ALLEGRO_KEY_F4][3])
   {
      blind_save_game_moves(3);
      save_log_file();



-----------

log files for now...

put checks for program exit in fast exit and end of main....done...

look for occurances of save_log_file...good

now just find an entry point for leaving a running game...


resume_allowed...no...

when leaving program_mode 11 to 1 or 3

done...




I think all cases ahould be covered now...

occ of blind_save_game_moves();

blind_save_game_moves(3); F4         only if game_exit set
blind_save_game_moves(3); fast exit  only if game_exit set
blind_save_game_moves(2); game quit  only if game_exit set
blind_save_game_moves(1); level done only if level done set

occ of save_log_file()
F4           only if program exit set
fast exit    only if program exit set
end of main  only if program exit set
game quit    only if game_exit set
level done   only if level done set

looking good....





lets try some log tmr and view on graph...nice....

tmst back:[0.0060] lifts:[0.0207] items:[0.5058] enem:[0.0101] ebul:[0.0001] pbul:[0.0001] play:[0.0035] buff:[0.0111] ovrl:[0.1171] flip:[0.1415]
tmst back:[0.0053] lifts:[0.0197] items:[0.5073] enem:[0.0097] ebul:[0.0001] pbul:[0.0002] play:[0.0033] buff:[0.0112] ovrl:[0.1181] flip:[0.1382]
tmst back:[0.0060] lifts:[0.0206] items:[0.5062] enem:[0.0096] ebul:[0.0002] pbul:[0.0001] play:[0.0034] buff:[0.0108] ovrl:[0.1169] flip:[0.1311]

its 150 char

lets log it...



20230114 8:44 AM

working on timestamp logging today....at least for now...

have move and draw done
total and all individual..

now work on graph and pop up values...
show series and accurate units

units done
series name done


I have this stupid bug that is annoying me....

I have text drawing routines I have made that can take either 'font' pristine or 'f3' pixel gosub

I have been making good use of:
al_get_text_dimensions(f3, text, &bx, &by, &bw, &bh);

I have no problems with the width but the bh and by sometimes do strange things...

mostly by

I want to do some experiment with these fonts to see if I can make a solution

I just want my text to line up consistantly

what is the character range?

pristine 32-127
pixel_gosub 32-127


what is the max and min for bx, by, bw, bh


the built in font has all 0 0 8 8...nice

how did stuff not break when I changed to pristine??
why does it still draw with 8 8 like the old one....




int al_get_font_line_height(const ALLEGRO_FONT *f)

font and font0 are 8
f3 is 9??? WTF

looking into it: almost everything I care about in f3 is 5 high
exceptions:
Q - 6
{} () | $ are 7

also all the ones that are bh5 are also by4...this would cover 99% of what I do with them....


so to make some code common.....

do not use al_get_text_dimensions for height...
you can us it for width, that seems to be fine

have my own custom get text_height thing...
for font or font0, always return 0 8
for f3 always return -4 5

void mw_get_text_height(ALLEGRO_FONT *f, int by, int bw)
{
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

this is just craxy enough to work!

what can I do to test it?

make an example that shows the problem...


function that you send a char, font, color, x, y and it prints that in a nice bounding box with 1 pixel border.
then test that funtion with various fonts and text strings....

I think I got it!

2 steps:
- use my function to get text dimensions
- use bx and by when drawing text
this seems to work for all cases

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; }
   if (f == font0) { by = 0; bh = 8; }
}

void draw_text_in_box(const char* txt, ALLEGRO_FONT *f, int x, int y, int color, int type)
{
   int bx, by, bw, bh;

   if (type == 0) // the regular method
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, palette_color[color], 1);
      al_draw_textf(f, palette_color[color], x+2, y+2, 0, txt);
   }
   if (type == 1) // use bx, by to offset text
   {
      al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, palette_color[color], 1);
      al_draw_textf(f, palette_color[color], x+2-bx, y+2-by, 0, txt);
   }

   if (type == 2) // use my method to force by offset and bh size
   {
      mw_get_text_dimensions(f, txt, bx, by, bw, bh);
      al_draw_rectangle(x, y, x+bw+4, y+bh+4, palette_color[color], 1);
      al_draw_textf(f, palette_color[color], x+2-bx, y+2-by, 0, txt);
   }
}


void temp_test(void)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(palette_color[0]);

   ALLEGRO_FONT *f = font;

   for (int j=0; j<3; j++)
      for (int i=0; i<3; i++)
      {
         if (i == 0) f = font;
         if (i == 1) f = font0;
         if (i == 2) f = f3;

         draw_text_in_box("Hellg", f, 100, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("Hello", f, 150, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("emmem", f, 200, 100 + i*20 + j*100, 10, j);
         draw_text_in_box("e{3}",  f, 250, 100 + i*20 + j*100, 10, j);
      }
}


lets try it out...

where to put my function...in z_fnx...

fixed draw point...perfect...

now lets go through graph, and fix all.....

basically just search for al_get_text_dimensions

make series legend text x + 1
what if I load that font with no kerning???


it is loaded with no kerning...

force bx for that font?? yes...and bw...remember, this font is suppose to be 8x8

void mw_get_text_dimensions(ALLEGRO_FONT *f, const char* txt, int &bx, int &by, int &bw, int &bh)
{
    // first get from the allegro method
   al_get_text_dimensions(f, txt, &bx, &by, &bw, &bh);

   // then override for my nefarious purposes!
   if (f == f3)    { by = 4; bh = 5; }
   if (f == font)  { by = 0; bh = 8; bx = 0; bw = 8*strlen(txt); }
   if (f == font0) { by = 0; bh = 8; }
}


done all the mw_get_text_dimensions in mwGraph....

I should add some code to see if labels are touching each other because they are too close...
try x axis first....i have it working....
labels can only be powers of 10....that is fine...
what would the whole thing look like if I used this to set major instaed of bewyeen 2 and 20...gave up...

oh this is done...

now what the hell was I doing before?

just added move profiling...


better auto colors in graph...
make a function to set colors...just skip 0....done....

now fix the goddam 2 line drawing bug....done...

take a break and come back for more....


now I want to go inside the move enemy and break down individual types..same with draw....


Hysterisis window following player
lots of options there

can I make the hyst div number make more sense?

its a fraction of screen size...

2 is max

how about 1/num * 2 that was 1 will be widest

20 min 1/20 * 2 == .1

save as float from 0.01 to 1

when using it do 1/num and divide by 2....

i use it to divide SCREEN_W and H so now I can just muliply instead...done...

this settings page works, but could use some polish






make a header of mwGraph and move header there


what have you done?

made z_mwGraph.h

put the class declaration there
and at the end of the class declaration:
extern mwGraph mG[10];



// z_mwGraph.cpp
#include "pm.h"
#include "z_mwGraph.h"
mwGraph mG[10];


then the only other source file that needed access was z_log.cpp and all I had to do was add
// zlog.cpp
#include "pm.h"
#include "z_mwGraph.h"


wow, that was easy...

z_mwGraph.h 250 lines
z_mwGraph.cpp 1850 lines

viewport page on settings completely done....

zoom is not saved...well it is, but when getting loaded it always loads 1...
I should make sure of that then remove it from config file...not yet, just disabled and forced to 1.0 instant on load

Disable speed settings including function keys
Speed testing abilites.

is speed save to config file? no and I don't think it should be
I do want a variable to unlock speed changes though...

int speed_control_lock = 1;


done...


I have all the stuff in place for display trandform double, just need to make it look nice...


20230114 9:45PM...push



I don't think I can profile the individual enemies and items as easy....

so what else can I do...





20230115 11:11

so this morning I chose to do something completely different...
something meta....

source code stats!!!

Purple Martians Source Code Line Counts [2023-01-15  11:11:11]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[  2378][  1597][  1387][   385][   175][   210][   606] - z_log.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
--------------------------------------------------------
[ 46138][ 33787][ 28655][  8526][  3394][  5132][  8957] - Total





Purple Martians Source Code Line Counts [2023-01-15  11:27:00]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2435][  1623][  1411][   388][   176][   212][   636] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[   109][    90][    86][    13][     9][     4][    10] - z_map.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
--------------------------------------------------------
[ 46195][ 33813][ 28679][  8529][  3395][  5134][  8987] - Total


sorted by code size



why the fuck do I still have z_map.cpp??


// zmap.cpp

#include "pm.h"

void set_map_position()
{

//  1   9   2
//      |
// -----+-----
//      |
//  4   |   3

   int alp = active_local_player;

   int px1 = players1[alp].sbx1;
   int py1 = players1[alp].sby1;
   int px2 = players1[alp].sbx2;
   int py2 = players1[alp].sby2;

//   printf("gmo:%d mx:%d my:%d px1:%d py1:%d px2:%d py2:%d\n",game_map_on, map_x, map_y, px1, py1, px2, py2);
   switch (game_map_on)
   {
      case 0:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
      break;
      case 1:
         map_x = BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         // check to see if player is covered by the map
         if ((px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 2;
      break;
      case 2:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (py1 < map_y + map_size))  game_map_on = 1;
      break;
      case 3:
         map_x = SCREEN_W - map_size - BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px2 > map_x)
          && (py2 > map_y))  game_map_on = 4;
      break;
      case 4:
         map_x = BORDER_WIDTH;
         map_y = SCREEN_H - map_size - BORDER_WIDTH;
         if ((px1 < map_x + map_size)
          && (py2 > map_y))  game_map_on = 3;
      break;
      case 9:
         map_x = SCREEN_W/2 - map_size/2;
         map_y = BORDER_WIDTH;
         if ((px2 > map_x)
          && (px1 < map_x + map_size)
          && (py1 < map_y + map_size))  game_map_on = 4;
      break;
   }
}

void next_map_mode()
{
   int old_game_map_on = game_map_on;
   switch (game_map_on)
   {
      case 0: game_map_on = 1; break;
      case 1: game_map_on = 2; break;
      case 2: game_map_on = 3; break;
      case 3: game_map_on = 4; break;
      case 4: game_map_on = 9; break;
      case 9: game_map_on = 0; break;
   }
   set_map_position();
   if (old_game_map_on == game_map_on) game_map_on = 0;
}

void next_map_size()
{
   int smin = 0;
   if (SCREEN_H < SCREEN_W) smin = SCREEN_H;
   else smin = SCREEN_W;

   if (new_size == smin /4) new_size = smin/3; // 1/3
   else if (new_size == smin /3) new_size = smin/2; // 1/2
   else if (new_size == smin /2) new_size = smin/4; // 1/4
   else  new_size = smin /3; // if for some reason none of these match
}

void draw_map()
{
   if (game_map_on)
   {
      // process the size change gradually
      if (map_size < new_size)
      {
         map_size+=30;
         if (map_size > new_size) map_size = new_size;
      }
      if (map_size > new_size)
      {
         map_size-=60;
         if (map_size < new_size) map_size = new_size;
      }
      set_map_position();
      al_draw_scaled_bitmap(level_buffer, 0,0, 2000, 2000, map_x, map_y, map_size, map_size, 0);
   }
}

kill it!!!

a few more tweaks then I am done....

Purple Martians Source Code Line Counts [2023-01-15  11:41:32]

[ total][  code][cd_onl][commnt][cm_onl][ cd+cm][ blank]
--------------------------------------------------------
[  2833][  2149][  1713][   601][   165][   436][   519] - z_item.cpp
[  2720][  1961][  1338][   885][   262][   623][   497] - z_enemy.cpp
[  2454][  1829][  1588][   418][   177][   241][   448] - z_fnx.cpp
[  2115][  1791][  1376][   522][   107][   415][   217] - e_object_viewer_windows.cpp
[  2404][  1620][  1405][   391][   176][   215][   608] - z_log.cpp
[  1861][  1589][  1439][   206][    56][   150][   216] - z_mwGraph.cpp
[  1900][  1324][  1278][   195][   149][    46][   427] - pm.h
[  1725][  1322][  1106][   315][    99][   216][   304] - z_player.cpp
[  1842][  1319][  1095][   272][    48][   224][   475] - e_sliders.cpp
[  1812][  1281][  1102][   312][   133][   179][   398] - z_screen_overlay.cpp
[  1490][  1145][  1010][   221][    86][   135][   259] - e_mWindow.cpp
[  1395][  1128][   996][   182][    50][   132][   217] - z_menu.cpp
[  1256][   932][   803][   188][    59][   129][   265] - e_bitmap.cpp
[  1259][   918][   801][   163][    46][   117][   295] - e_fnx.cpp
[  1587][   899][   814][   183][    98][    85][   590] - e_glt.cpp
[  1060][   878][   743][   194][    59][   135][   123] - e_editor_zfs.cpp
[   878][   737][   418][   368][    49][   319][    92] - e_editor_main.cpp
[   940][   716][   665][   105][    54][    51][   170] - n_server.cpp
[   920][   710][   653][   133][    76][    57][   134] - z_control.cpp
[   784][   690][   607][   103][    20][    83][    74] - e_group_edit_windows.cpp
[  1040][   683][   595][   197][   109][    88][   248] - z_screen.cpp
[   937][   666][   576][   202][   112][    90][   159] - z_loop.cpp
[   832][   640][   604][    96][    60][    36][   132] - z_file.cpp
[   877][   638][   607][   127][    96][    31][   143] - z_logo.cpp
[   791][   564][   514][   113][    63][    50][   164] - e_visual_level.cpp
[   773][   563][   501][   109][    47][    62][   163] - z_settings.cpp
[   655][   529][   483][    84][    38][    46][    88] - n_client.cpp
[   899][   506][   469][   132][    95][    37][   298] - z_main.cpp
[   612][   504][   379][   150][    25][   125][    83] - e_item.cpp
[   598][   488][   399][   111][    22][    89][    88] - e_lift.cpp
[   578][   409][   185][   257][    33][   224][   136] - e_tile_helper.cpp
[   496][   381][   301][   106][    26][    80][    89] - z_lift.cpp
[   508][   334][   331][    58][    55][     3][   119] - z_display.cpp
[   396][   328][   288][    48][     8][    40][    60] - e_pde.cpp
[   743][   291][   244][   303][   256][    47][   196] - z_args.cpp
[   351][   289][   229][    71][    11][    60][    51] - e_enemy.cpp
[   639][   188][   187][   314][   313][     1][   138] - z_config.cpp
[   256][   181][   180][     5][     4][     1][    71] - z_mwGraph.h
[   238][   170][   140][    46][    16][    30][    52] - z_bullets.cpp
[   199][   149][   149][     0][     0][     0][    50] - libnet.h
[   168][   127][   125][     8][     6][     2][    35] - n_packet.cpp
[   127][   102][   100][     8][     6][     2][    19] - z_sound.cpp
[    62][    28][    27][     7][     6][     1][    28] - z_ping_buffer.cpp
[    45][    24][    24][    10][    10][     0][    11] - n_network.cpp
-------------------------------------------------------- - totals
[ 46055][ 33720][ 28587][  8519][  3386][  5133][  8949] - 44 files

done!!!!...

just for comparison, what does code blocks say?

47 files
45856 - total
26651 - code only
 4834 - code and comment
 8899 - blank
 5472 - comment

manually add
26651 - code only
 4834 - code and comment
-------
31485

what files does it get that I don't




got to move on.....






make sure all logging entries throughtout the code have appropriate if statements
list them...


extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_game_move;
extern int LOG_NET_sdat;
extern int LOG_NET_sdak;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_show_dif1;
extern int LOG_NET_show_dif2;

--------------------------------------------------------
LOG_NET [10]
--------------------------------------------------------

8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()


6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()


1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()




   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }


   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }


   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }



1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL

server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked



--------------------------------------------------------
LOG_NET_player_array [26]
--------------------------------------------------------
1 x server_control() [26]

--------------------------------------------------------
LOG_NET_bandwidth [23][24]
--------------------------------------------------------
1 x process_bandwidth_counters() [23][24]

--------------------------------------------------------
LOG_NET_cdat [35]
--------------------------------------------------------
1 x server_proc_cdat_packet() [35]
1 x proc_player_input() // when client sends cdat [35]

--------------------------------------------------------
LOG_NET_game_move
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdat
--------------------------------------------------------
not used

--------------------------------------------------------
LOG_NET_sdak
--------------------------------------------------------
not used


--------------------------------------------------------
LOG_NET_stdf
--------------------------------------------------------
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]
1 x client_process_stdf_packet() dif decompressed [27]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]
1 x server_proc_stak_packet() [30]

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   //---------------------------------------
   // server new game
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", frame_num);
      add_log_entry2(27, 0, msg);
   }



--------------------------------------------------------
LOG_NET_stdf_all_packets
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received [28]
1 x server_send_stdf() // when sending an individual stdf packets to a client [28]


1 x client_timer_adjust() [36]
   sprintf(msg, "timer adjust dsync[%3.2f] offset[%3.2f] fps_chase[%3.2f]\n", players1[p].dsync*1000, players1[p].client_chase_offset*1000, fps_chase);
   if (LOG_NET_stdf_all_packets) add_log_entry2(36, p, msg);

1 x ping_array_add() [37]
   sprintf(msg, "ping [%3.2f] avg[%3.2f]\n", ping*1000, players1[p].ping_avg*1000);
   if (LOG_NET_stdf_all_packets) add_log_entry2(37, p, msg);

--------------------------------------------------------
LOG_NET_stdf_when_to_apply
--------------------------------------------------------
1 x client_apply_diff() [29]
   sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);



--------------------------------------------------------
LOG_NET_show_dif1
--------------------------------------------------------
all in fnx

--------------------------------------------------------
LOG_NET_show_dif2
--------------------------------------------------------
all in fnx

void show_state_dif(char *a, char *b) 430 lines..has not been used in a while....

maybe its time for all that to go away.....gone...now remove the LOG_NET...done...


what about the ping... what is it used for??
is it only for ping_graph?

Make this list also show the log entry type number....
also removed game_move, sdat, sdak...











---------------------------------------------------------------------------------
-------------   The official list of how logging works: -------------------------
---------------------------------------------------------------------------------
extern int LOG_NET;
extern int LOG_NET_join;
extern int LOG_NET_player_array;
extern int LOG_NET_bandwidth;
extern int LOG_NET_cdat;
extern int LOG_NET_stdf;
extern int LOG_NET_stdf_all_packets;
extern int LOG_NET_stdf_when_to_apply;
extern int LOG_NET_client_ping;
extern int LOG_NET_client_timer_adj;
extern int LOG_NET_server_rx_stak;

--------------------------------------------------------
LOG_NET [10] [both]
--------------------------------------------------------
8 x  ClientInitNetwork()
1 x ClientExitNetwork()
2 x client_init()
3 x client_proc_player_drop()

6 x ServerInitNetwork()
4 x ServerListen()
1 x ServerExitNetwork()
3 x server_init()
3 x server_proc_player_drop()

1 x proc_player_active_game_move()
3 x proc_player_inactive_game_move()

   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (program_state == 22)
   if (LOG_NET)
   {
      sprintf(msg,"LEVEL %d STARTED", play_level);
      add_log_entry_header(10, 0, msg, 3);
   }

   //---------------------------------------
   // 12 - level done
   //---------------------------------------
   if (program_state == 12)
   {
      if (LOG_NET) { sprintf(msg,"NEXT LEVEL:%d", next_level); add_log_entry_header(10, 0, msg, 3); }

      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

   //---------------------------------------
   // server new game
   //---------------------------------------
   if (program_state == 20)
   {
      if (LOG_NET)
      {
         sprintf(msg,"LEVEL %d STARTED", play_level);
         add_log_entry_header(10, 0, msg, 3);
      }

1 x void proc_player_health(int p)
{
      sprintf(msg,"PLAYER:%d DIED!", p);
      if (LOG_NET) add_log_entry_header(10, 0, msg, 1);


--------------------------------------------------------
LOG_NET_join [11] [both]
--------------------------------------------------------
client tx cjon
client rx sjon
client rx sjon SERVER FULL
server rx cjon
server tx sjon
server tx sjon SERVER FULL
server client has locked

--------------------------------------------------------
LOG_NET_player_array [26] [server]
--------------------------------------------------------
1 x server_control()

--------------------------------------------------------
LOG_NET_bandwidth [23][24] [both]
--------------------------------------------------------
1 x process_bandwidth_counters()

--------------------------------------------------------
LOG_NET_cdat [35] [both]
--------------------------------------------------------
1 x server_proc_cdat_packet()
1 x proc_player_input()

--------------------------------------------------------
LOG_NET_stdf [27][29] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() dif received and decompressed [27]
1 x client_apply_diff() reset base [27]
1 x client_apply_diff() dif cannot be applied [29]
1 x client_apply_diff() dif applied [29]

1 x server_send_stdf() send all stdf packets [27]
2 x server_rewind() // once when rewinding to prev state, once when setting new state [27]

   //---------------------------------------
   // 12 - level done [27]
   //---------------------------------------
   //---------------------------------------
   // server new game [27]
   //---------------------------------------
   // set server initial state (for both 2-new game and 5-level done when server)
   game_vars_to_state(srv_stdf_state[1]);
   srv_stdf_state_frame_num[1] = frame_num;
   if (LOG_NET_stdf)
   {
      sprintf(msg, "stdf saved server state[1]:%d\n", frame_num);
      add_log_entry2(27, 0, msg);
   }

--------------------------------------------------------
LOG_NET_stdf_all_packets [28] [both]
--------------------------------------------------------
1 x client_process_stdf_packet() // when any stdf packets is received
1 x server_send_stdf() // when sending an individual stdf packets to a client

--------------------------------------------------------
LOG_NET_stdf_when_to_apply [29] [client]
--------------------------------------------------------
1 x client_apply_diff()

--------------------------------------------------------
LOG_NET_client_timer_adj [36] [client]
--------------------------------------------------------
1 x client_timer_adjust()

--------------------------------------------------------
LOG_NET_client_ping [37] [client]
--------------------------------------------------------
1 x ping_array_add()

--------------------------------------------------------
LOG_NET_server_rx_stak [30] [server]
--------------------------------------------------------
1 x server_proc_stak_packet() [30]


the only area that I still am not sure about is 27 and 29 for stdf...
a lot of these things all fall under the stdf blanket...
but it would be nice to have the option of not filling the log with unneeded stuff...

what is the point of logging that dif was received if I don't say if it was successfully appllied?



here is what I would like to see in great detail:

1 - server decides to make new dif (this is when the base it uses comes due)

2 - server rewinds to previous saved state

3 - server plays back a set number of frames (and applies all late input)

4 - server saves a new state

5 - server plays a set number of states to get back to where it was originally

6 - server set a flag to send stdf

7 - goes back into the game loop and continues the current frame (processes input, moves frame, draws frame, then sends stdf to clients)

why the delay here? why can't I send it sooner?
I am already delayed by having to rewind and make a new state....
Nothing in the state I am sending will change by playing this current loop....

The way I am doing it now is waiting for the worst possible time to do that.

I have waited for the timer to fire, then I send based on the old state
I don't even get fresh input...

What I think I should do is: (server only)

play the frame to the end (draw also?) ...no... everything but draw
get all the input
process all the client packets
move the frame...

then...before draw...do the server thing if needed....

rewind, make new state, apply lost stuff (you realize this means you will replay the frame you just played...???)

then send the stdf, then draw...


I just had a thought...what if all I do is send the stdf before I draw?

would that have the same effect??

also if I could process all client input before I make the dif that should be good also....



one at a time....
on the server, when do I process cdats.....
right at the top of the frame...I cannot make that any sooner...

second...
I already send the stdf before draw...

you were saying.....

what about when the client sends pings....literally at the end of the game_loop right before the free time....

could I be rewinding and replaying in the background?...idk

i think it is time for some tests....

ping graph needs 36 and 37 tmaj and ping




show in debug overlay, how much time it took to process the last frame
basically how much free time....
as a percentage...

50% means it took 20ms...

done...


do some more testing....











I would like a scrolling real time graph to show on debug overlay...
oh really, and would you like some gold and silver with that?


come on it will be fun and will look so cool....

make it a class kind of like ping buffer...

all you need to do it pass it values once a frame

then call it to draw itself


it will only keep a certain ammount of history then throw stuff away.


use it to show, ping, dysnc, cpu, draw, move...


1 pixel per frame....


similar to mWgraph

it doesn't even have to have any history...it can just slide over the bitmap and draw a new pixel...

what am I going to call it?

class qGraph

what about the series size, this should be a lot samller than mwGraph...after all it is quick graph...

4 series max
1000 data points max

implicit x axis is frames and should be an int

1000 / 40 = 25 sec

yaxis will be a double

how about

double data[1000][4]

the index is the x axis

or this...

   struct data_series
   {
      double data[1000];
      int active;
      int color1;
      int color2;
      char name[256];
   };
   data_series series[4] = {0};

this expects new data every frame

when it gets data the old data is pushed down one.

draw is called independantly


y axis will be scaled manually or auto
for now lets start with manual...


I will call draw from srceen overlay..done
I will add data at the end of game loop
where am I going to set this up..new game...done


I don't think I want store x and y in the class...just pass x and y with draw...

the object must know its size though

should we put some data in?

it is working!!

in single player what else can I show but cpu??

client can do ping, dysnc, cpu

I think they should be on separate graphs...

make one just for cpu

auto range from 100 to 50 to 25

OK, challenge accepted


make type variable and type 1 == cpu

make y_axis_min, y_axis_max, y_axis_rng

its just fucking beautiful!!
I love it so much!!

cant wait to make it work on client with dsync and ping....

I could still do it on m36...just make something else the server....

OK lets do this...done....


the cpu makes use of the timestamp buffer, which fills up pretty soon...
change it to just use standard timstamps in the main loop....


then try again...

it 11:30 at night....just a little longer....

fixed cpu...now lets get this to as many clients as I can...

11:57 push



20230117 6:0AM

thing are going slower no that I am back to work....

add more options to pm -t
-t   type 1 exe only
-tl  type 2 exe and levels
-tr  type 3 delete everything first and do release
-ta  type 4 abslutely everything

cleaned up this part of the code...works nicely now...

lets do a full release to all...done


not much time...

what graph can I run on client to see what is using all cpu??

profile

level 29 single player on m36

draw from 500 to 800us

move 95% 30us BUT! spikes to 2000 and once to 4000!!!

I need to know what...

did the move_all profiling and found spikes on player (2ms) and enemy (2-4ms)






implement the per enemy and per item timers...

can I use the timer buffer??

I might have 100 thing to time...

put each enemy in a bin...

      timestamps[i].frame0 = 0;
      timestamps[i].frame1 = 0;
      timestamps[i].frame2 = 0;
      timestamps[i].type   = 0;
      timestamps[i].t0     = 0;
      timestamps[i].t1     = 0;
      timestamps[i].t2     = 0;


I think I will precalc each time...


then add a timestamp like
frame0 - current frame
frame1 - enemy number
frame2 - enemy type
t0 - delta time

then at the end, calculate, enter log entry and erase them all...

LOG_TMR_enem added...

I need to know how many enemies cause the number...



It looks like I have a problem with enemy deathcount...
walk through what happens....


enemy killed by player bullet...

void enemy_bouncer(int e)
{
   if (Ei[e][31]) // hit
   {
      enemy_killed(e);
      return; // to stop rest of execution
   }

in enemy killed:
Ei[e][0] = 99; // set type to death loop


in enemy_move:
case 99: enemy_deathcount(e); break;


void enemy_deathcount(int e)
{
   int EXint = al_fixtoi(Efi[e][0]);
   int EYint = al_fixtoi(Efi[e][1]);
   Efi[e][14] += Efi[e][13]; // rot inc
   Efi[e][12] = al_fixmul(Efi[e][11], Efi[e][12]); // scale inc

   Efi[e][0] += Efi[e][2]; // xinc
   Efi[e][1] += Efi[e][3]; // yinc

   Ei[e][1] = zz[0][ Ei[e][3] ]; // draw current ans shape
   // dec and check countdown timer
   if (--Ei[e][30] < 0) // create bonus
   {
      Ei[e][0] = 0; // kill enemy
      for (int c=0; c<500; c++)
         if (item[c][0] == 0) // find empty
         {
            for (int y=0; y<16; y++) item[c][y] = 0; // clear item
            item[c][0] = 2;           // type - bonus
            item[c][1] = Ei[e][24];  // flower shape
            item[c][2] = 1; // draw mode normal
            item[c][3] = -1; // carryable
            item[c][4] = EXint;
            item[c][5] = EYint;
            item[c][6] = 1; // bonus type 1 - health
            item[c][7] = Ei[e][25];  //  life
            item[c][8] = 0;

            item[c][14] = 800; // time to live

            itemf[c][0] = al_itofix(item[c][4]);
            itemf[c][1] = al_itofix(item[c][5]);
            itemf[c][2] = al_itofix(0);
            itemf[c][3] = al_itofix(0);
            break; // end loop
         }
   }
}

looks like its only the first frame of 99...

tmst arch:[0.3217] cann:[0.3111] trak:[0.6000] clon:[0.1750] flap:[0.4810]
tmst arch:[0.3043] cann:[0.3444] trak:[0.7000] clon:[0.1500] flap:[0.4333]
tmst arch:[0.3522] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6050] dth1:[1600.6000]
tmst arch:[0.2957] cann:[0.3333] trak:[0.7000] clon:[0.2000] flap:[0.5050] dth1:[0.1000]
tmst arch:[0.3000] cann:[0.3111] trak:[0.6000] clon:[0.1500] flap:[0.4800] dth1:[0.1000]
tmst arch:[0.4174] cann:[0.5000] trak:[0.8000] clon:[0.3250] flap:[0.5750] dth1:[0.3000]
tmst arch:[0.3565] cann:[0.3556] trak:[0.7000] clon:[0.1750] flap:[0.5400] dth1:[0.1000]
tmst arch:[0.3261] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3087] cann:[0.3444] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.2000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.8000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3444] trak:[0.6000] clon:[0.2000] flap:[0.4750] dth1:[0.1000]
tmst arch:[0.3609] cann:[0.3667] trak:[0.7000] clon:[0.2000] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3222] trak:[0.8000] clon:[0.1250] flap:[0.5300] dth1:[0.1000]
tmst arch:[0.3783] cann:[0.4333] trak:[0.9000] clon:[0.3750] flap:[0.6400] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.3778] trak:[0.6000] clon:[0.1750] flap:[0.5350] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3667] trak:[0.7000] clon:[0.1500] flap:[0.5250] dth1:[0.1000]
tmst arch:[0.3565] cann:[0.4222] trak:[0.7000] clon:[0.2000] flap:[0.5000] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3889] trak:[0.8000] clon:[0.1750] flap:[0.5450] dth1:[0.1000]
tmst arch:[0.3174] cann:[0.3667] trak:[0.7000] clon:[0.1750] flap:[0.5000] dth1:[0.1000]
tmst arch:[0.3348] cann:[0.3889] trak:[0.7000] clon:[0.2250] flap:[0.5500] dth1:[0.2000]
tmst arch:[0.3391] cann:[0.3778] trak:[0.7000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst arch:[0.3913] cann:[0.4556] trak:[0.8000] clon:[0.2750] flap:[0.6200] dth1:[0.2000]
tmst arch:[0.3304] cann:[0.3444] trak:[0.6000] clon:[0.1750] flap:[0.5100] dth1:[0.1000]
tmst mpty:[0.2000] arch:[0.3000] cann:[0.4000] trak:[0.7000] clon:[0.2250] flap:[0.6500]
tmst arch:[0.3217] cann:[0.3556] trak:[0.6000] clon:[0.1750] flap:[0.5000]
tmst arch:[0.3304] cann:[0.3667] trak:[0.8000] clon:[0.1750] flap:[0.6050]

I think it might be one of these....

//      if (ht == 1) game_event(60, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 2) game_event(62, 0, 0, Ei[e][26], e, 0, 0);
//      if (ht == 3) game_event(64, 0, 0, Ei[e][26], e, 0, 0);


3 should not exist...field


         case 60: case 62: case 64: // enemy killed
            al_play_sample(snd[8], 0.5, 0, 1.2, ALLEGRO_PLAYMODE_ONCE, NULL);
         break;



its definitely in bmsg...not the sound part though...

is it every call to create new bmsg??.. i think it is...disable this bullshit and see what happens...

much better... now lets try a busy level...

copy all to clients

now I found that drawing the screen overlay takes almost 25ms on 4230 ClientSend
on e6430 it only takes 2.5ms


there are definitely some things to look at....

can I make screen overlay take less?
how much do graphs take?


bottom msg
why does it take so much when creating a new one?
displaying them all does not take so much...



gtg its linzies 18th!!

20230118 6:45AM



run profile graph with screen overlay on/off

could it be that the temp_bitmap created is a memory bitmap??

won't know till I profile...







made profiling page in settings
button to open most recent graph
button to run game from that page
done


some duplicate labels are messing up profile graphs...

all draw have d- prefix
all move have m- prefix
all move enemy now have m- prefix


all profile to add new bmsg




making sounds have its own header...


moved all externs and function prototypes to  .h

// ------------------------------------------------
// ---------------- sound -------------------------
// ------------------------------------------------
extern ALLEGRO_VOICE *voice;
extern ALLEGRO_MIXER *mn_mixer;
extern ALLEGRO_MIXER *se_mixer;
extern ALLEGRO_MIXER *st_mixer;
extern ALLEGRO_SAMPLE *snd[20];
extern ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
extern ALLEGRO_AUDIO_STREAM *pm_theme_stream;
extern int fuse_loop_playing;
extern int sample_delay[8];
extern int st_scaler;
extern int se_scaler;
extern int lit_item;
extern int sound_on;

// z_sound.h
void start_music(int resume);
void stop_sound(void);
void proc_sound(void);
void load_sound(void);
void set_se_scaler(void);
void set_st_scaler(void);
void sound_toggle(void);



moved all declarations to sound.cpp

ALLEGRO_VOICE *voice = NULL;
ALLEGRO_MIXER *mn_mixer = NULL;
ALLEGRO_MIXER *se_mixer = NULL;
ALLEGRO_MIXER *st_mixer = NULL;
ALLEGRO_SAMPLE *snd[20];
ALLEGRO_SAMPLE_INSTANCE *sid_hiss;
ALLEGRO_AUDIO_STREAM *pm_theme_stream;
int fuse_loop_playing;
int sample_delay[8];
int se_scaler=5;
int st_scaler=5;
int lit_item;
int sound_on = 1;


then every file that needs access includes z_sound.h

that seems to work good.....

did the same with z_log...




I am profiling bmsg...

add 1.4-2.2ms
draw 7us


now lets try to change somethings...

see what type of bitmap is created...


there is a global variable:
ALLEGRO_BITMAP *bmsg_temp;

every time new_bmsg is called:
bmsg_temp = al_create_bitmap(800, 20); // create a temp bitmap to build a single line
al_destroy_bitmap(bmsg_temp); // destroy the temp bitmap

why do I bother?? it is always the same size...
bitmap flags:
ALLEGRO_VIDEO_BITMAP
ALLEGRO_NO_PRESERVE_TEXTURE

I will try to create it in create bitmap

still 1.6 to 1.9ms

next....

maybe its my dtextout...does nothing except double text size, but it uses a temp bitmap...

comment out and speed test..still 1.1 to 1.3...


how about instead of all these temp bitmaps, I just draw on the final...pass a pointer to it to al the subfunctions


al_set_target_bitmap(bmsg_bmp[bmsg_index]);
al_clear_to_color(al_map_rgb(0, 0, 0));

//al_draw_bitmap(bmsg_temp, (400 - (bmsg_length/2)), 0, 0); same as 0

al_convert_mask_to_alpha(bmsg_bmp[bmsg_index], al_map_rgb(0, 0, 0)) ;
al_set_target_backbuffer(display);


so just pass (bmsg_bmp[bmsg_index]);

I don't think that was what was slowing it down

I think it was:
- the dtextout using a temp bitmap to doubel text size
- the call to set alpha..

i fixed the text thing by creating another font that is size 16..
have not figured out the alpha yet...

i think I need to bring bacj the temp bitmap, if for no other reason than:
I need to make it centered, but can't do that until I am finished drawing...
like I said, I dont think that was the bottleneck...

changed from
al_clear_to_color(al_map_rgb(0, 0, 0));
to
al_clear_to_color(al_map_rgba(0, 0, 0, 0));

now it works better...


first add spikes to 700us then around 100-150us...10x better...

not sure why first one is different

print bmsg when adding and compare to profile graph...


why when I draw a tile it takes ~6us but when I draw text, it takes ~100us

it makes no sense to me...



when I use the built in 8x8 font I get the first spike to 50us then around 10-15us

maybe the problem all along has been the truetype font

can I convert it to a bitmap type font?


I sure as fuck am going to try...

first of all print the pristine char set...



I only care about 32-127


now that I have done that, they seem to draw very fast....
no big spike on start, max for everything in add bmsg is 34us..draw text is typically 10us
I am very happy with that...I'll need to put it all back together

put the code here in the comments for future reference...




//   convert pristine ttf font to bitmap font so I can draw it faster 16x16 version



   ALLEGRO_BITMAP *b = al_create_bitmap(290, 110);
   al_set_target_bitmap(b);

   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);

   al_clear_to_color(bg1);

   int y = 2;
   for (int b=32; b<128; b+=16)
   {
      int x = 2;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*18, y, x+a*18+16, y+16, bg2);
         al_draw_textf(font2, t, x+a*18, y, 0, "%c", a+b);
      }
      y+=18;
   }

   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);

   al_save_bitmap("bitmaps/Pristine_16.bmp", b);


   al_flip_display();
   tsw();



//   convert pristine ttf font to bitmap font so I can draw it faster 8x8 version
//
//   ALLEGRO_BITMAP *b = al_create_bitmap(162, 62);
//   al_set_target_bitmap(b);
//
//   ALLEGRO_COLOR bg1 = al_map_rgb(255, 0, 0);
//   ALLEGRO_COLOR bg2 = al_map_rgb(0, 0, 0);
//   ALLEGRO_COLOR t = al_map_rgb(255, 255, 255);
//
//   al_clear_to_color(bg1);
//
//   int y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//   al_set_target_backbuffer(display);
//   al_draw_bitmap(b, 0, 0, 0);
//
//   al_save_bitmap("bitmaps/new_p_8.bmp", b);
//
//
//   al_flip_display();
//   tsw();
//
//
//   ALLEGRO_BITMAP* tmp234 = al_load_bitmap("bitmaps/new_p_8.bmp");
//   if (!tmp234) m_err((char*)"Can't load bitmaps//new_p_8.bmp");
//   else
//   {
//      al_destroy_font(font);
//      int ranges[] = {32, 127};
//      font = al_grab_font_from_bitmap(tmp234, 1, ranges);
//      if(!font) m_err("Failed to load font from bitmaps/Pristine.ttf");
//      al_destroy_bitmap(tmp234);
//   }
//
//
//   al_set_target_backbuffer(display);
//   al_clear_to_color(bg2);
//   al_flip_display();
//
//   y = 2;
//   for (int b=32; b<128; b+=16)
//   {
//      int x = 2;
//      for (int a=0; a<16; a++)
//      {
//         al_draw_filled_rectangle(x+a*10, y, x+a*10+8, y+8, bg2);
//         al_draw_textf(font, t, x+a*10, y, 0, "%c", a+b);
//      }
//      y+=10;
//   }
//
//
//
//
//   al_flip_display();
//   tsw();
//
//




OK that should be done for now....

I have other things to profile...like screen overlay...lets see if that got any better now that I have fonts fixed....





20230120 2:00AM
profile screen overlay..


make a way to disable bmg in settings...done
hostname is not getting saved...done




on m36 as client
cpu 120us
sync 230us
cbuttons 43us


none of that seems excessive....


I want to know what happens when player paused due to death...

scrn overlay takes a huge hit in jq...
why don't I get jq when clients join quit?? i do...

what can I do to make jq faster??

5ms then 1.5, 1.5, 1.5 then 5ms
spikes once to 6.7 at start and end..

its that fucking convert mask to alpha!!
265us spike then 35 then 164 spike near end...

why is it sooo slow? why do I need it?

same thing as bmsg....

old:
al_clear_to_color(al_map_rgb(0,0,0));
al_draw_text(font0, palette_color[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);
al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

new:
al_clear_to_color(al_map_rgba(0,0,0,0));
al_draw_text(font0, palette_color[col], sw/2, 0, ALLEGRO_ALIGN_CENTRE, txt1);

now it is transparent and really fast...



find all occurances of: al_convert_mask_to_alpha and see if they are needed...

25 matches...

ignore one that are not in a fast loop..
6 in bitmap.cpp
4 in file when loading from file..
7 in logo
mw_text for 'created by' fixed...
title..fixed

2 x void draw_large_text_overlay(int type, int color)..fixed
3 x void idw(int txt, int x, int y, float x_scale, float y_scale)

some when loading my new fonts...can I do that before I save?
does not seem to save in bmp format, i still need to call

al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)) in bmp after loading and before loading font from it...

here is my new routine:

void convert_ttf_to_bitmap_font(const char* ttf_filename, const char* bmp_filename, int char_size)
{
   // converts ttf fonts to bitmap font to draw faster and have consistant size
   sprintf(msg, "bitmaps/%s", ttf_filename);
   ALLEGRO_FONT *cf = al_load_ttf_font(msg, char_size, ALLEGRO_TTF_NO_KERNING | ALLEGRO_TTF_MONOCHROME | ALLEGRO_TTF_NO_AUTOHINT);
   if(!cf)
   {
      sprintf(msg, "Failed to load font from bitmaps/%s", ttf_filename);
      m_err("Failed to load font from bitmaps/Pristine.ttf");
   }
   else printf("loaded font %s\n", msg);

   int bw = 1;                 // border width
   int step0 = char_size+bw;   // step size between char
   int step1 = char_size;      // char size
   int bmp_w = (16 * step0) + bw;
   int bmp_h = (6  * step0) + bw;

   ALLEGRO_BITMAP *b = al_create_bitmap(bmp_w, bmp_h);
   al_set_target_bitmap(b);

   al_clear_to_color(al_map_rgb(255, 0, 0));  // set entire bitmap to red, this will be the background color separating the glyphs

   int y = bw;
   for (int b=32; b<128; b+=16)
   {
      int x = bw;
      for (int a=0; a<16; a++)
      {
         al_draw_filled_rectangle(x+a*step0, y, x+a*step0+step1, y+step1, al_map_rgb(0, 0, 0)); // clear glyph background
         al_draw_textf(cf, al_map_rgb(255, 255, 255), x+a*step0, y, 0, "%c", a+b);
      }
      y+=step0;
   }
   al_convert_mask_to_alpha(b, al_map_rgb(0, 0, 0)); // does not actually save in bmp format :(
   al_set_target_backbuffer(display);
   al_draw_bitmap(b, 0, 0, 0);
   sprintf(msg, "bitmaps/%s", bmp_filename);
   al_save_bitmap(msg, b);
   al_destroy_font(cf);
}

convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_8.bmp", 8);
convert_ttf_to_bitmap_font("Pristine.ttf", "Pristine_16.bmp", 16);

and here is how I load them...

   ALLEGRO_BITMAP* tmp = al_load_bitmap("bitmaps/Pristine_8.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_8.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font);
      int ranges[] = {32, 127};
      font = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font) m_err("Failed to load font from bitmaps/Pristine_8.bmp");
      al_destroy_bitmap(tmp);
   }

   tmp = al_load_bitmap("bitmaps/Pristine_16.bmp");
   if (!tmp) m_err((char*)"Can't load bitmaps//Pristine_16.bmp");
   else
   {
      al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;
      al_destroy_font(font2);
      int ranges[] = {32, 127};
      font2 = al_grab_font_from_bitmap(tmp, 1, ranges);
      if (!font2) m_err("Failed to load font from bitmaps/Pristine_16.bmp");
      al_destroy_bitmap(tmp);
   }


back to looking for al_convert_mask_to_alpha(tmp, al_map_rgb(0, 0, 0)) ;

should be all good...

I have a couple of functions that are not used anymore:

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col);
void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col);

ill list them here then delete them...



/*

void mtextout(char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // can show mirror image text when scales are negative
   // used only mdw logo animation
//   int sw = strlen(txt1) * 8;      // string length in pixels
//   int sh = 8;                     // string height in pixels


   int bbx1, bby1, bbw1, bbh1;
   al_get_text_dimensions(f1, txt1, &bbx1, &bby1, &bbw1, &bbh1);

//   printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);

   // scale the scale...
   x_scale *=  24 / (float) al_get_font_line_height(f1);
   y_scale *=  24 / (float) al_get_font_line_height(f1);

   int sw = bbw1;
   int sh = bbh1;



   ALLEGRO_BITMAP *temps = NULL;
   temps = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temps);
   al_clear_to_color(al_map_rgb(0,0,0));


//   al_draw_text(font,palette_color[col], 0, 0, 0, txt1 );

   al_draw_text(f1, palette_color[col], 0-bbx1, 0-bby1, 0, txt1);


   al_convert_mask_to_alpha(temps, al_map_rgb(0, 0, 0)) ;


   int flags = 0;
   if (x_scale < 0) flags |= ALLEGRO_FLIP_HORIZONTAL;
   if (y_scale < 0) flags |= ALLEGRO_FLIP_VERTICAL;

   // offset x pos if scale is negative
   if (x_scale < 0) x -= abs( (int) ((float)sw * x_scale) );

   // offset y pos if scale is negative
   if (y_scale < 0) y -= abs( (int) ((float)sh * y_scale) );

   al_set_target_backbuffer(display);
   al_draw_scaled_rotated_bitmap(temps, 0, 0, x, y, fabs(x_scale), fabs(y_scale), 0, flags);
   al_destroy_bitmap(temps);
}

void mtextout_centre(const char *txt1, int x, int y, float x_scale, float y_scale, int col)
{
   // used only by bottom message and level done
   int sw = strlen(txt1) * 8;      // string length in pixels
   int sh = 8;                     // string height in pixels

   ALLEGRO_BITMAP *temp = al_create_bitmap(sw,sh);
   al_set_target_bitmap(temp);
   al_clear_to_color(al_map_rgb(0,0,0));

   int dw = (int) ((float)sw * x_scale);
   int dh = (int) ((float)sh * y_scale);

   al_draw_text(font, palette_color[col], 0, 0, 0, txt1);
   al_convert_mask_to_alpha(temp, al_map_rgb(0, 0, 0)) ;

   al_set_target_backbuffer(display);
   al_draw_scaled_bitmap(temp, 0, 0, sw, sh, x-dw/2, y, dw, dh, 0);

   al_destroy_bitmap(temp);
}
*/


20230120 7:00AM

well I think I have that sorted out...


now back to things that were slowing down on profile...


I was in client with the three things in screen overlay...


240us sync_ping
130us CPU
100   client grid
90    debug common
44    cbuttons
it all adds up to about 700us


when running as client everything added up (cpu) takes about 1ms, draw and move

if i turn off the debug overlay everything is around 400us





clients still around 90-100%

ran the profile graph on a client and 22ms spent in draw and 17 was screen overlay


what to do about that?

make it adjustable somehow. I want to see cpu

sync 7ms
cpu 4ms
c_grid 2.3
dbug_com 1.5

the width of the qGraph determines how many points are drawn...
right now I am using 200 for width which gives me 5s

should I make this adjustable?

set ranges based on how large the screen is?

I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...


20230221 5:00AM
pm -? show commandline options...done




show_debug_overlay to have more options:

0-off
1-minimal
2-medium
3-all

mimimal
cpu only

medium
cpu and sync (client only)

all


make list of things that can be shown:
- cpu
- client sync and ping
- client grid
- server grid

common list of text
more list of text...






I notice big swings in the cpu, when running server but cant see in move or draw
probably server send stdf...

should add cpu to logging...

also sdif seems to be working but when it isnt called and the point is missing on the graph.
my graph just draw a straight line over it.

I could fix by forcing to add a point on a frame when no stdf was sent...

the way I have it now is is only measures send to one client...
and it only add a log entry when it actually sends...
what I want to do is move it to here:

from loop:
if (players1[0].server_send_dif) server_send_stdf();

and add a log entry every frame...
that way I will get the total time, and zero's when nothing happens

between this and rewind, I should have all the main server stuff profiled...done


log cpu (total time spent processing each frame)

calc where?

right now screen_overlay does it...is this what I want??
this is not actually at the end of the frame is it?
no...it is at the end of loop where it is added to qG

            if (proc_frame_skip()) draw_frame();

            double pt = al_get_time() - timestamp_frame_start;
            double cpu = (pt/0.025)*100;
            qG[0].add_data(0, cpu);

literally the last thing...
this is where I should add the log entry also...
LOG_TMR_cpu

done...


ready for some more tests??
looking good...

bug..why does it fail at level done when trying to load next level and getting level 0?

it looks like next_level is only set when player touches exit or warp...
I think some clients are missing this...

fix when I get back....

got to go to a first aid class on a saturday...oh well..8H OT..

push..





20230121 4:30PM
moved all settings related stuff to z_settings.cpp and z_settings.h

e_mWindow.h done
z_player.h done


now I am down to 1300 lines in pm.h...little by little, I am chipping away at it....


added to player array:

   int level_done_next_level;

find occ of next_level and replace with players[0].level_done_next_level....done

that should fix that....


I think I am back to the testing part of things....
send out to all


the dsync on clients has a bit of a strange pattern

on e6430 one peak at +60-500us then a few at -2.3ms

on 4230 4 around +1ms then 1 at -15ms

why is this happening?

what does it all mean?

what happens on a pattern of 5 frames?

I think its the timer adjust...the patterns match...

can I make it less aggressive....



I am dealing with very small values here...

I have usually kept fps at 40 and set timer with 1/40

I could just as easily set timer with 0.025

1 / 40.00 = 0.0250000
1 / 40.10 = 0.024937
            0.000063 or 63us

1 / 40.00 = 0.0250000
1 / 40.01 = 0.0249937
            0.0000063 or 6.3us

my adjustments seem really small


maybe I need to print all the numbers used in my calc

make a new log entry for now...temp...









I want to make a PID loop...


I have an output I can measure: dsync
I have a setpoint I am trying to achieve: offset
I have a variable I can use to control the process: fps


first of all I want to graph these...
then I will try to plug in a new PID algorithm


make a new graph just for this....
client only

in the interests of it all fitting on the same graph I will use fps_adjust as my control

and I will make fps adjust the value added or subtracted to 0.025....

all my values will be in ms to 3 deciaml places...

make a new log entry...done...


now I can easily plot...

   float mv = players1[p].dsync;                 // measured value
   float sp = players1[p].client_chase_offset;   // set point
   float err = sp - mv;                          // error = set point - measured value



my control loop currently is just P, err*100 = P

to get the integral I will need a running total...

simply add and subtract the error....

why do I have doubts this will work?

beacuse when it ramps up the I will grow really fast...

2 ways to solve this...
- set limits on i
- gradually decay i


first of all I need a global variable to keep a running total...

done...



what if the problem is that the things I am trying to sync are inherently unstable....

what if I took an average of dsync and used that...


how often do I get dsync?

with every dif so 2-3 frame...


what if I just took a running average, like ping?


I can still show the instantaneous ones, but use the average to set chase speed

this needs to be fast for initial chase though...


try it....



make ping_buffer have a header file and be self contained...then add dsync...

add dsync_avg to player1 array..done


add call when calc



I think I have stumbled upon something amazing...all this bullshit happens when we need 2 packets...

each packet causes its own timer adjust, and one is definitely later than the other...duh...


how can I make it not do that?

have a variable last stdf_packet frame and check it...
already had var...check it now and only do one timer adj per frame based on first stdf rx'd..done

still getting some wild oscilliations


lets also try starting offset at 0 instead of +10ms


set ia to zero.
how long does it take for mv to climb to zero line?
then with overshoot how long to cross back down?

pa = 100
mv  = 748-727 = 21
mv  = 793-727 = 66

mva = 762-727 = 35
mva = 805-727 = 78


pa = 60

mv  = 428-384 = 44
mv  = 456-384 = 72

mva = 442-384 = 58
mva = 471-384 = 87



make client offset update faster at start of chase..
it seems to take a while to actually change off zero...
352-259 = 93 frames

i cant run ping graph...i broks it..fixed
691-622 = 69

still does not seem to send first ping till frame_num>0 (initial state rx?)


this is getting complicated...is is worth it to send pings while still in setup?
while still in setup stdf packets are being processed and timer is being adjusted...
might as well be based on a real setpoint based on a real ping...
while in setup the loop happens very fast and frame_num is not incremented...

need another way to trigger sending pings...


how about in loop, after the main 11 is done, send client ping if flag is set.

then I can set this flag in 11 like normal, and also in setup based on a timer...

if (players1[active_local_player].client_ping_flag)
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

make a new timer png_timer..done...

now the event timer is the only thing that sets the flag...
it works, but still no pings for the first bit...

why the fuck not??

log...
all on frame 0:
got reply
send and rx join
start level..

then on frame 152
152 game state updated
162 tmaj
165
166
172
...
240
243
244 ping!!!

this is a long delay...

also client does not show when they became active??
not in log anyway

so back to the issue at hand:

after client gets initial state, it starts the main loop and and chases, while inactive
there is a long pause here before the first ping is received...

why?


show on console the frames when ping is sent..

191026 initial state
191028 ping
191047 ping
191067 ping
191087 ping
191107 ping
191128 ping

in logs
191108 1st ping received 24ms
191129 2nd ping received 28ms


I am sending them, but it appears that the first 4 are lost??

what a subtle bug!!!
on server, when rxing ping and replying, it looks up who from player_num and fails if player is not active yet!!

int get_player_num_from_who(int who)
{
   for(int p=0; p<NUM_PLAYERS; p++)
//      if ((players[p].active) && (players1[p].who == who)) return p;
      if (players1[p].who == who) return p;
   return -1;
}

still the same

console:
652 initial state
671 ping
691 ping
711 ping
731 ping
752 ping

log
732 1st ping
753 2nd ping

still missing first 4 pings...


more console logging:

049 init state
069 send ping
089 send ping
109 send ping
129 send ping
130 rx pong
150 tx ping
151 rx pong

as far as I can tell server is not sending reply...

add console logging on server and look into who...


I think I forgot to send most recent compile to server...it works now...


ping graph dumps a bunch of shit to console...fixed

make it so that once init state is rx, do a one time send ping by setting flag...

OK I think I have that one thing figured out....

clean up and move on...

this is how I handle client ping sends:

made a timer:
png_timer = al_create_timer(.5);   // 2 fps

made a variable in player1 array:
players1[].client_ping_flag

when timer event fires:
if (ev.timer.source == png_timer) players1[active_local_player].client_ping_flag = 1;

in the main loop just after every thing else:
if ((players1[active_local_player].client_ping_flag) && (ima_client))
{
   players1[active_local_player].client_ping_flag = 0;
   client_send_ping();
}

in client setup, when initial state is received:
players1[active_local_player].client_ping_flag = 1;

the only thing I might like to add later is a method of slowing the ping timer...
maybe I don't need to...2 packets per second is hardly anything

now I want to make the ping and sync graph easier to use..

first of all...
make a button on logging to load most recent file in log file viewer..done
then remove profile button from that page...done
then put both pages adjacent...done

now, how do I make ping sync graph better?

I can do most stuff with generic profile graph
tmaj and ping

the only nice thing about the specific one is that it has ping also...

make it all use profile...

ping uses 37
old tmaj uses 36

tmr uses 44

do both for now:

LOG_NET_client_timer_adj 36
LOG_NET_client_ping 37

new:
LOG_TMR_client_timer_adj
LOG_TMR_client_ping

now both graphs can co-exist....


after all this messing around, I have not come to any real conclusions

client sync is still pretty much what it used to be...


now can I finally look at what changing s1 and s2 do?


server_rewind is called and it determines if it is time to make a new state and send dif...

if the current frame_num matches the frame_num of the last saved base+s1+s2....

then it is time....

- rewind to the last saved base
- play forward s1 frames
- save new state
- play forward s2 frames




random demo game is very not random...
always starts with trigger...
add this: srand((unsigned) time(&t)); // done
checkbox to test opacity on demo...done
when starting stuff from demo save config first so it comes back to the same page..done



next on my simulation
keep client and server frame numbers different
when server is in rewind do not move client fn...

when server makes new state, jump to clients side and receive and rewind it...



what happens if I set s2 to 0??

LAN seem to work with no issues...
WAN i get a few late cdats and some noticeable corrections

tried s2 == 1
WAN was about the same...






I never use the 4 states in this array:
// server's copy of last stdf state
extern char srv_stdf_state[4][STATE_SIZE];
extern int srv_stdf_state_frame_num[4];

I only ever use [1]


I should remove it and make it a flat array....

do I use all 8 of these?

extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

they are server only, so is 0 unused?

I would have to say I think it is

so for server only iI can use 0

I am currently using:
srv_stdf_state[1]
srv_stdf_state_frame_num[1]

I propose to use:
srv_client_state[0][1]
srv_client_state_frame_num[0][1]

I am 99% sure I can do this...so do it...but doc all that you do....

7 occ of
pm..done
main...done
fnx memset..done

loop: 2 places....
old:
game_vars_to_state(srv_stdf_state[1]);
srv_stdf_state_frame_num[1] = frame_num;

new:
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = frame_num;

server 1:
//frame_num = srv_stdf_state_frame_num[1]; // set rewind frame num
//state_to_game_vars(srv_stdf_state[1]);   // apply rewind state
frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
state_to_game_vars(srv_client_state[0][1]);   // apply rewind state

server 2:
//game_vars_to_state(srv_stdf_state[1]);
//srv_stdf_state_frame_num[1] = frame_num;
game_vars_to_state(srv_client_state[0][1]);
srv_client_state_frame_num[0][1] = frame_num;


4 more in server:
if (frame_num == srv_client_state_frame_num[0][1] + s3)
sprintf(msg, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
if (cdat_frame_num < srv_client_state_frame_num[0][1])
printf("[%d]late cdat dropped p:%d c:%d  state:%d  tally:%d\n", frame_num, p, cdat_frame_num, srv_client_state_frame_num[0][1], players1[p].late_cdats);



it still seems to work...remove all traces...

I would like to put all netgame stuff in its own file...

n_netgame.cpp
n_netgame.h

do it...done...



20230124 6:15AM

I have some thoughts about what I would like to monitor:
I want to be able to see how much the clients need to rewind
in LAN test they are exact or 1






I think I have an idea about what s2 is for..
its so that the difs sent are not the most current







remove from player1 struct??
there is no field anymore...

//   float field_damage_tally;
//   int field_damage_holdoff;
//   int field_damage_enemy_number;




but is it used for other stuff?  like mine or block damage?
idk
yes, used for block damage, but not mine...


game_event(59
called only when block_damage is taking health from player

game_event(57
not called at all

game_event(50
mine collison

convert the bit in health to work with block_damage
OK I fixed all that, but that was not what I planned to do...


I wanted to add client_rewind to player1...done and added to client debug grid...done
LAN always 0 or 1..even when increasing s1 and s2...
WAN always 1 or 2..even when increasing s1 and s2... (ping ~27)



20230125 2:20AM


add some sort of manual sync control to client

Like I can set to manual, or the value for auto..

I want to experiment with changing offset and seeing how my clients rewinds come out..


what variables?, should I put it in settings? yes, and also live control..

players1[p].client_chase_offset

currently set in add ping:

players1[p].client_chase_offset = - players1[p].ping_avg;

also in debug overlay


double client_chase_offset;
double client_chase_offset_auto_offset;
int client_chase_offset_mode; // 0 = manual, 1 = auto

add button /auto/manual done
make button adjust ping offset in that mode..done...

now make a way to view client rewind in real time..I can see it in debug grid just fine...


in LAN mode, if I increase a few ms, I no longer jump from 0 to 1, I stay steady on 1

in WAN mode with a ping of 20-30, if I add or subtract a few I can force mostly 1 or 2 for rewind

what have I learned from this?

idk...


I am trying to figure out the effect of changing client sync offset

what effect does it have on when server receives cdat?  I guess I actually have to press keys to see that!

when client is doing rewind of 2 server say game move sync is 0


s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

I think I am on to something here...

try this with different s1 and s2 values

s1:3 s2:1
crwd sgms
2    0
1    -1
0    -2

s1:3 s2:2
crwd sgms
2    0
1    -1
0    -2

s1:4 s2:2
crwd sgms
2    0
1    -1
0    -2

that did not seem to change anything...
how is sgms calculated?

void server_proc_cdat_packet(double timestamp)
{
   players1[p].server_game_move_sync = cdat_frame_num - frame_num;


what does this tell me?

at what point of sgms are cdats considered late and not applied?
when they are earlier than last saved server state...

lets try to make that happen...

when client moves ahead of server with a positive offset
and sgms gets to -3 then I get late cdat errors...

changing s1 did not seem to affect this...


on client, when I adjust dsync too high it ramps...see if I con find out why...


It looks like my raw calclution of dsync...when it goes over 25, it subtracts 25....

   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   players1[p].client_sync = dst - frame_num;               // crude integer sync based on frame numbers

   if (players1[p].client_last_stdf_rx_frame_num != frame_num)       // this is the first stdf received for this frame
   {
      players1[p].client_last_stdf_rx_frame_num = frame_num;         // client keeps track of last stdf rx'd and quits if too long
      players1[p].dsync = al_get_time() - timestamp;                 // time between when the packet was received into the packet buffer and now
      players1[p].dsync += (double) players1[p].client_sync * 0.025; // add to integer sync in case we are out by a lot
      dsync_array_add();
      client_timer_adjust();
   }


the problem is that csync goes to 1 for only one frame

the problem is much deeper than that....
the client has no way of dealing with a future dif...
it just applies it, and that has the effect of the client jumping forward in time

yes abandon this line of questioning, I don't really care about this case...or do I?

what would happen if I did not apply till the next frame??

I think I have that fixed, and it seems to work...


I need to change to docs...

now why did i do that again?


to see what happens to sgms and crwd...ok let see...


crwd now goes to -1 and -2, never got less than zero before...
sgms now to -3 and -4....

when sgms goes to -3 (in s1:3 s2:1) late cdats happen constantly

lets try changing s2....

when s2 goes to 2 late cdats stop...
then increasing client offset till sgms = 4
late cdats again...

I think I found out something...

s2 affects late cdats...

lets do a grid compare again..

WAN with 20-30ms ping


s1:3 s2:0
offs crwd sgms late cdats
-40  2    0
-15  1    -1  rare
+10  0    -2  constant
+80       -6  game done

s1:3 s2:1
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same
          -6    game done


s1:3 s2:2
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    rare
+54  0/-2 -4    constant
+80  0/-3 -5    same game done


s1:3 s2:3
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3    none
+54  0/-2 -4    rare
+80  0/-3 -5    constant
+86       -6    game done


s1:3 s2:4
offs crwd sgms late cdats
-40  2    0
-15  1    -1
+10  0    -2
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5    rare game done


OK now what if I try changing s1:

leave s2 at 1

s1:1 s2:1
offs crwd sgms late cdats base resets
-40  2    0
-15  1    -1
+10  0    -2   rare
+35  0/-1 -3
+54  0/-2 -4
+80  0/-3 -5



with s1 set at 1, I get constant base resets 7K dif size 7 packets 290kBs or 2.3Mbps
lets just throw this one out...its sending dif every frame...

OK so lets start with the minimum s1 of 2
now around 30kBs or 0.24Mpbs

s1:2 s2:1
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   occ/rare   occ/rare
+35  0/-1 -3   constant   const
+54  0/-2 -4   lost server


s1:2 s2:2
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   rare       const
+50  0/-2 -4   const      const
+55  lost server

s1:2 s2:3
offs crwd sgms late cdats base resets
-40  2    0    0          rare
-15  1    -1   0          rare
+10  0    -2   0          rare
+35  0/-1 -3   0          const
+50  0/-2 -4   rare       const
+55  lost server


redo 3
around 21kBps or 0.17Mbps


s1:3 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    const      0
+40  0/-2 -3    const      occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 rare       0
+25  0/-1 -3    rare       0
+40  0/-2 -3/-4 most       occ
+45  0/-2 -4    const      const
+85 lost server


s1:3 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+15  0    -2/-3 0          0
+25  0/-1 -3    0          0
+40  0/-2 -3/-4 0          occ
+45  0/-2 -4    0          const
+68       -5    const      const
+80 lost server

now do 4
15kBps or 0.12Mbps


s1:4 s2:1
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+20  0    -2/-3 occ        0
+30  0/-1 -3    const      0
+50  0/-2 -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:2
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+40       -3/-4 rare       0
+50       -4    const      0
+65       -4/-5 const      occ
+70       -5    const      const
+95       -6
+110 lost server


s1:4 s2:3
offs crwd sgms  late cdats base resets
-40  2    0     0          0
-15  1    -1    0          0
+10  0    -2    0          0
+50       -4    0          0
+65       -4/-5 rare       occ
+70       -5    const      const
+95       -6
+110 lost server



OK... there is alot of data:

its 7:30 so I don't have time to analyze

very briefly

s1
min:2
best 3-4


s2
min:0
best 1-3

3 2 will probalby be best...

experiment with auto sync at 1/2 round trip ping....



20230126 3:00AM

So see if you can do so sort of summary...

s1
controls the frequency or sending difs
1 sends them every frame, should not use, every dif will be full size
2 sends every other frame, occasional base resets are common
3 base reset are very rare


s2
how much the client can lag server without late cdats..
1-3 works probably use 2..


there are probably other things that these affect, that I have not been able to measure yet
I assume that the longer I take to rewind and resnd, the more jarring the corrections will be..

I need some way of measuring that...


how long from sending a cdat, does the client need to wait before it gets a dif with that cdat...
that sounds so simple, how will I measure it

client rx dif for frame 98-100, current client frame = 102...

client rewinds to 100 and ff 2..

so that worst case is a move made on frame 98 does not get back to client until 102...

something like that, lets look at some real data from a log...

3871 tx cdat
3873 dif applied 3867-3871

just that one line:
3873 dif applied 3867-3871

tells me that at worst case 3873-3867 = 6 frames before making a move and getting the official dif from server

this was in mode 4 3..

try in mode 2 3











side track:

why does server rack up a shitload of base resets, waiting for client to join?

make finer tuning of stdf shit in log

I would like to be able to filter out all unsuccessful dif applied
there are a lot of them

maybe a different tag for succesfull vs unsuccesful

27 and 29


extern int LOG_NET_dif_applied;
extern int LOG_NET_dif_not_applied;

replace
extern int LOG_NET_stdf_when_to_apply;

done...the logging is much more better...



mode 2 3 gets 4...this is better yes?

should I calculate and show on client?


where? when dif applied
saved where?

new var
int client_move_lag;

done...now experimeting with that..
I would assume that lower is better..

I have found that when s1 = 2
I need to adjust offset so dsync is about -12 (half frame) or I get base resets...

should I show somewhere on client the base resets?

I already have players1[p].client_base_resets++; on the server
re use it for clients...done..now in debug grid



so, is that what I should do for offset?  aim for - 1/2 frame??

ping  offset
0-12   -12
12-37  -37


changing the offset changes move_lag also...


I have one setup that should work good but the corrections are quite jarring:
s1:2 s2:2
move_lag:2
dsync +12
sgms -2
no late cdat
no base reset

this one has much less jarring corrections:
s1:2 s2:2
move_lag:3
dsync -12
sgms -1
jno late cdat
no base reset

also good is
s1:3 s2:1
move_lag:5
dsync -35
sgms 0
jno late cdat
no base reset

many settings work
also good
s1:2 s2:1

maybe the move_lag is not all important...
it can be longer, as long as the prediction and the actual are not too far off...

I might just be as good as I can get...

set offset so that dsync is about 12-14 ms independant of ping

figure out how to test on worse networks...

why does reducing s1 cause bad problems on server?
kicks client and wont let new one connect

when the new one tries to connect:
server log shows stak reply that client fails base set, has base from previous game


am I not resetting something on server?
when that happens on server, server resets its copy of client base state to zero..
am I not resetting that on client?


reset_states()
client_state_dif_src = -1; // -1 will never match a frame_num
client_state_dif_dst = -1;

this will mark if we have not received a state yet, or the state is a bad decompress



server keeps old last acked state for client

need to reset that on server when client quits or is dropped....done

changed this:
void client_apply_diff(void)
{
   int p = active_local_player;

   // check if valid dif
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1))
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
//      if (frame_num == 0)
//      {
//         printf("initial state - dif_src:%d dif_dts:%d  cbsfn:%d \n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
//      }
//      if ((client_state_dif_dst > client_state_base_frame_num) || (frame_num == 0)) // stored dif with a new dest, or initial state (frame 0)



      if ((client_state_dif_dst > client_state_base_frame_num)) // stored dif has a newer dest
      {

OK with that cleaned up..back to why reducing s1 is bad...does not seem to be bad any more, maybe test more...


when client does level done and starts new level...
it is not waiting for initial state...that is the way it should be
it is still getting stdfs from last level...? at least it is smart enough not to try tp apply them

on the server, do I need to reset client states at level done??

in level done reset_states is called....

clientlog:
------------------
1    client rx dif from 22122 to 22124
     client says wrong client base and replies with 0 for client base
4    client rx dif from 0-22126
4-10 client doesnt apply...too early
11   client rx dif from 0-3

then we are back on track..


server log:
------------------
22122 tx 22120-22122
22123 rx stak  22122
22124 tx 22122-22124
22125 rx stak  0
22125 server drop player sync>100
22126 tx 0-22126
22127 NEXT LEVEL
3     tx 0-3
4     rx stak 3

then we are back on track..

OK what can I do about this?
nothing right now...its time for work...

20230126 7:37AM
20230127 4:24 AM

why do I want to do something about it? it works
I don't like how the server tries to drop the client


I don't like how the client is still getting difs from the previous level.
It is just a natural consequence of the client being ahead of the server..

What if on the client, I check to see if dif_src is much larger than current frame number?
Won't this also catch initial state? Maybe not...is not initial state dif_src == 0?

if (client_state_dif_src - frame_num > 100)


I have rewritten the client_apply_dif() again..


this time I have front loaded all the tests and added one for  if (client_state_dif_src - frame_num > 100)
it only seems to catch when level done and client is ahead of server...


void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d frame_num:%d\n", client_state_dif_src, frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // stored dif has a newer dest
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }

            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);

               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = frame_num - client_state_dif_dst; // dst compared to current frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));


                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update frame_num and client base frame_num
                  frame_num = client_state_base_frame_num = client_state_dif_dst;

                  // for initial state only
                  if (frame_num == 0) set_frame_nums(client_state_dif_dst);

                  players1[p].client_last_dif_applied = frame_num;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = frame_num - client_state_dif_src;

                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}

this is a log of how it works


[31][1][2272]dif [2267 to 2269] not applied - not newer than current [2269]
[27][1][2273]rx dif complete [2269 to 2271] sync[-2] dsync[-35.9ms] - decompressed
[30][1][2273]dif [2269 to 2271] applied - rewind [2] frames
[31][1][2274]dif [2269 to 2271] not applied - not newer than current [2271]
[27][1][2275]rx dif complete [2271 to 2273] sync[-2] dsync[-36.7ms] - decompressed
[30][1][2275]dif [2271 to 2273] applied - rewind [2] frames
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                              NEXT LEVEL:151                              |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]|                                                                          |
[10][0][2275]+--------------------------------------------------------------------------+
[10][0][0]+--------------------------------------------------------------------------+
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                            LEVEL 151 STARTED                             |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]|                                                                          |
[10][0][0]+--------------------------------------------------------------------------+
[31][1][1]dif is not valid - src:-1 dst:-1
[27][1][2]rx dif complete [2273 to 2275] sync[2273] dsync[56839.2ms] - decompressed
[31][1][2]dif_src is > 100 frames in the future - src:2273 frame_num:2
[31][1][3]dif_src is > 100 frames in the future - src:2273 frame_num:3
[31][1][4]dif_src is > 100 frames in the future - src:2273 frame_num:4
[31][1][5]dif_src is > 100 frames in the future - src:2273 frame_num:5
[31][1][6]dif_src is > 100 frames in the future - src:2273 frame_num:6
[31][1][7]dif_src is > 100 frames in the future - src:2273 frame_num:7
[31][1][8]dif_src is > 100 frames in the future - src:2273 frame_num:8
[27][1][9]rx dif complete [0 to 3] sync[-6] dsync[-136.1ms] - decompressed
[31][1][9]Resetting client base state to zero
[30][1][9]dif [0 to 3] applied - rewind [6] frames
[31][1][10]dif [0 to 3] not applied - not newer than current [3]
[31][1][11]dif [0 to 3] not applied - not newer than current [3]
[27][1][12]rx dif complete [3 to 5] sync[-7] dsync[-168.9ms] - decompressed
[30][1][12]dif [3 to 5] applied - rewind [7] frames
[31][1][13]dif [3 to 5] not applied - not newer than current [5]
[31][1][14]dif [3 to 5] not applied - not newer than current [5]
[31][1][15]dif [3 to 5] not applied - not newer than current [5]
[27][1][16]rx dif complete [5 to 7] sync[-9] dsync[-210.9ms] - decompressed
[30][1][16]dif [5 to 7] applied - rewind [9] frames
[31][1][17]dif [5 to 7] not applied - not newer than current [7]
[31][1][18]dif [5 to 7] not applied - not newer than current [7]
[27][1][19]rx dif complete [7 to 9] sync[-10] dsync[-243.8ms] - decompressed
[30][1][19]dif [7 to 9] applied - rewind [10] frames
[31][1][20]dif [7 to 9] not applied - not newer than current [9]
[31][1][21]dif [7 to 9] not applied - not newer than current [9]
[31][1][22]dif [7 to 9] not applied - not newer than current [9]
[27][1][23]rx dif complete [9 to 11] sync[-12] dsync[-285.9ms] - decompressed



windows wants to do an update so I am going to do a push first


then go through code and make sure dif is not spelled diff
and that state and dif refer to the proper things...


'state' refers the the entire game state, typically put into a char array of size STATE_SIZE
'dif' is when 2 states are subtracted, resulting in the diference between the 2

difs are then compressed, optionally broken into packet sized pieces and sent from server to clients

when a client has all the pieces of a dif, and the state on which it is based,
it applies the dif to its base state, recreating the server state..

                  // update frame_num and client base frame_num
                  frame_num = client_state_base_frame_num = client_state_dif_dst;

removed this... i don't think it ever applies... in the previous line frame_num will be set to something non-zero

                  // for initial state only
            //      if (frame_num == 0) set_frame_nums(client_state_dif_dst);




re did the netgame docs for client_apply_dif()

time for work:

20230127 7:25AM


what do I want to do next?

make the auto offset run at - 1/2 frame

figure out how to test with bad network...








































































































































































































