20221228

New running log of changes to the project...

The old one was over 40,000 lines and 1M char...


do a line count:

24525 code only
8006 empty
4979 comment
4557 code and comment
----------------
42067 total


where do I use proc_controllers?
108 matches

not in client anymore since I removed the blocking...

client does not exit when connection fails...fixed first part...

now what about waiting for initial state from server?

break it on the server and test how client responds

did it not used to say waiting for server in a few places?


I have made a nice way to quit while waiting for initial state....

I should make all the ways to exit from client go to a state that cleans up....i think I did...

client still will not rejoin until program is restarted....fixed...it was a strange issue with packetpos needing to be reset to 0


later make sure that server cleans up at exit like client, and try to restart....

also make sure that TCP still works...



Now I think I am finally ready to try some fast ping packets


OK I have the packet passing...what should I do about it?


when server receives pong do some timing

ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   0.9 ms
ping time:   1.2 ms
ping time:   1.6 ms
ping time:   1.6 ms
ping time:   0.5 ms
ping time:   1.3 ms
ping time:   0.9 ms
ping time:   1.1 ms
ping time:   1.5 ms
ping time:   1.0 ms
ping time:   1.5 ms
ping time:   0.7 ms
ping time:   0.6 ms
ping time:   0.6 ms

this is round trip UDP on LAN

switching to WAN


96.45.15.187


I am going to send the ts with the packet and add client ts also...
how do I add a double to a packet?

I could turn it into a char array like I do with state...


im guessing sizeof double is 8...

double test = 1.23;

memcpy(packetbuffer+pos, test,  8);





   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;




before I do this in a packet, lets just try to do it in a regular way....



void PacketPutDouble(double *d)
{
   memcpy(packetbuffer+packetsize, d, 8);
	packetsize+=8;
}

double PacketGetDouble(void)
{
   double d[2];
   memcpy(d, packetbuffer+packetpos, 8);
	packetpos+=8;
	return *d;
}



use this:
char packetbuffer[1024];

make a function to stick something in it and another fucntion to get it out....




char packetbuffer1[1024] = {0};
int packetsize1 = 0;
int packetpos1 = 0;

void PacketPutDouble1(double d)
{
   double dd[2] = {0};
   dd[0] = d;
   memcpy(packetbuffer1 + packetsize1, dd, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d[2] = {0};
   memcpy(d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d[0];
}

void temp_test(void)
{
   double t0 = 0.000123;
   printf("1 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);

   PacketPutDouble1(t0);
   printf("2 - ps:%d pp:%d sot:%d t0:%f\n", packetsize1, packetpos1, sizeof(t0), t0);


   double t1 = PacketGetDouble1();
   printf("3 - ps:%d pp:%d sot:%d t1:%f\n", packetsize1, packetpos1, sizeof(t1), t1);


this shit works!!!


the problem I was having is that memcopy does not like to be passed plain variables, it wants pointers...
so I made an array of the variable tyope I wanted and only use the first element...

found this:


double in=2.132;
char arr[12] = {};
memcpy(arr,&in,sizeof(in));

char arr2[12] = ...;
double out;
memcpy(&out,arr2,sizeof(out));

void PacketPutDouble1(double d)
{
   memcpy(packetbuffer1 + packetsize1, &d, 8);
	packetsize1+=8;
}

double PacketGetDouble1(void)
{
   double d = 0;
   memcpy(&d, packetbuffer1 + packetpos1, 8);
	packetpos1+=8;
	return d;
}

that works too!

now put it in the packets....done...

now try


C:\pm>pm -s

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Local address of channel:24785
Network initialized - channel mode (UDP)
Server successfully initialized

Server received initial 1234 packet from '192.168.1.116:24785'
Server opened channel for `192.168.1.116:24785' and sent reply
ping time:   0.7 ms
ping time:   0.7 ms
ping time:   0.4 ms
ping time:   1.3 ms
ping time:   0.3 ms
ping time:   1.1 ms
ping time:   1.0 ms
ping time:   1.2 ms
ping time:   0.4 ms
ping time:   0.8 ms
ping time:   0.4 ms
ping time:   1.1 ms
ping time:   0.4 ms
ping time:   0.6 ms
ping time:   0.5 ms
Shutting down the server


now try internet:


Server received initial 1234 packet from '70.75.228.155:24785'
Server opened channel for `70.75.228.155:24785' and sent reply
ping time:  30.6 ms
ping time:  25.7 ms
ping time:  21.7 ms
ping time:  26.7 ms
ping time:  20.7 ms
ping time:  31.1 ms
ping time:  26.3 ms
ping time:  27.9 ms
ping time:  24.1 ms
ping time:  27.8 ms
ping time:  25.9 ms
ping time:  35.6 ms
Shutting down the server


OK I've got something

now try TCP

Purple Martians Version 7.24.1
Allegro Version: 5.2.7.1
System ID: Windows
Desktop Resolution: 3840x2160
Network initialized - connection mode (TCP)
Server successfully initialized

Connection received from 70.75.228.155:63272
ping time:  34.1 ms
ping time:  48.3 ms
ping time:  24.3 ms
ping time:  23.1 ms
ping time:  23.7 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  28.8 ms
ping time:  26.4 ms
ping time:  27.4 ms
ping time:  32.7 ms
ping time:  25.6 ms
ping time:  30.6 ms
ping time:  28.6 ms
ping time:  31.7 ms
ping time:  70.3 ms
Shutting down the server

not that much of a difference...

Now how can I use this to monitor and adjust timing..

Now that I can receive stdf any time, I want to know exactly when I am receiving them

this will be a client thing

when client gets an stdf, compare to the latest frame start

it was about 23ms after frame start...

soon, timestamp fills up.. I should make one global timestamp called frame_start....
I am amazed at how stable the timer is, fps adjust very rarely has anything to do...

now lets try fine tuning the sync...


I can get it down to 5-10 instead of 22 with fine tuning, but it does not make the game more playable on WAN
LAN still looks great

the problem on WAN is the corrections make it look really jumpy
try s1 = 2...



it work so good on LAN, whay not WAN, why so many jumpy corrections??

I need to look into the timing closer

maybe running just in time to get difs as needed is not the right approach

If I got difs for a frame that I has already rendered...
I could replay with the local controls for that frame that has already occured...
this would mean I am running ahead of the the server
controls that I am currently pressing are not as old on the server



If I got difs for a frame that I had not rendered yet...
i would hold off till then and apply it
this would mean I am running behind the server
controls that I am currently pressing are even older on the server



I will need to experiment with both

20221219 11:22PM ..push



I have some thoughts...

I want to know where in the client frame are the stdf's rx'd and where are they used..


Make a graphical overlay for the game

sliding bar to show sync and stuff

controls also...

timestamp bar in screen overlay
what am I going to show?

where will i get the data for that

should I clear old timestamps every second?

yes and I should do somthing in there about doing some nice averages and min max

later...


now I want to have some timestamps that do not get saved, only for current frame...
I have one for frame start, but I also want one for stdf rx..


what if I log these so that I can make a nice graph and look at them?? maybe later...


what I am seeing is the stdf being rx'd right after draw in the frame


where in the frame does the client use stdf?

at the very start...

- input
- move
- draw


what if I measured the timestamp difference between stdf packet being received and it being used by the client?

that is the critical timing anyway, is it not?



I want to solve the client sync thing....
I want to be able to control where in the frame the stdf is rx'd
this is proving to be harder than I thought

OK I think I figured out how to do that...

now I want to see if I can have some on screen controls

they will need to be non-blocking


run them from debug screen overlay

first can I show mouse??..yes

button works but blocks on mouse press....
made a non_blocking version


         static int pres = 0;
         if (mdw_buttont_nb(100, yyy, 200, 16,  0,0,0,0,  0,14,15, 0,  1,0,1,0, "Inc"))
         {
            if (pres == 0) printf ("incd\n");
            pres = 1;
         }
         else pres = 0;




now make a global to control the client dsync....done


when adjusting chase too close the connection is lost
the client gets difs too late to apply and does nothing??

cleaning up the logging...

removed call to apply dif from rx packet thing
now only called in the loop every frame and when waiting for intial state

logs look much better now...

I can tell the we are receiving stdf's too late..

they fail all the time when trying to apply, but that is normal.

what I should do is check when they are completed if there is any chance they can be used....
if they are late then I should raise some errors...already done....but addedd to log...
in client debug screen if server_sync = -1

and stays there for 100 frames server will drop

should client reply at all, all it has is stak...and we are not acknowledging anything...

we ack when we get a bad base, should we ack when we get a bad dest??...yes...done...



now sync can go to -1 and client stays connected

I should have something on the client to tell when te last applied dif is.

I am thinking about the nice little graph that shows dsync...
It could also display last diff applied....

added to player1

   int client_last_diff_applied;


That works...


now I want to make a nice little display for the client.

graph
buttons
chase_offset
last_dif
draw in red if last_dif > 2


for the actual value, lets take if from

added to player1 struct...
   double dsync;


OMG that looks great...

now what??

that is about the only thing that I can adjust and monitor on the client....
it sends cdats when they occurs
it processes stdfs just before it has to apply them...

this client dsync is such an important number that I wonder if I should sync it back to the server.
I could add it to stak....

on the client


move all of these to player1

double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;
double client_chase_offset = 0.010;

done...

I actually did not need these and removed them...
double timestamp_stdf_rx = 0;
double timestamp_stdf_ap = 0;

still wondering about adding dsync to stak so server has it....

It was as easy as adding one line on the client:

   PacketPutDouble(players1[p].dsync);

   and one on the client...

   players1[p].dsync            = PacketGetDouble();

add display it in server debug...done...


now what?

do some things for server...like?

buttons to change s1 and s2

graph to show when clients cdats arrive in relation to current frame...

s1 and s2 are already part of the player1 struct...

done...


I want to know at what position in the frame do cdats arrive at, and how many frames behind....

crudely looking in the logs -2 and rarely -3 for a WAN game....
-1 for a LAN game....this might be unavoidable...

if the round trip ping is around 30 then one way would be 15...

I want to know exactly what it is and see if adjusting the client offset can do anything about it....


so how to measure?


server fast packet loop already marks cdats with timestamp when they arrive

so go to where they are processed...




I still don't like how the frame_number are processed!!
I really want to fix it but I am scared of what it will break....

---------------
- current:
---------------
timer_triggers_event

input
move
draw
inc frame

wait until triggered again...


---------------
what I want:
---------------
timer_triggers_event

inc frame
input
move
draw

wait until triggered again...

this would mean that for the entirety of the frame, the frame number is the same

not
change frame number
wait
do stuff

the wait would be at the end....


goddamn it!! I don't care what I have to fix...I'm going to make it so that is how it is...

one consequence is there will never be a frame 0...I know somethings depend on that....

or rather any setup that is done before the first loop will be done on frame 1....


it is done, these are the first lines

frame_num++;
update_animation();

lets see what still works...

single player seems good....level done too

server and client seem to work...omg...

This will have more of an effect on some timer things I am doing....




[1457]cdat 1455  gc:-2 0.016008
[1458]cdat 1456  gc:-2 0.012546
[1459]cdat 1457  gc:-2 0.008733
[1460]cdat 1458  gc:-2 0.013411
[1461]cdat 1459  gc:-2 0.015866
[1462]cdat 1460  gc:-2 0.016015
[1463]cdat 1461  gc:-2 0.008641
[1464]cdat 1462  gc:-2 0.012660
[1465]cdat 1463  gc:-2 0.016165
[1466]cdat 1464  gc:-2 0.016065
[1467]cdat 1465  gc:-2 0.008550
[1468]cdat 1466  gc:-2 0.016006
[1469]cdat 1467  gc:-2 0.013687
[1470]cdat 1468  gc:-2 0.010922
[1471]cdat 1469  gc:-2 0.011143
[1472]cdat 1470  gc:-2 0.015377
[1473]cdat 1471  gc:-2 0.011053
[1474]cdat 1472  gc:-2 0.013461
[1476]cdat 1473  gc:-3 0.023695
[1477]cdat 1474  gc:-3 0.023571
[1477]cdat 1475  gc:-2 0.015960
[1478]cdat 1476  gc:-2 0.016023
[1479]cdat 1477  gc:-2 0.008565
[1480]cdat 1478  gc:-2 0.015372
[1481]cdat 1479  gc:-2 0.011239
[1482]cdat 1480  gc:-2 0.015975
[1483]cdat 1481  gc:-2 0.016240
[1484]cdat 1482  gc:-2 0.013693
[1485]cdat 1483  gc:-2 0.013712
[1486]cdat 1484  gc:-2 0.016219
[1487]cdat 1485  gc:-2 0.006484
[1488]cdat 1486  gc:-2 0.010268
[1489]cdat 1487  gc:-2 0.016290
[1490]cdat 1488  gc:-2 0.016250
[1491]cdat 1489  gc:-2 0.005989
[1492]cdat 1490  gc:-2 0.016332
[1493]cdat 1491  gc:-2 0.016286
[1494]cdat 1492  gc:-2 0.011335
[1496]cdat 1493  gc:-3 0.015332
[1496]late cdat dropped p:1 c:1493  state:1494  tally:5
[1496]cdat 1494  gc:-2 0.015881
[1497]cdat 1495  gc:-2 0.011157
[1498]cdat 1496  gc:-2 0.016283
[1500]cdat 1497  gc:-3 0.018602
[1500]cdat 1498  gc:-2 0.016122
[1501]cdat 1499  gc:-2 0.016274
[1502]cdat 1500  gc:-2 0.016290
[1504]cdat 1501  gc:-3 0.022777
[1504]cdat 1502  gc:-2 0.015344
[1505]cdat 1503  gc:-2 0.016394
[1506]cdat 1504  gc:-2 0.013682
[1507]cdat 1505  gc:-2 0.005452
[1508]cdat 1506  gc:-2 0.016448
[1509]cdat 1507  gc:-2 0.008965
[1510]cdat 1508  gc:-2 0.013958
[1511]cdat 1509  gc:-2 0.012853
[1512]cdat 1510  gc:-2 0.012440
[1513]cdat 1511  gc:-2 0.010386
[1514]cdat 1512  gc:-2 0.015350
[1515]cdat 1513  gc:-2 0.002899
[1516]cdat 1514  gc:-2 0.015026
[1517]cdat 1515  gc:-2 0.010401
[1518]cdat 1516  gc:-2 0.012886
[1519]cdat 1517  gc:-2 0.012882
[1520]cdat 1518  gc:-2 0.015386
[1521]cdat 1519  gc:-2 0.012910
[1522]cdat 1520  gc:-2 0.015355
[1523]cdat 1521  gc:-2 0.007923
[1524]cdat 1522  gc:-2 0.012935
[1525]cdat 1523  gc:-2 0.012978
[1526]cdat 1524  gc:-2 0.015520
[1527]cdat 1525  gc:-2 0.012827
[1528]cdat 1526  gc:-2 0.015430
[1529]cdat 1527  gc:-2 0.015545
[1530]cdat 1528  gc:-2 0.012892
[1531]cdat 1529  gc:-2 0.012998
[1532]cdat 1530  gc:-2 0.014326
[1533]cdat 1531  gc:-2 0.012941
[1534]cdat 1532  gc:-2 0.015566
[1535]cdat 1533  gc:-2 0.008016
[1537]cdat 1535  gc:-2 0.015592
[1538]cdat 1536  gc:-2 0.015593
[1539]cdat 1537  gc:-2 0.000435
[1540]cdat 1538  gc:-2 0.015559
[1541]cdat 1539  gc:-2 0.015597
[1542]cdat 1540  gc:-2 0.015425
[1543]cdat 1541  gc:-2 0.008001
[1544]cdat 1542  gc:-2 0.014422
[1545]cdat 1543  gc:-2 0.008050
[1546]cdat 1544  gc:-2 0.015639
[1547]cdat 1545  gc:-2 0.015657
[1548]cdat 1546  gc:-2 0.010277
[1549]cdat 1547  gc:-2 0.015553
[1550]cdat 1548  gc:-2 0.013098
[1551]cdat 1549  gc:-2 0.008058
[1552]cdat 1550  gc:-2 0.015317
[1553]cdat 1551  gc:-2 0.016250
[1554]cdat 1552  gc:-2 0.016115
[1555]cdat 1553  gc:-2 0.006201
[1556]cdat 1554  gc:-2 0.016057
[1557]cdat 1555  gc:-2 0.013614
[1558]cdat 1556  gc:-2 0.011243
[1559]cdat 1557  gc:-2 0.013781
[1560]cdat 1558  gc:-2 0.015270
[1561]cdat 1559  gc:-2 0.016355
[1562]cdat 1560  gc:-2 0.016313
[1563]cdat 1561  gc:-2 0.005983
[1564]cdat 1562  gc:-2 0.016292
[1565]cdat 1563  gc:-2 0.016259
[1566]cdat 1564  gc:-2 0.016243
[1568]cdat 1565  gc:-3 0.021811
[1568]late cdat dropped p:1 c:1565  state:1566  tally:6
[1568]cdat 1566  gc:-2 0.010779
[1569]cdat 1567  gc:-2 0.013561
[1570]cdat 1568  gc:-2 0.013822
[1571]cdat 1569  gc:-2 0.013807
[1572]cdat 1570  gc:-2 0.016112
[1573]cdat 1571  gc:-2 0.013626
[1574]cdat 1572  gc:-2 0.011389
[1575]cdat 1573  gc:-2 0.008685
[1576]cdat 1574  gc:-2 0.014161
[1577]cdat 1575  gc:-2 0.013923
[1578]cdat 1576  gc:-2 0.013768
[1579]cdat 1577  gc:-2 0.011336
[1580]cdat 1578  gc:-2 0.013763
[1581]cdat 1579  gc:-2 0.013759
[1582]cdat 1580  gc:-2 0.016342
[1583]cdat 1581  gc:-2 0.013814
[1584]cdat 1582  gc:-2 0.009788
[1585]cdat 1583  gc:-2 0.015957
[1586]cdat 1584  gc:-2 0.015287
[1587]cdat 1585  gc:-2 0.012783
[1588]cdat 1586  gc:-2 0.012283
[1589]cdat 1587  gc:-2 0.014804
[1590]cdat 1588  gc:-2 0.009828
[1591]cdat 1589  gc:-2 0.012939
[1592]cdat 1590  gc:-2 0.014961
[1593]cdat 1591  gc:-2 0.014743
[1594]cdat 1592  gc:-2 0.015493
[1595]cdat 1593  gc:-2 0.015486
[1596]cdat 1594  gc:-2 0.015339
[1597]cdat 1595  gc:-2 0.015183
[1598]cdat 1596  gc:-2 0.012898
[1599]cdat 1597  gc:-2 0.012872
[1600]cdat 1598  gc:-2 0.015144
[1601]cdat 1599  gc:-2 0.015399
[1602]cdat 1600  gc:-2 0.015535
[1603]cdat 1601  gc:-2 0.015149
[1604]cdat 1602  gc:-2 0.015224
[1605]cdat 1603  gc:-2 0.015317
[1606]cdat 1604  gc:-2 0.015380
[1607]cdat 1605  gc:-2 0.015513
[1608]cdat 1606  gc:-2 0.015421
[1609]cdat 1607  gc:-2 0.013009
[1610]cdat 1608  gc:-2 0.015586
[1611]cdat 1609  gc:-2 0.013025
[1612]cdat 1610  gc:-2 0.009968
[1613]cdat 1611  gc:-2 0.012802
[1614]cdat 1612  gc:-2 0.015206
[1615]cdat 1613  gc:-2 0.013571
[1616]cdat 1614  gc:-2 0.010078
[1617]cdat 1615  gc:-2 0.013467
[1618]cdat 1616  gc:-2 0.011040
[1619]cdat 1617  gc:-2 0.008677
[1620]cdat 1618  gc:-2 0.013720
[1621]cdat 1619  gc:-2 0.008645
[1622]cdat 1620  gc:-2 0.016253
[1623]cdat 1621  gc:-2 0.013690
[1624]cdat 1622  gc:-2 0.010371
[1625]cdat 1623  gc:-2 0.016220
[1626]cdat 1624  gc:-2 0.016234
[1627]cdat 1625  gc:-2 0.013284
[1628]cdat 1626  gc:-2 0.016230
[1629]cdat 1627  gc:-2 0.016302
[1630]cdat 1628  gc:-2 0.013344
[1631]cdat 1629  gc:-2 0.013923
[1632]cdat 1630  gc:-2 0.014303
[1633]cdat 1631  gc:-2 0.011076
[1634]cdat 1632  gc:-2 0.016218
[1636]cdat 1634  gc:-2 0.016113
[1637]cdat 1635  gc:-2 0.016295
[1638]cdat 1636  gc:-2 0.011313
[1639]cdat 1637  gc:-2 0.011073
[1640]cdat 1638  gc:-2 0.009382
[1641]cdat 1639  gc:-2 0.015344
[1642]cdat 1640  gc:-2 0.013728
[1643]cdat 1641  gc:-2 0.011338
[1644]cdat 1642  gc:-2 0.012676
[1645]cdat 1643  gc:-2 0.016255
[1646]cdat 1644  gc:-2 0.016330
[1647]cdat 1645  gc:-2 0.011304
[1648]cdat 1646  gc:-2 0.012836
[1649]cdat 1647  gc:-2 0.016026
[1650]cdat 1648  gc:-2 0.013793
[1651]cdat 1649  gc:-2 0.011195
[1652]cdat 1650  gc:-2 0.015942
[1653]cdat 1651  gc:-2 0.013636
[1654]cdat 1652  gc:-2 0.013275
[1655]cdat 1653  gc:-2 0.013769
[1656]cdat 1654  gc:-2 0.015110
[1657]cdat 1655  gc:-2 0.010577
[1658]cdat 1656  gc:-2 0.016374
[1659]cdat 1657  gc:-2 0.011284
[1660]cdat 1658  gc:-2 0.010566
[1661]cdat 1659  gc:-2 0.015398
[1662]cdat 1660  gc:-2 0.015214
[1663]cdat 1661  gc:-2 0.012801
[1664]cdat 1662  gc:-2 0.007925
[1665]cdat 1663  gc:-2 0.014823
[1666]cdat 1664  gc:-2 0.012664
[1667]cdat 1665  gc:-2 0.012927
[1668]cdat 1666  gc:-2 0.007893
[1669]cdat 1667  gc:-2 0.013443
[1670]cdat 1668  gc:-2 0.015582
[1671]cdat 1669  gc:-2 0.000908
[1672]cdat 1670  gc:-2 0.009900
[1673]cdat 1671  gc:-2 0.013594
[1674]cdat 1672  gc:-2 0.015531
[1675]cdat 1673  gc:-2 0.010952
[1676]cdat 1674  gc:-2 0.013435
[1677]cdat 1675  gc:-2 0.013549
[1678]cdat 1676  gc:-2 0.008466
[1680]cdat 1677  gc:-3 0.019645
[1680]cdat 1678  gc:-2 0.002917
[1681]cdat 1679  gc:-2 0.008503
[1682]cdat 1680  gc:-2 0.016072
[1683]cdat 1681  gc:-2 0.011123
[1684]cdat 1682  gc:-2 0.003675
[1685]cdat 1683  gc:-2 0.013604
[1686]cdat 1684  gc:-2 0.015596
[1687]cdat 1685  gc:-2 0.016052
[1688]cdat 1686  gc:-2 0.015212
[1689]cdat 1687  gc:-2 0.016168
[1690]cdat 1688  gc:-2 0.011074
[1691]cdat 1689  gc:-2 0.013681
[1692]cdat 1690  gc:-2 0.013463
[1693]cdat 1691  gc:-2 0.011137
[1694]cdat 1692  gc:-2 0.011156
[1695]cdat 1693  gc:-2 0.000906
[1696]cdat 1694  gc:-2 0.009721
[1697]cdat 1695  gc:-2 0.016065
[1698]cdat 1696  gc:-2 0.010847
[1699]cdat 1697  gc:-2 0.008499
[1700]cdat 1698  gc:-2 0.015868
[1701]cdat 1699  gc:-2 0.013527
[1702]cdat 1700  gc:-2 0.012817
[1703]cdat 1701  gc:-2 0.013946
[1704]cdat 1702  gc:-2 0.015312
[1705]cdat 1703  gc:-2 0.016129
[1706]cdat 1704  gc:-2 0.016215
[1707]cdat 1705  gc:-2 0.001235
[1708]cdat 1706  gc:-2 0.016209
[1709]cdat 1707  gc:-2 0.016298
[1710]cdat 1708  gc:-2 0.016262
[1711]cdat 1709  gc:-2 0.006192
[1712]cdat 1710  gc:-2 0.015423
[1713]cdat 1711  gc:-2 0.015889
[1714]cdat 1712  gc:-2 0.013694
[1715]cdat 1713  gc:-2 0.013802
[1716]cdat 1714  gc:-2 0.013334
[1717]cdat 1715  gc:-2 0.011154
[1718]cdat 1716  gc:-2 0.016351
[1719]cdat 1717  gc:-2 0.016319
[1720]cdat 1718  gc:-2 0.002903
[1721]cdat 1719  gc:-2 0.015321
[1722]cdat 1720  gc:-2 0.013337
[1723]cdat 1721  gc:-2 0.013783
[1724]cdat 1722  gc:-2 0.016235
[1725]cdat 1723  gc:-2 0.016357
[1726]cdat 1724  gc:-2 0.015293
[1727]cdat 1725  gc:-2 0.016391
[1728]cdat 1726  gc:-2 0.012899
[1729]cdat 1727  gc:-2 0.011115
[1730]cdat 1728  gc:-2 0.015705
[1731]cdat 1729  gc:-2 0.013571
[1732]cdat 1730  gc:-2 0.013652
[1733]cdat 1731  gc:-2 0.013832
[1734]cdat 1732  gc:-2 0.015658
[1735]cdat 1733  gc:-2 0.013765
[1736]cdat 1734  gc:-2 0.010355
[1737]cdat 1735  gc:-2 0.015423
[1738]cdat 1736  gc:-2 0.012726
[1739]cdat 1737  gc:-2 0.005048
[1740]cdat 1738  gc:-2 0.015540
[1741]cdat 1739  gc:-2 0.010319
[1742]cdat 1740  gc:-2 0.007640
[1743]cdat 1741  gc:-2 0.002646
[1744]cdat 1742  gc:-2 0.010272
[1745]cdat 1743  gc:-2 0.020515
[1746]cdat 1744  gc:-2 0.015403
[1747]cdat 1745  gc:-2 0.012900
[1748]cdat 1746  gc:-2 0.007992
[1749]cdat 1747  gc:-2 0.015303
[1750]cdat 1748  gc:-2 0.010310
[1751]cdat 1749  gc:-2 0.007921
[1752]cdat 1750  gc:-2 0.012557
[1753]cdat 1751  gc:-2 0.015826
[1754]cdat 1752  gc:-2 0.016052
[1755]cdat 1753  gc:-2 0.011077
[1756]cdat 1754  gc:-2 0.013468
[1757]cdat 1755  gc:-2 0.016045
[1758]cdat 1756  gc:-2 0.016096
[1759]cdat 1757  gc:-2 0.011004
[1760]cdat 1758  gc:-2 0.015371
[1761]cdat 1759  gc:-2 0.011178
Shutting down the server
savegame/game_exit_20221230-183937-lev150.txt - saved
logs/20221230-183937-[150][m36].txt saved

C:\pm>







so how to combine those two numbers


and do they even still make sense?


Now, if I get one I can assume by the time it gets added it will be the next frame...
or this frame because by the time it is processed the frame has incremented

so when I get one that says -2 on frame 1730 for example...
that mean the cdat is for 1728, 2 frame ago...


now that the start of frame timer can be trusted, I should use that to go back and find out exactly when the packet arrived in relation to the frame start.

then I can make a composite number of how late it is...

WAN

[244]cdat 242  gc:-2 0.016242 -33.757700ms
[245]cdat 243  gc:-2 0.013527 -36.472500ms
[246]cdat 244  gc:-2 0.001073 -48.926800ms
[247]cdat 245  gc:-2 0.013675 -36.325100ms
[248]cdat 246  gc:-2 0.008515 -41.484700ms
[249]cdat 247  gc:-2 0.013653 -36.346700ms
[250]cdat 248  gc:-2 0.003773 -46.226500ms
[251]cdat 249  gc:-2 0.013406 -36.593600ms
[252]cdat 250  gc:-2 0.013678 -36.322400ms
[253]cdat 251  gc:-2 0.013635 -36.364900ms
[255]cdat 252  gc:-3 0.018778 -56.222400ms
[256]cdat 253  gc:-3 0.013594 -61.405500ms
[256]cdat 254  gc:-2 0.013532 -36.468100ms
[257]cdat 255  gc:-2 0.013844 -36.155600ms
[258]cdat 256  gc:-2 0.008631 -41.369000ms
[259]cdat 257  gc:-2 0.011310 -38.690000ms
[260]cdat 258  gc:-2 0.013817 -36.183400ms
[261]cdat 259  gc:-2 0.012976 -37.023800ms
[262]cdat 260  gc:-2 0.006389 -43.610600ms
[263]cdat 261  gc:-2 0.011331 -38.669100ms
[264]cdat 262  gc:-2 0.013452 -36.548300ms
[265]cdat 263  gc:-2 0.003223 -46.777400ms
[266]cdat 264  gc:-2 0.008756 -41.244300ms
[267]cdat 265  gc:-2 0.011006 -38.994200ms
[268]cdat 266  gc:-2 0.016051 -33.949000ms
[269]cdat 267  gc:-2 0.013857 -36.143100ms
[270]cdat 268  gc:-2 0.008706 -41.294100ms
[271]cdat 269  gc:-2 0.011205 -38.794700ms
[272]cdat 270  gc:-2 0.013796 -36.204100ms
[278]cdat 276  gc:-2 0.006955 -43.044900ms



LAN 10ms

[352]cdat 351  gc:-1 0.012526 -12.474100ms
[353]cdat 352  gc:-1 0.011416 -13.583900ms
[354]cdat 353  gc:-1 0.012495 -12.505200ms
[355]cdat 354  gc:-1 0.012518 -12.481800ms
[356]cdat 355  gc:-1 0.011462 -13.538200ms
[357]cdat 356  gc:-1 0.013423 -11.577100ms
[358]cdat 357  gc:-1 0.013426 -11.573700ms
[359]cdat 358  gc:-1 0.012400 -12.599700ms
[360]cdat 359  gc:-1 0.012547 -12.453300ms
[361]cdat 360  gc:-1 0.013429 -11.570900ms
[362]cdat 361  gc:-1 0.012374 -12.626400ms
[363]cdat 362  gc:-1 0.013445 -11.554800ms
[364]cdat 363  gc:-1 0.013457 -11.543500ms
[365]cdat 364  gc:-1 0.012394 -12.606000ms
[366]cdat 365  gc:-1 0.012999 -12.001300ms
[367]cdat 366  gc:-1 0.012964 -12.036300ms
[368]cdat 367  gc:-1 0.011328 -13.672500ms

LAN 2ms

[573]cdat 572  gc:-1 0.021599 -3.400600ms
[574]cdat 573  gc:-1 0.021587 -3.412900ms
[575]cdat 574  gc:-1 0.020520 -4.480400ms
[576]cdat 575  gc:-1 0.020883 -4.117200ms
[577]cdat 576  gc:-1 0.021548 -3.452300ms
[578]cdat 577  gc:-1 0.020530 -4.470000ms
[579]cdat 578  gc:-1 0.021555 -3.445200ms
[580]cdat 579  gc:-1 0.021530 -3.469900ms
[581]cdat 580  gc:-1 0.020455 -4.545000ms
[582]cdat 581  gc:-1 0.021507 -3.493000ms
[583]cdat 582  gc:-1 0.021511 -3.489000ms
[584]cdat 583  gc:-1 0.019713 -5.286600ms
[585]cdat 584  gc:-1 0.021510 -3.490400ms
[586]cdat 585  gc:-1 0.021510 -3.489900ms
[587]cdat 586  gc:-1 0.020450 -4.550300ms
[588]cdat 587  gc:-1 0.021512 -3.488100ms



I want to have server stats on cdat_rx time
tally for 1s and do average and max min
same for late cdats

OK I have done that...big surprise...nothing seems to effect when cdats are received on server, except for client dsync....


the only thing I can do to get cdats to the server faster, would be to let the client move ahead of the server in time....
but then the client would always get difs that were too late to apply....

what if I let the client rewind?
and apply the local moves from the last frame?

that would mean I would have to keep the clients local moves...it would only be one move per frame max...

this is just crazy enough to maybe work.....

client stores all its game moves in it's own local array....
when client get a dif that is in the past:
apply then play back to current...



right now I have the server in the lead, the client lags behind just enough so I can get the current state from the server and apply it.
If I let the client pass the server, the server will be able to get cdats with less delay, but who knows what else might happen??

I think it's worth a try....

1 - make client put stuff in its own local game_moves array

2 - remove the part in rx stdf where we ignore late difs

3 - modify apply dif to allow late ones

this is a tricky bit of code here....

   // check to see if frame_nums match and its time to apply dif or if initial state when frame_num == 0
   if ((frame_num != client_state_dif_dst) && (frame_num != 0))
   {


first of all if the match then do it
second of all if frame_num == 0 do it
third of all...
if newer than last applied dif....

what is the varaible for the last applied dif frame_num? 'client_state_base_frame_num'

so check if the dest of the dif_dest on deck is newer than that

if (client_state_dif_dst > client_state_base_frame_num) // we have dif with a newer dest than previous

omg I am ready to try it....

well it looks like I can run a game succesfully with negative sync... lets try it on WAN


client has all been put back together nicely...
still to do on client
look into chase multiplier...seems to work good but I have not examined it
automatically set chase amount, but based on what?
should it be a sliding scale, or a fixed number?

on server I have issues if I try to lower s1
raising it is OK but when I lower it, server becomes unresponsive and will not accept new connections

show more about the clients on the server...but what and why??

profile using timestamps certain functions...

move
draw
rewind
send stdf
receive packets

move packetbuffer code and functions to packet file


testing...making the client -40 seemed to make the game a lot smoother....


calculate and show ping on client and server...


server tx ping from 'loop' with current time

client rx ping and tx pong with passed time and current time

server rx pong
calc rt
return passed ts in pang

client rx pang
calc rt


ok now where to store it...

player1
   double ping;

put it on the bottom for client

in server it will be part of debug array



flush client and server on level done


when does client show red...removed

how about auto setting clients offset to ping....

but I would need to get an average ping
I only read it every 2s

how about reading it one per second and keep a 10s rolling average....

at the start of when a client joins
use default of zero to start...
get 8 pings in 2s for avg then use that to adjust
then do the rolling replace one every 2 sec

is this overkill...maybe...

but just blindly plugging one ping into offset is bad also

should have some limits....
+20 absolute max, why would you even want to go positive?
-50 to -80 somehwere around there for the min need to test...




try experimenting with different s1 and s2
3 1 - default

I'm getting late cdats and stuff from 4230's but not scat or e6430
the sync on them is jumping around a lot...
I could probably benefit from some code profiling....


20221231 9:26 AM

make the client initiate ping, as it is the one that needs it.
where?
how about from a timer?
too complex, just do it like the server does...
done...

now make way for client to do more right after join...

how about make the cyclic buffer of ping to average first....

then make a method to add new pings

then make a way that the average is calultaed

then make a way that when the buffer is not full, its pings mopre often...

struct ping_buffer

int num_filled;
int new_index;
double ping[8];
double avg;

initially:
num_filled = 0;
index = 0;
all are 0;

as added:
num_filled++
index++

num_filled can be greater than index

when doing avg

loop and add from 0 to num filled, or max if full

then divide and set avg...


do I need to do it in a struct? probably not the besy way...

double ping_array[8];
double ping_avg;
int    ping_num_filled;
int    ping_index;

make a new file ping_buffer.cpp

clear in client init..done

now make a function to add...done...

now where am I going to save this?

player1

ping_avg

ok that's done...now make it run faster until filled...

done...

now maybe toss out the highest and lowest for average....

experiment with different values of s1 and s2

right now I have been using 3 and 1

re do the client sync graph for the server, especially since I now use dsync

what did I use before?

stak packet on server prints this log line:

sprintf(tmsg1, "rx stak sync:[%d] chase:[%d] ack_fn:%d cli_fn:%d", players1[p].server_sync, players1[p].client_chase_fps, ack_frame_num, client_frame_num );

[30][1][318]rx stak sync:[1] chase:[39] ack_fn:316 cli_fn:317 set new base

I want to add dsync and remove unneeded things...why do I have 2 fn that are always the same??

change client_chase_fps to double from int....

its main use is to get back to the server to be displayed

OK I have parsed it from the log lines in graph...

but the problem is that the data for the graph is an integer array....

for now, multiply by 10...

redo sync to display in ms

I can come back to this later....
when I get this done I can examine chase better.....

OK, Ive been thinking...
I want to make the tag parsing thing a separate function...done
replaced 8-10 calls

Also this sync graph would probably be better on the client.

The server only has data when it receives stak....

what can I do to make the graph look better??

it is not frames anymore, but ms...

better....

can I auto range based on the data shown?...yes...

my stak log line can bee too long

[30][3][500]rx stak syn:[4] dsy:[12405.5] chs:[70.0] afn:496 cfn:496 failed to set base! cl:499

[30][4][6180]rx stak syn:[-2] dsy:[-113.3] chs:[31.7] afn:6177 cfn:6182 failed to set base! cl:6179
[30][3][6182]rx stak syn:[-2] dsy:[-104.8] chs:[33.0] afn:6179 cfn:6184 failed to set base! cl:6181
[30][4][6182]rx stak syn:[-2] dsy:[-104.6] chs:[32.6] afn:6177 cfn:6184 failed to set base! cl:6181
[30][2][6183]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6185 failed to set base! cl:6181
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183


failed to set base! cl:6183
change to
fail base set:6183

saved 9 char

more:
[30][2][6184]rx stak syn:[-2] dsy:[-100.0] chs:[33.0] afn:6179 cfn:6186 failed to set base! cl:6183

[30][2][6184]rx stak s[-2] d[-100.0] c[33.0] af:6179 cf:6186 fail set base:6183

saved 20 char



can I make some buttons in graphs?  at the top of the legend scale lock or autorange..
auto/manual
manual +/-



I really want to make the graphs simpler...

wouldn't it be nice to have a common function for all of them?

they all seem to have common x axis...frames, seconds, minutes, etc.....


what is the data needed to describe a graph?

screen coordinates x1, y1, x2, y2, w, h
these are in the standard computer screen format: x1,y1 is upper left corner

graph x axis
start and end data values

graph y axis
start and end data values

can get range from these.

an array of data used to plot points on the graph

data[][0] = x
data[][1] = y

can I make this an object?

why?

so it encaspulates it's own data and methods

I will call it to draw itself
optionally draw legends and gridlines
process mouse input on the graph

class mw_graph

make a new file and lets do this....


I don't get why I am having such a hard time mapping one range to another....
am i doing the wrong things??
I don't need to map the data range to the axis range!
I need to map the axis range to the screen range!!!!

   double xm = screen_w / x_axis_rng;
   double ym = screen_h / y_axis_rng;

   for (int i=0; i<data_points; i++)
   {
      float x = screen_x1 + (data[i][0]-x_axis_min) * xm;
      float y = screen_y2 - (data[i][1]-y_axis_min) * ym;
      al_draw_rectangle(x, y, x+1, y+1, palette_color[10], 1);
   }


now what??

should I put some mouse_controls in?
yes...

ist show mouse...

2nd show mouse position and convert to values...

this will mean I have to call this in a loop and process event queue....

done...
now I want an autoscale button
one for x and y and one for each also...

done...


what now?

can you do a nice title...

set a minimum x axis range....

butttons for nice axis management:
auto/manual
of just auto button
+ and - to adjust scale
for each min and mix??

not sure if this will be that usefull

implement mouse_drag...
x only or x and y?
can you set a scale conevrsion varaible for x axis and y axis
do it on the fly..it was easy...
mouse drag works beautifully




            // graph position under mouse (mx1) needs to stay the same

            // change range?? then find min and max to ensure same pos??


            // what if i calulated scaler, then changed that, then worked backwards from there
//            double x_scaler =  x_axis_rng / screen_w;
//            x_scaler *= 1.1;
//            x_axis_rng = x_scaler * screen_w; // convert range back

            // now how do I adjust min so that current pos is the same

            // old distance from current pos to min * scaler  ????

//
//            // old distance from curent position to min
//            double old_offset = mx1 - x_axis_min;
//
//            printf("old_offset:%f\n", old_offset);
//
//
//            // get original scale
//            double x_scaler =  x_axis_rng / screen_w;
//
//            printf("orignal_scale:%f\n", x_scaler);
//
//
//
//            // change scale
//            x_scaler *= 1.1;
//
//
//            printf("new_scale:%f\n", x_scaler);
//
//
//            printf("old range:%f\n", x_axis_rng);
//
//            // convert range
//            x_axis_rng = x_scaler * screen_w;
//
//            printf("new range:%f\n", x_axis_rng);
//
//
//
//            printf("old offset:%f\n", old_offset);
//
//            // scale to new
//            double new_offset = old_offset * 1.1;
//
//
//            printf("new offset:%f\n", new_offset);
//
//
//
//            printf("old min:%f\n", x_axis_min);
//
//            // set min from original position and new offset
//            x_axis_min = mx1 - new_offset;
//
//
//            printf("new min:%f\n", x_axis_min);
//
//            // set max1
//            x_axis_max = x_axis_min + x_axis_rng;
//
//
//


            double old_offset = mx1 - x_axis_min;     // old distance from curent position to min
            double new_offset = old_offset * 1.1;     // scale to new
            x_axis_min = mx1 - new_offset;            // set min from original position and new offset
            x_axis_rng *= 1.1;                        // convert range
            x_axis_max = x_axis_min + x_axis_rng;     // set new max


holy shit that is beautiful!!

mouse drag (x axis)
mouse wheel zoom (x axis)
mouse drag zoom in (x and y axis)

do something about mouse drag when off screen, clamp to edges done...

try y drag move...awesome...

try y zoom wheel...wicked...

now if I added lock buttons on the x and y axis to prevent this

will it lock both scroll and zoom??

for x axis

zoom lock..


I want scroll bars...

do an x one first


I think I am readt to start thinking about some limits....

limit the axis ranges....

make all changes to the axis ranges go through a common function so limit will only need to be tested once
done...
it works, but seems a little weird when drag turns into resize...
drag normally moves both start and end
if one does not move, it turns into a resize...
the alternative would be to do nothing, no drag move allowed if it would change range

I can live with it for now...


now make some ways to drag the scroll bar...

make scrollbar variables part of class...done

int x_axis_scrollbar_x1;
int x_axis_scrollbar_x2;
int x_axis_scrollbar_w;

int x_axis_scrollbar_bar_x1;
int x_axis_scrollbar_bar_x2;

int x_axis_scrollbar_y1;
int x_axis_scrollbar_y2;

moved draw into its own function


figure out the offset...data does not start till 40...done...


now I have 5 ways to adjust the scroll bar with the mouse and its looking pretty good...

sometimes I can adjust past data max and stuff breaks...
a_axis min can be more the max...this should not happen...

there is some chicken and egg things going on with enforce limits...

testing for min max
testing for wrong order

I need to test both min and max to see if they are in range

I also want to add another test...minimum range...

I should find the smallest difference between x values and make the minum range 10 of those...

for now, lets just set a static value and test..

if both max and min are stuck near the top separate them by minimum range...

this all looks good...

now I want to do some y ranging


   bool x_axis_lock_scroll;
   bool x_axis_lock_zoom;

   bool y_axis_lock_scroll;
   bool y_axis_lock_zoom;
   bool y_axis_lock_auto_zoom;



y_axis_lock_zoom
done for drag rect and mouse wheel
not done for drag scroll...still changes zoom...fixed

y_axis_lock_scroll

y_axis scrollbars

y axis is reversed, which poses some issues
how am I going to deal with that? at what point do I flip the axis...
x1 is smaller than x2 when drawing on the screen
but when the mouse moves they are oppposite...
make the data reveser
y2 is min, y1 is max...
im thinking of doing it all upside down...
y1 is lower

I just made the scrollbar y1 and y2 reversed....

I have implemented all scrollbar functionality to y scroll bar...
make the highlight look better, align better, color, size, different mouse_pointer....done...



now back to the locking...

enforce zoom lock on y scroll bar..done...


what does it mean if scroll is locked and zoom is not? does that even make sense??
it could mean that the x_min is locked, but not x_max and scroll


can change   min max rng
no lock       1   1   1
zl            1   1   0
sl            0   1   1
zl + sl       0   0   0


what about autoscale y depending on what is on screen

what if I made zoom_lock have 3 values

0 off
1 lock
2 auto

rignt click on axis or scrollbar for options..

mouseover text ...

mouse crosshairs

jump to nearest data position and show data for that...

I want a way to store the units for each axis...
call a fucntion to set msg

right click on stuff to popup menu....done


20230103 back to work...

what are the main things left to do on graph?

units, axis labels, gridlines

nice bounding boxes for all the graph elements
(optional) title and (optional)space for it (probably above but not married to it)

y axis labels (could be on left or right side)
y axis scrollabr (left or right)

x axis labels (could be on top or bottom)
x axis scrollabr (could be up or down)

all of these things are optional

reset range should turn auto off....

need to stack things on the axis...

gridlines and labels
axis label
scrollbar
these should all dynamically size...
then when that is all done, I will have the size of the entire graph area
maybe I can rename that to graph_x y etc... and the other to plot...

graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

these are the main ones that are set outside the class....
then after the width of all the things in the axes are calculated...
then what is left over will be for the plot

call resize at the beginning....

these will never be changed internally:
graph_x1
graph_y1
graph_x2
graph_y2
graph_w
graph_h

find out the width needed for axes...

set:
plot_x1
plot_y1
plot_x2
plot_y2
plot_w
plot_h





make a function to auto set positions... for each axis...

void x_axis_draw(void) // does gridlines, labels, axis title and scroll bars

int x_axis_get_size(void) // returns the size needed by x_axis


start with gridlines and labels...
make them all optional




I now have:

void x_axis_draw(void);
void x_axis_get_size(void);
void x_axis_draw_legend(void);
void x_axis_draw_gridlines_and_labels(void);
int  x_axis_draw_scrollbar(void);
void x_axis_proc_scrollbar(void);


called from main draw:

void mwGraph::x_axis_draw(void)
{
   x_axis_draw_gridlines_and_labels();
   x_axis_draw_legend();
   x_axis_draw_scrollbar();
}


I also have:

void mwGraph::process_input(void)
{
   x_axis_proc_scrollbar();

which also calls:

void mwGraph::x_axis_proc_scrollbar(void)
{
   int sb = x_axis_draw_scrollbar();


how are draw and proc called?
like this externally:
mG[0].draw();
mG[0].process_input();

I will probabaly change that later, do I really need to separarte them?

for now I have other things to do:

get the variables for each x_axis element done


int x_axis_label_draw_on;
int x_axis_label_tick_size;
int x_axis_label_text_size;
int x_axis_label_draw_size;



1st get axis sizes
2nd set plot size and pos
3rd set axis pos

do I need a spearate value for actual size, vs stored size
so I can restore if turned on and off...

I think the x axis is looking really good...now work on the y axis

I am very happy with how these look

next I want to have the option of small text on legends
done and now I have a much nicer method for drawing those...


next, I want to always put labels on origins...

done, but sometimes overwrite other axis labels..



make a function to display axis values...

why can't I put mouse on point on the edge of plot?? fixed
also fixed when point text box is draw off screen...

implment units for axis...

x_axis_value_type..

0 = none
1 = time in frames...

this will have a large impact...

depending on the current displayed range,
the units for an axis will change..

the max value displayed could be used to set the units in some cases...n other cases the range...

like for time (frames)
could be frames, sec, minutes...
depending on what range is shown

this will change:
x axis legend
gridlines and labels
point text box...

I need a main title for the legend:
Time
then I need another for units

I could make a type...

type 0 - do nothing
type 1 - customized for frames

made a type..


if 1, where do I check it??

depending on the range I need to set units, divider and legend

where does that naturally happen?
draw
set size and pos
input

none of these actually

how about enforce axis limits?


and what am I going to be setting?

if type 1
use range to set
legend text
divider
units text

add divider...


----------------------

make labels also able to have font
start with x..done
and also reduce space between labels and legend..done

now do y...done...


it gets kind of messy at the origin when I draw labels there that conflict with the auto ones...and the x and y sometimes confict too...

remove x, keep y.. actually fixed origin still conficts with auto...remove (comment out) both for now...








I am happy with this


should I try it on some real data??

what would happen if I tried more data? like a real bandwidth graph...


what if I made the array larger, to include more players


or I could put them all in the main array but tag them with different series...

or I could make an entirely new graph and overlay the data...

all these things I am thinking of would have a common x axis...

should I try to put everything in one array and tag it by series?
or should I have multiple arrays?

with any method, I need to make sure the data is in order



how about a three dimensional array

point[series][x][y]


I want an int for series and doubles for the other two..

looks like a structure

max needed would be 16 if I do 8tx and 8rx



each instance of my class will get this:


struct data_seri
{
   double data[10000][2];
   int num_data;
   int active;
   int color;
   char name[1024];
};
data_seri series[20] = {0};

use like this:
series[0].data[i][0]

wow! that was surpisingly easy to get 8 tx rate lines...

next I need a series legend and the ability to toggle series on and off while the graph is running...

I want to be able to have many other things shown as well...


when setting unlocked, make sure to set autrange off also...

I want to make a nice gui setup for changing things....

like a page of toggles and checkmarks...

maybe some sliders and buttons too..

show legend like:

series number - series name - show the color and line style - click to toggle

bug--scrollbar does not like negative data

removed clear screen from calling loop, handle it internally

I am calling axis_get_size_and_arrange_pos() externally every loop, do I need to?..yes
so call it internally then...
from draw, or proc input?  proc input...

now I only call 3 things externally and one is only in case the user resized the screen...

mG[0].set_graph_pos(0,0, SCREEN_W, SCREEN_H/2-10);
mG[0].draw();
mG[0].process_input();

now back to showing legend for multiple series.......



figure out how to draw dashed line...

https://www.allegro.cc/forums/thread/615463
https://www.allegro.cc/forums/thread/615415



It looks like I can only do al_draw_soft_line on a bitmap, drawing directly to the backbuffer has weird results

so lets try to figure out hpw to do that...


make a bitmap the same size as graph

now make all my draw stuff draw on that, but all coordinates will need to be adjust to 0,0 for graph_x and y

there were surprisingly few references to those..mostly in adjust x amd y axis...

now that I am drawing onto a bitmap instead of the backbuffer, the drawing looks a lot blockier...yay! :(
text looks fine, but the high level primitives (lines) suck...

the gridlines are terriblly blocky and missing in places...

what a goddamn hassle to try to draw dashed lines

there is no godamn reason for it...



how hard would it be to revert now?
and either:
- only draw the plot lines on its own bitmap, or
- figure out how to use soft lines with backbuffer

reverted...

try to figure out how to use soft lines with backbuffer

- does soft line return x and y that make sense?? yes...


if I store all the x and y in an array then draw them outside the function that seems to work...go fig...





now how im I going to implement this?

ideally I would like to call something very similar to draw_line

al_draw_line(100, 110, 200, 110, palette_color[15], 1);
mw_draw_line(100, 110, 200, 110, col1, col2);


here it is:

int mw_p[10000][2] = {0};
int mw_i = 0;

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t state, int x, int y)
{
   if (mw_i < 10000)
   {
      mw_p[mw_i][0] = x;
      mw_p[mw_i][1] = y;
      mw_i++;
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, int c1, int c2)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   mw_i = 0;
   al_draw_soft_line(&v1, &v2, (uintptr_t)NULL , mw_FirstFunction , mw_StepFunction , mw_DrawFunction);

   int cycle = 0;
   for (int i=0; i<mw_i; i++)
   {
      int x = mw_p[i][0];
      int y = mw_p[i][1];

      int c = c1;
      if ((cycle % 8) < 4) c = c2;
      cycle++;

//      al_draw_filled_circle(x, y, 1, palette_color[c]);
      al_draw_filled_rectangle(x-0.5, y-0.5, x+0.5, y+0.5, palette_color[c]);

//   printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
      //al_put_pixel(p[i][0], p[i][1], palette_color[p[i][2]]);
   }
}


I am thinking about doing it slightly different...

make my array contain only line segements of the same color

then use the regular al_draw_line to draw those segments...

then I would have less draw calls, and I could use the thickness of lines


values to send to draw:
cycle total
cycle 0 col (default color)

// cycle & total < val color = c1
cycle 1 val
cycle 1 col

8, 15, 4, 10

then when drawing, draw 1 to 0, 2 to 1...etc...

I have it all implemented except for the thinning of call to al_draw_line
it would make it more complicated and im not sure it is needed...

not that complicated

now I need to ensure the last point is not skipped...


int mw_p[10000][3] = {0};
struct mw_state
{
   int num_points;
   int cycle_total;
   int cycle_tally;
   int default_color;
   int c1_val;
   int c1_col;
   int c2_val;
   int c2_col;
};

void mw_FirstFunction(uintptr_t state, int x, int y, ALLEGRO_VERTEX* v1, ALLEGRO_VERTEX* v2) {}
void mw_StepFunction(uintptr_t state, int step) {}

void mw_DrawFunction(uintptr_t ms1, int x, int y)
{
   struct mw_state* ms = (struct mw_state*) ms1;
   if (ms->num_points < 10000)
   {
      // get color from cycle
      int col = ms->default_color;
      int mod = ms->cycle_tally++ % ms->cycle_total;
      if (mod < ms->c1_val) col = ms->c1_col;
      if (mod < ms->c2_val) col = ms->c2_col;

      // always set these, in case we get to the end and the point is skipped beacuse of duplicate colors
      mw_p[ms->num_points][0] = x;
      mw_p[ms->num_points][1] = y;

      // should i add this point?
      if ((ms->num_points == 0) || (col != mw_p[ms->num_points-1][2])) // if first point, or color different from previous
      {
         mw_p[ms->num_points][2] = col;
         ms->num_points++;
      }
   }
}

void mw_draw_line(int x1, int y1, int x2, int y2, float thickness, int cycle_total, int default_color, int c1_val, int c1_col, int c2_val, int c2_col)
{
   ALLEGRO_VERTEX v1;
   ALLEGRO_VERTEX v2;
   v1.x = x1; v1.y = y1; v1.z = 0;
   v2.x = x2; v2.y = y2; v2.z = 0;

   struct mw_state ms;
   ms.num_points = 0;
   ms.cycle_total = cycle_total;
   ms.default_color = default_color;
   ms.c1_val = c1_val;
   ms.c1_col = c1_col;
   ms.c2_val = c2_val;
   ms.c2_col = c2_col;

   al_draw_soft_line(&v1, &v2, (uintptr_t)&ms, mw_FirstFunction, mw_StepFunction, mw_DrawFunction);

   // ensure last point was not skipped, due to duplicate color
   mw_p[ms.num_points][2] = mw_p[ms.num_points-1][2];
   ms.num_points++;


   for (int i=1; i<ms.num_points; i++)
   {
      int x1 = mw_p[i-1][0];
      int y1 = mw_p[i-1][1];
      int x2 = mw_p[i][0];
      int y2 = mw_p[i][1];
      int c =  mw_p[i][2];
      al_draw_line(x1, y1, x2, y2, palette_color[c], thickness);
      //printf("x:%d y:%d  cycle:%d  dtd:%d\n", x, y, cycle, display_transform_double);
   }
}

that was the final iteration...now try it in action!!

see how long it takes...
it is literally 1000 times slower....

plot time: 0.000210   lines drawn:152
plot time: 0.227604   lines drawn:156

I commented out the drawing part...
its not the drawing part, its the call to soft line...

this is useless, but at least now I know it

I just wasted 6 hours on this...

can I make my own code that will do it better?


pass it 2 vertexes
and a span like this:

   int c0_len;
   int c1_col;
   int c1_len;
   int c1_col;

it will create an array of points

point 0 = vertex 1
next point

what math will you use?

total x span
total y span
total length

length of span / color_span = divider

divide xspan and yspan by divider to get incs

do incs and add vertex points...

this is my first hacked together implementaion and it works...
before I go any further, speed test it....


void mw_draw_line2(int x1, int y1, int x2, int y2, float thickness)
{
   int color_span = 10;

   double line_xspan = x2-x1;
   double line_yspan = y2-y1;
   double line_span = sqrt(pow(line_xspan, 2) + pow(line_yspan, 2));

   double div = line_span / color_span; // number of spans

   double xinc = line_xspan / div;
   double yinc = line_yspan / div;

   int xa = x1;
   int ya = y1;

   int xb = xa+xinc;
   int yb = ya+yinc;


   int c = 15;

   while (xa < x2)
   {
      al_draw_line(xa, ya, xb, yb, palette_color[c], thickness);
      if (c == 15) c = 10;
      else if (c == 10) c = 15;
      xa+=xinc;
      ya+=yinc;
      xb+=xinc;
      yb+=yinc;
   }
}


plot time: 0.000283   lines drawn:156


I'm back baby! as proof of concept it works and is just as fast as the al_draw_line...

now clean it up....

what if I kept the remainder of the color shift for the next line, that would make the graph look awesome...

I could keep a static int 'distance travelled' and use mod for the cycling repeats

3 colors, just like last one

this will mean a major rewrite of how I do the getting of lines..

it is so simple now because the span is always the same

8 red
3 blue
4 yellow


get inc from main period (14)
get inc from main to 2   (3)
get inc from 2 to 3      (4)

distance_travelled

start with the args...
 int c0_val, int c0_col, int c1_val, int c1_col, int c2_val, int c2_col))

I have a beautiful three color version working, but no carry over for color shift

plot time: 0.000990   lines drawn:156
plot time: 0.000983   lines drawn:156
plot time: 0.000986   lines drawn:156

now it takes almost 1ms...should I be worried?

it depends on how small the color line segments are


now how will i make this work in the plot? how will I keep track of color?

negative values for color?

2 values for color?

if second one is 0 just draw normally






if (series[s].color2 == 0) al_draw_line(ox, oy, x, y, palette_color[series[s].color1], 1.0);
else                       mw_draw_line(ox, oy, x, y, 1.0, 8, series[s].color1, 10, series[s].color2, 0, 0);

wait how??



I think I do want to implement the color shift across lines...when lines are too short, sometimes they dont show at all...


when I zoom in and get more color segments it really slows down...

do all lines draw every time? yes

try thinning....

did the test for x_axis min...works but i want to draw a line to the first offscreen data points

mak a function to get that....

get lowest x and highet x index on screen...
for each series
cycle the dat

that is done...

can I make a way to adjust the color shift span based on size?
I also could make the color shift carry over...

add clicking on series legend....
put series legend in y axis lineup...??
what order? can I assume...

now I want to try the color shift carry over


remainder as a fraction of position in the total color cycle...

maybe there is an easier way...


startxy endxy

get a unit for 1 pixel diagonally converted to x and y

then I can pick any spot on the line and do x,y

then start drawing the line sequence before the actual line

seg1
get ab_positin
static double line_color_offset = 0;
find un


I have finally done it, after much, much work....











































































































































































































































































































