---------------------------------------------------------
------------------------ Bugs ---------------------------
---------------------------------------------------------




---------------------------------------------------------
------------------------ To Do --------------------------
---------------------------------------------------------


where can I do one place to store version?

so it will show in the compiled program
and also be used for lin and win build scripts

I could just change it in three places...code (pm.h), win and lin make_release..
bump all now to 7.24.0826.1
done...



figure out netgame

I need more documentation...


add more at the end of client timing sync??

there is some better descriptions of both in ping...


this is what I have set right now:

loc[p].client_chase_offset_auto_offset = -0.02;

mPlayer.loc[0].server_state_freq = 1 + mcp/25; // use max_client_ping to set server_state_freq


how am I going to test, and what am I going to vary?

what is up with the client sync adjust?

It does not work like I want it to...

auto mode you can still adjust the offset
manual mode you cannot adjust anything??


I still am lost at how to adjust these things

at the very least add loc[p].client_chase_offset_auto_offset = -0.02; to config

maybe it should be somewhere else rather than the player struct...


I want to move these from loc struct to netgame class


   double client_chase_offset;
   double client_chase_offset_auto_offset;
   int client_chase_offset_mode; // 0 = manual, 1 = auto

done...

what is the default stdf_freq if not auto?


I want to be able to remotely monitor and control the server

I am thinking of some dedicated packets for this:

server will send a big chunk of data to a monitoring computer
like logs and graphs, but in real time

server will accept control packets from the same computer..

but what would I send to control? stdf freq?

I am thinking that I don't want to ever have stdf freq less than 2

but I am not really able to see what affect I am having..

base resets are the most important thing....

I am not sure why lower stdf freq is desirable.
Is it to reduce the size of corrections?

I have played with stdf of 10 and did not see any problems...
it made the initial join take longer

I want to move stdf freq from loc to netgame, just like cco
done...
also add actual value to config and allow to change in settings...done

bump ver and push




I want to see the client sync graph...figure it out...

      if (log_lines_int[i][0] == 30) // stak line
      {
         int p = log_lines_int[i][1];




   sprintf(msg, "%s %s\n", tmsg1, tmsg2);
   if (mLog.LOG_NET_server_rx_stak) mLog.add_log_entry2(33, p, msg);


change 30 to 33

also needs 10? for player active

x_axis_draw_gridlines_and_labels(0);


fixed a bug in graph...

void mwGraph::x_axis_draw_gridlines_and_labels(int set_size_only)


this while would block, so i added a guard to not do it if labels are not drawn

         // find out if major gridline labels will touch each other....
         if (x_axis_grid_label_draw_on)
         {
            int max_space_between_labels = - 9999;
            while (max_space_between_labels < 10)
            {


Now, here is how client_sync_graph works:

- only can run on server
- need to have LOG_NET_server_rx_stak logging enabled
- (optional) need to have LOG_NET enabled if you want to see when clients became active


Fixed all the help entries related to logs...

segfault when opening log...why?

so many fucking bugs!  arrrghhh!!!

fixed bug in get tag that errored when tag was not found


now moving on:

I was wanting to see how the slow chase happens with larger stdf_freq

LAN e6430 server stdf manual 2
start frame 237, lock 303

LAN e6430 server stdf manual 4
start frame 285, lock 384

LAN e6430 server stdf manual 6
start frame 203, lock 339

LAN e6430 server stdf manual 8
start frame 198, lock 372

LAN e6430 server stdf manual 10
start frame 209, lock 422

so I dont see much with this data, but what I do see is that with larger stdf the graph swings up and down more

what the hell is ping graph and what do I need to do to make it work?

   tags[36][0] = 1; tags[36][1] = 13; tags[36][3] = 84; sprintf(ctags[36], "tmaj"); // timer adjust (T) [C]
   tags[37][0] = 1; tags[37][1] = 13; tags[37][3] = 78; sprintf(ctags[37], "cpng"); // client ping  (N) [C]


with higher stdf_freq   dsysnc really has a cyclic pattern

what can I do about that?

can I make packets used for sync different from stdf...

what if I made ping packets once per frame?

hell I was going to send stdf once per frame!!

wait a tick here! I don't use stdf packets for timing....i use pong...

and they only come once every 2s!!! no wonder my chase loop oscillates


compare:


LAN e6430 server stdf manual 10 ping_freq:20
-22 -17 -23 -18 -23 -18
-39.9 - 40.1 on a 2-3 sec sine wave


LAN e6430 server stdf manual 10 ping_freq:2
-29 -12 -27 -13 -26 -14
-39.5 - 40.4 on a 2-3 sec sine wave


LAN e6430 server stdf manual 10 ping_freq:40 (every frame)

I am getting bad results doing it that way...


what if the server just broadcasts ticks

then the client can lock onto those

the client can reply and then the server will know the client time...

I can also make the tick more accurate


why is the dysnc on a 2s cycle, no matter what ping or stdf freq?
I don't know...


DUH!
client timer adjust is based on stdf dsync

that is where it is adjusted

all ping does is set chase offset....


this seems far more complicated than it needs to be...

I want to adjust time more often than when stdf's are received

otherwise stdf's could be my tick

put the ping back

stick it in with the 1Hz stuff

try stdf freq of 4, fixed and see if you can tweak the loop
the chase has very little cycling


what bad things happen when s1 never goes below 4?

I dont know


lets do another release and try over the internet....

seems to work good with manual stdf of 4, 3, 2

the only bad thing is the non local players seem to jump around a lot

but its pretty much the same with 4, 3, 2


I think that this is just the way that it is....



20230827 where am I at?

trying to put the finishing touches on netgame

the most noticeable thing is other players in a netgame
they jump and warp a lot


can you put a number on it?

can you make it less severe?

I think that faster stdf and less offset would make it look better

how can i measure?

I need to do more monitoring on the client, that is where you see all the jumpiness

how about max player correction for any active player...done

it does not show much difference because....

local client has been updated with local moves since last state
remote ones have not

this does not help, it actually is the opposite

try it with a large stdf and see...

tried with 8
remote cor max up to 40
local cor max up to 20

this actually looks like I'm onto something, or just confirming what I already knew

I want to document all the tools I have for monitoring and measuring netgame...

Starting with this...

wait a minute, should I measure corr after ff?

what am I trying to do here


original method:
get pos now
compare to past corrected pos

new method:
get pos now
compare to past corrected pos then played forward to now

alt:
rewind and get pos
apply and compare


of all the methods new seems best.
it compares now to corrected now


what is client_move_lag

measured on client when applying dif

mPlayer.loc[p].client_move_lag = mLoop.frame_num - client_state_dif_src;

what does it mean?

how far back the base frame is.

how many frames the client has been free running before it is corrected

directly related to stdf freq



what is client_rewind

int ff = mPlayer.loc[p].client_rewind = mLoop.frame_num - client_state_dif_dst; // dst compared to current mLoop.frame_num

measured on client when applying dif

the amount of frames that are ff replayed after a dif is applied

directly related to offset??, yes!!

It seems like I am better understanding this now....

the only thing to adjust on the server is stdf_freq

the only thing client can control is their timing relationship to the server

I was adjusting stdf freq based on max client ping, but maybe I should just make that fixed and adjust client offset

I have some values I am trying to minimize:

client_rewind
client_move_lag
late cdats

speaking of late cdats on the client, could I make that part of syn?

it is not documented??

server sets


change

   int late_cdats;
   int late_cdats_last_sec;

from loc to syn

I want to see them on the client and I don't want to pass them both with specialized packets

add 8 more spare ints to syn...done...

old:
psyn is 2304
tot is 112128

new:
psyn is 2304
tot is 112384

now move from loc to syn...done

now remove from packet exchange..done

now show in client debug grid

BUGS i am pretty sure that server rewind is clearing these....

      // save values we don't want rewound
      int lcd[8][2] = { 0 };
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            lcd[pp][0] = mPlayer.syn[pp].late_cdats;
            lcd[pp][1] = mPlayer.syn[pp].late_cdats_last_sec;
         }

      state_to_game_vars(srv_client_state[0][1]);   // apply rewind state
      mLoop.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
      mLoop.loop_frame(ff);

      // restore
      for (int pp=0; pp<NUM_PLAYERS; pp++)
         if (mPlayer.syn[pp].active)
         {
            mPlayer.syn[pp].late_cdats = lcd[pp][0];
            mPlayer.syn[pp].late_cdats_last_sec = lcd[pp][1];
         }

fixed...

bump version and release...
kill all data and config too..

remove late cdats line, now in grid
add cor to client grid
done


lag also, but maybe rename

think up better names for rewind and lag


client_rewind

int ff = mPlayer.loc[p].client_rewind = mLoop.frame_num - client_state_dif_dst; // dst compared to current mLoop.frame_num

measured on client when applying dif

the amount of frames that are ff replayed after a dif is applied

directly related to offset??, yes!!


other name that might be more descriptive:
client_replay_frames
client_ff_frames


releated to client_lag which is:

measured on client when applying dif

mPlayer.loc[p].client_move_lag = mLoop.frame_num - client_state_dif_src;

what does it mean?

how far back the base frame is.

directly related to stdf freq

how many frames the client has been free running before it is corrected
not exactly??


    +-------------+---------------+
base_frame   state_frame    current_frame

cf-sf = client_rewind
cf-bf = client_lag

what if I showed a graphic representation of this:

record the values when dif is applied

sfd (src frame_delta)
dfd (dst frame_delta)


I just realized that frame span between sfd and dfd is stdf_freq..

I really want to see this graphically in real time on the client


+--+--+
s d c





what if I send the entire game state every frame
always based on state zero

why?

just to see what it does

what kind of bandwidth are we talking here?

would it help with retransmits

how can I easily swap this in for testing?

what do I get before


do this with m36 as server and e6430 as client....

s1:2 no base resets 5kB
s1:1 no base resets 7kB
size 300



base 0
70K
size 3000


make it optional with stdf_freq = 0??


check what actually is going on...

is s1 == 1 everyframe?

no...wtf??

new state:359   s1:2
new state:362   s1:2
new state:365   s1:2
new state:368   s1:2
new state:371   s1:2

new state:393   s1:1
new state:395   s1:1
new state:397   s1:1
new state:399   s1:1
new state:401   s1:1

new state:484   s1:0
new state:485   s1:0
new state:486   s1:0



this is not what I expected, it could explain many things....

if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1)    // is it time to create a new state?

change it so that it does what I expect...

if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1 -1)    // is it time to create a new state?


0 = every frame and no base
1 = every frame
2 = every 2 frame
3 = every 3 frame


new state:191   s1:3
new state:194   s1:3
new state:197   s1:3

new state:200   s1:2
new state:202   s1:2
new state:204   s1:2

new state:226   s1:1
new state:227   s1:1
new state:228   s1:1

new state:250   s1:0
new state:251   s1:0
new state:252   s1:0


new bandwidths:

s1:3 no base resets 5kB
s1:2 no base resets 7kB
s1:1 no base resets 13kB
size 300


base 0
140K
size 3000


lets bump, deploy and test

can I make my headless server still detect serial key check?


it works over the internet with s1=0

each client uses about 140kB/s

still does not look much better with the warping corrections

my nice graphical thing is broken...it depends on the stdf src, which I am setting to zero for base reset reasons...

why do I even care about dif src?

I just liked having something to show on the client...

why not just the time from now to the dest of the dif...

that is crwd or ff


If I leave s1:0

the only other thing I can adjust is the client offset...
and I want to monitor crwd...

I can get 2 with offset > 25

and 1 with < 25


but I cant do < 25 when ping is 30

try local

m36 server and 2 clients
each has 330kps for a total of 670kbps  wow
I guess it depends on the level
that was level 64
level 1 has 135 each for a total of 270


does not seem to make much difference in the warping...
its better I think, but not dramatically better, hard to tell...

what is stsy, cdsy and gmav on server debug grid?




stsy - server stak sync
mPlayer.loc[p].stak_dsync*1000);
when server rx stak, how long did it take from client
not really used, more like a ping time


cdsy - client dsync
mPlayer.loc[p].dsync
calculated by client and passed to server with stak packets


gmav - client game move sync avg last sec
when server processes cdat it compares the time to the current server time
tallies average last sec for each client



I really want to be able to control and monitor the headless server remotely



how?

a seperate program connected with my own custom packet exchange?


or a connected client can just open a debug connection to the server

I want to see the full debug overlay, and be able to control s1 and zc


it would be easier (maybe) to base it off a connected client

put the client in a special inactive state...


or I could make my own connection...
independant of the netgame


I want to write up what I have discovered today. Formally, so I do not have to discover it again later.

First of all the good news. Netgame is working well. As good as possible with the current algorithm.

Now for the bad news.

Not really bad, but there is some warping of non-local clients on other clients games.

It looks like the player is twitching and jumping around.

Its really not that bad, but I spent a lot of time and effort to see if I could get rid of it or at least minimize it.


There are only a few adjustable things in the game.

On the server, the rate the states are sent.

On the the client, the timing offset in relation to the server.


First of all, lets discuss stdf_freq, the rate the server send states to clients.

0 = every frame and no base
1 = every frame
2 = every 2 frames
3 = every 3 frames

The more often they are sent, the less corrections on the clients.

This time I even made a new setting, 0, which in addition to sending states every frame,
also gets rid of the need for a base to make a diff with.

This was attempted to see what would happen.  Here is what happens:
The amount of bandwidth increases almost 10 times.

There might be a slight improvement in the client corrections, but its barely noticeable.
The functionality is left there to experiment with.
All you need to do is manually set stdf_freq to 0;

The end result is that will probably always use manual 1 for stdf_freq.


Next of all is client_offset.

In order for things to run as smooth as possible, with the fewest corrections, client offset should be as low as possible.

In a LAN with low ping times you can set client_offset as low as 5-10;

If you set it too low you will get late_cdats. Where the server gets input too late to be applied.


























-------------------------------------

If I do not need states for making clients difs, could I keep extra for late_cdats

I am not sure what I am talking about here...


I am adjusting client sync to get very close to the server, but as I get too close I get late cdats...


ideally I would get the dif on the frame it was needed, but then my input would be...


what would happen if I kept more states on the server, like 20, enough for 500ms of game time
then late cdats would not be an issue?

but how late of an input would I allow to affect the current state?

am i onto something here or am I just crazy?


what would it take to test?



an array of game states

lets just do 8 for now


   // server's last 8 states for rewinding
   char srv_rewind_state[8][STATE_SIZE];
   int srv_rewind_state_frame_num[8];


now every frame save state

how will I juggle the circular array?

find oldest and overwrite...


in function server rewind...

I will need to keep track of dirty frames

how about earliest new game move

wait..game move is not sorted..i can use that to my advantage

how about looking back

each time a state is made, also store gmep for that frame

then and this get tricky here

cf = 100

I have states from 92-99 stored

take the oldest state
look for new moves that match that state

I could just play back and make new ones, that seems simpler

- load oldest state
- step one frame at a time and save states

this all seems so complex

why do I not make the one that I base these on one frame earlier...

I am so confused....



when server makes a new state it overwrites the old base state

I want it to keep at least one older version

then when rewinding go back to the earliest version

then save newest and bump that to oldest



this is sounding like something that might work...


when server makes a new state save also save it in my new array and overwrite the oldest position



when server rewinds, find the oldest state in the array and load from there


wow! this is so simple and is just crazy enough to work



I need a good way of finding the oldest (min) frame_number

initialize array with mn = std::numeric_limits<int>::max();

     // also save in array

     // find lowest frame number
     int mn = std::numeric_limits<int>::max();
     int indx = 0;
     for (int i=0; i<8; i++)
     {
        if (srv_rewind_state_frame_num[i] < mn)
        {
           mn = srv_rewind_state_frame_num[i];
           indx = i;
        }
     }


     memcpy(srv_rewind_state[indx], srv_client_state[0][1], STATE_SIZE);

OK I have patched it in...lets take it for a ride


my min max bullshit doesn't work

start with zero


what do I want?

when adding I want to remove the lowest

when fetching I want to find the lowest

have -1 as unset....

when adding, do all -1 first, then lowest

when fetching, ignore -1



OK I have patched it in and it works, right up until I get late cdats, then it all goes to hell

do I even need to toss late cdats? they will not be executed...
I do because I want know that they are occuring and I want to be able to play back the save game


I could easily remove this new code I have added....


I was thinking...does this not require the client to also have the previuos state?
no...client base states are different, but are they?

I could test with s1 = 0...

It looks like its a server problem...

when ever the client does a sync offset and catches up to and passes the server the server gets messed up...


it happens when server tries to enter late game move??


I think I might know why?

server rewinds back 8 then replays to apply new input, but it only saves the newest state after the rewind.
it should resave all of them...


the way I have the states in a ring buffer is not needed anymore.

I will be redoing the entire list everytime I rewind

always have the oldest in position 0, then newer until space is gone

I only ever load from the oldest anyway...




load earliest state

ff and save rewind states up for current

play current

save current in rewind and other



reset all rewind states

or I could have a rewind_state_entry_index and reset that to zero


I think I have this new method working, kind of...

remove all traces orf old and save here in the comments..then test more


//int mwNetgame::find_earliest_rewind_state(void)
//{
//   // find lowest frame number
//   int mn = std::numeric_limits<int>::max();
//   int indx = -1;
//   for (int i=0; i<8; i++)
//   {
//      if ((srv_rewind_state_frame_num[i] > -1) && (srv_rewind_state_frame_num[i] < mn))
//      {
//         mn = srv_rewind_state_frame_num[i];
//         indx = i;
//      }
//   }
//   return indx;
//}


//
//void mwNetgame::add_rewind_state(void)
//{
//   int indx = -1;
//
//   // first use all empty slots (-1)
//   for (int i=0; i<8; i++)
//      if (srv_rewind_state_frame_num[i] == -1) indx = i;
//
//
//   if (indx == -1) // no empty's left
//   {
//      // find lowest frame number
//      int mn = std::numeric_limits<int>::max();
//      for (int i=0; i<8; i++)
//         if (srv_rewind_state_frame_num[i] < mn)
//         {
//            mn = srv_rewind_state_frame_num[i];
//            indx = i;
//         }
//   }
//   if (indx == -1)
//   {
//      //show_rewind_states(" -  indx:%d  frame:%d  ERROR! adding server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//   }
//   else
//   {
//      //show_rewind_states(" -  indx:%d  frame:%d  adding server rewind state \n", indx, srv_rewind_state_frame_num[indx]);
//      memcpy(srv_rewind_state[indx], srv_client_state[0][1], STATE_SIZE);
//      srv_rewind_state_frame_num[indx] = srv_client_state_frame_num[0][1];
//   }
//}
//
//
//
//void mwNetgame::load_earliest_rewind_state(void)
//{
//   if (mLoop.frame_num > 0)
//   {
//      int indx = find_earliest_rewind_state();
//      if (indx > -1)
//      {
//         memcpy(srv_client_state[0][1], srv_rewind_state[indx], STATE_SIZE);
//         srv_client_state_frame_num[0][1] = srv_rewind_state_frame_num[indx];
//        // show_rewind_states(" -  indx:%d  frame:%d  loading server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//      }
////      else show_rewind_states(" -  indx:%d  frame:%d  ERROR! loading server rewind state\n", indx, srv_rewind_state_frame_num[indx]);
//   }
//}
//

the whole algorithm is flawed...

34 34 -1 -1 -1 -1 -1 -1 frame:34
stdf saved server state[1]:34
stdf rewind to:35
35 35 -1 -1 -1 -1 -1 -1 frame:35
stdf saved server state[1]:35
stdf rewind to:36


rewind to index 0 then play back to current

but it only does the first few....



it might work when setup, but how to get it setup?

do not overwrite oldest? until array is filled?


I have thought about making this whole thing a class...

then I could tell it:

rewind to oldest and play back to current

and I would know how to do this from the start as well as while running


get a very detailed description of how you want it to work

- start out with all 8 rewind slots blank (frame set to -1)

- when server starts, add state from frame 0 to index 0

then every frame:

find the oldest and rewind to that one, ignoring -1's

then set that index to -1 so it can be reused

what if the oldest was always in slot 0?

then rewind to oldest

and as you play back overwrite from 0 up

this sound easy and intuitive:

1 - rewind to earliest (probably always index 0, maybe skip check and rewind to index 0)

2 - erase all other frame numbers (set to -1)

3 - as you play back save all new states


the only problem with this is it will start by rewinding 1 and never grow to more...


how about 0 is current frame and all others are previuos

have a way of poking in new state from the end and shifting all others back one, (and losing earliest)


1 - rewind to earliest
2 - play back and overwrite matching frame numbers
3 - do current loop and push from end, dropping earliest

3 could also be:
- find a place to put newest
- could be a -1, or if no -1 then the earliest

I think this might actually work!!


first of all, do I reset to -1? yes, i do

   for (int i=0; i<8; i++)
   {
      memset(srv_rewind_state[i], 0, STATE_SIZE);
      srv_rewind_state_frame_num[i] = -1;
   }

next, add initial state to index 0

bring back rewind to earliest (not including -1)

do i need multiple find earliest?

when I am rewinding, I want to min, but ignore -1

when I am adding, I want to replace the earliest, but -1 first


make 2 versions...




I think I have this all working...

server is saving states like it should

client can run with positive sync
need to clean it up a bit and do more tests...


cleaned up the code a bit...do some more tests tomorrow



what does it mean if the client dsync goes positive?
it means I can get crwd to zero, where the client does not have to ff after receving states

If I go too far and get crwd -1 then the client is dropped by the server?


tested over internet and it seems very choppy...also takes lots of cpu...

test more....



It is relatively simple to comment out in code:



Here are all the places in the server code:



void mwNetgame::server_rewind(void)
{

//      // load earliest rewind state
//      load_earliest_rewind_state();
//      mLog.addf(LOG_NET_stdf, 0, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);


      // calculate ff (how many frames will need to be replayed in fast forward mode)
      int ff = mLoop.frame_num - srv_client_state_frame_num[0][1];  // almost always equals s1, unless s1 has changed

      // apply rewind state and set frame num
      state_to_game_vars(srv_client_state[0][1]);
      mLoop.frame_num = srv_client_state_frame_num[0][1];

      // fast forward and save rewind states
      for (int i=0; i<ff; i++)
      {
         mLoop.loop_frame(1);
//         add_rewind_state(mLoop.frame_num);
      }

//      show_rewind_states("frame:%d\n", mLoop.frame_num);



server_create_new_state(void)

      // save state as a base for next rewind
      game_vars_to_state(srv_client_state[0][1]);
      srv_client_state_frame_num[0][1] = mLoop.frame_num+1;

//      add_rewind_state(mLoop.frame_num+1);



cdat:

   // find oldest frame
   int of = srv_client_state_frame_num[0][1]; // default
//   int indx = find_earliest_rewind_state(0);
//   if (indx > -1) of = srv_rewind_state_frame_num[indx];



I actually don't think this is a bad idea to save more rewind states

then I could do away with using  srv_client_state[0][1]...but maybe I need it beacuse I need a source and a dest to make a dif??

----------------------------------------

maybe I could encapsulate this in a class owned by netgame

name: state_ring_buffer, state_history

methods:
clear
add_initial
load_earliest_rewind_state
add_rewind_state

----------------------------------------

when sending dif:

on server, after applying moves for current frame, that frame is saved with frame+1 as the base for the next frame
but when the dif is sent to clients, its dest is set to the current frame

i don't know if that is an issue, but it looks funny in the logs when i see:
stdf saved server state[1]:277
tx stdf p:1 [src:275 dst:276] cmp:600 ratio:0.53 [1 packets needed]


on the client:

frame_num++
mNetgame.client_control();
mPlayer.proc_player_input();

so the client will get a new state then process local input

I think this all looks good... I mean, it is working....so it should be correct....

----------------------------------------

made some defines in mwNetgame.h
#define NUM_REWIND_STATES 8
#define USE_REWIND_STATES

test cpu usage

m36 server with 1 client on LAN
8 27%
4 24%
disabled 20%

m36 server with no clients
8 14-16%
4 12-14%
disabled 9-10%


e6420 server with 1 client internet
4 50%
but its doing stdf freq = 1 and base resets every frame



----------------------------------------

test some more

it looks like this new method can get the client a little closer to the server in time

on LAN when crwd is zero it seems to work great

on internet when increased to make crwd one less than normal it seems good, but more than that and it gets really jumpy


what about making s1 = 2 forced..test what happens...

I also notice that the printing to console takes a noticeable amount of cpu


---------------------

so to recap, the saving of more rewind states thing, what has it achieved?

- it allows me to run a client closer in time to the server without getting late cdats

before I had to stay a little behind...

I am so confused as too which way....

And I don't explicitly say in the docs..

can I figure it out with crwd?

if crwd = 0 then difs are arriving exactly on the frame they are needed

if crwd = 1 then difs are arriving 1 frame too late.
because then after applying 1 frame has to be played back

when sync is from -25 to 0   crwd = 1
when sync is from -25 to -50 crwd = 2

when client has to ff it means that the server is ahead, or in other words that the client is behind

so with this data I can say that:

dysnc is 0 when client receives dif exactly when needed
dysnc is negative when client recieves dif before it is needed (then it is applied and fast forwarded)
dysnc is positive when client receives dif after it is needed (this would never work, client would jump ahead)

so then why do I get late cdats when client gets closer to 0?

i think it was when there was not much time between rewind states
but now that that is not an issue...

I want to run the client as close as I can behind the server, so that crwd is zero

this seems to work well on LAN but not internet

do some tests and look at gmav and stuff

-----------
I just had a brainwave

you know how I do logs for netgame? what if I did a huge graph with all the relevant data...

like dsync,


 -------------

 Here is the official client dsync decription



 -------------



Do I want to run the client as close as I can to the server so that rewind is zero?

Are there any drawbacks to this?


test with e6430 as server and 2 clients

server force stdf 1 and 4 rewind states

in a LAN game with ping 0

sync is auto at -20
crwd is 1
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: -20
stsy: 15
gmav: 15


this looks great!

plays beautifully on LAN, even client on other client looks perfect..
cpu 30% on e6430 server with no overlay


now try to reduce sync...

manually lower sync to 10
-------------------------------------
crwd is 1
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: -10
stsy: 6
gmav: 6


manually lower sync to -5 (at zero it bounces between crwd 0 and 1)
-------------------------------------
crwd is 0
maxcor 6.4
nlcmxcor:6.4

srv shows
cdsy: 5
stsy: 15
gmav: -10


Now try with internet connection
-------------------------------------
ping is 23-28
sync is around -50
constant base resets
probably due to stdf freq = 1
e6430 cpu = 42 no ovrlay

crwd is 2-3
maxcor 6.4
nlcmxcor:12.6

srv shows
cdsy: -50
stsy: 12
gmav: 10

playable, a bit jumpy on non-local client



Now try lowering sync...
-------------------------------------
from -50 to -20

crwd is 1
maxcor 6.4
nlcmxcor:12.6

srv shows
cdsy: -20
stsy: 12
gmav: -15

playable, a bit jumpy on non-local client same as last trial pretty much



Now try with server stdf freq = 2
-------------------------------------
base resets gone (rare)
e6430 cpu = 30 no ovrlay

crwd is 1
maxcor 6.4
nlcmxcor:18.6

srv shows
cdsy: -20
stsy: 38-40
gmav: -13


a bit more jumpy



Go back to auto sync
-------------------------------------
now around -50
crwd is 2
maxcor 6.4
nlcmxcor:18.6

srv shows
cdsy: -47
stsy: 38-40
gmav: 12-14

same as last a bit more jumpy




Now try LAN with stdf freq = 2

it makes nlcmxcor: 12 instead of 6




-----------------------------
final thoughts:

It makes sense that the longer I go between state updates the further out of sync I will get...



I should set stdf_freq as low as possible...

I could even do the same thing I do on the server and keep multiple previous base states, but how much of an issue is it if I send the entire state every frame?

what if I just moved the clients offset so that the bases were not late? i don't think that will work, its a two way thing with the client acknowledging

just because I keep previous states on the client does not mean I have to ff from earlier, i only ff from the dest, not the src


but then on the server what gap should I use?

make a frame and base it on the -2 frame? always?

how much data?

how can I test forcing all zeros everytime?

2 - 7k
1 - 13k
0 - 137k


also what if I based it off the state of the loaded level...

I want to test this...

where can I save that?

it seems like it will use alot less data, like still one packet...

lets see if I can make this work...


I see one potential problem...server and client do not have the same starting point

but they really should...

I think it is mostly the player array....


I could make the server send a special initial state...

or I could figure out how to ensure player struct is always the same after a level load...


lets try number 1


number 2 what is changed?

      syn[p].active = 0;
      syn[p].paused = 0;
      syn[p].control_method = 0;

save before load
set to zero
save copy
restore


what do I need to do for number 1?


make server send its loaded level based on zero....
this is the only safe way...need to make sure they have the same base...



what is the easiest way to do this?

when a client joins have the server send the full zero base...


made a function on server:

void mwNetgame::server_send_base(int p) // send base to a client
{
   char zero[STATE_SIZE];
   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   memset(zero, 0, STATE_SIZE);

   get_state_dif(zero, load_state, dif, STATE_SIZE);

   // compress dif to cmp
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
   int cmp_size = destLen;
   float cr = (float)cmp_size*100 / (float)STATE_SIZE; // compression ratio

   // break compressed dif into smaller pieces
   int num_packets = (cmp_size / 1000) + 1;

   mPlayer.loc[p].cmp_dif_size = cmp_size;
   mPlayer.loc[p].num_dif_packets = num_packets;

   mLog.addf(LOG_NET_stdf, 0, "tx stdf p:%d [src:%d dst:%d] cmp:%d ratio:%3.2f [%d packets needed]\n", p, 0, 0, cmp_size, cr, num_packets);

   int start_byte = 0;
   for (int packet_num=0; packet_num < num_packets; packet_num++)
   {
      int packet_data_size = 1000; // default size
      if (start_byte + packet_data_size > cmp_size) packet_data_size = cmp_size - start_byte; // last piece is smaller

      mLog.addf(LOG_NET_stdf_packets, 0, "tx stdf piece [%d of %d] [%d to %d] st:%4d sz:%4d\n", packet_num+1, num_packets, 0, 0, start_byte, packet_data_size);

      Packet("stdf");
      PacketPut4ByteInt(0); // src frame_num
      PacketPut4ByteInt(0); // dst frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, mPlayer.loc[p].who, p);
      start_byte+=1000;
   }
}



I don't want to break the easy way I had clients go to the next level


- client join, or any time

does client have base 0,0 if not get it

Desktop Resolution: 3840x2160

Variables used to save levels in pml format

mLevel.l       : 40000
mItem.item     : 32000
mEnemy.Ef      :  6400
mEnemy.Ei      : 12800
mLift.cur      :  4480
mLift.stp      : 38400
mItem.pmsgtext :250000
------------:------
total       :384080

Variables used for netgame state exchange

mPlayer.syn         :  2304
mEnemy.Ei           : 12800
mEnemy.Ef           :  6400
mItem.item          : 32000
mItem.itemf         :  8000
mLift.cur           :  4480
mLevel.l            : 40000
mShot.p             :  1200
mShot.e             :  1200
mTriggerEvent.event :  4000
---------:------
total    :112384



mLift.stp      : 38400
mItem.pmsgtext :250000


112384
250000
 38400
-------
400,784

this is what it would take to do the entire game state, so that the client would not even need a copy of the level....
I am not pround of that 250K text file, what else could I do?

for now I just want to patch in this new method...

when the server loads a new level, it will save its base state then send that to clients..once


what will the data structure look like?


there will be one variable for the base state that gets save after server loads level
base_state

client will also use this same variable

there needs to be a way to tell if client has the base

how about a frame number associated with it?

it should be frame 0...if it is less, like -3 then it has not been loaded yet..

char base_state[STATE_SIZE];
int client_base_state_frame_num[8];

when loading level:

mNetgame.game_vars_to_state(mNetgame.base_state); // server's master base state
for (int i=0; i<8; i++) mNetgame.client_base_state_frame_num[i] = -3;

when server sends state:

when client gets state





client gets base...

client chases from zero

when it catches up and applies first state from base it dies on draw player to screen


first of all, make it stay in wait until we get a better base...

done...now it joins a lot faster, but still dies exactly like before






what gets subtratced from what??


when making a dif:
get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);


when applying a dif on client:
apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

void apply_state_dif(char *a, char *c, int size)
{
   for (int i=0; i< size; i++) a[i] -= c[i];
}


when I comment out the player draw direct to screen, the client joins, but has messed up colors for player and others...

blocks and bullets look OK

what is getting screwed up?

either I do not have the proper base, or I am not sending it properly, or, I am not decoding it properly....


lets go through everything again:

I found it!!


This is wrong:
memcpy(base_state, client_state_dif, STATE_SIZE);

This is correct:
memset(base_state, 0, STATE_SIZE);
mNetgame.apply_state_dif(base_state, client_state_dif, STATE_SIZE);


OK lets go back and put things together..



Testing...the amount of data needed increases as the game goes on...the further away from the initial state you get.
what is the busiest level?
little rocket...after a minute i'm up to 4K packets and 160kB/s
160 x 7 = 1.2MB/s



I would like to experiment with saving new client base states after a fixed amount of time. Like 1s 30s 60s etc...
how will I do that?

do I want to go back to where each client had its own base?

It seems like this method is using a lot more cpu

Am I copying a lots of states unneccesarily?

on the client I suppose I could use client_state_base like I always used to...
only now it will be set from base_state...





I have a lot of duplicated states maybe:

why can't I re-use the same ones across client and server?

I am expecially thinking of the [8][2] array

server uses it to keep 2 states for each client

why can't clients also use it?

in the interests of saving memory and being clever I am going to make it much harder to understand...lol

0 is the base
1 is the working copy

copy base from 0 to 1
apply dif to 1
1 to game state


no matter how I do it, each frame I will need to make a copy of the base and apply a dif to it...unless I just overwrite the base and lose it..

will this work?

on the server 1-7 are used
0 is used for local server state (but rewind could replace that...)

on clients 1-7 are not used...they should be...

lets do it....



old names:
   char srv_client_state[8][2][STATE_SIZE];
   int srv_client_state_frame_num[8][2];

   // local client's states
   char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
   int  client_state_buffer_pieces[16];   // to mark packet pieces as received
   char client_state_base[STATE_SIZE];    // last ack state
   int  client_state_base_frame_num;      // last ack state frame_num
   char client_state_dif[STATE_SIZE];     // uncompressed dif
   int  client_state_dif_src;             // uncompressed dif src frame_num
   int  client_state_dif_dst;             // uncompressed dif dst frame_num

   // servers master copy of base state
   char base_state[STATE_SIZE];
   int client_base_state_frame_num[8];

how many?

16 + 3 + 1 = 20



new names:

client_state[8][2]

0 = base
1 = working



[0][0] server and client base

[1-7][0] copy base here on clients then modify
[1-7][1] buffer for building compressed dif from packets

then decompress to temp and apply to 0


I could simplify like this also:

use the 2 unused slots on clients to replace 2 states

base and uncompressed...

I actually think I will be storing client base individually for each client


client_state[8][4] approx 40M

before I redo all the data structures figure out how I'm going to do that...

can I ever go back to the way it was with states...

why did i do this? because over the internet stdf freq of 1 would make me reset base a lot


I would really like to be able to switch between these 2 modes, but that might be too hard..


lets see what I can do with updating the base periodically


on the server it would be as easy as just sending a certain state and saying that it was now the new base...



right now they are all 0-100 0-101, 0-102...etc  what if I sent 100-100 and let the client know that I wanted this to be the new base...but how?

then the client would save that as the new base and reply in stak...

maybe it could be driven by the client...then client will tell the server it wants to start using a new base and from then on the server does...




Another big idea would have been to have the client store a few old states


I want to make a framework where I could do multiple algorithms..

right now task manager says I am using 150M

and 1.2Mbps Network, by my calculations I am using 140MBps so that tracks


I don't think it would be a big deal to make an state array:
client_state[8][3] approx 30M

do it...


client_state[8][3]
client_state_frame[8][3][2]

client_state[8][0] base
client_state[8][1] base copy for modifying


why?? this will make it harder to understand...


OK to start with replace base_state with

state[8][2] will replace srv_client_state[8][2]

do it...

holy shit it still compiles

replace base_state with state[0][0] on server and state[p][0] on client

done...


replace client_base_state_frame_num[8]; state_frame_num[8][0];


OK now I want to replace

   char client_state_base[STATE_SIZE];    // last ack state
   int  client_state_base_frame_num;      // last ack state frame_num

with

state[p][0];
state_frame_num[p][0];

then it will be consistant, all 0's will be base states..done


then I want to make the server uses bases for each client instead of a common one

am I circling back to where I was before?

to start with save in all clients when loading level..done

then when client sends stak...



how about on client when applying % 100 frame, save that as the next base and



I think that the server should be the one that tells the client what to save as a base


the server is always right....

how would that work?

it would have to be a state that we are no longer accepting input for...

why don't we just save a few states on the client as well

the client can have a rolling buffer like the server


suppose the client has the last 4 states received


the server will make states base on the last skip 2 states


make the server rewind thing a class and then make one for the client also

I don't really want to go from a static base, I want it to be a rolling base

what are you going to call it?



state_history
state_buffer
state_ring

mwStateHistory


loop 588

      mNetgame.game_vars_to_state(mNetgame.state[0][1]);
      mNetgame.state_frame_num[0][1] = frame_num;

      mLog.addf(LOG_NET_stdf, 0, "stdf saved server state[1]:%d\n", frame_num);

      mNetgame.game_vars_to_state(mNetgame.mStateHistory.history_state[0]);
      mNetgame.mStateHistory.history_state_frame_num[0] = frame_num;


loop 1033

      mNetgame.game_vars_to_state(mNetgame.state[0][1]);
      mNetgame.state_frame_num[0][1] = frame_num;

      mLog.addf(LOG_NET_stdf, 0, "stdf saved server state[1]:%d\n", frame_num);


      mNetgame.game_vars_to_state(mNetgame.mStateHistory.history_state[0]);
      mNetgame.mStateHistory.history_state_frame_num[0] = frame_num;





done...now on client save a history of states the server sent

like, keep the last 4 or so....


then when receiving a dif, just find the base that matches


then when sending difs, pick a base a few back from the current state...

what will all of this accomplish?
I should be able to send difs every frame, even when I have internet lag.
I will not get base resets, because I will have a few previous bases...


can I use the same state_history object for clients? I don't see why not...


when and where?

client apply dif....

should I only save to history when applied? like exact frame matches?
yes, start with that...

that was so simple, now what?

send acknowledge of last frame


I'm going to have to redo this all over again...

client getting initial state, sending staks, server sending based on staks... but now I will have some wiggle room with multiple history staks...



basically when client staks a certain frame, server can now send from that or newer....


how will it start?

back to client waiting for initial state..



change the part in program_state 21 back....

old:
      if ((mNetgame.state_frame_num[p][0] == 0) && (mLoop.frame_num > 0))
      {
         mPlayer.loc[p].client_last_stdf_rx_frame_num = frame_num + 2000; // set holdoff 200 frames in future so client won't try to drop while syncing
         mLog.add_headerf(LOG_NET_network_setup, p, 0, "Client received base state and initial state");
         state[0] = 11;
      }


original:


      if (frame_num > 0)
      {
         int p = mPlayer.active_local_player;
         // set holdoff 200 frames in future so client won't try to drop while syncing
         mPlayer.loc[p].client_last_stdf_rx_frame_num = frame_num + 200;
         state[0] = 11;
      }

done:


when the server creates a new dif to send:
it need to find an appropriate base to use...

on the server state_frame_num[p][0] should have the frame number of the last acknowledge state
it is set when receiving stak...

use this when creating a state, just like before

but where will i get the actual states from? the same place? yes for now, till something better comes up...


fixed this in serevr rx stak

//   state_frame_num[p][0] = ack_frame_num; // client has acknowledged having this base

   if (ack_frame_num == state_frame_num[p][1]) // check to make sure we have a copy of acknowledged state
   {
      // acknowledged state is new base state
      memcpy(state[p][0], state[p][1], STATE_SIZE);  // copy 1 to 0
      state_frame_num[p][0] = state_frame_num[p][1];

   }
   else // we don't have a copy of acknowledged state !!!
   {
      // see if we can find it in history...if not then reset to zero

//      memset(srv_client_state[p][0], 0, STATE_SIZE); // reset base to all zero
//      srv_client_state_frame_num[p][0] = 0;
//      mPlayer.loc[p].client_base_resets++;


   }


now I need a way to look for it in history...

//   state_frame_num[p][0] = ack_frame_num; // client has acknowledged having this base

   if (ack_frame_num == state_frame_num[p][1]) // check to make sure we have a copy of acknowledged state
   {
      // acknowledged state is new base state
      memcpy(state[p][0], state[p][1], STATE_SIZE);  // copy 1 to 0
      state_frame_num[p][0] = state_frame_num[p][1];

   }
   else // we don't have a copy of acknowledged state !!!
   {
      // see if we can find it in history...if not then reset to zero
      int indx = -1;
      for (int i=0; i<NUM_HISTORY_STATES; i++)
         if (ack_frame_num == mStateHistory.history_state_frame_num[i]) indx = i;

      if (indx > -1)
      {
         memcpy(state[p][0], mStateHistory.history_state[indx], STATE_SIZE);
         state_frame_num[p][0] = ack_frame_num;
      }
      else
      {
         memset(state[p][0], 0, STATE_SIZE); // reset base to all zero
         state_frame_num[p][0] = 0;
         mPlayer.loc[p].client_base_resets++;
      }
   }

here is the whole thing...



now that the server has that, it should be easy to make new difs...

original


   char msg[1024];
   // if last_ack_state_frame == 0 set base to all zeros
   if (srv_client_state_frame_num[p][0] == 0) memset(srv_client_state[p][0], 0, STATE_SIZE);

   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   // put current state in client's state slot 1
   game_vars_to_state(srv_client_state[p][1]);

   // put current mLoop.frame_num
   srv_client_state_frame_num[p][1] = mLoop.frame_num;

   // make a new dif from base and current
   get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);



new
         if (state_frame_num[p][0] == -3) // client does not have initial base state
         {
            char zero[STATE_SIZE] = {0};
            get_state_dif(zero, state[p][0], dif, STATE_SIZE);
            server_send_compressed_dif(p, 0, 0, dif);
         }
         else // normal dif
         {
            // make a new dif from current game state and base for this client
            char current_state[STATE_SIZE];
            game_vars_to_state(current_state);
            get_state_dif(state[p][0], current_state, dif, STATE_SIZE);
            server_send_compressed_dif(p, state_frame_num[p][0], mLoop.frame_num, dif);
         }




ok that part is done also...

now what about load level...


goddamn am I ready to try?

waiting for game state frm server....




-------------------------

20230910

yesterday I did massive 20H session.
changed all of netgame to use a single base created after level load.
it was nice, used 400 to 500 byte packets...
then I tried it on bigger, more complicated levels and it grew to 5-8K
then I though I would resend a new base ocaasionally, but that was too complex
so I ripped it all out started to implement a state history buffer on client as well
that is most done, but not quite working yet.
I also made a new class mwStateHistory that I use for both server rewind and client history


joins then dies


combine log message for rewind and save server state

I don't think I can, they happen as such different times
- rewind
- save state
- send dif

comment out the top 2 for now
combine and make server rx sdak nicer too


done...

client dies on move player??

client joins sometimes with proper cm and same on server
but position is off on client only...


could I have an issue with the server re doing states?

if I get a state from the server, could it later change?  I think it could...

do I need to separate the rewind states from the client base states?

because when rewinding I change them?

server sends dif 98-100

server later changes 98

why was this never an issue before?

because I never dipped into the rewind states to use as bases!!!

how hard will this be to implement?

it was surpisingly easy...

changed to array: mwStateHistory mStateHistory[8];
changed all times server uses it to mStateHistory[0] and client to mStateHistory[p]

client connects nicely now, but dies a few frames later....

I might be doing something wrong in client apply dif...

what are the the 2 states used for?

0 is the base
1 is the new state??

0 should not be overwritten until

in the old method it was called client_state_base
now I call it state[p][0]

I think it is the same:

first make sure base matches dif_src
then apply dif to base
the use base to set vars
the save state (which uses vars to create a new one)
then ff

the state left in base will be the base for next time
or if if does not match, look in history...


this all looks good, so what is going wrong?

it looks like the problem was the server making a new state for the next frame, but not adding 1 to frame when sending and saving

It seems to work smoothtly now...

test and monitor

this looks great on LAN cannot detect any lag...
no maxcor??
tested with 2 clients...no corrections locally and half what I normally got before for non-local client


clients quitting need to clean stuff up so they can rejoin without restarting server....
added mStateHistory[p].initialize(); to mwNetgame::reset_client_state(int p)


lets test on internet

having weird issues

server would not work on e6430 anymore, finally got server to work on scat

e6430 connected and worked good, but m36 would not

rebooted m36 and connected but it messed up the other client...

I now have tested scat server with three clients and it works
but occasionally a client will fuck up and all clients will die hard

sometimes the player colors get messed up too...

do some logging on clients and see what I can see


I found a bug in client, when applying dif, if base does not match then send newest state
it used to just try to apply it anyway...

maybe I should set it to what I have in state[p][0]...???

probably the same....


anyway, I still get crashes that kill all the clients


whatever I did this last time, I made the clients all jumpy....


clients look like they have a huge swing in dsync

dsync is all over the place

but ping is not...

I am basing this on the first stdf packet received in a frame, but maybe I should look at something else....


[28][1][47946]rx stdf piece [1 of 2] [47921 to 47942] st:   0 sz:1000
[28][1][47946]rx stdf piece [2 of 2] [47921 to 47942] st:1000 sz: 148
[28][1][47946]rx stdf piece [1 of 2] [47921 to 47943] st:   0 sz:1000
[28][1][47946]rx stdf piece [2 of 2] [47921 to 47943] st:1000 sz: 149
[28][1][47947]rx stdf piece [1 of 9] [0 to 47944] st:   0 sz:1000
[37][1][47947]timer adjust dsync[-72.81] offset[-51.70] fps_chase[31.447]
[28][1][47947]rx stdf piece [2 of 9] [0 to 47944] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47944] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47944] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47944] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47944] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47944] st:6000 sz:1000
[28][1][47947]rx stdf piece [8 of 9] [0 to 47944] st:7000 sz:1000
[28][1][47947]rx stdf piece [9 of 9] [0 to 47944] st:8000 sz: 279
[28][1][47947]rx stdf piece [1 of 9] [0 to 47945] st:   0 sz:1000
[28][1][47947]rx stdf piece [2 of 9] [0 to 47945] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47945] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47945] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47945] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47945] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47945] st:6000 sz:1000
[28][1][47947]rx stdf piece [8 of 9] [0 to 47945] st:7000 sz:1000
[28][1][47947]rx stdf piece [9 of 9] [0 to 47945] st:8000 sz: 292
[28][1][47947]rx stdf piece [1 of 9] [0 to 47946] st:   0 sz:1000
[28][1][47947]rx stdf piece [2 of 9] [0 to 47946] st:1000 sz:1000
[28][1][47947]rx stdf piece [3 of 9] [0 to 47946] st:2000 sz:1000
[28][1][47947]rx stdf piece [4 of 9] [0 to 47946] st:3000 sz:1000
[28][1][47947]rx stdf piece [5 of 9] [0 to 47946] st:4000 sz:1000
[28][1][47947]rx stdf piece [6 of 9] [0 to 47946] st:5000 sz:1000
[28][1][47947]rx stdf piece [7 of 9] [0 to 47946] st:6000 sz:1000
[28][1][47948]rx stdf piece [8 of 9] [0 to 47946] st:7000 sz:1000
[37][1][47948]timer adjust dsync[-48.39] offset[-51.70] fps_chase[31.503]
[28][1][47948]rx stdf piece [9 of 9] [0 to 47946] st:8000 sz: 306
[28][1][47948]rx stdf piece [1 of 9] [0 to 47947] st:   0 sz:1000
[28][1][47948]rx stdf piece [2 of 9] [0 to 47947] st:1000 sz:1000
[28][1][47948]rx stdf piece [3 of 9] [0 to 47947] st:2000 sz:1000
[28][1][47948]rx stdf piece [4 of 9] [0 to 47947] st:3000 sz:1000
[28][1][47948]rx stdf piece [5 of 9] [0 to 47947] st:4000 sz:1000
[28][1][47948]rx stdf piece [6 of 9] [0 to 47947] st:5000 sz:1000
[28][1][47948]rx stdf piece [7 of 9] [0 to 47947] st:6000 sz:1000
[28][1][47948]rx stdf piece [8 of 9] [0 to 47947] st:7000 sz:1000
[28][1][47948]rx stdf piece [9 of 9] [0 to 47947] st:8000 sz: 290
[28][1][47949]rx stdf piece [1 of 9] [0 to 47948] st:   0 sz:1000
[37][1][47949]timer adjust dsync[-16.87] offset[-51.70] fps_chase[31.866]
[28][1][47949]rx stdf piece [2 of 9] [0 to 47948] st:1000 sz:1000
[28][1][47949]rx stdf piece [3 of 9] [0 to 47948] st:2000 sz:1000
[28][1][47949]rx stdf piece [4 of 9] [0 to 47948] st:3000 sz:1000
[28][1][47949]rx stdf piece [5 of 9] [0 to 47948] st:4000 sz:1000
[28][1][47949]rx stdf piece [6 of 9] [0 to 47948] st:5000 sz:1000
[28][1][47949]rx stdf piece [7 of 9] [0 to 47948] st:6000 sz:1000
[28][1][47949]rx stdf piece [8 of 9] [0 to 47948] st:7000 sz:1000
[28][1][47949]rx stdf piece [9 of 9] [0 to 47948] st:8000 sz: 295
[28][1][47950]rx stdf piece [1 of 9] [0 to 47949] st:   0 sz:1000
[37][1][47950]timer adjust dsync[-9.54] offset[-51.70] fps_chase[32.297]
[28][1][47950]rx stdf piece [2 of 9] [0 to 47949] st:1000 sz:1000
[28][1][47950]rx stdf piece [3 of 9] [0 to 47949] st:2000 sz:1000
[28][1][47950]rx stdf piece [4 of 9] [0 to 47949] st:3000 sz:1000
[28][1][47950]rx stdf piece [5 of 9] [0 to 47949] st:4000 sz:1000
[28][1][47950]rx stdf piece [6 of 9] [0 to 47949] st:5000 sz:1000
[28][1][47950]rx stdf piece [7 of 9] [0 to 47949] st:6000 sz:1000
[28][1][47950]rx stdf piece [8 of 9] [0 to 47949] st:7000 sz:1000
[28][1][47950]rx stdf piece [9 of 9] [0 to 47949] st:8000 sz: 305
[28][1][47950]rx stdf piece [1 of 9] [0 to 47950] st:   0 sz:1000
[28][1][47950]rx stdf piece [2 of 9] [0 to 47950] st:1000 sz:1000
[28][1][47950]rx stdf piece [3 of 9] [0 to 47950] st:2000 sz:1000
[28][1][47950]rx stdf piece [4 of 9] [0 to 47950] st:3000 sz:1000
[28][1][47950]rx stdf piece [5 of 9] [0 to 47950] st:4000 sz:1000
[28][1][47950]rx stdf piece [6 of 9] [0 to 47950] st:5000 sz:1000
[28][1][47950]rx stdf piece [7 of 9] [0 to 47950] st:6000 sz:1000
[28][1][47950]rx stdf piece [8 of 9] [0 to 47950] st:7000 sz:1000
[28][1][47950]rx stdf piece [9 of 9] [0 to 47950] st:8000 sz: 321
[28][1][47951]rx stdf piece [1 of 1] [47947 to 47951] st:   0 sz: 881
[37][1][47951]timer adjust dsync[1.61] offset[-53.12] fps_chase[32.982]
[28][1][47952]rx stdf piece [1 of 1] [47948 to 47952] st:   0 sz: 886
[37][1][47952]timer adjust dsync[22.51] offset[-53.12] fps_chase[33.743]
[28][1][47953]rx stdf piece [1 of 1] [47951 to 47953] st:   0 sz: 859
[37][1][47953]timer adjust dsync[24.26] offset[-53.12] fps_chase[39.380]
[28][1][47953]rx stdf piece [1 of 1] [47951 to 47954] st:   0 sz: 892
[28][1][47955]rx stdf piece [1 of 1] [47952 to 47955] st:   0 sz: 902
[37][1][47955]timer adjust dsync[26.58] offset[-53.12] fps_chase[43.524]
[28][1][47955]rx stdf piece [1 of 1] [47952 to 47956] st:   0 sz: 904
[28][1][47957]rx stdf piece [1 of 1] [47954 to 47957] st:   0 sz: 852
[37][1][47957]timer adjust dsync[23.39] offset[-53.12] fps_chase[44.486]
[28][1][47958]rx stdf piece [1 of 1] [47954 to 47958] st:   0 sz: 881
[37][1][47958]timer adjust dsync[19.36] offset[-53.12] fps_chase[45.163]
[28][1][47959]rx stdf piece [1 of 1] [47954 to 47959] st:   0 sz: 899
[37][1][47959]timer adjust dsync[17.45] offset[-53.12] fps_chase[45.506]
[28][1][47960]rx stdf piece [1 of 1] [47957 to 47960] st:   0 sz: 832
[37][1][47960]timer adjust dsync[15.31] offset[-53.12] fps_chase[45.755]
[28][1][47961]rx stdf piece [1 of 1] [47958 to 47961] st:   0 sz: 871
[37][1][47961]timer adjust dsync[6.87] offset[-53.12] fps_chase[45.807]
[28][1][47962]rx stdf piece [1 of 1] [47959 to 47962] st:   0 sz: 840
[37][1][47962]timer adjust dsync[8.93] offset[-53.12] fps_chase[45.671]


OK this still might be an issue but the dying still happens....why??


I think it is only a client thing, the server just keeps going


see if I can catch it in move or draw or program state...

now that I enabled move I see a huge square wave from -45 to -70 in the sync graph, but it did not die!!
ping is -30 to -35 approx

it died after move eshots
it died after move players

it has over 100% cpu when it dies

when move only is on I get spikes in dsync


I think the logging to console is causing weird timing shit....

but the crashing happens even with no logging....


This is so weird... when I stand by a bonus, without picking it up, it flickers back and forth, but only on client

what the hell??


maybe it is something on the server...


on the server:
tx stdf 1700 1702
rx stak 1701 1703

which is right?




real example:

server side:


350 rx stak 348 351
350 tx stdf 348 351

351 rx stak 350 352
351 tx stdf 350 352

352 rx stak 350 353
352 tx stdf 350 353

353 rx stak 351 354
353 tx stdf 351 354


why am I getting a reply before I send?

client side:

[30][1][354]--- Client Apply Dif [348 to 351] ---
[30][1][354]Found matching base in history
[30][1][351]dif [348 to 351] applied - rewound [3] frames

[30][1][355]--- Client Apply Dif [350 to 353] ---
[30][1][355]Found matching base in history
[30][1][353]dif [350 to 353] applied - rewound [2] frames

[30][1][356]--- Client Apply Dif [350 to 353] ---
[30][1][356]Found matching base in history
[30][1][353]dif [350 to 353] applied - rewound [3] frames

[30][1][357]--- Client Apply Dif [351 to 354] ---
[30][1][357]Found matching base in history
[30][1][354]dif [351 to 354] applied - rewound [3] frames




On the server, why do I get a reply stak, before I send the stdf...this makes no sense at all...

Other than that, the frame numbers seem to make sense..
server sends on frame 350, but the dif destination is one more 351 because it is the base for the next frame
server uses base 348...why?...because the last stak (also on frame 350) acknowledges 348

On the client:
On frame 354 the dif is applied
client had base 348 in history, applied dif get to frame 351, then ff 3 frames
then somehow it sent stak that arrived and was logged on server before sending initial stdf


I is rock solid on LAN with m36 as server

what if I tried TCP?
had 4230 take up 150% cpu
cant reproduce, maybe base resets?
cpu   TCP UDP
m36   16  14
e6430 11  11
4230  45 44

so all looks good on LAN even with TCP

I want to see if the server does the out of order stuff...

back to UDP also

[33][1][382]rx stak d[-20.1] c[40.0] a:382 c:383 ack state = state[p][0]
[27][0][382]tx stdf p:1 [src:382 dst:383] cmp:606 ratio:0.54 [1 packets needed]

[33][1][383]rx stak d[-20.2] c[40.0] a:383 c:384 ack state = state[p][0]
[27][0][383]tx stdf p:1 [src:383 dst:384] cmp:610 ratio:0.54 [1 packets needed]

[33][1][384]rx stak d[-20.2] c[40.0] a:384 c:385 ack state = state[p][0]
[27][0][384]tx stdf p:1 [src:384 dst:385] cmp:641 ratio:0.57 [1 packets needed]

I just realized I made a mistake and this is nothing!!  I think...

frame 382 stak 382
frame 382 stdf 382-383

frame 383 stak 383
frame 383 stdf 383-384


so back to why stuff is fucking up on WAN...

I don't know?  Is that an answer? Yes, but not very useful....

how about turn on lots of logging and try....it doesn't save when it crashes...damn...


ok look up your notes for running debugger...


on client the shuddering is probably due to corrupted states


so add some logging to figure that out...



where does it hook into history?


void mwNetgame::client_apply_dif(void)

      for (int i=0; i<NUM_HISTORY_STATES; i++) if (client_state_dif_src == mStateHistory[p].history_state_frame_num[i]) indx = i;
      if (indx > -1)
      {
         mLog.addf(LOG_NET_dif_applied, p, "Found matching base in history\n");
         memcpy(state[p][0], mStateHistory[p].history_state[indx], STATE_SIZE);
         state_frame_num[p][0] = client_state_dif_src;

   // save to history
   mStateHistory[p].add_state(mLoop.frame_num);



what can I do?



I think it is unnecasiraly complex to use state[p] for clients previous state...especially now that I have state history

lets see if I can do without it....

on client when I need that I will just query the class and it will tell me the most current base

how about a function that gets you the most recent base


void get_most_recent_base(char * base, int * frame_num)


actually I don't want most recent base...I just want a base that matches or zero

1 line....

   mStateHistory[p].get_base_state(base, base_frame_num, int frame_num);


that really simplified a lot of things on the client....

now how about I kill it all on the server also?...done



I have now freed up the 16 states I used to use...

//   // server's copies of client states
//   char state[8][2][STATE_SIZE];
//   int state_frame_num[8][2];


I still have 4 x 8 in history though...


It seem to work OK...why do I have constant base resets??

void mwStateHistory::get_most_recent_state(char* base, int& base_frame_num)

need to fill in this function...


now having problems with initial state...

it looks like I got muliple complete difs before apply is called...call it from decompress also..done


now I randomly have issues with player going active at join...


server lock works and sets the player active

but for some reason that does not make it back to the client


what if I skip the whole chase and lock thing...i don't use it at level done...


can I make a hotkey to force reset base?

am I adding properly on the client, not replacing existing, but oldest...

I am replacing frame num if it exists and I think that is correct...



My big concern right now is:

Why do I have differences between server and client states? player array....

am i not saving things properly?

do I have wrong bases on server or client?

that is why I want to force re base from zero


but how can I do that?

what if client sends stak with zero?

that should make server rebase from zero, but it probably doesn't


what if server sends with src zero....
that should make client load zero base, apply and save as a new state....

the good news is that initializing state history on the server for 1-7 fixed the weirdness

the bad news is that weirdness is happening....

20230910 10:37 PM

push....


next I want to figure out that weirdness
show what is happening with the history, how wide they are and where I get hits.
see if I can minimize the size of history
see if I can reduce copying of states
test all that is broken

20230911

Muliplayer looks great

I can't even detect any local corrections on clients, even over the internet..

Non local clients are still jumpy

When client is playing ahead it assumes that the other players controls are never active
I could try to predict that the controls will stay the same as they were when the state arrived....
but that would not be accurate....



class mwStateHistory

I want a variable that always has the highest frame number, the lowest frame number and indexes to both

I also want be be able to just get pointers to states instead of making copies


when is the only time that the contents of state history are changed?

initialize and add...

at that time update the variables

   newest_state_frame_num = -1;
   newest_state_frame_index = -1;
   newest_state_pointer = NULL;

   oldest_state_frame_num = -1;
   oldest_state_frame_index = -1;
   oldest_state_pointer = NULL;


here are the rules:

when initialized they have this state:

   newest_state_frame_num = -1;
   newest_state_frame_index = -1;
   newest_state_pointer = NULL;

   oldest_state_frame_num = -1;
   oldest_state_frame_index = -1;
   oldest_state_pointer = NULL;

as soon as one is added they both are set to that...

oldest will never be -1 unless there are no other valid states



I have patched it in for server rewind and it works...the old method made a copy...new method uses the char pointer


now I am looking at: server_send_dif(int frame_num)
if I use pointer here, I will not have the base anymore

I think I should leave this one??

for now


while I am at is I would like to have the class have a values for the last stak state from a client...
used only by server...

what do I use now?

I think I might have found the bug....

server uses most recent and assumes that is the last ack, but it may not be


added:

   int last_ack_state_frame_num;
   int last_ack_state_index;
   char * last_ack_state;

all this works...

now all of server should use the new stuff...


now how about client?

done...



I have now patched all this in and it looks much cleaner, and seems to work...

now test on internet...

client sync is way off like -200??

why?


look at logs...

the server is getting stak, but still sending from zero...

make some logging to see if it is missing the match...


server never adds anything to clients state history....

found the bug in add...

Test Game level 64 on server scat (internet)


now I am playing 8 player game over the internet with a reported ping of 35
7 clients all with fakekey
approx 300kB/s

server is scat and has approx 35% cpu
client m36 has approx 7% cpu
client e6430 has approx 20% cpu
client 4230 have 60-80% but 29(jj) has closer to 100

clients local maxcor is always 0 and is beautiful to play locally
clients non local maxcor can go up to 24 and is quite jumpy

clients crwd is 2-3
gmav 20-40

between 1-2 packets (mostly 1 but sometimes 2)

a few late cdats


e6430 tried manually setting offest to -10 (from -55 auto)
now on e6430 other clients have maxcor of 7 and local player has12 mostly
about the same maxcor on other clients


This is a huge milestone..stuff is working great and I looks simpler...

clean up code a bit and push

done


added good documentation to each function in mwHistory


test some next level stuff



I just played a game where it all got screwed up again


reset base all the time, client sync -200 -400




I can reproduce...

scat server, internet, 8 clients join, do one level done at least to level 64
all fake key, after 1 min:
constant base resets
sync -200 to -300
ping 300-400

resetting base to zero on client or server does not fix...

are base resets the cause or is bad sysnc the cause?



some more data...
when it happens, all clients have constant base resets and cdsy -250 to -270
could this mean is is something on the server, is all clients have the same issue??


one nice thing, since I implemented state history, clients almost always have zero local corrections
even if they rewind a lot, like 12 frames.
I think this is because the local moves always make it to the server and are validated.
But the other clients still have corrections that get a lot worse the more they need to rewind...

so, what could be wrong that is causing this?

turn on a lots of logging and look....


happened around 4:00

on client:

what the hell happened?

why did this dif get applied so many times?

[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames


and also why does everydif get applied more that once...

apply dif is called from stdf and also once everyframe

this is OK maybe, is it needed to be called from stdf, I thought that was needed for join
see if I can remove that one....I did and still seems to join fine



also make it so that apply_dif does not try to do the same dest more than once??

can I do that? yes, i think so, server will never send a dif then send an older one
client should never apply a dif with a dest older than one it has already applied....

but also, why does having it applied again and again cause bigger rewinds?


[30][1][9506]--- Client Apply Dif [9499 to 9503]dif [9499 to 9503] applied - rewound [3] frames
[30][1][9506]--- Client Apply Dif [9499 to 9503]dif [9499 to 9503] applied - rewound [3] frames
[27][1][9507]rx dif complete [9501 to 9504] dsync[-57.4ms] - uncompressed
[30][1][9507]--- Client Apply Dif [9501 to 9504]dif [9501 to 9504] applied - rewound [3] frames
[30][1][9507]--- Client Apply Dif [9501 to 9504]dif [9501 to 9504] applied - rewound [3] frames
[27][1][9508]rx dif complete [9503 to 9505] dsync[-57.4ms] - uncompressed
[30][1][9508]--- Client Apply Dif [9503 to 9505]dif [9503 to 9505] applied - rewound [3] frames
[30][1][9508]--- Client Apply Dif [9503 to 9505]dif [9503 to 9505] applied - rewound [3] frames
[27][1][9509]rx dif complete [9503 to 9506] dsync[-57.9ms] - uncompressed
[30][1][9509]--- Client Apply Dif [9503 to 9506]dif [9503 to 9506] applied - rewound [3] frames
[30][1][9509]--- Client Apply Dif [9503 to 9506]dif [9503 to 9506] applied - rewound [3] frames
[27][1][9510]rx dif complete [9505 to 9507] dsync[-57.7ms] - uncompressed
[30][1][9510]--- Client Apply Dif [9505 to 9507]dif [9505 to 9507] applied - rewound [3] frames
[30][1][9510]--- Client Apply Dif [9505 to 9507]dif [9505 to 9507] applied - rewound [3] frames
[27][1][9511]rx dif complete [9505 to 9508] dsync[-59.5ms] - uncompressed
[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames
[30][1][9511]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [3] frames
[30][1][9512]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [4] frames
[30][1][9513]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [5] frames
[30][1][9514]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [6] frames
[30][1][9515]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [7] frames
[30][1][9516]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [8] frames
[30][1][9517]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [9] frames
[30][1][9518]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [10] frames
[30][1][9519]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [11] frames
[30][1][9520]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [12] frames
[30][1][9521]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [13] frames
[30][1][9522]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [14] frames
[30][1][9523]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [15] frames
[30][1][9524]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [16] frames
[30][1][9525]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [17] frames
[30][1][9526]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [18] frames
[30][1][9527]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [19] frames
[30][1][9528]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [20] frames
[30][1][9529]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [21] frames
[30][1][9530]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [22] frames
[30][1][9531]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [23] frames
[30][1][9532]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [24] frames
[30][1][9533]--- Client Apply Dif [9505 to 9508]dif [9505 to 9508] applied - rewound [25] frames
[27][1][9534]rx dif complete [9507 to 9509] dsync[-623.2ms] - uncompressed
[30][1][9534]--- Client Apply Dif [9507 to 9509]dif [9507 to 9509] applied - rewound [25] frames
[27][1][9534]rx dif complete [9508 to 9510] dsync[-623.2ms] - uncompressed
[30][1][9534]--- Client Apply Dif [9508 to 9510]dif [9508 to 9510] applied - rewound [24] frames
[30][1][9534]--- Client Apply Dif [9508 to 9510]dif [9508 to 9510] applied - rewound [24] frames
[27][1][9535]rx dif complete [9508 to 9511] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9511]dif [9508 to 9511] applied - rewound [24] frames
[27][1][9535]rx dif complete [9508 to 9512] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9512]dif [9508 to 9512] applied - rewound [23] frames
[27][1][9535]rx dif complete [9508 to 9513] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9513]dif [9508 to 9513] applied - rewound [22] frames
[27][1][9535]rx dif complete [9508 to 9514] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9514]dif [9508 to 9514] applied - rewound [21] frames
[27][1][9535]rx dif complete [9508 to 9515] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [9508 to 9515]dif [9508 to 9515] applied - rewound [20] frames
[27][1][9535]rx dif complete [0 to 9527] dsync[-581.0ms] - uncompressed
[30][1][9535]--- Client Apply Dif [0 to 9527]dif [0 to 9527] applied - rewound [8] frames
[30][1][9535]--- Client Apply Dif [0 to 9527]dif [0 to 9527] applied - rewound [8] frames
[27][1][9536]rx dif complete [0 to 9528] dsync[-182.3ms] - uncompressed
[30][1][9536]--- Client Apply Dif [0 to 9528]dif [0 to 9528] applied - rewound [8] frames
[30][1][9536]--- Client Apply Dif [0 to 9528]dif [0 to 9528] applied - rewound [8] frames
[27][1][9537]rx dif complete [0 to 9529] dsync[-167.8ms] - uncompressed
[30][1][9537]--- Client Apply Dif [0 to 9529]dif [0 to 9529] applied - rewound [8] frames
[30][1][9537]--- Client Apply Dif [0 to 9529]dif [0 to 9529] applied - rewound [8] frames
[27][1][9538]rx dif complete [0 to 9530] dsync[-166.6ms] - uncompressed


make sure all clients do things the same
now they do not have any repeats



7:20 = 7 * 60 + 20 = 440 * 40 = 17600

[27][1][17640]rx dif complete [17634 to 17637] dsync[-60.1ms] - uncompressed
[30][1][17640]--- Client Apply Dif [17634 to 17637]dif applied - rewound [3] frames
[27][1][17641]rx dif complete [17635 to 17638] dsync[-60.1ms] - uncompressed
[30][1][17641]--- Client Apply Dif [17635 to 17638]dif applied - rewound [3] frames
[30][1][17642]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17643]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17644]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17645]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17646]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17647]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17648]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17649]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17650]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17651]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17652]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17653]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17654]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17655]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17656]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17657]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17658]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17659]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17660]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17661]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17662]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[30][1][17663]--- Client Apply Dif [17635 to 17638] not newer than last dif applied
[27][1][17664]rx dif complete [17636 to 17639] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17640] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17641] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17642] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17643] dsync[-606.8ms] - uncompressed
[27][1][17664]rx dif complete [17637 to 17644] dsync[-606.8ms] - uncompressed
[30][1][17664]--- Client Apply Dif [17637 to 17644]dif applied - rewound [20] frames
[27][1][17665]rx dif complete [0 to 17660] dsync[-101.4ms] - uncompressed
[30][1][17665]--- Client Apply Dif [0 to 17660]dif applied - rewound [5] frames
[27][1][17666]rx dif complete [0 to 17661] dsync[-97.5ms] - uncompressed
[27][1][17666]rx dif complete [0 to 17662] dsync[-97.5ms] - uncompressed
[30][1][17666]--- Client Apply Dif [0 to 17662]dif applied - rewound [4] frames
[30][1][17667]--- Client Apply Dif [0 to 17662] not newer than last dif applied
[27][1][17668]rx dif complete [0 to 17663] dsync[-96.5ms] - uncompressed
[27][1][17668]rx dif complete [0 to 17664] dsync[-96.5ms] - uncompressed
[30][1][17668]--- Client Apply Dif [0 to 17664]dif applied - rewound [4] frames
[27][1][17669]rx dif complete [17660 to 17665] dsync[-83.3ms] - uncompressed
[27][1][17669]rx dif complete [17662 to 17666] dsync[-83.3ms] - uncompressed
[27][1][17669]rx dif complete [17662 to 17667] dsync[-83.3ms] - uncompressed
[30][1][17669]--- Client Apply Dif [17662 to 17667]dif applied - rewound [2] frames
[27][1][17670]rx dif complete [17662 to 17668] dsync[-24.9ms] - uncompressed
[27][1][17670]rx dif complete [17667 to 17669] dsync[-24.9ms] - uncompressed
[30][1][17670]--- Client Apply Dif [17667 to 17669]dif applied - rewound [1] frames
[27][1][17671]rx dif complete [17667 to 17670] dsync[-24.7ms] - uncompressed
[30][1][17671]--- Client Apply Dif [17667 to 17670]dif applied - rewound [1] frames
[27][1][17672]rx dif complete [17667 to 17671] dsync[-14.6ms] - uncompressed
[30][1][17672]--- Client Apply Dif [17667 to 17671]dif applied - rewound [1] frames

what the hell does this look like on the server?


looks like the stdf's were sent on the proper frames....

for some reason they did not arrive for 64-41 - 23 frames * 25ms = 575ms


this could be just a network hiccup...now netgame looks like it will survive it....

I have also reduced a lot of extra apply dif on clients


bump version and push
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































make the cannon facing direction optional

make the shortcut keys in the menu optional
also shortcut key in vls

make functionality to save level if if beats the best time with purple coins
that means I will need to track that also...

make it so that demo current level on overworld does something besides open file select
maybe that is not so bad...






--------------------------------------------------------
--  Things that need to be finished before a release  --
--------------------------------------------------------


--------------------------------------------------------
-- The best things about the game to show off --
--------------------------------------------------------
- netgame
- dynamic resizing
- logging, graphing, profiling



--------------------------------------------------------
--  Help Screens To Do  --
--------------------------------------------------------


make much simpler history page for help screens

add to history

also fix history on index.html page

maybe have a nice short history and then an in depth one


remove log file viewer and graphs from help screens?? why?

somehow describe snap...

hiders

npc








redoing docs one page at a time, since globals and fixed are removed


level array goes into a lot of the drawing sequence, that I don't think it should
should put that in its own file

there is some major rewriting needed for events and inputs


to do:


done:
logo
shots
sound
block flags
tile
display
game moves array
level array
level done
timers
input
events
project org


netgame main
netgame state and dif
netgame server state
netgame client state
netgame client control change
netgame client timing sync
netgame fast packet loop
netgame ping
netgame packets
netgame config
netgame join
netgame server setup
netgame control and monitoring



























---------------------------------------------------------
------------------------ Tests --------------------------
---------------------------------------------------------


test all multiplayer bmsg's
some messages show up twice
it is because of rewind
how am I going to fix it?
set a global flag when rewinding....
don't send game events when flag set...
done...

player join
player shot player is reversed
switched 3 calls to event 40 player hurt player
..fixed



test all enemies collision with player..good
ArchWagon-
Bouncer-
JumpWorm-
Cannon-
PodZilla-
TrakBot-
Cloner-
Block Walker-
Flapper-
VinePod-
always same shape for bouncer

player shot enemy
ArchWagon-
Bouncer-
JumpWorm-
Cannon-
PodZilla-
TrakBot-
Cloner-
Block Walker-
Flapper-
VinePod-
cannon with muliple shots, does not show unless killed

player exploded enemy
ArchWagon
Bouncer
JumpWorm
Cannon
PodZilla
TrakBot
Cloner
Block Walker
Flapper
VinePod
all good

player got shot by:
ArchWagon-
Bouncer-
Cannon-
PodZilla-
TrakBot-
Flapper-
VinePod - says podzilla



ArchWagon
Bouncer
JumpWorm
Cannon
PodZilla
TrakBot
Cloner
Block Walker
Flapper
VinePod



-------------------------------
-- Random thoughts and ideas --
-------------------------------


look at making screen double do values other than integers like 1.5

make "Rollin" play over final cutscene
time:93s

how long for all children to get in rocket?
30s
how long for rocket to fly





should I redo my commandline stuff to have an arbitrary number of options in any order
spec out exactly what you want.
each chuck should contain no whitespace, use that as a delimiter

-e
-e:<int>

-p
-p:<int>

-s
-sh

-c
-c<host>





Make some examples of vinepods to show off in levels
vinepod triggering another vinepod in a chain
vinepod triggering a group of vinepods in a star
vinepod getting out of the way of a shot aimed at it

vinepod flower on good and evil?
also on incinerator??


I could also do an eco draw for vinepods....



when a level is completed and sets a new time record < par and all purple coins collected
auto save that level in a special folder

here are the rules:
- level completed
- all coins
- time less than max so far

this makes me think I might need 2 speed records
one for all coins and one for not..
maybe I could just not count a speed record if all coins are not collected
too much work, just leave it...



what about messages and in level stats only show on local screen?
unless they are the show always type...
level_stats is a message also...
there is no mechanism in message to determine which player to show it for..
it would take a lot to add functionality to display different for each player
skip this




can I add level name to the filename
How would that look?

level002.pml

level002_Switch_Nest.pml






I am thinking of having some more buttons on the top of the edit menu

be able to toggle scroll at screen edge on/off
lock screen pos
scroll level by click and drag
zoom level with mouse wheel





working on making the ft_sel look better
all the info I need is in the ft_
the secondaries already have the right offset but the drawing routine can only get it from the real item data structs
I hate re invent or duplicate the drawing routines, can I just extend the exiting ones to pass explicit secondary, like I pass explicit x and y for cutom drawing?


why did I remove skip frame draw?
because 99% of the time, the thing was taking too much time was draw frame itself
netgame expects that the move frames happen exactly when they are supposed to
if I draw then I will screw up the timimg of netgame
I tried a staggered draw but the flashing was too much...
what I did not try was:
frame 1 get new back ground and draw


wait a tick here!
I have discovered that drawing from bitmap to bitmap does not scale well.
but drawing from bitmap to screen does...
I was thinking of drawing as much as I can directly to the screen
right now I draw at full scale from tiles to level_background and level_buffer
then only scale those when drawing to the screen.
so that would not affect the quality there, but maybe the rotation
also maybe the speed



enemies that still use trigger box, pod, vine
could I make them also optionally use trigger inputs
then they could move out of the way of bullets!

what would it take to extend lifts to use splines?

I would also like to make splines have more control points, maybe I'll have to make my own..


here is a huge one:
can level editor be brought under the program state umbrella?
I sort of duplicate level editor modes with program states



I want to see if I can make the player motion more smooth..
especially when riding lifts
but also when the background is scrolling

the player and the rocket might benefit from drawing directly on the screen instead of the screen buffer
it worked for bottom messages, the scaling looks ways better..

I would be nice be be able to do tc and netem things from within my program..
but I would need to figure out how to do that as non-root

If I did I could even do cool things like run training sessions with different network settings...



make a way to force x axis to show either frames or sec..
make a way to measure on graph
like CTRL SHIFT DRAG will display info about box size

make log in settings better:
- make a way to load most recent ping graph with one click
log like cpu, but with a multicolored bar...move, draw, other, all added up
...more



Things to add to settings:

optional resolution in window title
- I can already show it with debug overlay

optional text in bottom frame

main menu level editor shortcut key

level editor ov lock key

options to do the send stuff to clients? including which clients to send to, and text entry to add new ones????
then maybe I could retrieve log from client after netgame???...whoa...that's just crazy

what are the next things I can profile?
how long does it take client to decompress, run a dif, rewind?
how long does a bomb explosion take?
low long does it take to switch blocks?
how long does it take to draw all the blocks?
how long does it take to draw all messages?


what about the other timing thing I was going to do?
start of frame, and where everything else happened....not sure how useful that will be....

I wanted to experiment with differnt s1 and s2 values, but I wanted to be able to actually measure some effect it has.
that was the big push behind the program state thing, then the graph thing, then the settings menu because I want to be able
to measure stuff...



--------------------------------------------------------------------------------------------
I would like to make a mode where the server can run without a local player
I would like to be able to start it from the command line via ssh and control it like that too..
This would kind of suggest that I be able to pause the server...

Fundamentally this will require deep changes.
Right now the sync loop is dependant on the frame_num incrementing, like when the game is running.

This is not a deal breaker, the game loop can still run, just the local server player will not be participating..
There would be no menu stuff possible on the server though. I would need a different way to control it.
--------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------
when client starts,
don't show anything about level until initial state is received and client player's view is at the start
--------------------------------------------------------------------------------------------

add 8 char name
it will be saved in config file
it will be the name used for player[0]
where ever I print Player:x, i will now print 'name'





--------------------------------------------------------------------------------------------
as a pre cursor to layered recording
make a demo player on steroids
slider for speed
slider for location
pause, play.
--------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------
Layered multiplayer recording
------------------------------------------------------------------------------------------
How can I do a layered multiplayer recording, where a new player can record while paying back all the old ones?

single player local mode only

play and record mode..

for example:

play file:....
at a specific time start record one player...


I would need a new type of game...

like rungame_record


how does active local player work in rungame mode...


I might need a second game_move_array for this

while recording, copy from original and add from new playing...


how much space is used already by gma?

a drop in the bucket compared to everything else:
16M out of 1300M

so, make a second array

gma2


in rungame all active players have control method 1

make a new control method...like 6 for record rungame


Control panel

file loaded:
timeline with all 8 possible players and a line shown where there is data for each player
current position in savegame

able to seek to any pos
play and pause

set position and record for one player


--------------------------------------------------------------------------------------------
to something more graceful if the next level is not found..
--------------------------------------------------------------------------------------------

option 1: search for next level
option 2: if load fails go back to current level

whatever you do, do not just fail and leave a failed level loaded with menu...
I have changed it to print error to console and merr message on failure
------------------------------------------------------------------


------------------------------------------------------------------
8 character name for player...
------------------------------------------------------------------
I use 8 char for 'player x' already so the text should fit



--------------------------------------------------------------------------------------------
display window hystersis adjust
--------------------------------------------------------------------------------------------
the display window hystersis window thing shoould slowly drift in the direction the player is looking, so they can see further thay way..this is genius and should have been done a long time ago

it works but still needs some bugs worked out

take the players motion into account
if jumping then scroll to see more up
if falling then scroll to see more down

if riding rocket then do the same....

can I just use pxinc and pyinc??
what I am doing is moving the camera...

in hyst gradual:
if you are running in one direction, you will be pushed up against the hyst for that direction
I want it be be ahead of you so you can see where you are going
same with jumping and falling and rockets
some way of using players speed....

---------------------------------


-------------------------------------------------
in log file viewer, make a second array with only the lines that we are showing
this will make the scrolling up and down make much more sense
can do page up and page down intelligently
moving up and down by one line (or 10 or 100) will actually do what we expect
-------------------------------------------------



code stat to do optional alphabetical sort also optional skip header files


make level editor save the window position
make a way to click and drag to move le window
make a button to have le window show current item in center


add a bunch of settings for bottom message:
how many lines: 8 (max 20)
float io = 1.0; // initial opacity
float fo = 0.1; // final opacity
float ivs = 0.5; // initial v size
float fvs = 0.1; // final v size
float ihs = 0.5; // initial h size
float fhs = 0.1; // final h size

which game events cause messages

player tile, text or both
enemy  tile, text or both
item   tile, text or both

how close the player has to be to reduce messages





















-------------------------------------------------
Make an 'about' just like 'help'
-------------------------------------------------

--------------------------------------------------------------------------------------------
Make it so that a client does not have to have the level a server is serving.
--------------------------------------------------------------------------------------------
I am so close anyway.
All that needs to be done is also sync the lift steps...
and the pmgstext

Then every part of the necessary game state is sent.

This way a server can edit a level and clients can play it without needing a copy....

Variables used to save levels in pml format

level_header:    80
l           : 40000
item        : 32000
Efi         :  6400
Ei          : 12800
lifts       :  5280
lift_steps  : 38400
pmsgtext    :250000
------------:------
total       :384960

Variables used for netgame state exchange

players  :  1664
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
---------:------
total    :106144


this will add
lift_steps  : 38400
wait...I also need pmsgtext, and that is not trivial
maybe during join I can compress and send these static things once...
maybe I could send the level file, it is already compressed...

the biggest levels are only 8K
I can already send the state broken up into packets, why not the level??




-------------------------------------------------
Implement a system of data about levels played and results
-------------------------------------------------
keep a text file when ever a level is completed (or abandonded)

abandoned? whenever going to menu and resume allowed?
this part is not essential, only wanted to see how many times started and not finished

level_num
date and time stamp (completed or started)
time to complete
number of players
shots fired
enemies killed
purple coins
enemies left alive at the end
number of deaths

one line per level started?
when complete edit the line

what is the end result?

list of levels with number of times started, completed, abandoned
max time, min time, avg time, total time
enemies left max, min avg
purple coins, max, min avg



-------------------------------------------------
make end pieces for chains and maybe vines and ladders and ropes
-------------------------------------------------
What if I gave my levels names?
That way if they are re-arranged it wont matter
-------------------------------------------------
What if I had an overlay screen for levels
This all sounds very complex...
-------------------------------------------------


------------------------------------------------------
------------------------ Level ideas -----------------
------------------------------------------------------

make a level with block 0 and 1 that look the same but set block manip to change block 1...

make a level that requires traveling on a lift while jumping on and off of switches

level where you have to throw mines at the other player..

How about a level where you have to clone switches??

how about a level where you need to send rocket up through a minefield
or arrow field that player would die in....

level with 100 random flapper...vertical jumping section in middle...332

how about a level where you have a cannon following you through a constricting one way
maze, probably up past semi solid and then kill it with a bomb

make a level that relies on being able to carry a door through a door

------------------------------------------------------
------------------------ ememy ideas -----------------
------------------------------------------------------

how about an enemy that jumps over the player and fires down when directly over
invincible to sideways player shots

What if I made a cloner that could detect when what it created was destroyed and make a new ones?

what if I made on option for cloner to destroy all that it had created when trigger to create more...
that could be useful for timed things and other stuff

what if when a player is in a cloner src that fires, a free man is created?


------------------------------------------------------
------------------------ item ideas ------------------
------------------------------------------------------

make a green ball that you need to carry to its corresponding base to emit a trigger event


make the type of key you need to take to a matching lock
when you touch the lock it will show the blocks that get removed

something you jump on just like a switch
only emits toggle on and toggle off depending on shape...

something you shoot and it emits a trigger
make an obvious item that reacts when getting shot... toggle on and off..


matching set of items that need to be brought together
you can carry these around just like items...

what if you could carry around normal triggers and the field would follow?


trigger field that has a count of enemies or items or players

how about making health bonus only take the amount of health needed to get to 100
if any is left, just subtract and don't erase the item

what if you had to press FIRE to grab a rocket, but then after that you did not need to hold FIRE?
you could dismount with JUMP? ... that sounds cool

does remote trigger have a delay before the explosion?
I want it immediate to help the player time exploding moving things

make a field that manipulates the players controls, like gravity, etc...


---------------------------------------------------------
------------------ web docs -----------------------------
---------------------------------------------------------

2023

done:
netgame_client_state
netgame_client_control_change
netgame_state_and_dif
netgame_ping
netgame_client_timing_sync
netgame_packets
netgame_fast_packet_loop
netgame_config
netgame_join
netgame_server_state


to do:
netgame_main (or overview) the main landing page that gives the highest level description and links to all the other pages
netgame_status..started



netgame_server_setup
like join, but from the client's side....

maybe join should be more like client_join...











links:
fpl
client to dsync..done
server read buffer timetamp to not done in server_proc_cdat_packet....
ping, pong, pang,...done

cts
client rx stdf link to fpl...done





















--------------------------------------------------------
------------------- reduce globals ----------------------
---------------------------------------------------------

---------------------------------------------------------
------------------------ linux --------------------------
---------------------------------------------------------

---------------------------------------------------------
------------------------ Help file ------------
---------------------------------------------------------

The level editor has four major modes:

1 - Main editor
- most common way to draw blocks and add objects from selection window
- also can set draw item with mouse b2 and put draw item with mouse b1
- the only mode that has the pop-up menu

2 - Zoom Full Screen
- mostly used for manipulating rectagular selections of the level
- clear, copy, paste, move, save and load selection to disk...
- block fill, block frame, block floodfill

3 - Object Viewer
- used for manipulating properties of indiviudual objects, (items, enemies, lifts)
- can move and edit object properties with buttons and sliders
- can move and edit object properties with map

4 - Group Edit
- used for maninulating groups of objects (items and enemies)
- can set or randomize locations, variables, etc


All modes have a scalable level in the background.
It can be adjusted just like when the game is running
- scale can be adjusted with F5/F6
- fullscreen can be toggled with F12
- CTRL SHIFT F12 cycles the ortho double




---------------------------------------------------------
---------------------- Wish List ------------------------
---------------------------------------------------------


end of level stats:

number of:

enemies left
enemies killed
shots fired

per player:
enemies killed
shots fired
damage taken
health picked up


make more items that help the puzzle aspect.
like??

a key and lock type thing where you need to bring the key to the lock

companion cubes you can carry around
to jump off or weigh down switches

blocks that take more that one hit to clear

helpless victims that you need to rescue by bringing them to a safe spot

enemy that freezes when you look at it

make more shapes for player, I don't like static shape when jumping or falling

better profiling to find bottleneck

add a more things to customize:
like:

hystersis window
screen messages
bottom messages

make the main game loop called from the event loop
instead of calling the event loop from game loop
see if this improves performance

fix hysteresis window move when zooming

make other kind of mines, like spikes, lava, flames...etc

make player wall collisions pixel perfect like when on ladder???
make single block navigation like ladder move...
this will make jumping up into single block opening very hard...
this sound like a major re-write..

