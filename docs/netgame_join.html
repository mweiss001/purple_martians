<!doctype html>
<title>Netgame - Join</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="history.html" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="shots.html" target="_top">Shots</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    

<div style="text-align: center;"><a href="netgame_main.html"                     target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state_and_dif.html"            target="_top">Netgame - State and Dif</a></div>    
<div style="text-align: center;"><a href="netgame_server_state.html"             target="_top">Netgame - Server State</a></div>    
<div style="text-align: center;"><a href="netgame_client_state.html"             target="_top">Netgame - Client State</a></div>    
<div style="text-align: center;"><a href="netgame_client_control_change.html"    target="_top">Netgame - Client Control Change</a></div>    
<div style="text-align: center;"><a href="netgame_client_timing_sync.html"       target="_top">Netgame - Client Timing Sync</a></div>    
<div style="text-align: center;"><a href="netgame_fast_packet_loop.html"         target="_top">Netgame - Fast Packet Loop</a></div>    
<div style="text-align: center;"><a href="netgame_ping.html"                     target="_top">Netgame - Ping</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html"                  target="_top">Netgame - Packets</a></div>    
<div style="text-align: center;"><a href="netgame_config.html"                   target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_server_setup.html"             target="_top">Netgame - Server Setup</a></div>    
<div style="text-align: center;"><a href="netgame_join.html"                     target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_control_and_monitoring.html"   target="_top">Netgame - Control and Monitoring</a></div>    

</mdw_lhs_nav>
            
        </nav>
      
        <div class="col-2">
            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>

<mh3><hr></mh3>
<mh8>Netgame - Join</mh8>
<mh3><hr><mdw_file_toc> <a href="netgame_join.html#Overview" target="_top">Overview</a>
 <a href="netgame_join.html#Program states for client join" target="_top">Program states for client join</a>
 <a href="netgame_join.html#Client initializes network" target="_top">Client initializes network</a>
 <a href="netgame_join.html#Client sends 'cjon' packet" target="_top">Client sends 'cjon' packet</a>
 <a href="netgame_join.html#Server receives 'cjon' packet and replies with 'sjon' packet" target="_top">Server receives 'cjon' packet and replies with 'sjon' packet</a>
 <a href="netgame_join.html#Client receives 'sjon' packet" target="_top">Client receives 'sjon' packet</a>
 <a href="netgame_join.html#Client setup" target="_top">Client setup</a>
 <a href="netgame_join.html#Client waits for initial state from server" target="_top">Client waits for initial state from server</a>
 <a href="netgame_join.html#Client chase and lock" target="_top">Client chase and lock</a>
 <a href="netgame_join.html#Ending a client netgame" target="_top">Ending a client netgame</a>
 <a href="netgame_join.html#Setting up netgame" target="_top">Setting up netgame</a>
 <a href="netgame_join.html#Netgame over the Internet" target="_top">Netgame over the Internet</a>
</mdw_file_toc><hr></mh3>

<a name="Overview"></a>
<mh7>Overview</mh7>
<mh3>
The client initializes the network and requests to join.
The server sends a join invitation with all the game details.
The client waits for initial state from the server.
The client chases until it locks and the server sets it active.

</mh3>



<a name="Program states for client join"></a>
<mh7>Program states for client join</mh7>

<mh3>
The program states used by a joining client are:

24 - client start new game
23 - client wait for join invitation
22 - client level setup
21 - client wait for initial state
11 - main game loop

if at any point in this process an error occurs or the game ends, it goes to:

25 - client exit

</mh3>


<a name="Client initializes network"></a>
<mh7>Client initializes network</mh7>


<mh3>
When a client game is started, the first thing that happens is the network initialization.

This requires the server IP or hostname.

If the connection is successfully setup and a response is received from the server, we proceed to the next step.
</mh3>
<pre><code class="language-cpp">   //---------------------------------------
   // 24 - client new game
   //---------------------------------------
   if (state[1] == 24)
   {
      if (!mNetgame.client_init())
      {
         state[0] = 25;
         return;
      }
      for (int p=0; p < NUM_PLAYERS; p++) mPlayer.init_player(p, 1); // full reset
      mPlayer.syn[0].active = 1;
      state[0] = 23;
   }

int mwNetgame::client_init(void)
{
   if (!ClientInitNetwork(m_serveraddress)) return 0;  // initialize driver with server address
   Packet("cjon");
   PacketPut1ByteInt(mPlayer.syn[0].color); // requested color
   PacketAddString(mLoop.local_hostname);
   ClientSend(packetbuffer, packetsize);
   return 1;
}

int mwNetgame::ClientInitNetwork(const char *serveraddress)
{
   char msg[1024];
	if(NetworkInit())
   {
      sprintf(msg, "Error: failed to initialize network");
      mInput.m_err(msg);
      if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
      return 0;
   }
   if (TCP)
   {
      ServerConn = net_openconn(NetworkDriver, NULL);
      if(!ServerConn)
      {
         sprintf(msg, "Error: Client failed to create netconnection (TCP)");
         mInput.m_err(msg);
         if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
         return 0;
      }
      if(net_connect(ServerConn, serveraddress))
      {
         sprintf(msg, "Error: Client failed to set netconnection target: server[%s] (TCP)", serveraddress);
         mInput.m_err(msg);
         if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
         net_closeconn(ServerConn);
   		return 0;
   	}
      sprintf(msg, "Client network initialized: server[%s] (TCP)", serveraddress);
   }
   else // UDP
   {
      ServerChannel = net_openchannel(NetworkDriver, "");
      if (ServerChannel == NULL)
      {
         sprintf(msg, "Error: Client failed to create netchannel (UDP)");
         printf("%s\n", msg);
         mInput.m_err(msg);
         if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
         return 0;
      }
      if (net_assigntarget(ServerChannel, serveraddress))
      {
         sprintf(msg, "Error: Client failed to set netchannel target: server[%s] (UDP)", serveraddress);
         printf("%s\n", msg);
         mInput.m_err(msg);
         if (mLog.LOG_NET) mLog.add_log_entry_position_text(11, 0, 76, 10, msg, "|", " ");
         return 0;
      }
      sprintf(msg, "Client network (UDP) initialized: server:%s local address%s", serveraddress, net_getlocaladdress(ServerChannel));
      printf("%s\n", msg);
      if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
   }



   // Check for reply from server
   int tries = 1;        // number of times to try
   float try_delay = 1;  // delay between tries
   int got_reply = 0;

   while (!got_reply)
   {
      printf("ClientCheckResponse %d\n", tries);
      int ccr = ClientCheckResponse();
      if (ccr == 1)
      {
         got_reply = 1;
         sprintf(msg,"Got reply from server");
         printf("%s\n", msg);
         if (mLog.LOG_NET) mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
      }
      if (ccr == 0)
      {
         al_rest(try_delay);
         if (++tries > 2)
         {
            sprintf(msg,"Did not get reply from server");
            mInput.m_err(msg);
            printf("%s\n", msg);
            if (mLog.LOG_NET)
            {
                mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
                mLog.add_log_entry_centered_text(10, 0, 76, "", "+", "-");
            }
            return 0;
         }
      }
      if (ccr == -1)
      {
         sprintf(msg,"TCP response Error!");
         mInput.m_err(msg);
         printf("%s\n", msg);
         if (mLog.LOG_NET)
         {
             mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
             mLog.add_log_entry_centered_text(10, 0, 76, "", "+", "-");
         }
         return 0;
      }
      if (ccr == -2)
      {
         sprintf(msg,"Cancelled");
         //mInput.m_err(msg);
         printf("%s\n", msg);
         if (mLog.LOG_NET)
         {
             mLog.add_log_entry_position_text(10, 0, 76, 10, msg, "|", " ");
             mLog.add_log_entry_centered_text(10, 0, 76, "", "+", "-");
         }
         return 0;
      }
   }
   return 1;
}

int mwNetgame::ClientCheckResponse(void) // check for a repsonse from the server
{
   if (TCP)
   {
   	int x = net_poll_connect(ServerConn);
      if (x == 0) return 0; // no response yet
   	if (x >  0) return 1; // good response
   	if (x <  0) // error
      {
   		net_closeconn(ServerConn);
   		return -1;
   	}
   }
   else // UDP
   {
      char address[32];
      Packet("1234");
      ClientSend(packetbuffer, packetsize);
      printf("Sent initial packet 1234 to server\nWaiting for reply");

      int done = 10;
      while (done)
      {
         mEventQueue.proc();
         if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) return -2;

         printf(".");
         packetsize = net_receive(ServerChannel, packetbuffer, 1024, address);
         if (packetsize)
         {
            set_packetpos(0);
            if (PacketRead("5678"))
            {
               printf("got response 5678: %s\n", address);
               net_assigntarget(ServerChannel, address);
               return 1;
            }
         }
         al_rest(.1);
         done--;
      }
      printf("no response\n");
   }
   return 0;
}
</code></pre>



<a name="Client sends 'cjon' packet"></a>
<mh7>Client sends 'cjon' packet</mh7>
<mh3>
Now that we have connection to the server, the client sends a 'cjon' packet, requesting to join.

Then the client moves to state 23 and waits for a reply from the server.

</mh3>
<pre><code class="language-cpp">   Packet("cjon");
   PacketPut1ByteInt(mPlayer.syn[0].color); // requested color
   PacketAddString(mLoop.local_hostname);
   ClientSend(packetbuffer, packetsize);
</code></pre>

<a name="Server receives 'cjon' packet and replies with 'sjon' packet"></a>
<mh7>Server receives 'cjon' packet and replies with 'sjon' packet</mh7>
<mh3>
When the server receives a 'cjon' packet, it checks to see if it has an available slot for the client.

If the server is full, it replies with an 'sjon' packet indicating the server is full.
</mh3>
<pre><code class="language-cpp">void mwNetgame::server_proc_cjon_packet(int who)
{
   char msg[1024];
   char temp_name[16];
   int color = PacketGet1ByteInt();
   PacketReadString(temp_name);

   if (mLog.LOG_NET_join)
   {
      sprintf(msg,"Server received join request from %s requesting color:%d", temp_name, color);
      mLog.add_log_entry_centered_text(11, 0, 76, "", "+", "-");
      mLog.add_log_entry_position_text(11, 0, 76, 10, msg, "|", " ");
   }
   // find empty player slot
   int cn = 99;
   for (int p=0; p < NUM_PLAYERS; p++)
      if ((mPlayer.syn[p].active == 0) && (mPlayer.syn[p].control_method == 0))
      {
         cn = p;
         break;
      }
   if (cn == 99) // no empty player slots found
   {
      if (mLog.LOG_NET_join)
      {
         sprintf(msg, "Reply sent: 'SERVER FULL'");
         mLog.add_log_entry_position_text(11, 0, 76, 10, msg, "|", " ");
         mLog.add_log_entry_centered_text(11, 0, 76, "", "+", "-");
      }

      Packet("sjon");    // reply with sjon
      PacketPut2ByteInt(0);
      PacketPut4ByteInt(0);
      PacketPut1ByteInt(0);
      PacketPut1ByteInt(99); // send sjon with player 99 to indicate server full
      PacketPut1ByteInt(0);
      PacketPut2ByteInt(0);
      PacketPut1ByteInt(0);
      ServerSendTo(packetbuffer, packetsize, who, 0);
   }
</code></pre>

<mh3>
If the server is not full, it proceeds with the join process.

First it checks if it can use the requested color.

Then the server sets up a client player structure and replies with an 'sjon' packet.</mh3>

</mh3>
<pre><code class="language-cpp">   else // empty player slot found, proceed with join
   {
      // try to use requested color, unless already used by another player
      while (mPlayer.is_player_color_used(color)) if (++color > 15) color = 1;
      mPlayer.init_player(cn, 1);
      mPlayer.set_player_start_pos(cn, 0);
      mPlayer.syn[cn].color = color;
      mPlayer.syn[cn].control_method = 2; //server client view only
      mPlayer.loc[cn].who = who;
      mPlayer.loc[cn].server_last_stak_rx_frame_num = mLoop.frame_num + 200;
      sprintf(mPlayer.loc[cn].hostname, "%s", temp_name);

      mGameMoves.add_game_move(mLoop.frame_num, 3, cn, color); // add a game move type 3 to mark client started join

      Packet("sjon"); // reply with sjon
      PacketPut2ByteInt(mLevel.play_level);
      PacketPut4ByteInt(mLoop.frame_num);
      PacketPut1ByteInt(cn);
      PacketPut1ByteInt(color);
      PacketPut1ByteInt(mShot.deathmatch_shots);
      PacketPut2ByteInt(mShot.deathmatch_shot_damage+1000);
      PacketPut1ByteInt(mShot.suicide_shots);
      ServerSendTo(packetbuffer, packetsize, who, cn);
   }
}
</code></pre>


<a name="Client receives 'sjon' packet"></a>
<mh7>Client receives 'sjon' packet</mh7>
<mh3>
When the client receives the 'sjon' packet, it sets up the local player structure and moves to the next phase of joining.
</mh3>
<pre><code class="language-cpp">   //---------------------------------------
   // 23 - client wait for join
   //---------------------------------------
   if (state[1] == 23)
   {
      mNetgame.client_fast_packet_loop();
      mNetgame.client_read_packet_buffer();
      if (mInput.key[ALLEGRO_KEY_ESCAPE][1]) state[0] = 25; // give them an escape option
   }

void mwNetgame::client_process_sjon_packet(void)
{
   int pl = PacketGet2ByteInt();   // play level
   int server_sjon_frame_num  =  PacketGet4ByteInt();

   int p = PacketGet1ByteInt();      // client player number
   int color = PacketGet1ByteInt();  // client player color
   int ds = PacketGet1ByteInt();     // deathmatch_shots
   int dd = PacketGet2ByteInt();     // deathmatch_shot_damage
   int ss = PacketGet1ByteInt();     // suicide_shots

   if (p == 99) // server full, join denied
   {
      sprintf(msg,"Server replied with 'SERVER FULL'\n");
      printf("%s", msg);
      if (mLog.LOG_NET_join) mLog.add_log_entry2(11, mPlayer.active_local_player, msg);
      mLoop.state[0] = 25;
   }
   else // join allowed
   {
      mPlayer.active_local_player = p;
      mPlayer.syn[p].control_method = 4;
      mPlayer.syn[p].color = color;
      strncpy(mPlayer.loc[0].hostname, m_serveraddress, 16);
      strncpy(mPlayer.loc[p].hostname, mLoop.local_hostname, 16);
      ima_client = 1;
      mLevel.play_level = pl;
      mShot.deathmatch_shots = ds;
      mShot.deathmatch_shot_damage = dd-1000;
      mShot.suicide_shots = ss;
      mLoop.state[0] = 22;
   }
}
</code></pre>

<a name="Client setup"></a>
<mh7>Client setup</mh7>
<mh3>
Here the client loads the level, sets up for the game, then moves to the next step.
</mh3>

<pre><code class="language-cpp">   //---------------------------------------
   // 22 - client level setup
   //---------------------------------------
   if (state[1] == 22)
   {
      if (!mLevel.load_level(mLevel.play_level, 0, 0))
      {
         state[0] = 25;
         return;
      }

      for (int p=0; p < NUM_PLAYERS; p++)
         mPlayer.set_player_start_pos(p, 0);     // get starting position for all players, active or not

      mGameMoves.initialize();

      frame_num = 0;
      mNetgame.reset_states();
      mShot.clear_shots();
      mBottomMessage.initialize();
      mInput.initialize();
      mTriggerEvent.initialize();

      mSound.start_music(0);
      state[0] = 21;
   }
</code></pre>



<a name="Client waits for initial state from server"></a>
<mh7>Client waits for initial state from server</mh7>
<mh3>
Once the client receives the initial state from the server, it goes to state 11, which is the normal game loop.
</mh3>
<pre><code class="language-cpp">   //---------------------------------------
   // 21 - client wait for intial state
   //---------------------------------------
   if (state[1] == 21)
   {
      mNetgame.client_fast_packet_loop();
      mNetgame.client_read_packet_buffer();
      mNetgame.client_apply_dif();
      if (mInput.key[ALLEGRO_KEY_ESCAPE][3]) state[0] = 25;
	  
      sprintf(msg, "Waiting for game state from server");
      float stretch = ( (float)mDisplay.SCREEN_W / ((strlen(msg)+2)*8));
      mScreen.rtextout_centre(mFont.bltn, NULL, msg, mDisplay.SCREEN_W/2, mDisplay.SCREEN_H/2, 10, stretch, 1);

      al_flip_display();
	  
      if (frame_num > 0)
      {
         int p = mPlayer.active_local_player;
         // set holdoff 200 frames in future so client won't try to drop while syncing
         mPlayer.loc[p].client_last_stdf_rx_frame_num = frame_num + 200;
         state[0] = 11;
      }
   }
}
</code></pre>



<a name="Client chase and lock"></a>
<mh7>Client chase and lock</mh7>
<mh3>
We are now in the regular game loop (state 11). However the client player is not active yet.

The client will run the game with its local player inactive, adjusting its timer to chase and lock with the server.

Once the server determines the client has locked, it sets the client active.
</mh3>
<pre><code class="language-cpp">void mwNetgame::server_lock_client(int p)
{
   char msg[1024];
   if ((!mPlayer.syn[p].active) && (mPlayer.syn[p].control_method == 2)) // inactive client chasing for lock
   {
      if ((mPlayer.loc[p].dsync > -0.2) && (mPlayer.loc[p].dsync < 0.03)) mPlayer.loc[p].sync_stabilization_holdoff++; // -200 to +30
      else mPlayer.loc[p].sync_stabilization_holdoff = 0;
   }
   if (mPlayer.loc[p].sync_stabilization_holdoff > 20) // we have been stable for over 20 frames
   {
      mGameMoves.add_game_move(mLoop.frame_num + 4, 1, p, mPlayer.syn[p].color);
      mPlayer.loc[p].sync_stabilization_holdoff = 0;

      sprintf(msg,"Player:%d has locked and will become active in 4 frames!", p);
      if (mLog.LOG_NET_join) mLog.add_log_entry_header(11, 0, msg, 0);
   }
}</code></pre>

<a name="Ending a client netgame"></a>
<mh7>Ending a client netgame</mh7>

<mh3>
If an error occurs, or the client netgame ends, we go to state 25 to properly shutdown the network and clean up.
</mh3>
<pre><code class="language-cpp">   //---------------------------------------
   // 25 - client exit
   //---------------------------------------
   if (state[1] == 25) // client exit
   {
      mNetgame.client_exit();
      state[0] = 1;
   }

void mwNetgame::client_exit(void)
{
   ClientExitNetwork();
   ima_client = 0;
   // reset player data
   for (int p=0; p < NUM_PLAYERS; p++) mPlayer.init_player(p, 1);
   mPlayer.syn[0].active = 1; // local_control
   mPlayer.active_local_player = 0;
   mConfig.load(); // to restore color and other settings
}

void mwNetgame::ClientExitNetwork(void)
{
   if (TCP)
   {
   	if(ServerConn) net_closeconn(ServerConn);
   	ServerConn = NULL;
   }
   else // UDP
   {
   	if(ServerChannel) net_closechannel(ServerChannel);
   	ServerChannel = NULL;
   }
   net_shutdown();
}
</code></pre>
            


<br><a name="Setting up netgame"></a>
<mh7>Setting up netgame</mh7>

<mh3>
To join a netgame, the client needs to know the IP or hostname of the server.
    
The server does not need to know anything about the client.
    
If both the server and the client can ping each other, netgame should work.
In some cases a firewall exception may need to be created. (especially for the server)
    
In windows, open a command prompt window and type:
- 'ipconfig' to see your local IP address
- 'hostname' to see your hostname

In linux, open a terminal and type:
- 'ifconfig' to see your local IP address
- 'hostname' to see your hostname

Do this for both the client and the server.
    
Then try to ping each other by typing:
- 'ping [IP]' or
- 'ping [hostname]'     
    
If that works then all you need to do is make sure the client has the server's IP or hostname set.
    
You can do this three different ways:
- in the game from the 'netgame' tab in 'settings'.
- open the config file 'pm.cfg' and edit the entry 'server_IP='    
- from the console or a command prompt window, start the game in client mode with 'pm -c [hostname or IP]'

Once you have ensured the client has the server's IP or hostname:

Start the server with 'Host Network Game', then start the clients with 'Join Network Game'
    
In a few seconds the client will join.
</mh3>


<br><a name="Netgame over the Internet"></a>
<mh7>Netgame over the Internet</mh7>

<mh3>
Setting Netgamne over the internet is non-trivial. With port forwarding, DMZ's and other tricks and hacks, it can be done.

This is an issue that has nothing to do with this game and everything to do with 'Peer-to-Peer Communication Across Network Address Translators'.

The method I used was to have the server in a DMZ, or directly connected to the internet (no router).

</mh3>

















               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2023, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
