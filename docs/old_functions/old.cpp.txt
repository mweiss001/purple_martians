



void test_window_size_and_pos(void)
{
   int adj = 0;
   // test if window origin (UL) is off screen
   if ((disp_x_wind > disp_w_full) || (disp_x_wind < 0))
   {
      disp_x_curr = disp_x_wind = 32;
      adj = 1;
   }

   if ((disp_y_wind > disp_h_full) || (disp_y_wind < 0))
   {
      disp_y_curr = disp_y_wind = 32;
      adj = 1;
   }

   // test if window (LR) is off screen
   if ((disp_x_wind+disp_w_wind) > disp_w_full)
   {
      disp_x_curr = disp_x_wind = 32;
      adj = 1;

      if ((disp_x_wind+disp_w_wind) > disp_w_full) // still off screen?
      {
          disp_w_curr = disp_w_wind = disp_w_full - disp_x_wind - 32;;
      }
   }

   if (disp_y_wind + disp_h_wind > disp_h_full)
   {
      disp_y_curr = disp_y_wind = 32;
      adj = 1;

      if (disp_y_wind + disp_h_wind > disp_h_full) // still off screen?
      {
          disp_h_curr = disp_h_wind = disp_h_full - disp_y_wind - 32;
      }
   }
   if (adj) save_config();
}


void fill_door_tile(void)
{
   if (1) // load from disk
   {
      dtilemap = al_load_bitmap("bitmaps/door_tiles.bmp");
      if (!dtilemap) m_err((char*)"Can't load tiles from bitmaps/door_tiles.bmp");
      else
      {
         //printf("load good\n");
         al_convert_mask_to_alpha(dtilemap, al_map_rgb(0, 0, 0)) ;
         al_set_target_bitmap(M_dtilemap);
         al_draw_bitmap(dtilemap, 0, 0, 0);

         for (int a=0; a<16; a++)
            for (int b=0; b<8; b++)
               door_tile[0][a][b] = al_create_sub_bitmap(dtilemap, b*20, a*20, 20, 20);

         for (int a=0; a<16; a++)
            for (int b=0; b<8; b++)
               door_tile[1][a][b] = al_create_sub_bitmap(dtilemap, b*20, 320+a*20, 20, 20);
      }
   }

   if (0) // create from shapes
   {
      // new set
      for (int a=0; a<16; a++)
         for (int b=0; b<8; b++)
         {
            al_set_target_bitmap(door_tile[0][a][b]);
            al_draw_bitmap(tile[972+b], 0, 0, 0);
         }

      // old set
      for (int a=0; a<16; a++)
         for (int b=0; b<7; b++)
         {
            al_set_target_bitmap(door_tile[1][a][b]);
            al_draw_bitmap(tile[448+b], 0, 0, 0);
         }

      // i use color 12 and 3
      // 12 dark blue for the corners and center that do not move
      // 3 light blue for the lines that move
      // lets just change 3 for now


      // change index to lowest value (color -2)
      int cs = -2;
      for (int b=0; b<8; b++) //cycle 8 shapes
      {
         al_set_target_bitmap(door_tile[0][0][b]);
         al_lock_bitmap(door_tile[0][0][b],al_get_bitmap_format(door_tile[0][0][b]),ALLEGRO_LOCK_READWRITE);

         for (int x=0; x<20; x++)
            for (int y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(door_tile[0][0][b], x, y);

               float D = 0.1;
               if (  (abs(p.r - palette_color[3].r) < D) &&
                     (abs(p.g - palette_color[3].g) < D) &&
                     (abs(p.b - palette_color[3].b) < D) ) al_put_pixel(x, y, palette_color[(3+cs)]);

            }
            //   if (getpixel(door_tile[0][0][b], x, y) == palette_color[3])  putpixel(door_tile[0][0][b], x, y, palette_color[1]);

         al_unlock_bitmap(door_tile[0][0][b]);
      }

      //set rest of table
      for (int a=1; a<16; a++)
         for (int b=0; b<8; b++)
         {
            al_lock_bitmap(door_tile[0][0][b],al_get_bitmap_format(door_tile[0][0][b]),ALLEGRO_LOCK_READONLY);
            al_lock_bitmap(door_tile[0][a][b],al_get_bitmap_format(door_tile[0][a][b]),ALLEGRO_LOCK_READWRITE);
            al_set_target_bitmap(door_tile[0][a][b]);

            for (int x=0; x<20; x++)
               for (int y=0; y<20; y++)
               {
                  ALLEGRO_COLOR p = al_get_pixel(door_tile[0][0][b], x, y);

                  float D = 0.1;
                  if (  (abs(p.r - palette_color[1].r) < D) &&
                        (abs(p.g - palette_color[1].g) < D) &&
                        (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[a]);
               }
                  //if (getpixel(door_tile[0][0][b], x, y) == palette_color[1])  putpixel(door_tile[0][a][b], x, y, palette_color[a] );
            al_unlock_bitmap(door_tile[0][0][b]);
            al_unlock_bitmap(door_tile[0][a][b]);
            al_convert_mask_to_alpha(door_tile[0][a][b], al_map_rgb(0, 0, 0)) ;

         }



      // old door uses colors 12, 76, 124
      // change index to lowest value (color -11
      cs = -11;
      for (int b=0; b<7; b++) // cycle 7 shapes
      {
         al_set_target_bitmap(door_tile[1][0][b]);
         al_lock_bitmap(door_tile[1][0][b],al_get_bitmap_format(door_tile[1][0][b]),ALLEGRO_LOCK_READWRITE);

         for (int x=0; x<20; x++)
            for (int y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(door_tile[1][0][b], x, y);

               float D = 0.1;
               if (  (abs(p.r - palette_color[12].r) < D) &&
                     (abs(p.g - palette_color[12].g) < D) &&
                     (abs(p.b - palette_color[12].b) < D) ) al_put_pixel(x, y, palette_color[12+cs]);

               if (  (abs(p.r - palette_color[76].r) < D) &&
                     (abs(p.g - palette_color[76].g) < D) &&
                     (abs(p.b - palette_color[76].b) < D) ) al_put_pixel(x, y, palette_color[76+cs]);

               if (  (abs(p.r - palette_color[124].r) < D) &&
                     (abs(p.g - palette_color[124].g) < D) &&
                     (abs(p.b - palette_color[124].b) < D) ) al_put_pixel(x, y, palette_color[124+cs]);
            }
         al_unlock_bitmap(door_tile[1][0][b]);
      }

      // set rest of table
      for (int a=1; a<16; a++)
         for (int b=0; b<7; b++) // cycle 7 shapes
         {
            al_lock_bitmap(door_tile[1][0][b],al_get_bitmap_format(door_tile[1][0][b]),ALLEGRO_LOCK_READONLY);
            al_lock_bitmap(door_tile[1][a][b],al_get_bitmap_format(door_tile[1][a][b]),ALLEGRO_LOCK_READWRITE);
            al_set_target_bitmap(door_tile[1][a][b]);

            for (int x=0; x<20; x++)
               for (int y=0; y<20; y++)

               {
                  ALLEGRO_COLOR p = al_get_pixel(door_tile[1][0][b], x, y);

                  float D = 0.1;
                  if (  (abs(p.r - palette_color[1].r) < D) &&
                        (abs(p.g - palette_color[1].g) < D) &&
                        (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[a]);

                  if (  (abs(p.r - palette_color[65].r) < D) &&
                        (abs(p.g - palette_color[65].g) < D) &&
                        (abs(p.b - palette_color[65].b) < D) ) al_put_pixel(x, y, palette_color[64+a]);

                  if (  (abs(p.r - palette_color[113].r) < D) &&
                        (abs(p.g - palette_color[113].g) < D) &&
                        (abs(p.b - palette_color[113].b) < D) ) al_put_pixel(x, y, palette_color[112+a]);
               }

            al_unlock_bitmap(door_tile[1][0][b]);
            al_unlock_bitmap(door_tile[1][a][b]);
            al_convert_mask_to_alpha(door_tile[1][a][b], al_map_rgb(0, 0, 0)) ;

         }
   }

//   int text_col = 15;
//   draw_small_text(tile[1014], 7, 8, text_col, 2); // "IN"
//   draw_small_text(tile[1015], 5, 8, text_col, 1); // "OUT"
//   al_set_target_bitmap(tilemap);
//   al_draw_bitmap(tile[1014], 22*20, 31*20, 0);
//   al_draw_bitmap(tile[1015], 23*20, 31*20, 0);
//   al_set_target_bitmap(M_tilemap);
//   al_draw_bitmap(tilemap, 0, 0, 0);
//   al_save_bitmap("bitmaps/tiles2.bmp", M_tilemap);



   /*
   al_set_target_backbuffer(display);
   al_draw_bitmap(tile[1014], 100, 100, 0);
   al_draw_bitmap(tile[1015], 100, 120, 0);

al_draw_scaled_bitmap(tile[1014],0, 0, 20, 20, 200, 100, 100, 100, 0);
al_draw_scaled_bitmap(tile[1015],0, 0, 20, 20, 200, 200, 100, 100, 0);

       al_flip_display();
       al_rest(2);

*/


   if (0)
   {
       // save to disk
       al_set_target_bitmap(dtilemap);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[0][a][b], b*20, a*20, 0);

       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[1][a][b], b*20, 320+a*20, 0);


       al_set_target_backbuffer(display);
       al_draw_bitmap(dtilemap, 0, 0, 0);
       al_flip_display();

       al_save_bitmap("bitmaps/door_tiles.bmp", dtilemap);
       tsw();
   }



   // show all
   if (0)
   {
       al_set_target_backbuffer(display);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[0][a][b], b*20, a*20, 0);
       for (int a=0; a<16; a++)
          for (int b=0; b<8; b++)
             al_draw_bitmap(door_tile[1][a][b], b*20, 340+a*20, 0);
       al_flip_display();
       tsw();
   }

}


void fill_player_tile(void)
{
   //printf("fill player bitmap\n");
   int a, b, x, y;

   if (1) // load from disk
   {
      ptilemap = al_load_bitmap("bitmaps/player_tiles.bmp");
      if (!ptilemap) m_err((char*)"Can't load tiles from bitmaps/player_tiles.bmp");
      else
      {
         //printf("load good\n");
         al_convert_mask_to_alpha(ptilemap, al_map_rgb(0, 0, 0)) ;

         al_set_target_bitmap(M_ptilemap);
         al_draw_bitmap(ptilemap, 0, 0, 0);

         // create sub bitmaps
         for (a=0; a<16; a++)
            for (b=0; b<19; b++)
               player_tile[a][b] = al_create_sub_bitmap(ptilemap, b*20, a*20, 20, 20);
      }
   }



   if (0) // create from shapes
   {
      //int bf = al_get_bitmap_format(player_tile[0][0]);
      //printf("bitmap format %d\n", bf);


   // fill the player_tile
   // fill the top row first and make it color = 1 then generate all next row aoutomatically
      for (a=0; a<16; a++) // set all to default shapes
      {
         al_set_target_bitmap(player_tile[a][0]); al_draw_bitmap(tile[400], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][1]); al_draw_bitmap(tile[401], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][2]); al_draw_bitmap(tile[402], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][3]); al_draw_bitmap(tile[403], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][4]); al_draw_bitmap(tile[404], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][5]); al_draw_bitmap(tile[405], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][6]); al_draw_bitmap(tile[368], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][7]); al_draw_bitmap(tile[369], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][8]); al_draw_bitmap(tile[370], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][9]); al_draw_bitmap(tile[371], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][10]); al_draw_bitmap(tile[372], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][11]); al_draw_bitmap(tile[373], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][12]); al_draw_bitmap(tile[384], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][13]); al_draw_bitmap(tile[385], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][14]); al_draw_bitmap(tile[386], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][15]); al_draw_bitmap(tile[387], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][16]); al_draw_bitmap(tile[388], 0, 0, 0);
         al_set_target_bitmap(player_tile[a][17]); al_draw_bitmap(tile[389], 0, 0, 0);

         al_set_target_bitmap(player_tile[a][18]); al_draw_bitmap(tile[755], 0, 0, 0);
      }

      // change index to lowest value (color -7)
      int cs = - 7; // first pass will set index(0) to lowest value possible (1)
      for (b=0; b<19; b++) //cycle 19 bitmaps for one color
      {
         al_set_target_bitmap(player_tile[0][b]);
         al_lock_bitmap(player_tile[0][b],al_get_bitmap_format(player_tile[0][b]),ALLEGRO_LOCK_READWRITE);

         for (x=0; x<20; x++)
            for (y=0; y<20; y++)
            {
               ALLEGRO_COLOR p = al_get_pixel(player_tile[0][b], x, y);

   /*          if (p == 8  ) putpixel(player_tile[0][b], x, y, (p+cs) );
               if (p == 56 ) putpixel(player_tile[0][b], x, y, (p+cs) );
               if (p == 136) putpixel(player_tile[0][b], x, y, (p+cs) );
   */
             // new method also works with true color
   //        if (!memcmp(&p, &palette_color[8], sizeof(ALLEGRO_COLOR))) al_put_pixel(x, y, palette_color[(8+cs)] );

   //            printf ("x%d y%d - pr%f pg%f pb%f cr%f cg%f cb%f\n", x, y, p.r, p.g, p.b,
   //                     palette_color[8].r, palette_color[8].g, palette_color[8].b );

                 float D = 0.1;
                 if (  (abs(p.r - palette_color[8].r) < D) &&
                       (abs(p.g - palette_color[8].g) < D) &&
                       (abs(p.b - palette_color[8].b) < D) ) al_put_pixel(x, y, palette_color[(8+cs)]);

                 if (  (abs(p.r - palette_color[56].r) < D) &&
                       (abs(p.g - palette_color[56].g) < D) &&
                       (abs(p.b - palette_color[56].b) < D) ) al_put_pixel(x, y, palette_color[(56+cs)]);

                 if (  (abs(p.r - palette_color[136].r) < D) &&
                       (abs(p.g - palette_color[136].g) < D) &&
                       (abs(p.b - palette_color[136].b) < D) ) al_put_pixel(x, y, palette_color[(136+cs)]);
            }
        al_unlock_bitmap(player_tile[0][b]);
        al_convert_mask_to_alpha(player_tile[0][b], al_map_rgb(0, 0, 0)) ;
      }

      //set rest of table
      for (a=1; a<16; a++) //cycle 15 player colors (no zero)
      {
         //printf("%d\n",a);
         for (b=0; b<19; b++) //cycle 18 bitmaps for one player
         {
            al_set_target_bitmap(player_tile[a][b]);
            al_lock_bitmap(player_tile[a][b],al_get_bitmap_format(player_tile[a][b]),ALLEGRO_LOCK_READWRITE);
            al_lock_bitmap(player_tile[0][b],al_get_bitmap_format(player_tile[0][b]),ALLEGRO_LOCK_READONLY);

            for (x=0; x<20; x++)
               for (y=0; y<20; y++)
               {
                  ALLEGRO_COLOR p = al_get_pixel(player_tile[0][b], x, y); // always read from 0 index if reference


                 float D = 0.1;
                 if (  (abs(p.r - palette_color[1].r) < D) &&
                       (abs(p.g - palette_color[1].g) < D) &&
                       (abs(p.b - palette_color[1].b) < D) ) al_put_pixel(x, y, palette_color[(1+a)]);

                 if (  (abs(p.r - palette_color[49].r) < D) &&
                       (abs(p.g - palette_color[49].g) < D) &&
                       (abs(p.b - palette_color[49].b) < D) ) al_put_pixel(x, y, palette_color[(49+a)]);

                 if (  (abs(p.r - palette_color[129].r) < D) &&
                       (abs(p.g - palette_color[129].g) < D) &&
                       (abs(p.b - palette_color[129].b) < D) ) al_put_pixel(x, y, palette_color[(129+a)]);
               }
            al_unlock_bitmap(player_tile[0][b]);
            al_unlock_bitmap(player_tile[a][b]);
            al_convert_mask_to_alpha(player_tile[a][b], al_map_rgb(0, 0, 0)) ;
         }
      }
   }

   if (0)
   {
       // show all new player shapes
       al_set_target_backbuffer(display);
       for (a=0; a<16; a++)
          for (b=0; b<19; b++)
             al_draw_bitmap(player_tile[a][b], b*20, a*20, 0);
       al_flip_display();
       tsw();
   }


   if (0)
   {
       // save to disk
       al_set_target_bitmap(ptilemap);
       for (a=0; a<16; a++)
          for (b=0; b<19; b++)
             al_draw_bitmap(player_tile[a][b], b*20, a*20, 0);

       al_set_target_backbuffer(display);
       al_draw_bitmap(ptilemap, 0, 0, 0);

       al_flip_display();

       al_save_bitmap("bitmaps/player_tiles.bmp", ptilemap);

       tsw();
   }


}


void show_resize_msg(int type)
{
   al_set_target_backbuffer(display);
   al_clear_to_color(al_map_rgb(0,0,0));
   float sc = (float)SCREEN_W / 120; // fill horizontally
   sc /=2;
   if (type == 1) rtextout_centre(NULL, (char*)"Resizing Screen ", SCREEN_W/2, SCREEN_H/2, 10, sc, 0, 1);
   if (type == 2) rtextout_centre(NULL, (char*)"Reloading Shapes", SCREEN_W/2, SCREEN_H/2, 10, sc, 0, 1);
   if (type == 3) rtextout_centre(NULL, (char*)"Options", SCREEN_W/2, SCREEN_H/2, 9, sc, 0, 1);
   al_flip_display();
}





int small_letter(ALLEGRO_BITMAP *bmp, int x, int col, char *t)
{


   int text_width = 0;
   switch(t[0])
   {
/*      case 68: // D
             rect(bmp, x+0, 0, x+2, 3, palette_color[col]);
         putpixel(bmp, x+2, 0,    palette_color[0]);
         putpixel(bmp, x+2, 3,    palette_color[0]);
         text_width = 4;
      break;
*/

      case 73: // I
            al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         text_width = 2;
      break;
      case 78: // N
         al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         al_draw_line(x+3.5f, 0.5f, x+3.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+1, 1, palette_color[col]);
         al_put_pixel(x+2, 2, palette_color[col]);
         text_width = 5;
      break;




      case 79: // O
         al_draw_rectangle(x+0.5f, 0+0.5f, x+2+0.5f, 3+0.5f, palette_color[col], 1);
         text_width = 4;
      break;

/*
      case 80: // P
             rect(bmp, x+0, 0, x+2, 2, palette_color[col]);
         putpixel(bmp, x+0, 3,    palette_color[col]);
         text_width = 4;
      break;
  */

      case 84: // T
            //vline(bmp, x+1, 0, 3, palette_color[col]);
         al_draw_line(x+1.5f, 0.5f, x+1.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+0, 0, palette_color[col]);
         al_put_pixel(x+2, 0, palette_color[col]);
         text_width = 4;
      break;


      case 85: // U
         al_draw_line(x+0.5f, 0.5f, x+0.5f, 4.5, palette_color[col], 1);
         al_draw_line(x+2.5f, 0.5f, x+2.5f, 4.5, palette_color[col], 1);
         al_put_pixel(x+1, 3, palette_color[col]);
         text_width = 4;
      break;


/*

      case 87: // W
            vline(bmp, x+0, 0, 2, palette_color[col]);
            vline(bmp, x+4, 0, 2, palette_color[col]);
         putpixel(bmp, x+1, 3,    palette_color[col]);
         putpixel(bmp, x+3, 3,    palette_color[col]);
         putpixel(bmp, x+2, 2,    palette_color[col]);
         text_width = 6;
      break;
*/

   }


   return text_width;


}

void draw_small_text(ALLEGRO_BITMAP * bmp, int x, int y, int col, int textnum)
{

   int xpos = 0;
   ALLEGRO_BITMAP *temp = NULL;

   if (textnum == 1) // OUT
   {
      temp = al_create_bitmap(11,4);
      al_set_target_bitmap(temp);
      al_clear_to_color(al_map_rgb(0,0,0));
      xpos += small_letter(temp, xpos, col, (char*)"O");
      xpos += small_letter(temp, xpos, col, (char*)"U");
      xpos += small_letter(temp, xpos, col, (char*)"T");
      al_set_target_bitmap(bmp);
      al_draw_bitmap(temp, x, y, 0);
   }
   if (textnum == 2) // IN
   {
      temp = al_create_bitmap(6,4);
      al_set_target_bitmap(temp);
      al_clear_to_color(al_map_rgb(0,0,0));
      xpos += small_letter(temp, xpos, col, (char*)"I");
      xpos += small_letter(temp, xpos, col, (char*)"N");
      al_set_target_bitmap(bmp);
      al_draw_bitmap(temp, x, y, 0);
   }
/*
   if (textnum == 3) // UP
   {
      temp = al_create_bitmap(7,4);
      clear(temp);
      xpos += small_letter(temp, xpos, col, "U");
      xpos += small_letter(temp, xpos, col, "P");
      draw_sprite(bmp, temp, x, y);
   }
   if (textnum == 4) // DOWN
   {
      temp = al_create_bitmap(19,4);
      clear(temp);
      xpos += small_letter(temp, xpos, col, "D");
      xpos += small_letter(temp, xpos, col, "O");
      xpos += small_letter(temp, xpos, col, "W");
      xpos += small_letter(temp, xpos, col, "N");
      draw_sprite(bmp, temp, x, y);
   }

*/
   al_destroy_bitmap(temp);



}



















/*
int st_sr(int sx, int sy, int cd, int gfx_card)
{
   set_color_depth(cd);
   if (set_gfx_mode(gfx_card, sx, sy, 0, 0) == 0)
   {
      if (gfx_card == 1) sprintf(msg, "[%4d x %4d] %2d bit fullscreen..", sx, sy, cd);
      if (gfx_card == 2) sprintf(msg, "[%4d x %4d] %2d bit windowed....", sx, sy, cd);

      strcat(log_msg, msg);
      printf("%s", msg);
      return 1;
   }
   else  // failed
   {
      sprintf(msg, "Error setting: [%d x %d] gfx_card:%d color_depth:%d\n", sx, sy, gfx_card, cd);
      strcat(log_msg, msg);
      printf("%s", msg);
      return 0;
   }
}


void st_run(void)
{
   load_gm("test1.gm");
   players[0].control_method = 1;
   start_mode = 2; // load level and start, but skip game array erasing
   game_exit = 0;

   int start_timer = clock();
   pm_main();
   int finish_time = clock();
   int time = finish_time - start_timer;

   int cps = CLOCKS_PER_SEC;

   sprintf(msg, "[%3d] Frames per second -- [%dms] per frame\n",(passcount*cps) / time, time/passcount);
   printf("%s", msg);
   strcat(log_msg, msg);

}

void speed_test(void)
{
   sprintf(msg, "\n---------------------------------\n- Speed test for %s\n", local_hostname);
   printf("%s", msg);
   strcpy(log_msg, msg);

   get_desktop_resolution(&desktop_sx, &desktop_sy);
   desktop_colordepth = desktop_color_depth();

   sprintf(msg, "Desktop resolution: [%d x %d] %d bit\n", desktop_sx, desktop_sy, desktop_colordepth);
   printf("%s", msg);
   strcat(log_msg, msg);

   // get operating system type
   show_os_detected();
   strcat(log_msg, msg);
   strcat(log_msg, "\n");

   int cps = CLOCKS_PER_SEC;
   sprintf(msg, "CLOCKS_PER_SEC [%d]\n", cps);
   printf("%s", msg);
   strcat(log_msg, msg);

   // get allegro id
   sprintf(msg, "Allegro version:    [%s]\n\n", allegro_id);
   printf("%s", msg);
   strcat(log_msg, msg);

   speed_testing = 1;








//   if (st_sr(desktop_sx, desktop_sy, 32, 1)) st_run();
//   if (st_sr(desktop_sx, desktop_sy, 16, 1)) st_run();
//   if (st_sr(desktop_sx, desktop_sy, 8, 1)) st_run();
//
//   if (st_sr(1024, 768, 32, 2)) st_run();
//   if (st_sr(1024, 768, 16, 2)) st_run();
//   if (st_sr(1024, 768, 8, 2)) st_run();
//
//
//
//   if (st_sr(1024, 768, 32, 1)) st_run();
//   if (st_sr(1024, 768, 16, 1)) st_run();
//   if (st_sr(1024, 768, 8, 1)) st_run();



//   if (st_sr(800, 600, 32, 2)) st_run();



//   if (st_sr(800, 600, 16, 2)) st_run();
//   if (st_sr(800, 600, 8, 2)) st_run();
//
//   if (st_sr(800, 600, 32, 1)) st_run();
//   if (st_sr(800, 600, 16, 1)) st_run();
//   if (st_sr(800, 600, 8, 1)) st_run();


   FILE *filepntr;
   char filename[140];
   sprintf(filename, "logs/speedtest[%s].txt", local_hostname);
   filepntr = fopen(filename,"w");
   fprintf(filepntr, "%s", log_msg);
   fclose(filepntr);
}

*/









/*
   load_tiles();
   for (int z = 0; z < 32; z++)
   {
      al_set_target_bitmap(tile[z]);
      al_lock_bitmap(tile[z], al_get_bitmap_format(tile[z]), ALLEGRO_LOCK_READWRITE);
      for (int x = 0; x < 20; x++)
         for (int y = 0; y < 20; y++)
         {
            ALLEGRO_COLOR c = al_get_pixel(tile[z], x, y);
            float r, g, b;
            al_unmap_rgb_f(c, &r, &g, &b);

            if ( (r < 0.2) && (g < 0.2) && (b < 0.2) )
               al_put_pixel(x, y, al_map_rgb(0,0,0));

         }
      al_unlock_bitmap(tile[z]);
   }
    save_tiles();
*/




//   draw_large_2lines(gv, "Purple", "Martians", 8, 1);
//   al_flip_display();
//   tsw();

//   ALLEGRO_COLOR c[5];
//   c[0] = al_map_rgb(255, 0, 0);
//   c[1] = al_map_rgb(0, 255, 0);
//   c[2] = al_map_rgb(0, 0, 255);
//   c[3] = al_map_rgb(255, 255, 255);
//   c[4] = al_map_rgb(0, 0, 0);
//
//   int quit = 0;
//   while (!quit)
//   {
//      proc_controllers();
//      if (key[ALLEGRO_KEY_ESCAPE]) quit =1;
//
//      char m1[256];
//      char m2[256];
//      int bbx1, bby1, bbw1, bbh1;
//      int bbx2, bby2, bbw2, bbh2;
//
//      sprintf(m1, "Michael") ;
//      sprintf(m2, "Weiss") ;
//
//      sprintf(m1, "Purple") ;
//      sprintf(m2, "Martians") ;
//      al_get_text_dimensions(gv, m1, &bbx1, &bby1, &bbw1, &bbh1);
//      al_get_text_dimensions(gv, m2, &bbx2, &bby2, &bbw2, &bbh2);
//
//      // get max w and h
//      float bbw3 = bbw1; if (bbw2 > bbw1) bbw3 = bbw2;
//      float bbh3 = bbh1; if (bbh2 > bbh1) bbh3 = bbh2;
//
//      printf("bbx1:%d bby1:%d bbw1:%d bbh1:%d\n",bbx1, bby1, bbw1, bbh1);
//      printf("bbx2:%d bby2:%d bbw2:%d bbh2:%d\n",bbx2, bby2, bbw2, bbh2);
//
//      ALLEGRO_BITMAP *t1 = al_create_bitmap(bbw3, bbh3);
//      al_set_target_bitmap(t1);
//      al_clear_to_color(al_map_rgb(0,0,0));
//      al_draw_text(gv, palette_color[8], 0-bbx1 + (bbw3-bbw1)/2, 0-bby1, 0, m1);
//      al_convert_mask_to_alpha(t1, al_map_rgb(0, 0, 0));
//
//      ALLEGRO_BITMAP *t2 = al_create_bitmap(bbw3, bbh3);
//      al_set_target_bitmap(t2);
//      al_clear_to_color(al_map_rgb(0,0,0));
//      al_draw_text(gv, palette_color[8], 0-bbx2 + (bbw3-bbw2)/2, 0-bby2, 0, m2);
//      al_convert_mask_to_alpha(t2, al_map_rgb(0, 0, 0));
//
//
//      int xs = SCREEN_W*7/8; // x size
//      int ys = SCREEN_H*3/8; // y size
//
//
//      int x1 = (SCREEN_W - xs)/2;
//      int x2 = xs;
//
//      int yu1 = SCREEN_H*1/4 - ys/2;
//      int yu2 = ys;
//
//      int yl1 = SCREEN_H*3/4 - ys/2;
//      int yl2 = ys;
//
//
//
//
//      al_set_target_backbuffer(display);
//
////      al_draw_line(0, SCREEN_H*1/4, SCREEN_W, SCREEN_H*1/4, c[2], 1);
////      al_draw_line(0, SCREEN_H*2/4, SCREEN_W, SCREEN_H*2/4, c[2], 1);
////      al_draw_line(0, SCREEN_H*3/4, SCREEN_W, SCREEN_H*3/4, c[2], 1);
//
//
//
//      al_draw_scaled_bitmap(t1, 0, 0, bbw3, bbh3, x1, yu1, x2, yu2, 0);
//      al_draw_scaled_bitmap(t2, 0, 0, bbw3, bbh3, x1, yl1, x2, yl2, 0);
//
//      al_flip_display();
//      al_clear_to_color(al_map_rgb(0,0,0));
//
//      al_destroy_bitmap(t1);
//      al_destroy_bitmap(t2);
//   }
//


//   char fn[1000];
//   sprintf(fn, "help/");
//   int ret = mw_file_select("Test get filename", fn, ".txt", 0);
//   printf("ret:%d  filename:[%s]", ret, fn);


   //options_menu();

   /*

   int c, r, g, b;

   c = palette_color[3];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("3 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[9];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("9 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[10];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("10 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[13];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("13 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[15];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("15 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);


   c = palette_color[173];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("173 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   c = palette_color[141];
   r = getr(c);
   g = getg(c);
   b = getb(c);
   printf("141 c:%4d   r:%3d g:%3d b:%3d \n", c, r, g, b);

   //            tsw();

   int c, r, g, b;

   c = getpixel(tile[400], 6, 3);
   r = getr(c);
   g = getg(c);
   b = getb(c);

   int c32 = makecol32(r, g, b);

   int ccc = 56;
   //            int ccc = palette_color[c];

   int cc8 = palette_color[8];

   //            int cc8 = 23;


   printf("c:%4d   r:%3d g:%3d b:%3d   32:%d  ccc:%d  cc8:%d\n", c, r, g, b, c32, ccc, cc8);


   c = getpixel(tile[400], 7, 3);
   c = getpixel(tile[400], 8, 3);

   */




   /*

   int size = sizeof(players);
   int lim = size / 1;

   memmove(c_players, players, size); // copy to temp player struct for comparison

   //            players[0].active++;

   //            players[0].paused+=256;

   //            players[0].shape = 256;



   for (i=0; i<lim; i++)
      if (memcmp(&players+i, &c_players+i, 1) != 0)
         printf("difference found in player struct at %d bytes\n", i);
   */

   /*
   int size = sizeof(players);
   char b1[size];
   char b2[size];

   memcpy(b1, players, size);

   players[0].active++;

   players[0].active = 256;

   players[1].active = 256;

   memcpy(b2, players, size);


   for (int i=0; i<size; i++)
      if (b1[i] != b2[i])
         printf("difference found in player struct at %d bytes\n", i);


   tsw();

   */

   /*

     load_level(39, 1);
     void chunk(void);
     chunk();

   */


   /*

   ALLEGRO_PATH * exe  = al_get_standard_path(ALLEGRO_EXENAME_PATH);

   // remove the filename part
   al_set_path_filename(exe, NULL);

   // add savegame as last dir in path
   al_append_path_component(exe, "savegame");

   // convert to string
   const char * cpathx  = al_path_cstr(exe, ALLEGRO_NATIVE_PATH_SEP);
   const char * ret;

   ALLEGRO_FILECHOOSER *afc = al_create_native_file_dialog(cpathx, "Run Game Filename", "*.gm", 0);

   if (al_show_native_file_dialog(display, afc))
   {

   if (al_get_native_file_dialog_count(afc) == 1)
   {
   ret =  al_get_native_file_dialog_path(afc, 0);
   printf("file selected:%s\n", ret);

   }

   }
   else printf("file select cancelled\n" );

   al_destroy_native_file_dialog(afc);



   */

   //     load_gm(NULL);

   //            spline_test();
   //            spline_adjust();
   //            mdw_an();


   // get some random numbers

   // suppose i want from 2-5 with .01

   // scale for int = *100;
   // 200-500

   // range = 300
   // 300

   /*

   for (int y = 0; y<100; y++)
   {
      int r = 200 + rand() % 300;
      al_fixed s = al_itofix(r) / 100;
      printf("[%3.2f]",al_fixtof(s));
   }
   tsw();



   //void solid_test(void);

   //   solid_test();

   //void run_dialog_netgame_conf(void);
   //run_dialog_netgame_conf();


   //void speed_test(void);
   //speed_test();




   // test nested if else


    int a = 5;
    int b = 18;
    int c = 10;

    if (a == 5)
       if (b == 8)
          if (c == 10) printf("test1\n");
             else printf("test2\n");

   tsw();




   int d =4;
   while (d > 0)
   {
      rect(screen, SCREEN_W/2-164, SCREEN_H/2-42, SCREEN_W/2+160, SCREEN_H/2-24, 11);
      sprintf(msg, "Chasing to passcount");
      rtextout_centre(screen, msg, SCREEN_W/2, SCREEN_H/2-32, 10, 2, 0);
      rectfill(screen, SCREEN_W/2-180, SCREEN_H/2-20, SCREEN_W/2+180, SCREEN_H/2+20, 0);
      rect(screen, SCREEN_W/2-180, SCREEN_H/2-20, SCREEN_W/2+180, SCREEN_H/2+16, 10);
      sprintf(msg, "[%d]", d);
      rtextout_centre(screen, msg, SCREEN_W/2, SCREEN_H/2, 10, 4, 0);
       d--;
    }

   tsw();*/






// ---------------------------------------------------------------------------------------------------------------
// ***************************************************************************************************************
//----------------------------------------------------------------------------------------------------------------

void nc_client(void) // for specialized packet testing only
{
   if (ClientInit("192.168.1.170"))  printf("Client init failed\n");
//   if (ClientCheckResponse())        printf("No server response\n");
   while (ClientCheckResponse()); // wait until its zero        printf("No server response\n");
   int quit = 0;
   while (!quit)
   {
      proc_controllers();
      if (key[ALLEGRO_KEY_ESCAPE]) quit = 1;
      if ((packetsize = ClientReceive(packetbuffer)) &&  (PacketRead("peep")))
      {
         int pc = PacketGet2ByteInt();
//            printf("client rx peep:[%d]\n", pc);
         pc++;
         if (pc < 1000)
         {
//               printf("client tx poop:[%d]\n",pc);
            Packet("poop");
            PacketPut2ByteInt(pc);
            ClientSend(packetbuffer, packetsize);
         }
         else
         {
            int finish_time = clock(); // stop the timer
            int time = finish_time - log_timer;
            printf("time:[%d]ms\n", time);
         }
      }
      if (key[ALLEGRO_KEY_1])
      {
         while (key[ALLEGRO_KEY_1]) proc_controllers();
         log_timer = clock(); // start the timer...
         printf("Sending poop packet to server\n");
         Packet("poop");
         PacketPut1ByteInt(0);
         ClientSend(packetbuffer, packetsize);
      }
   }
}







// ---------------------------------------------------------------------------------------------------------------
// ***************************************************************************************************************
//----------------------------------------------------------------------------------------------------------------

void nc_server(void) // for specialized packet testing only
{
   static int who;
   if (ServerInit())  printf ("Error initializing server\n");

   int quit = 0;
   while (!quit)
   {
      if (key[ALLEGRO_KEY_ESCAPE]) quit = 1;
      ServerListen(); // listen for connections
      packetsize = ServerReceive(packetbuffer, &who); // get packets
      if (packetsize > 0)
      {
         if(PacketRead("poop"))
         {
            int pc = PacketGet2ByteInt();
//            printf("server rx poop:[%d]\n", pc);
            pc++;
//            printf("server tx peep:[%d]\n", pc);
            Packet("peep");
            PacketPut2ByteInt(pc);
            ServerSendTo(packetbuffer, packetsize, who, 0);
         }
      }
      if (key[ALLEGRO_KEY_0] && ClientNum)
      {
         while (key[ALLEGRO_KEY_0]);
         Packet("stoc");
         PacketPut1ByteInt(0);
         ServerSendTo(packetbuffer, packetsize, 0, 0);
      }
   }
}






//   offset += size;
//   size = sizeof(players);
//   memmove(b+offset, players, size);
//   //printf("players \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(Ei);
//   memmove(b+offset, Ei, size);
//   //printf("int Ei[100][32] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(Efi);
//   memmove(b+offset, Efi, size);
//   //printf("al_fixed Efi[100][16] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(item);
//   memmove(b+offset, item, size);
//   //printf("int item[500][16] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(itemf);
//   memmove(b+offset, itemf, size);
//   //printf("al_fixed item[500][4] \tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(lifts);
//   memmove(b+offset, lifts, size);
//   //printf("lifts \t\t\tsize %d \toffset %d \n", size, offset);
//   offset += size;
//   size = sizeof(l);
//   memmove(b+offset, l, size);
//   //printf("l[100][100] \t\tsize %d \toffset %d \n", size, offset);

   //offset += size;
   //printf("----------------total chunk size %d \n", offset);








//   if (screen_messages_on)
//      switch (ev)
//      {
//         case   1: add_screen_msg("bang!", x, y, 100, 4, z1, z2, z3, z4); break;
//         case   2: add_screen_msg("key", x, y, 100, 5, z1, z2, z3, z4); break;
//         case   3: sprintf(msg, "%d enemies left to kill!", z1);
//                   add_screen_msg(msg, x, y, 100, 0, z1, z2, z3, z4); break;
//         case   3: add_screen_msg("------O------", x, y, 100, 0); break;
//         case   5: add_screen_msg("--O--", x, y, 100, 0); break;
//         case   5: add_screen_msg("Door", x, y, 100, 1, z1, z2, z3, z4); break;
//         case   6: sprintf(msg, "H+%d", z1);
//                   add_screen_msg(msg, x, y, 100, 2, z1, z2, z3, z4); break;
//         case   7: sprintf(msg, "H-%d", z1);
//                   add_screen_msg(msg, x, y, 100, 3, z1, z2, z3, z4); break;
//         case  8:  add_screen_msg("Bomb Damage!", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  10: add_screen_msg("Mine", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  13: sprintf(msg, "%s died! (%d left)", enemy_name[Ei[z1][0]],  num_enemy-1);
//                   add_screen_msg(msg, x, y, 100, 0, z1, z2, z3, z4); break;
//         case  21: add_screen_msg("You Died!", x, y, 100, 0, z1, z2, z3, z4); break;
//         case  30: add_screen_msg("switch", x, y, 100, 7, z1, z2, z3, z4); break;
//         case  31: add_screen_msg("boing!", x, y, 100, 6, z1, z2, z3, z4); break;
//         case  32: add_screen_msg("In", x, y, 100, 1, z1, z2, z3, z4); break;
//         case  33: add_screen_msg("Out", x, y, 100, 1, z1, z2, z3, z4); break;
//         case  34: add_screen_msg("Ouch", x, y, 100, 34, z1, z2, z3, z4); break;
//         case  35: add_screen_msg("Ouch", x, y, 100, 35, z1, z2, z3, z4); break;
//      }






void draw_screen_msg(void)
{
    for (int a=0; a<100; a++)
       if (screen_msgs[a].active)
       {
          int ssn = screen_msgs[a].ssn;

          int x = screen_msgs[a].x;
          int y = screen_msgs[a].y;
          int c = screen_msgs[a].color;
          int rot = screen_msgs[a].rot;
          float s = screen_msgs[a].size;

          rtextout_centre(level_buffer, screen_msgs[a].text, x + 10, y + 10, c, s, rot, 1 );

           // for all mode that aren't multimode
           if ((ssn == 0) || (ssn == 0) || (ssn == 4) || (ssn == 5) || (ssn == 6) || (ssn == 7) || (ssn == 34)|| (ssn == 35))
           {
             // decrement delay till 0 then set inactive
             --screen_msgs[a].delay;
             if (screen_msgs[a].delay == 0) screen_msgs[a].active = 0;
           }

           if (screen_msgs[a].ssn == 2) // health +
           {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // next out
                 {
                    screen_msgs[a].delay = 5;
                    screen_msgs[a].color = 11;
                    screen_msgs[a].yinc = -5;
                    screen_msgs[a].size = .5;
                    screen_msgs[a].size_inc = .11;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].color = 11;

                    screen_msgs[a].yinc = 0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {
                 if (screen_msgs[a].delay == 0) // next in
                 {
                    screen_msgs[a].delay = 6;
                    screen_msgs[a].color = 11;
                    screen_msgs[a].yinc = 4;
                    screen_msgs[a].size_inc = -.14;
                    screen_msgs[a].current_step = 8;
                 }
              }
              if (screen_msgs[a].current_step == 8)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }

          }

          if (screen_msgs[a].ssn == 3) // health -
          {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // next out
                 {
                    screen_msgs[a].delay = 5;
                    screen_msgs[a].color = 10;
                    screen_msgs[a].yinc = -8;
                    screen_msgs[a].size = .5;
                    screen_msgs[a].size_inc = .11;
                    screen_msgs[a].rot_inc = 0;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].yinc = 0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {


                 if (screen_msgs[a].delay == 0) // next in
                 {
                    screen_msgs[a].delay = 6;
                    screen_msgs[a].yinc = 4;
                    screen_msgs[a].size_inc = -.14;
                    screen_msgs[a].current_step = 8;
                 }
              }
              if (screen_msgs[a].current_step == 8)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }

          }

           if (screen_msgs[a].ssn == 1) // door (fade in and out)
           {
             --screen_msgs[a].delay;

              if (screen_msgs[a].current_step == 1) // immediate next
              {
                 if (screen_msgs[a].delay == 0) // fade in
                 {
                    screen_msgs[a].delay = 6;

                    screen_msgs[a].color = 12 + (6 * 32);

                    screen_msgs[a].color_inc = - 32;

//                  screen_msgs[a].color_inc_holdoff = screen_msgs[a].delay / 12;
                    screen_msgs[a].color_inc_holdoff = 1;

                    screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;

                    screen_msgs[a].size = 1.0;
                    screen_msgs[a].size_inc = 0;
                    screen_msgs[a].current_step = 2;
                 }
              }
              if (screen_msgs[a].current_step == 2)
              {
                 if (screen_msgs[a].delay == 0) // next wait
                 {
                    screen_msgs[a].delay = 30;
                    screen_msgs[a].color = 12;
                    screen_msgs[a].color_inc = 0;
                    screen_msgs[a].current_step = 3;
                 }
              }

              if (screen_msgs[a].current_step == 3)
              {
                 if (screen_msgs[a].delay == 0) // fade out
                 {
                    screen_msgs[a].delay = 15;
                    screen_msgs[a].color = 12;
                    screen_msgs[a].color_inc = 16;
                    screen_msgs[a].color_inc_holdoff = 1;

                    screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;


                    screen_msgs[a].current_step = 4;
                 }
              }

              if (screen_msgs[a].current_step == 4)
              {
                 if (screen_msgs[a].delay == 0)
                 {
                    screen_msgs[a].active = 0;  // done
                 }
              }
          }

          // increment the size
          screen_msgs[a].size = screen_msgs[a].size + screen_msgs[a].size_inc;

          // increment the rot
          screen_msgs[a].rot = screen_msgs[a].rot + screen_msgs[a].rot_inc;

          // increment x and y
          screen_msgs[a].x = screen_msgs[a].x + (int) screen_msgs[a].xinc;
          screen_msgs[a].y = screen_msgs[a].y + (int) screen_msgs[a].yinc;

          // increment color
          if (screen_msgs[a].color_inc) // do nothing if no color_inc
          {
             if (--screen_msgs[a].current_holdoff <= 0)
             {
                screen_msgs[a].color += screen_msgs[a].color_inc;

                if (screen_msgs[a].color < 0) screen_msgs[a].color += 256;
                if (screen_msgs[a].color < 255) screen_msgs[a].color -= 256;

                screen_msgs[a].current_holdoff = screen_msgs[a].color_inc_holdoff;
             }
          }

       }
}



void add_screen_msg(char *txt, int x, int y, int delay, int ssn, int z1, int z2, int z3, int z4 )
{
   // check to see if identical to any active entry
   int already_exists = 0;
    for (int a=0; a<100; a++)
       if (screen_msgs[a].active)
          if (screen_msgs[a].original_x == x)
             if (screen_msgs[a].original_y == y)
                if (strcmp(screen_msgs[a].text, txt) == 0)
                   if (ssn != 4 ) already_exists = 1;

   if (!already_exists)
   {
      for (int a=0; a<100; a++)
         if (!screen_msgs[a].active) // find first empty
         {
             // default settings
             screen_msgs[a].delay = 40;
             screen_msgs[a].active = 1;
             screen_msgs[a].color = 15;
             screen_msgs[a].color_inc = 0;
             screen_msgs[a].color_inc_holdoff = 0;
             screen_msgs[a].current_holdoff = 0;
             screen_msgs[a].delay = delay;
             screen_msgs[a].ssn = ssn;
             screen_msgs[a].original_x = x;
             screen_msgs[a].original_y = y;
             screen_msgs[a].x = x;
             screen_msgs[a].y = y;
             screen_msgs[a].xinc = 0;
             screen_msgs[a].yinc = 0;
             sprintf(screen_msgs[a].text, "%s", txt);
             screen_msgs[a].size = 1.0;
             screen_msgs[a].size_inc = 0.0;
             screen_msgs[a].rot = 0;
             screen_msgs[a].rot_inc = 0;

             // specific overrides

             if (ssn == 1) // Door
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 0;
                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;
                screen_msgs[a].size = 1.0;
                screen_msgs[a].size_inc = -.000;
                screen_msgs[a].x = x;
                screen_msgs[a].y = y-12; // raise above door

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;
             }


             if (ssn == 2) // Health +
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 11; // green

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;

             }

             if (ssn == 3) // Health -
             {
                screen_msgs[a].delay = 1;
                screen_msgs[a].color = 10; // red

                // multistep
                screen_msgs[a].current_step = 1;

                // initial step set here
                screen_msgs[a].size = 0;
                screen_msgs[a].size_inc = 0;

             }


             if (ssn == 4) // player shoots, bang!
             {
                screen_msgs[a].delay = 8;

                int p = z1; // player num
                int b = z2; // bullet num

                screen_msgs[a].x = pbullet[b][2];
                screen_msgs[a].y = pbullet[b][3];

                screen_msgs[a].xinc = pbullet[b][4]/3;
                screen_msgs[a].yinc = pbullet[b][5]/3;

                // do one inc to see if lines up better
                screen_msgs[a].x += pbullet[b][4];
                screen_msgs[a].y += pbullet[b][5];

                screen_msgs[a].color = players[p].color;

                screen_msgs[a].size = .2;
                screen_msgs[a].size_inc = .1;
             }


             if (ssn == 5) // key
             {
                screen_msgs[a].delay = 20;
                // get key tile
                if  (z2 == 1039) screen_msgs[a].color = 10; //red
                if  (z2 == 1040) screen_msgs[a].color = 11; //green
                if  (z2 == 1041) screen_msgs[a].color = 13; //lt blue
                if  (z2 == 1042) screen_msgs[a].color = 8;  //purple
             }

             if (ssn == 6) // boing
             {
                screen_msgs[a].delay = 20;
                screen_msgs[a].color = 14; //yellow

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .4;
                screen_msgs[a].size_inc = .015;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y;
                screen_msgs[a].yinc = -4;

             }


             if (ssn == 7) // switch
             {
                screen_msgs[a].delay = 20;
                screen_msgs[a].color = 15; // white

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .8;
                screen_msgs[a].size_inc = .005;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y;
                screen_msgs[a].yinc = -1;

             }

             if ((ssn == 34) || (ssn == 35))  // squished or stuck
             {
                screen_msgs[a].delay = 8;
                screen_msgs[a].color = 10; // red

                screen_msgs[a].rot = 0;
                screen_msgs[a].rot_inc = 0;

                screen_msgs[a].size = .8;
                screen_msgs[a].size_inc = .035;

                screen_msgs[a].x = x;
                screen_msgs[a].y = y-10;
                screen_msgs[a].yinc = -3;

             }

              a =100; // quit loop
         }
   }
}

struct screen_msg
{
   int active;
   int delay;
   int original_x;
   int original_y;

   int x;
   int y;
   char text[80];

   int color;
   int color_inc;

   int color_inc_holdoff;
   int current_holdoff;

   int ssn; //type of msg; used to select processing and initalization

   int current_step; // used by certain ssn's for multi-mode

   float size;
   float size_inc;

   float xinc;
   float yinc;

   int rot;  /// (0-255)
   int rot_inc;

};
extern struct screen_msg screen_msgs[100];

struct screen_msg screen_msgs[100];














