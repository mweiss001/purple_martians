Notes on using sqlite
----------------------


Windows:


downloaded version 3.35.1 amalgamation for windows

put sqlite3.c and sqlite3.h in my source dir
added sqlite3.c and sqlite3.h to the project

#include "sqlite3.h" 

   // prepare statement
   const char* sql2 = "UPDATE sessions SET dt_end=?, duration=? WHERE id = ?";
   sqlite3_prepare_v2(mSql.db, sql2, -1, &stmt, NULL);

   // bind parameters
   sqlite3_bind_text(stmt, 1, te, -1, SQLITE_STATIC);
   sqlite3_bind_int(stmt, 2, duration);
   sqlite3_bind_int(stmt, 3, sid);


   // execute and step through results
   step_result = sqlite3_step(stmt);
   if (step_result == SQLITE_ROW) printf("UPDATE SUCCESSFUL");
   else if (step_result == SQLITE_DONE)
   {
      printf("No row found for the given ID.\n");
   }
   else
   {
      fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(mSql.db));
   }

   // finalize the statement
   sqlite3_finalize(stmt);



Linux:
-------------------------------------------------------------------------------------

C++
---

had to manually compile sqlite
gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o
it takes 45s to compile on o3000


how can I make it work without manual intervention?
rename .c to .cpp? that did not work..

all my cpp files are compiled with this
g++ -Wall
i need to use gcc

added to ./lin_compile:

gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o



php
---

sudo apt install sqlite3
sudo apt install php-sqlite3
sudo apt install php libapache2-mod-php
sudo a2enmod php8.3



here is what I have to do to replace mysql with sqlite

- no built in SEC_TO_TIME in db
not sure why I was using at anyway

old connect:

// database setup
$srvrname = "localhost";
$database = "pm";
$username = "pmdb_ro";
$password = "readonly";
$conn = mysqli_connect($srvrname, $username, $password, $database);
if (!$conn) die("Connection failed: " . mysqli_connect_error());


new connect:

// database setup
$db_filepath = "/home/m/dev/purple_martians/data/database.db";
if (!file_exists($db_filepath))
{
   echo "Database file: $filename not found.";
   return;
}
$db = new PDO("sqlite:/home/m/dev/purple_martians/data/database.db");












old:
$res = mysqli_query($GLOBALS['conn'], $sql);
while ($row = $res->fetch_assoc())

new:
$res = $GLOBALS['db']->query($sql);
while ($row = $res->fetch(PDO::FETCH_ASSOC))

old: this does not work
if ($result->num_rows == 0) { echo " gm not found \n";  return; }


new:
$res = $GLOBALS['db']->query("SELECT COUNT(*) FROM sessions WHERE id=$current_session_id");
if ($res->fetchColumn() == 0)  { echo " session [$current_session_id] not found \n";  return; } 





















-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
Command line stuff:

linux:
----------------------------
sudo apt install sqlite3
type sqlite
.open <database>

windows
---------
Get the standalone exe: 'sqlite3.exe'
It is usually easiest to put it in the same folder as the database.
You can run it from the command line like this:
C:\pm>sqlite3 test.db
Or you can just drop the database file on the executable.



common
---------

.database

will show you the current database

sqlite> .database
main: C:\pm\data\database.db r/w

SQLite version 3.50.4 2025-07-30 19:33:53
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> .database
main: "" r/w

.schema will show you the tables and the commands used to create them

.tables will show you a list of tables

.mode MODE: Sets the output format for query results (e.g., csv, column, html, list, line).

.quit















































older........






















sqlite3 test.db

do this from regular command prompt.

when done you will be at the sqlite> prompt

C:\pm>sqlite3 test.db
SQLite version 3.46.0 2024-05-23 13:25:27 (UTF-16 console I/O)
Enter ".help" for usage hints.
sqlite> .database
main: C:\pm\test.db r/w
sqlite>


CREATE TABLE `pm_log`
(
  id           int PRIMARY KEY NOT NULL,
  received_at  datetime NOT NULL,
  agt          double NOT NULL,
  player_num   int NOT NULL,
  message_type int NOT NULL,
  frame_num    int NOT NULL,
  message      text NOT NULL
);


CREATE TABLE `pm_log`
(
  id           int PRIMARY KEY,
  received_at  datetime,
  agt          double,
  player_num   int,
  message_type int,
  frame_num    int,
  message      text
);

INSERT INTO pm_log (player_num) VALUES(23);

SELECT * FROM pm_log;


INSERT INTO pm_log (player_num, frame_num) VALUES(23, 1001);


sqlite> CREATE TABLE `pm_log`
   ...> (
(x1...>   id           int PRIMARY KEY,
(x1...>   received_at  datetime,
(x1...>   agt          double,
(x1...>   player_num   int,
(x1...>   message_type int,
(x1...>   frame_num    int,
(x1...>   message      text
(x1...> );
sqlite>
sqlite> INSERT INTO pm_log (player_num) VALUES(23);
sqlite> SELECT * FROM pm_log;
|||23|||
sqlite> INSERT INTO pm_log (player_num, frame_num) VALUES(23, 1001);
sqlite> SELECT * FROM pm_log;
|||23|||
|||23||1001|
sqlite>
OK now what?

try to connect with c++


#include <stdio.h>
#include <sqlite3.h> 

int main(int argc, char* argv[]) {
   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return(0);
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);
}



downloaded the amalgamation
put sqlite.c and sqlite.h in my source dir
added sqlite.c to the project

#include <sqlite3.h> 

void mwMain::temp_test(void)
{

   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return;
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);


compiles and works....

what did it do to my executable?

pm.exe is now 16.3M
removed and now it is 15.2M


I have worked through tutorials to connect to database, create and drop tables insert and select...

now lets see what I have to do to get it to work on linux....

copy all the sources to pmh


had to manually compile with this line:
gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o

many errors if trying to compile with g++

it fucking works!!

it makes test.db in the pm dir

so now what?

can something else on the server read the database?

what should I do next...

...........

how do I get qt to read that database?


here is the answer....
sql is not a network database....


OK..does this invalidate everything I have been doing up to here?

Do I absolutely need the remote access to the database?

If I view it in a web context I can use php and read the db locally...

When I want to look at the data with my qt app, then I probably need to connect to a remote database.
Other ways of doing it:
copy the sqlite database file from the server to the machine running qt..
this is not that far fetched...
I could have smaller database files, rotate them, 

The other way would be to stick with mysql...
Figure out how to do database stuff in c++

This would be nice if the clients could send a packet to the server and the server would enter into the database
Still there is the issue of a lot of log entries filling up the database


I had an idea:

First of all, just make sure that the clients send all their log messages to the server.

Then on the server, you can do whatever you want, you will have all the log messages.

You could:
- use syslog udp packets to insert them into syslog. then parse and move them to other tables
- figure out how to insert them into the right databases from c++ code.
- save them to disk in a format that is easy to import directly into a database of your choice


This sounds good enough that I think I will try to implement it.

The first thing is how do I get all the log lines from the client to the server...

Naive first thought is to just blast them out with 1 packet as they happen.
Its kind of like how I am alreay doing it.

I am thinking about making a structure in my game for log lines.
kind of mirror what I do in pm_log

timestamp
frame_num
player_num
client_num (only valid on server)
message_type
message text

then I could send a few of these in a compressed packet...


the reasons for converting my log system to a structure of lines
- when I send them to the server I can do more than one line per packet
- i know when the server has got them with an acknowledge
- when I go to dump them to disk they are already structured...


this all sounds like a huge rewrite of the logging system

it might be worth it...


at all the places in the code where log messages are created, I should have a single simple way of doing that...

add_log_entry(p1 p2 frame agt message_type, message)

then if they are printed do one thing
logged to file, do another
added to struct for db insert file 

---------------------

what is the simplest thing I could do next?
make client send logs in a new packet type as they occur...

make server receive and process these new log lines


---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------

2026-01-04 04:31:43

Today is the day.

sqlite will now be a permanent part of my project

downloaded version 3.35.1 amalgamation for windows

put sqlite3.c and sqlite3.h in my source dir
added sqlite3.c and sqlite3.h to the project

#include "sqlite3.h" 

void mwMain::temp_test(void)
{

   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return;
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);

compiles and works....


now how to use it?

this is where the database file will live:

   rc = sqlite3_open("data/database.db", &db);


from my bsd project:


extern sqlite3 *db;


int open_database(void)
{
    if (sqlite3_open(database_filename, &db))
   {
      printf("Can't open database %s\n", database_filename);
      sqlite3_close(db);
      return (0);
   }
   printf("Database %s open.\n", database_filename);
   return (1);
}


void show_all_transactions(void)
{
   if (sqlite3_exec(db, "SELECT * FROM btransactions;", callback, NULL, NULL) != SQLITE_OK) printf("SELECT error\n");
}

void show_all_statements(void)
{
   if (sqlite3_exec(db, "SELECT * FROM bstatements;", callback, NULL, NULL) != SQLITE_OK) printf("SELECT error\n");
}


int does_bstatement_exist(int acct, const char* date)
{
   int cnt;
   char msg[500];
   char* messaggeError;
   sprintf(msg, "SELECT COUNT(*) FROM bstatements WHERE account_type=%d AND date='%s';", acct, date);
   if (sqlite3_exec(db, msg, single_value_callback, &cnt, &messaggeError) != SQLITE_OK) printf("Error: %s\n%s\n", messaggeError, msg);
   return cnt; // returns the number of matches
}



int single_value_callback(void *val, int count, char** data, char** columns)
{
   int *val_int = (int*)val; // convert void* to int* (make a copy of the pointer?)
   if (count != 1) printf("Error! More than one result when expecting only one.\n");
   const char *val_as_text = data[0];  // convert to string
   *val_int = atoi(val_as_text); // convert to int and store in *id_int
   return 0;
}

int callback(void* data, int argc, char** argv, char** azColName)
{
   for (int i=0; i<argc; i++)
      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
   printf("\n");
   return 0;
}

I think I should make a class for this:

mwSql
mwSql.cpp
mwSql.h


2026-01-04 05:25:59

I have a small test working, now see if I can do the same on linux

how to I do that easily?

C:\pm>win_copy_to_pmh.bat copy_src 192.168.1.146
C:\pm>win_copy_to_pmh.bat lin_build 192.168.1.146

