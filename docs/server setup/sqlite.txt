

Install sqlite on windows.

    Step 1 − Go to SQLite download page, and download precompiled binaries from Windows section.

    Step 2 − Download sqlite-shell-win32-*.zip and sqlite-dll-win32-*.zip zipped files.

    Step 3 − Create a folder C:\>sqlite and unzip above two zipped files in this folder, which will give you sqlite3.def, sqlite3.dll and sqlite3.exe files.

    Step 4 − Add C:\>sqlite in your PATH environment variable and finally go to the command prompt and issue sqlite3 command, which should display the following result.

C:\>sqlite3
SQLite version 3.7.15.2 2013-01-09 11:53:05
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite>



C:\pm>PATH

PATH=C:\Program Files (x86)\Common Files\Intel\Shared Libraries\redist\intel64\compiler;C:\Program Files\Common Files\Oracle\Java\javapath;C:\Program Files\Oculus\Support\oculus-runtime;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files\Git\cmd;C:\Program Files\dotnet\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Strawberry\c\bin;C:\Strawberry\perl\site\bin;C:\Strawberry\perl\bin;C:\Program Files\gs\gs10.00.0\bin;C:\Program Files\Calibre2\;C:\Program Files\MySQL\MySQL Shell 8.0\bin\;C:\Program Files\Oculus\Support\oculus-runtime;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files\Git\cmd;C:\Program Files\dotnet\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Strawberry\c\bin;C:\Strawberry\perl\site\bin;C:\Strawberry\perl\bin;C:\Users\m\AppData\Local\Microsoft\WindowsApps;;C:\Strawberry\perl\bin

C:\pm>setx /M path "%path%;C:\sqlite"

WARNING: The data being saved is truncated to 1024 characters.
ERROR: Access to the registry path is denied.

C:\pm>

This is trimmed down a little:

run as admin:

setx path "C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;C:\Program Files\Git\cmd;C:\Program Files\dotnet\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\gs\gs10.00.0\bin;C:\Program Files\Calibre2\;C:\Strawberry\c\bin;C:\Strawberry\perl\site\bin;C:\Strawberry\perl\bin;C:\Users\m\AppData\Local\Microsoft\WindowsApps;C:\sqlite;"





create a database:

sqlite3 test.db

do this from regular command prompt.

when done you will be at the sqlite> prompt

C:\pm>sqlite3 test.db
SQLite version 3.46.0 2024-05-23 13:25:27 (UTF-16 console I/O)
Enter ".help" for usage hints.
sqlite> .database
main: C:\pm\test.db r/w
sqlite>



CREATE TABLE `pm_log`
(
  id           int PRIMARY KEY NOT NULL,
  received_at  datetime NOT NULL,
  agt          double NOT NULL,
  player_num   int NOT NULL,
  message_type int NOT NULL,
  frame_num    int NOT NULL,
  message      text NOT NULL
);


CREATE TABLE `pm_log`
(
  id           int PRIMARY KEY,
  received_at  datetime,
  agt          double,
  player_num   int,
  message_type int,
  frame_num    int,
  message      text
);

INSERT INTO pm_log (player_num) VALUES(23);

SELECT * FROM pm_log;


INSERT INTO pm_log (player_num, frame_num) VALUES(23, 1001);


sqlite> CREATE TABLE `pm_log`
   ...> (
(x1...>   id           int PRIMARY KEY,
(x1...>   received_at  datetime,
(x1...>   agt          double,
(x1...>   player_num   int,
(x1...>   message_type int,
(x1...>   frame_num    int,
(x1...>   message      text
(x1...> );
sqlite>
sqlite> INSERT INTO pm_log (player_num) VALUES(23);
sqlite> SELECT * FROM pm_log;
|||23|||
sqlite> INSERT INTO pm_log (player_num, frame_num) VALUES(23, 1001);
sqlite> SELECT * FROM pm_log;
|||23|||
|||23||1001|
sqlite>
OK now what?

try to connect with c++


#include <stdio.h>
#include <sqlite3.h> 

int main(int argc, char* argv[]) {
   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return(0);
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);
}



downloaded the amalgamation
put sqlite.c and sqlite.h in my source dir
added sqlite.c to the project

#include <sqlite3.h> 

void mwMain::temp_test(void)
{

   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return;
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);


compiles and works....

what did it do to my executable?


pm.exe is now 16.3M
removed and now it is 15.2M


I have worked through tutorials to connect to database, create and drop tables insert and select...

now lets see what I have to do to get it to work on linux....

copy all the sources to pmh



had to manually compile with this line:
gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o

many errors if trying to compile with g++

it fucking works!!

it makes test.db in the pm dir

so now what?

can something else on the server read the database?

what should I do next...

...........

how do I get qt to read that database?



here is the answer....
sql is not a network database....


OK..does this invalidate everything I have been doing up to here?

Do I absolutely need the remote access to the database?

If I view it in a web context I can use php and read the db locally...

When I want to look at the data with my qt app, then I probably need to connect to a remote database.
Other ways of doing it:
copy the sqlite database file from the server to the machine running qt..
this is not that far fetched...
I could have smaller database files, rotate them, 

The other way would be to stick with mysql...
Figure out how to do database stuff in c++

This would be nice if the clients could send a packet to the server and the server would enter into the database
Still there is the issue of a lot of log entries filling up the database


I had an idea:

First of all, just make sure that the clients send all their log messages to the server.

Then on the server, you can do whatever you want, you will have all the log messages.

You could:
- use syslog udp packets to insert them into syslog. then parse and move them to other tables
- figure out how to insert them into the right databases from c++ code.
- save them to disk in a format that is easy to import directly into a database of your choice


This sounds good enough that I think I will try to implement it.

The first thing is how do I get all the log lines from the client to the server...

Naive first thought is to just blast them out with 1 packet as they happen.
Its kind of like how I am alreay doing it.

I am thinking about making a structure in my game for log lines.
kind of mirror what I do in pm_log


timestamp
frame_num
player_num
client_num (only valid on server)
message_type
message text

then I could send a few of these in a compressed packet...



the reasons for converting my log system to a structure of lines
- when I send them to the server I can do more than one line per packet
- i know when the server has got them with an acknowledge
- when I go to dump them to disk they are already structured...


this all sounds like a huge rewrite of the logging system

it might be worth it...


at all the places in the code where log messages are created, I should have a single simple way of doing that...

add_log_entry(p1 p2 frame agt message_type, message)

then if they are printed do one thing
logged to file, do another
added to struct for db insert file 


---------------------

what is the simplest thing I could do next?
make client send logs in a new packet type as they occur...

make server receive and process these new log lines



---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------

2026-01-04 04:31:43

Today is the day.

sqlite will now be a permanent part of my project

downloaded version 3.35.1 amalgamation for windows

put sqlite3.c and sqlite3.h in my source dir
added sqlite3.c and sqlite3.h to the project

#include "sqlite3.h" 

void mwMain::temp_test(void)
{

   sqlite3 *db;
   char *zErrMsg = 0;
   int rc;

   rc = sqlite3_open("test.db", &db);

   if( rc ) {
      fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
      return;
   } else {
      fprintf(stderr, "Opened database successfully\n");
   }
   sqlite3_close(db);

compiles and works....


now how to use it?

this is where the database file will live:

   rc = sqlite3_open("data/database.db", &db);


from my bsd project:


extern sqlite3 *db;


int open_database(void)
{
    if (sqlite3_open(database_filename, &db))
   {
      printf("Can't open database %s\n", database_filename);
      sqlite3_close(db);
      return (0);
   }
   printf("Database %s open.\n", database_filename);
   return (1);
}


void show_all_transactions(void)
{
   if (sqlite3_exec(db, "SELECT * FROM btransactions;", callback, NULL, NULL) != SQLITE_OK) printf("SELECT error\n");
}

void show_all_statements(void)
{
   if (sqlite3_exec(db, "SELECT * FROM bstatements;", callback, NULL, NULL) != SQLITE_OK) printf("SELECT error\n");
}


int does_bstatement_exist(int acct, const char* date)
{
   int cnt;
   char msg[500];
   char* messaggeError;
   sprintf(msg, "SELECT COUNT(*) FROM bstatements WHERE account_type=%d AND date='%s';", acct, date);
   if (sqlite3_exec(db, msg, single_value_callback, &cnt, &messaggeError) != SQLITE_OK) printf("Error: %s\n%s\n", messaggeError, msg);
   return cnt; // returns the number of matches
}



int single_value_callback(void *val, int count, char** data, char** columns)
{
   int *val_int = (int*)val; // convert void* to int* (make a copy of the pointer?)
   if (count != 1) printf("Error! More than one result when expecting only one.\n");
   const char *val_as_text = data[0];  // convert to string
   *val_int = atoi(val_as_text); // convert to int and store in *id_int
   return 0;
}


int callback(void* data, int argc, char** argv, char** azColName)
{
   for (int i=0; i<argc; i++)
      printf("%s = %s\n", azColName[i], argv[i] ? argv[i] : "NULL");
   printf("\n");
   return 0;
}



I think I should make a class for this:

mwSql

mwSql.cpp
mwSql.h


2026-01-04 05:25:59

I have a small test working, now see if I can do the same on linux


how to I do that easily?

C:\pm>win_copy_to_pmh.bat copy_src 192.168.1.146
C:\pm>win_copy_to_pmh.bat lin_build 192.168.1.146

would not link

had to manually compile sqlite
gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o
it takes 45s to compile on o3000


now it links and runs and the tests work the same

how can I make it work with intervention?

rename .c to .cpp? that did not work..

all my cpp files are compiled with this
g++ -Wall
i need to use gcc
added to ./lin_compile
gcc -Wall -c src/sqlite3.c -o o/src/sqlite.o


done...

2026-01-04 06:08:14

now back to doing something useful with it...

create the tables

Table 'sessions' Created Successfully
Table 'gm' Created Successfully
Table 'gm_sessions' Created Successfully
Table 'players' Created Successfully
Table 'gm_players' Created Successfully

2026-01-04 06:54:11

next...

bite the bullet and work on sessions?

its huge....
i could do a simple gm for now...

hook into sessions and do both 


starting:
---------
A session is started by calling:
void mwNetgame::session_add_entry(const char* address, const char* hostname, int p, int active, int endreason)
The server does this when replying to a join request.

This clears and fills the array struct for the client.
Then calls session_add_log(int i) to write it to disk.


checking:
--------
Once per frame in server control, 'session_check_active()' is called
if ((client_sessions[p].active) && (!mPlayer.syn[p].active)) session_close(p, 6); // session still active, but player is not active anymore
it will close any open sessions where the player is no longer active

ending:
-------
A session is closed by calling:
void mwNetgame::session_close(int p, int reason)

The server will do this on comm loss: session_close(p, 4); // reason 4 - comm loss
mwGameMoves will do this when client quit: session_close(p, 2); // reason 2 - client quit
It can also be closed by session_check_active()
if ((client_sessions[p].active) && (!mPlayer.syn[p].active)) session_close(p, 6); // session still active, but player is not active anymore

is the server exits, all sessions are closed and saved
session_flush_active_at_server_exit(void)

updating
--------
To update a session the function 'session_add_log()' is called again
all the info from the struct is written to disk, overwriting the old stuff

when a level is done, player data tallies are added to session and saved 
session_save_active_at_level_done()


void mwNetgame::session_add_entry(const char* address, const char* hostname, int p, int active, int endreason)

modified to enter new record in database


In think I want to add active to database, or I could use endreason
if endreason == 0 session is still open



am i planning on doing away with the sessions_struct entirely?

should I save a link to the id of the one in the database?


I have 8 copies of it, one per player...

i think it explicitly shadows player number...

should I keep it?

the server is the only one that does anything with sessions

could I add something in the local player struct to link to the session





   strcpy(sql, "CREATE TABLE IF NOT EXISTS sessions( \
               id                INTEGER PRIMARY KEY, \
               filename          VARCHAR(255), \
               dt_start          DATETIME, \
               dt_end            DATETIME, \
               duration          INT, \
               ip                VARCHAR(255), \
               port              INT, \
               hostname          VARCHAR(255), \
               endreason         VARCHAR(255),  \
               cdat_rx           INT, \
               player_num        INT, \
               player_name       VARCHAR(255), \
               player_color      INT, \
               next_levels       INT, \
               exits_activated   INT, \
               respawns          INT, \
               shots_fired       INT,  \
               enemy_hits        INT, \
               player_hits       INT, \
               self_hits         INT, \
               purple_coins      INT, \
               tx_bytes_total            INT, \
               tx_bytes_avg_per_sec      INT, \
               tx_bytes_max_per_frame    INT, \
               rx_bytes_total            INT, \
               rx_bytes_avg_per_sec      INT, \
               rx_bytes_max_per_frame    INT, \
               tx_packets_total          INT, \
               tx_packets_avg_per_sec    INT, \
               tx_packets_max_per_frame  INT, \
               rx_packets_total          INT, \
               rx_packets_avg_per_sec    INT, \
               rx_packets_max_per_frame  INT ); ");

creating new:
               dt_start          DATETIME, \
               ip                VARCHAR(255), \
               port              INT, \
               hostname          VARCHAR(255), \
               player_num        INT, \
               player_name       VARCHAR(255), \
               player_color      INT, \


update or close
              
               
               at level done
               dt_end            DATETIME, \
               duration          INT, \
               cdat_rx           INT, \
               next_levels       INT, \
               exits_activated   INT, \
               respawns          INT, \
               shots_fired       INT,  \
               enemy_hits        INT, \
               player_hits       INT, \
               self_hits         INT, \
               purple_coins      INT, \
               tx_bytes_total            INT, \
               tx_bytes_avg_per_sec      INT, \
               tx_bytes_max_per_frame    INT, \
               rx_bytes_total            INT, \
               rx_bytes_avg_per_sec      INT, \
               rx_bytes_max_per_frame    INT, \
               tx_packets_total          INT, \
               tx_packets_avg_per_sec    INT, \
               tx_packets_max_per_frame  INT, \
               rx_packets_total          INT, \
               rx_packets_avg_per_sec    INT, \
               rx_packets_max_per_frame  INT ); ");




I have add done
now update will use session_id in player loc

what else should I pass to update?
endreason

if zero keep open, otherwise just update everything

for now, don;t worry about all the tallies, just do times, and endreason

add to db, end_reason text..or I could just use what I have instead of int
make it VARCHAR


add to player loc, session_start, session_end...no





now the big one...php and sqlite


sudo apt install sqlite3
sudo apt install php-sqlite3


here is what I have to do to replace mysql with sqlite

- no built in SEC_TO_TIME in db
not sure why I was using at anyway

old connect:

// database setup
$srvrname = "localhost";
$database = "pm";
$username = "pmdb_ro";
$password = "readonly";
$conn = mysqli_connect($srvrname, $username, $password, $database);
if (!$conn) die("Connection failed: " . mysqli_connect_error());


new:
$db = new PDO("sqlite:./database.db");

old:
$res = mysqli_query($GLOBALS['conn'], $sql);
while ($row = $res->fetch_assoc())

new:
$res = $GLOBALS['db']->query($sql);
while ($row = $res->fetch(PDO::FETCH_ASSOC))

that is all...


next...

very important...

where is the database file going to live?

where it already is:

also in sqlite you cannot do:

   if ($result->num_rows == 0) { echo " gm not found \n";  return; }

do this instead:

   $res = $GLOBALS['db']->query("SELECT COUNT(*) FROM sessions WHERE id=$current_session_id");
   if ($res->fetchColumn() == 0)  { echo " session [$current_session_id] not found \n";  return; } 





   // prepare statement
   const char* sql2 = "UPDATE sessions SET dt_end=?, duration=? WHERE id = ?";
   sqlite3_prepare_v2(mSql.db, sql2, -1, &stmt, NULL);

   // bind parameters
   sqlite3_bind_text(stmt, 1, te, -1, SQLITE_STATIC);
   sqlite3_bind_int(stmt, 2, duration);
   sqlite3_bind_int(stmt, 3, sid);


   // execute and step through results
   step_result = sqlite3_step(stmt);
   if (step_result == SQLITE_ROW) printf("UPDATE SUCCESSFUL");
   else if (step_result == SQLITE_DONE)
   {
      printf("No row found for the given ID.\n");
   }
   else
   {
      fprintf(stderr, "SQL error: %s\n", sqlite3_errmsg(mSql.db));
   }


   // finalize the statement
   sqlite3_finalize(stmt);





all seems well....

now the big one...php and sqlite


sudo apt install sqlite3
sudo apt install php-sqlite3


here is what I have to do to replace mysql with sqlite

- no built in SEC_TO_TIME in db
not sure why I was using at anyway

old connect:

// database setup
$srvrname = "localhost";
$database = "pm";
$username = "pmdb_ro";
$password = "readonly";
$conn = mysqli_connect($srvrname, $username, $password, $database);
if (!$conn) die("Connection failed: " . mysqli_connect_error());


new:
$db = new PDO("sqlite:./database.db");

old:
$res = mysqli_query($GLOBALS['conn'], $sql);
while ($row = $res->fetch_assoc())

new:
$res = $GLOBALS['db']->query($sql);
while ($row = $res->fetch(PDO::FETCH_ASSOC))

that is all...


next...

very important...

where is the database file going to live?

where it already is:

also in sqlite you cannot do:

   if ($result->num_rows == 0) { echo " gm not found \n";  return; }

do this instead:

   $res = $GLOBALS['db']->query("SELECT COUNT(*) FROM sessions WHERE id=$current_session_id");
   if ($res->fetchColumn() == 0)  { echo " session [$current_session_id] not found \n";  return; } 


I am quite happy with how this is working...


I am going to get the sqlite specific shit in this file, move it up then copy most of these notes to the project notes....

























































































