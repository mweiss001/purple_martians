<!doctype html>
<title>Netgame - Main</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div></mdw_lhs_nav>

        </nav>




        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>

<mh3><hr></mh3>
<mh8>Netgame - Main</mh8>
<mh3><hr><mdw_file_toc> <a href="netgame_main.html#Overview" target="_top">Overview</a>
 <a href="netgame_main.html#The Game State" target="_top">The Game State</a>
 <a href="netgame_main.html#The difference bewtween a 'state' and a 'dif'" target="_top">The difference bewtween a 'state' and a 'dif'</a>


</mdw_file_toc><hr></mh3>

<a name="Overview"></a>
<mh7>Overview</mh7>


<mh3>
This is the latest iteration of Netgame circa 2023

I have completely abandoned syncing game moves between server and client.

The only method used now is sending the server's game state to the clients.

Just like before, the server is the absolute authority.

Clients may run independantly for a few frames, predicting what they think will happen, until a new state from the server is received and blindly overwrites the client's game state.

When a client's controls change, they are applied to the clients local game state, saved locally on the client, and sent to the server.

The clients run slightly ahead of the server in time. That means that when a client receives a state from the server, it will most likely be in past.

The client handles this by rewinding and replaying to the current frame.
The rewinding is simply applying a state from the past. That has the effect of rewinding.

When the client replays from there, it also re-applies its locally stored moves for frames past what the server has sent.



Because the server is running behind the clients, game moves from clients will most likely be received too late to be applied.
The server stores them in the the game moves array, even though they are in the past.

When the server sends states to clients, the server first rewinds and replays to apply the clients moves that arrived too late.


</mh3>    


<br><a name="The Game State"></a>
<mh7>The Game State</mh7>

<mh3>
The Game State is all of the data required to replicate the game between server and client.

It consists of all the relevant variables for the level, player, enemy, item, bullets.. etc.

</mh3>    
<pre><code class="language-cpp">// Variables used for netgame state exchange
players  :  2048
Ei       : 12800
Efi      :  6400
item     : 32000
itemf    : 32000
lifts    :  5280
l        : 40000
pbullet  :  1200
ebullets :  1200
pm_event :  4000
---------:------
total    :112928
</code></pre>



<mh3>
I use memcpy to put all those loose variables into a character array so I can process it as one chunk of data.

I call these large char arrays 'states'.  Clients use 3 and the server uses 16 (2 for each client).

</mh3>
<pre><code class="language-cpp">#define STATE_SIZE 112928

// server's copies of client states
extern char srv_client_state[8][2][STATE_SIZE];
extern int srv_client_state_frame_num[8][2];

// local client's states
extern char client_state_buffer[STATE_SIZE];  // buffer for building compressed dif from packet pieces
extern int  client_state_buffer_pieces[16];   // to mark packet pieces as received
extern char client_state_base[STATE_SIZE];    // last ack state
extern int  client_state_base_frame_num;      // last ack state frame_num
extern char client_state_dif[STATE_SIZE];     // uncompressed dif
extern int  client_state_dif_src;             // uncompressed dif src frame_num
extern int  client_state_dif_dst;             // uncompressed dif dst frame_num
</code></pre>

<mh3>
Here is how I put the variables into a char array and how I get them out:

</mh3>
<pre><code class="language-cpp">void game_vars_to_state(char * b)
{
   int sz = 0, offset = 0;
   offset += sz; sz = sizeof(players);  memcpy(b+offset, players,  sz);
   offset += sz; sz = sizeof(Ei);       memcpy(b+offset, Ei,       sz);
   offset += sz; sz = sizeof(Efi);      memcpy(b+offset, Efi,      sz);
   offset += sz; sz = sizeof(item);     memcpy(b+offset, item,     sz);
   offset += sz; sz = sizeof(itemf);    memcpy(b+offset, itemf,    sz);
   offset += sz; sz = sizeof(lifts);    memcpy(b+offset, lifts,    sz);
   offset += sz; sz = sizeof(l);        memcpy(b+offset, l,        sz);
   offset += sz; sz = sizeof(pbullet);  memcpy(b+offset, pbullet,  sz);
   offset += sz; sz = sizeof(ebullets); memcpy(b+offset, ebullets, sz);
   offset += sz; sz = sizeof(pm_event); memcpy(b+offset, pm_event, sz);
}

void state_to_game_vars(char * b)
{
   int sz = 0, offset = 0;
   sz = sizeof(players);  memcpy(players,  b+offset, sz); offset += sz;
   sz = sizeof(Ei);       memcpy(Ei,       b+offset, sz); offset += sz;
   sz = sizeof(Efi);      memcpy(Efi,      b+offset, sz); offset += sz;
   sz = sizeof(item);     memcpy(item,     b+offset, sz); offset += sz;
   sz = sizeof(itemf);    memcpy(itemf,    b+offset, sz); offset += sz;
   sz = sizeof(lifts);    memcpy(lifts,    b+offset, sz); offset += sz;
   sz = sizeof(l);        memcpy(l,        b+offset, sz); offset += sz;
   sz = sizeof(pbullet);  memcpy(pbullet,  b+offset, sz); offset += sz;
   sz = sizeof(ebullets); memcpy(ebullets, b+offset, sz); offset += sz;
   sz = sizeof(pm_event); memcpy(pm_event, b+offset, sz); offset += sz;
}
</code></pre>






<br><a name="The difference bewtween a 'state' and a 'dif'"></a>
<mh7>The difference bewtween a 'state' and a 'dif'</mh7>
<mh3>
'state' refers the the entire game state, memcpy'd to a char array of size STATE_SIZE

'dif' refers to when two states are subtracted, resulting in the difference between the two

Dif's are much more easily compressed, as they only have non-zero entries where the two states differ.

Difs are compressed with zlib, optionally broken into packet sized pieces, and sent from server to clients.

When a client has all the pieces of a dif, and the state on which it is based, it applies the dif to the base state, recreating the server state.

Without the dif scheme, the entire game state typically compresses to 5000-7000 bytes.

A dif, by comparison, typically compresses to 500-1300 bytes, and can be sent in 1 or 2 packets.
</mh3>


<br><a name="How a client gets a new state from the server"></a>
<mh7>How a client gets a new state from the server</mh7>
<mh3>
A client receives 'stdf' packets from the server.  Each packet contains pieces of a compressed dif state.
These packets have up to 1000 bytes of data each and are put into 'client_state_buffer' at the appropriate offset.

When all the pieces have been received, 'client_state_buffer' is decompressed into 'client_state_dif'.
The source and destination frame of 'client_state_dif' are updated to mark it as valid.
</mh3>

<pre><code class="language-cpp">void client_process_stdf_packet(double timestamp)
{
   int p = active_local_player;
   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   int seq = PacketGet1ByteInt();
   int max_seq = PacketGet1ByteInt();
   int sb = PacketGet4ByteInt();
   int sz = PacketGet4ByteInt();

   memcpy(client_state_buffer + sb, packetbuffer+22, sz);  // put the piece of data in the buffer
   client_state_buffer_pieces[seq] = dst;                  // mark it with destination frame_num

   int complete = 1;                                          // did we just get the last packet? (yes by default)
   for (int i=0; i< max_seq; i++)
      if (client_state_buffer_pieces[i] != dst) complete = 0; // no, if any piece not at latest frame_num

   if (complete)
   {
      // decompress client_state_buffer to dif
      uLongf destLen = sizeof(client_state_dif);
      uncompress((Bytef*)client_state_dif, (uLongf*)&destLen, (Bytef*)client_state_buffer, sizeof(client_state_buffer));
      if (destLen == STATE_SIZE)
      {
         sprintf(msg, "rx dif complete [%d to %d] sync[%d] dsync[%3.1fms] - decompressed\n", src, dst, players1[p].client_sync, players1[p].dsync*1000);
         client_state_dif_src = src; // mark dif data with new src and dst
         client_state_dif_dst = dst;
      }
      else
      {
         sprintf(msg, "rx dif complete [%d to %d] sync[%d] - bad decompress\n", src, dst, players1[p].client_sync);
         client_state_dif_src = -1; // mark dif data as bad
         client_state_dif_dst = -1;
      }
   }
}</code></pre>

<br><a name="How a client applies the new state"></a>
<mh7>How a client applies the new state</mh7>

<mh3>
Every frame the client checks its locally stored dif.

First it checks if the dif is valid:
</mh3>
<pre><code class="language-cpp">void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
</code></pre>
<mh3>
Then it checks if the dif source is greater than 100 frames in the future:

(this is to prevent stray late difs from a previous level affecting a newly started level)
</mh3>
<pre><code class="language-cpp">      if (client_state_dif_src - frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d frame_num:%d\n", client_state_dif_src, frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
</code></pre>
<mh3>
Then it checks if the dif's destination frame number is newer than the last applied dif:
</mh3>
<pre><code class="language-cpp">         if ((client_state_dif_dst <= client_state_base_frame_num)) // dif destination is not newer than last applied dif
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
</code></pre>
<mh3>
If we got this far, we know:

- the dif is valid
- the dif source is not greater than 100 frames in the future
- the dif destination is newer that the last applied dif 


At this point we will try to apply the dif.

First we need to see if we have a locally stored base that matches the dif source.

If we do not have the base that the dif was created from we cannot apply it.

If the server sent a dif with source frame 0, we need to set our local base state to zero also.

This happens for the initial state, or when for some rare occurance, the client does not have the same base as the server.

If the base is reset, the compressed dif sent over the network will be considerably larger, typically requiring 5-7 packets.
</mh3>
<pre><code class="language-cpp">            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }
</code></pre>

<mh3>
Now we check to see if our stored base matches the dif source.

If not, we will resend a 'stak' packet back to the server, indicating the last state we have acknowledged and have stored as a base.
</mh3>

<pre><code class="language-cpp">            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
</code></pre>

<mh3>
If we get this far, we either have a matching base, or one set to all zeros. Either way, we can proceed.

First we determine if the dif destination matches the current frame:
</mh3>
<pre><code class="language-cpp">            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = frame_num - client_state_dif_dst; // dst compared to current frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
</code></pre>

<mh3>
If the dif destination is not in the future, we can proceed.

First we apply the dif to the base state.
</mh3>
<pre><code class="language-cpp">                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

.....

void apply_state_dif(char *a, char *c, int size)
{
   for (int i=0; i< size; i++) a[i] -= c[i];
}</code></pre>

<mh3>
Next, we use that modifed state to overwrite the game variables and update the current frame_num.

This state is our new base state, so we update the frame_num for that too.
</mh3>
<pre><code class="language-cpp">         state_to_game_vars(client_state_base);                           // copy modified base state to game_vars
         frame_num = client_state_base_frame_num = client_state_dif_dst;  // update frame_num and client base frame_num
</code></pre>

<mh3>
Then, if we applied a state from the past, we replay to the current frame and re-apply any locally stored moves.
</mh3>
<pre><code class="language-cpp">         if (ff) loop_frame(ff); // if we rewound time, play it back
</code></pre>


<mh3>
Then we send a 'stak' packet to the server to acknowledge our new saved base state.
</mh3>
<pre><code class="language-cpp">                  client_send_stak();
                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);

...

void client_send_stak(void)
{
   int p = active_local_player;
   Packet("stak");
   PacketPut1ByteInt(p);
   PacketPut4ByteInt(client_state_base_frame_num);
   PacketPut4ByteInt(frame_num);
   PacketPut4ByteInt(players1[p].frames_skipped);
   PacketPutDouble(players1[p].client_chase_fps);
   PacketPutDouble(players1[p].dsync);
   ClientSend(packetbuffer, packetsize);
}
</code></pre>

<mh3>
Here is the entire code:
</mh3>
<pre><code class="language-cpp">void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d frame_num:%d\n", client_state_dif_src, frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // dif destination is not newer than last applied dif
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }
            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = frame_num - client_state_dif_dst; // dst compared to current frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));

                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update frame_num and client base frame_num
                  frame_num = client_state_base_frame_num = client_state_dif_dst;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = frame_num - client_state_dif_src;
                  players1[p].client_last_dif_applied = frame_num;
                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}</code></pre>




















               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2022, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
