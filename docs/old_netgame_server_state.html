<!doctype html>
<title>Netgame - Server State</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="history.html" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="shots.html" target="_top">Shots</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    

<div style="text-align: center;"><a href="netgame_main.html"                     target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state_and_dif.html"            target="_top">Netgame - State and Dif</a></div>    
<div style="text-align: center;"><a href="netgame_state_history.html"            target="_top">Netgame - State History</a></div>    
<div style="text-align: center;"><a href="netgame_client_state.html"             target="_top">Netgame - Client State</a></div>    
<div style="text-align: center;"><a href="netgame_client_control_change.html"    target="_top">Netgame - Client Control Change</a></div>    
<div style="text-align: center;"><a href="netgame_client_timing_sync.html"       target="_top">Netgame - Client Timing Sync</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html"                  target="_top">Netgame - Packets</a></div>    
<div style="text-align: center;"><a href="netgame_packet_buffer.html"            target="_top">Netgame - Packet Buffer</a></div>    
<div style="text-align: center;"><a href="netgame_server_setup.html"             target="_top">Netgame - Server Setup</a></div>    
<div style="text-align: center;"><a href="netgame_join.html"                     target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_ping.html"                     target="_top">Netgame - Ping</a></div>    
<div style="text-align: center;"><a href="netgame_config.html"                   target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_control_and_monitoring.html"   target="_top">Netgame - Control and Monitoring</a></div>    

</mdw_lhs_nav>

        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>

<mh3><hr></mh3>
<mh8>Netgame - Server State</mh8>
<mh3><hr><mdw_file_toc> <a href="old_netgame_server_state.html#Overview" target="_top">Overview</a>
 <a href="old_netgame_server_state.html#Server checks if it is time to make a new state" target="_top">Server checks if it is time to make a new state</a>
 <a href="old_netgame_server_state.html#Server rewinds and replays" target="_top">Server rewinds and replays</a>
 <a href="old_netgame_server_state.html#Server creates new state" target="_top">Server creates new state</a>
 <a href="old_netgame_server_state.html#Server sends dif to each client" target="_top">Server sends dif to each client</a>
 <a href="old_netgame_server_state.html#Server receives acknowledge packet 'stak' from client" target="_top">Server receives acknowledge packet 'stak' from client</a>
</mdw_file_toc><hr></mh3>

<a name="Overview"></a>
<mh7>Overview</mh7>


<mh3>
Every frame the server sends the entire game state to clients in the form of a compressed dif. (See <a href="netgame_state_and_dif.html" target="_top">states and difs</a>).

Before creating a new state, the server rewinds to the last saved state and replays to the current frame.
This is to apply late client input that was not applied when received, because it was late.

Next the server creates a new base state, overwriting its old one.

Then the server sends a dif to each client, based on the last acknowledged state for that client.

</mh3>    
    

<a name="Server rewinds"></a>
<mh7>Server checks if it is time to make a new state</mh7>

<mh3>
Every frame the server checks if the current frame is equal or greater than the last state it has saved plus 'server_state_freq'
</mh3>    

<pre><code class="language-cpp">void mwNetgame::server_rewind(void)
{
   int s1 = players1[0].server_state_freq;
   if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1)    // is it time to create a new state?
</code></pre>


<a name="Server rewinds and replays"></a>
<mh7>Server rewinds and replays</mh7>
<mh3>
If it is time to make a new state, first the server rewinds and replays to apply late client input.

Rewinding is achieved by simply loading the previous state.
</mh3>    

<pre><code class="language-cpp">      int ff = mLoop.frame_num - srv_client_state_frame_num[0][1];  // almost always equals s1, unless s1 has changed
      state_to_game_vars(srv_client_state[0][1]);   // apply rewind state
      mLoop.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num
</code></pre>


<mh3>
Then it replays to the current frame to apply any late input from clients that was missed the first time around.
</mh3>    

<pre><code class="language-cpp">      mLoop.loop_frame(ff);
</code></pre>

<mh3>
Then it sets the flag 'players1[0].server_send_dif'.
</mh3>    

<pre><code class="language-cpp">      players1[0].server_send_dif = 1;
</code></pre>

<mh3>
This is the entire function:
</mh3>    

<pre><code class="language-cpp">void mwNetgame::server_rewind(void)
{
   char msg[1024];
   int s1 = mPlayer.loc[0].server_state_freq;

   if (mLoop.frame_num >= srv_client_state_frame_num[0][1] + s1)    // is it time to create a new state?
   {
      int ff = mLoop.frame_num - srv_client_state_frame_num[0][1];  // almost always equals s1, unless s1 has changed

      // rewind and fast forward from last state to apply late client input

      if (mLog.LOG_NET_stdf)
      {
         sprintf(msg, "stdf rewind to:%d\n", srv_client_state_frame_num[0][1]);
         //printf(msg);
         mLog.add_log_entry2(27, 0, msg);
      }

      double t0 = al_get_time();

      state_to_game_vars(srv_client_state[0][1]);   // apply rewind state
      mLoop.frame_num = srv_client_state_frame_num[0][1]; // set rewind frame num

      mLoop.loop_frame(ff);

      if (mLog.LOG_TMR_rwnd) mLog.add_log_TMR(al_get_time() - t0, "rwnd", 0);

      mPlayer.loc[0].server_send_dif = 1;
   }
}
</code></pre>


<mh3>
Then game loop continues.

The server does not make the new state until after input for this frame has been processed and move_frame() has been called.
</mh3>    


<pre><code class="language-cpp">            mPlayer.proc_player_input();
            mGameMoves.proc();
            move_frame();
            mNetgame.server_create_new_state();
            mDrawSequence.draw(0);
</code></pre>

<a name="Server creates new state"></a>
<mh7>Server creates new state</mh7>

<mh3>
If the flag is set, the server creates a new state from the current frame, but sets its frame number to the next frame.

This state is created at the end of the current frame, so it is the starting point for the next frame.

Whenever a state is loaded, it is loaded at the start of a frame, before any processing of that frame has been done yet.
</mh3>    

<pre><code class="language-cpp">void mwNetgame::server_create_new_state(void)
{
   if (mPlayer.loc[0].server_send_dif)
   {
      mPlayer.loc[0].server_send_dif = 0;

      // save state as a base for next rewind
      game_vars_to_state(srv_client_state[0][1]);
      srv_client_state_frame_num[0][1] = mLoop.frame_num+1;
</code></pre>

<mh3>
Then the server calls 'server_send_dif()' for each client:
</mh3>    
<pre><code class="language-cpp">      for (int p=1; p < NUM_PLAYERS; p++)
         if ((mPlayer.syn[p].control_method == 2) || (mPlayer.syn[p].control_method == 8)) server_send_dif(p);
   }
}
</code></pre>


<a name="Server sends dif to each client"></a>
<mh7>Server sends dif to each client</mh7>


<mh3>
The first thing the server does is check the last acknowledged frame we have for that specific client.

This is the state that we will base the dif on, and the state the client will need to apply the dif when received.

If the last acknowledged frame is zero, it means we do not have a base in common with the client and will have to reset the base to zero.
</mh3>    



<pre><code class="language-cpp">void mwNetgame::server_send_dif(int p) // send dif to a specific client
{
   // if last_ack_state_frame == 0 set base to all zeros
   if (srv_client_state_frame_num[p][0] == 0) memset(srv_client_state[p][0], 0, STATE_SIZE);
</code></pre>


<mh3>
Next we declare two temporary char arrays for building and compressing the dif.
</mh3>


<pre><code class="language-cpp">   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];
</code></pre>


<mh3>
Then we overwrite the server's client slot 1 with the current saved state and frame_num.
</mh3>


<pre><code class="language-cpp">   game_vars_to_state(srv_client_state[p][1]);
   srv_client_state_frame_num[p][1] = mLoop.frame_num;
</code></pre>


<mh3>
Next we make a dif from the client's old state (slot 0) and the new state (slot 1).
</mh3>

<pre><code class="language-cpp">   get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);
</code></pre>

<mh3>
Then we compress 'dif' and put the result in 'cmp'.
</mh3>

<pre><code class="language-cpp">   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
   int cmp_size = destLen;
</code></pre>


<mh3>
Next we determine how many packets we need, based on the size of 'cmp'.
</mh3>

<pre><code class="language-cpp">   int num_packets = (cmp_size / 1000) + 1;
   mPlayer.loc[p].cmp_dif_size = cmp_size;
   mPlayer.loc[p].num_dif_packets = num_packets;
</code></pre>


<mh3>
Lastly we break it into pieces and send it.
</mh3>

<pre><code class="language-cpp">   int start_byte = 0;
   for (int packet_num=0; packet_num < num_packets; packet_num++)
   {
      int packet_data_size = 1000; // default size
      if (start_byte + packet_data_size > cmp_size) packet_data_size = cmp_size - start_byte; // last piece is smaller
      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mLoop.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mLoop.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      PacketPut1ByteInt(mPlayer.loc[p].late_cdats_last_sec);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, mPlayer.loc[p].who, p);
      start_byte+=1000;
   }
</code></pre>


<mh3>
This is the entire function:
</mh3>    

<pre><code class="language-cpp">void mwNetgame::server_send_dif(int p) // send dif to a specific client
{
   char msg[1024];
   // if last_ack_state_frame == 0 set base to all zeros
   if (srv_client_state_frame_num[p][0] == 0) memset(srv_client_state[p][0], 0, STATE_SIZE);

   char dif[STATE_SIZE];
   char cmp[STATE_SIZE];

   // put current state in client's state slot 1
   game_vars_to_state(srv_client_state[p][1]);

   // put current mLoop.frame_num
   srv_client_state_frame_num[p][1] = mLoop.frame_num;

   // make a new dif from base and current
   get_state_dif(srv_client_state[p][0], srv_client_state[p][1], dif, STATE_SIZE);

   // compress dif to cmp
   uLongf destLen= sizeof(cmp);
   compress2((Bytef*)cmp, (uLongf*)&destLen, (Bytef*)dif, sizeof(dif), zlib_cmp);
   int cmp_size = destLen;

   // break compressed dif into smaller pieces
   int num_packets = (cmp_size / 1000) + 1;

   mPlayer.loc[p].cmp_dif_size = cmp_size;
   mPlayer.loc[p].num_dif_packets = num_packets;

   if (mLog.LOG_NET_stdf)
   {
      float cr = (float)cmp_size*100 / (float)STATE_SIZE; // compression ratio
      sprintf(msg, "tx stdf p:%d [src:%d dst:%d] cmp:%d ratio:%3.2f [%d packets needed]\n",
                            p, srv_client_state_frame_num[p][0], srv_client_state_frame_num[p][1], cmp_size, cr, num_packets);
      mLog.add_log_entry2(27, p, msg);
   }
   int start_byte = 0;
   for (int packet_num=0; packet_num < num_packets; packet_num++)
   {
      int packet_data_size = 1000; // default size
      if (start_byte + packet_data_size > cmp_size) packet_data_size = cmp_size - start_byte; // last piece is smaller

      if (mLog.LOG_NET_stdf_all_packets)
      {
         sprintf(msg, "tx stdf piece [%d of %d] [%d to %d] st:%4d sz:%4d\n",
                       packet_num+1, num_packets, srv_client_state_frame_num[p][0], srv_client_state_frame_num[p][1], start_byte, packet_data_size);
         mLog.add_log_entry2(28, p, msg);
      }

      Packet("stdf");
      PacketPut4ByteInt(srv_client_state_frame_num[p][0]); // src mLoop.frame_num
      PacketPut4ByteInt(srv_client_state_frame_num[p][1]); // dst mLoop.frame_num
      PacketPut1ByteInt(packet_num);
      PacketPut1ByteInt(num_packets);
      PacketPut4ByteInt(start_byte);
      PacketPut4ByteInt(packet_data_size);
      PacketPut1ByteInt(mPlayer.loc[p].late_cdats_last_sec);
      memcpy(packetbuffer+packetsize, cmp+start_byte, packet_data_size);
      packetsize += packet_data_size;
      ServerSendTo(packetbuffer, packetsize, mPlayer.loc[p].who, p);
      start_byte+=1000;
   }
}</code></pre>




<a name="Server receives acknowledge packet 'stak' from client"></a>
<mh7>Server receives acknowledge packet 'stak' from client</mh7>

<mh3>
When the server receives an acknowledge packet 'stak' from client, the server checks if it has a copy of the new base the client just acknowledged.
</mh3>

<pre><code class="language-cpp">void mwNetgame::server_proc_stak_packet(double timestamp)
{
   char msg[1024];
   int p                                    = PacketGet1ByteInt();
   int ack_frame_num                        = PacketGet4ByteInt();
   int client_frame_num                     = PacketGet4ByteInt();
   mPlayer.loc[p].client_chase_fps             = PacketGetDouble();
   mPlayer.loc[p].dsync                        = PacketGetDouble();

   // calculate stak_sync
   int stak_sync = mLoop.frame_num - srv_client_state_frame_num[0][1];

   // calculate stak_dsync
   mPlayer.loc[p].stak_dsync = ( (double) stak_sync * 0.025) + mTimeStamp.timestamp_frame_start - timestamp;

   server_lock_client(p);

   // this is used to see if client is still alive
   mPlayer.loc[p].server_last_stak_rx_frame_num = mLoop.frame_num;

   if (ack_frame_num == srv_client_state_frame_num[p][1]) // check to make sure we have a copy of acknowledged state
   {
</code></pre>



<mh3>
If it does, the server moves the newly acknowledged state from slot 1 to slot 0. This is the new base state for this client.
</mh3>

<pre><code class="language-cpp">      // acknowledged state is new base state
      memcpy(srv_client_state[p][0], srv_client_state[p][1], STATE_SIZE);  // copy 1 to 0
      srv_client_state_frame_num[p][0] = srv_client_state_frame_num[p][1];
</code></pre>


<mh3>
If the server does not have a copy of the client's acknowledged state, it is forced to reset the base to zero's.
</mh3>


<pre><code class="language-cpp">   else // we don't have a copy of acknowledged state !!!
   {
      memset(srv_client_state[p][0], 0, STATE_SIZE); // reset base to all zero
      srv_client_state_frame_num[p][0] = 0;
      mPlayer.loc[p].client_base_resets++;
   }
</code></pre>


               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2024, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
