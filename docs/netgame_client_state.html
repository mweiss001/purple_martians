<!doctype html>
<title>Netgame - Client State</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    

<div style="text-align: center;"><a href="netgame_main.html"                  target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state_and_dif.html"         target="_top">Netgame - State and Dif</a></div>    
<div style="text-align: center;"><a href="netgame_server_state.html"          target="_top">Netgame - Server State</a></div>    
<div style="text-align: center;"><a href="netgame_client_state.html"          target="_top">Netgame - Client State</a></div>    
<div style="text-align: center;"><a href="netgame_client_control_change.html" target="_top">Netgame - Client Control Change</a></div>    
<div style="text-align: center;"><a href="netgame_client_timing_sync.html"    target="_top">Netgame - Client Timing Sync</a></div>    
<div style="text-align: center;"><a href="netgame_fast_packet_loop.html"      target="_top">Netgame - Fast Packet Loop</a></div>    
<div style="text-align: center;"><a href="netgame_ping.html"                  target="_top">Netgame - Ping</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html"               target="_top">Netgame - Packets</a></div>    
<div style="text-align: center;"><a href="netgame_config.html"                target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_join.html"                  target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html"                target="_top">Netgame - Status</a></div>    

</mdw_lhs_nav>

        </nav>




        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>

<mh3><hr></mh3>
<mh8>Netgame - Client State</mh8>
<mh3><hr><mdw_file_toc> <a href="netgame_client_state.html#Overview" target="_top">Overview</a>
 <a href="netgame_client_state.html#How a client gets a new state from the server" target="_top">How a client gets a new state from the server</a>
 <a href="netgame_client_state.html#How a client applies the new state" target="_top">How a client applies the new state</a>
 <a href="netgame_client_state.html#Check for dif based on state zero" target="_top">Check for dif based on state zero</a>
 <a href="netgame_client_state.html#Check for base match" target="_top">Check for base match</a>
 <a href="netgame_client_state.html#Check for future dif destination" target="_top">Check for future dif destination</a>
 <a href="netgame_client_state.html#Applying the dif to the base state" target="_top">Applying the dif to the base state</a>
 <a href="netgame_client_state.html#Overwriting the client's game state variables" target="_top">Overwriting the client's game state variables</a>
 <a href="netgame_client_state.html#Updating frame numbers" target="_top">Updating frame numbers</a>
 <a href="netgame_client_state.html#Fast forward replay" target="_top">Fast forward replay</a>
 <a href="netgame_client_state.html#Send acknowledge packet to server" target="_top">Send acknowledge packet to server</a>
 <a href="netgame_client_state.html#The entire function 'client_apply_dif'" target="_top">The entire function 'client_apply_dif'</a>
</mdw_file_toc><hr></mh3>

<a name="Overview"></a>
<mh7>Overview</mh7>

<mh3>
The server consolidates input from all clients and syncs the official server <a href="netgame_state_and_dif.html" target="_top">state</a> back to clients.

Clients run independantly for a few frames in between receiving states from the server.

During that time, the client's control changes are applied locally and sent to the server.

When a client receives a new state from the server, it overwrites its local game state.
</mh3>    

<br><a name="How a client gets a new state from the server"></a>
<mh7>How a client gets a new state from the server</mh7>
<mh3>
A client receives 'stdf' packets from the server.  Each packet contains pieces of a compressed dif state.
These packets have up to 1000 bytes of data each and are put into 'client_state_buffer' at the appropriate offset.

When all the pieces have been received, 'client_state_buffer' is decompressed into 'client_state_dif'.
The source and destination frame of 'client_state_dif' are updated to mark it as valid.
</mh3>

<pre><code class="language-cpp">void client_process_stdf_packet(double timestamp)
{
   int p = active_local_player;
   int src = PacketGet4ByteInt();
   int dst = PacketGet4ByteInt();
   int seq = PacketGet1ByteInt();
   int max_seq = PacketGet1ByteInt();
   int sb = PacketGet4ByteInt();
   int sz = PacketGet4ByteInt();

   memcpy(client_state_buffer + sb, packetbuffer+22, sz);  // put the piece of data in the buffer
   client_state_buffer_pieces[seq] = dst;                  // mark it with destination frame_num

   int complete = 1;                                          // did we just get the last packet? (yes by default)
   for (int i=0; i< max_seq; i++)
      if (client_state_buffer_pieces[i] != dst) complete = 0; // no, if any piece not at latest frame_num

   if (complete)
   {
      // decompress client_state_buffer to dif
      uLongf destLen = sizeof(client_state_dif);
      uncompress((Bytef*)client_state_dif, (uLongf*)&destLen, (Bytef*)client_state_buffer, sizeof(client_state_buffer));
      if (destLen == STATE_SIZE)
      {
         sprintf(msg, "rx dif complete [%d to %d] sync[%d] dsync[%3.1fms] - decompressed\n", src, dst, players1[p].client_sync, players1[p].dsync*1000);
         client_state_dif_src = src; // mark dif data with new src and dst
         client_state_dif_dst = dst;
      }
      else
      {
         sprintf(msg, "rx dif complete [%d to %d] sync[%d] - bad decompress\n", src, dst, players1[p].client_sync);
         client_state_dif_src = -1; // mark dif data as bad
         client_state_dif_dst = -1;
      }
   }
}</code></pre>

<br><a name="How a client applies the new state"></a>
<mh7>How a client applies the new state</mh7>

<mh3>
Every frame the client checks its locally stored dif.

First it checks if the dif is valid:
</mh3>
<pre><code class="language-cpp">void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
</code></pre>
<mh3>
Then it checks if the dif source is greater than 100 frames in the future (this is to prevent stray late difs from a previous level affecting a newly started level)
</mh3>
<pre><code class="language-cpp">      if (client_state_dif_src - frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d frame_num:%d\n", client_state_dif_src, frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
</code></pre>
<mh3>
Then it checks if the dif's destination frame number is newer than the last applied dif:
</mh3>
<pre><code class="language-cpp">         if ((client_state_dif_dst <= client_state_base_frame_num)) // dif destination is not newer than last applied dif
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
</code></pre>
<mh3>
If we got this far, we know:

- the dif is valid
- the dif source is not greater than 100 frames in the future
- the dif destination is newer that the last applied dif 

At this point we will try to apply the dif.
</mh3>

<br><a name="Check for dif based on state zero"></a>
<mh7>Check for dif based on state zero</mh7>

<mh3>
If the server sent a dif with base zero, the client resets its base to zero also.
This happens for the initial state, or rarely when the client does not have the same base as the server.

If the base is zero, the compressed dif sent over the network will be considerably larger, typically requiring 5-7 packets. (See <a href="netgame_state_and_dif.html#State compression methods"                    target="_top">State compression methods</a>)
</mh3>
<pre><code class="language-cpp">            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }
</code></pre>


<br><a name="Check for base match"></a>
<mh7>Check for base match</mh7>

<mh3>
Next, the dif's base state is compared to the client's stored base state. (the dif cannot be applied if we do not have the base it was created from)

If the bases do not match, the client resends a <a href="netgame_client_state.html#Send acknowledge packet to server"             target="_top">'stak'</a> packet to the server, indicating the last state we have acknowledged and have stored as a base.
</mh3>

<pre><code class="language-cpp">            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
</code></pre>

<mh3>
If we got this far, the bases match and we can proceed.
</mh3>



<br><a name="Check for future dif destination"></a>
<mh7>Check for future dif destination</mh7>


<mh3>
If the destination frame of the dif is in the future, we will not apply it yet. (this would have the effect of jumping forward in time)
</mh3>
<pre><code class="language-cpp">            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = frame_num - client_state_dif_dst; // dst compared to current frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
</code></pre>


<br><a name="Applying the dif to the base state"></a>
<mh7>Applying the dif to the base state</mh7>

<mh3>
If the dif destination is not in the future, we can proceed.

First we apply the dif to the base state.
</mh3>
<pre><code class="language-cpp">                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

.....

void apply_state_dif(char *a, char *c, int size)
{
   for (int i=0; i< size; i++) a[i] -= c[i];
}</code></pre>



<br><a name="Overwriting the client's game state variables"></a>
<mh7>Overwriting the client's game state variables</mh7>


<mh3>
Next, we use the modifed base state to overwrite the game variables.
</mh3>
<pre><code class="language-cpp">         state_to_game_vars(client_state_base);                           // copy modified base state to game_vars
</code></pre>

<br><a name="Updating frame numbers"></a>
<mh7>Updating frame numbers</mh7>



<mh3>
Then we update the client's frame number to the frame number of the destination.

This state is our new base state, so we update the frame number for that too.
</mh3>
<pre><code class="language-cpp">         frame_num = client_state_base_frame_num = client_state_dif_dst;  // update frame_num and client base frame_num
</code></pre>


<br><a name="Fast forward replay"></a>
<mh7>Fast forward replay</mh7>

<mh3>
Then, if we applied a state from the past, we replay to the current frame and re-apply any locally stored moves.
</mh3>
<pre><code class="language-cpp">         if (ff) loop_frame(ff); // if we rewound time, play it back
</code></pre>

<br><a name="Send acknowledge packet to server"></a>
<mh7>Send acknowledge packet to server</mh7>

<mh3>
Then we send a 'stak' packet to the server to acknowledge our new saved base state.
</mh3>
<pre><code class="language-cpp">                  client_send_stak();
                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);

...

void client_send_stak(void)
{
   int p = active_local_player;
   Packet("stak");
   PacketPut1ByteInt(p);
   PacketPut4ByteInt(client_state_base_frame_num);
   PacketPut4ByteInt(frame_num);
   PacketPut4ByteInt(players1[p].frames_skipped);
   PacketPutDouble(players1[p].client_chase_fps);
   PacketPutDouble(players1[p].dsync);
   ClientSend(packetbuffer, packetsize);
}
</code></pre>


<a name="The entire function 'client_apply_dif()'"></a>
<mh7>The entire function 'client_apply_dif'</mh7>

<pre><code class="language-cpp">void client_apply_dif(void)
{
   int p = active_local_player;
   if ((client_state_dif_src == -1) || (client_state_dif_dst == -1)) // check if valid dif
   {
      sprintf(msg, "dif is not valid - src:%d dst:%d\n", client_state_dif_src, client_state_dif_dst);
      if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
   }
   else
   {
      if (client_state_dif_src - frame_num > 100)
      {
         sprintf(msg, "dif_src is > 100 frames in the future - src:%d frame_num:%d\n", client_state_dif_src, frame_num);
         if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
      }
      else
      {
         if ((client_state_dif_dst <= client_state_base_frame_num)) // dif destination is not newer than last applied dif
         {
            sprintf(msg, "dif [%d to %d] not applied - not newer than current [%d]\n", client_state_dif_src, client_state_dif_dst, client_state_base_frame_num);
            if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
         }
         else
         {
            if (client_state_dif_src == 0) // if server has sent dif from src == 0, reset client base to 0
            {
               memset(client_state_base, 0, STATE_SIZE);
               client_state_base_frame_num = 0;
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, "Resetting client base state to zero\n");
               players1[p].client_base_resets++;
            }
            if (client_state_base_frame_num != client_state_dif_src) // stored base state does NOT match dif source
            {
               sprintf(msg, "dif cannot be applied (wrong client base) %d %d\n", client_state_base_frame_num, client_state_dif_src);
               if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               client_send_stak(); // resend ack to server with correct acknowledged base state
            }
            else // we have a matching base to apply dif
            {
               int ff = players1[p].client_rewind = frame_num - client_state_dif_dst; // dst compared to current frame_num
               char tmsg[64];
               if (ff == 0) sprintf(tmsg, "exact frame match [%d]\n", frame_num);
               if (ff > 0)  sprintf(tmsg, "rewind [%d] frames\n", ff);
               if (ff < 0)  sprintf(tmsg, "early [%d] frames\n", -ff);
               if (frame_num == 0) sprintf(tmsg, "initial state\n");
               if ((ff < 0) && (frame_num != 0))
               {
                  sprintf(msg, "dif [%d to %d] not applied yet - [%d] early\n", client_state_dif_src, client_state_dif_dst, -ff);
                  if (LOG_NET_dif_not_applied) add_log_entry2(31, p, msg);
               }
               else
               {
                  // make a copy of level array l[][]
                  int old_l[100][100];
                  memcpy(old_l, l, sizeof(l));

                  // apply dif to base state
                  apply_state_dif(client_state_base, client_state_dif, STATE_SIZE);

                  // copy modified base state to game_vars
                  state_to_game_vars(client_state_base);

                  // compare old_l to l and redraw changed tiles
                  al_set_target_bitmap(level_background);
                  for (int x=0; x<100; x++)
                     for (int y=0; y<100; y++)
                        if (l[x][y] != old_l[x][y])
                        {
                           // printf("dif at x:%d y:%d\n", x, y);
                           al_draw_filled_rectangle(x*20, y*20, x*20+20, y*20+20, palette_color[0]);
                           al_draw_bitmap(btile[l[x][y] & 1023], x*20, y*20, 0);
                        }

                  // fix control methods
                  players[0].control_method = 2; // on client, server is mode 2
                  if (players[p].control_method == 2) players[p].control_method = 4;
                  if (players[p].control_method == 8) new_program_state = 1; // server quit

                  // update frame_num and client base frame_num
                  frame_num = client_state_base_frame_num = client_state_dif_dst;

                  if (ff) loop_frame(ff); // if we rewound time, play it back

                  client_send_stak();

                  players1[p].client_move_lag = frame_num - client_state_dif_src;
                  players1[p].client_last_dif_applied = frame_num;
                  sprintf(msg, "dif [%d to %d] applied - %s", client_state_dif_src, client_state_dif_dst, tmsg);
                  if (LOG_NET_dif_applied) add_log_entry2(30, p, msg);
               }
            }
         }
      }
   }
}</code></pre>




















               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2023, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
