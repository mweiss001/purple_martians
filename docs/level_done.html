<!doctype html>
<title>Level Done</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div></mdw_lhs_nav>
            
        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>
<mh3><hr></mh3>
<mh8>Level Done</mh8>
<mh3><hr><mdw_file_toc> <a href="level_done.html#Overview" target="_top">Overview</a>
 <a href="level_done.html#High Level Description" target="_top">High Level Description</a>
 <a href="level_done.html#How The Process Is Initiated" target="_top">How The Process Is Initiated</a>
 <a href="level_done.html#Mode 6" target="_top">Mode 6</a>
 <a href="level_done.html#Mode 5" target="_top">Mode 5</a>
</mdw_file_toc><hr></mh3>




<br><a name="Overview"></a>
<mh7>Overview</mh7>
<mh3>    
Who would have thought something as simple as ending the level and starting the next one could end up so complicated?

It didn't start out that way, but with the addition of:
- netgame and the game moves array
- showing end of level stats
- waiting for all netgame players to acknowledge (or timeout)....

It got rather complex.

Hopefully not more complex than it needs to be....

</mh3>
<br><a name="High Level Description"></a>
<mh7>High Level Description</mh7>
<mh3>    
When any player touches an exit or warp, the level ends.

- Three game moves are entered in the game moves array ("Level Done 1", "Level Done 2", and "Next Level")

- These are entered with frame numbers in the future, so they will not take effect until that frame.

- "Level Done 1" is used only as a delay.

- "Level Done 2" is also a delay, but will also accept player acknowledgement if any control is pressed.

- "Next Level" triggers the next level being loaded and started.


These are the global variables used in the process:
</mh3>
<pre><code class="language-cpp">extern int level_done_mode;
extern int next_level;
</code></pre>
<mh3>
There are the different modes:
</mh3>
<pre><code class="language-cpp">0 = normal
8 = triggered (can only trigger from mode 0)
7 = all three game moves entered 'Level Done 1' 'Level Done 2' 'Next Level'
6 = game move 'Level Done 1' received and processed (wait mode 1 - time only)
5 = game move 'Level Done 2' received and processed (wait mode 2 - time or acknowledge)
0 = done and next level started
</code></pre>
<mh3>
These are the special game moves used: 
</mh3>
<pre><code class="language-cpp">type data1 data2 description
6    0     1     "Level Done 1"
6    0     2     "Level Done 2"
7    0     0     "Next Level"
8    p     0     "Player Acknowledge"
</code></pre>

<br><a name="How The Process Is Initiated"></a>
<mh7>How The Process Is Initiated</mh7>
<mh3>    
In all game modes (single player, netgame, client, server, rungame), any player can trigger level done.

This is done by setting the "level_done_mode" to 8.

This can only be done from mode 0, to prevent retriggering.
</mh3>
<pre><code class="language-cpp">void proc_exit_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = play_level + 1;
      players[p].paused = 5;
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
      level_done_mode = 8;
      next_level = item[i][8];
      players[p].paused = 5;
   }
}
</code></pre>

<mh3>    
However only single player and server game modes do anything with this.

In both cases "start_level_done(p)" is called.

There "level_done_mode" is set to 7 and three game moves are inserted with future frame numbers

</mh3>
<pre><code class="language-cpp">void proc_player_input(int ret)
{
   for (int p=0; p < NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 8) start_level_done(p);

void server_local_control(int p)
{
   if (level_done_mode == 8) start_level_done(p);


void start_level_done(int p)
{
   level_done_mode = 7;
   int fn = frame_num + control_lead_frames;
   add_game_move(fn,     6, 0, 1); // insert level done 1 into game move
   add_game_move(fn+100, 6, 0, 2); // insert level done 2 into game move
   add_game_move(fn+200, 7, 0, 0); // insert next level into game move
   players1[p].old_comp_move = players1[p].comp_move = 0; // reset both
}
</code></pre>

<mh3>    
Then nothing happens for a few frames until the game move "Level Done 1" is processed

In "proc_controllers()" "proc_game_move()" is called every frame to process special game moves.

</mh3>    
<pre><code class="language-cpp">int proc_controllers()
{
   proc_game_move();  // run once per frame to process system messages from game_move

void proc_game_move(void)
{
	case 6: // level done
	{
	   if (game_moves[x][3] == 1) level_done_mode = 6; // level done 1
</code></pre>


<br><a name="Mode 6"></a>
<mh7>Mode 6</mh7>
<mh3>    
Now we are in mode 6. Not much happens here. We are just waiting for the next game move "Level Done 2"

The screen overlay for the end of level statistics is shown is all level_done_modes except 0.
</mh3>    

<pre><code class="language-cpp">void draw_screen_overlay(void)
{
   if (level_done_mode) new_show_level_done();
</code></pre>

<mh3>    
In the main game loop, an entirely different loop is called for level_done_modes 1-6:

This does not process any of the moveable objects or redraw them. Everything is frozen.

But the game loop keeps running, which is very important for netgame and processing input.

</mh3>    
<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   proc_frame_delay();
   if (draw_frame)
   {
      get_new_screen_buffer(0, 0, 0);
      draw_screen_overlay();
      al_flip_display();
   }
}

void game_loop(int start_mode)
{
   game_exit = 0;
   proc_start_mode(start_mode);
   while (!game_exit)
   {
      proc_scale_factor_change();
      proc_sound();
      if (ima_server) server_control();
      if (ima_client) client_control();
      proc_controllers();
      if ((level_done_mode > 0) && (level_done_mode < 7)) proc_level_done_mode();
      else
      {
         move_ebullets();
         move_pbullets();
         move_lifts(0);
         move_players();
         move_enemies();
         move_items();
         proc_frame_delay();
         if (draw_frame)
         {
            get_new_background(0);
            draw_lifts();
            draw_items();
            draw_enemies();
            draw_ebullets();
            draw_pbullets();
            draw_players();
            get_new_screen_buffer(0, 0, 0);
            draw_screen_overlay();
            al_flip_display();
         }
      }
   }
   if (ima_server) server_exit();
   if (ima_client) client_exit();
   stop_sound();
   stamp();
}
</code></pre>
<mh3>    
Also the normal player inputs are disabled in single player and server mode
</mh3>    

<pre><code class="language-cpp">void proc_player_input(int ret)
{
   for (int p=0; p < NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if (level_done_mode == 8) start_level_done(p);
            if ((level_done_mode == 0) || (level_done_mode == 5)) // only allow player input in these modes
            {
               set_comp_move_from_player_key_check(p); // but don't set controls !!!
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(frame_num, 5, p, players1[p].comp_move);
               }
            }
         }

void server_local_control(int p)
{
   int fn = frame_num + control_lead_frames;               // add control_lead_frames to frame_num
   set_comp_move_from_player_key_check(p);
   if (level_done_mode == 8) start_level_done(p);
   if ((level_done_mode == 0) || (level_done_mode == 5))  // only allow player input in these modes
   {
      if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
      {
         players1[p].old_comp_move = players1[p].comp_move;
         add_game_move(fn, 5, p, players1[p].comp_move);
      }
   }
}

</code></pre>

<mh3>    
Nothing happens until "Level Done 2" is processed and level_done_mode is set to 5.
</mh3>    
<pre><code class="language-cpp">void proc_game_move(void)
{
   case 6: // level done
   {
      if (game_moves[x][3] == 2) level_done_mode = 5; // level done 2
</code></pre>

<mh3>    
The purpose of the unskippable mode 6 is twofold:

First to make a holdoff where keypresses from the game that just ended don't immediatley trigger the players acknowledge.

Second to have a minimum time that the end of level statistics show.

</mh3>    


<br><a name="Mode 5"></a>
<mh7>Mode 5</mh7>
<mh3>    
In mode 5 we are accepting input from players, but we are treating it differently.

Any input is considered an acknowledge and triggers a special game move entry.

In single player or server mode (the only modes that actually put anything in the game_moves array) the entry is intercepted and modified in level_done_mode 5.

</mh3>    

<pre><code class="language-cpp">void add_game_move(int frame, int type, int data1, int data2)
{
   if ((level_done_mode == 5) && (type == 5) && (data2))  // ack mode and not zero move
   {
      game_moves[game_move_entry_pos][0] = frame;
      game_moves[game_move_entry_pos][1] = 8;
      game_moves[game_move_entry_pos][2] = data1; // player num
      game_moves[game_move_entry_pos][3] = 0;
      game_move_entry_pos++;
      return; // to exit immediately
   }
</code></pre>





<mh3>    
To handle the acknowledge from a client, the client does not do anything different.

When a client control change occurs, it still sends the same 'cdat' packet to the server.

When the server processes it, it changes it to a special "Player Acknowledge" game move

</mh3>    
<pre><code class="language-cpp">void server_proc_cdat_packet(void)
{
   int p = PacketGet1ByteInt();
   int fn = PacketGet4ByteInt();
   int cm = PacketGet1ByteInt();
   if (level_done_mode == 5) add_game_move(fn, 8, p, 0); // add ack to game_move array
   else
   {
      add_game_move(fn, 5, p, cm); // add to game_move array
</code></pre>


<mh3>    
Also in level_done_mode 5, we check if all the players have acknowledged.

If they have, we enter a 'Next Level' game move a few frames in the future.

If this does not happen, the original 'Next Level' game move will eventually get processed.

</mh3>    


<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   if (level_done_mode == 5)
   {
      if (ima_server)
      {
         int aa = 1; // yes by default, set to no if any have not ack
         for (int p=0; p < NUM_PLAYERS; p++)
            if (players[p].active)
               if (!has_player_acknowledged(p)) aa = 0;
         if (aa)
         {
            int fn = frame_num + control_lead_frames;
            add_game_move(fn, 7, 0, 0); // insert next level into game move
         }
      }
      if ((players[0].control_method == 0) && (has_player_acknowledged(0)))    // single player
         add_game_move(frame_num, 7, 0, 0); // insert next level into game move
   }
}

int has_player_acknowledged(int p)
{
   for (int x=game_move_entry_pos; x>0; x--)  // look back for frame_num
      if ((game_moves[x][1] == 8) && (game_moves[x][2] == p)) return 1;
   return 0;
}
</code></pre>


<mh3>    
Then when the "Next Level" game move is processed:

- a bunch of cleanup and resetting of varous settings is done

- proc_start_mode(5) is called to load the new level and set up structures after loading a new level

- level_done_mode is set to 0
</mh3>    


<pre><code class="language-cpp">void proc_game_move(void)
{
   case 7: proc_next_level(); break;

void proc_next_level(void)
{
   if ((ima_client) || (ima_server))
   {
      for (int p=0; p < NUM_PLAYERS; p++)
         if (players[p].active) players1[p].quit_reason = 80;
   }

   stop_sound();
   int p = active_local_player;
   if (players[p].control_method == 1)
   {
      show_level_done(0);
      al_rest(1);
      game_exit = 1;// run game file play exits after level done
      return;
   }
   if ((ima_server) || (ima_client))
   {
      for (int p=0; p < NUM_PLAYERS; p++)
      {
         // free all the used clients, so they can be re-assigned on the next level
         if (players[p].control_method == 9) players[p].control_method = 0;
         // set all clients inactive on server and client, to force them to re-chase and lock on the new level
         if ((players[p].control_method == 2) || (players[p].control_method == 4)) players[p].active = 0;
      }
      if (ima_server) server_flush();
      if (ima_client) client_flush();
      al_rest(1);
   }
   blind_save_game_moves(1);
   save_log_file();
   play_level = next_level;
   proc_start_mode(5);
   level_done_mode = 0;
}
</code></pre>


               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2022, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
