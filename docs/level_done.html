<!doctype html>
<title>Level Done</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div></mdw_lhs_nav>
            
        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>
<mh3><hr></mh3>
<mh8>Level Done Procedure</mh8>
<mh3><hr><mdw_file_toc> <a href="level_done.html#Overview" target="_top">Overview</a>
 <a href="level_done.html#Variables" target="_top">Variables</a>
 <a href="level_done.html#Modes" target="_top">Modes</a>
 <a href="level_done.html#How The Procedure Is Initiated" target="_top">How The Procedure Is Initiated</a>
 <a href="level_done.html#How The Procedure Progresses" target="_top">How The Procedure Progresses</a>
 <a href="level_done.html#Mode 9 and 8 - Players Seek Exit" target="_top">Mode 9 and 8 - Players Seek Exit</a>
 <a href="level_done.html#Mode 7 - Players Shrink and Rotate into Exit" target="_top">Mode 7 - Players Shrink and Rotate into Exit</a>
 <a href="level_done.html#Mode 5 - Skippable Delay" target="_top">Mode 5 - Skippable Delay</a>
 <a href="level_done.html#Mode 2 - Delay to Load Next Level" target="_top">Mode 2 - Delay to Load Next Level</a>
 <a href="level_done.html#Mode 1 - Call to proc_start_mode(5)" target="_top">Mode 1 - Call to proc_start_mode(5)</a>
</mdw_file_toc><hr></mh3>



<br><a name="Overview"></a>
<mh7>Overview</mh7>
<mh3>    
A level is completed when any player touches an unlocked exit or a warp spiral.

The level is frozen and the end of level stats are shown.

Then after a timeout, or after all players acknowledge, the next level is loaded and started.

The server controls the process using the following variables, which are synced to the clients with the rest of the game data.
</mh3>
<br><a name="Variables"></a>
<mh7>Variables</mh7>
<mh3>
These are the variables used in the process:
</mh3>
<pre><code class="language-cpp">int players[0].level_done_mode
int players[0].level_done_timer
int players[p].level_done_ack
int players[p].level_done_x
int players[p].level_done_y
int players[p].level_done_player
</code></pre>
<mh3>'mode' is the current mode

'timer' controls the length of time before switching to the next mode

'ack' keeps track of which players have acknowledged

'x' and 'y' keep track of the exit position on the level

'player' keeps track of which player touched the exit
</mh3>
<br><a name="Modes"></a>
<mh7>Modes</mh7>

<mh3>
These are the different modes:
</mh3>
<pre><code class="language-cpp">level_done_mode = 9; // set up players seek xinc, yinc and direction
level_done_mode = 8; // all players move to the exit
level_done_mode = 7; // all players rotate and shirink into the exit
level_done_mode = 6; // not used, place holder for future features
level_done_mode = 5; // skippable 15s delay while level end stats show
level_done_mode = 4; // not used, place holder for future features
level_done_mode = 3; // not used, place holder for future features
level_done_mode = 2; // delay to load next level
level_done_mode = 1; // call proc_next_level() to load next level
level_done_mode = 0; // normal game play
</code></pre>


<br><a name="How The Procedure Is Initiated"></a>
<mh7>How The Procedure Is Initiated</mh7>
<mh3>    
The procedure is initiated by setting 'level_done_mode'.

It can only be started from mode 0, to prevent retriggering.

Exits start on level_done_mode 9.

Warps start on level_done_mode 3 to skip the delays and instantantly load the next level.
</mh3>
<pre><code class="language-cpp">void proc_exit_collision(int p, int i)
{
   if (players[0].level_done_mode == 0)
   {
	  players[0].level_done_mode = 9;
	  players[0].level_done_timer = 0;
	  next_level = play_level + 1;
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
	  players[0].level_done_mode = 3;
	  players[0].level_done_timer = 0;
      next_level = item[i][8];
   }
}
</code></pre>


<br><a name="How The Procedure Progresses"></a>
<mh7>How The Procedure Progresses</mh7>

<mh3>    
Once the procedure is started, 'level_done_mode' works its way back to 1 where the next level is loaded and finally 0 for normal game_play.


In the main game loop, if 'level_done_mode' is non-zero, 'proc_level_done_mode()' is called.

Otherwise all the objects in the game get moved.
</mh3>    

<pre><code class="language-cpp">void game_loop(int start_mode)
{
   ...
   if (players[0].level_done_mode) proc_level_done_mode();
   else move_frame();
   ...
</code></pre>
<mh3>This has the effect of freezing everything when in level done mode.



In 'proc_level_done_mode()' the timer is decremented and modes are switched until mode 1 when 'proc_start_mode(5)' is called.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   if (--players[0].level_done_timer <= 0) // time to change to next level_done_mode
   {
      players[0].level_done_mode--;
      if (players[0].level_done_mode == 8) players[0].level_done_timer = 60; // players seek exit
      if (players[0].level_done_mode == 7) players[0].level_done_timer = 20; // players shrink and rotate into exit
      if (players[0].level_done_mode == 6) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 5) players[0].level_done_timer = 600; // skippable 15s delay;
      if (players[0].level_done_mode == 4) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 3) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 2) players[0].level_done_timer = 10;  // delay to load next level
      if (players[0].level_done_mode == 1) proc_start_mode(5);
   }
}
</code></pre>


<br><a name="Mode 9 and 8 - Players Seek Exit"></a>
<mh7>Mode 9 and 8 - Players Seek Exit</mh7>


<mh3>
When the level done procedure starts, the level is frozen and all players move to the exit.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   ...
   if (players[0].level_done_mode == 9)  // set xinc and yinc for player exit home
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            // get distance between player and exit
            al_fixed dx = al_itofix(players[0].level_done_x) - players[p].PX;
            al_fixed dy = al_itofix(players[0].level_done_y) - players[p].PY;

            // get move
            players[p].xinc = al_fixdiv(dx, al_itofix(60));
            players[p].yinc = al_fixdiv(dy, al_itofix(60));

            // set left right direction
            if (players[p].xinc > al_itofix(0)) players[p].left_right = 1;
            if (players[p].xinc < al_itofix(0)) players[p].left_right = 0;
         }
   }

   if (players[0].level_done_mode == 8)
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].PX += players[p].xinc;
            players[p].PY += players[p].yinc;
         }
   }
   ...
</code></pre>



<br><a name="Mode 7 - Players Shrink and Rotate into Exit"></a>
<mh7>Mode 7 - Players Shrink and Rotate into Exit</mh7>


<mh3>
Then the players shrink and rotate into the exit.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   ...
   if (players[0].level_done_mode == 7)
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].draw_scale -= al_ftofix(0.05);
            players[p].draw_rot -= al_ftofix(8);
         }
   }
   ...
</code></pre>




<br><a name="Mode 5 - Skippable Delay"></a>
<mh7>Mode 5 - Skippable Delay</mh7>


<mh3>    
Mode 5 is a special case because it can be skipped if all players acknowledge.

When in level_done_mode, all player input is disabled, except to acknowledge.

Throughout the code, wherever there is player input there are tests like this:
</mh3>

<pre><code class="language-cpp">void proc_player_input(int ret)
{
   for (int p=0; p< NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5)) // only allow player input in these modes
            {
               set_comp_move_from_player_key_check(p);
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(frame_num, 5, p, players1[p].comp_move);
               }
            }
         }
         if (players[p].control_method == 3) server_local_control(p);
         if (players[p].control_method == 4) client_local_control(p);
         ...   

void server_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5))  // only allow player input in these modes
   {
      if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
      {
         players1[p].old_comp_move = players1[p].comp_move;
         add_game_move(frame_num, 5, p, players1[p].comp_move);
         ...

void client_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if (players1[p].old_comp_move != players1[p].comp_move)  // player's controls have changed
   {
      players1[p].old_comp_move = players1[p].comp_move;
      if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5))
      {
         Packet("cdat");
         PacketPut1ByteInt(p);
         PacketPut4ByteInt(frame_num);
         PacketPut1ByteInt(players1[p].comp_move);
         ClientSend(packetbuffer, packetsize);
         ...
</code></pre>


<mh3>    
All players inputs are entered into the server's game moves array.

However when in level_done_mode 5, the game move entered is modified to be a special 'ack' type game move.
</mh3>

<pre><code class="language-cpp">void add_game_move(int frame, int type, int data1, int data2)
{
   if ((players[0].level_done_mode == 5) && (type == 5) && (data2)) // all move type inputs are acks in this mode
   {
      if (!has_player_acknowledged(data1)) // to prevent multiple acks
      {
         game_moves[game_move_entry_pos][0] = frame;
         game_moves[game_move_entry_pos][1] = 8;
         game_moves[game_move_entry_pos][2] = data1; // player num
         game_moves[game_move_entry_pos][3] = 0;
         game_move_entry_pos++;
         ...   
</code></pre>


<mh3>
Then there is a function to check if a specific player has acknowledged:
</mh3>

<pre><code class="language-cpp">int has_player_acknowledged(int p)
{
   int start_pos = game_move_entry_pos;
   int end_pos = start_pos - 1000;
   if (end_pos < 0) end_pos = 0;
   for (int x=start_pos; x>end_pos; x--) // look back for ack
      if ((game_moves[x][1] == 8) && (game_moves[x][2] == p)) return 1;
   return 0;
}
</code></pre>

<mh3>
And a function to check if all active players have acknowledged:
</mh3>
<pre><code class="language-cpp">int have_all_players_acknowledged(void)
{
   for (int p=0; p< NUM_PLAYERS; p++)
      if ((players[p].active) && (!has_player_acknowledged(p))) return 0;
   return 1;
}
</code></pre>


<mh3>
In 'proc_level_done_mode()' if all players have acknowledged, the timer for mode 5 is set to 0 to immediately skip the delay
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   ...
   if (!ima_client)
   {
      if (players[0].level_done_mode == 5)
      {
         if (have_all_players_acknowledged()) players[0].level_done_timer = 0; // skip

         for (int p=0; p< NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }
      }
   }
</code></pre>


<mh3>Also each player is individually checked for acknowledge and the variable 'level_done_ack' is set in the player struct.

This is synced back to the clients as part of the player struct, as only the server controls who has acked.

It is used to display which players have acknowledged in the level done stats.

</mh3>

<pre><code class="language-cpp">void show_player_stat_box(int tx, int y, int p)
{
   ...
   if (players[0].level_done_mode == 5)
   {
      if (!players[p].level_done_ack)
      {
         c = flash_color;
         int pay = 16;
         al_draw_textf(font, palette_color[c], tx+158, y+pay, 0, "press");
         al_draw_textf(font, palette_color[c], tx+158, y+pay+8, 0, " any");
         int tl = players[0].level_done_timer/40;
         if (tl > 9) al_draw_textf(font, palette_color[c], tx+154, y+pay+18, 0, "  %2d", tl);
         else        al_draw_textf(font, palette_color[c], tx+158, y+pay+18, 0, "  %d", tl);
      }
      else al_draw_textf(font, palette_color[15], tx+158, y+20, 0, "ready");
   }
</code></pre>


<mh3>
If the player has not acknowledged it looks like this with the timer counting down:

</mh3>


<img src="images/ld_stat_not_ack.png" alt="flags" width="403" height="103">


<mh3>
If the player has acknowledged it looks like this:

</mh3>


<img src="images/ld_stat_ack.png" alt="flags" width="401" height="102">



<mh3>
Once all players have acknowledged or timed out we progress to the next level_done_mode.
</mh3>






<br><a name="Mode 2 - Delay to Load Next Level"></a>
<mh7>Mode 2 - Delay to Load Next Level</mh7>


<mh3>
Now we are done with the delays and end of level statistics and we are ready to load the next level.
(If we got here by touching a warp instead of an exit, all the previous modes will have been skipped.)

The server cannot just immediately load a new level, the clients will be stuck on the old level and timeout.

So we set a timer for 10 frames in the future when the new level loading will take effect.

This is enough time for the data to propogate to the client, so they can load the new level also and follow the server.

</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   if (--players[0].level_done_timer <= 0) // time to change to next level_done_mode
   {
      players[0].level_done_mode--;
      if (players[0].level_done_mode == 8) players[0].level_done_timer = 60; // players seek exit
      if (players[0].level_done_mode == 7) players[0].level_done_timer = 20; // players shrink and rotate into exit
      if (players[0].level_done_mode == 6) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 5) players[0].level_done_timer = 600; // skippable 15s delay;
      if (players[0].level_done_mode == 4) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 3) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 2) players[0].level_done_timer = 10;  // delay to load next level
      if (players[0].level_done_mode == 1) proc_start_mode(5);
   }
}
</code></pre>




<br><a name="Mode 1 - Call to proc_start_mode(5)"></a>
<mh7>Mode 1 - Call to proc_start_mode(5)</mh7>




<mh3>
In 'proc_start_mode(5)' we do all the cleanup, resetting, loading and preparing for the next level.
</mh3>


<pre><code class="language-cpp">// start modes:
// 1 single player new game
// 2 server new game
// 3 client new game
// 5 level done
// 7 resume single player
// 9 run demo mode
void proc_start_mode(int start_mode)
{
   if (start_mode == 5)
   {
      players[0].level_done_mode = 0;
      if (players[active_local_player].control_method == 1) // run demo mode saved game file
      {
         al_rest(1);
         game_exit = 1;// run game file play exits after level done
         return; // to exit immediately
      }

      if (ima_server) server_flush();
      if (ima_client) client_flush();

      blind_save_game_moves(1);
      save_log_file();
      play_level = next_level;
   }

   // clear game moves array, except demo
   if  (start_mode != 9) clear_game_moves();
   

   if ( (start_mode == 1) || (start_mode == 2) || (start_mode == 5))
   {
      add_game_move(0, 0, play_level, 0);       // [00] game_start
      add_game_move(0, 1, 0, players[0].color); // [01] player_state and color
   }

   if (!load_level(play_level, 0))
   {
      game_exit = 1;
      return;
   }
   set_frame_nums(0);
   reset_states();
   if (start_mode == 5) // start new level after level done
   {
      for (int p=0; p< NUM_PLAYERS; p++)
      {
         init_player(p, 2);
		 set_player_start_pos(p, 0); // get starting position for all players, active or not
      }
   }
   clear_bmsg();
   clear_bullets();
   clear_keys();
   clear_pm_events();
}
</code></pre>



               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2022, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
