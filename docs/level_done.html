<!doctype html>
<title>Level Done</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div></mdw_lhs_nav>
            
        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>
<mh3><hr></mh3>
<mh8>Level Done Procedure</mh8>
<mh3><hr><mdw_file_toc> <a href="level_done.html#Overview"              target="_top">Overview</a>
 <a href="level_done.html#Variables"                                    target="_top">Variables</a>
 <a href="level_done.html#Modes"                                        target="_top">Modes</a>
 <a href="level_done.html#How The Procedure Is Initiated"               target="_top">How The Procedure Is Initiated</a>
 <a href="level_done.html#How The Procedure Progresses"                 target="_top">How The Procedure Progresses</a>
 <a href="level_done.html#Mode 9 and 8 - Players Seek Exit"             target="_top">Mode 9 and 8 - Players Seek Exit</a>
 <a href="level_done.html#Mode 7 - Players Shrink and Rotate into Exit" target="_top">Mode 7 - Players Shrink and Rotate into Exit</a>
 <a href="level_done.html#Mode 5 - Skippable Delay"                     target="_top">Mode 5 - Skippable Delay</a>
 <a href="level_done.html#Mode 2 - Delay to Load Next Level"            target="_top">Mode 2 - Delay to Load Next Level</a>
 <a href="level_done.html#Mode 1 - Load and start next level"           target="_top">Mode 1 - Load and start next level</a>
 <a href="level_done.html#Conclusion and Notes"                         target="_top">Conclusion and Notes</a>
</mdw_file_toc><hr></mh3>



<br><a name="Overview"></a>
<mh7>Overview</mh7>
<mh3>    
A level is completed when any player touches an unlocked exit or a warp spiral.

The level is frozen and the end of level stats are shown.

Then after a timeout, or after all players acknowledge, the next level is loaded and started.

The server controls the process using the following variables, which are synced to the clients with the rest of the game data.
</mh3>
<br><a name="Variables"></a>
<mh7>Variables</mh7>
<mh3>
These are the variables used in the process:
</mh3>
<pre><code class="language-cpp">int players[0].level_done_mode
int players[0].level_done_timer
int players[p].level_done_ack
int players[p].level_done_x
int players[p].level_done_y
int players[p].level_done_player
</code></pre>
<mh3>'mode' is the current mode

'timer' controls the length of time before switching to the next mode

'ack' keeps track of which players have acknowledged

'x' and 'y' keep track of the exit position on the level

'player' keeps track of which player touched the exit
</mh3>
<br><a name="Modes"></a>
<mh7>Modes</mh7>

<mh3>
These are the different modes:
</mh3>
<pre><code class="language-cpp">level_done_mode = 9; // set up players seek xinc, yinc and direction
level_done_mode = 8; // all players move to the exit
level_done_mode = 7; // all players rotate and shirink into the exit
level_done_mode = 6; // not used, place holder for future features
level_done_mode = 5; // skippable 15s delay while level end stats show
level_done_mode = 4; // not used, place holder for future features
level_done_mode = 3; // not used, place holder for future features
level_done_mode = 2; // delay to load next level
level_done_mode = 1; // call proc_next_level() to load next level
level_done_mode = 0; // normal game play
</code></pre>


<br><a name="How The Procedure Is Initiated"></a>
<mh7>How The Procedure Is Initiated</mh7>
<mh3>    
The procedure is initiated by setting 'level_done_mode'.

It can only be started from mode 0, to prevent retriggering.

'Exits' start on mode 9.

'Warps' start on mode 3 to skip the delays and instantly load the next level.
</mh3>
<pre><code class="language-cpp">void proc_exit_collision(int p, int i)
{
   if (players[0].level_done_mode == 0)
   {
	  players[0].level_done_mode = 9;
	  players[0].level_done_timer = 0;
      players[0].level_done_x = al_fixtoi(itemf[i][0]);
      players[0].level_done_y = al_fixtoi(itemf[i][1]);
      players[0].level_done_player = p;
	  next_level = play_level + 1;
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
	  players[0].level_done_mode = 3;
	  players[0].level_done_timer = 0;
      players[0].level_done_x = al_fixtoi(itemf[i][0]);
      players[0].level_done_y = al_fixtoi(itemf[i][1]);
      players[0].level_done_player = p;
      next_level = item[i][8];
   }
}
</code></pre>


<br><a name="How The Procedure Progresses"></a>
<mh7>How The Procedure Progresses</mh7>

<mh3>    
Once the procedure is started, 'level_done_mode' works its way back to 1 where the next level is loaded and finally 0 for normal game_play.


In the main game loop, if 'level_done_mode' is non-zero, 'proc_level_done_mode()' is called.

Otherwise all the objects in the game get moved.
</mh3>    

<pre><code class="language-cpp">void game_loop(int start_mode)
{
   ...
   if (players[0].level_done_mode) process_level_done_mode();
   else move_frame();
   ...
</code></pre>
<mh3>This has the effect of freezing everything when in level done mode.



In 'process_level_done_mode()' the timer is decremented and modes are switched until mode 1 when program_state=12 is set to load the next level.
</mh3>

<pre><code class="language-cpp">void process_level_done_mode(void)
{
   if (--players[0].level_done_timer <= 0) // time to change to next level_done_mode
   {
      players[0].level_done_mode--;
      if (players[0].level_done_mode == 8) players[0].level_done_timer = 60; // players seek exit
      if (players[0].level_done_mode == 7) players[0].level_done_timer = 20; // players shrink and rotate into exit
      if (players[0].level_done_mode == 6) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 5) players[0].level_done_timer = 600; // skippable 15s delay;
      if (players[0].level_done_mode == 4) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 3) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 2) players[0].level_done_timer = 10;  // delay to load next level
      if (players[0].level_done_mode == 1) program_state = 12;                // load new level
   }
}
</code></pre>


<br><a name="Mode 9 and 8 - Players Seek Exit"></a>
<mh7>Mode 9 and 8 - Players Seek Exit</mh7>


<mh3>
When the level done procedure starts, the level is frozen and all players move to the exit.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   ...
   if (players[0].level_done_mode == 9)  // set xinc and yinc for player exit home
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            // get distance between player and exit
            al_fixed dx = al_itofix(players[0].level_done_x) - players[p].PX;
            al_fixed dy = al_itofix(players[0].level_done_y) - players[p].PY;

            // get move
            players[p].xinc = al_fixdiv(dx, al_itofix(60));
            players[p].yinc = al_fixdiv(dy, al_itofix(60));

            // set left right direction
            if (players[p].xinc > al_itofix(0)) players[p].left_right = 1;
            if (players[p].xinc < al_itofix(0)) players[p].left_right = 0;
         }
   }

   if (players[0].level_done_mode == 8)
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].PX += players[p].xinc;
            players[p].PY += players[p].yinc;
         }
   }
   ...
</code></pre>



<br><a name="Mode 7 - Players Shrink and Rotate into Exit"></a>
<mh7>Mode 7 - Players Shrink and Rotate into Exit</mh7>


<mh3>
Then the players shrink and rotate into the exit.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   ...
   if (players[0].level_done_mode == 7)
   {
      for (int p=0; p< NUM_PLAYERS; p++)
         if (players[p].active)
         {
            players[p].draw_scale -= al_ftofix(0.05);
            players[p].draw_rot -= al_ftofix(8);
         }
   }
   ...
</code></pre>




<br><a name="Mode 5 - Skippable Delay"></a>
<mh7>Mode 5 - Skippable Delay</mh7>


<mh3>    
Mode 5 is a special case because it can be skipped if all players acknowledge.

When in level_done_mode, all player input is disabled, except to acknowledge.

Here is the test in 'proc_player_input()' to only allow input in level_done_modes 0 and 5.
</mh3>

<pre><code class="language-cpp">void proc_player_input(void)
{
   for (int p=0; p< NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
         if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 5)) // only allow player input in these modes
...
</code></pre>


<mh3>    
All players inputs are entered into the game_moves array.

However when in level_done_mode 5, the game move entered is modified to be a special 'ack' type game move.
</mh3>

<pre><code class="language-cpp">void add_game_move(int frame, int type, int data1, int data2)
{
   if ((players[0].level_done_mode == 5) && (type == 5) && (data2)) // all move type inputs are acks in this mode
   {
      if (!has_player_acknowledged(data1)) // to prevent multiple acks
      {
         game_moves[game_move_entry_pos][0] = frame;
         game_moves[game_move_entry_pos][1] = 8;
         game_moves[game_move_entry_pos][2] = data1; // player num
         game_moves[game_move_entry_pos][3] = 0;
         game_move_entry_pos++;
         ...   
</code></pre>


<mh3>
Then there is a function to check if a specific player has acknowledged:
</mh3>

<pre><code class="language-cpp">int has_player_acknowledged(int p)
{
   int start_pos = game_move_entry_pos;
   int end_pos = start_pos - 1000;
   if (end_pos < 0) end_pos = 0;
   for (int x=start_pos; x>end_pos; x--) // look back for ack
      if ((game_moves[x][1] == 8) && (game_moves[x][2] == p)) return 1;
   return 0;
}
</code></pre>

<mh3>
And a function to check if all active players have acknowledged:
</mh3>
<pre><code class="language-cpp">int have_all_players_acknowledged(void)
{
   for (int p=0; p< NUM_PLAYERS; p++)
      if ((players[p].active) && (!has_player_acknowledged(p))) return 0;
   return 1;
}
</code></pre>


<mh3>
In 'process_level_done_mode()' in mode 5, if all players have acknowledged, the timer is set to 0 to immediately skip the delay

This is only done on the server, and then synced back to clients as part of the player struct.
</mh3>

<pre><code class="language-cpp">void process_level_done_mode(void)
{
   if (players[0].level_done_mode == 5) // level done 5 - skippable 15s timeout
   {
      if (!ima_client)
      {
         if (have_all_players_acknowledged()) players[0].level_done_timer = 0; // skip
         for (int p=0; p< NUM_PLAYERS; p++)
            if (players[p].active)
            {
               if (has_player_acknowledged(p)) players[p].level_done_ack = 1;
               else players[p].level_done_ack = 0;
            }
      }
   }
}
</code></pre>


<mh3>Also each player is individually checked for acknowledge and the variable 'level_done_ack' is set in the player struct.

This is used to display which players have acknowledged in the level done stats.
</mh3>

<pre><code class="language-cpp">void show_player_stat_box(int tx, int y, int p)
{
   ...
   if (players[0].level_done_mode == 5)
   {
      if (!players[p].level_done_ack)
      {
         c = flash_color;
         int pay = 16;
         al_draw_textf(font, palette_color[c], tx+158, y+pay, 0, "press");
         al_draw_textf(font, palette_color[c], tx+158, y+pay+8, 0, " any");
         int tl = players[0].level_done_timer/40;
         if (tl > 9) al_draw_textf(font, palette_color[c], tx+154, y+pay+18, 0, "  %2d", tl);
         else        al_draw_textf(font, palette_color[c], tx+158, y+pay+18, 0, "  %d", tl);
      }
      else al_draw_textf(font, palette_color[15], tx+158, y+20, 0, "ready");
   }
</code></pre>


<mh3>
If the player has not acknowledged it looks like this with the timer counting down:

</mh3>


<img src="images/ld_stat_not_ack.png" alt="flags" width="403" height="103">


<mh3>
If the player has acknowledged it looks like this:

</mh3>


<img src="images/ld_stat_ack.png" alt="flags" width="401" height="102">



<mh3>
Once all players have acknowledged or timed out we progress to the next level_done_mode.
</mh3>






<br><a name="Mode 2 - Delay to Load Next Level"></a>
<mh7>Mode 2 - Delay to Load Next Level</mh7>


<mh3>
Now we are done with the delays and end of level statistics and we are ready to load the next level.
(If we got here by touching a warp instead of an exit, all the previous modes will have been skipped.)

The server cannot just immediately load a new level, the clients will be stuck on the old level and timeout.

So we set a timer for 10 frames in the future when the new level loading will take effect.

This is enough time for the data to propogate to the client, so they can load the new level also and follow the server.
</mh3>

<pre><code class="language-cpp">void process_level_done_mode(void)
{
   if (--players[0].level_done_timer <= 0) // time to change to next level_done_mode
   {
      players[0].level_done_mode--;
      if (players[0].level_done_mode == 8) players[0].level_done_timer = 60; // players seek exit
      if (players[0].level_done_mode == 7) players[0].level_done_timer = 20; // players shrink and rotate into exit
      if (players[0].level_done_mode == 6) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 5) players[0].level_done_timer = 600; // skippable 15s delay;
      if (players[0].level_done_mode == 4) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 3) players[0].level_done_timer = 0;
      if (players[0].level_done_mode == 2) players[0].level_done_timer = 10;  // delay to load next level
      if (players[0].level_done_mode == 1) program_state = 12;                // load new level
   }
}
</code></pre>




<br><a name="Mode 1 - Load and start next level"></a>
<mh7>Mode 1 - Load and start next level</mh7>




<mh3>
In 'program_state == 12'  we do all the cleanup, resetting, loading and preparing for the next level.
</mh3>

<pre><code class="language-cpp">if (program_state == 12)
{
   players[0].level_done_mode = 0;
   play_level = next_level;
   load_level(play_level, 0);

   for (int p=0; p< NUM_PLAYERS; p++) // reset players
   {
      init_player(p, 2);            // next level reset
      set_player_start_pos(p, 0);   // get starting position for all players, active or not
   }

   clear_game_moves();
   set_frame_nums(0);
   reset_states();
   clear_bullets();
   clear_bmsg();
   clear_keys();
   clear_pm_events();

   program_state = 11; // the main game loop
}
</code></pre>

<br><a name="Conclusion and Notes"></a>
<mh7>Conclusion and Notes</mh7>

<mh3>
This entire process may seem overly complicated. I have tried to simplify it in as many ways as I can.

I once spent an entire day refactoring the entire procedure and it looked great and was slightly simpler. But it did not work for netgame.

It is very complicated to get this procedure to work with client and server, when either one can rewind and replay frames in order to make the muliplayer work nicely.

As I slowly changed pieces of simpler system, it got more complex, until it was essentially the same algorithm.
Only I had lost an entire day chasing bugs banging my head against the wall, untill I realized why I did it this way in the first place.

There is one more bit of code.
When the client or server has to rewind a few frames and replay, the level_done procedure has to be replayed also.
Here is what that looks like:

</mh3>

<pre><code class="language-cpp">void move_frame(void)
{
   move_ebullets();
   move_pbullets();
   move_lifts(0);
   move_players();
   move_enemies();
   move_items();
}

void loop_frame(int times) // used for fast forwarding after rewind
{
   for (int i=0; i< times; i++)
   {
      proc_game_moves_array();
      if (players[0].level_done_mode) process_level_done_mode();
      else move_frame();
      frame_num++;
   }
}

</code></pre>


               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2022, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
