<!doctype html>
<title>Level Done</title>

<html>

    <script src="prism.js"></script>
    <link href = "themes/prism.css" rel="stylesheet" />
    <link href = "css/mdw.css"      rel="stylesheet" type = "text/css" />

    
    <body>

        <nav class="col-1">

<mdw_lhs_nav><div style="text-align: center;">Navigation</div><hr>    
<div style="text-align: center;"><a href="index.html" target="_top">Home</a></div>    
<div style="text-align: center;"><a href="index.html#Description" target="_top">Description</a></div>    
<div style="text-align: center;"><a href="index.html#Demo Video" target="_top">Demo Video</a></div>    
<div style="text-align: center;"><a href="index.html#Features" target="_top">Features</a></div>    
<div style="text-align: center;"><a href="index.html#Created by" target="_top">Created by</a></div>    
<div style="text-align: center;"><a href="index.html#Created with" target="_top">Created with</a></div>    
<div style="text-align: center;"><a href="index.html#License" target="_top">License</a></div>    
<div style="text-align: center;"><a href="index.html#Supported Systems" target="_top">Supported Systems</a></div>    
<div style="text-align: center;"><a href="index.html#External Links" target="_top">External Links</a></div>    
<div style="text-align: center;"><a href="index.html#Older Versions" target="_top">Older Versions</a></div>    
<div style="text-align: center;"><a href="index.html#History" target="_top">History</a></div>    

<br><div style="text-align: center;">Technical Descriptions</div><hr>    
<div style="text-align: center;"><a href="project_organization.html" target="_top">Project Organization</a></div>    
<div style="text-align: center;"><a href="logo.html" target="_top">Logo</a></div>    
<div style="text-align: center;"><a href="timers.html" target="_top">Timers</a></div>    
<div style="text-align: center;"><a href="events.html" target="_top">Events</a></div>    
<div style="text-align: center;"><a href="input.html" target="_top">Input</a></div>    
<div style="text-align: center;"><a href="level_done.html" target="_top">Level Done</a></div>    
<div style="text-align: center;"><a href="game_moves_array.html" target="_top">Game Moves Array</a></div>    
<div style="text-align: center;"><a href="sound.html" target="_top">Sound</a></div>    
<div style="text-align: center;"><a href="display.html" target="_top">Display</a></div>    
<div style="text-align: center;"><a href="tiles.html" target="_top">Tiles</a></div>    
<div style="text-align: center;"><a href="block_flags.html" target="_top">Block Flags</a></div>    
<div style="text-align: center;"><a href="bullets.html" target="_top">Bullets</a></div>    
<div style="text-align: center;"><a href="level_array.html" target="_top">Level Array</a></div>    
<div style="text-align: center;"><a href="netgame_main.html" target="_top">Netgame - Main</a></div>    
<div style="text-align: center;"><a href="netgame_state.html" target="_top">Netgame - State</a></div>    
<div style="text-align: center;"><a href="netgame_join.html" target="_top">Netgame - Join</a></div>    
<div style="text-align: center;"><a href="netgame_status.html" target="_top">Netgame - Status</a></div>    
<div style="text-align: center;"><a href="netgame_config.html" target="_top">Netgame - Config</a></div>    
<div style="text-align: center;"><a href="netgame_packets.html" target="_top">Netgame - Packets</a></div></mdw_lhs_nav>
            
        </nav>

        
        <div class="col-2">

            <header>
                <mh11>Purple Martians</mh11><hr>
                <mh12>Technical Code Descriptions</mh12><hr>
            </header>
<mh3><hr></mh3>
<mh8>Level Done Procedure</mh8>
<mh3><hr><mdw_file_toc> <a href="level_done.html#Overview" target="_top">Overview</a>
 <a href="level_done.html#Variables" target="_top">Variable</a>
 <a href="level_done.html#Modes" target="_top">Modes</a>
 <a href="level_done.html#How The Procedure Is Initiated" target="_top">How The Procedure Is Initiated</a>
 <a href="level_done.html#How The Procedure Progresses" target="_top">How The Procedure Progresses</a>
 <a href="level_done.html#Mode 6" target="_top">Mode 6</a>
 <a href="level_done.html#Mode 5" target="_top">Mode 5</a>
</mdw_file_toc><hr></mh3>








<br><a name="Overview"></a>
<mh7>Overview</mh7>
<mh3>    
A level is completed when any player touches an unlocked exit or a warp spiral.

The level is frozen and the end of level stats are shown.

Then after a timeout, or after all players acknowledge, the next level is loaded and started.

The server controls the entire process by setting the following variables, which are automatically synced to the clients with the rest of the game data.
</mh3>
<br><a name="Variables"></a>
<mh7>Variables</mh7>
<mh3>
These are the variables used in the process:
</mh3>
<pre><code class="language-cpp">int players[0].level_done_mode
int players[0].level_done_timer
int players[p].level_done_ack
</code></pre>
<mh3>'mode' is the current mode

'timer' controls the length of time before switching to the next mode

'ack' keeps track of which players have acknowledged
</mh3>
<br><a name="Modes"></a>
<mh7>Modes</mh7>

<mh3>
These are the different modes:
</mh3>
<pre><code class="language-cpp">players[0].level_done_mode = 0; // normal game play
players[0].level_done_mode = 9; // exit touched
players[0].level_done_mode = 8; // 2s unskippable delay
players[0].level_done_mode = 7; // 10s skippable delay
players[0].level_done_mode = 6; // both delays done, start load new level countdown
players[0].level_done_mode = 5; // load new level
</code></pre>


<br><a name="How The Procedure Is Initiated"></a>
<mh7>How The Procedure Is Initiated</mh7>
<mh3>    
The level done procedure is initiated by setting level_done_mode.

Exits start on mode 9 and warps start on mode 7.

This is because warps are instantaneous and skip the delays of exits.

</mh3>
<pre><code class="language-cpp">void proc_exit_collision(int p, int i)
{
   if (players[0].level_done_mode == 0)
   {
	  players[0].level_done_mode = 9;
	  players[0].level_done_timer = 0;
	  next_level = play_level + 1;
   }
}

void proc_warp_collision(int p, int i)
{
   if (level_done_mode == 0)
   {
	  players[0].level_done_mode = 7;
	  players[0].level_done_timer = 0;
      next_level = item[i][8];
   }
}
</code></pre>


<br><a name="How The Procedure Progresses"></a>
<mh7>How The Procedure Progresses</mh7>

<mh3>    
In the main game loop, if level_done_mode is non-zero,  'proc_level_done_mode()' is called.

Otherwise all the objects in the game get moved.

This has the effect of freezing everything when in level done mode.

</mh3>    

<pre><code class="language-cpp">void game_loop(int start_mode)
{
   ...
   if (players[0].level_done_mode) proc_level_done_mode();
   else move_frame();
   ...
</code></pre>







<mh3>    
In 'proc_level_done_mode()' the timer is decremented and modes are switched until mode 5 when 'proc_next_level()' is called.
</mh3>

<pre><code class="language-cpp">void proc_level_done_mode(void)
{
   if (--players[0].level_done_timer <= 0) // time to change to next level_done_mode
   {
      players[0].level_done_mode--;
      if (players[0].level_done_mode == 8) players[0].level_done_timer = 80;  // unskippable 2s delay
      if (players[0].level_done_mode == 7) players[0].level_done_timer = 600; // skippable 15s delay
      if (players[0].level_done_mode == 6) players[0].level_done_timer = 10;  // delay to load next level
      if (players[0].level_done_mode == 5) proc_next_level();
   }
}
</code></pre>


<mh3>    
Mode 7 is a special case because it can be skipped if all players acknowledge.

When in level_done_mode, all player input is disabled, except to acknowledge.

Through the code, wherever there is player input there is a test like this:

</mh3>





<pre><code class="language-cpp">void proc_player_input(int ret)
{
   for (int p=0; p< NUM_PLAYERS; p++)
      if (players[p].active) // cycle all active players
      {
         if (players[p].control_method == 0) // local single player control
         {
            if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 7)) // only allow player input in these modes
            {
               set_comp_move_from_player_key_check(p);
               if (players1[p].comp_move != players1[p].old_comp_move)
               {
                  players1[p].old_comp_move = players1[p].comp_move;
                  add_game_move(frame_num, 5, p, players1[p].comp_move);
               }
            }
         }
         if (players[p].control_method == 3) server_local_control(p);
         if (players[p].control_method == 4) client_local_control(p);
         ...   

void server_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 7))  // only allow player input in these modes
   {
      if (players1[p].comp_move != players1[p].old_comp_move) // players controls have changed
      {
         players1[p].old_comp_move = players1[p].comp_move;
         add_game_move(frame_num, 5, p, players1[p].comp_move);
         ...

void client_local_control(int p)
{
   set_comp_move_from_player_key_check(p);
   if (players1[p].old_comp_move != players1[p].comp_move)  // player's controls have changed
   {
      players1[p].old_comp_move = players1[p].comp_move;
      if ((players[0].level_done_mode == 0) || (players[0].level_done_mode == 7))
      {
         Packet("cdat");
         PacketPut1ByteInt(p);
         PacketPut4ByteInt(frame_num);
         PacketPut1ByteInt(players1[p].comp_move);
         ClientSend(packetbuffer, packetsize);
         ...
</code></pre>


<mh3>    
Clients send input to the server where it is entered into the game moves array, just like in server and single player mode.

However when it level_done_mode the game move enetered is modified to be a special move type 8

</mh3>



<mh3>
These are the special game moves used: 
</mh3>

<pre><code class="language-cpp">void add_game_move(int frame, int type, int data1, int data2)
{
   if ((players[0].level_done_mode == 7) && (type == 5) && (data2)) // all move type inputs are acks in this mode
   {
      if (!has_player_acknowledged(data1)) // to prevent multiple acks
      {
         game_moves[game_move_entry_pos][0] = frame;
         game_moves[game_move_entry_pos][1] = 8;
         game_moves[game_move_entry_pos][2] = data1; // player num
         game_moves[game_move_entry_pos][3] = 0;
         game_move_entry_pos++;
         ...   
</code></pre>




<mh3>
These are the special game moves used: 
</mh3>

<pre><code class="language-cpp">type data1 data2 description
8    p     0     "Player Acknowledge"
</code></pre>


int has_player_acknowledged(int p)
{
   for (int x=game_move_entry_pos; x>0; x--)  // look back for frame_num
      if ((game_moves[x][1] == 8) && (game_moves[x][2] == p)) return 1;
   return 0;
}
</code></pre>


<mh3>    
Then when the "Next Level" game move is processed:

- a bunch of cleanup and resetting of varous settings is done

- proc_start_mode(5) is called to load the new level and set up structures after loading a new level

- level_done_mode is set to 0
</mh3>    


<pre><code class="language-cpp">void proc_game_move(void)
{
   case 7: proc_next_level(); break;

void proc_next_level(void)
{
   if ((ima_client) || (ima_server))
   {
      for (int p=0; p < NUM_PLAYERS; p++)
         if (players[p].active) players1[p].quit_reason = 80;
   }

   stop_sound();
   int p = active_local_player;
   if (players[p].control_method == 1)
   {
      show_level_done(0);
      al_rest(1);
      game_exit = 1;// run game file play exits after level done
      return;
   }
   if ((ima_server) || (ima_client))
   {
      for (int p=0; p < NUM_PLAYERS; p++)
      {
         // free all the used clients, so they can be re-assigned on the next level
         if (players[p].control_method == 9) players[p].control_method = 0;
         // set all clients inactive on server and client, to force them to re-chase and lock on the new level
         if ((players[p].control_method == 2) || (players[p].control_method == 4)) players[p].active = 0;
      }
      if (ima_server) server_flush();
      if (ima_client) client_flush();
      al_rest(1);
   }
   blind_save_game_moves(1);
   save_log_file();
   play_level = next_level;
   proc_start_mode(5);
   level_done_mode = 0;
}
</code></pre>


               <footer>                <mh11>Purple Martians</mh11><hr>
                <div id="copyright">
                Copyright &copy; 2022, by <a href="mailto:mweiss001@gmail.com"> Michael David Weiss</a>
                </div>
</footer>

        </div>
    </body>

</html>
